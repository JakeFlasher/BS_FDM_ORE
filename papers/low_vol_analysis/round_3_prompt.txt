<system_context>
You are an expert C++ developer implementing two positivity-preserving finite
difference schemes from Milev & Tagliani (2010) into QuantLib v1.23's modern
Fdm* framework. The schemes address spurious oscillations and negative prices
that standard Crank‚ÄìNicolson produces when œÉ¬≤ ‚â™ r and payoffs are discontinuous.

PAPER REFERENCE (corrected formulations):
Scheme 1: Fully implicit with Duffy's exponentially fitted diffusion coefficient.
Scheme 2: Crank‚ÄìNicolson variant with a modified 6-node reaction-term stencil.
Both are described in the GOLDEN REFERENCE DOCUMENT (Round 1.5 output), whose
corrected equation chain (CE-1 through CE-25) is authoritative.

SOURCE-OF-TRUTH / NO-HALLUCINATION RULES (mandatory):
- Use ONLY the provided source files and prior-round outputs as factual reference
  for class/method signatures, include paths, base-class requirements, and
  coding conventions.
- If any referenced file content is missing (i.e., an [INSERT FULL CONTENT ...]
  placeholder is not filled), DO NOT guess or reconstruct.
  STOP and ask the user to provide the missing file(s).
- If a requirement is ambiguous, search the provided files for the relevant
  implementation detail and implement the behavior that matches the source.
  If still ambiguous, STOP and ask a precise clarification question.

INTERNAL VERIFICATION PROTOCOL (mandatory; do before coding; do not print):
- Verify what the 1D BS mesher stores as spatial coordinate x (ln(S), ln(S/K),
  or other) by reading FdmBlackScholesMesher and FdmBlackScholesOp.
- Verify how FirstDerivativeOp / SecondDerivativeOp incorporate nonuniform mesh
  spacing (which mesher spacing functions they use).
- Verify the TripleBandLinearOp sign conventions: which off-diagonal coefficients
  must be nonneg for the system matrix (I ‚àí Œ∏¬∑dt¬∑L) to be an M-matrix.
- Verify how FiniteDifferenceModel handles StepCondition::applyTo (every step
  vs stopping times, and whether at the initial 'from' time).

CODING CONVENTIONS (mandatory):
- Namespace: all classes in `namespace QuantLib { }`
- Smart pointers: use `ext::shared_ptr`, NOT `std::shared_ptr`
- Return arrays: use `Array`; if similar methods return `Disposable<Array>`, match
- Assertions: `QL_REQUIRE(condition, message)` for preconditions,
  `QL_ENSURE(condition, message)` for postconditions
- Include guards: `#ifndef quantlib_<path_underscored>_hpp`
- Copyright header: match the style of adjacent files in the same directory
- Includes: use angle brackets `<ql/...>` for QuantLib headers
- No `using namespace std;` in headers
- Naming: `camelCase` for methods, `camelCase_` for private members,
  `CamelCase` for classes

OUTPUT RULES:
- Produce COMPLETE files, never diffs or partial snippets
- Only output files that are new or modified in this round
- Each file must compile against unmodified QuantLib v1.23 headers plus any
  files produced in prior rounds
- Include all necessary #include directives
</system_context>

<mathematical_context>
PAPER'S ORIGINAL PDE (S-space, time-to-expiry œÑ; CE-1):
  ‚àí‚àÇV/‚àÇœÑ + rS¬∑‚àÇV/‚àÇS + ¬ΩœÉ¬≤S¬≤¬∑‚àÇ¬≤V/‚àÇS¬≤ ‚àí rV = 0

QUANTLIB LOG-SPACE PDE (x = ln(S), backward time œÑ):
  ‚àíu_œÑ + b¬∑u_x + a¬∑u_xx ‚àí r¬∑u = 0
  where a = œÉ¬≤/2,  b = (r ‚àí q) ‚àí œÉ¬≤/2

‚ïê‚ïê‚ïê SCHEME 1: EXPONENTIALLY FITTED OPERATOR (CE-7 through CE-15) ‚ïê‚ïê‚ïê

In log-space, the P√©clet parameter and fitting factor at interior node j are:
  Œ∏_j = b ¬∑ h_j / (2¬∑a)                   (local P√©clet)
  œÅ_j = Œ∏_j ¬∑ coth(Œ∏_j)                   (fitting factor; œÅ ‚Üí 1+Œ∏¬≤/3 for |Œ∏|<1e-8)

Fitted stencil (replacing the standard centered operator):
  ‚Ñì_j = a¬∑œÅ_j/h¬≤ ‚àí b/(2h)     (lower off-diagonal; GUARANTEED ‚â• 0)
  d_j = ‚àí2¬∑a¬∑œÅ_j/h¬≤ ‚àí r        (main diagonal)
  u_j = a¬∑œÅ_j/h¬≤ + b/(2h)     (upper off-diagonal; GUARANTEED ‚â• 0)

PROOF OF NON-NEGATIVITY (critical for M-matrix):
  ‚Ñì_j = (b/(2h))¬∑(coth(Œ∏) ‚àí 1) ‚â• 0  for all Œ∏ (b>0 ‚üπ coth>1; b<0 ‚üπ both negative)
  u_j = (b/(2h))¬∑(coth(Œ∏) + 1) ‚â• 0  for all Œ∏ (same sign argument)

This GUARANTEES the system matrix (I ‚àí Œ∏¬∑dt¬∑L) is an M-matrix for any h, dt.

Artificial diffusion (CE-15, low-œÉ limit): ¬Ω¬∑r¬∑S¬∑ŒîS¬∑V_SS in S-space,
equivalently ¬Ω¬∑|b|¬∑h¬∑u_xx in log-space when |Œ∏| ‚â´ 1.

NONUNIFORM GRID NOTE: For non-uniform meshes, compute a per-node effective
spacing consistent with QuantLib's derivative operators:
  h_j := 0.5*(dplus_j + dminus_j)

‚ïê‚ïê‚ïê SCHEME 2: CN VARIANT WITH MODIFIED REACTION TERM (CE-16 through CE-23) ‚ïê‚ïê‚ïê

The standard ‚àír¬∑u_j is replaced by the 6-node stencil:
  ‚àír¬∑[œâ¬∑u_{j‚àí1} + (1‚àí2œâ)¬∑u_j + œâ¬∑u_{j+1}]

at each time level, with œâ‚ÇÅ = œâ‚ÇÇ = œâ (symmetric weighting).

In log-space, this adds off-diagonal reaction contributions to the operator:
  ‚Ñì'_j = a/h¬≤ ‚àí b/(2h) ‚àí rœâ   (modified lower)
  d'_j = ‚àí2a/h¬≤ ‚àí r(1‚àí2œâ)     (modified diagonal)
  u'_j = a/h¬≤ + b/(2h) ‚àí rœâ   (modified upper)

PARAMETER CHOICE (CE-19, adapted to log-space):
  S-space optimal: œâ = ‚àír/(16œÉ¬≤)   (from completing-the-square in S_j)
  Log-space: since coefficients are constant, œâ must satisfy:
    ‚Ñì'_j ‚â• 0  ‚üπ  œâ ‚â§ (a/h¬≤ ‚àí b/(2h))/r
    u'_j ‚â• 0  ‚üπ  œâ ‚â§ (a/h¬≤ + b/(2h))/r
  The binding constraint (tighter) determines the maximum |œâ|.

TIME-STEP CONSTRAINT (CE-20): For Scheme 2 with CN time-stepping, the
diagonal of the explicit-side matrix N must be non-negative:
  Œît < 1 / [r(¬Ω ‚àí 2œâ) + ¬Ω(œÉM)¬≤]   (S-space form)

Artificial diffusion (CE-23): ‚Öõ¬∑(r¬∑ŒîS/œÉ)¬≤¬∑V_SS in S-space.

‚ïê‚ïê‚ïê DISCRETE BARRIER MONITORING (CE-6) ‚ïê‚ïê‚ïê

At each monitoring date t_i, after the time-step solve:
  U_j ‚Üê U_j ¬∑ ùüô_{[L,U]}(S_j)
This re-introduces discontinuities that the schemes must handle.

‚ïê‚ïê‚ïê M-MATRIX DIAGNOSTIC (CE-10, Proposition 4.1) ‚ïê‚ïê‚ïê

For the system matrix (I ‚àí Œ∏¬∑dt¬∑L) stored as mapT_:
  M-matrix satisfied ‚ü∫ all off-diagonals of mapT_ are NON-NEGATIVE
  (because system off-diag = ‚àíŒ∏¬∑dt¬∑(operator off-diag), and Œ∏¬∑dt > 0)
</mathematical_context>

<task>
ROUND 3 OF 7: Modify CrankNicolsonScheme to support Rannacher-style damping
restart after discrete monitoring events (where CE-6 re-introduces discontinuities),
and modify FdmSchemeDesc to carry the new configuration parameters including
scheme selection for Scheme 1 vs Scheme 2.

These changes are internal to the scheme layer and do not depend on Rounds 1-2.

OUTPUT: 3 files (1 modified FdmSchemeDesc/FdmBackwardSolver header,
1 modified CN scheme header, 1 modified CN scheme implementation).
NOTE: Only FdmSchemeDesc changes inside fdmbackwardsolver.hpp ‚Äî
the FdmBackwardSolver class body is NOT changed until Round 4.
</task>

<source_files>
FILE: ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andreas Gaida
 Copyright (C) 2009 Ralph Schreyer
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmbackwardsolver.hpp
*/

#ifndef quantlib_fdm_backward_solver_hpp
#define quantlib_fdm_backward_solver_hpp

#include <ql/methods/finitedifferences/utilities/fdmboundaryconditionset.hpp>

namespace QuantLib {

    class FdmLinearOpComposite;
    class FdmStepConditionComposite;

    struct FdmSchemeDesc {
        enum FdmSchemeType { HundsdorferType, DouglasType,
                             CraigSneydType, ModifiedCraigSneydType, 
                             ImplicitEulerType, ExplicitEulerType,
                             MethodOfLinesType, TrBDF2Type,
                             CrankNicolsonType };

        FdmSchemeDesc(FdmSchemeType type, Real theta, Real mu);

        const FdmSchemeType type;
        const Real theta, mu;

        // some default scheme descriptions
        static FdmSchemeDesc Douglas(); //same as Crank-Nicolson in 1 dimension
        static FdmSchemeDesc CrankNicolson();
        static FdmSchemeDesc ImplicitEuler();
        static FdmSchemeDesc ExplicitEuler();
        static FdmSchemeDesc CraigSneyd();
        static FdmSchemeDesc ModifiedCraigSneyd(); 
        static FdmSchemeDesc Hundsdorfer();
        static FdmSchemeDesc ModifiedHundsdorfer();
        static FdmSchemeDesc MethodOfLines(
            Real eps=0.001, Real relInitStepSize=0.01);
        static FdmSchemeDesc TrBDF2();
    };
        
    class FdmBackwardSolver {
      public:
        typedef FdmLinearOp::array_type array_type;

        FdmBackwardSolver(ext::shared_ptr<FdmLinearOpComposite> map,
                          FdmBoundaryConditionSet bcSet,
                          const ext::shared_ptr<FdmStepConditionComposite>& condition,
                          const FdmSchemeDesc& schemeDesc);

        void rollback(array_type& a, 
                      Time from, Time to,
                      Size steps, Size dampingSteps);

      protected:
        const ext::shared_ptr<FdmLinearOpComposite> map_;
        const FdmBoundaryConditionSet bcSet_;
        const ext::shared_ptr<FdmStepConditionComposite> condition_;
        const FdmSchemeDesc schemeDesc_;
    };
}

#endif


FILE: ql/methods/finitedifferences/schemes/cranknicolsonscheme.hpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2019 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cranknicolsonscheme.hpp
    \brief Crank-Nicolson scheme
*/

#ifndef quantlib_crank_nicolson_scheme_hpp
#define quantlib_crank_nicolson_scheme_hpp

#include <ql/methods/finitedifferences/schemes/impliciteulerscheme.hpp>

namespace QuantLib {

    /*! In one dimension the Crank-Nicolson scheme is equivalent to the
        Douglas scheme and in higher dimensions it is usually inferior to
        operator splitting methods like Craig-Sneyd or Hundsdorfer-Verwer.
    */
    class ExplicitEulerScheme;

    class CrankNicolsonScheme  {
      public:
        // typedefs
        typedef OperatorTraits<FdmLinearOp> traits;
        typedef traits::operator_type operator_type;
        typedef traits::array_type array_type;
        typedef traits::bc_set bc_set;
        typedef traits::condition_type condition_type;

        // constructors
        CrankNicolsonScheme(
            Real theta,
            const ext::shared_ptr<FdmLinearOpComposite>& map,
            const bc_set& bcSet = bc_set(),
            Real relTol = 1e-8,
            ImplicitEulerScheme::SolverType solverType
                = ImplicitEulerScheme::BiCGstab);

        void step(array_type& a, Time t);
        void setStep(Time dt);

        Size numberOfIterations() const;
      protected:
        Real dt_;
        const Real theta_;
        const ext::shared_ptr<ExplicitEulerScheme> explicit_;
        const ext::shared_ptr<ImplicitEulerScheme> implicit_;
    };
}

#endif


FILE: ql/methods/finitedifferences/schemes/cranknicolsonscheme.cpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2019 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/schemes/expliciteulerscheme.hpp>
#include <ql/methods/finitedifferences/schemes/cranknicolsonscheme.hpp>

namespace QuantLib {
    CrankNicolsonScheme::CrankNicolsonScheme(
        Real theta,
        const ext::shared_ptr<FdmLinearOpComposite> & map,
        const bc_set& bcSet,
        Real relTol,
        ImplicitEulerScheme::SolverType solverType)
    : dt_(Null<Real>()),
      theta_(theta),
      explicit_(ext::make_shared<ExplicitEulerScheme>(map, bcSet)),
      implicit_(ext::make_shared<ImplicitEulerScheme>(
          map, bcSet, relTol, solverType)) {
    }

    void CrankNicolsonScheme::step(array_type& a, Time t) {
        QL_REQUIRE(t-dt_ > -1e-8, "a step towards negative time given");

        if (theta_ != 1.0)
            explicit_->step(a, t, 1.0-theta_);

        if (theta_ != 0.0)
            implicit_->step(a, t, theta_);
    }

    void CrankNicolsonScheme::setStep(Time dt) {
        dt_ = dt;
        explicit_->setStep(dt_);
        implicit_->setStep(dt_);
    }

    Size CrankNicolsonScheme::numberOfIterations() const {
        return implicit_->numberOfIterations();
    }
}


FILE: ql/methods/finitedifferences/schemes/impliciteulerscheme.hpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andreas Gaida
 Copyright (C) 2009 Ralph Schreyer
 Copyright (C) 2009, 2017 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file impliciteulerscheme.hpp
    \brief Implicit-Euler scheme
*/

#ifndef quantlib_implicit_euler_scheme_hpp
#define quantlib_implicit_euler_scheme_hpp

#include <ql/methods/finitedifferences/operatortraits.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/schemes/boundaryconditionschemehelper.hpp>

namespace QuantLib {

    class ImplicitEulerScheme {
      public:
        enum SolverType { BiCGstab, GMRES };

        // typedefs
        typedef OperatorTraits<FdmLinearOp> traits;
        typedef traits::operator_type operator_type;
        typedef traits::array_type array_type;
        typedef traits::bc_set bc_set;
        typedef traits::condition_type condition_type;

        // constructors
        explicit ImplicitEulerScheme(ext::shared_ptr<FdmLinearOpComposite> map,
                                     const bc_set& bcSet = bc_set(),
                                     Real relTol = 1e-8,
                                     SolverType solverType = BiCGstab);

        void step(array_type& a, Time t);
        void setStep(Time dt);

        Size numberOfIterations() const;
      protected:
        friend class CrankNicolsonScheme;
        void step(array_type& a, Time t, Real theta);

        Array apply(const Array& r, Real theta) const;
          
        Time dt_;
        ext::shared_ptr<Size> iterations_;

        const Real relTol_;
        const ext::shared_ptr<FdmLinearOpComposite> map_;
        const BoundaryConditionSchemeHelper bcSet_;
        const SolverType solverType_;
    };
}

#endif


FILE: ql/methods/finitedifferences/schemes/expliciteulerscheme.hpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andreas Gaida
 Copyright (C) 2009 Ralph Schreyer
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file expliciteulerscheme.hpp
    \brief explicit-Euler scheme
*/

#ifndef quantlib_explicit_euler_scheme_hpp
#define quantlib_explicit_euler_scheme_hpp

#include <ql/methods/finitedifferences/operatortraits.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/schemes/boundaryconditionschemehelper.hpp>

namespace QuantLib {

    class ExplicitEulerScheme  {
      public:
        // typedefs
        typedef OperatorTraits<FdmLinearOp> traits;
        typedef traits::operator_type operator_type;
        typedef traits::array_type array_type;
        typedef traits::bc_set bc_set;
        typedef traits::condition_type condition_type;

        // constructors
        explicit ExplicitEulerScheme(ext::shared_ptr<FdmLinearOpComposite> map,
                                     const bc_set& bcSet = bc_set());

        void step(array_type& a, Time t);
        void setStep(Time dt);

      protected:
        friend class CrankNicolsonScheme;
        void step(array_type& a, Time t, Real theta);

        Time dt_;
        const ext::shared_ptr<FdmLinearOpComposite> map_;
        const BoundaryConditionSchemeHelper bcSet_;
    };
}

#endif

</source_files>

<implementation_guidance>

=== FILE 1: Modified FdmSchemeDesc (in fdmbackwardsolver.hpp) ===

FdmSchemeDesc gains two new fields:
  Size monitoringDampingSteps;    // Rannacher half-steps after each monitoring event
  Size operatorType;              // 0 = standard, 1 = fitted (Scheme 1), 2 = CN variant (Scheme 2)

APPROACH: Check whether existing members are const or non-const. Add fields
accordingly (see template Round 3 for the two approaches).

New static factories:
  static FdmSchemeDesc FittedImplicit();
  // Returns {ImplicitEulerType, 1.0, 0.0, 0, 1}
  // Scheme 1 with fully implicit time-stepping (paper's recommendation)

  static FdmSchemeDesc FittedCrankNicolson();
  // Returns {CrankNicolsonType, 0.5, 0.0, 0, 1}
  // Scheme 1 with CN time-stepping (not in paper, but useful for 2nd-order accuracy)

  static FdmSchemeDesc CNVariant(Size monitoringDampingSteps = 0);
  // Returns {CrankNicolsonType, 0.5, 0.0, monitoringDampingSteps, 2}
  // Scheme 2 with CN time-stepping (paper's formulation)

  static FdmSchemeDesc CrankNicolsonWithDamping(Size monitoringDampingSteps = 2);
  // Returns {CrankNicolsonType, 0.5, 0.0, monitoringDampingSteps, 0}
  // Standard operator with monitoring restart damping

All EXISTING static factories must still compile and produce identical behavior
(operatorType=0, monitoringDampingSteps=0).

CRITICAL: Do NOT change FdmBackwardSolver class body in this round.


=== FILES 2-3: Modified CrankNicolsonScheme ===

Add Rannacher monitoring-restart capability. After a discrete monitoring event
re-introduces a discontinuity, perform implicit Euler damping half-steps before
resuming CN to suppress the spurious oscillations documented in CE-25 / C25.

Modified constructor:
  CrankNicolsonScheme(
      Real theta,
      const ext::shared_ptr<FdmLinearOpComposite>& map,
      const bc_set& bcSet = bc_set(),
      Real relTol = 1e-8,
      ImplicitEulerScheme::SolverType solverType
          = ImplicitEulerScheme::BiCGstab,
      Size dampingHalfSteps = 0);    // NEW ‚Äî must be even; 0 = no restart damping

New methods:
  void notifyDiscontinuity();
  // Sets inDampingPhase_ = true, dampingRemaining_ = dampingHalfSteps_
  // If dampingHalfSteps_ == 0, this is a no-op

  bool isDamping() const;

QL_REQUIRE: dampingHalfSteps must be even (0 allowed).

Modified step() method:
  void CrankNicolsonScheme::step(array_type& a, Time t) {
      if (inDampingPhase_ && dampingRemaining_ > 0) {
          // Two implicit Euler half-steps at dt/2
          Time halfDt = dt_ * 0.5;
          implicit_->setStep(halfDt);
          implicit_->step(a, t, 1.0);              // t ‚Üí t‚àídt/2
          implicit_->step(a, t - halfDt, 1.0);     // t‚àídt/2 ‚Üí t‚àídt
          implicit_->setStep(dt_);                  // restore
          dampingRemaining_ -= 2;
          if (dampingRemaining_ <= 0) inDampingPhase_ = false;
          return;
      }
      // Standard CN (unchanged):
      if (theta_ != 1.0) explicit_->step(a, t, 1.0 - theta_);
      if (theta_ != 0.0) implicit_->step(a, t, theta_);
  }

Default behavior (dampingHalfSteps=0) must be BIT-IDENTICAL to original.

</implementation_guidance>

<constraints>
- Default behavior must be IDENTICAL to original CrankNicolsonScheme
- notifyDiscontinuity() when dampingHalfSteps_==0 must be a no-op
- Do NOT modify any other scheme files
- Do NOT modify FdmBackwardSolver class in this round
- All existing FdmSchemeDesc factories produce identical behavior
</constraints>

<output_specification>
Produce exactly 3 files:
1. fdmbackwardsolver.hpp (FdmSchemeDesc modified, FdmBackwardSolver unchanged)
2. cranknicolsonscheme.hpp (modified)
3. cranknicolsonscheme.cpp (modified ‚Äî complete implementation)
</output_specification>

<quality_checklist>
‚ñ° All existing FdmSchemeDesc factories return operatorType=0, monitoringDampingSteps=0
‚ñ° New factories produce correct operatorType values
‚ñ° CrankNicolsonScheme with dampingHalfSteps=0 behaves identically to original
‚ñ° QL_REQUIRE enforces dampingHalfSteps is even
‚ñ° step() during damping performs exactly 2 implicit Euler half-steps per call
‚ñ° implicit_->setStep restored to dt_ after damping half-steps
‚ñ° FdmBackwardSolver class declaration unchanged from input
</quality_checklist>
