<system_context>
You are an expert C++ developer implementing improvements to QuantLib v1.23's
finite difference framework for Black-Scholes option pricing. You have deep
familiarity with QuantLib's coding conventions, class hierarchy, and the modern
Fdm* framework (not the deprecated legacy MixedScheme framework).

SOURCE-OF-TRUTH / NO-HALLUCINATION RULES (mandatory):
- Use ONLY the provided source files and prior-round outputs as factual reference for:
  * class/method signatures
  * include paths
  * base-class requirements and pure-virtual methods
  * coding conventions and header styles
  * sign conventions and operator semantics
- If any referenced file content is missing (i.e., an [INSERT FULL CONTENT ...]
  placeholder is not filled), DO NOT guess or reconstruct.
  STOP and ask the user to provide the missing file(s).
- If a requirement is ambiguous (e.g., coordinate definition ln(S) vs ln(S/K),
  whether applyTo is called at every step vs stopping times, or whether a scheme
  is copied by value), you MUST:
  (a) search the provided files for the relevant implementation detail, and
  (b) implement the behavior that matches the source.
  If still ambiguous, STOP and ask a precise clarification question.

INTERNAL VERIFICATION PROTOCOL (mandatory; do before coding; do not print):
- Verify what the 1D BS mesher stores as spatial coordinate x (ln(S), ln(S/K),
  or other) by reading the provided FdmBlackScholesMesher and/or by inspecting
  how FdmBlackScholesOp interprets mesher->location().
- Verify how FirstDerivativeOp / SecondDerivativeOp incorporate nonuniform mesh
  spacing (which mesher spacing functions they use).
- Verify how FiniteDifferenceModel handles StepCondition::applyTo:
  * is applyTo called at every time step, or only at stopping times?
  * is the evolver copied by value inside the model?
- Verify TripleBandLinearOp sign conventions before implementing any M-matrix
  diagnostics (i.e., which diagonal coefficients must be nonnegative vs
  nonpositive for the operator representation actually stored in mapT_).

CODING CONVENTIONS (mandatory):
- Namespace: all classes in `namespace QuantLib { }`
- Smart pointers: use `ext::shared_ptr`, NOT `std::shared_ptr`
- Return arrays: use `Array` (QuantLib uses move semantics; match existing
  method signatures — if similar methods return `Disposable<Array>`, do so too)
- Assertions: use `QL_REQUIRE(condition, message)` for preconditions,
  `QL_ENSURE(condition, message)` for postconditions
- Include guards: `#ifndef quantlib_<path_underscored>_hpp` /
  `#define quantlib_<path_underscored>_hpp`
- Copyright header: match the style of adjacent files in the same directory
- Includes: use angle brackets `<ql/...>` for QuantLib headers
- No `using namespace std;` in headers
- Follow existing naming: `camelCase` for methods, `camelCase_` for private
  members, `CamelCase` for classes

OUTPUT RULES:
- Produce COMPLETE files, never diffs or partial snippets
- Only output files that are new or modified in this round
- Each file must compile against unmodified QuantLib v1.23 headers (plus any
  files produced in prior rounds, which will be provided if needed)
- Include all necessary #include directives

</system_context>

<mathematical_context>
PDE in log-coordinate x and time-to-maturity τ (τ=0 at payoff, τ=T today):

  -u_τ + a(x,τ)·u_xx + b(x,τ)·u_x − r·u = 0

where a(x,τ) = σ²/2,  b(x,τ) = (r−q) − σ²/2.

IMPORTANT IMPLEMENTATION NOTE (coordinate convention):
- The notation above uses a generic log-coordinate x. The actual QuantLib
  implementation may use x=ln(S) or x=ln(S/K) (or a variant).
- In code, you MUST follow the convention used by the provided QuantLib v1.23
  sources (FdmBlackScholesMesher / FdmBlackScholesOp), especially for:
  * barrier comparisons and alignment targets
  * any conversion between S-space and mesh coordinate space
- Do not “assume ln(S/K)” just because it appears in this preamble.

EXPONENTIAL FITTING:
  θ_j = b_j·h / (2·a_j)       (local Péclet parameter)
  ρ_j = θ_j·coth(θ_j)         (fitting factor; ρ ≈ 1 + θ²/3 for |θ| < 1e-8)

Fitted stencil at interior node j (uniform grid spacing h):
  ℓ_j = a_j·ρ_j/h² − b_j/(2h)     (lower off-diagonal)
  d_j = −2·a_j·ρ_j/h² − r          (main diagonal)
  u_j⁺ = a_j·ρ_j/h² + b_j/(2h)    (upper off-diagonal)

NONUNIFORM GRID NOTE:
- The proof that exponential fitting guarantees ℓ_j ≥ 0 and u_j⁺ ≥ 0 is
  strictly for uniform spacing h.
- When using a nonuniform 1D mesher (e.g., sinh), define a per-node effective
  spacing consistent with QuantLib’s derivative operators, e.g.:
    h_j := 0.5*(dplus_j + dminus_j)
  where dplus/dminus are the local forward/backward spacings used by the
  derivative operators. This is required when computing θ_j.

IMPORTANT: Exponential fitting GUARANTEES ℓ_j ≥ 0 and u_j⁺ ≥ 0 for all
finite a_j > 0 (uniform-grid proof). Upwind fallback is only needed as a
degenerate guard when a_j ≈ 0.

This stencil decomposes as: b_j·(∂/∂x) + a_j·ρ_j·(∂²/∂x²) − r·I,
which means it can be assembled via TripleBandLinearOp::axpyb():
  mapT_.axpyb(b_array, firstDerivOp, secondDerivOp.mult(aρ_array), Array(1,-r))

RANNACHER-SMOOTHED CN: After each discontinuity event (payoff at τ=0,
monitoring projection), perform 2 implicit Euler half-steps at dt/2, then
resume Crank-Nicolson.

GREEKS: Δ = u_x/S,  Γ = (u_xx − u_x)/S²  where x is a log-coordinate.

SINH MESH: x(ξ) = x_center + c·sinh(α·(ξ − ξ₀)) for ξ ∈ [0,1], with ξ₀
found by bisection to satisfy endpoint constraints x(0)=xMin, x(1)=xMax.
</mathematical_context>


<task>
ROUND 4 OF 7: Modify FdmBackwardSolver to support monitoring-restart damping
via time-segment splitting, and modify FdmBlackScholesSolver to support the
fitted operator selection.

This round depends on:
- Round 1: FdmFittedBlackScholesOp (new operator)
- Round 3: Modified CrankNicolsonScheme (with notifyDiscontinuity) and
  modified FdmSchemeDesc (with monitoringDampingSteps field)

OUTPUT: 4 files (2 modified headers + 2 modified implementations).
</task>

<source_files>
FILE: ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp
[Attach the relevant output from Round 3 here]

FILE: ql/methods/finitedifferences/solvers/fdmbackwardsolver.cpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andreas Gaida
 Copyright (C) 2009 Ralph Schreyer
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmbackwardsolver.cpp
*/

#include <ql/mathconstants.hpp>
#include <ql/methods/finitedifferences/finitedifferencemodel.hpp>
#include <ql/methods/finitedifferences/schemes/craigsneydscheme.hpp>
#include <ql/methods/finitedifferences/schemes/cranknicolsonscheme.hpp>
#include <ql/methods/finitedifferences/schemes/douglasscheme.hpp>
#include <ql/methods/finitedifferences/schemes/expliciteulerscheme.hpp>
#include <ql/methods/finitedifferences/schemes/hundsdorferscheme.hpp>
#include <ql/methods/finitedifferences/schemes/impliciteulerscheme.hpp>
#include <ql/methods/finitedifferences/schemes/methodoflinesscheme.hpp>
#include <ql/methods/finitedifferences/schemes/modifiedcraigsneydscheme.hpp>
#include <ql/methods/finitedifferences/schemes/trbdf2scheme.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <utility>


namespace QuantLib {
    
    FdmSchemeDesc::FdmSchemeDesc(FdmSchemeType aType, Real aTheta, Real aMu)
    : type(aType), theta(aTheta), mu(aMu) { }

    FdmSchemeDesc FdmSchemeDesc::Douglas() { return {FdmSchemeDesc::DouglasType, 0.5, 0.0}; }

    FdmSchemeDesc FdmSchemeDesc::CrankNicolson() {
        return {FdmSchemeDesc::CrankNicolsonType, 0.5, 0.0};
    }

    FdmSchemeDesc FdmSchemeDesc::CraigSneyd() { return {FdmSchemeDesc::CraigSneydType, 0.5, 0.5}; }

    FdmSchemeDesc FdmSchemeDesc::ModifiedCraigSneyd() {
        return {FdmSchemeDesc::ModifiedCraigSneydType, 1.0 / 3.0, 1.0 / 3.0};
    }
    
    FdmSchemeDesc FdmSchemeDesc::Hundsdorfer() {
        return {FdmSchemeDesc::HundsdorferType, 0.5 + std::sqrt(3.0) / 6, 0.5};
    }
    
    FdmSchemeDesc FdmSchemeDesc::ModifiedHundsdorfer() {
        return {FdmSchemeDesc::HundsdorferType, 1.0 - std::sqrt(2.0) / 2, 0.5};
    }
    
    FdmSchemeDesc FdmSchemeDesc::ExplicitEuler() {
        return {FdmSchemeDesc::ExplicitEulerType, 0.0, 0.0};
    }

    FdmSchemeDesc FdmSchemeDesc::ImplicitEuler() {
        return {FdmSchemeDesc::ImplicitEulerType, 0.0, 0.0};
    }

    FdmSchemeDesc FdmSchemeDesc::MethodOfLines(Real eps, Real relInitStepSize) {
        return {FdmSchemeDesc::MethodOfLinesType, eps, relInitStepSize};
    }

    FdmSchemeDesc FdmSchemeDesc::TrBDF2() { return {FdmSchemeDesc::TrBDF2Type, 2 - M_SQRT2, 1e-8}; }

    FdmBackwardSolver::FdmBackwardSolver(
        ext::shared_ptr<FdmLinearOpComposite> map,
        FdmBoundaryConditionSet bcSet,
        const ext::shared_ptr<FdmStepConditionComposite>& condition,
        const FdmSchemeDesc& schemeDesc)
    : map_(std::move(map)), bcSet_(std::move(bcSet)),
      condition_((condition) != nullptr ?
                     condition :
                     ext::make_shared<FdmStepConditionComposite>(
                         std::list<std::vector<Time> >(), FdmStepConditionComposite::Conditions())),
      schemeDesc_(schemeDesc) {}

    void FdmBackwardSolver::rollback(FdmBackwardSolver::array_type& rhs, 
                                     Time from, Time to,
                                     Size steps, Size dampingSteps) {

        const Time deltaT = from - to;
        const Size allSteps = steps + dampingSteps;
        const Time dampingTo = from - (deltaT*dampingSteps)/allSteps;

        if ((dampingSteps != 0U) && schemeDesc_.type != FdmSchemeDesc::ImplicitEulerType) {
            ImplicitEulerScheme implicitEvolver(map_, bcSet_);    
            FiniteDifferenceModel<ImplicitEulerScheme> 
                    dampingModel(implicitEvolver, condition_->stoppingTimes());
            dampingModel.rollback(rhs, from, dampingTo, 
                                  dampingSteps, *condition_);
        }

        switch (schemeDesc_.type) {
          case FdmSchemeDesc::HundsdorferType:
            {
                HundsdorferScheme hsEvolver(schemeDesc_.theta, schemeDesc_.mu, 
                                            map_, bcSet_);
                FiniteDifferenceModel<HundsdorferScheme> 
                               hsModel(hsEvolver, condition_->stoppingTimes());
                hsModel.rollback(rhs, dampingTo, to, steps, *condition_);
            }
            break;
          case FdmSchemeDesc::DouglasType:
            {
                DouglasScheme dsEvolver(schemeDesc_.theta, map_, bcSet_);
                FiniteDifferenceModel<DouglasScheme> 
                               dsModel(dsEvolver, condition_->stoppingTimes());
                dsModel.rollback(rhs, dampingTo, to, steps, *condition_);
            }
            break;
          case FdmSchemeDesc::CrankNicolsonType:
            {
              CrankNicolsonScheme cnEvolver(schemeDesc_.theta, map_, bcSet_);
              FiniteDifferenceModel<CrankNicolsonScheme>
                             cnModel(cnEvolver, condition_->stoppingTimes());
              cnModel.rollback(rhs, dampingTo, to, steps, *condition_);

            }
            break;
          case FdmSchemeDesc::CraigSneydType:
            {
                CraigSneydScheme csEvolver(schemeDesc_.theta, schemeDesc_.mu, 
                                           map_, bcSet_);
                FiniteDifferenceModel<CraigSneydScheme> 
                               csModel(csEvolver, condition_->stoppingTimes());
                csModel.rollback(rhs, dampingTo, to, steps, *condition_);
            }
            break;
          case FdmSchemeDesc::ModifiedCraigSneydType:
            {
                ModifiedCraigSneydScheme csEvolver(schemeDesc_.theta, 
                                                   schemeDesc_.mu,
                                                   map_, bcSet_);
                FiniteDifferenceModel<ModifiedCraigSneydScheme> 
                              mcsModel(csEvolver, condition_->stoppingTimes());
                mcsModel.rollback(rhs, dampingTo, to, steps, *condition_);
            }
            break;
          case FdmSchemeDesc::ImplicitEulerType:
            {
                ImplicitEulerScheme implicitEvolver(map_, bcSet_);
                FiniteDifferenceModel<ImplicitEulerScheme> 
                   implicitModel(implicitEvolver, condition_->stoppingTimes());
                implicitModel.rollback(rhs, from, to, allSteps, *condition_);
            }
            break;
          case FdmSchemeDesc::ExplicitEulerType:
            {
                ExplicitEulerScheme explicitEvolver(map_, bcSet_);
                FiniteDifferenceModel<ExplicitEulerScheme> 
                   explicitModel(explicitEvolver, condition_->stoppingTimes());
                explicitModel.rollback(rhs, dampingTo, to, steps, *condition_);
            }
            break;
          case FdmSchemeDesc::MethodOfLinesType:
            {
                MethodOfLinesScheme methodOfLines(
                    schemeDesc_.theta, schemeDesc_.mu, map_, bcSet_);
                FiniteDifferenceModel<MethodOfLinesScheme>
                   molModel(methodOfLines, condition_->stoppingTimes());
                molModel.rollback(rhs, dampingTo, to, steps, *condition_);
            }
            break;
          case FdmSchemeDesc::TrBDF2Type:
            {
                const FdmSchemeDesc trDesc
                    = FdmSchemeDesc::CraigSneyd();

                const ext::shared_ptr<CraigSneydScheme> hsEvolver(
                    ext::make_shared<CraigSneydScheme>(
                        trDesc.theta, trDesc.mu, map_, bcSet_));

                TrBDF2Scheme<CraigSneydScheme> trBDF2(
                    schemeDesc_.theta, map_, hsEvolver, bcSet_,schemeDesc_.mu);

                FiniteDifferenceModel<TrBDF2Scheme<CraigSneydScheme> >
                   trBDF2Model(trBDF2, condition_->stoppingTimes());
                trBDF2Model.rollback(rhs, dampingTo, to, steps, *condition_);
            }
            break;
          default:
            QL_FAIL("Unknown scheme type");
        }
    }
}


FILE: ql/methods/finitedifferences/solvers/fdmblackscholessolver.hpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmblackscholessolver.hpp
*/

#ifndef quantlib_fdm_black_scholes_solver_hpp
#define quantlib_fdm_black_scholes_solver_hpp

#include <ql/handle.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/utilities/fdmquantohelper.hpp>

namespace QuantLib {

    class Fdm1DimSolver;
    class FdmSnapshotCondition;
    class GeneralizedBlackScholesProcess;

    class FdmBlackScholesSolver : public LazyObject {
      public:
        FdmBlackScholesSolver(Handle<GeneralizedBlackScholesProcess> process,
                              Real strike,
                              FdmSolverDesc solverDesc,
                              const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas(),
                              bool localVol = false,
                              Real illegalLocalVolOverwrite = -Null<Real>(),
                              Handle<FdmQuantoHelper> quantoHelper = Handle<FdmQuantoHelper>());

        Real valueAt(Real s) const;
        Real deltaAt(Real s) const;
        Real gammaAt(Real s) const;
        Real thetaAt(Real s) const;

      protected:
        void performCalculations() const override;

      private:
        Handle<GeneralizedBlackScholesProcess> process_;
        const Real strike_;
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;
        const bool localVol_;
        const Real illegalLocalVolOverwrite_;
        const Handle<FdmQuantoHelper> quantoHelper_;

        mutable ext::shared_ptr<Fdm1DimSolver> solver_;
    };
}

#endif /* quantlib_fdm_black_scholes_solver_hpp */


FILE: ql/methods/finitedifferences/solvers/fdmblackscholessolver.cpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/operators/fdmblackscholesop.hpp>
#include <ql/methods/finitedifferences/solvers/fdm1dimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmblackscholessolver.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    FdmBlackScholesSolver::FdmBlackScholesSolver(Handle<GeneralizedBlackScholesProcess> process,
                                                 Real strike,
                                                 FdmSolverDesc solverDesc,
                                                 const FdmSchemeDesc& schemeDesc,
                                                 bool localVol,
                                                 Real illegalLocalVolOverwrite,
                                                 Handle<FdmQuantoHelper> quantoHelper)
    : process_(std::move(process)), strike_(strike), solverDesc_(std::move(solverDesc)),
      schemeDesc_(schemeDesc), localVol_(localVol),
      illegalLocalVolOverwrite_(illegalLocalVolOverwrite), quantoHelper_(std::move(quantoHelper)) {

        registerWith(process_);
        registerWith(quantoHelper_);
    }

    void FdmBlackScholesSolver::performCalculations() const {
            const ext::shared_ptr<FdmBlackScholesOp> op(
            ext::make_shared<FdmBlackScholesOp>(
                solverDesc_.mesher, process_.currentLink(), strike_,
                localVol_, illegalLocalVolOverwrite_, 0,
                (quantoHelper_.empty())
                    ? ext::shared_ptr<FdmQuantoHelper>()
                    : quantoHelper_.currentLink()));

        solver_ = ext::make_shared<Fdm1DimSolver>(solverDesc_, schemeDesc_, op);
    }

    Real FdmBlackScholesSolver::valueAt(Real s) const {
        calculate();
        return solver_->interpolateAt(std::log(s));
    }

    Real FdmBlackScholesSolver::deltaAt(Real s) const {
        calculate();
        return solver_->derivativeX(std::log(s))/s;
    }

    Real FdmBlackScholesSolver::gammaAt(Real s) const {
        calculate();
        return (solver_->derivativeXX(std::log(s))
                -solver_->derivativeX(std::log(s)))/(s*s);
    }

    Real FdmBlackScholesSolver::thetaAt(Real s) const {
        return solver_->thetaAt(std::log(s));
    }
}


FILE: ql/methods/finitedifferences/solvers/fdm1dimsolver.hpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdm1dimsolver.hpp
*/

#ifndef quantlib_fdm_1_dim_solver_hpp
#define quantlib_fdm_1_dim_solver_hpp

#include <ql/handle.hpp>
#include <ql/math/matrix.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>


namespace QuantLib {

    class CubicInterpolation;
    class FdmSnapshotCondition;

    class Fdm1DimSolver : public LazyObject {
      public:
        Fdm1DimSolver(const FdmSolverDesc& solverDesc,
                      const FdmSchemeDesc& schemeDesc,
                      ext::shared_ptr<FdmLinearOpComposite> op);

        Real interpolateAt(Real x) const;
        Real thetaAt(Real x) const;

        Real derivativeX(Real x) const;
        Real derivativeXX(Real x) const;

      protected:
        void performCalculations() const override;

      private:
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;
        const ext::shared_ptr<FdmLinearOpComposite> op_;

        const ext::shared_ptr<FdmSnapshotCondition> thetaCondition_;
        const ext::shared_ptr<FdmStepConditionComposite> conditions_;

        std::vector<Real> x_, initialValues_;
        mutable Array resultValues_;
        mutable ext::shared_ptr<CubicInterpolation> interpolation_;
    };
}

#endif


FILE: ql/methods/finitedifferences/finitedifferencemodel.hpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file finitedifferencemodel.hpp
    \brief generic finite difference model
*/

#ifndef quantlib_finite_difference_model_hpp
#define quantlib_finite_difference_model_hpp

#include <ql/methods/finitedifferences/boundarycondition.hpp>
#include <ql/methods/finitedifferences/operatortraits.hpp>
#include <ql/methods/finitedifferences/stepcondition.hpp>
#include <utility>

namespace QuantLib {

    //! Generic finite difference model
    /*! \ingroup findiff */
    template<class Evolver>
    class FiniteDifferenceModel {
      public:
        typedef typename Evolver::traits traits;
        typedef typename traits::operator_type operator_type;
        typedef typename traits::array_type array_type;
        typedef typename traits::bc_set bc_set;
        typedef typename traits::condition_type condition_type;
        // constructors
        FiniteDifferenceModel(const operator_type& L,
                              const bc_set& bcs,
                              std::vector<Time> stoppingTimes = std::vector<Time>())
        : evolver_(L, bcs), stoppingTimes_(std::move(stoppingTimes)) {
            std::sort(stoppingTimes_.begin(), stoppingTimes_.end());
            auto last = std::unique(stoppingTimes_.begin(), stoppingTimes_.end());
            stoppingTimes_.erase(last, stoppingTimes_.end());
        }
        FiniteDifferenceModel(Evolver evolver,
                              std::vector<Time> stoppingTimes = std::vector<Time>())
        : evolver_(std::move(evolver)), stoppingTimes_(std::move(stoppingTimes)) {
            std::sort(stoppingTimes_.begin(), stoppingTimes_.end());
            auto last = std::unique(stoppingTimes_.begin(), stoppingTimes_.end());
            stoppingTimes_.erase(last, stoppingTimes_.end());
        }
        // methods
        // array_type grid() const { return evolver.xGrid(); }
        const Evolver& evolver() const{ return evolver_; }
        /*! solves the problem between the given times.
            \warning being this a rollback, <tt>from</tt> must be a later
                     time than <tt>to</tt>.
        */
        void rollback(array_type& a,
                      Time from,
                      Time to,
                      Size steps) {
            rollbackImpl(a, from, to, steps, (const condition_type*)nullptr);
        }
        /*! solves the problem between the given times,
            applying a condition at every step.
            \warning being this a rollback, <tt>from</tt> must be a later
                     time than <tt>to</tt>.
        */
        void rollback(array_type& a,
                      Time from,
                      Time to,
                      Size steps,
                      const condition_type& condition) {
            rollbackImpl(a,from,to,steps,&condition);
        }
      private:
        void rollbackImpl(array_type& a,
                          Time from,
                          Time to,
                          Size steps,
                          const condition_type* condition) {

            QL_REQUIRE(from >= to,
                       "trying to roll back from " << from << " to " << to);

            Time dt = (from-to)/steps, t = from;
            evolver_.setStep(dt);

            if(!stoppingTimes_.empty() && stoppingTimes_.back() == from) {
                if (condition)
                    condition->applyTo(a,from);
            }
            for (Size i=0; i<steps; ++i, t -= dt) {
                Time now = t;
                // make sure last step ends exactly on "to" in order to not
                // miss a stopping time at "to" due to numerical issues
                Time next = (i < steps -1)? t-dt : to;

                if (std::fabs(to-next) < std::sqrt(QL_EPSILON)) next = to;
                bool hit = false;
                for (Integer j = static_cast<Integer>(stoppingTimes_.size())-1; j >= 0 ; --j) {
                    if (next <= stoppingTimes_[j] && stoppingTimes_[j] < now) {
                        // a stopping time was hit
                        hit = true;

                        // perform a small step to stoppingTimes_[j]...
                        evolver_.setStep(now-stoppingTimes_[j]);
                        evolver_.step(a,now);
                        if (condition)
                            condition->applyTo(a,stoppingTimes_[j]);
                        // ...and continue the cycle
                        now = stoppingTimes_[j];
                    }
                }
                // if we did hit...
                if (hit) {
                    // ...we might have to make a small step to
                    // complete the big one...
                    if (now > next) {
                        evolver_.setStep(now - next);
                        evolver_.step(a,now);
                        if (condition)
                            condition->applyTo(a,next);
                    }
                    // ...and in any case, we have to reset the
                    // evolver to the default step.
                    evolver_.setStep(dt);
                } else {
                    // if we didn't, the evolver is already set to the
                    // default step, which is ok for us.
                    evolver_.step(a,now);
                    if (condition)
                        condition->applyTo(a, next);
                }
            }
        }
        Evolver evolver_;
        std::vector<Time> stoppingTimes_;
    };

}


#endif


ROUND 1 OUTPUT (for reference):
FILE: ql/methods/finitedifferences/operators/fdmfittedblackscholesop.hpp
[Attach the relevant output from Round 1 here]

ROUND 3 OUTPUT (for reference):
FILE: ql/methods/finitedifferences/schemes/cranknicolsonscheme.hpp
[Attach the relevant output from Round 3 here]
</source_files>

<implementation_guidance>

=== FILE 1: Modified FdmBackwardSolver ===

FACT-CHECKS (mandatory; do not print):
- Read finitedifferencemodel.hpp rollback logic to confirm:
  * if the evolver is copied by value
  * when StepCondition::applyTo is called (each step and/or stopping times)
  * whether applyTo is called at the initial 'from' time (important for segment boundaries)
- Confirm time ordering conventions (from > to, backward marching).

CRITICAL DESIGN FIX (monitoring restart damping coherence):
- Round 3 adds CrankNicolsonScheme::notifyDiscontinuity() implementing true
  Rannacher restart smoothing (2 implicit Euler half-steps at dt/2).
- Round 4 MUST use that mechanism for monitoring restart damping.
- Do NOT replace it with “full implicit Euler damping segments” that bypass
  notifyDiscontinuity(); that would make Round 3 unused and would deviate
  from the intended two-half-step restart smoothing.

Baseline behavior preservation:
- When schemeDesc_.monitoringDampingSteps == 0 OR schemeDesc_.type != CrankNicolsonType:
  rollback behavior must be IDENTICAL to the original implementation.
- When monitoringDampingSteps > 0 but there are NO stopping times inside the CN phase interval:
  behavior must be identical to monitoringDampingSteps==0 (to preserve numerical identity).

Original structure reminder:
  void FdmBackwardSolver::rollback(..., Size steps, Size dampingSteps) {
      // Phase 1: damping steps with implicit Euler
      // Phase 2: main scheme steps (CN/Douglas/Hundsdorfer/etc.)
  }

NEW STRUCTURE when monitoring restart damping is enabled (CN only):
1) Phase 1 (unchanged): if dampingSteps != 0, run the original implicit Euler
   damping phase exactly as before.

2) Phase 2 (CN only): run CN from dampingTo -> to, but split into segments at
   condition_->stoppingTimes() that lie STRICTLY inside (to, dampingTo) (use tolerance).
   Let CNFrom = dampingTo, CNTo = to, CNSteps = steps - dampingSteps.

3) Build segment boundaries in descending (backward) order:
     boundaries = {CNFrom, t_stop_1, t_stop_2, ..., CNTo}
   where t_stop_k are filtered/sorted stopping times within (CNTo, CNFrom).

4) Distribute CNSteps across segments proportionally to segment length, ensuring:
   - sum(segmentSteps) == CNSteps
   - each segment with positive length gets at least 1 step
   - if impossible (too many segments vs steps), QL_REQUIRE with a clear message

5) For each segment [segFrom, segTo] with segSteps:
   - Construct a CrankNicolsonScheme with dampingHalfSteps = schemeDesc_.monitoringDampingSteps.
   - If this segment begins immediately AFTER a discontinuity time (i.e., segFrom is a stopping time
     that has just been applied at the end of the previous segment), call
       cnEvolver.notifyDiscontinuity();
     BEFORE passing cnEvolver into FiniteDifferenceModel for this segment.
   - Then rollback this segment via FiniteDifferenceModel<CrankNicolsonScheme>.

IMPORTANT SEMANTICS NOTE:
- Segmenting must not cause double-application of step conditions at segment boundaries.
  Verify FiniteDifferenceModel’s behavior from source:
  * If applyTo is only called after each step at the new time t, segment boundaries are safe.
  * If applyTo is also called at the initial segFrom time, you MUST adjust the segmentation
    logic to prevent double-application (e.g., excluding segFrom from the time list used
    by that model call, or using tolerance-based filtering).

Other scheme types:
- The switch statement and behavior for Douglas/Hundsdorfer/etc. must remain unchanged.

You may factor out a helper rollbackSegment(...) to reuse the original two-phase
(damping + main scheme) logic, but DO NOT change the behavior of the non-CN schemes.


=== FILE 2: Modified FdmBlackScholesSolver ===

Simpler change: add bool useFittedOperator_ member and constructor parameter.

Constructor gains:
  bool useFittedOperator = false

In performCalculations():
  ext::shared_ptr<FdmLinearOpComposite> op;
  if (useFittedOperator_) {
      op = ext::make_shared<FdmFittedBlackScholesOp>(
          solverDesc_.mesher, process_.currentLink(), strike_,
          localVol_, illegalLocalVolOverwrite_, 0,
          quantoHelper_.empty() ? ext::shared_ptr<FdmQuantoHelper>()
                                : quantoHelper_.currentLink());
  } else {
      op = ext::make_shared<FdmBlackScholesOp>(/* same args */);
  }
  solver_ = ext::make_shared<Fdm1DimSolver>(solverDesc_, schemeDesc_, op);

Include the new header:
  #include <ql/methods/finitedifferences/operators/fdmfittedblackscholesop.hpp>

</implementation_guidance>

<constraints>
- When monitoringDampingSteps == 0: rollback behavior must be IDENTICAL to
  the original implementation (byte-for-byte same numerical results)
- When monitoringDampingSteps > 0 but no stopping times exist in the
  condition's stopping times within the CN phase interval: behavior identical
  to monitoringDampingSteps==0
- Do NOT modify FiniteDifferenceModel
- The switch statement for other scheme types (Douglas, Hundsdorfer, etc.)
  must remain unchanged
- FdmBlackScholesSolver's existing constructor signature must remain valid
  (new parameter has default value)
- fdmfittedblackscholesop.hpp must be included in the .cpp, not the .hpp
- If any required .cpp source file content is missing, STOP and ask (do not reconstruct)
</constraints>

<output_specification>
Produce exactly 4 files:
1. fdmbackwardsolver.hpp (modified — FdmBackwardSolver updated; FdmSchemeDesc from Round 3 retained)
2. fdmbackwardsolver.cpp (modified — restructured rollback for CN monitoring restart damping)
3. fdmblackscholessolver.hpp (modified — new constructor parameter)
4. fdmblackscholessolver.cpp (modified — conditional operator creation)
</output_specification>

<quality_checklist>
□ Original rollback behavior preserved when monitoringDampingSteps == 0
□ CN phase segmented at stopping times; notifyDiscontinuity used for restart smoothing
□ Step counts distributed proportionally and sum to total
□ No double-application of discrete dividend / step conditions at segment boundaries
□ Other scheme types unchanged
□ FdmBlackScholesSolver compiles with both old and new constructor forms
□ FdmFittedBlackScholesOp header is #included in the .cpp, not the .hpp
</quality_checklist>
