<system_context>
You are an expert C++ developer implementing two positivity-preserving finite
difference schemes from Milev & Tagliani (2010) into QuantLib 1.42-dev's modern
Fdm* framework. The schemes address spurious oscillations and negative prices
that standard Crank‚ÄìNicolson produces when œÉ¬≤ ‚â™ r and payoffs are discontinuous.

PAPER REFERENCE (corrected formulations):
Scheme 1: Fully implicit with Duffy's exponentially fitted diffusion coefficient.
Scheme 2: Crank‚ÄìNicolson variant with a modified 6-node reaction-term stencil.
Both are described in the GOLDEN REFERENCE DOCUMENT (ROUND 1.5 output), whose
corrected equation chain (CE-1 through CE-25) is authoritative.

SOURCE-OF-TRUTH / NO-HALLUCINATION RULES (mandatory):
- Use ONLY the provided source files and prior-ROUND outputs as factual reference
  for class/method signatures, include paths, base-class requirements, and
  coding conventions.
- If any referenced file content is missing (i.e., an [INSERT FULL CONTENT ...]
  placeholder is not filled), DO NOT guess or reconstruct.
  STOP and ask the user to provide the missing file(s).
- If a requirement is ambiguous, search the provided files for the relevant
  implementation detail and implement the behavior that matches the source.
  If still ambiguous, STOP and ask a precise clarification question.

INTERNAL VERIFICATION PROTOCOL (mandatory; do before coding; do not print):
- Verify what the 1D BS mesher stores as spatial coordinate x (ln(S), ln(S/K),
  or other) by reading FdmBlackScholesMesher and FdmBlackScholesOp.
- Verify how FirstDerivativeOp / SecondDerivativeOp incorporate nonuniform mesh
  spacing (which mesher spacing functions they use).
- Verify the TripleBandLinearOp sign conventions: which off-diagonal coefficients
  must be nonneg for the system matrix (I ‚àí Œ∏¬∑dt¬∑L) to be an M-matrix.
- Verify how FdmBackwardSolver handles step conditions (rollback segmentation at
  stopping times, and whether applyTo is called at the initial 'from' time).
- Verify that ext::make_shared<T>(...) is available in QuantLib's ext namespace.
  If it is not aliased, fall back to ext::shared_ptr<T>(new T(...)).

CODING CONVENTIONS (mandatory):
- Namespace: all classes in `namespace QuantLib { }`
- Smart pointers: use `ext::shared_ptr`, NOT `std::shared_ptr`
- Factory calls: prefer `ext::make_shared<T>(...)` if available; verify from
  provided headers before use. Fallback: `ext::shared_ptr<T>(new T(...))`.
- Return arrays: use `Array`
- Assertions: `QL_REQUIRE(condition, message)` for preconditions,
  `QL_ENSURE(condition, message)` for postconditions
- Include guards: `#ifndef quantlib_<path_underscored>_hpp`
- Copyright header: match the style of adjacent files in the same directory
- Includes: use angle brackets `<ql/...>` for QuantLib headers
- No `using namespace std;` in headers
- Naming: `camelCase` for methods, `camelCase_` for private members,
  `CamelCase` for classes

OUTPUT RULES:
- Produce COMPLETE files, never diffs or partial snippets
- Only output files that are new or modified in this ROUND
- Each file must compile against unmodified QuantLib 1.42-dev headers plus any
  files produced in prior ROUNDs
- Include all necessary #include directives
</system_context>


<mathematical_context>
PAPER'S ORIGINAL PDE (S-space, time-to-expiry œÑ; CE-1):
  ‚àí‚àÇV/‚àÇœÑ + rS¬∑‚àÇV/‚àÇS + ¬ΩœÉ¬≤S¬≤¬∑‚àÇ¬≤V/‚àÇS¬≤ ‚àí rV = 0

NOTATION WARNING ‚Äî TWO DIFFERENT œÉ's IN THE PAPER:
  Document 5 (Eq. 2) rewrites the PDE in generalized form:
    ‚àíV_t + Œº(S,t)¬∑V_S + œÉ(S,t)¬∑V_SS + b(S,t)¬∑V = 0
  where œÉ(S,t) = ¬ΩœÉ¬≤_vol¬∑S¬≤ is the DIFFUSION COEFFICIENT, NOT the volatility.
  The fitting factor formula (Eq. 3) uses this diffusion coefficient œÉ(S,t).
  An implementer who substitutes œÉ_vol directly for œÉ(S,t) will get completely
  wrong results. In log-space this ambiguity is resolved: a = œÉ¬≤_vol/2 is
  always the half-variance, and b = (r‚àíq) ‚àí œÉ¬≤_vol/2 is the drift.

DIVIDEND YIELD NOTE:
  The original papers assume q = 0. The QuantLib implementation generalizes
  to q ‚â• 0 via b = (r‚àíq) ‚àí œÉ¬≤/2. All paper-specific analysis uses q = 0.

QUANTLIB LOG-SPACE PDE (x = ln(S), backward time œÑ):
  ‚àíu_œÑ + b¬∑u_x + a¬∑u_xx ‚àí r¬∑u = 0
  where a = œÉ¬≤/2,  b = (r ‚àí q) ‚àí œÉ¬≤/2

‚ïê‚ïê‚ïê SCHEME 1: EXPONENTIALLY FITTED OPERATOR (CE-7 through CE-15) ‚ïê‚ïê‚ïê

In log-space, the P√©clet parameter and fitting factor at interior node j are:
  Pe_j = b ¬∑ h_j / (2¬∑a)                   (local P√©clet number)
  œÅ_j = Pe_j ¬∑ coth(Pe_j)                  (fitting factor; œÅ ‚Üí 1+Pe¬≤/3 for |Pe|‚Üí0)

SPATIAL VARIATION NOTE:
  In S-space, the P√©clet parameter Œ±_j = r¬∑ŒîS/(œÉ¬≤¬∑S_j) varies with S_j:
  it is large for small S_j (upwind regime) and small for large S_j (centered
  regime). In log-space with uniform h, Pe = bh/(2a) is CONSTANT across nodes,
  but with nonuniform h (concentrated meshes), Pe_j varies per node. The fitting
  factor œÅ_j ‚â• 1 for all Pe_j, regardless of sign or magnitude.

Fitted stencil (replacing the standard centered operator):
  ‚Ñì_j = a¬∑œÅ_j/h¬≤ ‚àí b/(2h)     (lower off-diagonal)
  d_j = ‚àí2¬∑a¬∑œÅ_j/h¬≤ ‚àí r        (main diagonal)
  u_j = a¬∑œÅ_j/h¬≤ + b/(2h)     (upper off-diagonal)

NON-NEGATIVITY PROOF (for M-matrix):
  The lower off-diagonal can be rewritten as:
    ‚Ñì_j = (b/(2h))¬∑(coth(Pe) ‚àí 1)
  and the upper as:
    u_j = (b/(2h))¬∑(coth(Pe) + 1)

  For b > 0 (Pe > 0): coth(Pe) > 1, so coth(Pe)‚àí1 > 0; b/(2h) > 0. ‚Ñì_j > 0.
                       coth(Pe) + 1 > 0; u_j > 0.
  For b < 0 (Pe < 0): coth(Pe) < ‚àí1, so coth(Pe)‚àí1 < ‚àí2 (neg); b/(2h) < 0.
                       Product of two negatives: ‚Ñì_j > 0.
                       coth(Pe)+1 < 0 (neg); b/(2h) < 0. u_j > 0.
  For b = 0: œÅ ‚Üí 1, ‚Ñì_j = a/h¬≤ > 0, u_j = a/h¬≤ > 0.

  KEY PROPERTY: The inequality œÅ_j ‚â• 1 holds for ALL real Pe_j because
  x¬∑coth(x) ‚â• 1 for all x (equality only at x=0 in the limit). This guarantee
  is per-node and holds on ANY mesh (uniform or nonuniform).

  On UNIFORM meshes this guarantees system matrix (I ‚àí Œ∏¬∑dt¬∑L) is an M-matrix
  for any h > 0 and any parameter values.
  On NONUNIFORM meshes, the guarantee holds when the mesh ratio d‚Å∫/d‚Åª is
  moderate (typically < 3:1). The mMatrixViolationCount() diagnostic verifies
  this at runtime.

This ensures the system matrix (I ‚àí Œ∏¬∑dt¬∑L) is an M-matrix.

Artificial diffusion (CE-15, low-œÉ limit): ¬Ω¬∑r¬∑S¬∑ŒîS¬∑V_SS in S-space.
In log-space with uniform grid: ¬Ω¬∑b¬∑h¬∑u_xx (from the upwind limiting scheme).

NOTE ON PAPER TYPO (p. 227): The upwind scheme formulas on p. 227 show a
denominator of 2h, but direct computation shows the correct denominator is h.
The subsequent consistency analysis (eq. 7) and numerical diffusion formula
¬ΩŒºh¬∑V_SS are correct ‚Äî they correspond to the actual limiting scheme with h.

NONUNIFORM GRID NOTE: For non-uniform meshes, compute a per-node effective
spacing consistent with QuantLib's derivative operators:
  h_j := 0.5*(dplus_j + dminus_j)
At boundary nodes (first/last), dplus or dminus is Null<Real>(); skip these
nodes in per-node computations (they are handled by boundary conditions).

‚ïê‚ïê‚ïê SCHEME 2: CN VARIANT WITH MODIFIED REACTION TERM (CE-16 through CE-23) ‚ïê‚ïê‚ïê

The paper's CN variant replaces ‚àír¬∑u_j with the 6-node stencil:
  ‚àír¬∑[œâ¬∑u_{j‚àí1} + (1‚àí2œâ)¬∑u_j + œâ¬∑u_{j+1}]
at each time level, with œâ‚ÇÅ = œâ‚ÇÇ = œâ (symmetric weighting).

PARAMETER CHOICE (CE-19):
  œâ = ‚àír/(16œÉ¬≤)

EFFECTIVE-DIFFUSION REFORMULATION FOR LOG-SPACE ASSEMBLY:
  The paper's CN variant applies the FULL off-diagonal reaction weight œâ at
  each time level (eq. 8: each level sums to ¬Ω, but œâ appears unsplit).
  Standard CN time-stepping halves the operator. To compensate, the spatial
  operator L must contain 2|rœâ| on its off-diagonals so that after CN's
  ¬Ω-factor, the system matrix reproduces the paper's P and N.

  This is mathematically equivalent to using an enhanced diffusion coefficient:
    a_eff = œÉ¬≤/2 + r¬≤¬∑h¬≤/(8¬∑œÉ¬≤)
  with the standard reaction term ‚àír, assembled via the standard axpyb() pattern.

  PROOF: With a_eff, standard CN produces system matrix P = I ‚àí ¬ΩŒît¬∑L where:
    L_lower = a_eff/h¬≤ ‚àí b/(2h) = œÉ¬≤/(2h¬≤) + r¬≤/(8œÉ¬≤) ‚àí b/(2h)
    P_lower = ‚àí¬ΩŒît¬∑L_lower
    The additional off-diagonal vs standard CN: ‚àí¬ΩŒît¬∑r¬≤/(8œÉ¬≤) = ‚àíŒît¬∑r¬≤/(16œÉ¬≤)

    In the paper's S-space P matrix (Document 5, p. 228), the additional
    off-diagonal from the distributed reaction is rœâ‚ÇÇ = ‚àír¬≤/(16œÉ¬≤), which
    when multiplied by Œît (to convert from the paper's 1/Œît-normalized form)
    gives ‚àíŒît¬∑r¬≤/(16œÉ¬≤). These match. ‚àé

  IMPORTANT: The coefficient is r¬≤h¬≤/(8œÉ¬≤), NOT r¬≤h¬≤/(16œÉ¬≤).
  The factor-of-2 arises because the paper places FULL œâ at each CN time level
  while standard CN halves the operator contribution. Without the doubling, we
  would get r¬≤h¬≤/(16œÉ¬≤) ‚Äî which is wrong by exactly a factor of 2.

M-MATRIX GUARANTEE FOR CN VARIANT (corrected from audit ¬ß4b):
  In S-space, the P lower entry with œâ = ‚àír/(16œÉ¬≤) is:
    P_lower = rœâ + rS_j/(4ŒîS) ‚àí œÉ¬≤S_j¬≤/(4ŒîS¬≤)
            = ‚àír¬≤/(16œÉ¬≤) + rj/4 ‚àí œÉ¬≤j¬≤/4     (where j = S_j/ŒîS)
  Completing the square:
    = ‚àí(œÉ¬≤/4)¬∑(j ‚àí r/(2œÉ¬≤))¬≤
  This is a SINGLE non-positive perfect square: P_lower ‚â§ 0 for ALL j ‚â• 0.
  Similarly, P_upper = ‚àír¬≤/(16œÉ¬≤) ‚àí rj/4 ‚àí œÉ¬≤j¬≤/4 < 0 for j > 0.
  Therefore P is ALWAYS an M-matrix, unconditionally ‚Äî no parameter
  restrictions needed for the off-diagonals.

  In log-space, the equivalent condition on the L operator (L_lower ‚â• 0) is:
    a_eff/h¬≤ ‚àí b/(2h) ‚â• 0,  i.e.,  a_eff ‚â• bh/2
  Since a_eff = œÉ¬≤/2 + r¬≤h¬≤/(8œÉ¬≤) and b ‚âà r for q=0, œÉ‚â™r:
    r¬≤h¬≤/(8œÉ¬≤) ‚â• rh/2  ‚ü∫  rh/(4œÉ¬≤) ‚â• 1  ‚ü∫  h ‚â• 4œÉ¬≤/r
  For œÉ=0.001, r=0.05: h ‚â• 8√ó10‚Åª‚Åµ ‚Äî effectively always satisfied.

TIME-STEP CONSTRAINT (CE-20, log-space form):
  For N ‚â• 0 (explicit-side diagonal non-negative):
    1 ‚àí 0.5¬∑Œît¬∑(2¬∑a_eff/h¬≤ + r) ‚â• 0
  ‚üπ  Œît < 1 / [œÉ¬≤/(2h¬≤) + r¬≤/(8œÉ¬≤) + r/2]
  This is less restrictive than the S-space form (no growing (œÉM)¬≤ term)
  but still very tight for small œÉ. For œÉ=0.001, r=0.05, h=0.01:
  the r¬≤/(8œÉ¬≤) = 312.5 term dominates, giving Œît < 0.0032.

ACCURACY CONSTRAINTS (from audit ¬ß5b):
  Scheme 1 numerical diffusion (S-space): ¬ΩrSŒîS¬∑V_SS
  For this to be negligible vs physical diffusion ¬ΩœÉ¬≤S¬≤¬∑V_SS:
    ŒîS ‚â™ œÉ¬≤S/r
  At S=100, œÉ=0.001, r=0.05: ŒîS ‚â™ 0.002. With ŒîS=0.05, numerical diffusion
  is ~25√ó the physical diffusion ‚Äî the solution is heavily smeared.

  Scheme 2 numerical diffusion (S-space): ‚Öõ(rŒîS/œÉ)¬≤¬∑V_SS
  For this ‚â™ ¬ΩœÉ¬≤S¬≤¬∑V_SS: need (rŒîS/œÉ)¬≤ ‚â™ 4œÉ¬≤S¬≤
  Equivalently: ŒîS ‚â™ 2œÉ¬≤S/r (same order as Scheme 1 at moderate S).

  In log-space with uniform h:
    Scheme 1 diffusion: ¬Ωbh¬∑u_xx ‚Üí need h ‚â™ 2a/b = œÉ¬≤/(r‚àíq‚àíœÉ¬≤/2) ‚âà œÉ¬≤/r
    Scheme 2 diffusion: r¬≤h¬≤/(8œÉ¬≤)¬∑u_xx ‚Üí need h ‚â™ 2œÉ/r (from r¬≤h¬≤/(8œÉ¬≤) ‚â™ œÉ¬≤/2)

  PRACTICAL GUIDELINE: For œÉ=0.001, r=0.05, both schemes need h ‚â≤ 2√ó10‚Åª‚Åµ
  (roughly 50,000+ log-space nodes on [ln(50), ln(150)]) for diffusion-free
  accuracy. Coarser grids are usable but introduce measurable smearing.

SCHEME CROSSOVER ANALYSIS (from audit ¬ß5c):
  The two numerical diffusion terms are equal (in S-space) when:
    ¬ΩrSŒîS = ‚Öõ(rŒîS/œÉ)¬≤  ‚üπ  ŒîS = 4œÉ¬≤S/r
  For coarser grids (ŒîS > 4œÉ¬≤S/r), Scheme 1 has LESS diffusion.
  For finer grids, Scheme 2 wins due to its ŒîS¬≤ dependence.
  For œÉ=0.001, r=0.05, S=100: crossover at ŒîS ‚âà 0.008.

Artificial diffusion (CE-23): ‚Öõ¬∑(r¬∑ŒîS/œÉ)¬≤¬∑V_SS in S-space.

NOTE ON FittedCrankNicolson POSITIVITY ANALYSIS:
  Combining Scheme 1's fitted operator with CN time-stepping:
  - P = I ‚àí ¬ΩŒît¬∑L: off-diag = ‚àí¬ΩŒît¬∑(fitted L off-diag) ‚â§ 0 (M-matrix ‚úì)
    because fitted L off-diags are ‚â• 0 (proven above).
  - N = I + ¬ΩŒît¬∑L: off-diag = ¬ΩŒît¬∑(fitted L off-diag) ‚â• 0 (non-negative ‚úì)
  - N diagonal requires: 1 ‚àí ¬ΩŒît¬∑(2aœÅ/h¬≤ + r) ‚â• 0
    ‚üπ Œît ‚â§ 1/(aœÅ_max/h¬≤ + r/2)
  Since œÅ_max ‚âà |Pe_max| for large Pe, and Pe = bh/(2a):
    Œît ‚â§ 1/(|b|/(2h) + r/2)
  This is LESS restrictive than the CN variant's constraint (no r¬≤/(8œÉ¬≤) term)
  and may be preferable for very low volatility. However, the temporal accuracy
  is O(Œît¬≤) only, not the CN variant's O(Œît¬≤,h¬≤) ‚Äî the spatial accuracy is
  O(h) from the fitting.

‚ïê‚ïê‚ïê DISCRETE BARRIER MONITORING (CE-6) ‚ïê‚ïê‚ïê

At each monitoring date t_i, after the time-step solve:
  U_j ‚Üê U_j ¬∑ ùüô_{[L,U]}(S_j)
This re-introduces discontinuities that the schemes must handle.

GRID ALIGNMENT REQUIREMENT:
  The barrier values L, U (and ideally the strike K) should be GRID POINTS.
  The paper uses ŒîS=0.05 with L=90, K=100, U=110 ‚Äî all exact multiples.
  Violating this introduces interpolation error that can reintroduce oscillations.
  In log-space: ln(L), ln(U), ln(K) should be mesher locations. QuantLib's
  Concentrating1dMesher can place nodes at specified points. The
  FdmBlackScholesMesher already concentrates aROUND the strike; users should
  also ensure barrier locations are mesher concentration points.

S_MAX SELECTION (from Document 1, Eq. 5.2):
  S_max = max{R¬∑K, K¬∑exp(‚àö(2TœÉ¬≤¬∑ln 100))},  R ‚â• 2
  For very low œÉ: S_max = R¬∑K (rule of thumb: 3‚Äì4 times the strike).
  For moderate œÉ: the exponential term dominates.
  In log-space: x_max = ln(S_max), x_min = ln(S_min) with S_min small but >0.

‚ïê‚ïê‚ïê M-MATRIX DIAGNOSTIC (CE-10, Proposition 4.1) ‚ïê‚ïê‚ïê

For the operator L stored in mapT_, the M-matrix condition for the system
matrix (I ‚àí Œ∏¬∑dt¬∑L) requires:
  All off-diagonals of L (lower_[] and upper_[]) must be NON-NEGATIVE.
  (Because system off-diag = ‚àíŒ∏¬∑dt¬∑(operator off-diag), and Œ∏¬∑dt > 0.)

To access protected lower_[]/upper_[] arrays of TripleBandLinearOp, construct
a temporary ModTripleBandLinearOp from mapT_ and use its public accessors.

‚ïê‚ïê‚ïê NOTE ON FittedCrankNicolson COMBINATION ‚ïê‚ïê‚ïê

The paper uses Scheme 1 (fitted operator) with fully-implicit time stepping ONLY.
The FittedCrankNicolson factory (Scheme 1 operator + CN time stepping) is a
natural EXTENSION not present in the original paper. It may offer improved
temporal accuracy but its M-matrix and positivity properties differ from the
paper's proven guarantees. See the positivity analysis above for details.
Use with appropriate testing.

‚ïê‚ïê‚ïê LOCAL VOLATILITY CAVEAT ‚ïê‚ïê‚ïê

With local or stochastic volatility, œÉ = œÉ(S,t):
- The fitting factor must be recomputed every time step (handled by setTime())
- The CN variant parameter œâ = ‚àír/(16œÉ¬≤) becomes spatially varying
- The M-matrix guarantees remain valid per-node (the algebraic identities
  hold for any œÉ_j > 0) but the time-step constraint for the CN variant
  becomes node-dependent; use the worst-case node.
- Positivity guarantees for the quanto-adjusted case have NOT been verified.
</mathematical_context>

<task>
ROUND 6 OF 7: Create a comprehensive test file that validates implementations
against the paper's numerical examples and theoretical guarantees.

OUTPUT: 1 file (test implementation).

FACT-CHECK (mandatory; do not print):
- Inspect any provided test file to confirm framework (Boost.Test, custom
  macros) and naming/registration conventions.
- If no test file is provided, STOP and ask for one.
</task>

<source_files>
All output headers from ROUNDs 1-5:
[>>> ATTACH HERE: output file(s) generated in Round(s) 1, 2, 3, 4, 5 <<<]

QuantLib test infrastructure:
FILE: test-suite/utilities.hpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_test_utilities_hpp
#define quantlib_test_utilities_hpp

#include <ql/indexes/indexmanager.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/exercise.hpp>
#include <ql/instruments/barriertype.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/termstructures/volatility/equityfx/blackvoltermstructure.hpp>
#include <ql/quote.hpp>
#include <ql/patterns/observable.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <boost/test/unit_test.hpp>
#if BOOST_VERSION < 105900
#include <boost/test/floating_point_comparison.hpp>
#else
#include <boost/test/tools/floating_point_comparison.hpp>
#endif
#include <cmath>
#include <iomanip>
#include <numeric>
#include <string>
#include <utility>
#include <vector>

// This adapts the BOOST_CHECK_SMALL and BOOST_CHECK_CLOSE macros to
// support a struct as Real for arguments, while fully transparant to regular doubles.
// Unfortunately boost does not provide a portable way to customize these macros' behaviour,
// so we need to define wrapper macros QL_CHECK_SMALL etc.
//
// It is required to have a function `value` defined that returns the double-value
// of the Real type (or a value function in the Real type's namespace for ADT).

namespace QuantLib {
    // overload this function in case Real is something different - it should alway return double
    inline double value(double x) {
        return x;
    }
}

using QuantLib::value;

#define QL_CHECK_SMALL(FPV, T)  BOOST_CHECK_SMALL(value(FPV), value(T))
#define QL_CHECK_CLOSE(L, R, T) BOOST_CHECK_CLOSE(value(L), value(R), value(T))
#define QL_CHECK_CLOSE_FRACTION(L, R, T) BOOST_CHECK_CLOSE_FRACTION(value(L), value(R), value(T))

namespace QuantLib {

    std::string payoffTypeToString(const ext::shared_ptr<Payoff>&);
    std::string exerciseTypeToString(const ext::shared_ptr<Exercise>&);
    std::string barrierTypeToString(Barrier::Type type);


    ext::shared_ptr<YieldTermStructure>
    flatRate(const Date& today,
             const ext::shared_ptr<Quote>& forward,
             const DayCounter& dc);

    ext::shared_ptr<YieldTermStructure>
    flatRate(const Date& today,
             Rate forward,
             const DayCounter& dc);

    ext::shared_ptr<YieldTermStructure>
    flatRate(const ext::shared_ptr<Quote>& forward,
             const DayCounter& dc);

    ext::shared_ptr<YieldTermStructure>
    flatRate(Rate forward,
             const DayCounter& dc);


    ext::shared_ptr<BlackVolTermStructure>
    flatVol(const Date& today,
            const ext::shared_ptr<Quote>& volatility,
            const DayCounter& dc);

    ext::shared_ptr<BlackVolTermStructure>
    flatVol(const Date& today,
            Volatility volatility,
            const DayCounter& dc);

    ext::shared_ptr<BlackVolTermStructure>
    flatVol(const ext::shared_ptr<Quote>& volatility,
            const DayCounter& dc);

    ext::shared_ptr<BlackVolTermStructure>
    flatVol(Volatility volatility,
            const DayCounter& dc);


    Real relativeError(Real x1, Real x2, Real reference);

    //bool checkAbsError(Real x1, Real x2, Real tolerance){
    //    return std::fabs(x1 - x2) < tolerance;
    //};

    class Flag : public QuantLib::Observer {
      private:
        bool up_ = false;

      public:
        Flag() = default;
        void raise() { up_ = true; }
        void lower() { up_ = false; }
        bool isUp() const { return up_; }
        void update() override { raise(); }
    };

    template<class Iterator>
    Real norm(const Iterator& begin, const Iterator& end, Real h) {
        // squared values
        std::vector<Real> f2(end-begin);
        std::transform(begin, end, begin, f2.begin(), std::multiplies<>());
        // numeric integral of f^2
        Real I = h * (std::accumulate(f2.begin(),f2.end(),Real(0.0))
                      - 0.5*f2.front() - 0.5*f2.back());
        return std::sqrt(I);
    }


    inline Integer timeToDays(Time t, Integer daysPerYear = 360) {
        return Integer(std::lround(t * daysPerYear));
    }


    // Used to check that an exception message contains the expected message string
    struct ExpectedErrorMessage {

        explicit ExpectedErrorMessage(std::string msg) : expected(std::move(msg)) {}

        bool operator()(const Error& ex) const {
            std::string actual(ex.what());
            if (actual.find(expected) == std::string::npos) {
                BOOST_TEST_MESSAGE("Error expected to contain: '" << expected << "'.");
                BOOST_TEST_MESSAGE("Actual error is: '" << actual << "'.");
                return false;
            } else {
                return true;
            }
        }

        std::string expected;
    };


    // Allow streaming vectors to error messages.

    // The standard forbids defining new overloads in the std
    // namespace, so we have to use a wrapper instead of overloading
    // operator<< to send a vector to the stream directly.
    // Defining the overload outside the std namespace wouldn't work
    // with Boost streams because of ADT name lookup rules.

    template <class T>
    struct vector_streamer {
        explicit vector_streamer(std::vector<T> v) : v(std::move(v)) {}
        std::vector<T> v;
    };

    template <class T>
    vector_streamer<T> to_stream(const std::vector<T>& v) {
        return vector_streamer<T>(v);
    }

    template <class T>
    std::ostream& operator<<(std::ostream& out, const vector_streamer<T>& s) {
        out << "{ ";
        if (!s.v.empty()) {
            for (size_t n=0; n<s.v.size()-1; ++n)
                out << s.v[n] << ", ";
            out << s.v.back();
        }
        out << " }";
        return out;
    }


}


#endif


FILE: test-suite/americanoption.cpp (registration pattern reference)
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2005, 2007 StatPro Italia srl
 Copyright (C) 2005 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include "preconditions.hpp"
#include "toplevelfixture.hpp"
#include "utilities.hpp"
#include <ql/any.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/integrals/gausslobattointegral.hpp>
#include <ql/math/integrals/integral.hpp>
#include <ql/math/randomnumbers/rngtraits.hpp>
#include <ql/math/statistics/incrementalstatistics.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/baroneadesiwhaleyengine.hpp>
#include <ql/pricingengines/vanilla/bjerksundstenslandengine.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesshoutengine.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesvanillaengine.hpp>
#include <ql/pricingengines/vanilla/juquadraticengine.hpp>
#include <ql/pricingengines/vanilla/qdfpamericanengine.hpp>
#include <ql/pricingengines/vanilla/qdplusamericanengine.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <map>

using namespace QuantLib;
using namespace boost::unit_test_framework;

BOOST_FIXTURE_TEST_SUITE(QuantLibTests, TopLevelFixture)

BOOST_AUTO_TEST_SUITE(AmericanOptionTests)

#undef REPORT_FAILURE
#define REPORT_FAILURE(greekName, payoff, exercise, s, q, r, today, \
                       v, expected, calculated, error, tolerance) \
    BOOST_ERROR(exerciseTypeToString(exercise) << " " \
               << payoff->optionType() << " option with " \
               << payoffTypeToString(payoff) << " payoff:\n" \
               << "    spot value:       " << s << "\n" \
               << "    strike:           " << payoff->strike() << "\n" \
               << "    dividend yield:   " << io::rate(q) << "\n" \
               << "    risk-free rate:   " << io::rate(r) << "\n" \
               << "    reference date:   " << today << "\n" \
               << "    maturity:         " << exercise->lastDate() << "\n" \
               << "    volatility:       " << io::volatility(v) << "\n\n" \
               << std::fixed << std::setprecision(4) \
               << "    expected   " << greekName << ": " << expected << "\n" \
               << "    calculated " << greekName << ": " << calculated << "\n"\
               << std::scientific \
               << "    error:            " << error << "\n" \
               << "    tolerance:        " << tolerance);

struct AmericanOptionData {
    Option::Type type;
    Real strike;
    Real s;        // spot
    Rate q;        // dividend
    Rate r;        // risk-free rate
    Time t;        // time to maturity
    Volatility v;  // volatility
    Real result;   // expected result
};

BOOST_AUTO_TEST_CASE(testBaroneAdesiWhaleyValues) {

    BOOST_TEST_MESSAGE("Testing Barone-Adesi and Whaley approximation "
                       "for American options...");

    /* The data below are from
       "Option pricing formulas", E.G. Haug, McGraw-Hill 1998
       pag 24

       The following values were replicated only up to the second digit
       by the VB code provided by Haug, which was used as base for the
       C++ implementation

    */
    AmericanOptionData values[] = {
      //        type, strike,   spot,    q,    r,    t,  vol,   value
      { Option::Call, 100.00,  90.00, 0.10, 0.10, 0.10, 0.15,  0.0206 },
      { Option::Call, 100.00, 100.00, 0.10, 0.10, 0.10, 0.15,  1.8771 },
      { Option::Call, 100.00, 110.00, 0.10, 0.10, 0.10, 0.15, 10.0089 },
      { Option::Call, 100.00,  90.00, 0.10, 0.10, 0.10, 0.25,  0.3159 },
      { Option::Call, 100.00, 100.00, 0.10, 0.10, 0.10, 0.25,  3.1280 },
      { Option::Call, 100.00, 110.00, 0.10, 0.10, 0.10, 0.25, 10.3919 },
      { Option::Call, 100.00,  90.00, 0.10, 0.10, 0.10, 0.35,  0.9495 },
      { Option::Call, 100.00, 100.00, 0.10, 0.10, 0.10, 0.35,  4.3777 },
      { Option::Call, 100.00, 110.00, 0.10, 0.10, 0.10, 0.35, 11.1679 },
      { Option::Call, 100.00,  90.00, 0.10, 0.10, 0.50, 0.15,  0.8208 },
      { Option::Call, 100.00, 100.00, 0.10, 0.10, 0.50, 0.15,  4.0842 },
      { Option::Call, 100.00, 110.00, 0.10, 0.10, 0.50, 0.15, 10.8087 },
      { Option::Call, 100.00,  90.00, 0.10, 0.10, 0.50, 0.25,  2.7437 },
      { Option::Call, 100.00, 100.00, 0.10, 0.10, 0.50, 0.25,  6.8015 },
      { Option::Call, 100.00, 110.00, 0.10, 0.10, 0.50, 0.25, 13.0170 },
      { Option::Call, 100.00,  90.00, 0.10, 0.10, 0.50, 0.35,  5.0063 },
      { Option::Call, 100.00, 100.00, 0.10, 0.10, 0.50, 0.35,  9.5106 },
      { Option::Call, 100.00, 110.00, 0.10, 0.10, 0.50, 0.35, 15.5689 },
      { Option::Put,  100.00,  90.00, 0.10, 0.10, 0.10, 0.15, 10.0000 },
      { Option::Put,  100.00, 100.00, 0.10, 0.10, 0.10, 0.15,  1.8770 },
      { Option::Put,  100.00, 110.00, 0.10, 0.10, 0.10, 0.15,  0.0410 },
      { Option::Put,  100.00,  90.00, 0.10, 0.10, 0.10, 0.25, 10.2533 },
      { Option::Put,  100.00, 100.00, 0.10, 0.10, 0.10, 0.25,  3.1277 },
      { Option::Put,  100.00, 110.00, 0.10, 0.10, 0.10, 0.25,  0.4562 },
      { Option::Put,  100.00,  90.00, 0.10, 0.10, 0.10, 0.35, 10.8787 },
      { Option::Put,  100.00, 100.00, 0.10, 0.10, 0.10, 0.35,  4.3777 },
      { Option::Put,  100.00, 110.00, 0.10, 0.10, 0.10, 0.35,  1.2402 },
      { Option::Put,  100.00,  90.00, 0.10, 0.10, 0.50, 0.15, 10.5595 },
      { Option::Put,  100.00, 100.00, 0.10, 0.10, 0.50, 0.15,  4.0842 },
      { Option::Put,  100.00, 110.00, 0.10, 0.10, 0.50, 0.15,  1.0822 },
      { Option::Put,  100.00,  90.00, 0.10, 0.10, 0.50, 0.25, 12.4419 },
      { Option::Put,  100.00, 100.00, 0.10, 0.10, 0.50, 0.25,  6.8014 },
      { Option::Put,  100.00, 110.00, 0.10, 0.10, 0.50, 0.25,  3.3226 },
      { Option::Put,  100.00,  90.00, 0.10, 0.10, 0.50, 0.35, 14.6945 },
      { Option::Put,  100.00, 100.00, 0.10, 0.10, 0.50, 0.35,  9.5104 },
      { Option::Put,  100.00, 110.00, 0.10, 0.10, 0.50, 0.35,  5.8823 },
      { Option::Put,  100.00, 100.00, 0.00, 0.00, 0.50, 0.15,  4.2294 }
    };

    Date today = Date::todaysDate();
    DayCounter dc = Actual360();
    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    Real tolerance = 3.0e-3;

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(value.type, value.strike));
        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(
                                         new AmericanExercise(today, exDate));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));

        ext::shared_ptr<PricingEngine> engine(
                      new BaroneAdesiWhaleyApproximationEngine(stochProcess));

        VanillaOption option(payoff, exercise);
        option.setPricingEngine(engine);

        Real calculated = option.NPV();
        Real error = std::fabs(calculated - value.result);
        if (error > tolerance) {
            REPORT_FAILURE("value", payoff, exercise, value.s, value.q, value.r, today, value.v,
                           value.result, calculated, error, tolerance);
        }
    }
}

BOOST_AUTO_TEST_CASE(testBjerksundStenslandValues) {

    BOOST_TEST_MESSAGE("Testing Bjerksund and Stensland approximation "
                       "for American options...");

    AmericanOptionData values[] = {
        //      type, strike,   spot,    q,    r,    t,  vol,   value, tol
        // from "Option pricing formulas", Haug, McGraw-Hill 1998, pag 27
      { Option::Call,  40.00,  42.00, 0.08, 0.04, 0.75, 0.35,  5.2704 },
        // from "Option pricing formulas", Haug, McGraw-Hill 1998, VBA code
      { Option::Put,   40.00,  36.00, 0.00, 0.06, 1.00, 0.20,  4.4531 },
        // ATM option with very small volatility, reference value taken from R
      { Option::Call, 100, 100, 0.05, 0.05, 1.0, 0.0021, 0.08032314 },
        // ATM option with very small volatility,
        // reference value taken from Barone-Adesi and Whaley Approximation
      { Option::Call, 100, 100, 0.05, 0.05, 1.0, 0.0001, 0.003860656 },
      { Option::Call, 100, 99.99, 0.05, 0.05, 1.0, 0.0001, 0.00081 },
        // ITM option with a very small volatility
      { Option::Call, 100, 110, 0.05, 0.05, 1.0, 0.0001, 10.0 },
      { Option::Put, 110, 100, 0.05, 0.05, 1.0, 0.0001, 10.0 },
        // ATM option with a very large volatility
      { Option::Put, 100, 110, 0.05, 0.05, 1.0, 10, 95.12289 }
    };

    Date today = Date::todaysDate();
    DayCounter dc = Actual360();
    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    Real tolerance = 5.0e-5;

    for (auto& value : values) {

        ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(value.type, value.strike));
        Date exDate = today + timeToDays(value.t);
        ext::shared_ptr<Exercise> exercise(new AmericanExercise(today, exDate));

        spot->setValue(value.s);
        qRate->setValue(value.q);
        rRate->setValue(value.r);
        vol->setValue(value.v);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));

        ext::shared_ptr<PricingEngine> engine(
                     new BjerksundStenslandApproximationEngine(stochProcess));

        VanillaOption option(payoff, exercise);
        option.setPricingEngine(engine);

        Real calculated = option.NPV();
        Real error = std::fabs(calculated - value.result);
        if (error > tolerance) {
            REPORT_FAILURE("value", payoff, exercise, value.s, value.q, value.r, today, value.v,
                           value.result, calculated, error, tolerance);
        }
    }
}

/* The data below are from
   An Approximate Formula for Pricing American Options
   Journal of Derivatives Winter 1999
   Ju, N.
*/
AmericanOptionData juValues[] = {
    //        type, strike,   spot,    q,    r,    t,     vol,   value, tol
    // These values are from Exhibit 3 - Short dated Put Options
    { Option::Put, 35.00,   40.00,  0.0,  0.0488, 0.0833,  0.2,  0.006 },
    { Option::Put, 35.00,   40.00,  0.0,  0.0488, 0.3333,  0.2,  0.201 },
    { Option::Put, 35.00,   40.00,  0.0,  0.0488, 0.5833,  0.2,  0.433 },

    { Option::Put, 40.00,   40.00,  0.0,  0.0488, 0.0833,  0.2,  0.851 },
    { Option::Put, 40.00,   40.00,  0.0,  0.0488, 0.3333,  0.2,  1.576 },
    { Option::Put, 40.00,   40.00,  0.0,  0.0488, 0.5833,  0.2,  1.984 },

    { Option::Put, 45.00,   40.00,  0.0,  0.0488, 0.0833,  0.2,  5.000 },
    { Option::Put, 45.00,   40.00,  0.0,  0.0488, 0.3333,  0.2,  5.084 },
    { Option::Put, 45.00,   40.00,  0.0,  0.0488, 0.5833,  0.2,  5.260 },

    { Option::Put, 35.00,   40.00,  0.0,  0.0488, 0.0833,  0.3,  0.078 },
    { Option::Put, 35.00,   40.00,  0.0,  0.0488, 0.3333,  0.3,  0.697 },
    { Option::Put, 35.00,   40.00,  0.0,  0.0488, 0.5833,  0.3,  1.218 },

    { Option::Put, 40.00,   40.00,  0.0,  0.0488, 0.0833,  0.3,  1.309 },
    { Option::Put, 40.00,   40.00,  0.0,  0.0488, 0.3333,  0.3,  2.477 },
    { Option::Put, 40.00,   40.00,  0.0,  0.0488, 0.5833,  0.3,  3.161 },

    { Option::Put, 45.00,   40.00,  0.0,  0.0488, 0.0833,  0.3,  5.059 },
    { Option::Put, 45.00,   40.00,  0.0,  0.0488, 0.3333,  0.3,  5.699 },
    { Option::Put, 45.00,   40.00,  0.0,  0.0488, 0.5833,  0.3,  6.231 },

    { Option::Put, 35.00,   40.00,  0.0,  0.0488, 0.0833,  0.4,  0.247 },
    { Option::Put, 35.00,   40.00,  0.0,  0.0488, 0.3333,  0.4,  1.344 },
    { Option::Put, 35.00,   40.00,  0.0,  0.0488, 0.5833,  0.4,  2.150 },

    { Option::Put, 40.00,   40.00,  0.0,  0.0488, 0.0833,  0.4,  1.767 },
    { Option::Put, 40.00,   40.00,  0.0,  0.0488, 0.3333,  0.4,  3.381 },
    { Option::Put, 40.00,   40.00,  0.0,  0.0488, 0.5833,  0.4,  4.342 },

    { Option::Put, 45.00,   40.00,  0.0,  0.0488, 0.0833,  0.4,  5.288 },
    { Option::Put, 45.00,   40.00,  0.0,  0.0488, 0.3333,  0.4,  6.501 },
    { Option::Put, 45.00,   40.00,  0.0,  0.0488, 0.5833,  0.4,  7.367 },

    // Type in Exhibits 4 and 5 if you have some spare time ;-)

    //        type, strike,   spot,    q,    r,    t,     vol,   value, tol
    // values from Exhibit 6 - Long dated Call Options with dividends
    { Option::Call, 100.00,   80.00,  0.07,  0.03, 3.0,  0.2,   2.605 },
    { Option::Call, 100.00,   90.00,  0.07,  0.03, 3.0,  0.2,   5.182 },
    { Option::Call, 100.00,  100.00,  0.07,  0.03, 3.0,  0.2,   9.065 },
    { Option::Call, 100.00,  110.00,  0.07,  0.03, 3.0,  0.2,  14.430 },
    { Option::Call, 100.00,  120.00,  0.07,  0.03, 3.0,  0.2,  21.398 },

    { Option::Call, 100.00,   80.00,  0.07,  0.03, 3.0,  0.4,  11.336 },
    { Option::Call, 100.00,   90.00,  0.07,  0.03, 3.0,  0.4,  15.711 },
    { Option::Call, 100.00,  100.00,  0.07,  0.03, 3.0,  0.4,  20.760 },
    { Option::Call, 100.00,  110.00,  0.07,  0.03, 3.0,  0.4,  26.440 },
    { Option::Call, 100.00,  120.00,  0.07,  0.03, 3.0,  0.4,  32.709 },

    { Option::Call, 100.00,   80.00,  0.07,  0.00001, 3.0,  0.3,   5.552 },
    { Option::Call, 100.00,   90.00,  0.07,  0.00001, 3.0,  0.3,   8.868 },
    { Option::Call, 100.00,  100.00,  0.07,  0.00001, 3.0,  0.3,  13.158 },
    { Option::Call, 100.00,  110.00,  0.07,  0.00001, 3.0,  0.3,  18.458 },
    { Option::Call, 100.00,  120.00,  0.07,  0.00001, 3.0,  0.3,  24.786 },

    { Option::Call, 100.00,   80.00,  0.03,  0.07, 3.0,  0.3,  12.177 },
    { Option::Call, 100.00,   90.00,  0.03,  0.07, 3.0,  0.3,  17.411 },
    { Option::Call, 100.00,  100.00,  0.03,  0.07, 3.0,  0.3,  23.402 },
    { Option::Call, 100.00,  110.00,  0.03,  0.07, 3.0,  0.3,  30.028 },
    { Option::Call, 100.00,  120.00,  0.03,  0.07, 3.0,  0.3,  37.177 }
};


BOOST_AUTO_TEST_CASE(testJuValues) {

    BOOST_TEST_MESSAGE("Testing Ju approximation for American options...");

    Date today = Date::todaysDate();
    DayCounter dc = Actual360();
    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    Real tolerance = 1.0e-3;

    for (auto& juValue : juValues) {

        ext::shared_ptr<StrikedTypePayoff> payoff(
            new PlainVanillaPayoff(juValue.type, juValue.strike));
        Date exDate = today + timeToDays(juValue.t);
        ext::shared_ptr<Exercise> exercise(
                                         new AmericanExercise(today, exDate));

        spot->setValue(juValue.s);
        qRate->setValue(juValue.q);
        rRate->setValue(juValue.r);
        vol->setValue(juValue.v);

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));

        ext::shared_ptr<PricingEngine> engine(
                            new JuQuadraticApproximationEngine(stochProcess));

        VanillaOption option(payoff, exercise);
        option.setPricingEngine(engine);

        Real calculated = option.NPV();
        Real error = std::fabs(calculated - juValue.result);
        if (error > tolerance) {
            REPORT_FAILURE("value", payoff, exercise, juValue.s, juValue.q, juValue.r, today,
                           juValue.v, juValue.result, calculated, error, tolerance);
        }
    }
}

BOOST_AUTO_TEST_CASE(testFdValues) {

    BOOST_TEST_MESSAGE("Testing finite-difference and QR+ engine "
                       "for American options...");

    Date today = Date::todaysDate();
    DayCounter dc = Actual360();
    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> qTS = flatRate(today, qRate, dc);
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    ext::shared_ptr<YieldTermStructure> rTS = flatRate(today, rRate, dc);
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    ext::shared_ptr<BlackVolTermStructure> volTS = flatVol(today, vol, dc);

    Real tolerance = 8.0e-2;

    ext::shared_ptr<BlackScholesMertonProcess> stochProcess =
        ext::make_shared<BlackScholesMertonProcess>(
            Handle<Quote>(spot),
            Handle<YieldTermStructure>(qTS),
            Handle<YieldTermStructure>(rTS),
            Handle<BlackVolTermStructure>(volTS));

    ext::shared_ptr<PricingEngine> pdeEngine =
        ext::make_shared<FdBlackScholesVanillaEngine>(stochProcess, 100, 400);

    ext::shared_ptr<PricingEngine> qrPlusEngine =
        ext::make_shared<FdBlackScholesVanillaEngine>(stochProcess);

    for (auto& juValue : juValues) {

        ext::shared_ptr<StrikedTypePayoff> payoff(
            new PlainVanillaPayoff(juValue.type, juValue.strike));

        Date exDate = today + timeToDays(juValue.t);
        ext::shared_ptr<Exercise> exercise(
                                         new AmericanExercise(today, exDate));

        spot->setValue(juValue.s);
        qRate->setValue(juValue.q);
        rRate->setValue(juValue.r);
        vol->setValue(juValue.v);

        VanillaOption option(payoff, exercise);
        option.setPricingEngine(pdeEngine);

        Real pdeCalculated = option.NPV();
        Real error = std::fabs(pdeCalculated - juValue.result);
        if (error > tolerance) {
            REPORT_FAILURE("value", payoff, exercise, juValue.s, juValue.q, juValue.r, today,
                           juValue.v, juValue.result, pdeCalculated, error, tolerance);
        }

        option.setPricingEngine(qrPlusEngine);

        Real qrPlusCalculated = option.NPV();
        if (std::abs(pdeCalculated - qrPlusCalculated) > 2e-2)
            BOOST_FAIL("QR+ boundary approximation failed to "
                    "reproduce PDE value for "
                    << "\n    OptionType: " <<
                    ((juValue.type == Option::Call)? "Call" : "Put")
                    << std::setprecision(16)
                    << "\n    spot:       " << spot->value()
                    << "\n    strike:     " << juValue.strike
                    << "\n    r:          " << rRate->value()
                    << "\n    q:          " << qRate->value()
                    << "\n    vol:        " << vol->value()
                    << "\n    PDE value:  " << pdeCalculated
                    << "\n    QR+ value:  " << qrPlusCalculated);
    }
}


template <class Engine>
void testFdGreeks() {

    std::map<std::string,Real> calculated, expected, tolerance;
    tolerance["delta"]  = 7.0e-4;
    tolerance["gamma"]  = 2.0e-4;
    //tolerance["theta"]  = 1.0e-4;

    Option::Type types[] = { Option::Call, Option::Put };
    Real strikes[] = { 50.0, 99.5, 100.0, 100.5, 150.0 };
    Real underlyings[] = { 100.0 };
    Rate qRates[] = { 0.04, 0.05, 0.06 };
    Rate rRates[] = { 0.01, 0.05, 0.15 };
    Integer years[] = { 1, 2 };
    Volatility vols[] = { 0.11, 0.50, 1.20 };

    DayCounter dc = Actual360();
    Date today = Date::todaysDate();
    Settings::instance().evaluationDate() = today;

    ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(0.0));
    ext::shared_ptr<SimpleQuote> qRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> qTS(flatRate(qRate, dc));
    ext::shared_ptr<SimpleQuote> rRate(new SimpleQuote(0.0));
    Handle<YieldTermStructure> rTS(flatRate(rRate, dc));
    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.0));
    Handle<BlackVolTermStructure> volTS(flatVol(vol, dc));

    ext::shared_ptr<StrikedTypePayoff> payoff;

    for (auto& type : types) {
        for (Real strike : strikes) {
            for (int year : years) {
                Date exDate = today + year * Years;
                ext::shared_ptr<Exercise> exercise(new AmericanExercise(today, exDate));
                ext::shared_ptr<StrikedTypePayoff> payoff(new PlainVanillaPayoff(type, strike));
                ext::shared_ptr<BlackScholesMertonProcess> stochProcess(
                    new BlackScholesMertonProcess(Handle<Quote>(spot), qTS, rTS, volTS));

                ext::shared_ptr<PricingEngine> engine(new Engine(stochProcess, 50));

                VanillaOption option(payoff, exercise);
                option.setPricingEngine(engine);

                for (Real u : underlyings) {
                    for (Real m : qRates) {
                        for (Real n : rRates) {
                            for (Real v : vols) {
                                Rate q = m, r = n;
                                spot->setValue(u);
                                qRate->setValue(q);
                                rRate->setValue(r);
                                vol->setValue(v);
                                Real value = option.NPV();
                                calculated["delta"] = option.delta();
                                calculated["gamma"] = option.gamma();
                                // calculated["theta"]  = option.theta();

                                if (value > spot->value() * 1.0e-5) {
                                    // perturb spot and get delta and gamma
                                    Real du = u * 1.0e-4;
                                    spot->setValue(u + du);
                                    Real value_p = option.NPV(), delta_p = option.delta();
                                    spot->setValue(u - du);
                                    Real value_m = option.NPV(), delta_m = option.delta();
                                    spot->setValue(u);
                                    expected["delta"] = (value_p - value_m) / (2 * du);
                                    expected["gamma"] = (delta_p - delta_m) / (2 * du);

                                    /*
                                    // perturb date and get theta
                                    Time dT = dc.yearFraction(today-1, today+1);
                                    Settings::instance().setEvaluationDate(today-1);
                                    value_m = option.NPV();
                                    Settings::instance().setEvaluationDate(today+1);
                                    value_p = option.NPV();
                                    Settings::instance().setEvaluationDate(today);
                                    expected["theta"] = (value_p - value_m)/dT;
                                    */

                                    // compare
                                    std::map<std::string, Real>::iterator it;
                                    for (it = calculated.begin(); it != calculated.end();
                                         ++it) {
                                        std::string greek = it->first;
                                        Real expct = expected[greek], calcl = calculated[greek],
                                            tol = tolerance[greek];
                                        Real error = relativeError(expct, calcl, u);
                                        if (error > tol) {
                                            REPORT_FAILURE(greek, payoff, exercise, u, q, r,
                                                           today, v, expct, calcl, error, tol);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

BOOST_AUTO_TEST_CASE(testFdAmericanGreeks) {
    BOOST_TEST_MESSAGE("Testing finite-differences American option greeks...");
    testFdGreeks<FdBlackScholesVanillaEngine>();
}

BOOST_AUTO_TEST_CASE(testFdShoutGreeks, *precondition(if_speed(Fast))) {
    BOOST_TEST_MESSAGE("Testing finite-differences shout option greeks...");
    testFdGreeks<FdBlackScholesShoutEngine>();
}

BOOST_AUTO_TEST_CASE(testFDShoutNPV) {
    BOOST_TEST_MESSAGE("Testing finite-differences shout option pricing...");

    const auto dc = Actual365Fixed();
    const auto today = Date(4, February, 2021);
    Settings::instance().evaluationDate() = today;

    const auto spot = Handle<Quote>(ext::make_shared<SimpleQuote>(100.0));
    const auto q = Handle<YieldTermStructure>(flatRate(0.03, dc));
    const auto r = Handle<YieldTermStructure>(flatRate(0.06, dc));

    const auto volTS = Handle<BlackVolTermStructure>(flatVol(0.25, dc));
    const auto process = ext::make_shared<BlackScholesMertonProcess>(
            spot, q, r, volTS);

    const auto maturityDate = today + Period(5, Years);

    struct TestDescription { Real strike; Option::Type type; Real expected; };

    const TestDescription testDescriptions[] = {
            {105, Option::Put, 19.136},
            {105, Option::Call, 28.211},
            {120, Option::Put, 28.02},
            {80, Option::Call, 40.785}
    };

    const auto engine = ext::make_shared<FdBlackScholesShoutEngine>(
        process, 400, 200);

    for (const TestDescription& desc: testDescriptions) {
        const Real strike = desc.strike;
        const Option::Type type = desc.type;

        auto option = VanillaOption(
            ext::make_shared<PlainVanillaPayoff>(type, strike),
            ext::make_shared<AmericanExercise>(maturityDate));

        option.setPricingEngine(engine);

        const Real expected = desc.expected;
        const Real tol = 2e-2;
        const Real calculated = option.NPV();
        const Real diff = std::fabs(calculated-expected);

        if (diff > tol) {
            BOOST_FAIL("failed to reproduce known shout option price for "
                    << "\n    strike:     " << strike
                    << "\n    option type:" <<
                        ((type == Option::Call)?"Call" : "Put")
                    << "\n    calculated: " << calculated
                    << "\n    expected:   " << expected
                    << "\n    difference: " << diff
                    << "\n    tolerance:  " << tol);
        }
    }
}

BOOST_AUTO_TEST_CASE(testZeroVolFDShoutNPV) {
    BOOST_TEST_MESSAGE("Testing zero volatility shout option pricing with discrete dividends...");

    const auto dc = Actual365Fixed();
    const auto today = Date(14, February, 2021);
    Settings::instance().evaluationDate() = today;

    const auto spot = Handle<Quote>(ext::make_shared<SimpleQuote>(100.0));
    const auto q = Handle<YieldTermStructure>(flatRate(0.03, dc));
    const auto r = Handle<YieldTermStructure>(flatRate(0.07, dc));

    const auto volTS = Handle<BlackVolTermStructure>(flatVol(1e-6, dc));
    const auto process = ext::make_shared<BlackScholesMertonProcess>(
            spot, q, r, volTS);

   const auto maturityDate = today + Period(1, Years);
   const Date dividendDate = today + Period(3, Months);
   const Real dividendAmount = 10.0;
   auto dividends = DividendVector({ dividendDate },{ dividendAmount });

   VanillaOption option(
       ext::make_shared<PlainVanillaPayoff>(Option::Put, 100.0),
       ext::make_shared<AmericanExercise>(today, maturityDate)
   );

   option.setPricingEngine(
       ext::make_shared<FdBlackScholesVanillaEngine>(
           process, dividends, 50, 50));

   const Real americanNPV = option.NPV();

   VanillaOption option2(
       ext::make_shared<PlainVanillaPayoff>(Option::Put, 100.0),
       ext::make_shared<AmericanExercise>(today, maturityDate)
   );

   option2.setPricingEngine(
       ext::make_shared<FdBlackScholesShoutEngine>(process, dividends, 50, 50));

   Real shoutNPV = option2.NPV();

   const DiscountFactor df = r->discount(maturityDate)/r->discount(dividendDate);

   const Real tol = 1e-3;
   Real diff = std::fabs(americanNPV - shoutNPV/df);

   if (diff > tol) {
       BOOST_FAIL("failed to reproduce American option NPV with "
                  "shout option pricing engine for "
                  << "\n    calculated: " << shoutNPV/df
                  << "\n    expected  : " << americanNPV
                  << "\n    difference: " << diff
                  << "\n    tolerance:  " << tol);
   }
}

BOOST_AUTO_TEST_CASE(testLargeDividendShoutNPV) {
    BOOST_TEST_MESSAGE("Testing zero strike shout option pricing with discrete dividends...");

    const auto dc = Actual365Fixed();
    const auto today = Date(21, February, 2021);
    Settings::instance().evaluationDate() = today;

    const Real s0 = 100.0;
    const Volatility vol = 0.25;

    const auto q = Handle<YieldTermStructure>(flatRate(0.00, dc));
    const auto r = Handle<YieldTermStructure>(flatRate(0.00, dc));
    const auto vTS = Handle<BlackVolTermStructure>(flatVol(vol, dc));

    const auto process = ext::make_shared<BlackScholesMertonProcess>(
        Handle<Quote>(ext::make_shared<SimpleQuote>(s0)), q, r, vTS);

   const auto maturityDate = today + Period(6, Months);
   const Date dividendDate = today + Period(3, Months);
   const Real divAmount = 30.0;
   auto dividends = DividendVector({ dividendDate }, { divAmount });

   const Real strike = 80.0;
   VanillaOption option(
       ext::make_shared<PlainVanillaPayoff>(Option::Call, strike),
       ext::make_shared<AmericanExercise>(today, maturityDate)
   );

   option.setPricingEngine(
       ext::make_shared<FdBlackScholesShoutEngine>(process, dividends, 100, 400));

   Real calculated = option.NPV();

   VanillaOption ref_option(
       ext::make_shared<PlainVanillaPayoff>(Option::Call, strike),
       ext::make_shared<AmericanExercise>(today, dividendDate)
   );

   ref_option.setPricingEngine(
       ext::make_shared<FdBlackScholesShoutEngine>(process, 100, 400));

   const Real expected = ref_option.NPV()
       * r->discount(maturityDate) / r->discount(dividendDate);

   const Real tol = 5e-2;
   Real diff = std::fabs(expected - calculated);

   if (diff > tol) {
       BOOST_FAIL("failed to reproduce American option NPV with "
                  "shout option pricing engine for "
                  << "\n    calculated: " << calculated
                  << "\n    expected  : " << expected
                  << "\n    difference: " << diff
                  << "\n    tolerance:  " << tol);
   }
}

BOOST_AUTO_TEST_CASE(testEscrowedVsSpotAmericanOption) {
    BOOST_TEST_MESSAGE("Testing escrowed vs spot dividend model for American options...");

    const auto dc = Actual360();
    const auto today = Date(27, February, 2021);
    Settings::instance().evaluationDate() = today;

    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.3));

    const auto process = ext::make_shared<BlackScholesMertonProcess>(
        Handle<Quote>(ext::make_shared<SimpleQuote>(100)),
        Handle<YieldTermStructure>(flatRate(0.08, dc)),
        Handle<YieldTermStructure>(flatRate(0.04, dc)),
        Handle<BlackVolTermStructure>(flatVol(vol, dc))
    );

   const auto maturityDate = today + Period(12, Months);
   std::vector<Date> dividendDates = { today + Period(10, Months) };
   std::vector<Real> dividendAmounts = { 10.0 };
   auto dividends = DividendVector(dividendDates, dividendAmounts);

   const Real strike = 100.0;
   VanillaOption option(
       ext::make_shared<PlainVanillaPayoff>(Option::Call, strike),
       ext::make_shared<AmericanExercise>(today, maturityDate)
   );

   option.setPricingEngine(
       ext::make_shared<FdBlackScholesVanillaEngine>(process, dividends, 100, 400));

   const Real spotNpv = option.NPV();
   const Real spotDelta = option.delta();

   vol->setValue(100/90.*0.3);

   option.setPricingEngine(
       MakeFdBlackScholesVanillaEngine(process)
       .withTGrid(100)
       .withXGrid(400)
       .withCashDividends(dividendDates, dividendAmounts)
       .withCashDividendModel(FdBlackScholesVanillaEngine::Escrowed)
   );

   const Real escrowedNpv = option.NPV();
   const Real escrowedDelta = option.delta();

   const Real diffNpv = std::abs(escrowedNpv - spotNpv);
   const Real tol = 1e-2;

   if (diffNpv > tol) {
       BOOST_FAIL("failed to compare American option NPV with "
                  "escrowed and spot dividend model "
                  << "\n    escrowed div: " << escrowedNpv
                  << "\n    spot div    : " << spotNpv
                  << "\n    difference: " << diffNpv
                  << "\n    tolerance:  " << tol);
   }


   const Real diffDelta = std::abs(escrowedDelta - spotDelta);

   if (diffDelta > tol) {
       BOOST_FAIL("failed to compare American option Delta with "
                  "escrowed and spot dividend model "
                  << "\n    escrowed div: " << escrowedDelta
                  << "\n    spot div    : " << spotDelta
                  << "\n    difference: " << diffDelta
                  << "\n    tolerance:  " << tol);
   }
}

BOOST_AUTO_TEST_CASE(testTodayIsDividendDate) {
    BOOST_TEST_MESSAGE("Testing escrowed vs spot dividend model on dividend dates for American options...");

    const auto dc = Actual360();
    const auto today = Date(27, February, 2021);
    Settings::instance().evaluationDate() = today;

    ext::shared_ptr<SimpleQuote> vol(new SimpleQuote(0.3));

    const auto process = ext::make_shared<BlackScholesMertonProcess>(
        Handle<Quote>(ext::make_shared<SimpleQuote>(100)),
        Handle<YieldTermStructure>(flatRate(0.05, dc)),
        Handle<YieldTermStructure>(flatRate(0.07, dc)),
        Handle<BlackVolTermStructure>(flatVol(vol, dc))
    );

    const auto maturityDate = today + Period(12, Months);
    std::vector<Date> dividendDates = { today, today + Period(11, Months) };
    std::vector<Real> dividendAmounts = { 5.0, 5.0 };

    ext::shared_ptr<PricingEngine> spotEngine =
        MakeFdBlackScholesVanillaEngine(process)
        .withTGrid(100)
        .withXGrid(400)
        .withCashDividends(dividendDates, dividendAmounts)
        .withCashDividendModel(FdBlackScholesVanillaEngine::Spot);

    ext::shared_ptr<PricingEngine> escrowedEngine =
        MakeFdBlackScholesVanillaEngine(process)
        .withTGrid(100)
        .withXGrid(400)
        .withCashDividends(dividendDates, dividendAmounts)
        .withCashDividendModel(FdBlackScholesVanillaEngine::Escrowed);

    const Real strike = 90.0;
    VanillaOption option(
        ext::make_shared<PlainVanillaPayoff>(Option::Put, strike),
        ext::make_shared<AmericanExercise>(today, maturityDate)
    );

    option.setPricingEngine(spotEngine);

    Real spotNpv = option.NPV();
    const Real spotDelta = option.delta();
    BOOST_CHECK_THROW(option.theta(), QuantLib::Error);

    vol->setValue(100/95.*0.3);

    option.setPricingEngine(escrowedEngine);

    Real escrowedNpv = option.NPV();
    const Real escrowedDelta = option.delta();
    BOOST_CHECK_THROW(option.theta(), QuantLib::Error);

    Real diffNpv = std::abs(escrowedNpv - spotNpv);
    const Real tol = 5e-2;

    if (diffNpv > tol) {
        BOOST_FAIL("failed to compare American option NPV with "
                   "escrowed and spot dividend model "
                   << "\n    escrowed div: " << escrowedNpv
                   << "\n    spot div    : " << spotNpv
                   << "\n    difference:   " << diffNpv
                   << "\n    tolerance:    " << tol);
    }

    const Real diffDelta = std::abs(escrowedDelta - spotDelta);

    if (diffDelta > tol) {
        BOOST_FAIL("failed to compare American option Delta with "
                   "escrowed and spot dividend model "
                   << "\n    escrowed div: " << escrowedDelta
                   << "\n    spot div    : " << spotDelta
                   << "\n    difference:   " << diffDelta
                   << "\n    tolerance:    " << tol);
    }

    dividendDates[0] = today + 1;

    spotEngine =
        MakeFdBlackScholesVanillaEngine(process)
        .withTGrid(100)
        .withXGrid(400)
        .withCashDividends(dividendDates, dividendAmounts)
        .withCashDividendModel(FdBlackScholesVanillaEngine::Spot);

    escrowedEngine =
        MakeFdBlackScholesVanillaEngine(process)
        .withTGrid(100)
        .withXGrid(400)
        .withCashDividends(dividendDates, dividendAmounts)
        .withCashDividendModel(FdBlackScholesVanillaEngine::Escrowed);

    vol->setValue(0.3);

    option.setPricingEngine(spotEngine);
    spotNpv = option.NPV();

    vol->setValue(100/95.0*0.3);
    option.setPricingEngine(escrowedEngine);

    escrowedNpv = option.NPV();
    BOOST_CHECK_NO_THROW(option.theta());

    diffNpv = std::abs(escrowedNpv - spotNpv);

    if (diffNpv > tol) {
        BOOST_FAIL("failed to compare American option NPV with "
                   "escrowed and spot dividend model "
                   << "\n    escrowed div: " << escrowedNpv
                   << "\n    spot div    : " << spotNpv
                   << "\n    difference:   " << diffNpv
                   << "\n    tolerance:    " << tol);
    }
}

BOOST_AUTO_TEST_CASE(testCallPutParity) {
    BOOST_TEST_MESSAGE("Testing call/put parity for American options...");

    // R.L. McDonald, M.D. Schroder: A parity result for American option

    const DayCounter dc = Actual365Fixed();
    const Date today = Date(8, April, 2022);
    Settings::instance().evaluationDate() = today;

    struct OptionSpec {
        Real spot;
        Real strike;
        Size maturityInDays;
        Real volatility;
        Real r;
        Real q;
    };

    auto buildStochProcess = [&dc](const OptionSpec& testCase) {
        return ext::make_shared<BlackScholesMertonProcess>(
            Handle<Quote>(ext::make_shared<SimpleQuote>(testCase.spot)),
            Handle<YieldTermStructure>(flatRate(testCase.q, dc)),
            Handle<YieldTermStructure>(flatRate(testCase.r, dc)),
            Handle<BlackVolTermStructure>(flatVol(testCase.volatility, dc))
        );
    };
    const OptionSpec testCaseSpecs[] = {
        {100.0, 100.0, 365, 0.5, 0.15, 0.02},
        {100.0, 90.0, 365, 0.5, 0.15, 0.02},
        {100.0, 125.0, 730, 0.4, 0.15, 0.05},
        {100.0, 125.0, 730, 0.4, 0.06, 0.05}
    };

    const Size xGrid = 400;
    const Size timeStepsPerYear=50;

    for (const auto& testCaseSpec: testCaseSpecs) {
        const auto maturityDate =
            today + Period(testCaseSpec.maturityInDays, Days);
        const Time maturityTime = dc.yearFraction(today,  maturityDate);
        const Size tGrid = Size(maturityTime * timeStepsPerYear);

        const auto exercise =
            ext::make_shared<AmericanExercise>(today, maturityDate);

        VanillaOption putOption(
            ext::make_shared<PlainVanillaPayoff>(
                Option::Put, testCaseSpec.strike),
            exercise
        );
        putOption.setPricingEngine(
            ext::make_shared<FdBlackScholesVanillaEngine>(
                buildStochProcess(testCaseSpec), tGrid, xGrid)
        );
        const Real putNpv = putOption.NPV();

        OptionSpec callOptionSpec = {
            testCaseSpec.strike,
            testCaseSpec.spot,
            testCaseSpec.maturityInDays,
            testCaseSpec.volatility,
            testCaseSpec.q,
            testCaseSpec.r
        };
        VanillaOption callOption(
            ext::make_shared<PlainVanillaPayoff>(
                Option::Call, callOptionSpec.strike),
            exercise
        );
        callOption.setPricingEngine(
            ext::make_shared<FdBlackScholesVanillaEngine>(
                buildStochProcess(callOptionSpec), tGrid, xGrid)
        );
        const Real callNpv = callOption.NPV();

        const Real diff = std::fabs(putNpv -callNpv);
        const Real tol = 0.001;

        if (diff > tol) {
            BOOST_FAIL("failed to reproduce American call/put parity"
                    << "\n    Put NPV   : " << putNpv
                    << "\n    Call NPV  : " << callNpv
                    << "\n    difference: " << diff
                    << "\n    tolerance : " << tol);
        }
    }
}

BOOST_AUTO_TEST_CASE(testQdPlusBoundaryValues) {
    BOOST_TEST_MESSAGE("Testing QD+ boundary approximation...");

    const DayCounter dc = Actual365Fixed();
    const Real S = 100;
    const Real K = 120;
    const Rate r = 0.1;
    const Rate q = 0.03;
    const Volatility sigma = 0.25;
    const Time maturity = 5.0;

    const QdPlusAmericanEngine qrPlusEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess>(), 10);

    std::vector<std::pair<Real, Real> > testCaseSpecs = {
        {4.9, 87.76960949965387},
        {4.0, 88.39053003614612},
        {2.5, 90.14327315762256},
        {1.0, 94.49793803095984},
        {0.1, 106.2588964442338}
    };

    for (const auto& testCaseSpec: testCaseSpecs) {
        const auto calculated
            = qrPlusEngine.putExerciseBoundaryAtTau(
                S, K, r, q, sigma, maturity, testCaseSpec.first);

        const Real boundary = calculated.second;
        const Size nrEvaluations = calculated.first;

        const Real expected = testCaseSpec.second;

        const Real diff = std::fabs(boundary - expected);
        const Real tol = 1e-12;

        if (diff > tol) {
            BOOST_FAIL("failed to reproduce QR+ boundary approximation"
                    << "\n    calculated: " << boundary
                    << "\n    expected:   " << expected
                    << "\n    difference: " << diff
                    << "\n    tolerance : " << tol);
        }

        if (nrEvaluations > 10) {
            BOOST_FAIL("failed to reproduce rate of convergence"
                    << "\n    evaluations: " << nrEvaluations
                    << "\n    max eval :   " << 10);
        }
    }
}

BOOST_AUTO_TEST_CASE(testQdPlusBoundaryConvergence) {
    BOOST_TEST_MESSAGE("Testing QD+ boundary convergence...");

    const DayCounter dc = Actual365Fixed();
    const Real S = 100;
    const Volatility sigma = 0.25;
    const Time maturity = 10.0;

    struct TestCaseSpec {
        Real r, q, strike;
        Size maxEvaluations;
    };

    TestCaseSpec testCases[] = {
        { 0.10, 0.03, 120, 2000 },
        { 0.0001, 0.03, 120, 2000 },
        { 0.0001, 0.000002, 120, 2000 },
        { 0.01, 0.75, 120, 2000 },
        { 0.03, 0.0, 30, 2000 },
        { 0.03, 0.0, 1e7, 2500 },
        { 0.075, 0.0, 1e-8, 2000 }
    };

    const std::vector<std::pair<QdPlusAmericanEngine::SolverType, std::string> >
        solverTypes{
        { QdPlusAmericanEngine::Brent, "Brent" },
        { QdPlusAmericanEngine::Newton, "Newton" },
        { QdPlusAmericanEngine::Ridder, "Ridder" },
        { QdPlusAmericanEngine::Halley, "Halley" },
        { QdPlusAmericanEngine::SuperHalley, "SuperHalley" }
    };

    for (const auto& testCase: testCases) {
        for (const auto& solverType : solverTypes) {
            const QdPlusAmericanEngine qrPlusEngine(
                ext::shared_ptr<GeneralizedBlackScholesProcess>(),
                Null<Size>(), solverType.first, 1e-8);

            Size nrEvaluations = 0;

            for (Real t=0.0; t < maturity; t+=0.1) {
                const auto calculated = qrPlusEngine.putExerciseBoundaryAtTau(
                    S, testCase.strike, testCase.r,
                    testCase.q, sigma, maturity, t);
                nrEvaluations += calculated.first;
            }

            const Size maxEvaluations =
                (   solverType.first == QdPlusAmericanEngine::Halley
                 || solverType.first == QdPlusAmericanEngine::SuperHalley)
                 ? 750 : testCase.maxEvaluations;

            if (nrEvaluations > maxEvaluations) {
                BOOST_FAIL("QR+ boundary approximation failed to converge "
                        << "\n    evaluations: " << nrEvaluations
                        << "\n    max eval:    " << maxEvaluations
                        << "\n    Solver:      " << solverType.second
                        << "\n    r :          " << testCase.r
                        << "\n    q :          " << testCase.q
                        << "\n    K :          " << testCase.strike);
            }
        }
    }
}

BOOST_AUTO_TEST_CASE(testQdAmericanEngines) {
    BOOST_TEST_MESSAGE("Testing QD+ American option pricing...");

    const DayCounter dc = Actual365Fixed();
    const Date today = Date(1, June, 2022);
    Settings::instance().evaluationDate() = today;

    struct OptionSpec {
        Option::Type optionType;
        Real spot;
        Real strike;
        Size maturityInDays;
        Real volatility;
        Real r;
        Real q;
        Real expectedValue;
        Real precision;
    };

    // high precision edge cases
    const OptionSpec edgeTestCases[] = {

        // standard put option
        {Option::Put, 100.0, 120.0, 3650, 0.25, 0.10, 0.03, 22.97383256003585, 1e-8},
        // call-put parity on standard option
        {Option::Call, 120.0, 100.0, 3650, 0.25, 0.03, 0.10, 22.97383256003585, 1e-8},

        // zero strike put
        {Option::Put, 100.0, 0.0, 365, 0.25, 0.02, 0.02, 0.0, 1e-14},
        {Option::Put, 100.0, 1e-8, 365, 0.25, 0.02, 0.02, 0.0, 1e-14},

        // zero strike call
        {Option::Call, 100.0, 0.0, 365, 0.25, 0.05, 0.01, 100.0, 1e-11},
        {Option::Call, 100.0, 1e-7, 365, 0.25, 0.05, 0.01, 100.0-1e-7, 1e-9},

        // zero vol call
        {Option::Call, 100.0, 50.0, 365, 0.0, 0.05, 0.01, 51.4435121498811085, 1e-10},
        {Option::Call, 100.0, 50.0, 365, 1e-8, 0.05, 0.01, 51.4435121498811156, 1e-8},

        // zero vol put 1
        {Option::Put, 100.0, 120.0, 4*3650, 1e-6, 0.01, 0.50, 108.980920365700442, 1e-4},
        {Option::Put, 100.0, 120.0, 4*3650, 0.0, 0.01, 0.50, 108.980904561184602, 1e-10},

        // zero vol put 2
        {Option::Put, 100.0, 120.0, 365, 1e-7, 0.05, 0.01, 20.0, 1e-9},
        {Option::Put, 100.0, 120.0, 365, 0.0, 0.05, 0.01, 20.0, 1e-12},

        // zero vol put 3
        {Option::Put, 100.0, 120.0, 365, 1e-7, 0.00, 0.05, 24.8770575499286082, 1e-8},
        {Option::Put, 100.0, 120.0, 365, 0.0, 0.00, 0.05, 24.8770575499286082, 1e-10},

        // zero spot put
        {Option::Put, 1e-6, 120.0, 365, 0.25, -0.075, 0.05, 129.346097154926355, 1e-9},
        {Option::Put, 0.0, 120.0, 365, 0.25, -0.075, 0.05, 129.346098106155779, 1e-10},

        // zero spot call
        {Option::Call, 1e-6, 120.0, 365, 0.25, 0.075, 0.05, 0.0, 1e-14},
        {Option::Call, 0.0, 120.0, 365, 0.25, 0.075, 0.05, 0.0, 1e-14},

        // put option with one day left
        {Option::Put, 100.0, 120.0, 1, 0.25, 0.05, 0.0, 20.0, 1e-10},

        // put option at maturity
        {Option::Put, 100.0, 120.0, 0, 0.25, 0.05, 0.0, 0.0, 1e-14},

        // zero everything
        {Option::Put, 0.0, 0.0, 365, 0.0, 0.0, 0.0, 0.0, 1e-14},

        // zero strike call with zero vol
        {Option::Call, 100.0, 1e-7, 365, 1e-8, 0.05, 0.025, 100.0-1e-7, 1e-8},
        {Option::Call, 100.0, 0.0, 365, 1e-8, 0.05, 0.025, 100.0, 1e-8},
        {Option::Call, 100.0, 1e-7, 365, 0.0, 0.05, 0.025, 100.0-1e-7, 1e-8},
        {Option::Call, 100.0, 0.0, 365, 0.0, 0.05, 0.025, 100.0, 1e-8},

        // zero spot call with zero vol
        {Option::Call, 1e-8, 100, 365, 1e-8, 0.05, 0.025, 0.0, 1e-10},
        {Option::Call, 0.0, 100, 365, 0.0, 0.05, 0.025, 0.0, 1e-14},

        // zero interest rate call
        {Option::Call, 100, 100, 365, 0.25, 0.0, 0.025, 8.871505915120776, 1e-8},

        // zero dividend rate call
        {Option::Call, 100, 100, 365, 0.25, 0.05, 0.0, 12.3359989303687243, 1e-8},

        // extreme spot call
        {Option::Call, 1e10, 100, 365, 0.25, 0.01, 0.05, 1e10-100.0, -1},

        // extreme strike call
        {Option::Call, 100, 1e10, 365, 0.25, 0.01, 0.05, 0.0, 1e-14},

        // extreme vol call
        {Option::Call, 100, 100, 365, 100.0, 0.01, 0.05, 99.9874942266127, 1e-8},

        // extreme dividend yield call
        {Option::Call, 100, 100, 365, 0.25, 0.10, 10.0, 0.1159627202107989, 1e-8},

        // extreme maturity call
        {Option::Call, 100, 100, 170*365, 0.25, 0.01, 0.002, 80.37468392429741, 1e-8}
    };

    // random test cases
    const double pde_values[] = {
        581.46895,113.78442,581.44547,1408.579,49.19448,1060.27367,
        834.83366,176.48305,120.38008,307.11264,602.7006,233.80171,
        204.74596,0.30987,0,0,5.36215,0.01711,0,84.51193,0.67131,
        0.06414,152.67188,54.75257,90.31861,168.50289,18.38926,0,
        282.4995,0,0.08428,12.30929,42.26359,139.87748,0.28724,0.00421,
        0,0.00206,0,658.60427,140.51139,23.17387,0.35612,0,909.14828,
        0,0.11549,5.46749,144.25428,2576.6754,562.16484,0,122.725,
        383.48463,278.7447,3.52566,82.34348,81.06139,0,10.42824,
        4.95917,25.28602,31.38869,3.53697,0,0.012,0,0.4263,162.16184,
        0.4618,97.714,283.03442,0.38176,70.25367,134.94142,2.19293,
        226.4746,76.74309,46.03123,15.76214,0.01666,1806.26208,0,
        103.93726,6.82956,337.81301,0.64236,677.63248,25.01763,
        443.79052,1793.78327,118.6293,185.79849,11.59313,679.01736,
        17.99005,403.57554,1.67418,0,0.03795,3326.09089,71.1996,
        0,485.10353,0,1681.25166,0,43.15432,0.75825,0.05895,34.71493,
        0.00015,5.58671,115.98793,37.7713,399.24494,0.00766,445.42207,
        152.65397,0,47.05874,0.96921,14.21875,257.84754,109.62533,
        2553.99295,138.46663,192.33614,81.41877,18.21403,113.926,
        27.28409,174.77093,42.70527,0.90326,0,967.9901,616.0143,
        253.56442,0.00397,2493.82098,9.29406,11.00023,0,0,234.12481,
        0,72.46356,0,9.00932,48.67934,29.42756,13.4271,0,0,0,0,20.71417,
        48.57474,2.26452,0,109.0243,0,21.26801,1.21164,0,86.25232,
        36.00437,4.53844,7.40503,313.53602,379.76105,165.84347,77.19665,
        9.02466,0.10634,214.84982,6.13387,133.44645,303.25953,0,
        134.26724,246.89804,0,123.32975,32.83429,9.56819,7.42582,0,
        73.82832,196.84831,0.00001,72.70391,2173.8649,123.00513,
        153.83539,21.63003,209.84752,30.12425,0,197.6502,0,164.02863,
        7.65143,56.57631,2392.70018,0,0,34.23457,171.08459,0.49387,
        31.13395,237.68801,0.01262,0,0,0,0,41.56635,0,8.41535,55.01775,
        310.50094,0,14.85456,174.34018,7.19772,0.00001,0,91.70874,
        0.00001,17.51724,0.00587,0,532.24902,2.05553,36.80843,0,
        33.39288,0.00006,0.04439,1.3434,0,0.41816,926.37642,0,247.61559,
        151.98965,0.35243,4.33198,23294.47744,0.00791,12.51996,53.47727,
        167.95572,0.0062,6.8482,0,347.83408,852.85742,558.21422,0,
        53.89293,78.61011,187.3978,9.18927,0.00553,113.48101,1467.30556,
        74.82251,94.84476,0,101.3649,59.27007,0,773.81251,0,542.7889,0,
        68.96209,96.0435,0.00004,0.10738,0.00187,324.97758,245.68455,
        30.52818,129.84472,0,46.86288,368.41675,139.29763,4.4393,16.29594,
        25.7554,64.02621,89.41363,0.62751,219.65237,0.26039,0,12.02172,
        101.97733,69.37456,45.81122,1263.33603,164.31607,15.88788,0,48.77797,
        0.13233,147.16808,10.31217,7.50634,7.48611,177.95409,225.77562,3.56947,
        0.02531,4.88869,8.76632,0,0,0.02214,305.08468,44.52185,182.17332,
        538.31458,0,46.97229,0,31.94202,410.43038,0,70.35432,15.58346,74.14177,
        953.67663,11.79128,59.83061,0,37.86557,1184.22731,2411.37823,0,0,0,0,
        49.3179,236.38654,21.36225,218.048,517.57006,0,0,12.52933,256.71967,
        0.00025,1.47981,158.19166,0,1923.70709,4.94441,1199.81196,45.92353,
        85.73255,14.91338,88.81459,21.42459,3456.9466,31.97838,233.26863,
        49.34801,2684.07758,0,0,32.24149,0,111.79552,0.00506,8.77602,0,
        406.54213,0.32974,365.53998,1.49714,19.65603,37.33877,205.06928,
        0.01805,589.23478,9.58273,0.02946,286.48706,463.34512,528.21392,0,
        47.71294,21.0864,114.81771,80.489,21.30905,41.95873,19.03598,156.09295,
        0,73.6509,0,0,168.17576,0,32.71243,36.75044,177.64583,0.05618,
        156.38616,1370.4754,24.5976,59.83173,0,354.93074,34.96889,0.00532,
        16.95287,1259.72993,241.05777,18.9778,0.57635,43.98093,25.2678,
        369.39896,0.31549,0,31.95512,101.60559,11.22079,970.16273,0,0,
        1.55445,0,18.6067,0,1124.20117,52.67762,10.38273,0,10.22588,251.27813,
        0,431.82244,0,1.31252,0,84.72154,100.98411,160.95557,129.51372,
        0.00026,103.81663,421.64767,0.00031,0,104.48529,162.59225,0,
        1504.0869,88.11253,4.14052,0.07195,203.78754,0.00002,42.5395,0,
        17.05087,26.89157,64.64923,0,390.87453,124.55406,0.01018,94.23963};

    std::vector<OptionSpec> testCaseSpecs;
    testCaseSpecs.reserve(std::size(pde_values) + std::size(edgeTestCases));

    PseudoRandom::rng_type rng(PseudoRandom::urng_type(12345UL));

    for (double pde_value : pde_values) {
        const Option::Type optionType
            = (rng.next().value > 0)? Option::Call : Option::Put;
        const Real spot = 100*std::exp(1.5*rng.next().value);
        const Real strike = 100*std::exp(1.5*rng.next().value);
        const Size maturityInDays = Size(1 + 365*std::exp(2*rng.next().value));
        const Volatility  vol = 0.5*std::exp(rng.next().value);
        const Rate r = 0.10*std::exp(rng.next().value);
        const Rate q = 0.10*std::exp(rng.next().value);

        const OptionSpec spec = {optionType, spot,      strike, maturityInDays, vol, r,
                                 q,          pde_value, -1};

        testCaseSpecs.push_back(spec);
    }

    testCaseSpecs.insert(
        testCaseSpecs.end(),std::begin(edgeTestCases), std::end(edgeTestCases));

    const auto spot = ext::make_shared<SimpleQuote>(1.0);
    const auto rRate = ext::make_shared<SimpleQuote>(0.0);
    const auto qRate = ext::make_shared<SimpleQuote>(0.0);
    const auto vol = ext::make_shared<SimpleQuote>(0.0);

    const auto bsProcess = ext::make_shared<BlackScholesMertonProcess>(
        Handle<Quote>(spot),
        Handle<YieldTermStructure>(flatRate(today, qRate, dc)),
        Handle<YieldTermStructure>(flatRate(today, rRate, dc)),
        Handle<BlackVolTermStructure>(flatVol(today, vol, dc))
    );

    const auto qrPlusAmericanEngine =
        ext::make_shared<QdPlusAmericanEngine>(
            bsProcess, 8, QdPlusAmericanEngine::Halley, 1e-10
        );

    for (const auto& testCaseSpec: testCaseSpecs) {
        const Date maturityDate =
            today + Period(testCaseSpec.maturityInDays, Days);

        spot->setValue(testCaseSpec.spot);
        rRate->setValue(testCaseSpec.r);
        qRate->setValue(testCaseSpec.q);
        vol->setValue(testCaseSpec.volatility);

        VanillaOption option(
            ext::make_shared<PlainVanillaPayoff>(
                testCaseSpec.optionType, testCaseSpec.strike),
            ext::make_shared<AmericanExercise>(today, maturityDate)
        );
        option.setPricingEngine(qrPlusAmericanEngine);

        const Real calculated = option.NPV();
        const Real expected = testCaseSpec.expectedValue;

        if ((testCaseSpec.precision > 0
                && std::abs(expected-calculated) > testCaseSpec.precision)
            || (testCaseSpec.precision < 0
                    && expected > 0.1 && std::abs(calculated-expected)/expected > 0.005)
            || (testCaseSpec.precision < 0 && expected <= 0.1
                    && std::abs(expected-calculated) > 5e-4)) {
            BOOST_ERROR("QR+ boundary approximation failed to "
                    "reproduce cached edge and PDE values for "
                    << "\n    OptionType: " <<
                    ((testCaseSpec.optionType == Option::Call)? "Call" : "Put")
                    << std::setprecision(16)
                    << "\n    spot:       " << spot->value()
                    << "\n    strike:     " << testCaseSpec.strike
                    << "\n    r:          " << rRate->value()
                    << "\n    q:          " << qRate->value()
                    << "\n    vol:        " << vol->value()
                    << "\n    calculated: " << calculated
                    << "\n    expected:   " << expected);
        }
    };
}

BOOST_AUTO_TEST_CASE(testQdFpIterationScheme) {
    BOOST_TEST_MESSAGE("Testing Legendre and tanh-sinh iteration "
                       "scheme for QD+ fixed-point American engine...");

    const Real tol = 1e-8;
    const Size l=32, m=6, n=18, p=36;

    const ext::shared_ptr<QdFpIterationScheme> schemes[] = {
        ext::make_shared<QdFpLegendreScheme>(l, m, n, p),
        ext::make_shared<QdFpLegendreTanhSinhScheme>(l, m, n, tol),
        ext::make_shared<QdFpTanhSinhIterationScheme>(m, n, tol)
    };

    const NormalDistribution nd;

    for (const auto& scheme: schemes) {
        BOOST_CHECK_EQUAL(n, scheme->getNumberOfChebyshevInterpolationNodes());
        BOOST_CHECK_EQUAL(1, scheme->getNumberOfJacobiNewtonFixedPointSteps());
        BOOST_CHECK_EQUAL(m-1, scheme->getNumberOfNaiveFixedPointSteps());

        QL_CHECK_SMALL(scheme->getFixedPointIntegrator()
            ->operator()(nd, -10.0, 10.0) - 1.0, tol);
        QL_CHECK_SMALL(scheme->getExerciseBoundaryToPriceIntegrator()
            ->operator()(nd, -10.0, 10.0) - 1.0, tol);
    }
}

BOOST_AUTO_TEST_CASE(testAndersenLakeHighPrecisionExample) {
    BOOST_TEST_MESSAGE("Testing Andersen, Lake and Offengenden "
                        "high precision example...");

    // Example and results are taken from
    //    Leif Andersen, Mark Lake and Dimitri Offengenden (2015)
    //    "High Performance American Option Pricing",
    //    https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2547027

    struct SchemeSpec {
        Size l, m, n;
        Rate r;
        Real expected[2];
        Real tol;
    };
    
    const SchemeSpec testCases[] = {
        { 24, 3, 9,  0.05, {0.1069528125898476, 0.1069524359360852}, 1e-6},
        {  5, 1, 4,  0.05, {0.1070237787625299, 0.1070042740171235}, 1e-3},
        { 11, 2, 5,  0.05, {0.106938750864602, 0.1069479057531648}, 1e-4},
        { 35, 8, 16, 0.05, {0.1069527032381714, 0.106952558361499}, 1e-9},
        { 65, 8, 32, 0.05, {0.1069527028247546, 0.1069526779971959}, 1e-11},
        {  5, 1, 4, 0.075, {0.3674420299196104, 0.3674766444325588}, 1e-3},
        { 11, 2, 5, 0.075, {0.3671056766787473, 0.3671024005532715}, 1e-4},
        { 35, 8, 16,0.075, {0.3671116758420414, 0.3671111055677869}, 1e-9},
        { 65, 8, 32,0.075, {0.3671112309062572, 0.3671111267813689}, 1e-11}
    };

    const DayCounter dc = Actual365Fixed();
    const Date today = Date(25, July, 2022);
    Settings::instance().evaluationDate() = today;

    const auto spot = ext::make_shared<SimpleQuote>(100.0);
    const Real strike = 100.0;
    const Rate q = 0.05;
    const Volatility vol = 0.25;
    const Date maturityDate = today + Period(1, Years);

    const auto payoff =
        ext::make_shared<PlainVanillaPayoff>(Option::Put, strike);

    for (const auto& testCase: testCases) {
        const Size l = testCase.l;
        const Size m = testCase.m;
        const Size n = testCase.n;
        const Rate r = testCase.r;
        const Real tol = testCase.tol;

        const auto bsProcess = ext::make_shared<BlackScholesMertonProcess>(
            Handle<Quote>(spot),
            Handle<YieldTermStructure>(flatRate(today, q, dc)),
            Handle<YieldTermStructure>(flatRate(today, r, dc)),
            Handle<BlackVolTermStructure>(flatVol(today, vol, dc))
        );

        VanillaOption americanOption(
            payoff, ext::make_shared<AmericanExercise>(today, maturityDate));

        VanillaOption europeanOption(
            payoff, ext::make_shared<EuropeanExercise>(maturityDate));

        europeanOption.setPricingEngine(
            ext::make_shared<AnalyticEuropeanEngine>(bsProcess));

        const Real europeanNPV = europeanOption.NPV();

        const QdFpAmericanEngine::FixedPointEquation schemes[] = {
            QdFpAmericanEngine::FP_A, QdFpAmericanEngine::FP_B
        };

        for (Size i=0; i < std::size(schemes); ++i) {

            americanOption.setPricingEngine(
                ext::make_shared<QdFpAmericanEngine>(
                    bsProcess,
                    ext::make_shared<QdFpLegendreTanhSinhScheme>(l, m, n, tol),
                    schemes[i])
            );

            const Real americanNPV = americanOption.NPV();
            const Real americanPremium = americanNPV - europeanNPV;

            const Real diff = std::abs(americanPremium - testCase.expected[i]);
            if (diff > tol) {
                BOOST_ERROR("failed to reproduce high precision literature values"
                        << "\n    FP-Scheme: " <<
                        ((schemes[i] == QdFpAmericanEngine::FP_A)? "FP-A" : "FP-B")
                        << "\n    r        : " << r
                        << "\n    (l,m,n)  : (" << l << "," << m << "," << n << ")"
                        << "\n    diff     : " << diff
                        << "\n    tol      : " << tol);
            }
        }
    }
}

BOOST_AUTO_TEST_CASE(testQdEngineStandardExample) {
    BOOST_TEST_MESSAGE("Testing Andersen, Lake and Offengenden "
                        "standard example...");

    const DayCounter dc = Actual365Fixed();
    const Date today = Date(1, June, 2022);
    Settings::instance().evaluationDate() = today;

    const Real S = 100;
    const Real K = 95;
    const Rate r = 0.075;
    const Rate q = 0.05;
    const Volatility sigma = 0.25;
    const Date maturityDate = today + Period(1, Years);

    const auto bsProcess = ext::make_shared<BlackScholesMertonProcess>(
        Handle<Quote>(ext::make_shared<SimpleQuote>(S)),
        Handle<YieldTermStructure>(flatRate(today, q, dc)),
        Handle<YieldTermStructure>(flatRate(today, r, dc)),
        Handle<BlackVolTermStructure>(flatVol(today, sigma, dc))
    );

    const auto payoff =
        ext::make_shared<PlainVanillaPayoff>(Option::Put, K);

    VanillaOption europeanOption(
        payoff, ext::make_shared<EuropeanExercise>(maturityDate));

    europeanOption.setPricingEngine(
        ext::make_shared<AnalyticEuropeanEngine>(bsProcess));

    VanillaOption americanOption(
        payoff, ext::make_shared<AmericanExercise>(today, maturityDate));


    const QdFpAmericanEngine::FixedPointEquation schemes[] = {
        QdFpAmericanEngine::FP_A, QdFpAmericanEngine::FP_B
    };
    const Real expected[] = { 0.2386475283369327, 0.2386596962737606 };

    for (Size i=0; i < std::size(schemes); ++i) {
        americanOption.setPricingEngine(
            ext::make_shared<QdFpAmericanEngine>(
                bsProcess,
                ext::make_shared<QdFpLegendreScheme>(32, 2, 15, 48),
                schemes[i])
        );
        const Real calculated = americanOption.NPV() - europeanOption.NPV();

        const Real tol = 7e-15;
        const Real diff = std::abs(calculated - expected[i]);

        if (diff > tol) {
            BOOST_ERROR("failed to reproduce high precision test values"
                    << "\n    diff     : " << diff
                    << "\n    tol      : " << tol);
        }
    }
}

class QdFpGaussLobattoScheme: public QdFpIterationScheme {
  public:
    QdFpGaussLobattoScheme(Size m, Size n, Real eps)
    : m_(m), n_(n),
      integrator_(ext::make_shared<GaussLobattoIntegral>(
                                                         100000, QL_MAX_REAL, 0.1*eps)) {
    }
    Size getNumberOfChebyshevInterpolationNodes() const override {
        return n_;
    }
    Size getNumberOfNaiveFixedPointSteps() const override {
        return m_-1;
    }
    Size getNumberOfJacobiNewtonFixedPointSteps() const override {
        return Size(1);
    }
    ext::shared_ptr<Integrator>
    getFixedPointIntegrator() const override {
        return integrator_;
    }
    ext::shared_ptr<Integrator>
    getExerciseBoundaryToPriceIntegrator() const override {
        return integrator_;
    }

  private:
    const Size m_, n_;
    const ext::shared_ptr<Integrator> integrator_;
};


BOOST_AUTO_TEST_CASE(testBulkQdFpAmericanEngine) {
    BOOST_TEST_MESSAGE("Testing Andersen, Lake and Offengenden "
                        "bulk examples...");

    // Examples are taken from
    //    Leif Andersen, Mark Lake and Dimitri Offengenden (2015)
    //    "High Performance American Option Pricing",
    //    https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2547027

    const DayCounter dc = Actual365Fixed();
    const Date today = Date(1, June, 2022);
    Settings::instance().evaluationDate() = today;

    const auto spot = ext::make_shared<SimpleQuote>(1.0);
    const auto rRate = ext::make_shared<SimpleQuote>(0.0);
    const auto qRate = ext::make_shared<SimpleQuote>(0.0);
    const auto vol = ext::make_shared<SimpleQuote>(0.0);

    // original test set from the article, takes too long
    // const Size T[] = {30, 91, 182, 273, 365};
    // const Rate rf[] = {0.02, 0.04, 0.06, 0.08, 0.1};
    // const Rate qy[] = {0, 0.04, 0.08, 0.12};
    // const Real S[] = {25, 50, 80, 90, 100, 110, 120, 150, 175, 200};
    // const Volatility sig[] = {0.1, 0.2, 0.3, 0.4, 0.5, 0.6};

     const Size T[] = {30, 182, 365};
     const Rate rf[] = {0.02, 0.04, 0.06, 0.1};
     const Rate qy[] = {0, 0.04, 0.08, 0.12};
     const Real S[] = {25, 75, 100, 125, 200};
     const Volatility sig[] = {0.1, 0.25, 0.6};

    const auto payoff = ext::make_shared<PlainVanillaPayoff>(Option::Put, 100);

    const auto bsProcess = ext::make_shared<BlackScholesMertonProcess>(
        Handle<Quote>(spot),
        Handle<YieldTermStructure>(flatRate(today, qRate, dc)),
        Handle<YieldTermStructure>(flatRate(today, rRate, dc)),
        Handle<BlackVolTermStructure>(flatVol(today, vol, dc))
    );

    const auto qdFpFastAmericanEngine =
        ext::make_shared<QdFpAmericanEngine>(
            bsProcess, QdFpAmericanEngine::fastScheme());

    const auto qdFpAccurateAmericanEngine =
        ext::make_shared<QdFpAmericanEngine>(
            bsProcess, QdFpAmericanEngine::accurateScheme());

    const auto qdFpGaussLobattoAmericanEngine =
        ext::make_shared<QdFpAmericanEngine>(
            bsProcess,ext::make_shared<QdFpGaussLobattoScheme>(3, 7, 1e-5));

    IncrementalStatistics statsAccurate, statsLobatto;
    for (auto t: T) {
        const Date maturityDate = today + Period(t, Days);
        VanillaOption option(
            payoff, ext::make_shared<AmericanExercise>(today, maturityDate));

        for (auto r: rf) {
            rRate->setValue(r);
            for (auto q: qy) {
                qRate->setValue(q);
                for (auto v: sig) {
                    vol->setValue(v);
                    for (auto s: S) {
                        spot->setValue(s);

                        option.setPricingEngine(qdFpFastAmericanEngine);
                        const Real fast = option.NPV();

                        option.setPricingEngine(qdFpAccurateAmericanEngine);
                        const Real accurate = option.NPV();
                        statsAccurate.add(std::abs(fast-accurate));

                        option.setPricingEngine(qdFpGaussLobattoAmericanEngine);
                        const Real lobatto = option.NPV();
                        statsLobatto.add(std::abs(accurate-lobatto));
                    }
                }
            }
        }
    }


    const Real tolStdDev = 1e-4;
    if (statsAccurate.standardDeviation() > tolStdDev)
        BOOST_ERROR("failed to reproduce low RMSE with fast American engine"
                << "\n    RMSE diff: " << statsAccurate.standardDeviation()
                << "\n    tol      : " << tolStdDev);

    if (statsLobatto.standardDeviation() > tolStdDev)
        BOOST_ERROR("failed to reproduce low RMSE with fast Lobatto American engine"
                << "\n    RMSE diff: " << statsLobatto.standardDeviation()
                << "\n    tol      : " << tolStdDev);

    const Real tolMax = 2.5e-3;
    if (statsAccurate.max() > tolMax)
        BOOST_ERROR("failed to reproduce low max deviation "
                "with fast American engine"
                << "\n    max diff: " << statsAccurate.max()
                << "\n    tol     : " << tolMax);

    if (statsLobatto.max() > tolMax)
        BOOST_ERROR("failed to reproduce low max deviation "
                "with fast Lobatto American engine"
                << "\n    max diff: " << statsLobatto.max()
                << "\n    tol     : " << tolMax);
}

BOOST_AUTO_TEST_CASE(testQdEngineWithLobattoIntegral) {
    BOOST_TEST_MESSAGE("Testing Andersen, Lake and Offengenden "
                        "with high precision Gauss-Lobatto integration...");

    const DayCounter dc = Actual365Fixed();
    const Date today = Date(5, November, 2022);
    Settings::instance().evaluationDate() = today;

    const auto spot = ext::make_shared<SimpleQuote>(36);
    const Real K = 40;
    const Rate r = 0.075;
    const Rate q = 0.01;
    const Volatility sigma = 0.40;
    const Date maturityDate = today + Period(2, Years);

    const auto bsProcess = ext::make_shared<BlackScholesMertonProcess>(
        Handle<Quote>(spot),
        Handle<YieldTermStructure>(flatRate(today, q, dc)),
        Handle<YieldTermStructure>(flatRate(today, r, dc)),
        Handle<BlackVolTermStructure>(flatVol(today, sigma, dc))
    );

    VanillaOption option(
        ext::make_shared<PlainVanillaPayoff>(Option::Put, K),
        ext::make_shared<AmericanExercise>(today, maturityDate)
    );

    const QdFpAmericanEngine::FixedPointEquation schemes[] = {
        QdFpAmericanEngine::FP_A, QdFpAmericanEngine::FP_B
    };

    const auto gaussLobattoScheme =
        ext::make_shared<QdFpGaussLobattoScheme>(10, 30, 1e-10);

    for (auto scheme: schemes) {
        const auto highPrecisionEngine =
            ext::make_shared<QdFpAmericanEngine>(
                bsProcess, QdFpAmericanEngine::highPrecisionScheme(), scheme);
        const auto lobattoEngine =
            ext::make_shared<QdFpAmericanEngine>(
                bsProcess, gaussLobattoScheme, scheme);

        for (Real s: std::list<Real>{36, 40-1e-8, 40, 40+1e-8, 50}) {
            spot->setValue(s);

            option.setPricingEngine(highPrecisionEngine);
            const Real highPrecisionNPV = option.NPV();

            option.setPricingEngine(lobattoEngine);
            const Real lobattoNPV = option.NPV();

            const Real diff = std::abs(lobattoNPV - highPrecisionNPV);
            const Real tol = 1e-11;

            if (diff > tol || std::isnan(lobattoNPV)) {
                BOOST_ERROR("failed to reproduce high precision American "
                        "option values with QD+ fixed point and Lobatto integration"
                        << "\n    FP-Scheme: " <<
                        ((scheme == QdFpAmericanEngine::FP_A)? "FP-A" : "FP-B")
                        << "\n    spot     : " << s
                        << "\n    diff     : " << diff
                        << "\n    tol      : " << tol);
            }
        }
    }
}

BOOST_AUTO_TEST_CASE(testQdNegativeDividendYield) {
    BOOST_TEST_MESSAGE("Testing Andersen, Lake and Offengenden "
                        "with positive or zero interest rate and "
                        "negative dividend yield...");

    const DayCounter dc = Actual365Fixed();
    const Date today = Date(5, December, 2022);
    Settings::instance().evaluationDate() = today;
    const Date maturityDate = today + Period(18, Months);

    const Real K = 90;
    const auto spot = ext::make_shared<SimpleQuote>(100);
    const auto qRate = ext::make_shared<SimpleQuote>(0);
    const auto rRate = ext::make_shared<SimpleQuote>(0);

    const auto process = ext::make_shared<BlackScholesMertonProcess>(
        Handle<Quote>(spot),
        Handle<YieldTermStructure>(flatRate(qRate, dc)),
        Handle<YieldTermStructure>(flatRate(rRate, dc)),
        Handle<BlackVolTermStructure>(flatVol(0.4, dc))
    );

    VanillaOption option(
        ext::make_shared<PlainVanillaPayoff>(Option::Put, K),
        ext::make_shared<AmericanExercise>(today, maturityDate)
    );
    const auto qdPlusEngine =
        ext::make_shared<QdPlusAmericanEngine>(process);
    const auto qdFpEngine =
        ext::make_shared<QdFpAmericanEngine>(process);
    const auto fdmEngine =
        ext::make_shared<FdBlackScholesVanillaEngine>(process, 800, 200);

    const Rate rRates[] = {0.025, 0.5, 0.0, 1e-6};
    const Rate qRates[] = {-0.05, -0.1, -0.5, 0.0};

    for (auto r: rRates) {
        rRate->setValue(r);
        for (auto q: qRates) {
            qRate->setValue(q);

            option.setPricingEngine(qdFpEngine);
            const Real qdFpNPV = option.NPV();
            option.setPricingEngine(qdPlusEngine);
            const Real qdPlusNPV = option.NPV();
            option.setPricingEngine(fdmEngine);
            const Real fdmNPV = option.NPV();

            const Real tol = 1.5e-2;
            const Real diffFdmQqFp = std::abs(fdmNPV - qdFpNPV);

            if (diffFdmQqFp > tol || std::isnan(diffFdmQqFp)) {
                BOOST_ERROR("failed to reproduce QD+ fixed point values"
                        << "\n    r        : " << r
                        << "\n    q        : " << q
                        << "\n    diff     : " << diffFdmQqFp
                        << "\n    tol      : " << tol);
            }

            const Real diffFdmQdPlus = std::abs(fdmNPV - qdPlusNPV);
            if (diffFdmQdPlus > 5*tol || std::isnan(diffFdmQdPlus)) {
                BOOST_ERROR("failed to reproduce QD+ values"
                        << "\n    r        : " << r
                        << "\n    q        : " << q
                        << "\n    diff     : " << diffFdmQdPlus
                        << "\n    tol      : " << 5*tol);
            }
        }
    }
}

BOOST_AUTO_TEST_CASE(testBjerksundStenslandEuropeanGreeks) {
    BOOST_TEST_MESSAGE("Testing Bjerksund-Stensland greeks when early "
                       "exercise is not optimal...");

    const Date today = Date(5, November, 2022);
    Settings::instance().evaluationDate() = today;

    const auto spot = ext::make_shared<SimpleQuote>(100);
    const Real K = 105;

    const Volatility sigma = 0.40;
    const Date maturityDate = today + Period(724, Days);

    const auto qTS = ext::make_shared<SimpleQuote>(0.0);
    const auto rTS = ext::make_shared<SimpleQuote>(0.0);

    const auto bsProcess = ext::make_shared<BlackScholesMertonProcess>(
        Handle<Quote>(spot),
        Handle<YieldTermStructure>(flatRate(qTS, Actual365Fixed())),
        Handle<YieldTermStructure>(flatRate(rTS, Actual360())),
        Handle<BlackVolTermStructure>(
            flatVol(today, sigma, Thirty360(Thirty360::European)))
    );

    struct OptionSpec {
        Option::Type type;
        Real r;
        Real q;
    };

    const OptionSpec testCaseSpecs[] = {
        {Option::Put, -0.05, 0.02},
        {Option::Call, 0.05, -0.025}
    };

    const auto europeanExercise =
        ext::make_shared<EuropeanExercise>(maturityDate);
    const auto americanExercise =
        ext::make_shared<AmericanExercise>(today, maturityDate);

    const auto europeanEngine =
        ext::make_shared<AnalyticEuropeanEngine>(bsProcess);

    const auto bjerksundStenslandEngine =
        ext::make_shared<BjerksundStenslandApproximationEngine>(bsProcess);


    for (const auto& testCaseSpec: testCaseSpecs) {
        qTS->setValue(testCaseSpec.q);
        rTS->setValue(testCaseSpec.r);

        VanillaOption americanOption(
            ext::make_shared<PlainVanillaPayoff>(testCaseSpec.type, K),
            americanExercise
        );
        americanOption.setPricingEngine(bjerksundStenslandEngine);

        VanillaOption europeanOption(
            ext::make_shared<PlainVanillaPayoff>(testCaseSpec.type, K),
            europeanExercise
        );
        europeanOption.setPricingEngine(europeanEngine);

        constexpr double tol = 1000*QL_EPSILON;

        QL_CHECK_CLOSE(europeanOption.NPV(), americanOption.NPV(), tol);
        QL_CHECK_CLOSE(europeanOption.delta(), americanOption.delta(), tol);
        QL_CHECK_CLOSE(europeanOption.strikeSensitivity(), americanOption.strikeSensitivity(), tol);
        QL_CHECK_CLOSE(europeanOption.gamma(), americanOption.gamma(), tol);
        QL_CHECK_CLOSE(europeanOption.vega(), americanOption.vega(), tol);
        QL_CHECK_CLOSE(europeanOption.theta(), americanOption.theta(), tol);
        QL_CHECK_CLOSE(europeanOption.thetaPerDay(), americanOption.thetaPerDay(), tol);
        QL_CHECK_CLOSE(europeanOption.rho(), americanOption.rho(), tol);
        QL_CHECK_CLOSE(europeanOption.dividendRho(), americanOption.dividendRho(), tol);
    }
}

BOOST_AUTO_TEST_CASE(testBjerksundStenslandAmericanGreeks) {
    BOOST_TEST_MESSAGE("Testing Bjerksund-Stensland American greeks...");

    const Date today = Date(5, December, 2022);
    Settings::instance().evaluationDate() = today;

    const auto spot = ext::make_shared<SimpleQuote>(0);
    const auto vol = ext::make_shared<SimpleQuote>(0);

    const auto qRate = ext::make_shared<SimpleQuote>(0);
    const auto rRate = ext::make_shared<SimpleQuote>(0);

    const auto bsProcess = ext::make_shared<BlackScholesMertonProcess>(
        Handle<Quote>(spot),
        Handle<YieldTermStructure>(flatRate(qRate, Actual360())),
        Handle<YieldTermStructure>(flatRate(rRate, Actual365Fixed())),
        Handle<BlackVolTermStructure>(
            flatVol(today, vol, Thirty360(Thirty360::ISDA)))
    );

    const auto bjerksundStenslandEngine =
        ext::make_shared<BjerksundStenslandApproximationEngine>(bsProcess);

    const Real strike = 100;
    const Option::Type types[] = { Option::Call, Option::Put };
    const Rate rf[] = {0.0, 0.02, 0.06, 0.1, 0.2};
    const Rate qy[] = {0.0, 0.08, 0.12};

    const Volatility sig[] = {0.1, 0.2, 0.4, 1.0};
    const Real S[] = {25, 50, 99.9, 110, 150, 200};
    const Size T[] = {30, 182, 365, 1825};

    const Real f_d = 1e-5;
    const Real f_g = 5e-5;
    const Real f_q = 1e-6;

    for (auto type: types) {
        const auto payoff = [type](Real strike) {
            return ext::make_shared<PlainVanillaPayoff>(type, strike);};

        const auto stdPayoff = payoff(strike);

        for (auto t: T) {
            const Date maturityDate = today + Period(t, Days);
            const auto exercise = [today, maturityDate](const Period& offset) {
                return ext::make_shared<AmericanExercise>(
                    today, maturityDate + offset);};

            const auto stdExercise = exercise(Period(0, Days));

            VanillaOption option(stdPayoff, stdExercise);
            option.setPricingEngine(bjerksundStenslandEngine);

            VanillaOption strike_up(payoff(strike*(1+f_d)), stdExercise);
            strike_up.setPricingEngine(bjerksundStenslandEngine);
            VanillaOption strike_down(payoff(strike*(1-f_d)), stdExercise);
            strike_down.setPricingEngine(bjerksundStenslandEngine);

            VanillaOption day_up(stdPayoff, exercise(Period(1, Days)));
            day_up.setPricingEngine(bjerksundStenslandEngine);
            VanillaOption day_down(stdPayoff, exercise(Period(-1, Days)));
            day_down.setPricingEngine(bjerksundStenslandEngine);


            for (auto r: rf) {
                rRate->setValue(r);
                for (auto q: qy) {
                    qRate->setValue(q);
                    for (auto v: sig) {
                        vol->setValue(v);
                        for (auto s: S) {
                            spot->setValue(s);

                            const Real npv = option.NPV();
                            const Real delta = option.delta();
                            const Real gamma = option.gamma();
                            const Real strikeSensitivity = option.strikeSensitivity();
                            const Real dividendRho = option.dividendRho();
                            const Real rho = option.rho();
                            const Real vega = option.vega();
                            const Real theta = option.theta();
                            const auto exerciseType = ext::any_cast<std::string>(
                                option.additionalResults().find("exerciseType")->second);

                            OneAssetOption::results numericalResults;

                            spot->setValue(s*(1+f_d));
                            const Real f2 = option.NPV();
                            spot->setValue(s*(1-f_d));
                            const Real f1 = option.NPV();
                            spot->setValue(s);
                            numericalResults.delta = (f2 - f1)/(2*f_d*s);

                            Real error = std::abs(delta - numericalResults.delta);
                            if (error > 5e-6)
                                REPORT_FAILURE("delta", \
                                    stdPayoff, stdExercise, s, q, r, today, v, \
                                    numericalResults.delta, delta, error, 5e-6);

                            spot->setValue(s*(1+2*f_g));
                            const Real gp2 = option.NPV();
                            spot->setValue(s*(1+f_g));
                            const Real gp1 = option.NPV();
                            spot->setValue(s*(1-f_g));
                            const Real gm1 = option.NPV();
                            spot->setValue(s*(1-2*f_g));
                            const Real gm2 = option.NPV();
                            spot->setValue(s);
                            numericalResults.gamma
                                = (-gp2 + 16*gp1 - 30*npv + 16*gm1 - gm2)/(12*squared(f_g*s));

                            error = std::abs(gamma - numericalResults.gamma);
                            if (error > 1e-4 && t < 1000)
                                REPORT_FAILURE("gamma", \
                                    stdPayoff, stdExercise, s, q, r, today, v, \
                                    numericalResults.gamma, gamma, error, 5e-5);

                            const Real k2 = strike_up.NPV();
                            const Real k1 = strike_down.NPV();
                            numericalResults.strikeSensitivity = (k2 - k1)/(2*f_d*strike);
                            error = std::abs(strikeSensitivity - numericalResults.strikeSensitivity);

                            if (error > 5e-6)
                                REPORT_FAILURE("strikeSensitivity", \
                                    stdPayoff, stdExercise, s, q, r, today, v, \
                                    numericalResults.strikeSensitivity, strikeSensitivity, error, 5e-6);

                            if (q != 0.0) {
                                qRate->setValue(q + f_q);
                                const Real q2 = option.NPV();
                                qRate->setValue(q - f_q);
                                const Real q1 = option.NPV();
                                qRate->setValue(q);
                                numericalResults.dividendRho = (q2-q1)/(2*f_q);

                                error = std::abs(dividendRho - numericalResults.dividendRho);

                                if (error > 3e-2)
                                    REPORT_FAILURE("dividendRho", \
                                        stdPayoff, stdExercise, s, q, r, today, v, \
                                        numericalResults.dividendRho, dividendRho, error, 1e-3);

                                rRate->setValue(r + f_q);
                                const Real r2 = option.NPV();
                                rRate->setValue(r - f_q);
                                const Real r1 = option.NPV();
                                rRate->setValue(r);
                                numericalResults.rho = (r2 - r1)/(2*f_q);

                                error = std::abs(rho - numericalResults.rho);
                                if (error > 3e-2)
                                    REPORT_FAILURE("rho", \
                                        stdPayoff, stdExercise, s, q, r, today, v, \
                                        numericalResults.rho, rho, error, 1e-3);
                            }

                            vol->setValue(v + f_d);
                            const Real v2 = option.NPV();
                            vol->setValue(v - f_d);
                            const Real v1 = option.NPV();
                            vol->setValue(v);
                            numericalResults.vega = (v2 - v1)/(2*f_d);

                            error = std::abs(vega - numericalResults.vega);
                            if (error > 5e-4)
                                REPORT_FAILURE("vega", \
                                    stdPayoff, stdExercise, s, q, r, today, v, \
                                    numericalResults.vega, vega, error, 5e-4);

                            if (exerciseType == "American") {
                                const Real t2 = day_up.NPV();
                                const Real t1 = day_down.NPV();
                                numericalResults.thetaPerDay = (t1-t2)/2;
                                numericalResults.theta = 365*numericalResults.thetaPerDay;
                                error = std::abs(theta - numericalResults.theta);
                                const Real thetaTol = (t < 60) ? 3.0: 5e-4;
                                if (error > thetaTol) {
                                  REPORT_FAILURE("theta", \
                                      stdPayoff, stdExercise, s, q, r, today, v, \
                                      numericalResults.theta, theta, error, thetaTol);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

BOOST_AUTO_TEST_CASE(testSingleBjerksundStenslandGreeks) {
    BOOST_TEST_MESSAGE("Testing a single Bjerksund-Stensland greeks set...");

    const Date today = Date(20, January, 2023);
    Settings::instance().evaluationDate() = today;

    const Real s = 100;
    const Volatility v = 0.3;
    const Rate q = 0.04;
    const Rate r = 0.07;

    const auto spot = ext::make_shared<SimpleQuote>(s);
    const auto vol = ext::make_shared<SimpleQuote>(v);

    const auto qRate = ext::make_shared<SimpleQuote>(q);
    const auto rRate = ext::make_shared<SimpleQuote>(r);

    const auto bsProcess = ext::make_shared<BlackScholesMertonProcess>(
        Handle<Quote>(spot),
        Handle<YieldTermStructure>(flatRate(qRate, Actual365Fixed())),
        Handle<YieldTermStructure>(flatRate(rRate, Actual365Fixed())),
        Handle<BlackVolTermStructure>(
            flatVol(today, vol, Actual365Fixed()))
    );

    const Date maturityDate = today + Period(2, Years);

    const auto exercise
        = ext::make_shared<AmericanExercise>(today, maturityDate);
    const auto payoff
        = ext::make_shared<PlainVanillaPayoff>(Option::Call, 100);

    VanillaOption option(payoff, exercise);

    option.setPricingEngine(
        ext::make_shared<BjerksundStenslandApproximationEngine>(bsProcess)
    );

    const Real npv = option.NPV();
    const Real delta = option.delta();
    const Real gamma = option.gamma();
    const Real strikeSensitivity = option.strikeSensitivity();
    const Real divRho = option.dividendRho();
    const Real rho = option.rho();
    const Real vega = option.vega();
    const Real theta = option.theta();
    const Real thetaPerDay = option.thetaPerDay();
    const auto exerciseType = ext::any_cast<std::string>(
        option.additionalResults().find("exerciseType")->second);

    const Real expectedNpv = 17.9251834488399169;
    const Real expectedDelta = 0.590801845261082592;
    const Real expectedGamma = 0.00825347110063545664;
    const Real expectedStrikeSensitivity = -0.411550010772683383;
    const Real expectedDivRho = -114.137818682236826;
    const Real expectedRho = 80.4900013901554416;
    const Real expectedVega = 49.2906331545933227;
    const Real expectedTheta = -4.22540293840206704;

    const auto report = [=](Real value, Real expectedValue, const std::string& name) {
        constexpr double tol = 1e6*QL_EPSILON;
        const Real error = std::abs(value-expectedValue);
        if (error > tol)
            REPORT_FAILURE(name, \
                payoff, exercise, s, q, r, today, v, \
                value, expectedValue, error, tol);
    };

    report(npv, expectedNpv, "npv");
    report(delta, expectedDelta, "delta");
    report(gamma, expectedGamma, "gamma");
    report(strikeSensitivity, expectedStrikeSensitivity,
            "strikeSensitivity");
    report(divRho, expectedDivRho, "dividendRho");
    report(rho, expectedRho, "rho");
    report(vega, expectedVega, "vega");
    report(theta, expectedTheta, "theta");
    report(thetaPerDay, expectedTheta/365, "thetaPerDay");

    if (exerciseType != "American")
        BOOST_FAIL("American exercise type expected");
}

BOOST_AUTO_TEST_SUITE_END()

BOOST_AUTO_TEST_SUITE_END()

</source_files>

<implementation_guidance>

File: test-suite/fdmpositivitypreserving.cpp

=== TEST T1: Fitted Operator M-Matrix Guarantee ===
Setup: FdmFittedBlackScholesOp with parameters:
  œÉ = {0.001, 0.01, 0.1, 0.5, 1.0}, r = {0.01, 0.05, 0.1, 0.5}
  Grid sizes: 50, 200, 800. Both uniform and concentrated meshes.
Assertion: mMatrixViolationCount() == 0 for ALL combinations on uniform meshes.


=== TEST T2: Positivity Preservation (Scheme 1 vs Standard CN) ===
Setup: Truncated call (Definition 4.1):
  K=50, U=70, T=5/12, r=0.05, œÉ=0.001, S_max=140
  Log-space grid: 800 nodes, Œît=0.01

GRID RESOLUTION NOTE (M3 fix): The paper uses ~2800 S-space nodes (ŒîS=0.05,
S_max=140). This test uses 800 log-space nodes, which is a QUALITATIVELY
different mesh. This test validates positivity/oscillation properties, NOT
exact reproduction of the paper's figures. For approximate reproduction of
the paper's S-space resolution, see the optional T2b variant below.

Run with:
  (a) Standard FdmBlackScholesOp + CrankNicolson
  (b) FdmFittedBlackScholesOp + ImplicitEuler (Scheme 1)

Assertions:
  (a) Standard CN: negativeCount > 0 OR oscillationScore > 0.05
  (b) Fitted: min(u) ‚â• 0, negativeCount == 0, oscillationScore < 0.01


=== TEST T2b (OPTIONAL): High-Resolution Positivity Check ===
Same setup as T2, but with 4000 log-space nodes and Œît=0.005.
Same assertions, wider tolerance (oscillationScore < 0.05 for scheme 1).
Purpose: Approximate the paper's S-space grid resolution in log-space.


=== TEST T3: Positivity Preservation (Scheme 2 ‚Äî CN Variant) ===
Same truncated call as T2. Run with FdmCNVariantBlackScholesOp + CN.
Assertions: min(u) ‚â• ‚àí1e-10, oscillationScore < 0.01.
Additional: document that timestepConstraint() < Œît used.


=== TEST T4: Convergence Rate (Scheme 1) ===
European call (smooth payoff): S‚ÇÄ=100, K=100, T=1.0, r=0.05, q=0.02, œÉ=0.2
Reference: Black-Scholes closed form.
Grid sizes N = 50, 100, 200, 400.
Assertion: Richardson error ratio approaches 2.0 (first-order spatial).


=== TEST T5: Convergence Rate (Scheme 2) ===
Same European call. Grid sizes N = 50, 100, 200, 400.
Assertion: Richardson error ratio approaches 4.0 (second-order spatial).


=== TEST T6: Discrete Double Barrier Knock-Out ===
K=100, L=95, U=110, T=1, r=0.05, œÉ=0.001, monthly monitoring (12 dates).
Use FdmSchemeDesc::FittedImplicit() and FdmSchemeDesc::CNVariant(2).
Both: min(u) ‚â• 0, oscillationScore < 0.01.
Standard CN without damping should show oscillations near barriers.


=== TEST T7: Artificial Diffusion Comparison ===
Truncated call at multiple grid sizes (200, 400, 800, 1600 log-space nodes).
Verify: error ratio ~2 for Scheme 1, ~4 for Scheme 2.


=== TEST T8: Backward Compatibility ===
European call with FdmSchemeDesc::Douglas() and FdmSchemeDesc::CrankNicolson().
NPV must match stored reference values to machine epsilon.

=== TEST T9: Grid Alignment Effect ===
Setup: Discrete barrier knock-out with barriers at L=95.037, U=110.037
(intentionally NOT grid-aligned) vs L=95, U=110 (grid-aligned).
Both with FdmSchemeDesc::FittedImplicit().
Assertion: misaligned barriers produce larger error near the barriers
(measured by max|V_aligned ‚àí V_misaligned| near barriers).


=== TEST T10: Time-Step Constraint Validation (CN Variant) ===
Setup: CN variant with œÉ=0.001, r=0.05.
Run with Œît = 0.5 * timestepConstraint() (should succeed, positive solution)
and Œît = 2.0 * timestepConstraint() (may produce negative values).
Assertion: First run has min(u) ‚â• 0. Second run documents behavior.


=== TEST T11: Accuracy Constraint Awareness ===
Truncated call with œÉ=0.001, r=0.05.
Scheme 1 with h=0.1 (numerical diffusion ‚â´ physical) vs h=0.001.
Scheme 2 with h=0.1 vs h=0.001.
Assertion: Error vs analytical decreases with h; ratio consistent with
O(h) for Scheme 1 and O(h¬≤) for Scheme 2.

</implementation_guidance>

<constraints>
- All tests must not depend on external data files
- Each test should complete in < 10 seconds
- T2/T3: use 0.0 for strict positivity on Scheme 1; -1e-10 for Scheme 2
- T8 uses hardcoded reference values from unmodified QuantLib
- T2 and T2b document that log-space grids are NOT S-space equivalents
</constraints>

<output_specification>
Produce 1 file:
1. fdmpositivitypreserving.cpp (complete test file)
</output_specification>

<quality_checklist>
‚ñ° All 8+ tests present with meaningful assertions
‚ñ° T1 checks M-matrix guarantee across many parameter combinations
‚ñ° T2 demonstrates the problem (CN fails) and the fix (Scheme 1 works)
‚ñ° T2 documents grid resolution difference from the paper
‚ñ° T3 validates Scheme 2 and documents CE-20 constraint violation
‚ñ° T4/T5 check convergence rates via Richardson ratios
‚ñ° T6 uses barrier monitoring with both schemes
‚ñ° T7 quantifies artificial diffusion differences
‚ñ° T8 ensures backward compatibility
‚ñ° All tests use QuantLib infrastructure (Process, TermStructure, etc.)
‚ñ° Log-space grid sizes specified directly (not S-space equivalents)
‚ñ° If test framework patterns are missing, STOP and ask
</quality_checklist>
