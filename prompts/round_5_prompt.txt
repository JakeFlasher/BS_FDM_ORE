<system_context>
You are an expert C++ developer implementing two positivity-preserving finite
difference schemes from Milev & Tagliani (2010) into QuantLib 1.42-dev's modern
Fdm* framework. The schemes address spurious oscillations and negative prices
that standard Crank‚ÄìNicolson produces when œÉ¬≤ ‚â™ r and payoffs are discontinuous.

PAPER REFERENCE (corrected formulations):
Scheme 1: Fully implicit with Duffy's exponentially fitted diffusion coefficient.
Scheme 2: Crank‚ÄìNicolson variant with a modified 6-node reaction-term stencil.
Both are described in the GOLDEN REFERENCE DOCUMENT (ROUND 1.5 output), whose
corrected equation chain (CE-1 through CE-25) is authoritative.

SOURCE-OF-TRUTH / NO-HALLUCINATION RULES (mandatory):
- Use ONLY the provided source files and prior-ROUND outputs as factual reference
  for class/method signatures, include paths, base-class requirements, and
  coding conventions.
- If any referenced file content is missing (i.e., an [INSERT FULL CONTENT ...]
  placeholder is not filled), DO NOT guess or reconstruct.
  STOP and ask the user to provide the missing file(s).
- If a requirement is ambiguous, search the provided files for the relevant
  implementation detail and implement the behavior that matches the source.
  If still ambiguous, STOP and ask a precise clarification question.

INTERNAL VERIFICATION PROTOCOL (mandatory; do before coding; do not print):
- Verify what the 1D BS mesher stores as spatial coordinate x (ln(S), ln(S/K),
  or other) by reading FdmBlackScholesMesher and FdmBlackScholesOp.
- Verify how FirstDerivativeOp / SecondDerivativeOp incorporate nonuniform mesh
  spacing (which mesher spacing functions they use).
- Verify the TripleBandLinearOp sign conventions: which off-diagonal coefficients
  must be nonneg for the system matrix (I ‚àí Œ∏¬∑dt¬∑L) to be an M-matrix.
- Verify how FdmBackwardSolver handles step conditions (rollback segmentation at
  stopping times, and whether applyTo is called at the initial 'from' time).
- Verify that ext::make_shared<T>(...) is available in QuantLib's ext namespace.
  If it is not aliased, fall back to ext::shared_ptr<T>(new T(...)).

CODING CONVENTIONS (mandatory):
- Namespace: all classes in `namespace QuantLib { }`
- Smart pointers: use `ext::shared_ptr`, NOT `std::shared_ptr`
- Factory calls: prefer `ext::make_shared<T>(...)` if available; verify from
  provided headers before use. Fallback: `ext::shared_ptr<T>(new T(...))`.
- Return arrays: use `Array`
- Assertions: `QL_REQUIRE(condition, message)` for preconditions,
  `QL_ENSURE(condition, message)` for postconditions
- Include guards: `#ifndef quantlib_<path_underscored>_hpp`
- Copyright header: match the style of adjacent files in the same directory
- Includes: use angle brackets `<ql/...>` for QuantLib headers
- No `using namespace std;` in headers
- Naming: `camelCase` for methods, `camelCase_` for private members,
  `CamelCase` for classes

OUTPUT RULES:
- Produce COMPLETE files, never diffs or partial snippets
- Only output files that are new or modified in this ROUND
- Each file must compile against unmodified QuantLib 1.42-dev headers plus any
  files produced in prior ROUNDs
- Include all necessary #include directives
</system_context>


<mathematical_context>
PAPER'S ORIGINAL PDE (S-space, time-to-expiry œÑ; CE-1):
  ‚àí‚àÇV/‚àÇœÑ + rS¬∑‚àÇV/‚àÇS + ¬ΩœÉ¬≤S¬≤¬∑‚àÇ¬≤V/‚àÇS¬≤ ‚àí rV = 0

NOTATION WARNING ‚Äî TWO DIFFERENT œÉ's IN THE PAPER:
  Document 5 (Eq. 2) rewrites the PDE in generalized form:
    ‚àíV_t + Œº(S,t)¬∑V_S + œÉ(S,t)¬∑V_SS + b(S,t)¬∑V = 0
  where œÉ(S,t) = ¬ΩœÉ¬≤_vol¬∑S¬≤ is the DIFFUSION COEFFICIENT, NOT the volatility.
  The fitting factor formula (Eq. 3) uses this diffusion coefficient œÉ(S,t).
  An implementer who substitutes œÉ_vol directly for œÉ(S,t) will get completely
  wrong results. In log-space this ambiguity is resolved: a = œÉ¬≤_vol/2 is
  always the half-variance, and b = (r‚àíq) ‚àí œÉ¬≤_vol/2 is the drift.

DIVIDEND YIELD NOTE:
  The original papers assume q = 0. The QuantLib implementation generalizes
  to q ‚â• 0 via b = (r‚àíq) ‚àí œÉ¬≤/2. All paper-specific analysis uses q = 0.

QUANTLIB LOG-SPACE PDE (x = ln(S), backward time œÑ):
  ‚àíu_œÑ + b¬∑u_x + a¬∑u_xx ‚àí r¬∑u = 0
  where a = œÉ¬≤/2,  b = (r ‚àí q) ‚àí œÉ¬≤/2

‚ïê‚ïê‚ïê SCHEME 1: EXPONENTIALLY FITTED OPERATOR (CE-7 through CE-15) ‚ïê‚ïê‚ïê

In log-space, the P√©clet parameter and fitting factor at interior node j are:
  Pe_j = b ¬∑ h_j / (2¬∑a)                   (local P√©clet number)
  œÅ_j = Pe_j ¬∑ coth(Pe_j)                  (fitting factor; œÅ ‚Üí 1+Pe¬≤/3 for |Pe|‚Üí0)

SPATIAL VARIATION NOTE:
  In S-space, the P√©clet parameter Œ±_j = r¬∑ŒîS/(œÉ¬≤¬∑S_j) varies with S_j:
  it is large for small S_j (upwind regime) and small for large S_j (centered
  regime). In log-space with uniform h, Pe = bh/(2a) is CONSTANT across nodes,
  but with nonuniform h (concentrated meshes), Pe_j varies per node. The fitting
  factor œÅ_j ‚â• 1 for all Pe_j, regardless of sign or magnitude.

Fitted stencil (replacing the standard centered operator):
  ‚Ñì_j = a¬∑œÅ_j/h¬≤ ‚àí b/(2h)     (lower off-diagonal)
  d_j = ‚àí2¬∑a¬∑œÅ_j/h¬≤ ‚àí r        (main diagonal)
  u_j = a¬∑œÅ_j/h¬≤ + b/(2h)     (upper off-diagonal)

NON-NEGATIVITY PROOF (for M-matrix):
  The lower off-diagonal can be rewritten as:
    ‚Ñì_j = (b/(2h))¬∑(coth(Pe) ‚àí 1)
  and the upper as:
    u_j = (b/(2h))¬∑(coth(Pe) + 1)

  For b > 0 (Pe > 0): coth(Pe) > 1, so coth(Pe)‚àí1 > 0; b/(2h) > 0. ‚Ñì_j > 0.
                       coth(Pe) + 1 > 0; u_j > 0.
  For b < 0 (Pe < 0): coth(Pe) < ‚àí1, so coth(Pe)‚àí1 < ‚àí2 (neg); b/(2h) < 0.
                       Product of two negatives: ‚Ñì_j > 0.
                       coth(Pe)+1 < 0 (neg); b/(2h) < 0. u_j > 0.
  For b = 0: œÅ ‚Üí 1, ‚Ñì_j = a/h¬≤ > 0, u_j = a/h¬≤ > 0.

  KEY PROPERTY: The inequality œÅ_j ‚â• 1 holds for ALL real Pe_j because
  x¬∑coth(x) ‚â• 1 for all x (equality only at x=0 in the limit). This guarantee
  is per-node and holds on ANY mesh (uniform or nonuniform).

  On UNIFORM meshes this guarantees system matrix (I ‚àí Œ∏¬∑dt¬∑L) is an M-matrix
  for any h > 0 and any parameter values.
  On NONUNIFORM meshes, the guarantee holds when the mesh ratio d‚Å∫/d‚Åª is
  moderate (typically < 3:1). The mMatrixViolationCount() diagnostic verifies
  this at runtime.

This ensures the system matrix (I ‚àí Œ∏¬∑dt¬∑L) is an M-matrix.

Artificial diffusion (CE-15, low-œÉ limit): ¬Ω¬∑r¬∑S¬∑ŒîS¬∑V_SS in S-space.
In log-space with uniform grid: ¬Ω¬∑b¬∑h¬∑u_xx (from the upwind limiting scheme).

NOTE ON PAPER TYPO (p. 227): The upwind scheme formulas on p. 227 show a
denominator of 2h, but direct computation shows the correct denominator is h.
The subsequent consistency analysis (eq. 7) and numerical diffusion formula
¬ΩŒºh¬∑V_SS are correct ‚Äî they correspond to the actual limiting scheme with h.

NONUNIFORM GRID NOTE: For non-uniform meshes, compute a per-node effective
spacing consistent with QuantLib's derivative operators:
  h_j := 0.5*(dplus_j + dminus_j)
At boundary nodes (first/last), dplus or dminus is Null<Real>(); skip these
nodes in per-node computations (they are handled by boundary conditions).

‚ïê‚ïê‚ïê SCHEME 2: CN VARIANT WITH MODIFIED REACTION TERM (CE-16 through CE-23) ‚ïê‚ïê‚ïê

The paper's CN variant replaces ‚àír¬∑u_j with the 6-node stencil:
  ‚àír¬∑[œâ¬∑u_{j‚àí1} + (1‚àí2œâ)¬∑u_j + œâ¬∑u_{j+1}]
at each time level, with œâ‚ÇÅ = œâ‚ÇÇ = œâ (symmetric weighting).

PARAMETER CHOICE (CE-19):
  œâ = ‚àír/(16œÉ¬≤)

EFFECTIVE-DIFFUSION REFORMULATION FOR LOG-SPACE ASSEMBLY:
  The paper's CN variant applies the FULL off-diagonal reaction weight œâ at
  each time level (eq. 8: each level sums to ¬Ω, but œâ appears unsplit).
  Standard CN time-stepping halves the operator. To compensate, the spatial
  operator L must contain 2|rœâ| on its off-diagonals so that after CN's
  ¬Ω-factor, the system matrix reproduces the paper's P and N.

  This is mathematically equivalent to using an enhanced diffusion coefficient:
    a_eff = œÉ¬≤/2 + r¬≤¬∑h¬≤/(8¬∑œÉ¬≤)
  with the standard reaction term ‚àír, assembled via the standard axpyb() pattern.

  PROOF: With a_eff, standard CN produces system matrix P = I ‚àí ¬ΩŒît¬∑L where:
    L_lower = a_eff/h¬≤ ‚àí b/(2h) = œÉ¬≤/(2h¬≤) + r¬≤/(8œÉ¬≤) ‚àí b/(2h)
    P_lower = ‚àí¬ΩŒît¬∑L_lower
    The additional off-diagonal vs standard CN: ‚àí¬ΩŒît¬∑r¬≤/(8œÉ¬≤) = ‚àíŒît¬∑r¬≤/(16œÉ¬≤)

    In the paper's S-space P matrix (Document 5, p. 228), the additional
    off-diagonal from the distributed reaction is rœâ‚ÇÇ = ‚àír¬≤/(16œÉ¬≤), which
    when multiplied by Œît (to convert from the paper's 1/Œît-normalized form)
    gives ‚àíŒît¬∑r¬≤/(16œÉ¬≤). These match. ‚àé

  IMPORTANT: The coefficient is r¬≤h¬≤/(8œÉ¬≤), NOT r¬≤h¬≤/(16œÉ¬≤).
  The factor-of-2 arises because the paper places FULL œâ at each CN time level
  while standard CN halves the operator contribution. Without the doubling, we
  would get r¬≤h¬≤/(16œÉ¬≤) ‚Äî which is wrong by exactly a factor of 2.

M-MATRIX GUARANTEE FOR CN VARIANT (corrected from audit ¬ß4b):
  In S-space, the P lower entry with œâ = ‚àír/(16œÉ¬≤) is:
    P_lower = rœâ + rS_j/(4ŒîS) ‚àí œÉ¬≤S_j¬≤/(4ŒîS¬≤)
            = ‚àír¬≤/(16œÉ¬≤) + rj/4 ‚àí œÉ¬≤j¬≤/4     (where j = S_j/ŒîS)
  Completing the square:
    = ‚àí(œÉ¬≤/4)¬∑(j ‚àí r/(2œÉ¬≤))¬≤
  This is a SINGLE non-positive perfect square: P_lower ‚â§ 0 for ALL j ‚â• 0.
  Similarly, P_upper = ‚àír¬≤/(16œÉ¬≤) ‚àí rj/4 ‚àí œÉ¬≤j¬≤/4 < 0 for j > 0.
  Therefore P is ALWAYS an M-matrix, unconditionally ‚Äî no parameter
  restrictions needed for the off-diagonals.

  In log-space, the equivalent condition on the L operator (L_lower ‚â• 0) is:
    a_eff/h¬≤ ‚àí b/(2h) ‚â• 0,  i.e.,  a_eff ‚â• bh/2
  Since a_eff = œÉ¬≤/2 + r¬≤h¬≤/(8œÉ¬≤) and b ‚âà r for q=0, œÉ‚â™r:
    r¬≤h¬≤/(8œÉ¬≤) ‚â• rh/2  ‚ü∫  rh/(4œÉ¬≤) ‚â• 1  ‚ü∫  h ‚â• 4œÉ¬≤/r
  For œÉ=0.001, r=0.05: h ‚â• 8√ó10‚Åª‚Åµ ‚Äî effectively always satisfied.

TIME-STEP CONSTRAINT (CE-20, log-space form):
  For N ‚â• 0 (explicit-side diagonal non-negative):
    1 ‚àí 0.5¬∑Œît¬∑(2¬∑a_eff/h¬≤ + r) ‚â• 0
  ‚üπ  Œît < 1 / [œÉ¬≤/(2h¬≤) + r¬≤/(8œÉ¬≤) + r/2]
  This is less restrictive than the S-space form (no growing (œÉM)¬≤ term)
  but still very tight for small œÉ. For œÉ=0.001, r=0.05, h=0.01:
  the r¬≤/(8œÉ¬≤) = 312.5 term dominates, giving Œît < 0.0032.

ACCURACY CONSTRAINTS (from audit ¬ß5b):
  Scheme 1 numerical diffusion (S-space): ¬ΩrSŒîS¬∑V_SS
  For this to be negligible vs physical diffusion ¬ΩœÉ¬≤S¬≤¬∑V_SS:
    ŒîS ‚â™ œÉ¬≤S/r
  At S=100, œÉ=0.001, r=0.05: ŒîS ‚â™ 0.002. With ŒîS=0.05, numerical diffusion
  is ~25√ó the physical diffusion ‚Äî the solution is heavily smeared.

  Scheme 2 numerical diffusion (S-space): ‚Öõ(rŒîS/œÉ)¬≤¬∑V_SS
  For this ‚â™ ¬ΩœÉ¬≤S¬≤¬∑V_SS: need (rŒîS/œÉ)¬≤ ‚â™ 4œÉ¬≤S¬≤
  Equivalently: ŒîS ‚â™ 2œÉ¬≤S/r (same order as Scheme 1 at moderate S).

  In log-space with uniform h:
    Scheme 1 diffusion: ¬Ωbh¬∑u_xx ‚Üí need h ‚â™ 2a/b = œÉ¬≤/(r‚àíq‚àíœÉ¬≤/2) ‚âà œÉ¬≤/r
    Scheme 2 diffusion: r¬≤h¬≤/(8œÉ¬≤)¬∑u_xx ‚Üí need h ‚â™ 2œÉ/r (from r¬≤h¬≤/(8œÉ¬≤) ‚â™ œÉ¬≤/2)

  PRACTICAL GUIDELINE: For œÉ=0.001, r=0.05, both schemes need h ‚â≤ 2√ó10‚Åª‚Åµ
  (roughly 50,000+ log-space nodes on [ln(50), ln(150)]) for diffusion-free
  accuracy. Coarser grids are usable but introduce measurable smearing.

SCHEME CROSSOVER ANALYSIS (from audit ¬ß5c):
  The two numerical diffusion terms are equal (in S-space) when:
    ¬ΩrSŒîS = ‚Öõ(rŒîS/œÉ)¬≤  ‚üπ  ŒîS = 4œÉ¬≤S/r
  For coarser grids (ŒîS > 4œÉ¬≤S/r), Scheme 1 has LESS diffusion.
  For finer grids, Scheme 2 wins due to its ŒîS¬≤ dependence.
  For œÉ=0.001, r=0.05, S=100: crossover at ŒîS ‚âà 0.008.

Artificial diffusion (CE-23): ‚Öõ¬∑(r¬∑ŒîS/œÉ)¬≤¬∑V_SS in S-space.

NOTE ON FittedCrankNicolson POSITIVITY ANALYSIS:
  Combining Scheme 1's fitted operator with CN time-stepping:
  - P = I ‚àí ¬ΩŒît¬∑L: off-diag = ‚àí¬ΩŒît¬∑(fitted L off-diag) ‚â§ 0 (M-matrix ‚úì)
    because fitted L off-diags are ‚â• 0 (proven above).
  - N = I + ¬ΩŒît¬∑L: off-diag = ¬ΩŒît¬∑(fitted L off-diag) ‚â• 0 (non-negative ‚úì)
  - N diagonal requires: 1 ‚àí ¬ΩŒît¬∑(2aœÅ/h¬≤ + r) ‚â• 0
    ‚üπ Œît ‚â§ 1/(aœÅ_max/h¬≤ + r/2)
  Since œÅ_max ‚âà |Pe_max| for large Pe, and Pe = bh/(2a):
    Œît ‚â§ 1/(|b|/(2h) + r/2)
  This is LESS restrictive than the CN variant's constraint (no r¬≤/(8œÉ¬≤) term)
  and may be preferable for very low volatility. However, the temporal accuracy
  is O(Œît¬≤) only, not the CN variant's O(Œît¬≤,h¬≤) ‚Äî the spatial accuracy is
  O(h) from the fitting.

‚ïê‚ïê‚ïê DISCRETE BARRIER MONITORING (CE-6) ‚ïê‚ïê‚ïê

At each monitoring date t_i, after the time-step solve:
  U_j ‚Üê U_j ¬∑ ùüô_{[L,U]}(S_j)
This re-introduces discontinuities that the schemes must handle.

GRID ALIGNMENT REQUIREMENT:
  The barrier values L, U (and ideally the strike K) should be GRID POINTS.
  The paper uses ŒîS=0.05 with L=90, K=100, U=110 ‚Äî all exact multiples.
  Violating this introduces interpolation error that can reintroduce oscillations.
  In log-space: ln(L), ln(U), ln(K) should be mesher locations. QuantLib's
  Concentrating1dMesher can place nodes at specified points. The
  FdmBlackScholesMesher already concentrates aROUND the strike; users should
  also ensure barrier locations are mesher concentration points.

S_MAX SELECTION (from Document 1, Eq. 5.2):
  S_max = max{R¬∑K, K¬∑exp(‚àö(2TœÉ¬≤¬∑ln 100))},  R ‚â• 2
  For very low œÉ: S_max = R¬∑K (rule of thumb: 3‚Äì4 times the strike).
  For moderate œÉ: the exponential term dominates.
  In log-space: x_max = ln(S_max), x_min = ln(S_min) with S_min small but >0.

‚ïê‚ïê‚ïê M-MATRIX DIAGNOSTIC (CE-10, Proposition 4.1) ‚ïê‚ïê‚ïê

For the operator L stored in mapT_, the M-matrix condition for the system
matrix (I ‚àí Œ∏¬∑dt¬∑L) requires:
  All off-diagonals of L (lower_[] and upper_[]) must be NON-NEGATIVE.
  (Because system off-diag = ‚àíŒ∏¬∑dt¬∑(operator off-diag), and Œ∏¬∑dt > 0.)

To access protected lower_[]/upper_[] arrays of TripleBandLinearOp, construct
a temporary ModTripleBandLinearOp from mapT_ and use its public accessors.

‚ïê‚ïê‚ïê NOTE ON FittedCrankNicolson COMBINATION ‚ïê‚ïê‚ïê

The paper uses Scheme 1 (fitted operator) with fully-implicit time stepping ONLY.
The FittedCrankNicolson factory (Scheme 1 operator + CN time stepping) is a
natural EXTENSION not present in the original paper. It may offer improved
temporal accuracy but its M-matrix and positivity properties differ from the
paper's proven guarantees. See the positivity analysis above for details.
Use with appropriate testing.

‚ïê‚ïê‚ïê LOCAL VOLATILITY CAVEAT ‚ïê‚ïê‚ïê

With local or stochastic volatility, œÉ = œÉ(S,t):
- The fitting factor must be recomputed every time step (handled by setTime())
- The CN variant parameter œâ = ‚àír/(16œÉ¬≤) becomes spatially varying
- The M-matrix guarantees remain valid per-node (the algebraic identities
  hold for any œÉ_j > 0) but the time-step constraint for the CN variant
  becomes node-dependent; use the worst-case node.
- Positivity guarantees for the quanto-adjusted case have NOT been verified.
</mathematical_context>

<task>
ROUND 5 OF 7: Modify the user-facing pricing engine to expose new capabilities,
wire the barrier projection condition into the step condition composite, and
update header registrations.

OUTPUT: 6-8 files.
</task>

<source_files>
FILE: ql/pricingengines/vanilla/fdblackscholesvanillaengine.hpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdblackscholesvanillaengine.hpp
    \brief Finite-differences Black Scholes vanilla option engine
*/

#ifndef quantlib_fd_black_scholes_vanilla_engine_hpp
#define quantlib_fd_black_scholes_vanilla_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/pricingengines/vanilla/cashdividendeuropeanengine.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    class FdmQuantoHelper;
    class GeneralizedBlackScholesProcess;

    //! Finite-differences Black Scholes vanilla option engine
    /*! \ingroup vanillaengines

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature
              and comparison with Black pricing.
    */
    class FdBlackScholesVanillaEngine : public VanillaOption::engine {
      public:
        enum CashDividendModel {
            Spot = CashDividendEuropeanEngine::Spot,
            Escrowed = CashDividendEuropeanEngine::Escrowed
        };

        explicit FdBlackScholesVanillaEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess>,
            Size tGrid = 100,
            Size xGrid = 100,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas(),
            bool localVol = false,
            Real illegalLocalVolOverwrite = -Null<Real>(),
            CashDividendModel cashDividendModel = Spot);

        FdBlackScholesVanillaEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess>,
            DividendSchedule dividends,
            Size tGrid = 100,
            Size xGrid = 100,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas(),
            bool localVol = false,
            Real illegalLocalVolOverwrite = -Null<Real>(),
            CashDividendModel cashDividendModel = Spot);

        FdBlackScholesVanillaEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess>,
            ext::shared_ptr<FdmQuantoHelper> quantoHelper,
            Size tGrid = 100,
            Size xGrid = 100,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas(),
            bool localVol = false,
            Real illegalLocalVolOverwrite = -Null<Real>(),
            CashDividendModel cashDividendModel = Spot);

        FdBlackScholesVanillaEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess>,
            DividendSchedule dividends,
            ext::shared_ptr<FdmQuantoHelper> quantoHelper,
            Size tGrid = 100,
            Size xGrid = 100,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas(),
            bool localVol = false,
            Real illegalLocalVolOverwrite = -Null<Real>(),
            CashDividendModel cashDividendModel = Spot);

        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        DividendSchedule dividends_;
        Size tGrid_, xGrid_, dampingSteps_;
        FdmSchemeDesc schemeDesc_;
        bool localVol_;
        Real illegalLocalVolOverwrite_;
        ext::shared_ptr<FdmQuantoHelper> quantoHelper_;
        CashDividendModel cashDividendModel_;
    };


    class MakeFdBlackScholesVanillaEngine {
      public:
        explicit MakeFdBlackScholesVanillaEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);

        MakeFdBlackScholesVanillaEngine& withQuantoHelper(
            const ext::shared_ptr<FdmQuantoHelper>& quantoHelper);

        MakeFdBlackScholesVanillaEngine& withTGrid(Size tGrid);
        MakeFdBlackScholesVanillaEngine& withXGrid(Size xGrid);
        MakeFdBlackScholesVanillaEngine& withDampingSteps(
            Size dampingSteps);

        MakeFdBlackScholesVanillaEngine& withFdmSchemeDesc(
            const FdmSchemeDesc& schemeDesc);

        MakeFdBlackScholesVanillaEngine& withLocalVol(bool localVol);
        MakeFdBlackScholesVanillaEngine& withIllegalLocalVolOverwrite(
            Real illegalLocalVolOverwrite);

        MakeFdBlackScholesVanillaEngine& withCashDividends(
            const std::vector<Date>& dividendDates,
            const std::vector<Real>& dividendAmounts);

        MakeFdBlackScholesVanillaEngine& withCashDividendModel(
            FdBlackScholesVanillaEngine::CashDividendModel cashDividendModel);

        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        DividendSchedule dividends_;
        Size tGrid_ = 100, xGrid_ = 100, dampingSteps_ = 0;
        ext::shared_ptr<FdmSchemeDesc> schemeDesc_;
        bool localVol_ = false;
        Real illegalLocalVolOverwrite_;
        ext::shared_ptr<FdmQuantoHelper> quantoHelper_;
        FdBlackScholesVanillaEngine::CashDividendModel cashDividendModel_ = FdBlackScholesVanillaEngine::Spot;
    };

}

#endif


FILE: ql/pricingengines/vanilla/fdblackscholesvanillaengine.cpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/methods/finitedifferences/meshers/fdmblackscholesmesher.hpp>
#include <ql/methods/finitedifferences/utilities/escroweddividendadjustment.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/solvers/fdmblackscholessolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/methods/finitedifferences/utilities/fdmescrowedloginnervaluecalculator.hpp>
#include <ql/methods/finitedifferences/utilities/fdmquantohelper.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesvanillaengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    FdBlackScholesVanillaEngine::FdBlackScholesVanillaEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Size tGrid,
        Size xGrid,
        Size dampingSteps,
        const FdmSchemeDesc& schemeDesc,
        bool localVol,
        Real illegalLocalVolOverwrite,
        CashDividendModel cashDividendModel)
    : process_(std::move(process)), tGrid_(tGrid), xGrid_(xGrid),
      dampingSteps_(dampingSteps), schemeDesc_(schemeDesc), localVol_(localVol),
      illegalLocalVolOverwrite_(illegalLocalVolOverwrite), cashDividendModel_(cashDividendModel) {
        registerWith(process_);
    }

    FdBlackScholesVanillaEngine::FdBlackScholesVanillaEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        DividendSchedule dividends,
        Size tGrid,
        Size xGrid,
        Size dampingSteps,
        const FdmSchemeDesc& schemeDesc,
        bool localVol,
        Real illegalLocalVolOverwrite,
        CashDividendModel cashDividendModel)
    : process_(std::move(process)), dividends_(std::move(dividends)),
      tGrid_(tGrid), xGrid_(xGrid), dampingSteps_(dampingSteps), schemeDesc_(schemeDesc),
      localVol_(localVol), illegalLocalVolOverwrite_(illegalLocalVolOverwrite),
      cashDividendModel_(cashDividendModel) {
        registerWith(process_);
    }

    FdBlackScholesVanillaEngine::FdBlackScholesVanillaEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        ext::shared_ptr<FdmQuantoHelper> quantoHelper,
        Size tGrid,
        Size xGrid,
        Size dampingSteps,
        const FdmSchemeDesc& schemeDesc,
        bool localVol,
        Real illegalLocalVolOverwrite,
        CashDividendModel cashDividendModel)
    : process_(std::move(process)),
      tGrid_(tGrid), xGrid_(xGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), localVol_(localVol),
      illegalLocalVolOverwrite_(illegalLocalVolOverwrite), quantoHelper_(std::move(quantoHelper)),
      cashDividendModel_(cashDividendModel) {
        registerWith(process_);
        registerWith(quantoHelper_);
    }

    FdBlackScholesVanillaEngine::FdBlackScholesVanillaEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        DividendSchedule dividends,
        ext::shared_ptr<FdmQuantoHelper> quantoHelper,
        Size tGrid,
        Size xGrid,
        Size dampingSteps,
        const FdmSchemeDesc& schemeDesc,
        bool localVol,
        Real illegalLocalVolOverwrite,
        CashDividendModel cashDividendModel)
    : process_(std::move(process)), dividends_(std::move(dividends)),
      tGrid_(tGrid), xGrid_(xGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), localVol_(localVol),
      illegalLocalVolOverwrite_(illegalLocalVolOverwrite), quantoHelper_(std::move(quantoHelper)),
      cashDividendModel_(cashDividendModel) {
        registerWith(process_);
        registerWith(quantoHelper_);
    }


    void FdBlackScholesVanillaEngine::calculate() const {

        // 0. Cash dividend model
        const Date exerciseDate = arguments_.exercise->lastDate();
        const Time maturity = process_->time(exerciseDate);
        const Date settlementDate = process_->riskFreeRate()->referenceDate();

        Real spotAdjustment = 0.0;
        DividendSchedule dividendSchedule = DividendSchedule();

        ext::shared_ptr<EscrowedDividendAdjustment> escrowedDivAdj;

        switch (cashDividendModel_) {
          case Spot:
            dividendSchedule = dividends_;
            break;
          case Escrowed:
            if  (arguments_.exercise->type() != Exercise::European)
                // add dividend dates as stopping times
                for (const auto& cf: dividends_)
                    dividendSchedule.push_back(
                        ext::make_shared<FixedDividend>(0.0, cf->date()));

            QL_REQUIRE(quantoHelper_ == nullptr,
                "Escrowed dividend model is not supported for Quanto-Options");

            escrowedDivAdj = ext::make_shared<EscrowedDividendAdjustment>(
                dividends_,
                process_->riskFreeRate(),
                process_->dividendYield(),
                [&](Date d){ return process_->time(d); },
                maturity
            );

            spotAdjustment =
                escrowedDivAdj->dividendAdjustment(process_->time(settlementDate));

            QL_REQUIRE(process_->x0() + spotAdjustment > 0.0,
                    "spot minus dividends becomes negative");

            break;
          default:
              QL_FAIL("unknwon cash dividend model");
        }

        // 1. Mesher
        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);

        const ext::shared_ptr<Fdm1dMesher> equityMesher =
            ext::make_shared<FdmBlackScholesMesher>(
                    xGrid_, process_, maturity, payoff->strike(), 
                    Null<Real>(), Null<Real>(), 0.0001, 1.5,
                    std::pair<Real, Real>(payoff->strike(), 0.1),
                    dividendSchedule, quantoHelper_,
                    spotAdjustment);
        
        const ext::shared_ptr<FdmMesher> mesher =
            ext::make_shared<FdmMesherComposite>(equityMesher);
        
        // 2. Calculator
        const ext::shared_ptr<FdmInnerValueCalculator> calculator =
            ext::make_shared<FdmLogInnerValue>(payoff, mesher, 0);

        ext::shared_ptr<FdmInnerValueCalculator> earlyExerciseCalculator;
        switch (cashDividendModel_) {
          case Spot:
              earlyExerciseCalculator = calculator;
            break;
          case Escrowed:
              earlyExerciseCalculator = ext::make_shared<FdmEscrowedLogInnerValueCalculator>(
                  escrowedDivAdj, payoff, mesher, 0);
            break;
          default:
              QL_FAIL("unknwon cash dividend model");
        }

        // 3. Step conditions
        const ext::shared_ptr<FdmStepConditionComposite> conditions = 
            FdmStepConditionComposite::vanillaComposite(
                dividendSchedule, arguments_.exercise, mesher,
                earlyExerciseCalculator,
                process_->riskFreeRate()->referenceDate(),
                process_->riskFreeRate()->dayCounter());

        // 4. Boundary conditions
        const FdmBoundaryConditionSet boundaries;

        // 5. Solver
        FdmSolverDesc solverDesc = {
            mesher, boundaries, conditions, calculator, maturity, tGrid_, dampingSteps_
        };

        const ext::shared_ptr<FdmBlackScholesSolver> solver(
            ext::make_shared<FdmBlackScholesSolver>(
                Handle<GeneralizedBlackScholesProcess>(process_),
                payoff->strike(), solverDesc, schemeDesc_,
                localVol_, illegalLocalVolOverwrite_,
                Handle<FdmQuantoHelper>(quantoHelper_)));

        const Real spot = process_->x0() + spotAdjustment;

        results_.value = solver->valueAt(spot);
        results_.delta = solver->deltaAt(spot);
        results_.gamma = solver->gammaAt(spot);
        results_.theta = solver->thetaAt(spot);
    }

    MakeFdBlackScholesVanillaEngine::MakeFdBlackScholesVanillaEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)),
      schemeDesc_(ext::make_shared<FdmSchemeDesc>(FdmSchemeDesc::Douglas())),
      illegalLocalVolOverwrite_(-Null<Real>()) {}

    MakeFdBlackScholesVanillaEngine&
    MakeFdBlackScholesVanillaEngine::withQuantoHelper(
        const ext::shared_ptr<FdmQuantoHelper>& quantoHelper) {
        quantoHelper_ = quantoHelper;
        return *this;
    }

    MakeFdBlackScholesVanillaEngine&
    MakeFdBlackScholesVanillaEngine::withTGrid(Size tGrid) {
        tGrid_ = tGrid;
        return *this;
    }

    MakeFdBlackScholesVanillaEngine&
    MakeFdBlackScholesVanillaEngine::withXGrid(Size xGrid) {
        xGrid_ = xGrid;
        return *this;
    }

    MakeFdBlackScholesVanillaEngine&
    MakeFdBlackScholesVanillaEngine::withDampingSteps(Size dampingSteps) {
        dampingSteps_ = dampingSteps;
        return *this;
    }

    MakeFdBlackScholesVanillaEngine&
    MakeFdBlackScholesVanillaEngine::withFdmSchemeDesc(
        const FdmSchemeDesc& schemeDesc) {
        schemeDesc_ = ext::make_shared<FdmSchemeDesc>(schemeDesc);
        return *this;
    }

    MakeFdBlackScholesVanillaEngine&
    MakeFdBlackScholesVanillaEngine::withLocalVol(bool localVol) {
        localVol_ = localVol;
        return *this;
    }

    MakeFdBlackScholesVanillaEngine&
    MakeFdBlackScholesVanillaEngine::withIllegalLocalVolOverwrite(
        Real illegalLocalVolOverwrite) {
        illegalLocalVolOverwrite_ = illegalLocalVolOverwrite;
        return *this;
    }

    MakeFdBlackScholesVanillaEngine&
    MakeFdBlackScholesVanillaEngine::withCashDividends(
            const std::vector<Date>& dividendDates,
            const std::vector<Real>& dividendAmounts) {
        dividends_ = DividendVector(dividendDates, dividendAmounts);
        return *this;
    }

    MakeFdBlackScholesVanillaEngine&
    MakeFdBlackScholesVanillaEngine::withCashDividendModel(
        FdBlackScholesVanillaEngine::CashDividendModel cashDividendModel) {
        cashDividendModel_ = cashDividendModel;
        return *this;
    }

    MakeFdBlackScholesVanillaEngine::operator
    ext::shared_ptr<PricingEngine>() const {
        return ext::make_shared<FdBlackScholesVanillaEngine>(
                process_,
                dividends_,
                quantoHelper_,
                tGrid_, xGrid_, dampingSteps_,
                *schemeDesc_,
                localVol_,
                illegalLocalVolOverwrite_,
                cashDividendModel_);
    }

}


FILE: ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmstepconditioncomposite.hpp
    \brief composite of fdm step conditions
*/

#ifndef quantlib_fdm_step_condition_composite_hpp
#define quantlib_fdm_step_condition_composite_hpp

#include <ql/time/date.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/instruments/dividendschedule.hpp>
#include <ql/methods/finitedifferences/stepcondition.hpp>

#include <list>

namespace QuantLib {

    class FdmMesher;
    class Exercise;
    class FdmSnapshotCondition;
    class FdmInnerValueCalculator;
    
    class FdmStepConditionComposite : public StepCondition<Array> {
    public:
        typedef std::list<ext::shared_ptr<StepCondition<Array> > > Conditions;

        FdmStepConditionComposite(const std::list<std::vector<Time> >& stoppingTimes,
                                  Conditions conditions);

        void applyTo(Array& a, Time t) const override;
        const std::vector<Time>& stoppingTimes() const;
        const Conditions& conditions() const;

        static ext::shared_ptr<FdmStepConditionComposite> joinConditions(
                    const ext::shared_ptr<FdmSnapshotCondition>& c1,
                    const ext::shared_ptr<FdmStepConditionComposite>& c2);

        static ext::shared_ptr<FdmStepConditionComposite> vanillaComposite(
             const DividendSchedule& schedule,
             const ext::shared_ptr<Exercise>& exercise,
             const ext::shared_ptr<FdmMesher>& mesher,
             const ext::shared_ptr<FdmInnerValueCalculator>& calculator,
             const Date& refDate,
             const DayCounter& dayCounter);
        
    private:
        std::vector<Time> stoppingTimes_;
        const Conditions conditions_;
    };
}
#endif


FILE: ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.cpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include <ql/exercise.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmamericanstepcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmbermudanstepcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsnapshotcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdividendhandler.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <set>
#include <utility>

namespace QuantLib {

    FdmStepConditionComposite::FdmStepConditionComposite(
        const std::list<std::vector<Time> >& stoppingTimes, Conditions conditions)
    : conditions_(std::move(conditions)) {

        std::set<Real> allStoppingTimes;
        for (const auto& stoppingTime : stoppingTimes) {
            allStoppingTimes.insert(stoppingTime.begin(), stoppingTime.end());
        }
        stoppingTimes_ = std::vector<Time>(allStoppingTimes.begin(),
                                           allStoppingTimes.end());
    }

    const FdmStepConditionComposite::Conditions&
    FdmStepConditionComposite::conditions() const {
        return conditions_;
    }

    const std::vector<Time>& FdmStepConditionComposite::stoppingTimes() const {
        return stoppingTimes_;
    }

    void FdmStepConditionComposite::applyTo(Array& a, Time t) const {
        for (const auto& condition : conditions_) {
            condition->applyTo(a, t);
        }
    }
    
    ext::shared_ptr<FdmStepConditionComposite> 
    FdmStepConditionComposite::joinConditions(
                const ext::shared_ptr<FdmSnapshotCondition>& c1,
                const ext::shared_ptr<FdmStepConditionComposite>& c2) {

        std::list<std::vector<Time> > stoppingTimes;
        stoppingTimes.push_back(c2->stoppingTimes());
        stoppingTimes.emplace_back(1, c1->getTime());

        FdmStepConditionComposite::Conditions conditions;
        conditions.push_back(c2);
        conditions.push_back(c1);

        return ext::make_shared<FdmStepConditionComposite>(
            stoppingTimes, conditions);
    }

    ext::shared_ptr<FdmStepConditionComposite> 
    FdmStepConditionComposite::vanillaComposite(
                 const DividendSchedule& cashFlow,
                 const ext::shared_ptr<Exercise>& exercise,
                 const ext::shared_ptr<FdmMesher>& mesher,
                 const ext::shared_ptr<FdmInnerValueCalculator>& calculator,
                 const Date& refDate,
                 const DayCounter& dayCounter) {
        
        std::list<std::vector<Time> > stoppingTimes;
        std::list<ext::shared_ptr<StepCondition<Array> > > stepConditions;

        if (!cashFlow.empty()) {
            const Date maturityDate = exercise->lastDate();
            DividendSchedule dividends;
            std::copy_if(
                cashFlow.begin(), cashFlow.end(),
                std::back_inserter(dividends),
                [refDate, maturityDate](const ext::shared_ptr<Dividend>& div) -> bool {
                    return div->date() >= refDate && div->date() <= maturityDate;
                }
            );

            auto dividendCondition =
                ext::make_shared<FdmDividendHandler>(dividends, mesher,
                                                     refDate, dayCounter, 0);
            stepConditions.push_back(dividendCondition);

            std::vector<Time> dividendTimes = dividendCondition->dividendTimes();
            const Time maturityTime = dayCounter.yearFraction(refDate, exercise->lastDate());

            // this effectively excludes times after maturity
            for (auto& t: dividendTimes)
                t = std::min(maturityTime, t);
            stoppingTimes.push_back(dividendTimes);

            // smoother convergence behavior with number of time steps
            for (auto& t: dividendTimes)
                t = std::min(maturityTime, t+1e-5);
            stoppingTimes.push_back(dividendTimes);
        }

        QL_REQUIRE(   exercise->type() == Exercise::American
                   || exercise->type() == Exercise::European
                   || exercise->type() == Exercise::Bermudan,
                   "exercise type is not supported");
        if (exercise->type() == Exercise::American) {
            stepConditions.push_back(ext::shared_ptr<StepCondition<Array> >(
                          new FdmAmericanStepCondition(mesher,calculator)));
        }
        else if (exercise->type() == Exercise::Bermudan) {
            ext::shared_ptr<FdmBermudanStepCondition> bermudanCondition(
                new FdmBermudanStepCondition(exercise->dates(),
                                             refDate, dayCounter,
                                             mesher, calculator));
            stepConditions.push_back(bermudanCondition);
            stoppingTimes.push_back(bermudanCondition->exerciseTimes());
        }
        
        return ext::make_shared<FdmStepConditionComposite>(
            stoppingTimes, stepConditions);

    }

}


FILE: ql/methods/finitedifferences/operators/all.hpp
/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/methods/finitedifferences/operators/fdm2dblackscholesop.hpp>
#include <ql/methods/finitedifferences/operators/fdmbatesop.hpp>
#include <ql/methods/finitedifferences/operators/fdmblackscholesfwdop.hpp>
#include <ql/methods/finitedifferences/operators/fdmblackscholesop.hpp>
#include <ql/methods/finitedifferences/operators/fdmcevop.hpp>
#include <ql/methods/finitedifferences/operators/fdmcirop.hpp>
#include <ql/methods/finitedifferences/operators/fdmg2op.hpp>
#include <ql/methods/finitedifferences/operators/fdmhestonfwdop.hpp>
#include <ql/methods/finitedifferences/operators/fdmhestonhullwhiteop.hpp>
#include <ql/methods/finitedifferences/operators/fdmhestonop.hpp>
#include <ql/methods/finitedifferences/operators/fdmhullwhiteop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopiterator.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/fdmlocalvolfwdop.hpp>
#include <ql/methods/finitedifferences/operators/fdmornsteinuhlenbeckop.hpp>
#include <ql/methods/finitedifferences/operators/fdmsabrop.hpp>
#include <ql/methods/finitedifferences/operators/fdmsquarerootfwdop.hpp>
#include <ql/methods/finitedifferences/operators/fdmwienerop.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/modtriplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/ninepointlinearop.hpp>
#include <ql/methods/finitedifferences/operators/nthorderderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/numericaldifferentiation.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/secondordermixedderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>



FILE: ql/methods/finitedifferences/stepconditions/all.hpp
/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/methods/finitedifferences/stepconditions/fdmamericanstepcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmarithmeticaveragecondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmbermudanstepcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsimplestoragecondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsimpleswingcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsnapshotcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>



FILE: ql/methods/finitedifferences/utilities/all.hpp
/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/methods/finitedifferences/utilities/bsmrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/cevrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/escroweddividendadjustment.hpp>
#include <ql/methods/finitedifferences/utilities/fdmaffinemodelswapinnervalue.hpp>
#include <ql/methods/finitedifferences/utilities/fdmaffinemodeltermstructure.hpp>
#include <ql/methods/finitedifferences/utilities/fdmboundaryconditionset.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdirichletboundary.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdiscountdirichletboundary.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdividendhandler.hpp>
#include <ql/methods/finitedifferences/utilities/fdmescrowedloginnervaluecalculator.hpp>
#include <ql/methods/finitedifferences/utilities/fdmhestongreensfct.hpp>
#include <ql/methods/finitedifferences/utilities/fdmindicesonboundary.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/methods/finitedifferences/utilities/fdmmesherintegral.hpp>
#include <ql/methods/finitedifferences/utilities/fdmquantohelper.hpp>
#include <ql/methods/finitedifferences/utilities/fdmshoutloginnervaluecalculator.hpp>
#include <ql/methods/finitedifferences/utilities/fdmtimedepdirichletboundary.hpp>
#include <ql/methods/finitedifferences/utilities/gbsmrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/hestonrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/localvolrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/riskneutraldensitycalculator.hpp>
#include <ql/methods/finitedifferences/utilities/squarerootprocessrndcalculator.hpp>



ROUND 1-4 OUTPUTS (headers only, for #include paths):
[>>> ATTACH HERE: output file(s) generated in Round(s) 1, 2, 3, 4 <<<]
</source_files>

<implementation_guidance>

=== FILE 1-2: Modified FdBlackScholesVanillaEngine ===

The operatorType and monitoringDampingSteps are carried inside FdmSchemeDesc.
Users select the scheme via the static factories:
  FdmSchemeDesc::FittedImplicit()
  FdmSchemeDesc::FittedCrankNicolson()
  FdmSchemeDesc::CNVariant()
  FdmSchemeDesc::CrankNicolsonWithDamping(2)

Existing constructor signature must still compile.


=== FILE 3-4: Modified FdmStepConditionComposite ===

Add a new static factory for barrier-monitored options:

  static ext::shared_ptr<FdmStepConditionComposite>
  barrierMonitoredComposite(
      const DividendSchedule& cashFlow,
      const ext::shared_ptr<Exercise>& exercise,
      const ext::shared_ptr<FdmMesher>& mesher,
      const ext::shared_ptr<FdmInnerValueCalculator>& calculator,
      const Date& refDate,
      const DayCounter& dayCounter,
      const std::vector<Date>& monitoringDates,
      Real lowerBarrier,
      Real upperBarrier);

WIRING REQUIREMENTS (m3 fix ‚Äî make explicit):
  This factory must:
  1. Convert monitoringDates to monitoringTimes (using dayCounter and refDate).
  2. Create FdmBarrierProjectionCondition with these times + barriers.
  3. Insert ALL monitoringTimes into the stoppingTimes set (so the solver
     segments the rollback at monitoring dates and applies the projection).
  4. Associate the FdmBarrierProjectionCondition with those stopping times
     in the conditions list.
  5. Also include dividend and exercise stopping times (as vanillaComposite does).

GRID ALIGNMENT INTEGRATION:
  The engine should log a warning if any barrier value's ln() is more than
  h/4 away from the nearest mesh point. This can be checked in the engine's
  performCalculations() method after mesher construction.

Empty monitoringDates must return same result as vanillaComposite().

#include for FdmBarrierProjectionCondition in the .cpp file.


=== FILES 5-7: Updated all.hpp headers ===

operators/all.hpp: add
  #include <ql/methods/finitedifferences/operators/fdmfittedblackscholesop.hpp>
  #include <ql/methods/finitedifferences/operators/fdmcnvariantblackscholesop.hpp>

stepconditions/all.hpp: add
  #include <ql/methods/finitedifferences/stepconditions/fdmbarrierprojectioncondition.hpp>

utilities/all.hpp: add
  #include <ql/methods/finitedifferences/utilities/fdmdiagnostics.hpp>

All additions in alphabetical order.

</implementation_guidance>

<constraints>
- Existing constructor signatures must still compile
- FdmSchemeDesc::Douglas() default produces identical results to original
- all.hpp additions alphabetically sorted
- No circular include dependencies
- If engine file path or content missing, STOP and ask
- barrierMonitoredComposite must explicitly insert monitoring times as stopping times
</constraints>

<output_specification>
Produce the following files:
1. fdblackscholesvanillaengine.hpp (modified)
2. fdblackscholesvanillaengine.cpp (modified)
3. fdmstepconditioncomposite.hpp (modified)
4. fdmstepconditioncomposite.cpp (modified)
5. operators/all.hpp (modified)
6. stepconditions/all.hpp (modified)
7. utilities/all.hpp (modified)
</output_specification>

<quality_checklist>
‚ñ° Existing code compiles without changes
‚ñ° Default schemeDesc produces identical results to original
‚ñ° barrierMonitoredComposite with empty monitoring dates = vanillaComposite
‚ñ° barrierMonitoredComposite explicitly registers monitoring times as stopping times
‚ñ° all.hpp entries alphabetically sorted
‚ñ° No new public dependencies in engine .hpp
</quality_checklist>
