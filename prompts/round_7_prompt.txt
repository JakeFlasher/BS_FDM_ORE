<system_context>
You are an expert C++ developer implementing two positivity-preserving finite
difference schemes from Milev & Tagliani (2010) into QuantLib 1.42-dev's modern
Fdm* framework. The schemes address spurious oscillations and negative prices
that standard Crankâ€“Nicolson produces when ÏƒÂ² â‰ª r and payoffs are discontinuous.

PAPER REFERENCE (corrected formulations):
Scheme 1: Fully implicit with Duffy's exponentially fitted diffusion coefficient.
Scheme 2: Crankâ€“Nicolson variant with a modified 6-node reaction-term stencil.
Both are described in the GOLDEN REFERENCE DOCUMENT (ROUND 1.5 output), whose
corrected equation chain (CE-1 through CE-25) is authoritative.

SOURCE-OF-TRUTH / NO-HALLUCINATION RULES (mandatory):
- Use ONLY the provided source files and prior-ROUND outputs as factual reference
  for class/method signatures, include paths, base-class requirements, and
  coding conventions.
- If any referenced file content is missing (i.e., an [INSERT FULL CONTENT ...]
  placeholder is not filled), DO NOT guess or reconstruct.
  STOP and ask the user to provide the missing file(s).
- If a requirement is ambiguous, search the provided files for the relevant
  implementation detail and implement the behavior that matches the source.
  If still ambiguous, STOP and ask a precise clarification question.

INTERNAL VERIFICATION PROTOCOL (mandatory; do before coding; do not print):
- Verify what the 1D BS mesher stores as spatial coordinate x (ln(S), ln(S/K),
  or other) by reading FdmBlackScholesMesher and FdmBlackScholesOp.
- Verify how FirstDerivativeOp / SecondDerivativeOp incorporate nonuniform mesh
  spacing (which mesher spacing functions they use).
- Verify the TripleBandLinearOp sign conventions: which off-diagonal coefficients
  must be nonneg for the system matrix (I âˆ’ Î¸Â·dtÂ·L) to be an M-matrix.
- Verify how FdmBackwardSolver handles step conditions (rollback segmentation at
  stopping times, and whether applyTo is called at the initial 'from' time).
- Verify that ext::make_shared<T>(...) is available in QuantLib's ext namespace.
  If it is not aliased, fall back to ext::shared_ptr<T>(new T(...)).

CODING CONVENTIONS (mandatory):
- Namespace: all classes in `namespace QuantLib { }`
- Smart pointers: use `ext::shared_ptr`, NOT `std::shared_ptr`
- Factory calls: prefer `ext::make_shared<T>(...)` if available; verify from
  provided headers before use. Fallback: `ext::shared_ptr<T>(new T(...))`.
- Return arrays: use `Array`
- Assertions: `QL_REQUIRE(condition, message)` for preconditions,
  `QL_ENSURE(condition, message)` for postconditions
- Include guards: `#ifndef quantlib_<path_underscored>_hpp`
- Copyright header: match the style of adjacent files in the same directory
- Includes: use angle brackets `<ql/...>` for QuantLib headers
- No `using namespace std;` in headers
- Naming: `camelCase` for methods, `camelCase_` for private members,
  `CamelCase` for classes

OUTPUT RULES:
- Produce COMPLETE files, never diffs or partial snippets
- Only output files that are new or modified in this ROUND
- Each file must compile against unmodified QuantLib 1.42-dev headers plus any
  files produced in prior ROUNDs
- Include all necessary #include directives
</system_context>


<mathematical_context>
PAPER'S ORIGINAL PDE (S-space, time-to-expiry Ï„; CE-1):
  âˆ’âˆ‚V/âˆ‚Ï„ + rSÂ·âˆ‚V/âˆ‚S + Â½ÏƒÂ²SÂ²Â·âˆ‚Â²V/âˆ‚SÂ² âˆ’ rV = 0

NOTATION WARNING â€” TWO DIFFERENT Ïƒ's IN THE PAPER:
  Document 5 (Eq. 2) rewrites the PDE in generalized form:
    âˆ’V_t + Î¼(S,t)Â·V_S + Ïƒ(S,t)Â·V_SS + b(S,t)Â·V = 0
  where Ïƒ(S,t) = Â½ÏƒÂ²_volÂ·SÂ² is the DIFFUSION COEFFICIENT, NOT the volatility.
  The fitting factor formula (Eq. 3) uses this diffusion coefficient Ïƒ(S,t).
  An implementer who substitutes Ïƒ_vol directly for Ïƒ(S,t) will get completely
  wrong results. In log-space this ambiguity is resolved: a = ÏƒÂ²_vol/2 is
  always the half-variance, and b = (râˆ’q) âˆ’ ÏƒÂ²_vol/2 is the drift.

DIVIDEND YIELD NOTE:
  The original papers assume q = 0. The QuantLib implementation generalizes
  to q â‰¥ 0 via b = (râˆ’q) âˆ’ ÏƒÂ²/2. All paper-specific analysis uses q = 0.

QUANTLIB LOG-SPACE PDE (x = ln(S), backward time Ï„):
  âˆ’u_Ï„ + bÂ·u_x + aÂ·u_xx âˆ’ rÂ·u = 0
  where a = ÏƒÂ²/2,  b = (r âˆ’ q) âˆ’ ÏƒÂ²/2

â•â•â• SCHEME 1: EXPONENTIALLY FITTED OPERATOR (CE-7 through CE-15) â•â•â•

In log-space, the PÃ©clet parameter and fitting factor at interior node j are:
  Pe_j = b Â· h_j / (2Â·a)                   (local PÃ©clet number)
  Ï_j = Pe_j Â· coth(Pe_j)                  (fitting factor; Ï â†’ 1+PeÂ²/3 for |Pe|â†’0)

SPATIAL VARIATION NOTE:
  In S-space, the PÃ©clet parameter Î±_j = rÂ·Î”S/(ÏƒÂ²Â·S_j) varies with S_j:
  it is large for small S_j (upwind regime) and small for large S_j (centered
  regime). In log-space with uniform h, Pe = bh/(2a) is CONSTANT across nodes,
  but with nonuniform h (concentrated meshes), Pe_j varies per node. The fitting
  factor Ï_j â‰¥ 1 for all Pe_j, regardless of sign or magnitude.

Fitted stencil (replacing the standard centered operator):
  â„“_j = aÂ·Ï_j/hÂ² âˆ’ b/(2h)     (lower off-diagonal)
  d_j = âˆ’2Â·aÂ·Ï_j/hÂ² âˆ’ r        (main diagonal)
  u_j = aÂ·Ï_j/hÂ² + b/(2h)     (upper off-diagonal)

NON-NEGATIVITY PROOF (for M-matrix):
  The lower off-diagonal can be rewritten as:
    â„“_j = (b/(2h))Â·(coth(Pe) âˆ’ 1)
  and the upper as:
    u_j = (b/(2h))Â·(coth(Pe) + 1)

  For b > 0 (Pe > 0): coth(Pe) > 1, so coth(Pe)âˆ’1 > 0; b/(2h) > 0. â„“_j > 0.
                       coth(Pe) + 1 > 0; u_j > 0.
  For b < 0 (Pe < 0): coth(Pe) < âˆ’1, so coth(Pe)âˆ’1 < âˆ’2 (neg); b/(2h) < 0.
                       Product of two negatives: â„“_j > 0.
                       coth(Pe)+1 < 0 (neg); b/(2h) < 0. u_j > 0.
  For b = 0: Ï â†’ 1, â„“_j = a/hÂ² > 0, u_j = a/hÂ² > 0.

  KEY PROPERTY: The inequality Ï_j â‰¥ 1 holds for ALL real Pe_j because
  xÂ·coth(x) â‰¥ 1 for all x (equality only at x=0 in the limit). This guarantee
  is per-node and holds on ANY mesh (uniform or nonuniform).

  On UNIFORM meshes this guarantees system matrix (I âˆ’ Î¸Â·dtÂ·L) is an M-matrix
  for any h > 0 and any parameter values.
  On NONUNIFORM meshes, the guarantee holds when the mesh ratio dâº/dâ» is
  moderate (typically < 3:1). The mMatrixViolationCount() diagnostic verifies
  this at runtime.

This ensures the system matrix (I âˆ’ Î¸Â·dtÂ·L) is an M-matrix.

Artificial diffusion (CE-15, low-Ïƒ limit): Â½Â·rÂ·SÂ·Î”SÂ·V_SS in S-space.
In log-space with uniform grid: Â½Â·bÂ·hÂ·u_xx (from the upwind limiting scheme).

NOTE ON PAPER TYPO (p. 227): The upwind scheme formulas on p. 227 show a
denominator of 2h, but direct computation shows the correct denominator is h.
The subsequent consistency analysis (eq. 7) and numerical diffusion formula
Â½Î¼hÂ·V_SS are correct â€” they correspond to the actual limiting scheme with h.

NONUNIFORM GRID NOTE: For non-uniform meshes, compute a per-node effective
spacing consistent with QuantLib's derivative operators:
  h_j := 0.5*(dplus_j + dminus_j)
At boundary nodes (first/last), dplus or dminus is Null<Real>(); skip these
nodes in per-node computations (they are handled by boundary conditions).

â•â•â• SCHEME 2: CN VARIANT WITH MODIFIED REACTION TERM (CE-16 through CE-23) â•â•â•

The paper's CN variant replaces âˆ’rÂ·u_j with the 6-node stencil:
  âˆ’rÂ·[Ï‰Â·u_{jâˆ’1} + (1âˆ’2Ï‰)Â·u_j + Ï‰Â·u_{j+1}]
at each time level, with Ï‰â‚ = Ï‰â‚‚ = Ï‰ (symmetric weighting).

PARAMETER CHOICE (CE-19):
  Ï‰ = âˆ’r/(16ÏƒÂ²)

EFFECTIVE-DIFFUSION REFORMULATION FOR LOG-SPACE ASSEMBLY:
  The paper's CN variant applies the FULL off-diagonal reaction weight Ï‰ at
  each time level (eq. 8: each level sums to Â½, but Ï‰ appears unsplit).
  Standard CN time-stepping halves the operator. To compensate, the spatial
  operator L must contain 2|rÏ‰| on its off-diagonals so that after CN's
  Â½-factor, the system matrix reproduces the paper's P and N.

  This is mathematically equivalent to using an enhanced diffusion coefficient:
    a_eff = ÏƒÂ²/2 + rÂ²Â·hÂ²/(8Â·ÏƒÂ²)
  with the standard reaction term âˆ’r, assembled via the standard axpyb() pattern.

  PROOF: With a_eff, standard CN produces system matrix P = I âˆ’ Â½Î”tÂ·L where:
    L_lower = a_eff/hÂ² âˆ’ b/(2h) = ÏƒÂ²/(2hÂ²) + rÂ²/(8ÏƒÂ²) âˆ’ b/(2h)
    P_lower = âˆ’Â½Î”tÂ·L_lower
    The additional off-diagonal vs standard CN: âˆ’Â½Î”tÂ·rÂ²/(8ÏƒÂ²) = âˆ’Î”tÂ·rÂ²/(16ÏƒÂ²)

    In the paper's S-space P matrix (Document 5, p. 228), the additional
    off-diagonal from the distributed reaction is rÏ‰â‚‚ = âˆ’rÂ²/(16ÏƒÂ²), which
    when multiplied by Î”t (to convert from the paper's 1/Î”t-normalized form)
    gives âˆ’Î”tÂ·rÂ²/(16ÏƒÂ²). These match. âˆ

  IMPORTANT: The coefficient is rÂ²hÂ²/(8ÏƒÂ²), NOT rÂ²hÂ²/(16ÏƒÂ²).
  The factor-of-2 arises because the paper places FULL Ï‰ at each CN time level
  while standard CN halves the operator contribution. Without the doubling, we
  would get rÂ²hÂ²/(16ÏƒÂ²) â€” which is wrong by exactly a factor of 2.

M-MATRIX GUARANTEE FOR CN VARIANT (corrected from audit Â§4b):
  In S-space, the P lower entry with Ï‰ = âˆ’r/(16ÏƒÂ²) is:
    P_lower = rÏ‰ + rS_j/(4Î”S) âˆ’ ÏƒÂ²S_jÂ²/(4Î”SÂ²)
            = âˆ’rÂ²/(16ÏƒÂ²) + rj/4 âˆ’ ÏƒÂ²jÂ²/4     (where j = S_j/Î”S)
  Completing the square:
    = âˆ’(ÏƒÂ²/4)Â·(j âˆ’ r/(2ÏƒÂ²))Â²
  This is a SINGLE non-positive perfect square: P_lower â‰¤ 0 for ALL j â‰¥ 0.
  Similarly, P_upper = âˆ’rÂ²/(16ÏƒÂ²) âˆ’ rj/4 âˆ’ ÏƒÂ²jÂ²/4 < 0 for j > 0.
  Therefore P is ALWAYS an M-matrix, unconditionally â€” no parameter
  restrictions needed for the off-diagonals.

  In log-space, the equivalent condition on the L operator (L_lower â‰¥ 0) is:
    a_eff/hÂ² âˆ’ b/(2h) â‰¥ 0,  i.e.,  a_eff â‰¥ bh/2
  Since a_eff = ÏƒÂ²/2 + rÂ²hÂ²/(8ÏƒÂ²) and b â‰ˆ r for q=0, Ïƒâ‰ªr:
    rÂ²hÂ²/(8ÏƒÂ²) â‰¥ rh/2  âŸº  rh/(4ÏƒÂ²) â‰¥ 1  âŸº  h â‰¥ 4ÏƒÂ²/r
  For Ïƒ=0.001, r=0.05: h â‰¥ 8Ã—10â»âµ â€” effectively always satisfied.

TIME-STEP CONSTRAINT (CE-20, log-space form):
  For N â‰¥ 0 (explicit-side diagonal non-negative):
    1 âˆ’ 0.5Â·Î”tÂ·(2Â·a_eff/hÂ² + r) â‰¥ 0
  âŸ¹  Î”t < 1 / [ÏƒÂ²/(2hÂ²) + rÂ²/(8ÏƒÂ²) + r/2]
  This is less restrictive than the S-space form (no growing (ÏƒM)Â² term)
  but still very tight for small Ïƒ. For Ïƒ=0.001, r=0.05, h=0.01:
  the rÂ²/(8ÏƒÂ²) = 312.5 term dominates, giving Î”t < 0.0032.

ACCURACY CONSTRAINTS (from audit Â§5b):
  Scheme 1 numerical diffusion (S-space): Â½rSÎ”SÂ·V_SS
  For this to be negligible vs physical diffusion Â½ÏƒÂ²SÂ²Â·V_SS:
    Î”S â‰ª ÏƒÂ²S/r
  At S=100, Ïƒ=0.001, r=0.05: Î”S â‰ª 0.002. With Î”S=0.05, numerical diffusion
  is ~25Ã— the physical diffusion â€” the solution is heavily smeared.

  Scheme 2 numerical diffusion (S-space): â…›(rÎ”S/Ïƒ)Â²Â·V_SS
  For this â‰ª Â½ÏƒÂ²SÂ²Â·V_SS: need (rÎ”S/Ïƒ)Â² â‰ª 4ÏƒÂ²SÂ²
  Equivalently: Î”S â‰ª 2ÏƒÂ²S/r (same order as Scheme 1 at moderate S).

  In log-space with uniform h:
    Scheme 1 diffusion: Â½bhÂ·u_xx â†’ need h â‰ª 2a/b = ÏƒÂ²/(râˆ’qâˆ’ÏƒÂ²/2) â‰ˆ ÏƒÂ²/r
    Scheme 2 diffusion: rÂ²hÂ²/(8ÏƒÂ²)Â·u_xx â†’ need h â‰ª 2Ïƒ/r (from rÂ²hÂ²/(8ÏƒÂ²) â‰ª ÏƒÂ²/2)

  PRACTICAL GUIDELINE: For Ïƒ=0.001, r=0.05, both schemes need h â‰² 2Ã—10â»âµ
  (roughly 50,000+ log-space nodes on [ln(50), ln(150)]) for diffusion-free
  accuracy. Coarser grids are usable but introduce measurable smearing.

SCHEME CROSSOVER ANALYSIS (from audit Â§5c):
  The two numerical diffusion terms are equal (in S-space) when:
    Â½rSÎ”S = â…›(rÎ”S/Ïƒ)Â²  âŸ¹  Î”S = 4ÏƒÂ²S/r
  For coarser grids (Î”S > 4ÏƒÂ²S/r), Scheme 1 has LESS diffusion.
  For finer grids, Scheme 2 wins due to its Î”SÂ² dependence.
  For Ïƒ=0.001, r=0.05, S=100: crossover at Î”S â‰ˆ 0.008.

Artificial diffusion (CE-23): â…›Â·(rÂ·Î”S/Ïƒ)Â²Â·V_SS in S-space.

NOTE ON FittedCrankNicolson POSITIVITY ANALYSIS:
  Combining Scheme 1's fitted operator with CN time-stepping:
  - P = I âˆ’ Â½Î”tÂ·L: off-diag = âˆ’Â½Î”tÂ·(fitted L off-diag) â‰¤ 0 (M-matrix âœ“)
    because fitted L off-diags are â‰¥ 0 (proven above).
  - N = I + Â½Î”tÂ·L: off-diag = Â½Î”tÂ·(fitted L off-diag) â‰¥ 0 (non-negative âœ“)
  - N diagonal requires: 1 âˆ’ Â½Î”tÂ·(2aÏ/hÂ² + r) â‰¥ 0
    âŸ¹ Î”t â‰¤ 1/(aÏ_max/hÂ² + r/2)
  Since Ï_max â‰ˆ |Pe_max| for large Pe, and Pe = bh/(2a):
    Î”t â‰¤ 1/(|b|/(2h) + r/2)
  This is LESS restrictive than the CN variant's constraint (no rÂ²/(8ÏƒÂ²) term)
  and may be preferable for very low volatility. However, the temporal accuracy
  is O(Î”tÂ²) only, not the CN variant's O(Î”tÂ²,hÂ²) â€” the spatial accuracy is
  O(h) from the fitting.

â•â•â• DISCRETE BARRIER MONITORING (CE-6) â•â•â•

At each monitoring date t_i, after the time-step solve:
  U_j â† U_j Â· ğŸ™_{[L,U]}(S_j)
This re-introduces discontinuities that the schemes must handle.

GRID ALIGNMENT REQUIREMENT:
  The barrier values L, U (and ideally the strike K) should be GRID POINTS.
  The paper uses Î”S=0.05 with L=90, K=100, U=110 â€” all exact multiples.
  Violating this introduces interpolation error that can reintroduce oscillations.
  In log-space: ln(L), ln(U), ln(K) should be mesher locations. QuantLib's
  Concentrating1dMesher can place nodes at specified points. The
  FdmBlackScholesMesher already concentrates aROUND the strike; users should
  also ensure barrier locations are mesher concentration points.

S_MAX SELECTION (from Document 1, Eq. 5.2):
  S_max = max{RÂ·K, KÂ·exp(âˆš(2TÏƒÂ²Â·ln 100))},  R â‰¥ 2
  For very low Ïƒ: S_max = RÂ·K (rule of thumb: 3â€“4 times the strike).
  For moderate Ïƒ: the exponential term dominates.
  In log-space: x_max = ln(S_max), x_min = ln(S_min) with S_min small but >0.

â•â•â• M-MATRIX DIAGNOSTIC (CE-10, Proposition 4.1) â•â•â•

For the operator L stored in mapT_, the M-matrix condition for the system
matrix (I âˆ’ Î¸Â·dtÂ·L) requires:
  All off-diagonals of L (lower_[] and upper_[]) must be NON-NEGATIVE.
  (Because system off-diag = âˆ’Î¸Â·dtÂ·(operator off-diag), and Î¸Â·dt > 0.)

To access protected lower_[]/upper_[] arrays of TripleBandLinearOp, construct
a temporary ModTripleBandLinearOp from mapT_ and use its public accessors.

â•â•â• NOTE ON FittedCrankNicolson COMBINATION â•â•â•

The paper uses Scheme 1 (fitted operator) with fully-implicit time stepping ONLY.
The FittedCrankNicolson factory (Scheme 1 operator + CN time stepping) is a
natural EXTENSION not present in the original paper. It may offer improved
temporal accuracy but its M-matrix and positivity properties differ from the
paper's proven guarantees. See the positivity analysis above for details.
Use with appropriate testing.

â•â•â• LOCAL VOLATILITY CAVEAT â•â•â•

With local or stochastic volatility, Ïƒ = Ïƒ(S,t):
- The fitting factor must be recomputed every time step (handled by setTime())
- The CN variant parameter Ï‰ = âˆ’r/(16ÏƒÂ²) becomes spatially varying
- The M-matrix guarantees remain valid per-node (the algebraic identities
  hold for any Ïƒ_j > 0) but the time-step constraint for the CN variant
  becomes node-dependent; use the worst-case node.
- Positivity guarantees for the quanto-adjusted case have NOT been verified.
</mathematical_context>

<task>
ROUND 7 (OPTIONAL): Create a standalone S-space implementation of both schemes
exactly as described in the paper, for validation against the log-space
implementations from ROUNDs 1-6.

OUTPUT: 2 files (1 header + 1 implementation).
</task>

<source_files>
ROUND 1.5 OUTPUT (Golden Reference Document):
[>>> ATTACH HERE: INSERT the complete Golden Reference Document from ROUND_1.5_output.md,
specifically Â§3 (Mathematical Specification) and Â§5 (Monolithic Pseudocode) <<<]

ROUND 1.4 OUTPUT (Corrected Equation Chain):
[>>> ATTACH HERE: INSERT the Corrected Equation Chain CE-1 through CE-25 <<<]

QuantLib headers (minimal):
FILE: ql/math/array.hpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2009 StatPro Italia srl
 Copyright (C) 2004 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file array.hpp
    \brief 1-D array used in linear algebra.
*/

#ifndef quantlib_array_hpp
#define quantlib_array_hpp

#include <ql/types.hpp>
#include <ql/errors.hpp>
#include <ql/utilities/null.hpp>
#include <iterator>
#include <functional>
#include <algorithm>
#include <numeric>
#include <vector>
#include <initializer_list>
#include <iomanip>
#include <memory>
#include <type_traits>

namespace QuantLib {

    //! 1-D array used in linear algebra.
    /*! This class implements the concept of vector as used in linear
        algebra.
        As such, it is <b>not</b> meant to be used as a container -
        <tt>std::vector</tt> should be used instead.

        \test construction of arrays is checked in a number of cases
    */
    class Array {
      public:
        //! \name Constructors, destructor, and assignment
        //@{
        //! creates the array with size 0
        Array() : Array(static_cast<Size>(0)) {}
        //! creates the array with the given dimension
        explicit Array(Size size);
        //! creates the array and fills it with <tt>value</tt>
        Array(Size size, Real value);
        /*! \brief creates the array and fills it according to
            \f$ a_{0} = value, a_{i}=a_{i-1}+increment \f$
        */
        Array(Size size, Real value, Real increment);
        Array(const Array&);
        Array(Array&&) noexcept;
        Array(std::initializer_list<Real>);
        template <typename T, typename = std::enable_if_t<std::is_convertible_v<T, Real>>>
        Array(std::initializer_list<T> init);
        //! creates the array from an iterable sequence
        template <class ForwardIterator>
        Array(ForwardIterator begin, ForwardIterator end);
        ~Array() = default;

        Array& operator=(const Array&);
        Array& operator=(Array&&) noexcept;

        bool operator==(const Array&) const;
        bool operator!=(const Array&) const;
        //@}
        /*! \name Vector algebra

            <tt>v += x</tt> and similar operation involving a scalar value
            are shortcuts for \f$ \forall i : v_i = v_i + x \f$

            <tt>v *= w</tt> and similar operation involving two vectors are
            shortcuts for \f$ \forall i : v_i = v_i \times w_i \f$

            \pre all arrays involved in an algebraic expression must have
            the same size.
        */
        //@{
        const Array& operator+=(const Array&);
        const Array& operator+=(Real);
        const Array& operator-=(const Array&);
        const Array& operator-=(Real);
        const Array& operator*=(const Array&);
        const Array& operator*=(Real);
        const Array& operator/=(const Array&);
        const Array& operator/=(Real);
        //@}
        //! \name Element access
        //@{
        //! read-only
        Real operator[](Size) const;
        Real at(Size) const;
        Real front() const;
        Real back() const;
        //! read-write
        Real& operator[](Size);
        Real& at(Size);
        Real& front();
        Real& back();
        //@}
        //! \name Inspectors
        //@{
        //! dimension of the array
        Size size() const;
        //! whether the array is empty
        bool empty() const;
        //@}
        typedef Size size_type;
        typedef Real value_type;
        typedef Real* iterator;
        typedef const Real* const_iterator;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        //! \name Iterator access
        //@{
        const_iterator begin() const;
        iterator begin();
        const_iterator end() const;
        iterator end();
        const_reverse_iterator rbegin() const;
        reverse_iterator rbegin();
        const_reverse_iterator rend() const;
        reverse_iterator rend();
        //@}
        //! \name Utilities
        //@{
        void resize(Size n);
        void swap(Array&) noexcept;
        //@}

      private:
        std::unique_ptr<Real[]> data_;
        Size n_;
    };


    /*! \relates Array */
    Real DotProduct(const Array&, const Array&);

    /*! \relates Array */
    Real Norm2(const Array&);

    // unary operators
    /*! \relates Array */
    Array operator+(const Array& v);
    /*! \relates Array */
    Array operator+(Array&& v);
    /*! \relates Array */
    Array operator-(const Array& v);
    /*! \relates Array */
    Array operator-(Array&& v);

    // binary operators
    /*! \relates Array */
    Array operator+(const Array&, const Array&);
    /*! \relates Array */
    Array operator+(const Array&, Array&&);
    /*! \relates Array */
    Array operator+(Array&&, const Array&);
    /*! \relates Array */
    Array operator+(Array&&, Array&&);
    /*! \relates Array */
    Array operator+(const Array&, Real);
    /*! \relates Array */
    Array operator+(Array&&, Real);
    /*! \relates Array */
    Array operator+(Real, const Array&);
    /*! \relates Array */
    Array operator+(Real, Array&&);
    /*! \relates Array */
    Array operator-(const Array&, const Array&);
    /*! \relates Array */
    Array operator-(const Array&, Array&&);
    /*! \relates Array */
    Array operator-(Array&&, const Array&);
    /*! \relates Array */
    Array operator-(Array&&, Array&&);
    /*! \relates Array */
    Array operator-(const Array&, Real);
    /*! \relates Array */
    Array operator-(Real, const Array&);
    /*! \relates Array */
    Array operator-(Array&&, Real);
    /*! \relates Array */
    Array operator-(Real, Array&&);
    /*! \relates Array */
    Array operator*(const Array&, const Array&);
    /*! \relates Array */
    Array operator*(const Array&, Array&&);
    /*! \relates Array */
    Array operator*(Array&&, const Array&);
    /*! \relates Array */
    Array operator*(Array&&, Array&&);
    /*! \relates Array */
    Array operator*(const Array&, Real);
    /*! \relates Array */
    Array operator*(Real, const Array&);
    /*! \relates Array */
    Array operator*(Array&&, Real);
    /*! \relates Array */
    Array operator*(Real, Array&&);
    /*! \relates Array */
    Array operator/(const Array&, const Array&);
    /*! \relates Array */
    Array operator/(const Array&, Array&&);
    /*! \relates Array */
    Array operator/(Array&&, const Array&);
    /*! \relates Array */
    Array operator/(Array&&, Array&&);
    /*! \relates Array */
    Array operator/(const Array&, Real);
    /*! \relates Array */
    Array operator/(Real, const Array&);
    /*! \relates Array */
    Array operator/(Array&&, Real);
    /*! \relates Array */
    Array operator/(Real, Array&&);

    // math functions
    /*! \relates Array */
    Array Abs(const Array&);
    /*! \relates Array */
    Array Abs(Array&&);
    /*! \relates Array */
    Array Sqrt(const Array&);
    /*! \relates Array */
    Array Sqrt(Array&&);
    /*! \relates Array */
    Array Log(const Array&);
    /*! \relates Array */
    Array Log(Array&&);
    /*! \relates Array */
    Array Exp(const Array&);
    /*! \relates Array */
    Array Exp(Array&&);
    /*! \relates Array */
    Array Pow(const Array&, Real);
    /*! \relates Array */
    Array Pow(Array&&, Real);

    // utilities
    /*! \relates Array */
    void swap(Array&, Array&) noexcept;

    // format
    /*! \relates Array */
    std::ostream& operator<<(std::ostream&, const Array&);


    // inline definitions

    inline Array::Array(Size size)
    : data_(size != 0U ? new Real[size] : (Real*)nullptr), n_(size) {}

    inline Array::Array(Size size, Real value)
    : data_(size != 0U ? new Real[size] : (Real*)nullptr), n_(size) {
        std::fill(begin(),end(),value);
    }

    inline Array::Array(Size size, Real value, Real increment)
    : data_(size != 0U ? new Real[size] : (Real*)nullptr), n_(size) {
        for (iterator i=begin(); i!=end(); ++i, value+=increment)
            *i = value;
    }

    inline Array::Array(const Array& from)
    : data_(from.n_ != 0U ? new Real[from.n_] : (Real*)nullptr), n_(from.n_) {
        if (data_)
            std::copy(from.begin(),from.end(),begin());
    }

    inline Array::Array(Array&& from) noexcept
    : data_((Real*)nullptr), n_(0) {
        swap(from);
    }

    namespace detail {

        template <class I>
        inline void _fill_array_(Array& a,
                                 std::unique_ptr<Real[]>& data_,
                                 Size& n_,
                                 I begin, I end,
                                 const std::true_type&) {
            // we got redirected here from a call like Array(3, 4)
            // because it matched the constructor below exactly with
            // ForwardIterator = int.  What we wanted was fill an
            // Array with a given value, which we do here.
            Size n = begin;
            Real value = end;
            data_.reset(n ? new Real[n] : (Real*)nullptr);
            n_ = n;
            std::fill(a.begin(),a.end(),value);
        }

        template <class I>
        inline void _fill_array_(Array& a,
                                 std::unique_ptr<Real[]>& data_,
                                 Size& n_,
                                 const I& begin, const I& end,
                                 const std::false_type&) {
            // true iterators
            Size n = std::distance(begin, end);
            data_.reset(n ? new Real[n] : (Real*)nullptr);
            n_ = n;
            #if defined(QL_PATCH_MSVC) && defined(QL_DEBUG)
            if (n_)
            #endif
            std::copy(begin, end, a.begin());
        }

    }

    inline Array::Array(std::initializer_list<Real> init) {
        detail::_fill_array_(*this, data_, n_, init.begin(), init.end(),
                             std::false_type());
    }

    template <class ForwardIterator>
    inline Array::Array(ForwardIterator begin, ForwardIterator end) {   // NOLINT(performance-unnecessary-value-param)
        // Unfortunately, calls such as Array(3, 4) match this constructor.
        // We have to detect integral types and dispatch.
        detail::_fill_array_(*this, data_, n_, begin, end,
                             std::is_integral<ForwardIterator>());
    }

    template <typename T, typename>
    Array::Array(std::initializer_list<T> init) {
        detail::_fill_array_(*this, data_, n_, init.begin(), init.end(), std::false_type());
    }

    inline Array& Array::operator=(const Array& from) {
        // strong guarantee
        Array temp(from);
        swap(temp);
        return *this;
    }

    inline Array& Array::operator=(Array&& from) noexcept {
        swap(from);
        return *this;
    }

    inline bool Array::operator==(const Array& to) const {
        return (n_ == to.n_) && std::equal(begin(), end(), to.begin());
    }

    inline bool Array::operator!=(const Array& to) const {
        return !(this->operator==(to));
    }

    inline const Array& Array::operator+=(const Array& v) {
        QL_REQUIRE(n_ == v.n_,
                   "arrays with different sizes (" << n_ << ", "
                   << v.n_ << ") cannot be added");
        std::transform(begin(),end(),v.begin(),begin(), std::plus<>());
        return *this;
    }


    inline const Array& Array::operator+=(Real x) {
        std::transform(begin(), end(), begin(), [=](Real y) -> Real { return y + x; });
        return *this;
    }

    inline const Array& Array::operator-=(const Array& v) {
        QL_REQUIRE(n_ == v.n_,
                   "arrays with different sizes (" << n_ << ", "
                   << v.n_ << ") cannot be subtracted");
        std::transform(begin(), end(), v.begin(), begin(), std::minus<>());
        return *this;
    }

    inline const Array& Array::operator-=(Real x) {
        std::transform(begin(),end(),begin(), [=](Real y) -> Real { return y - x; });
        return *this;
    }

    inline const Array& Array::operator*=(const Array& v) {
        QL_REQUIRE(n_ == v.n_,
                   "arrays with different sizes (" << n_ << ", "
                   << v.n_ << ") cannot be multiplied");
        std::transform(begin(), end(), v.begin(), begin(), std::multiplies<>());
        return *this;
    }

    inline const Array& Array::operator*=(Real x) {
        std::transform(begin(), end(), begin(), [=](Real y) -> Real { return y * x; });
        return *this;
    }

    inline const Array& Array::operator/=(const Array& v) {
        QL_REQUIRE(n_ == v.n_,
                   "arrays with different sizes (" << n_ << ", "
                   << v.n_ << ") cannot be divided");
        std::transform(begin(), end(), v.begin(), begin(), std::divides<>());
        return *this;
    }

    inline const Array& Array::operator/=(Real x) {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(x != 0.0, "division by zero");
        #endif
        std::transform(begin(), end(), begin(), [=](Real y) -> Real { return y / x; });
        return *this;
    }

    inline Real Array::operator[](Size i) const {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(i<n_,
                   "index (" << i << ") must be less than " << n_ <<
                   ": array access out of range");
        #endif
        return data_.get()[i];
    }

    inline Real Array::at(Size i) const {
        QL_REQUIRE(i<n_,
                   "index (" << i << ") must be less than " << n_ <<
                   ": array access out of range");
        return data_.get()[i];
    }

    inline Real Array::front() const {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(n_>0, "null Array: array access out of range");
        #endif
        return data_.get()[0];
    }

    inline Real Array::back() const {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(n_>0, "null Array: array access out of range");
        #endif
        return data_.get()[n_-1];
    }

    inline Real& Array::operator[](Size i) {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(i<n_,
                   "index (" << i << ") must be less than " << n_ <<
                   ": array access out of range");
        #endif
        return data_.get()[i];
    }

    inline Real& Array::at(Size i) {
        QL_REQUIRE(i<n_,
                   "index (" << i << ") must be less than " << n_ <<
                   ": array access out of range");
        return data_.get()[i];
    }

    inline Real& Array::front() {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(n_>0, "null Array: array access out of range");
        #endif
        return data_.get()[0];
    }

    inline Real& Array::back() {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(n_>0, "null Array: array access out of range");
        #endif
        return data_.get()[n_-1];
    }

    inline Size Array::size() const {
        return n_;
    }

    inline bool Array::empty() const {
        return n_ == 0;
    }

    inline Array::const_iterator Array::begin() const {
        return data_.get();
    }

    inline Array::iterator Array::begin() {
        return data_.get();
    }

    inline Array::const_iterator Array::end() const {
        return data_.get()+n_;
    }

    inline Array::iterator Array::end() {
        return data_.get()+n_;
    }

    inline Array::const_reverse_iterator Array::rbegin() const {
        return const_reverse_iterator(end());
    }

    inline Array::reverse_iterator Array::rbegin() {
        return reverse_iterator(end());
    }

    inline Array::const_reverse_iterator Array::rend() const {
        return const_reverse_iterator(begin());
    }

    inline Array::reverse_iterator Array::rend() {
        return reverse_iterator(begin());
    }

    inline void Array::resize(Size n) {
        if (n > n_) {
            Array swp(n);
            std::copy(begin(), end(), swp.begin());
            swap(swp);
        }
        else if (n < n_) {
            n_ = n;
        }
    }

    inline void Array::swap(Array& from) noexcept {
        data_.swap(from.data_);
        std::swap(n_, from.n_);
    }

    // dot product and norm

    inline Real DotProduct(const Array& v1, const Array& v2) {
        QL_REQUIRE(v1.size() == v2.size(),
                   "arrays with different sizes (" << v1.size() << ", "
                   << v2.size() << ") cannot be multiplied");
        return std::inner_product(v1.begin(),v1.end(),v2.begin(),Real(0.0));
    }

    inline Real Norm2(const Array& v) {
        return std::sqrt(DotProduct(v, v));
    }

    // overloaded operators

    // unary

    inline Array operator+(const Array& v) {
        Array result = v;
        return result;
    }

    inline Array operator+(Array&& v) {
        return std::move(v);
    }

    inline Array operator-(const Array& v) {
        Array result(v.size());
        std::transform(v.begin(), v.end(), result.begin(), std::negate<>());
        return result;
    }

    inline Array operator-(Array&& v) {
        Array result = std::move(v);
        std::transform(result.begin(), result.end(), result.begin(), std::negate<>());
        return result;
    }

    // binary operators

    inline Array operator+(const Array& v1, const Array& v2) {
        QL_REQUIRE(v1.size() == v2.size(),
                   "arrays with different sizes (" << v1.size() << ", "
                   << v2.size() << ") cannot be added");
        Array result(v1.size());
        std::transform(v1.begin(),v1.end(),v2.begin(),result.begin(), std::plus<>());
        return result;
    }

    inline Array operator+(const Array& v1, Array&& v2) {
        QL_REQUIRE(v1.size() == v2.size(),
                   "arrays with different sizes (" << v1.size() << ", "
                   << v2.size() << ") cannot be added");
        Array result = std::move(v2);
        std::transform(v1.begin(), v1.end(), result.begin(), result.begin(), std::plus<>());
        return result;
    }

    inline Array operator+(Array&& v1, const Array& v2) {
        QL_REQUIRE(v1.size() == v2.size(),
                   "arrays with different sizes (" << v1.size() << ", "
                   << v2.size() << ") cannot be added");
        Array result = std::move(v1);
        std::transform(result.begin(), result.end(), v2.begin(), result.begin(), std::plus<>());
        return result;
    }

    inline Array operator+(Array&& v1, Array&& v2) { // NOLINT(cppcoreguidelines-rvalue-reference-param-not-moved)
        QL_REQUIRE(v1.size() == v2.size(),
                   "arrays with different sizes (" << v1.size() << ", "
                   << v2.size() << ") cannot be added");
        Array result = std::move(v2);
        std::transform(v1.begin(), v1.end(), result.begin(), result.begin(), std::plus<>());
        return result;
    }

    inline Array operator+(const Array& v1, Real a) {
        Array result(v1.size());
        std::transform(v1.begin(), v1.end(), result.begin(), [=](Real y) -> Real { return y + a; });
        return result;
    }

    inline Array operator+(Array&& v1, Real a) {
        Array result = std::move(v1);
        std::transform(result.begin(), result.end(), result.begin(), [=](Real y) -> Real { return y + a; });
        return result;
    }

    inline Array operator+(Real a, const Array& v2) {
        Array result(v2.size());
        std::transform(v2.begin(),v2.end(),result.begin(), [=](Real y) -> Real { return a + y; });
        return result;
    }

    inline Array operator+(Real a, Array&& v2) {
        Array result = std::move(v2);
        std::transform(result.begin(), result.end(), result.begin(), [=](Real y) -> Real { return a + y; });
        return result;
    }

    inline Array operator-(const Array& v1, const Array& v2) {
        QL_REQUIRE(v1.size() == v2.size(),
                   "arrays with different sizes (" << v1.size() << ", "
                   << v2.size() << ") cannot be subtracted");
        Array result(v1.size());
        std::transform(v1.begin(), v1.end(), v2.begin(), result.begin(), std::minus<>());
        return result;
    }

    inline Array operator-(const Array& v1, Array&& v2) {
        QL_REQUIRE(v1.size() == v2.size(),
                   "arrays with different sizes (" << v1.size() << ", "
                   << v2.size() << ") cannot be subtracted");
        Array result = std::move(v2);
        std::transform(v1.begin(), v1.end(), result.begin(), result.begin(), std::minus<>());
        return result;
    }

    inline Array operator-(Array&& v1, const Array& v2) {
        QL_REQUIRE(v1.size() == v2.size(),
                   "arrays with different sizes (" << v1.size() << ", "
                   << v2.size() << ") cannot be subtracted");
        Array result = std::move(v1);
        std::transform(result.begin(), result.end(), v2.begin(), result.begin(), std::minus<>());
        return result;
    }

    inline Array operator-(Array&& v1, Array&& v2) { // NOLINT(cppcoreguidelines-rvalue-reference-param-not-moved)
        QL_REQUIRE(v1.size() == v2.size(),
                   "arrays with different sizes (" << v1.size() << ", "
                   << v2.size() << ") cannot be subtracted");
        Array result = std::move(v2);
        std::transform(v1.begin(), v1.end(), result.begin(), result.begin(), std::minus<>());
        return result;
    }

    inline Array operator-(const Array& v1, Real a) {
        Array result(v1.size());
        std::transform(v1.begin(),v1.end(),result.begin(), [=](Real y) -> Real { return y - a; });
        return result;
    }

    inline Array operator-(Array&& v1, Real a) {
        Array result = std::move(v1);
        std::transform(result.begin(), result.end(), result.begin(), [=](Real y) -> Real { return y - a; });
        return result;
    }

    inline Array operator-(Real a, const Array& v2) {
        Array result(v2.size());
        std::transform(v2.begin(),v2.end(),result.begin(), [=](Real y) -> Real { return a - y; });
        return result;
    }

    inline Array operator-(Real a, Array&& v2) {
        Array result = std::move(v2);
        std::transform(result.begin(), result.end(), result.begin(), [=](Real y) -> Real { return a - y; });
        return result;
    }

    inline Array operator*(const Array& v1, const Array& v2) {
        QL_REQUIRE(v1.size() == v2.size(),
                   "arrays with different sizes (" << v1.size() << ", "
                   << v2.size() << ") cannot be multiplied");
        Array result(v1.size());
        std::transform(v1.begin(), v1.end(), v2.begin(), result.begin(), std::multiplies<>());
        return result;
    }

    inline Array operator*(const Array& v1, Array&& v2) {
        QL_REQUIRE(v1.size() == v2.size(),
                   "arrays with different sizes (" << v1.size() << ", "
                   << v2.size() << ") cannot be multiplied");
        Array result = std::move(v2);
        std::transform(v1.begin(), v1.end(), result.begin(), result.begin(), std::multiplies<>());
        return result;
    }

    inline Array operator*(Array&& v1, const Array& v2) {
        QL_REQUIRE(v1.size() == v2.size(),
                   "arrays with different sizes (" << v1.size() << ", "
                   << v2.size() << ") cannot be multiplied");
        Array result = std::move(v1);
        std::transform(result.begin(), result.end(), v2.begin(), result.begin(), std::multiplies<>());
        return result;
    }

    inline Array operator*(Array&& v1, Array&& v2) { // NOLINT(cppcoreguidelines-rvalue-reference-param-not-moved)
        QL_REQUIRE(v1.size() == v2.size(),
                   "arrays with different sizes (" << v1.size() << ", "
                   << v2.size() << ") cannot be multiplied");
        Array result = std::move(v2);
        std::transform(v1.begin(), v1.end(), result.begin(), result.begin(), std::multiplies<>());
        return result;
    }

    inline Array operator*(const Array& v1, Real a) {
        Array result(v1.size());
        std::transform(v1.begin(),v1.end(),result.begin(), [=](Real y) -> Real { return y * a; });
        return result;
    }

    inline Array operator*(Array&& v1, Real a) {
        Array result = std::move(v1);
        std::transform(result.begin(), result.end(), result.begin(), [=](Real y) -> Real { return y * a; });
        return result;
    }

    inline Array operator*(Real a, const Array& v2) {
        Array result(v2.size());
        std::transform(v2.begin(),v2.end(),result.begin(), [=](Real y) -> Real { return a * y; });
        return result;
    }

    inline Array operator*(Real a, Array&& v2) {
        Array result = std::move(v2);
        std::transform(result.begin(), result.end(), result.begin(), [=](Real y) -> Real { return a * y; });
        return result;
    }

    inline Array operator/(const Array& v1, const Array& v2) {
        QL_REQUIRE(v1.size() == v2.size(),
                   "arrays with different sizes (" << v1.size() << ", "
                   << v2.size() << ") cannot be divided");
        Array result(v1.size());
        std::transform(v1.begin(), v1.end(), v2.begin(), result.begin(), std::divides<>());
        return result;
    }

    inline Array operator/(const Array& v1, Array&& v2) {
        QL_REQUIRE(v1.size() == v2.size(),
                   "arrays with different sizes (" << v1.size() << ", "
                   << v2.size() << ") cannot be divided");
        Array result = std::move(v2);
        std::transform(v1.begin(), v1.end(), result.begin(), result.begin(), std::divides<>());
        return result;
    }

    inline Array operator/(Array&& v1, const Array& v2) {
        QL_REQUIRE(v1.size() == v2.size(),
                   "arrays with different sizes (" << v1.size() << ", "
                   << v2.size() << ") cannot be divided");
        Array result = std::move(v1);
        std::transform(result.begin(), result.end(), v2.begin(), result.begin(), std::divides<>());
        return result;
    }

    inline Array operator/(Array&& v1, Array&& v2) { // NOLINT(cppcoreguidelines-rvalue-reference-param-not-moved)
        QL_REQUIRE(v1.size() == v2.size(),
                   "arrays with different sizes (" << v1.size() << ", "
                   << v2.size() << ") cannot be divided");
        Array result = std::move(v2);
        std::transform(v1.begin(), v1.end(), result.begin(), result.begin(), std::divides<>());
        return result;
    }

    inline Array operator/(const Array& v1, Real a) {
        Array result(v1.size());
        std::transform(v1.begin(),v1.end(),result.begin(), [=](Real y) -> Real { return y / a; });
        return result;
    }

    inline Array operator/(Array&& v1, Real a) {
        Array result = std::move(v1);
        std::transform(result.begin(), result.end(), result.begin(), [=](Real y) -> Real { return y / a; });
        return result;
    }

    inline Array operator/(Real a, const Array& v2) {
        Array result(v2.size());
        std::transform(v2.begin(),v2.end(),result.begin(), [=](Real y) -> Real { return a / y; });
        return result;
    }

    inline Array operator/(Real a, Array&& v2) {
        Array result = std::move(v2);
        std::transform(result.begin(), result.end(), result.begin(), [=](Real y) -> Real { return a / y; });
        return result;
    }

    // functions

    inline Array Abs(const Array& v) {
        Array result(v.size());
        std::transform(v.begin(), v.end(), result.begin(),
                       [](Real x) -> Real { return std::fabs(x); });
        return result;
    }

    inline Array Abs(Array&& v) {
        Array result = std::move(v);
        std::transform(result.begin(), result.end(), result.begin(),
                       [](Real x) -> Real { return std::fabs(x); });
        return result;
    }

    inline Array Sqrt(const Array& v) {
        Array result(v.size());
        std::transform(v.begin(),v.end(),result.begin(),
                       [](Real x) -> Real { return std::sqrt(x); });
        return result;
    }

    inline Array Sqrt(Array&& v) {
        Array result = std::move(v);
        std::transform(result.begin(), result.end(), result.begin(),
                       [](Real x) -> Real { return std::sqrt(x); });
        return result;
    }

    inline Array Log(const Array& v) {
        Array result(v.size());
        std::transform(v.begin(),v.end(),result.begin(),
                       [](Real x) -> Real { return std::log(x); });
        return result;
    }

    inline Array Log(Array&& v) {
        Array result = std::move(v);
        std::transform(result.begin(), result.end(), result.begin(),
                       [](Real x) -> Real { return std::log(x); });
        return result;
    }

    inline Array Exp(const Array& v) {
        Array result(v.size());
        std::transform(v.begin(), v.end(), result.begin(),
                       [](Real x) -> Real { return std::exp(x); });
        return result;
    }

    inline Array Exp(Array&& v) {
        Array result = std::move(v);
        std::transform(result.begin(), result.end(), result.begin(),
                       [](Real x) -> Real { return std::exp(x); });
        return result;
    }

    inline Array Pow(const Array& v, Real alpha) {
        Array result(v.size());
        std::transform(v.begin(), v.end(), result.begin(),
                       [=](Real x) -> Real { return std::pow(x, alpha); });
        return result;
    }

    inline Array Pow(Array&& v, Real alpha) {
        Array result = std::move(v);
        std::transform(result.begin(), result.end(), result.begin(),
                       [=](Real x) -> Real { return std::pow(x, alpha); });
        return result;
    }

    inline void swap(Array& v, Array& w) noexcept {
        v.swap(w);
    }

    inline std::ostream& operator<<(std::ostream& out, const Array& a) {
        std::streamsize width = out.width();
        out << "[ ";
        if (!a.empty()) {
            for (Size n=0; n<a.size()-1; ++n)
                out << std::setw(int(width)) << a[n] << "; ";
            out << std::setw(int(width)) << a.back();
        }
        out << " ]";
        return out;
    }

}


#endif

</source_files>

<implementation_guidance>

=== FILES: FdmSSpaceReferenceSolver ===

Path: ql/methods/finitedifferences/utilities/fdmsspacereferencesolver.hpp
      ql/methods/finitedifferences/utilities/fdmsspacereferencesolver.cpp

A standalone solver implementing BOTH schemes in S-space exactly as in the
Golden Reference Document. Does NOT use QuantLib's FDM framework.

  class FdmSSpaceReferenceSolver {
    public:
      enum Scheme { ExponentiallyFitted, CrankNicolsonVariant };

      struct Result {
          Array prices;
          Array grid;
          Size timeSteps;
          bool positivityPreserved;
          Real minPrice;
          Real oscillationScore;
      };

      FdmSSpaceReferenceSolver(
          Real r, Real sigma, Real K,
          Real T, Real Smax,
          Real deltaS, Real deltaT,
          Scheme scheme);

      Result solveTruncatedCall(Real upperCutoff) const;

      Result solveDiscreteBarrierCall(
          Real lowerBarrier, Real upperBarrier,
          const std::vector<Time>& monitoringTimes) const;

    private:
      static Array thomasSolve(
          const Array& sub, const Array& diag,
          const Array& sup, const Array& rhs);

      static Real computeRho(Real mu_j, Real sigma_d_j, Real deltaS);

      Real r_, sigma_, K_, T_, Smax_, deltaS_, deltaT_;
      Scheme scheme_;
  };

IMPLEMENTATION NOTES:
- Follow the Golden Reference Â§5 pseudocode line-by-line
- Scheme 1: assemble A per CE-9, solve AÂ·U^{n+1} = U^n
- Scheme 2: assemble P and N per CE-17/CE-18 with Ï‰ = -r/(16ÏƒÂ²),
  solve PÂ·U^{n+1} = NÂ·U^n
- Apply monitoring projection per CE-6

CRITICAL NOTATION WARNING (from audit Â§2):
  The paper's Eq. (2) uses Ïƒ for the DIFFUSION COEFFICIENT Ïƒ(S,t) = Â½ÏƒÂ²_volÂ·SÂ².
  The fitting factor formula (Eq. 3) uses this diffusion coefficient.
  In this S-space implementation, always use:
    sigma_d = 0.5 * sigma_vol * sigma_vol * S_j * S_j   (diffusion coefficient)
    mu_j = r * S_j                                        (convection)
  And the PÃ©clet argument is:  mu_j * deltaS / (2 * sigma_d)
                              = r * deltaS / (sigma_volÂ² * S_j)
  NEVER substitute sigma_vol directly where sigma_d belongs.
  
</implementation_guidance>

<constraints>
- Does NOT use QuantLib's FDM framework
- Uses only ql/math/array.hpp for Array storage
- Thread-safe (no mutable state)
</constraints>

<output_specification>
Produce exactly 2 files:
1. fdmsspacereferencesolver.hpp
2. fdmsspacereferencesolver.cpp
</output_specification>

<quality_checklist>
â–¡ Thomas algorithm matches Â§3(g) of Golden Reference
â–¡ Fitting factor matches CE-7 with all numerical guards
â–¡ Scheme 1 matrix A matches CE-9 exactly
â–¡ Scheme 2 matrices P, N match CE-17/CE-18 with Ï‰ from CE-19
â–¡ Monitoring projection matches CE-6
â–¡ Handles CE-20 constraint violation gracefully (warns, does not crash)
</quality_checklist>
