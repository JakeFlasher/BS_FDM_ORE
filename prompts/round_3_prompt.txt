<system_context>
You are an expert C++ developer implementing two positivity-preserving finite
difference schemes from Milev & Tagliani (2010) into QuantLib 1.42-dev's modern
Fdm* framework. The schemes address spurious oscillations and negative prices
that standard Crankâ€“Nicolson produces when ÏƒÂ² â‰ª r and payoffs are discontinuous.

PAPER REFERENCE (corrected formulations):
Scheme 1: Fully implicit with Duffy's exponentially fitted diffusion coefficient.
Scheme 2: Crankâ€“Nicolson variant with a modified 6-node reaction-term stencil.
Both are described in the GOLDEN REFERENCE DOCUMENT (ROUND 1.5 output), whose
corrected equation chain (CE-1 through CE-25) is authoritative.

SOURCE-OF-TRUTH / NO-HALLUCINATION RULES (mandatory):
- Use ONLY the provided source files and prior-ROUND outputs as factual reference
  for class/method signatures, include paths, base-class requirements, and
  coding conventions.
- If any referenced file content is missing (i.e., an [INSERT FULL CONTENT ...]
  placeholder is not filled), DO NOT guess or reconstruct.
  STOP and ask the user to provide the missing file(s).
- If a requirement is ambiguous, search the provided files for the relevant
  implementation detail and implement the behavior that matches the source.
  If still ambiguous, STOP and ask a precise clarification question.

INTERNAL VERIFICATION PROTOCOL (mandatory; do before coding; do not print):
- Verify what the 1D BS mesher stores as spatial coordinate x (ln(S), ln(S/K),
  or other) by reading FdmBlackScholesMesher and FdmBlackScholesOp.
- Verify how FirstDerivativeOp / SecondDerivativeOp incorporate nonuniform mesh
  spacing (which mesher spacing functions they use).
- Verify the TripleBandLinearOp sign conventions: which off-diagonal coefficients
  must be nonneg for the system matrix (I âˆ’ Î¸Â·dtÂ·L) to be an M-matrix.
- Verify how FdmBackwardSolver handles step conditions (rollback segmentation at
  stopping times, and whether applyTo is called at the initial 'from' time).
- Verify that ext::make_shared<T>(...) is available in QuantLib's ext namespace.
  If it is not aliased, fall back to ext::shared_ptr<T>(new T(...)).

CODING CONVENTIONS (mandatory):
- Namespace: all classes in `namespace QuantLib { }`
- Smart pointers: use `ext::shared_ptr`, NOT `std::shared_ptr`
- Factory calls: prefer `ext::make_shared<T>(...)` if available; verify from
  provided headers before use. Fallback: `ext::shared_ptr<T>(new T(...))`.
- Return arrays: use `Array`
- Assertions: `QL_REQUIRE(condition, message)` for preconditions,
  `QL_ENSURE(condition, message)` for postconditions
- Include guards: `#ifndef quantlib_<path_underscored>_hpp`
- Copyright header: match the style of adjacent files in the same directory
- Includes: use angle brackets `<ql/...>` for QuantLib headers
- No `using namespace std;` in headers
- Naming: `camelCase` for methods, `camelCase_` for private members,
  `CamelCase` for classes

OUTPUT RULES:
- Produce COMPLETE files, never diffs or partial snippets
- Only output files that are new or modified in this ROUND
- Each file must compile against unmodified QuantLib 1.42-dev headers plus any
  files produced in prior ROUNDs
- Include all necessary #include directives
</system_context>


<mathematical_context>
PAPER'S ORIGINAL PDE (S-space, time-to-expiry Ï„; CE-1):
  âˆ’âˆ‚V/âˆ‚Ï„ + rSÂ·âˆ‚V/âˆ‚S + Â½ÏƒÂ²SÂ²Â·âˆ‚Â²V/âˆ‚SÂ² âˆ’ rV = 0

NOTATION WARNING â€” TWO DIFFERENT Ïƒ's IN THE PAPER:
  Document 5 (Eq. 2) rewrites the PDE in generalized form:
    âˆ’V_t + Î¼(S,t)Â·V_S + Ïƒ(S,t)Â·V_SS + b(S,t)Â·V = 0
  where Ïƒ(S,t) = Â½ÏƒÂ²_volÂ·SÂ² is the DIFFUSION COEFFICIENT, NOT the volatility.
  The fitting factor formula (Eq. 3) uses this diffusion coefficient Ïƒ(S,t).
  An implementer who substitutes Ïƒ_vol directly for Ïƒ(S,t) will get completely
  wrong results. In log-space this ambiguity is resolved: a = ÏƒÂ²_vol/2 is
  always the half-variance, and b = (râˆ’q) âˆ’ ÏƒÂ²_vol/2 is the drift.

DIVIDEND YIELD NOTE:
  The original papers assume q = 0. The QuantLib implementation generalizes
  to q â‰¥ 0 via b = (râˆ’q) âˆ’ ÏƒÂ²/2. All paper-specific analysis uses q = 0.

QUANTLIB LOG-SPACE PDE (x = ln(S), backward time Ï„):
  âˆ’u_Ï„ + bÂ·u_x + aÂ·u_xx âˆ’ rÂ·u = 0
  where a = ÏƒÂ²/2,  b = (r âˆ’ q) âˆ’ ÏƒÂ²/2

â•â•â• SCHEME 1: EXPONENTIALLY FITTED OPERATOR (CE-7 through CE-15) â•â•â•

In log-space, the PÃ©clet parameter and fitting factor at interior node j are:
  Pe_j = b Â· h_j / (2Â·a)                   (local PÃ©clet number)
  Ï_j = Pe_j Â· coth(Pe_j)                  (fitting factor; Ï â†’ 1+PeÂ²/3 for |Pe|â†’0)

SPATIAL VARIATION NOTE:
  In S-space, the PÃ©clet parameter Î±_j = rÂ·Î”S/(ÏƒÂ²Â·S_j) varies with S_j:
  it is large for small S_j (upwind regime) and small for large S_j (centered
  regime). In log-space with uniform h, Pe = bh/(2a) is CONSTANT across nodes,
  but with nonuniform h (concentrated meshes), Pe_j varies per node. The fitting
  factor Ï_j â‰¥ 1 for all Pe_j, regardless of sign or magnitude.

Fitted stencil (replacing the standard centered operator):
  â„“_j = aÂ·Ï_j/hÂ² âˆ’ b/(2h)     (lower off-diagonal)
  d_j = âˆ’2Â·aÂ·Ï_j/hÂ² âˆ’ r        (main diagonal)
  u_j = aÂ·Ï_j/hÂ² + b/(2h)     (upper off-diagonal)

NON-NEGATIVITY PROOF (for M-matrix):
  The lower off-diagonal can be rewritten as:
    â„“_j = (b/(2h))Â·(coth(Pe) âˆ’ 1)
  and the upper as:
    u_j = (b/(2h))Â·(coth(Pe) + 1)

  For b > 0 (Pe > 0): coth(Pe) > 1, so coth(Pe)âˆ’1 > 0; b/(2h) > 0. â„“_j > 0.
                       coth(Pe) + 1 > 0; u_j > 0.
  For b < 0 (Pe < 0): coth(Pe) < âˆ’1, so coth(Pe)âˆ’1 < âˆ’2 (neg); b/(2h) < 0.
                       Product of two negatives: â„“_j > 0.
                       coth(Pe)+1 < 0 (neg); b/(2h) < 0. u_j > 0.
  For b = 0: Ï â†’ 1, â„“_j = a/hÂ² > 0, u_j = a/hÂ² > 0.

  KEY PROPERTY: The inequality Ï_j â‰¥ 1 holds for ALL real Pe_j because
  xÂ·coth(x) â‰¥ 1 for all x (equality only at x=0 in the limit). This guarantee
  is per-node and holds on ANY mesh (uniform or nonuniform).

  On UNIFORM meshes this guarantees system matrix (I âˆ’ Î¸Â·dtÂ·L) is an M-matrix
  for any h > 0 and any parameter values.
  On NONUNIFORM meshes, the guarantee holds when the mesh ratio dâº/dâ» is
  moderate (typically < 3:1). The mMatrixViolationCount() diagnostic verifies
  this at runtime.

This ensures the system matrix (I âˆ’ Î¸Â·dtÂ·L) is an M-matrix.

Artificial diffusion (CE-15, low-Ïƒ limit): Â½Â·rÂ·SÂ·Î”SÂ·V_SS in S-space.
In log-space with uniform grid: Â½Â·bÂ·hÂ·u_xx (from the upwind limiting scheme).

NOTE ON PAPER TYPO (p. 227): The upwind scheme formulas on p. 227 show a
denominator of 2h, but direct computation shows the correct denominator is h.
The subsequent consistency analysis (eq. 7) and numerical diffusion formula
Â½Î¼hÂ·V_SS are correct â€” they correspond to the actual limiting scheme with h.

NONUNIFORM GRID NOTE: For non-uniform meshes, compute a per-node effective
spacing consistent with QuantLib's derivative operators:
  h_j := 0.5*(dplus_j + dminus_j)
At boundary nodes (first/last), dplus or dminus is Null<Real>(); skip these
nodes in per-node computations (they are handled by boundary conditions).

â•â•â• SCHEME 2: CN VARIANT WITH MODIFIED REACTION TERM (CE-16 through CE-23) â•â•â•

The paper's CN variant replaces âˆ’rÂ·u_j with the 6-node stencil:
  âˆ’rÂ·[Ï‰Â·u_{jâˆ’1} + (1âˆ’2Ï‰)Â·u_j + Ï‰Â·u_{j+1}]
at each time level, with Ï‰â‚ = Ï‰â‚‚ = Ï‰ (symmetric weighting).

PARAMETER CHOICE (CE-19):
  Ï‰ = âˆ’r/(16ÏƒÂ²)

EFFECTIVE-DIFFUSION REFORMULATION FOR LOG-SPACE ASSEMBLY:
  The paper's CN variant applies the FULL off-diagonal reaction weight Ï‰ at
  each time level (eq. 8: each level sums to Â½, but Ï‰ appears unsplit).
  Standard CN time-stepping halves the operator. To compensate, the spatial
  operator L must contain 2|rÏ‰| on its off-diagonals so that after CN's
  Â½-factor, the system matrix reproduces the paper's P and N.

  This is mathematically equivalent to using an enhanced diffusion coefficient:
    a_eff = ÏƒÂ²/2 + rÂ²Â·hÂ²/(8Â·ÏƒÂ²)
  with the standard reaction term âˆ’r, assembled via the standard axpyb() pattern.

  PROOF: With a_eff, standard CN produces system matrix P = I âˆ’ Â½Î”tÂ·L where:
    L_lower = a_eff/hÂ² âˆ’ b/(2h) = ÏƒÂ²/(2hÂ²) + rÂ²/(8ÏƒÂ²) âˆ’ b/(2h)
    P_lower = âˆ’Â½Î”tÂ·L_lower
    The additional off-diagonal vs standard CN: âˆ’Â½Î”tÂ·rÂ²/(8ÏƒÂ²) = âˆ’Î”tÂ·rÂ²/(16ÏƒÂ²)

    In the paper's S-space P matrix (Document 5, p. 228), the additional
    off-diagonal from the distributed reaction is rÏ‰â‚‚ = âˆ’rÂ²/(16ÏƒÂ²), which
    when multiplied by Î”t (to convert from the paper's 1/Î”t-normalized form)
    gives âˆ’Î”tÂ·rÂ²/(16ÏƒÂ²). These match. âˆ

  IMPORTANT: The coefficient is rÂ²hÂ²/(8ÏƒÂ²), NOT rÂ²hÂ²/(16ÏƒÂ²).
  The factor-of-2 arises because the paper places FULL Ï‰ at each CN time level
  while standard CN halves the operator contribution. Without the doubling, we
  would get rÂ²hÂ²/(16ÏƒÂ²) â€” which is wrong by exactly a factor of 2.

M-MATRIX GUARANTEE FOR CN VARIANT (corrected from audit Â§4b):
  In S-space, the P lower entry with Ï‰ = âˆ’r/(16ÏƒÂ²) is:
    P_lower = rÏ‰ + rS_j/(4Î”S) âˆ’ ÏƒÂ²S_jÂ²/(4Î”SÂ²)
            = âˆ’rÂ²/(16ÏƒÂ²) + rj/4 âˆ’ ÏƒÂ²jÂ²/4     (where j = S_j/Î”S)
  Completing the square:
    = âˆ’(ÏƒÂ²/4)Â·(j âˆ’ r/(2ÏƒÂ²))Â²
  This is a SINGLE non-positive perfect square: P_lower â‰¤ 0 for ALL j â‰¥ 0.
  Similarly, P_upper = âˆ’rÂ²/(16ÏƒÂ²) âˆ’ rj/4 âˆ’ ÏƒÂ²jÂ²/4 < 0 for j > 0.
  Therefore P is ALWAYS an M-matrix, unconditionally â€” no parameter
  restrictions needed for the off-diagonals.

  In log-space, the equivalent condition on the L operator (L_lower â‰¥ 0) is:
    a_eff/hÂ² âˆ’ b/(2h) â‰¥ 0,  i.e.,  a_eff â‰¥ bh/2
  Since a_eff = ÏƒÂ²/2 + rÂ²hÂ²/(8ÏƒÂ²) and b â‰ˆ r for q=0, Ïƒâ‰ªr:
    rÂ²hÂ²/(8ÏƒÂ²) â‰¥ rh/2  âŸº  rh/(4ÏƒÂ²) â‰¥ 1  âŸº  h â‰¥ 4ÏƒÂ²/r
  For Ïƒ=0.001, r=0.05: h â‰¥ 8Ã—10â»âµ â€” effectively always satisfied.

TIME-STEP CONSTRAINT (CE-20, log-space form):
  For N â‰¥ 0 (explicit-side diagonal non-negative):
    1 âˆ’ 0.5Â·Î”tÂ·(2Â·a_eff/hÂ² + r) â‰¥ 0
  âŸ¹  Î”t < 1 / [ÏƒÂ²/(2hÂ²) + rÂ²/(8ÏƒÂ²) + r/2]
  This is less restrictive than the S-space form (no growing (ÏƒM)Â² term)
  but still very tight for small Ïƒ. For Ïƒ=0.001, r=0.05, h=0.01:
  the rÂ²/(8ÏƒÂ²) = 312.5 term dominates, giving Î”t < 0.0032.

ACCURACY CONSTRAINTS (from audit Â§5b):
  Scheme 1 numerical diffusion (S-space): Â½rSÎ”SÂ·V_SS
  For this to be negligible vs physical diffusion Â½ÏƒÂ²SÂ²Â·V_SS:
    Î”S â‰ª ÏƒÂ²S/r
  At S=100, Ïƒ=0.001, r=0.05: Î”S â‰ª 0.002. With Î”S=0.05, numerical diffusion
  is ~25Ã— the physical diffusion â€” the solution is heavily smeared.

  Scheme 2 numerical diffusion (S-space): â…›(rÎ”S/Ïƒ)Â²Â·V_SS
  For this â‰ª Â½ÏƒÂ²SÂ²Â·V_SS: need (rÎ”S/Ïƒ)Â² â‰ª 4ÏƒÂ²SÂ²
  Equivalently: Î”S â‰ª 2ÏƒÂ²S/r (same order as Scheme 1 at moderate S).

  In log-space with uniform h:
    Scheme 1 diffusion: Â½bhÂ·u_xx â†’ need h â‰ª 2a/b = ÏƒÂ²/(râˆ’qâˆ’ÏƒÂ²/2) â‰ˆ ÏƒÂ²/r
    Scheme 2 diffusion: rÂ²hÂ²/(8ÏƒÂ²)Â·u_xx â†’ need h â‰ª 2Ïƒ/r (from rÂ²hÂ²/(8ÏƒÂ²) â‰ª ÏƒÂ²/2)

  PRACTICAL GUIDELINE: For Ïƒ=0.001, r=0.05, both schemes need h â‰² 2Ã—10â»âµ
  (roughly 50,000+ log-space nodes on [ln(50), ln(150)]) for diffusion-free
  accuracy. Coarser grids are usable but introduce measurable smearing.

SCHEME CROSSOVER ANALYSIS (from audit Â§5c):
  The two numerical diffusion terms are equal (in S-space) when:
    Â½rSÎ”S = â…›(rÎ”S/Ïƒ)Â²  âŸ¹  Î”S = 4ÏƒÂ²S/r
  For coarser grids (Î”S > 4ÏƒÂ²S/r), Scheme 1 has LESS diffusion.
  For finer grids, Scheme 2 wins due to its Î”SÂ² dependence.
  For Ïƒ=0.001, r=0.05, S=100: crossover at Î”S â‰ˆ 0.008.

Artificial diffusion (CE-23): â…›Â·(rÂ·Î”S/Ïƒ)Â²Â·V_SS in S-space.

NOTE ON FittedCrankNicolson POSITIVITY ANALYSIS:
  Combining Scheme 1's fitted operator with CN time-stepping:
  - P = I âˆ’ Â½Î”tÂ·L: off-diag = âˆ’Â½Î”tÂ·(fitted L off-diag) â‰¤ 0 (M-matrix âœ“)
    because fitted L off-diags are â‰¥ 0 (proven above).
  - N = I + Â½Î”tÂ·L: off-diag = Â½Î”tÂ·(fitted L off-diag) â‰¥ 0 (non-negative âœ“)
  - N diagonal requires: 1 âˆ’ Â½Î”tÂ·(2aÏ/hÂ² + r) â‰¥ 0
    âŸ¹ Î”t â‰¤ 1/(aÏ_max/hÂ² + r/2)
  Since Ï_max â‰ˆ |Pe_max| for large Pe, and Pe = bh/(2a):
    Î”t â‰¤ 1/(|b|/(2h) + r/2)
  This is LESS restrictive than the CN variant's constraint (no rÂ²/(8ÏƒÂ²) term)
  and may be preferable for very low volatility. However, the temporal accuracy
  is O(Î”tÂ²) only, not the CN variant's O(Î”tÂ²,hÂ²) â€” the spatial accuracy is
  O(h) from the fitting.

â•â•â• DISCRETE BARRIER MONITORING (CE-6) â•â•â•

At each monitoring date t_i, after the time-step solve:
  U_j â† U_j Â· ğŸ™_{[L,U]}(S_j)
This re-introduces discontinuities that the schemes must handle.

GRID ALIGNMENT REQUIREMENT:
  The barrier values L, U (and ideally the strike K) should be GRID POINTS.
  The paper uses Î”S=0.05 with L=90, K=100, U=110 â€” all exact multiples.
  Violating this introduces interpolation error that can reintroduce oscillations.
  In log-space: ln(L), ln(U), ln(K) should be mesher locations. QuantLib's
  Concentrating1dMesher can place nodes at specified points. The
  FdmBlackScholesMesher already concentrates aROUND the strike; users should
  also ensure barrier locations are mesher concentration points.

S_MAX SELECTION (from Document 1, Eq. 5.2):
  S_max = max{RÂ·K, KÂ·exp(âˆš(2TÏƒÂ²Â·ln 100))},  R â‰¥ 2
  For very low Ïƒ: S_max = RÂ·K (rule of thumb: 3â€“4 times the strike).
  For moderate Ïƒ: the exponential term dominates.
  In log-space: x_max = ln(S_max), x_min = ln(S_min) with S_min small but >0.

â•â•â• M-MATRIX DIAGNOSTIC (CE-10, Proposition 4.1) â•â•â•

For the operator L stored in mapT_, the M-matrix condition for the system
matrix (I âˆ’ Î¸Â·dtÂ·L) requires:
  All off-diagonals of L (lower_[] and upper_[]) must be NON-NEGATIVE.
  (Because system off-diag = âˆ’Î¸Â·dtÂ·(operator off-diag), and Î¸Â·dt > 0.)

To access protected lower_[]/upper_[] arrays of TripleBandLinearOp, construct
a temporary ModTripleBandLinearOp from mapT_ and use its public accessors.

â•â•â• NOTE ON FittedCrankNicolson COMBINATION â•â•â•

The paper uses Scheme 1 (fitted operator) with fully-implicit time stepping ONLY.
The FittedCrankNicolson factory (Scheme 1 operator + CN time stepping) is a
natural EXTENSION not present in the original paper. It may offer improved
temporal accuracy but its M-matrix and positivity properties differ from the
paper's proven guarantees. See the positivity analysis above for details.
Use with appropriate testing.

â•â•â• LOCAL VOLATILITY CAVEAT â•â•â•

With local or stochastic volatility, Ïƒ = Ïƒ(S,t):
- The fitting factor must be recomputed every time step (handled by setTime())
- The CN variant parameter Ï‰ = âˆ’r/(16ÏƒÂ²) becomes spatially varying
- The M-matrix guarantees remain valid per-node (the algebraic identities
  hold for any Ïƒ_j > 0) but the time-step constraint for the CN variant
  becomes node-dependent; use the worst-case node.
- Positivity guarantees for the quanto-adjusted case have NOT been verified.
</mathematical_context>

<task>
ROUND 3 OF 7: Modify FdmSchemeDesc to carry new configuration parameters and
modify CrankNicolsonScheme to support Rannacher-style damping restart after
discrete monitoring events.

OUTPUT: 3 files (1 modified header, 1 modified scheme header, 1 modified
scheme implementation).
NOTE: Only FdmSchemeDesc changes inside fdmbackwardsolver.hpp â€”
the FdmBackwardSolver class body is NOT changed until ROUND 4.
</task>

<source_files>
FILE: ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andreas Gaida
 Copyright (C) 2009 Ralph Schreyer
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmbackwardsolver.hpp
*/

#ifndef quantlib_fdm_backward_solver_hpp
#define quantlib_fdm_backward_solver_hpp

#include <ql/methods/finitedifferences/utilities/fdmboundaryconditionset.hpp>

namespace QuantLib {

    class FdmLinearOpComposite;
    class FdmStepConditionComposite;

    struct FdmSchemeDesc {
        enum FdmSchemeType { HundsdorferType, DouglasType,
                             CraigSneydType, ModifiedCraigSneydType, 
                             ImplicitEulerType, ExplicitEulerType,
                             MethodOfLinesType, TrBDF2Type,
                             CrankNicolsonType };

        FdmSchemeDesc(FdmSchemeType type, Real theta, Real mu);

        const FdmSchemeType type;
        const Real theta, mu;

        // some default scheme descriptions
        static FdmSchemeDesc Douglas(); //same as Crank-Nicolson in 1 dimension
        static FdmSchemeDesc CrankNicolson();
        static FdmSchemeDesc ImplicitEuler();
        static FdmSchemeDesc ExplicitEuler();
        static FdmSchemeDesc CraigSneyd();
        static FdmSchemeDesc ModifiedCraigSneyd(); 
        static FdmSchemeDesc Hundsdorfer();
        static FdmSchemeDesc ModifiedHundsdorfer();
        static FdmSchemeDesc MethodOfLines(
            Real eps=0.001, Real relInitStepSize=0.01);
        static FdmSchemeDesc TrBDF2();
    };
        
    class FdmBackwardSolver {
      public:
        typedef FdmLinearOp::array_type array_type;

        FdmBackwardSolver(ext::shared_ptr<FdmLinearOpComposite> map,
                          FdmBoundaryConditionSet bcSet,
                          const ext::shared_ptr<FdmStepConditionComposite>& condition,
                          const FdmSchemeDesc& schemeDesc);

        void rollback(array_type& a, 
                      Time from, Time to,
                      Size steps, Size dampingSteps);

      protected:
        const ext::shared_ptr<FdmLinearOpComposite> map_;
        const FdmBoundaryConditionSet bcSet_;
        const ext::shared_ptr<FdmStepConditionComposite> condition_;
        const FdmSchemeDesc schemeDesc_;
    };
}

#endif


FILE: ql/methods/finitedifferences/schemes/cranknicolsonscheme.hpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2019 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cranknicolsonscheme.hpp
    \brief Crank-Nicolson scheme
*/

#ifndef quantlib_crank_nicolson_scheme_hpp
#define quantlib_crank_nicolson_scheme_hpp

#include <ql/methods/finitedifferences/schemes/impliciteulerscheme.hpp>

namespace QuantLib {

    /*! In one dimension the Crank-Nicolson scheme is equivalent to the
        Douglas scheme and in higher dimensions it is usually inferior to
        operator splitting methods like Craig-Sneyd or Hundsdorfer-Verwer.
    */
    class ExplicitEulerScheme;

    class CrankNicolsonScheme  {
      public:
        // typedefs
        typedef OperatorTraits<FdmLinearOp> traits;
        typedef traits::operator_type operator_type;
        typedef traits::array_type array_type;
        typedef traits::bc_set bc_set;
        typedef traits::condition_type condition_type;

        // constructors
        CrankNicolsonScheme(
            Real theta,
            const ext::shared_ptr<FdmLinearOpComposite>& map,
            const bc_set& bcSet = bc_set(),
            Real relTol = 1e-8,
            ImplicitEulerScheme::SolverType solverType
                = ImplicitEulerScheme::BiCGstab);

        void step(array_type& a, Time t);
        void setStep(Time dt);

        Size numberOfIterations() const;
      protected:
        Real dt_;
        const Real theta_;
        const ext::shared_ptr<ExplicitEulerScheme> explicit_;
        const ext::shared_ptr<ImplicitEulerScheme> implicit_;
    };
}

#endif


FILE: ql/methods/finitedifferences/schemes/cranknicolsonscheme.cpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2019 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/schemes/expliciteulerscheme.hpp>
#include <ql/methods/finitedifferences/schemes/cranknicolsonscheme.hpp>

namespace QuantLib {
    CrankNicolsonScheme::CrankNicolsonScheme(
        Real theta,
        const ext::shared_ptr<FdmLinearOpComposite> & map,
        const bc_set& bcSet,
        Real relTol,
        ImplicitEulerScheme::SolverType solverType)
    : dt_(Null<Real>()),
      theta_(theta),
      explicit_(ext::make_shared<ExplicitEulerScheme>(map, bcSet)),
      implicit_(ext::make_shared<ImplicitEulerScheme>(
          map, bcSet, relTol, solverType)) {
    }

    void CrankNicolsonScheme::step(array_type& a, Time t) {
        QL_REQUIRE(t-dt_ > -1e-8, "a step towards negative time given");

        if (theta_ != 1.0)
            explicit_->step(a, t, 1.0-theta_);

        if (theta_ != 0.0)
            implicit_->step(a, t, theta_);
    }

    void CrankNicolsonScheme::setStep(Time dt) {
        dt_ = dt;
        explicit_->setStep(dt_);
        implicit_->setStep(dt_);
    }

    Size CrankNicolsonScheme::numberOfIterations() const {
        return implicit_->numberOfIterations();
    }
}


FILE: ql/methods/finitedifferences/schemes/impliciteulerscheme.hpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andreas Gaida
 Copyright (C) 2009 Ralph Schreyer
 Copyright (C) 2009, 2017 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file impliciteulerscheme.hpp
    \brief Implicit-Euler scheme
*/

#ifndef quantlib_implicit_euler_scheme_hpp
#define quantlib_implicit_euler_scheme_hpp

#include <ql/methods/finitedifferences/operatortraits.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/schemes/boundaryconditionschemehelper.hpp>

namespace QuantLib {

    class ImplicitEulerScheme {
      public:
        enum SolverType { BiCGstab, GMRES };

        // typedefs
        typedef OperatorTraits<FdmLinearOp> traits;
        typedef traits::operator_type operator_type;
        typedef traits::array_type array_type;
        typedef traits::bc_set bc_set;
        typedef traits::condition_type condition_type;

        // constructors
        explicit ImplicitEulerScheme(ext::shared_ptr<FdmLinearOpComposite> map,
                                     const bc_set& bcSet = bc_set(),
                                     Real relTol = 1e-8,
                                     SolverType solverType = BiCGstab);

        void step(array_type& a, Time t);
        void setStep(Time dt);

        Size numberOfIterations() const;
      protected:
        friend class CrankNicolsonScheme;
        void step(array_type& a, Time t, Real theta);

        Array apply(const Array& r, Real theta) const;
          
        Time dt_;
        ext::shared_ptr<Size> iterations_;

        const Real relTol_;
        const ext::shared_ptr<FdmLinearOpComposite> map_;
        const BoundaryConditionSchemeHelper bcSet_;
        const SolverType solverType_;
    };
}

#endif


FILE: ql/methods/finitedifferences/schemes/expliciteulerscheme.hpp
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andreas Gaida
 Copyright (C) 2009 Ralph Schreyer
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file expliciteulerscheme.hpp
    \brief explicit-Euler scheme
*/

#ifndef quantlib_explicit_euler_scheme_hpp
#define quantlib_explicit_euler_scheme_hpp

#include <ql/methods/finitedifferences/operatortraits.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/schemes/boundaryconditionschemehelper.hpp>

namespace QuantLib {

    class ExplicitEulerScheme  {
      public:
        // typedefs
        typedef OperatorTraits<FdmLinearOp> traits;
        typedef traits::operator_type operator_type;
        typedef traits::array_type array_type;
        typedef traits::bc_set bc_set;
        typedef traits::condition_type condition_type;

        // constructors
        explicit ExplicitEulerScheme(ext::shared_ptr<FdmLinearOpComposite> map,
                                     const bc_set& bcSet = bc_set());

        void step(array_type& a, Time t);
        void setStep(Time dt);

      protected:
        friend class CrankNicolsonScheme;
        void step(array_type& a, Time t, Real theta);

        Time dt_;
        const ext::shared_ptr<FdmLinearOpComposite> map_;
        const BoundaryConditionSchemeHelper bcSet_;
    };
}

#endif

</source_files>

<implementation_guidance>

=== FILE 1: Modified FdmSchemeDesc (in fdmbackwardsolver.hpp) ===

FdmSchemeDesc has ALL CONST members. New fields must also be const.

APPROACH: Replace the existing 3-parameter constructor with a 5-parameter
constructor that has defaults for backward compatibility:

  struct FdmSchemeDesc {
      enum FdmSchemeType { HundsdorferType, DouglasType,
                           CraigSneydType, ModifiedCraigSneydType,
                           ImplicitEulerType, ExplicitEulerType,
                           MethodOfLinesType, TrBDF2Type,
                           CrankNicolsonType };

      FdmSchemeDesc(FdmSchemeType type, Real theta, Real mu,
                    Size monitoringDampingSteps = 0,
                    Size operatorType = 0);

      const FdmSchemeType type;
      const Real theta, mu;
      const Size monitoringDampingSteps;  // NEW: Rannacher half-steps after monitoring
      const Size operatorType;             // NEW: 0=standard, 1=fitted, 2=CN variant

      // ALL existing static factories â€” produce identical behavior
      static FdmSchemeDesc Douglas();
      static FdmSchemeDesc CrankNicolson();
      static FdmSchemeDesc ImplicitEuler();
      static FdmSchemeDesc ExplicitEuler();
      static FdmSchemeDesc CraigSneyd();
      static FdmSchemeDesc ModifiedCraigSneyd();
      static FdmSchemeDesc Hundsdorfer();
      static FdmSchemeDesc ModifiedHundsdorfer();
      static FdmSchemeDesc MethodOfLines(Real eps=0.001, Real relInitStepSize=0.01);
      static FdmSchemeDesc TrBDF2();

      // NEW static factories
      static FdmSchemeDesc FittedImplicit();
      // Returns {ImplicitEulerType, 1.0, 0.0, 0, 1}

      static FdmSchemeDesc FittedCrankNicolson();
      // Returns {CrankNicolsonType, 0.5, 0.0, 0, 1}
      // NOTE: This is an EXTENSION beyond the paper. The paper uses Scheme 1
      // (fitted operator) only with fully-implicit time stepping. CN time
      // stepping with the fitted operator may offer improved temporal accuracy
      // but its positivity properties are NOT proven by the paper.

      static FdmSchemeDesc CNVariant(Size monitoringDampingSteps = 0);
      // Returns {CrankNicolsonType, 0.5, 0.0, monitoringDampingSteps, 2}

      static FdmSchemeDesc CrankNicolsonWithDamping(Size monitoringDampingSteps = 2);
      // Returns {CrankNicolsonType, 0.5, 0.0, monitoringDampingSteps, 0}
  };

All EXISTING static factories pass 0,0 for the new parameters (via defaults).
This is fully backward-compatible.

CRITICAL: Do NOT change FdmBackwardSolver class body in this ROUND.


=== FILES 2-3: Modified CrankNicolsonScheme ===

Add Rannacher monitoring-restart capability.

PREREQUISITE VERIFICATION (mandatory; do before coding; do not print):
  Inspect the provided ImplicitEulerScheme header to verify:
  1. ImplicitEulerScheme has a public setStep(Time dt) method.
  2. CrankNicolsonScheme is declared as a friend of ImplicitEulerScheme
     (or the three-argument step(a,t,theta) is accessible).
  3. Calling implicit_->setStep(halfDt) does NOT affect explicit_->dt_.
  If any of these cannot be confirmed, STOP and ask.

Modified constructor:
  CrankNicolsonScheme(
      Real theta,
      const ext::shared_ptr<FdmLinearOpComposite>& map,
      const bc_set& bcSet = bc_set(),
      Real relTol = 1e-8,
      ImplicitEulerScheme::SolverType solverType
          = ImplicitEulerScheme::BiCGstab,
      Size dampingHalfSteps = 0);    // NEW â€” must be even; 0 = no restart

New methods:
  void notifyDiscontinuity();
  // Sets inDampingPhase_ = true, dampingRemaining_ = dampingHalfSteps_
  // If dampingHalfSteps_ == 0, this is a no-op

  bool isDamping() const;

QL_REQUIRE: dampingHalfSteps must be even (0 allowed).

Modified step() method:
  void CrankNicolsonScheme::step(array_type& a, Time t) {
      if (inDampingPhase_ && dampingRemaining_ > 0) {
          // Two implicit Euler half-steps at dt/2
          Time halfDt = dt_ * 0.5;
          implicit_->setStep(halfDt);
          implicit_->step(a, t, 1.0);              // t â†’ tâˆ’dt/2
          implicit_->step(a, t - halfDt, 1.0);     // tâˆ’dt/2 â†’ tâˆ’dt
          implicit_->setStep(dt_);                  // restore
          dampingRemaining_ -= 2;
          if (dampingRemaining_ <= 0) inDampingPhase_ = false;
          return;
      }
      // Standard CN (unchanged):
      if (theta_ != 1.0) explicit_->step(a, t, 1.0 - theta_);
      if (theta_ != 0.0) implicit_->step(a, t, theta_);
  }

Default behavior (dampingHalfSteps=0) must be BIT-IDENTICAL to original.

</implementation_guidance>

<constraints>
- Default behavior must be IDENTICAL to original CrankNicolsonScheme
- notifyDiscontinuity() when dampingHalfSteps_==0 must be a no-op
- Do NOT modify any other scheme files
- Do NOT modify FdmBackwardSolver class in this ROUND
- All existing FdmSchemeDesc factories produce identical behavior
- The 5-parameter constructor replaces (not supplements) the 3-parameter one
- Verify ImplicitEulerScheme::setStep() accessibility from source before coding
</constraints>

<output_specification>
Produce exactly 3 files:
1. fdmbackwardsolver.hpp (FdmSchemeDesc modified, FdmBackwardSolver unchanged)
2. cranknicolsonscheme.hpp (modified)
3. cranknicolsonscheme.cpp (modified â€” complete implementation)
</output_specification>

<quality_checklist>
â–¡ FdmSchemeDesc constructor is 5-param with defaults; old 3-param call sites compile
â–¡ All existing FdmSchemeDesc factories return operatorType=0, monitoringDampingSteps=0
â–¡ New factories produce correct operatorType values
â–¡ FittedCrankNicolson factory includes comment noting it is an extension beyond paper
â–¡ CrankNicolsonScheme with dampingHalfSteps=0 behaves identically to original
â–¡ QL_REQUIRE enforces dampingHalfSteps is even
â–¡ step() during damping performs exactly 2 implicit Euler half-steps per call
â–¡ implicit_->setStep() accessibility verified from source (not assumed)
â–¡ implicit_->setStep restored to dt_ after damping half-steps
â–¡ FdmBackwardSolver class declaration unchanged from input
</quality_checklist>
