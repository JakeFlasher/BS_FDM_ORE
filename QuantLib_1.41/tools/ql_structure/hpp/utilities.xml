<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/utilities/clone.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/utilities/dataparsers.hpp>
#include <ql/utilities/null.hpp>
#include <ql/utilities/null_deleter.hpp>
#include <ql/utilities/observablevalue.hpp>
#include <ql/utilities/steppingiterator.hpp>
#include <ql/utilities/tracing.hpp>
#include <ql/utilities/variants.hpp>
#include <ql/utilities/vectors.hpp>

]]></document_content>
  </document>
  <document index="2">
    <source>clone.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file clone.hpp
    \brief cloning proxy to an underlying object
*/

#ifndef quantlib_clone_hpp
#define quantlib_clone_hpp

#include <ql/errors.hpp>
#include <algorithm>
#include <memory>

namespace QuantLib {

    //! cloning proxy to an underlying object
    /*! When copied, this class will make a clone of its underlying
        object, which must provide a <tt>clone()</tt> method returning
        a std::auto_ptr (or a std::unique_ptr, depending on your
        configuration) to a newly-allocated instance.
    */
    template <class T>
    class Clone {
      public:
        Clone() = default;
        Clone(std::unique_ptr<T>&&);
        Clone(const T&);
        Clone(const Clone<T>&);
        Clone(Clone<T>&&) noexcept;
        Clone<T>& operator=(const T&);
        Clone<T>& operator=(const Clone<T>&);
        Clone<T>& operator=(Clone<T>&&) noexcept;
        T& operator*() const;
        T* operator->() const;
        bool empty() const;
        void swap(Clone<T>& t) noexcept;
        ~Clone() = default;
      private:
        std::unique_ptr<T> ptr_;
    };

    /*! \relates Clone */
    template <class T>
    void swap(Clone<T>&, Clone<T>&) noexcept;


    // inline definitions

    template <class T>
    inline Clone<T>::Clone(std::unique_ptr<T>&& p)
    : ptr_(std::move(p)) {}

    template <class T>
    inline Clone<T>::Clone(const T& t)
    : ptr_(t.clone().release()) {}

    template <class T>
    inline Clone<T>::Clone(const Clone<T>& t)
    : ptr_(t.empty() ? (T*)nullptr : t->clone().release()) {}

    template <class T>
    inline Clone<T>::Clone(Clone<T>&& t) noexcept {
        swap(t);
    }

    template <class T>
    inline Clone<T>& Clone<T>::operator=(const T& t) {
        ptr_ = t.clone();
        return *this;
    }

    template <class T>
    inline Clone<T>& Clone<T>::operator=(const Clone<T>& t) {
        ptr_.reset(t.empty() ? (T*)nullptr : t->clone().release());
        return *this;
    }

    template <class T>
    inline Clone<T>& Clone<T>::operator=(Clone<T>&& t) noexcept {
        swap(t);
        return *this;
    }

    template <class T>
    inline T& Clone<T>::operator*() const {
        QL_REQUIRE(!this->empty(), "no underlying objects");
        return *(this->ptr_);
    }

    template <class T>
    inline T* Clone<T>::operator->() const {
        return this->ptr_.get();
    }

    template <class T>
    inline bool Clone<T>::empty() const {
        return !ptr_;
    }

    template <class T>
    inline void Clone<T>::swap(Clone<T>& t) noexcept {
        this->ptr_.swap(t.ptr_);
    }

    template <class T>
    inline void swap(Clone<T>& t, Clone<T>& u) noexcept {
        t.swap(u);
    }

}


#endif
]]></document_content>
  </document>
  <document index="3">
    <source>dataformatters.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file dataformatters.hpp
    \brief output manipulators
*/

#ifndef quantlib_data_formatters_hpp
#define quantlib_data_formatters_hpp

#include <ql/utilities/null.hpp>
#include <ostream>

namespace QuantLib {

    namespace detail {

        template <typename T> struct null_checker {
            explicit null_checker(T value) : value(value) {}
            T value;
        };
        template <typename T>
        std::ostream& operator<<(std::ostream&, const null_checker<T>&);

        struct ordinal_holder {
            explicit ordinal_holder(Size n) : n(n) {}
            Size n;
        };
        std::ostream& operator<<(std::ostream&, const ordinal_holder&);

        template <typename T> struct power_of_two_holder {
            explicit power_of_two_holder(T n) : n(n) {}
            T n;
        };
        template <typename T>
        std::ostream& operator<<(std::ostream&,
                                 const power_of_two_holder<T>&);

        struct percent_holder {
            explicit percent_holder(Real value) : value(value) {}
            Real value;
        };
        std::ostream& operator<<(std::ostream&, const percent_holder&);

        template <typename InputIterator> struct sequence_holder {
            sequence_holder(InputIterator begin, InputIterator end)
            : begin(begin), end(end) {}
            InputIterator begin, end;
        };
        template <typename I>
        std::ostream& operator<<(std::ostream&, const sequence_holder<I>&);

    }


    namespace io {

        /*! \defgroup manips Output manipulators

            Helper functions for creating formatted output.

            @{
        */

        //! check for nulls before output
        template <typename T>
        detail::null_checker<T> checknull(T);

        //! outputs naturals as 1st, 2nd, 3rd...
        detail::ordinal_holder ordinal(Size);

        //! output integers as powers of two
        template <typename T>
        detail::power_of_two_holder<T> power_of_two(T);

        //! output reals as percentages
        detail::percent_holder percent(Real);

        //! output rates and spreads as percentages
        detail::percent_holder rate(Rate);

        //! output volatilities as percentages
        detail::percent_holder volatility(Volatility);

        //! output STL-compliant containers as space-separated sequences
        template <class Container>
        detail::sequence_holder<typename Container::const_iterator>
        sequence(const Container& c);

        /*! @}  */


        // inline definitions

        template <typename T>
        inline detail::null_checker<T> checknull(T x) {
            return detail::null_checker<T>(x);
        }

        inline detail::ordinal_holder ordinal(Size n) {
            return detail::ordinal_holder(n);
        }

        template <typename T>
        inline detail::power_of_two_holder<T> power_of_two(T n) {
            return detail::power_of_two_holder<T>(n);
        }

        inline detail::percent_holder percent(Real x) {
            return detail::percent_holder(x);
        }

        inline detail::percent_holder rate(Rate r) {
            return detail::percent_holder(r);
        }

        inline detail::percent_holder volatility(Volatility v) {
            return detail::percent_holder(v);
        }

        template <class Container>
        inline detail::sequence_holder<typename Container::const_iterator>
        sequence(const Container& c) {
            return detail::sequence_holder<typename Container::const_iterator>(
                                                           c.begin(), c.end());
        }

    }

    namespace detail {

        template <typename T>
        inline std::ostream& operator<<(std::ostream& out,
                                        const null_checker<T>& checker) {
            if (checker.value == Null<T>())
                return out << "null";
            else
                return out << checker.value;
        }

        template <typename T>
        inline std::ostream& operator<<(std::ostream& out,
                                        const power_of_two_holder<T>& holder) {
            if (holder.n == Null<T>())
                return out << "null";

            T n = holder.n;
            Integer power = 0;
            if (n != 0) {
                while (!(n & 1UL)) {
                    power++;
                    n >>= 1;
                }
            }
            return out << n << "*2^" << power;
        }

        template <typename I>
        inline std::ostream& operator<<(std::ostream& out,
                                        const sequence_holder<I>& holder) {
            out << "( ";
            for (I i = holder.begin; i != holder.end; ++i)
                out << *i << " ";
            out << ")";
            return out;
        }

    }

}


#endif
]]></document_content>
  </document>
  <document index="4">
    <source>dataparsers.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Decillion Pty(Ltd)
 Copyright (C) 2006 Joseph Wang
 Copyright (C) 2009 Mark Joshi
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file dataparsers.hpp
    \brief Classes used to parse data for input
*/

#ifndef quantlib_data_parsers_hpp
#define quantlib_data_parsers_hpp

#include <ql/time/date.hpp>
#include <vector>
#include <string>

namespace QuantLib {

    class PeriodParser {
      public:
        static Period parse(const std::string& str);
      private:
        static Period parseOnePeriod(const std::string& str);
    };

    class DateParser {
      public:
        //! Parses a string in a used-defined format.
        /*! This method uses the parsing functions from
            Boost.Date_Time and supports the same formats.
        */
        static Date parseFormatted(const std::string& str,
                                   const std::string& fmt);
        static Date parseISO(const std::string& str);
    };

}


#endif
]]></document_content>
  </document>
  <document index="5">
    <source>null.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004 StatPro Italia srl
 Copyright (C) 2010 Kakhkhor Abdijalilov

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file null.hpp
    \brief null values
*/

#ifndef quantlib_null_hpp
#define quantlib_null_hpp

#include <ql/types.hpp>
#include <type_traits>
#include <limits>

namespace QuantLib {

    #ifdef QL_NULL_AS_FUNCTIONS

    //! template function providing a null value for a given type.
    template <typename T>
    constexpr T Null() {
        if constexpr (std::is_floating_point_v<T>) {
            // a specific, unlikely value that should fit into any Real
            return (std::numeric_limits<float>::max)();
        } else if constexpr (std::is_integral_v<T>) {
            // this should fit into any Integer
            return (std::numeric_limits<int>::max)();
        } else {
            return T();
        }
    }

    #else

    //! template class providing a null value for a given type.
    template <class Type>
    class Null;

    // default implementation for built-in types
    template <typename T>
    class Null {
      public:
        constexpr Null() = default;
        constexpr operator T() const {
            if constexpr (std::is_floating_point_v<T>) {
                // a specific, unlikely value that should fit into any Real
                return (std::numeric_limits<float>::max)();
            } else if constexpr (std::is_integral_v<T>) {
                // this should fit into any Integer
                return (std::numeric_limits<int>::max)();
            } else {
                return T();
            }
        }
    };

    #endif

}


#endif
]]></document_content>
  </document>
  <document index="6">
    <source>null_deleter.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file null_deleter.hpp
    \brief empty deleter for shared_ptr
*/

#ifndef quantlib_nulldeleter_hpp
#define quantlib_nulldeleter_hpp

#include <ql/qldefines.hpp>

namespace QuantLib {
struct null_deleter {
    template <typename T> void operator()(T *) const noexcept {}
};
}

#endif
]]></document_content>
  </document>
  <document index="7">
    <source>observablevalue.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file observablevalue.hpp
    \brief observable and assignable proxy to concrete value
*/

#ifndef quantlib_observable_value_hpp
#define quantlib_observable_value_hpp

#include <ql/patterns/observable.hpp>

namespace QuantLib {

    //! %observable and assignable proxy to concrete value
    /*! Observers can be registered with instances of this class so
        that they are notified when a different value is assigned to
        such instances. Client code can copy the contained value or
        pass it to functions via implicit conversion.
        \note it is not possible to call non-const method on the
              returned value. This is by design, as this possibility
              would necessarily bypass the notification code; client
              code should modify the value via re-assignment instead.
    */
    template <class T>
    class ObservableValue { // NOLINT(cppcoreguidelines-special-member-functions)
      public:
        ObservableValue();
        ObservableValue(T&&);
        ObservableValue(const T&);
        ObservableValue(const ObservableValue<T>&);
        ~ObservableValue() = default;
        //! \name controlled assignment
        //@{
        ObservableValue<T>& operator=(T&&);
        ObservableValue<T>& operator=(const T&);
        ObservableValue<T>& operator=(const ObservableValue<T>&);
        //@}
        //! implicit conversion
        operator T() const;
        operator ext::shared_ptr<Observable>() const;
        //! explicit inspector
        const T& value() const;
      private:
        T value_;
        ext::shared_ptr<Observable> observable_;
    };


    // template definition

    template <class T>
    ObservableValue<T>::ObservableValue()
    : value_(), observable_(new Observable) {}

    template <class T>
    ObservableValue<T>::ObservableValue(T&& t)
    : value_(std::move(t)), observable_(new Observable) {}

    template <class T>
    ObservableValue<T>::ObservableValue(const T& t)
    : value_(t), observable_(new Observable) {}

    template <class T>
    ObservableValue<T>::ObservableValue(const ObservableValue<T>& t)
    : value_(t.value_), observable_(new Observable) {}

    template <class T>
    ObservableValue<T>& ObservableValue<T>::operator=(T&& t) {
        value_ = std::move(t);
        observable_->notifyObservers();
        return *this;
    }

    template <class T>
    ObservableValue<T>& ObservableValue<T>::operator=(const T& t) {
        value_ = t;
        observable_->notifyObservers();
        return *this;
    }

    template <class T>
    ObservableValue<T>&
    ObservableValue<T>::operator=(const ObservableValue<T>& t) { // NOLINT(bugprone-unhandled-self-assignment)
        value_ = t.value_;
        observable_->notifyObservers();
        return *this;
    }

    template <class T>
    ObservableValue<T>::operator T() const {
        return value_;
    }

    template <class T>
    ObservableValue<T>::operator ext::shared_ptr<Observable>() const {
        return observable_;
    }

    template <class T>
    const T& ObservableValue<T>::value() const {
        return value_;
    }

}

#endif
]]></document_content>
  </document>
  <document index="8">
    <source>steppingiterator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file steppingiterator.hpp
    \brief Iterator advancing in constant steps
*/

#ifndef quantlib_stepping_iterator_hpp
#define quantlib_stepping_iterator_hpp

#include <ql/errors.hpp>
#include <ql/types.hpp>
#include <iterator>
#include <type_traits>

namespace QuantLib {

    //! Iterator advancing in constant steps
    /*! This iterator advances an underlying random-access iterator in
        steps of \f$ n \f$ positions, where \f$ n \f$ is a positive
        integer given upon construction.
    */
#ifdef __cpp_concepts
    template <std::random_access_iterator Iterator>
#else
    template <class Iterator>
#endif
    class step_iterator {  // NOLINT(cppcoreguidelines-special-member-functions)
      private:
        Iterator base_{};
        // a Size would mess up integer division in distance_to
        BigInteger step_{};

      public:
        using iterator_category = typename std::iterator_traits<Iterator>::iterator_category;
        using difference_type = typename std::iterator_traits<Iterator>::difference_type;
        using value_type = typename std::iterator_traits<Iterator>::value_type;
        using pointer = typename std::iterator_traits<Iterator>::pointer;
        using reference = typename std::iterator_traits<Iterator>::reference;

        step_iterator() = default;
        step_iterator(const step_iterator& other) = default;

        explicit step_iterator(const Iterator& base, Size step)
        : base_(base), step_(static_cast<BigInteger>(step)) {}

        template <class OtherIterator>
        step_iterator(const step_iterator<OtherIterator>& i,
                      std::enable_if_t<std::is_convertible_v
                      <OtherIterator, Iterator>>* = nullptr)
        : base_(i.base_), step_(static_cast<BigInteger>(i.step())) {}

        Size step() const { return static_cast<Size>(this->step_); }

        step_iterator& operator=(const step_iterator& other) = default;

        step_iterator& operator++() {
            base_ += step_;
            return *this;
        }

        step_iterator operator++(int) {
            auto tmp = *this;
            base_ += step_;
            return tmp;
        }

        reference operator*() const {
            return *base_;
        }

        step_iterator& operator--() {
            base_ -= step_;
            return *this;
        }

        step_iterator operator--(int) {
            auto tmp = *this;
            base_ -= step_;
            return tmp;
        }

        step_iterator& operator+=(Size n) {
            base_ += n * step_;
            return *this;
        }

        step_iterator& operator-=(Size n) {
            base_ -= n * step_;
            return *this;
        }

        reference operator[](Size n) const {
            return *(base_ + n * step_);
        }

        friend step_iterator operator+(const step_iterator& i, Size n) {
            return step_iterator(i.base_ + n * i.step_, i.step_);
        }

        friend step_iterator operator+(Size n, const step_iterator& i) {
            return step_iterator(i.base_ + n * i.step_, i.step_);
        }

        friend step_iterator operator-(const step_iterator& i, Size n) {
            return step_iterator(i.base_ - n * i.step_, i.step_);
        }

        friend difference_type operator-(const step_iterator& lhs, const step_iterator& rhs) {
#ifdef QL_EXTRA_SAFETY_CHECKS
            QL_REQUIRE(lhs.step_ == rhs.step_, "step_iterators with different step cannot be added or subtracted");
#endif
            return (lhs.base_ - rhs.base_) / lhs.step_;
        }

        friend bool operator==(const step_iterator& lhs, const step_iterator& rhs) {
            return lhs.base_ == rhs.base_ && lhs.step_ == rhs.step_;
        }

        friend bool operator!=(const step_iterator& lhs, const step_iterator& rhs) {
            return lhs.base_ != rhs.base_ || lhs.step_ != rhs.step_;
        }

        friend bool operator<(const step_iterator& lhs, const step_iterator& rhs) {
#ifdef QL_EXTRA_SAFETY_CHECKS
            QL_REQUIRE(lhs.step_ == rhs.step_, "step_iterators with different step cannot be compared");
#endif
            return lhs.base_ < rhs.base_;
        }

        friend bool operator>(const step_iterator& lhs, const step_iterator& rhs) {
#ifdef QL_EXTRA_SAFETY_CHECKS
            QL_REQUIRE(lhs.step_ == rhs.step_, "step_iterators with different step cannot be compared");
#endif
            return lhs.base_ > rhs.base_;
        }

        friend bool operator<=(const step_iterator& lhs, const step_iterator& rhs) {
#ifdef QL_EXTRA_SAFETY_CHECKS
            QL_REQUIRE(lhs.step_ == rhs.step_, "step_iterators with different step cannot be compared");
#endif
            return lhs.base_ <= rhs.base_;
        }

        friend bool operator>=(const step_iterator& lhs, const step_iterator& rhs) {
#ifdef QL_EXTRA_SAFETY_CHECKS
            QL_REQUIRE(lhs.step_ == rhs.step_, "step_iterators with different step cannot be compared");
#endif
            return lhs.base_ >= rhs.base_;
        }
    };

    //! helper function to create step iterators
    /*! \relates step_iterator */
    template <class Iterator>
    step_iterator<Iterator> make_step_iterator(Iterator it, Size step) {
        return step_iterator<Iterator>(it,step);
    }

}


#endif
]]></document_content>
  </document>
  <document index="9">
    <source>tracing.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file tracing.hpp
    \brief tracing facilities
*/

#ifndef quantlib_tracing_hpp
#define quantlib_tracing_hpp

#include <ql/types.hpp>
#include <ql/errors.hpp>
#include <ql/patterns/singleton.hpp>
#include <boost/current_function.hpp>
#include <iosfwd>

namespace QuantLib::detail {

        class Tracing : public Singleton<Tracing> {
            friend class QuantLib::Singleton<Tracing>;
          private:
            Tracing();  // NOLINT(modernize-use-equals-delete)
          public:
            void enable() {
                #if defined(QL_ENABLE_TRACING)
                enabled_ = true;
                #else
                QL_FAIL("tracing support not available");
                #endif
            }
            void disable() { enabled_ = false; }
            void setStream(std::ostream& stream) { out_ = &stream; }
            bool enabled() const { return enabled_; }
            std::ostream& stream() { return *out_; }
            Integer depth() const { return depth_; }
            void down() { depth_++; }
            void up() { depth_--; }
          private:
            std::ostream* out_;
            bool enabled_ = false;
            Integer depth_ = 0;
        };

    }

/*! \addtogroup macros
    @{
*/

/*! \defgroup debugMacros Debugging macros

    For debugging purposes, macros can be used to output information
    about the code being executed.  Instrumenting code as in:
    \code
    namespace Foo {

        int bar(int i) {
            QL_TRACE_ENTER_FUNCTION;
            QL_TRACE_VARIABLE(i);

            if (i == 42) {
                QL_TRACE_LOCATION;
                QL_TRACE("Right answer, but no question");
            } else {
                QL_TRACE_LOCATION;
                QL_TRACE("Wrong answer");
                i *= 2;
            }

            QL_TRACE_VARIABLE(i);
            QL_TRACE_EXIT_FUNCTION;
            return i;
        }

    }
    \endcode
    will output a trace like the following when the code is run:
    \code
    trace[3]: Entering int Foo::bar(int)
    trace[3]: i = 21
    trace[3]: At line 16 in tracing_example.cpp
    trace[3]: Wrong answer
    trace[3]: i = 42
    trace[3]: Exiting int Foo::bar(int)
    \endcode
    (the actual output will depend on the compiler and the file
    names).  A word of warning must be added: adding so much tracing
    to your code might degrade its readability.

    @{
*/

/*! \def QL_TRACE_ENABLE
    \brief enable tracing

    The statement
    \code
    QL_TRACE_ENABLE;
    \endcode
    can be used to enable tracing. Such statement might be
    ignored; refer to QL_TRACE for details.
*/

/*! \def QL_TRACE_DISABLE
    \brief disable tracing

    The statement
    \code
    QL_TRACE_DISABLE;
    \endcode
    can be used to disable tracing. Such statement might be
    ignored; refer to QL_TRACE for details.
*/

/*! \def QL_TRACE_ON
    \brief set tracing stream

    The statement
    \code
    QL_TRACE_ON(stream);
    \endcode
    can be used to set the stream where tracing messages are
    output. Such statement might be ignored; refer to QL_TRACE for
    details.
*/

/*! \def QL_TRACE
    \brief output tracing information

    The statement
    \code
    QL_TRACE(message);
    \endcode
    can be used to output a trace of the code being executed. If
    tracing was disabled during configuration, such statements are
    removed by the preprocessor for maximum performance; if it was
    enabled, whether and where the message is output depends on the
    current settings.
*/

/*! \def QL_TRACE_ENTER_FUNCTION
    \brief output tracing information

    The statement
    \code
    QL_TRACE_ENTER_FUNCTION;
    \endcode
    can be used at the beginning of a function to trace the fact that
    the program execution is entering such function. It should be
    paired with a corresponding QL_TRACE_EXIT_FUNCTION macro. Such
    statement might be ignored; refer to QL_TRACE for details. Also,
    function information might not be available depending on the
    compiler.
*/

/*! \def QL_TRACE_EXIT_FUNCTION
    \brief output tracing information

    The statement
    \code
    QL_TRACE_EXIT_FUNCTION;
    \endcode
    can be used before returning from a function to trace the fact
    that the program execution is exiting such function. It should be
    paired with a corresponding QL_TRACE_ENTER_FUNCTION macro. Such
    statement might be ignored; refer to QL_TRACE for details. Also,
    function information might not be available depending on the
    compiler.
*/

/*! \def QL_TRACE_LOCATION
    \brief output tracing information

    The statement
    \code
    QL_TRACE_LOCATION;
    \endcode
    can be used to trace the current file and line. Such statement
    might be ignored; refer to QL_TRACE for details.
*/

/*! \def QL_TRACE_VARIABLE
    \brief output tracing information

    The statement
    \code
    QL_TRACE_VARIABLE(variable);
    \endcode
    can be used to trace the current value of a variable. Such
    statement might be ignored; refer to QL_TRACE for details. Also,
    the variable type must allow sending it to an output stream.
*/

/*! @} */

/*! @} */

#if defined(QL_ENABLE_TRACING)

#define QL_DEFAULT_TRACER   QuantLib::detail::Tracing::instance()

#define QL_TRACE_ENABLE \
QL_DEFAULT_TRACER.enable()

#define QL_TRACE_DISABLE \
QL_DEFAULT_TRACER.disable()

#define QL_TRACE_ON(out) \
QL_DEFAULT_TRACER.setStream(out)

#define QL_TRACE(message) \
if (QL_DEFAULT_TRACER.enabled()) \
    try { \
        QL_DEFAULT_TRACER.stream() << "trace[" << QL_DEFAULT_TRACER.depth() \
                                   << "]: " << message << std::endl; \
    } catch (...) {} \
else

#define QL_TRACE_ENTER_FUNCTION \
if (QL_DEFAULT_TRACER.enabled()) \
    try { \
        QL_DEFAULT_TRACER.down(); \
        QL_DEFAULT_TRACER.stream() << "trace[" << QL_DEFAULT_TRACER.depth() \
                                   << "]: " \
                                   << "Entering " << BOOST_CURRENT_FUNCTION \
                                   << std::endl; \
    } catch (...) {} \
else

#define QL_TRACE_EXIT_FUNCTION \
if (QL_DEFAULT_TRACER.enabled()) \
    try { \
        QL_DEFAULT_TRACER.stream() << "trace[" << QL_DEFAULT_TRACER.depth() \
                                   << "]: " \
                                   << "Exiting " << BOOST_CURRENT_FUNCTION \
                                   << std::endl; \
        QL_DEFAULT_TRACER.up(); \
    } catch (...) { QL_DEFAULT_TRACER.up(); } \
else

#define QL_TRACE_LOCATION \
QL_TRACE("At line " << __LINE__ << " in " << __FILE__)

#define QL_TRACE_VARIABLE(variable) \
QL_TRACE(#variable << " = " << variable)

#else

#define QL_DEFAULT_TRACER
#define QL_TRACE_ENABLE
#define QL_TRACE_DISABLE
#define QL_TRACE_ON(out)
#define QL_TRACE(message)
#define QL_TRACE_ENTER_FUNCTION
#define QL_TRACE_EXIT_FUNCTION
#define QL_TRACE_LOCATION
#define QL_TRACE_VARIABLE(variable)

#endif

#endif
]]></document_content>
  </document>
  <document index="10">
    <source>variants.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

#ifndef quantlib_utilities_variants_hpp
#define quantlib_utilities_variants_hpp

namespace QuantLib::detail {

    // Helper type for use with std::visit.
    template <class... Ts>
    struct variant_visitor : Ts... {
        using Ts::operator()...;
    };

    template <class... Ts>
    variant_visitor(Ts...) -> variant_visitor<Ts...>;

}

#endif
]]></document_content>
  </document>
  <document index="11">
    <source>vectors.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vectors.hpp
    \brief Utilities for vector manipulation
*/

#ifndef quantlib_utilities_vectors_hpp
#define quantlib_utilities_vectors_hpp

#include <ql/types.hpp>
#include <vector>

namespace QuantLib::detail {

        template <class T, class U>
        T get(const std::vector<T>& v,
              Size i,
              U defaultValue) {
            if (v.empty()) {
                return static_cast<T>(defaultValue);
            } else if (i < v.size()) {
                return v[i];
            } else {
                return v.back();
            }
        }

    }


#endif
]]></document_content>
  </document>
</documents>