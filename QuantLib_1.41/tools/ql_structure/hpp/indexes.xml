<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/indexes/bmaindex.hpp>
#include <ql/indexes/equityindex.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/indexes/indexmanager.hpp>
#include <ql/indexes/inflationindex.hpp>
#include <ql/indexes/interestrateindex.hpp>
#include <ql/indexes/region.hpp>
#include <ql/indexes/swapindex.hpp>

#include <ql/indexes/ibor/all.hpp>
#include <ql/indexes/inflation/all.hpp>
#include <ql/indexes/swap/all.hpp>
]]></document_content>
  </document>
  <document index="2">
    <source>bmaindex.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bmaindex.hpp
    \brief Bond Market Association index
*/

#ifndef quantlib_bma_index_hpp
#define quantlib_bma_index_hpp

#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/indexes/interestrateindex.hpp>
#include <ql/time/schedule.hpp>

namespace QuantLib {

    //! Bond Market Association index
    /*! The BMA index is the short-term tax-exempt reference index of
        the Bond Market Association.  It has tenor one week, is fixed
        weekly on Wednesdays and is applied with a one-day's fixing
        gap from Thursdays on for one week.  It is the tax-exempt
        correspondent of the 1M USD-Libor.
    */
    class BMAIndex : public InterestRateIndex {
      public:
        explicit BMAIndex(Handle<YieldTermStructure> h = {});
        //! \name Index interface
        //@{
        /*! BMA is fixed weekly on Wednesdays.
        */
        bool isValidFixingDate(const Date& fixingDate) const override;
        //@}
        //! \name Inspectors
        //@{
        Handle<YieldTermStructure> forwardingTermStructure() const;
        //@}
        //! \name Date calculations
        //@{
        Date maturityDate(const Date& valueDate) const override;
        /*! This method returns a schedule of fixing dates between
            start and end.
        */
        Schedule fixingSchedule(const Date& start,
                                const Date& end);
        // @}
      protected:
        Rate forecastFixing(const Date& fixingDate) const override;
        Handle<YieldTermStructure> termStructure_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="3">
    <source>equityindex.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2023 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file equityindex.hpp
    \brief base class for equity indexes
*/

#ifndef quantlib_equityindex_hpp
#define quantlib_equityindex_hpp

#include <ql/index.hpp>
#include <ql/time/calendar.hpp>
#include <ql/currency.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>

namespace QuantLib {

    //! Base class for equity indexes
    /*! The equity index object allows to retrieve past fixings,
        as well as project future fixings using either both
        the risk free interest rate term structure and the dividend
        term structure, or just the interest rate term structure
        in which case one can provide a term structure of equity
        forwards implied from, e.g. option prices.
        
        In case of the first method, the forward is calculated as:
        \f[
        I(t, T) = I(t, t) \frac{P_{D}(t, T)}{P_{R}(t, T)},
        \f]
        where \f$ I(t, t) \f$ is today's value of the index,
        \f$ P_{D}(t, T) \f$ is a discount factor of the dividend
        curve at future time \f$ T \f$, and \f$ P_{R}(t, T) \f$ is
        a discount factor of the risk free curve at future time
        \f$ T \f$.

        In case of the latter method, the forward is calculated as:
        \f[
        I(t, T) = I(t, t) \frac{1}{P_{F}(t, T)},
        \f]
        where \f$ P_{F}(t, T) \f$ is a discount factor of the equity
        forward term structure.

        To forecast future fixings, the user can either provide a
        handle to the current index spot. If spot handle is empty,
        today's fixing will be used, instead.
    */
    class EquityIndex : public Index {
      public:
        EquityIndex(std::string name,
                    Calendar fixingCalendar,
                    Currency currency,
                    Handle<YieldTermStructure> interest = {},
                    Handle<YieldTermStructure> dividend = {},
                    Handle<Quote> spot = {});

        //! \name Index interface
        //@{
        std::string name() const override { return name_; }
        Calendar fixingCalendar() const override { return fixingCalendar_; }
        bool isValidFixingDate(const Date& fixingDate) const override;
        Real fixing(const Date& fixingDate, bool forecastTodaysFixing = false) const override;
        //@}
        //! \name Inspectors
        //@{
        //! The index currency
        Currency currency() const { return currency_; }
        //! the rate curve used to forecast fixings
        Handle<YieldTermStructure> equityInterestRateCurve() const { return interest_; }
        //! the dividend curve used to forecast fixings
        Handle<YieldTermStructure> equityDividendCurve() const { return dividend_; }
        //! index spot value
        Handle<Quote> spot() const { return spot_; }
        //@}
        //! \name Fixing calculations
        //@{
        //! It can be overridden to implement particular conventions
        virtual Real forecastFixing(const Date& fixingDate) const;
        // @}
        //! \name Other methods
        //@{
        //! returns a copy of itself linked to different interest, dividend curves
        //! or spot quote
        virtual ext::shared_ptr<EquityIndex> clone(const Handle<YieldTermStructure>& interest,
                                                   const Handle<YieldTermStructure>& dividend,
                                                   const Handle<Quote>& spot) const;
        // @}
      private:
        std::string name_;
        Calendar fixingCalendar_;
        Currency currency_;
        Handle<YieldTermStructure> interest_;
        Handle<YieldTermStructure> dividend_;
        Handle<Quote> spot_;
    };

    inline bool EquityIndex::isValidFixingDate(const Date& d) const {
        return fixingCalendar().isBusinessDay(d);
    }
}

#endif
]]></document_content>
  </document>
  <document index="4">
    <source>ibor/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/indexes/ibor/aonia.hpp>
#include <ql/indexes/ibor/audlibor.hpp>
#include <ql/indexes/ibor/bbsw.hpp>
#include <ql/indexes/ibor/bibor.hpp>
#include <ql/indexes/ibor/bkbm.hpp>
#include <ql/indexes/ibor/cadlibor.hpp>
#include <ql/indexes/ibor/cdi.hpp>
#include <ql/indexes/ibor/cdor.hpp>
#include <ql/indexes/ibor/chflibor.hpp>
#include <ql/indexes/ibor/corra.hpp>
#include <ql/indexes/ibor/custom.hpp>
#include <ql/indexes/ibor/destr.hpp>
#include <ql/indexes/ibor/dkklibor.hpp>
#include <ql/indexes/ibor/eonia.hpp>
#include <ql/indexes/ibor/estr.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/indexes/ibor/eurlibor.hpp>
#include <ql/indexes/ibor/fedfunds.hpp>
#include <ql/indexes/ibor/gbplibor.hpp>
#include <ql/indexes/ibor/jibar.hpp>
#include <ql/indexes/ibor/jpylibor.hpp>
#include <ql/indexes/ibor/kofr.hpp>
#include <ql/indexes/ibor/libor.hpp>
#include <ql/indexes/ibor/mosprime.hpp>
#include <ql/indexes/ibor/nzdlibor.hpp>
#include <ql/indexes/ibor/nzocr.hpp>
#include <ql/indexes/ibor/pribor.hpp>
#include <ql/indexes/ibor/robor.hpp>
#include <ql/indexes/ibor/saron.hpp>
#include <ql/indexes/ibor/seklibor.hpp>
#include <ql/indexes/ibor/shibor.hpp>
#include <ql/indexes/ibor/sofr.hpp>
#include <ql/indexes/ibor/sonia.hpp>
#include <ql/indexes/ibor/swestr.hpp>
#include <ql/indexes/ibor/tibor.hpp>
#include <ql/indexes/ibor/tonar.hpp>
#include <ql/indexes/ibor/thbfix.hpp>
#include <ql/indexes/ibor/trlibor.hpp>
#include <ql/indexes/ibor/usdlibor.hpp>
#include <ql/indexes/ibor/wibor.hpp>
#include <ql/indexes/ibor/zibor.hpp>

]]></document_content>
  </document>
  <document index="5">
    <source>ibor/aonia.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2016 Fabrice Lecuyer

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file aonia.hpp
\brief %Aonia index
*/

#ifndef quantlib_aonia_hpp
#define quantlib_aonia_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/australia.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/oceania.hpp>

namespace QuantLib {

    //! %Aonia index
    /*! Aonia (Australia Overnight Index Average) rate fixed by the RBA.

    See <http://www.isda.org/publications/pdf/Supplement-13-to-2000DefinitionsAnnex.pdf>.
    */
    class Aonia : public OvernightIndex {
      public:
        explicit Aonia(const Handle<YieldTermStructure>& h = {})
        : OvernightIndex("Aonia", 0, AUDCurrency(),
                         Australia(),
                         Actual365Fixed(), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="6">
    <source>ibor/audlibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file audlibor.hpp
    \brief %AUD %LIBOR rate
*/

#ifndef quantlib_aud_libor_hpp
#define quantlib_aud_libor_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/australia.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/oceania.hpp>

namespace QuantLib {

    //! %AUD %LIBOR rate
    /*! Australian Dollar LIBOR discontinued as of 2013.
    */
    class AUDLibor : public Libor {
      public:
        AUDLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h = {})
        : Libor("AUDLibor", tenor,
                2,
                AUDCurrency(),
                Australia(),
                Actual360(), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="7">
    <source>ibor/bbsw.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2016 Fabrice Lecuyer

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bbsw.hpp
    \brief %Bbsw index
*/

#ifndef quantlib_bbsw_hpp
#define quantlib_bbsw_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/australia.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/oceania.hpp>

namespace QuantLib {

    //! %Bbsw index
    /*! Bbsw rate fixed by AFMA.

        See <http://www.afma.com.au/data/BBSW>.
    */
    class Bbsw : public IborIndex {
      public:
        Bbsw(const Period& tenor,
             const Handle<YieldTermStructure>& h = {})
        : IborIndex("Bbsw", tenor,
                    0, // settlement days
                    AUDCurrency(), Australia(),
                    HalfMonthModifiedFollowing, true,
                    Actual365Fixed(), h) {
            QL_REQUIRE(this->tenor().units() != Days,
                       "for daily tenors (" << this->tenor() <<
                       ") dedicated DailyTenor constructor must be used");
        }
    };

    //! 1-month %Bbsw index
    class Bbsw1M : public Bbsw {
      public:
        explicit Bbsw1M(const Handle<YieldTermStructure>& h = {})
        : Bbsw(Period(1, Months), h) {}
    };

    //! 2-months %Bbsw index
    class Bbsw2M : public Bbsw {
      public:
        explicit Bbsw2M(const Handle<YieldTermStructure>& h = {})
        : Bbsw(Period(2, Months), h) {}
    };

    //! 3-months %Bbsw index
    class Bbsw3M : public Bbsw {
      public:
        explicit Bbsw3M(const Handle<YieldTermStructure>& h = {})
        : Bbsw(Period(3, Months), h) {}
    };

    //! 4-months %Bbsw index
    class Bbsw4M : public Bbsw {
      public:
        explicit Bbsw4M(const Handle<YieldTermStructure>& h = {})
        : Bbsw(Period(4, Months), h) {}
    };

    //! 5-months %Bbsw index
    class Bbsw5M : public Bbsw {
      public:
        explicit Bbsw5M(const Handle<YieldTermStructure>& h = {})
        : Bbsw(Period(5, Months), h) {}
    };

    //! 6-months %Bbsw index
    class Bbsw6M : public Bbsw {
      public:
        explicit Bbsw6M(const Handle<YieldTermStructure>& h = {})
        : Bbsw(Period(6, Months), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="8">
    <source>ibor/bibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Matthias Groncki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bibor.hpp
    \brief %Bangkok Interbank Offered Rate index
*/

#ifndef quantlib_bibor_hpp
#define quantlib_bibor_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! %Bibor index
    /*! Bangkok Interbank Offered Rate  fixed by the Bank of Thailand BOT.
    */
    class Bibor : public IborIndex {
      public:
        Bibor(const Period& tenor,
              const Handle<YieldTermStructure>& h = {});
    };


    //! 1-week %Bibor index
    class BiborSW : public Bibor {
      public:
        explicit BiborSW(const Handle<YieldTermStructure>& h = {})
        : Bibor(Period(1, Weeks), h) {}
    };


    //! 1-month %Bibor index
    class Bibor1M : public Bibor {
      public:
        explicit Bibor1M(const Handle<YieldTermStructure>& h = {})
        : Bibor(Period(1, Months), h) {}
    };

    //! 2-months %Bibor index
    class Bibor2M : public Bibor {
      public:
        explicit Bibor2M(const Handle<YieldTermStructure>& h = {})
        : Bibor(Period(2, Months), h) {}
    };

    //! 3-months %Bibor index
    class Bibor3M : public Bibor {
      public:
        explicit Bibor3M(const Handle<YieldTermStructure>& h = {})
        : Bibor(Period(3, Months), h) {}
    };

    //! 6-months %Bibor index
    class Bibor6M : public Bibor {
      public:
        explicit Bibor6M(const Handle<YieldTermStructure>& h = {})
        : Bibor(Period(6, Months), h) {}
    };

    //! 1-year %Bibor index
    class Bibor1Y : public Bibor {
      public:
        explicit Bibor1Y(const Handle<YieldTermStructure>& h = {})
        : Bibor(Period(1, Years), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="9">
    <source>ibor/bkbm.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2016 Fabrice Lecuyer

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bkbm.hpp
\brief %Bkbm index
*/

#ifndef quantlib_bkbm_hpp
#define quantlib_bkbm_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/newzealand.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/oceania.hpp>

namespace QuantLib {

    //! %Bkbm index
    /*! Bkbm rate fixed by NZFMA.

        See <http://www.nzfma.org/Site/data/default.aspx>.
    */
    class Bkbm : public IborIndex {
      public:
        Bkbm(const Period& tenor,
             const Handle<YieldTermStructure>& h = {})
        : IborIndex("Bkbm", tenor,
                    0, // settlement days
                    NZDCurrency(), NewZealand(),
                    ModifiedFollowing, true,
                    Actual365Fixed(), h) {
            QL_REQUIRE(this->tenor().units() != Days,
                       "for daily tenors (" << this->tenor() <<
                       ") dedicated DailyTenor constructor must be used");
        }
    };

    //! 1-month %Bkbm index
    class Bkbm1M : public Bkbm {
      public:
        explicit Bkbm1M(const Handle<YieldTermStructure>& h = {})
        : Bkbm(Period(1, Months), h) {}
    };

    //! 2-months %Bkbm index
    class Bkbm2M : public Bkbm {
      public:
        explicit Bkbm2M(const Handle<YieldTermStructure>& h = {})
        : Bkbm(Period(2, Months), h) {}
    };

    //! 3-months %Bkbm index
    class Bkbm3M : public Bkbm {
      public:
        explicit Bkbm3M(const Handle<YieldTermStructure>& h = {})
        : Bkbm(Period(3, Months), h) {}
    };

    //! 4-months %Bkbm index
    class Bkbm4M : public Bkbm {
      public:
        explicit Bkbm4M(const Handle<YieldTermStructure>& h = {})
        : Bkbm(Period(4, Months), h) {}
    };

    //! 5-months %Bkbm index
    class Bkbm5M : public Bkbm {
      public:
        explicit Bkbm5M(const Handle<YieldTermStructure>& h = {})
        : Bkbm(Period(5, Months), h) {}
    };

    //! 6-months %Bkbm index
    class Bkbm6M : public Bkbm {
      public:
        explicit Bkbm6M(const Handle<YieldTermStructure>& h = {})
        : Bkbm(Period(6, Months), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="10">
    <source>ibor/cadlibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cadlibor.hpp
    \brief %CAD %LIBOR rate
*/

#ifndef quantlib_cad_libor_hpp
#define quantlib_cad_libor_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/canada.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/america.hpp>

namespace QuantLib {

    //! %CAD LIBOR rate
    /*! Canadian Dollar LIBOR discontinued as of 2013.

        Conventions are taken from a number of sources including
        OpenGamma "Interest Rate Instruments and Market Conventions
        Guide", BBG, IKON.

        \warning This is the rate fixed in London by BBA. Use CDOR if
                 you're interested in the Canadian fixing by IDA.
    */
    class CADLibor : public Libor {
      public:
        CADLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h = {})
        : Libor("CADLibor", tenor,
                0,
                CADCurrency(),
                Canada(),
                Actual365Fixed(), h) {}
    };

    //! Overnight %CAD %Libor index
    class CADLiborON : public DailyTenorLibor {
      public:
        explicit CADLiborON(const Handle<YieldTermStructure>& h = {})
        : DailyTenorLibor("CADLibor",
                          0,
                          CADCurrency(),
                          Canada(),
                          Actual365Fixed(), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="11">
    <source>ibor/cdi.hpp</source>
    <document_content><![CDATA[/*
 Copyright (C) 2025 Sotirios Papathanasopoulos
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/
 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.
 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_cdi_hpp
#define quantlib_cdi_hpp

#include <ql/currencies/america.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/brazil.hpp>
#include <ql/time/daycounters/business252.hpp>

namespace QuantLib {

    //! BRL-CDI Index: relevant for https://en.wikipedia.org/wiki/Brazilian_Swap

    class Cdi : public OvernightIndex {
      public:
        explicit Cdi(const Handle<YieldTermStructure>& h = {})
        : OvernightIndex("CDI", 0, BRLCurrency(), Brazil(Brazil::Settlement), Business252(), h) {}

        Rate forecastFixing(const Date& fixingDate) const override;

    };

} 

#endif]]></document_content>
  </document>
  <document index="12">
    <source>ibor/cdor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cdor.hpp
    \brief %CDOR rate
*/

#ifndef quantlib_cdor_hpp
#define quantlib_cdor_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/canada.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/america.hpp>

namespace QuantLib {

    //! %CDOR rate
    /*! Canadian Dollar Offered Rate fixed by IDA.

        Conventions are taken from a number of sources including
        OpenGamma "Interest Rate Instruments and Market Conventions
        Guide", BBG, IKON.

        \warning This is the rate fixed in Canada by IDA. Use CADLibor
                 if you're interested in the London fixing by BBA.
    */
    class Cdor : public IborIndex {
      public:
        Cdor(const Period& tenor,
             const Handle<YieldTermStructure>& h = {})
        : IborIndex("CDOR", tenor, 0, CADCurrency(),
                    Canada(), ModifiedFollowing, false,
                    Actual365Fixed(), h) {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="13">
    <source>ibor/chflibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file chflibor.hpp
    \brief %CHF %LIBOR rate
*/

#ifndef quantlib_chf_libor_hpp
#define quantlib_chf_libor_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/switzerland.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    //! %CHF %LIBOR rate
    /*! Swiss Franc LIBOR fixed by ICE.

        See <https://www.theice.com/marketdata/reports/170>.

        \warning This is the rate fixed in London by BBA. Use ZIBOR if
                 you're interested in the Zurich fixing.
    */
    class CHFLibor : public Libor {
      public:
        CHFLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h = {})
        : Libor("CHFLibor", tenor,
                2,
                CHFCurrency(),
                Switzerland(),
                Actual360(), h) {}
    };

    //! base class for the one day deposit BBA %CHF %LIBOR indexes
    class DailyTenorCHFLibor : public DailyTenorLibor {
      public:
        DailyTenorCHFLibor(Natural settlementDays,
                           const Handle<YieldTermStructure>& h = {})
        : DailyTenorLibor("CHFLibor", settlementDays,
                          CHFCurrency(),
                          Switzerland(),
                          Actual360(), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="14">
    <source>ibor/corra.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2023 Aditya Narayan Das

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_corra_hpp
#define quantlib_corra_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {
    class Corra : public OvernightIndex {
      public:
        explicit Corra(const Handle<YieldTermStructure>& h = {});
    };
}


#endif
]]></document_content>
  </document>
  <document index="15">
    <source>ibor/custom.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

#ifndef quantlib_custom_ibor_hpp
#define quantlib_custom_ibor_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    /*! LIBOR-like index that allows specifying custom calendars for value
        and maturity dates calculations:

        * valueDate() advances on the valueCalendar and adjusts on the
         maturityCalendar.

        * maturityDate() advances on the maturityCalendar.

        * fixingDate() goes back on the valueCalendar.

        Typical LIBOR indexes use:

        * fixingCalendar = valueCalendar = UK, maturityCalendar =
        JoinHolidays(UK, CurrencyCalendar) for non-EUR currencies.

        * fixingCalendar = JoinHolidays(UK, TARGET), valueCalendar =
        maturityCalendar = TARGET for EUR.
    */
    class CustomIborIndex : public IborIndex {
      public:
        CustomIborIndex(const std::string& familyName,
                        const Period& tenor,
                        Natural settlementDays,
                        const Currency& currency,
                        const Calendar& fixingCalendar,
                        Calendar  valueCalendar,
                        Calendar  maturityCalendar,
                        BusinessDayConvention convention,
                        bool endOfMonth,
                        const DayCounter& dayCounter,
                        const Handle<YieldTermStructure>& h = {});
        //! \name InterestRateIndex interface
        //@{
        Date fixingDate(const Date& valueDate) const override;
        Date valueDate(const Date& fixingDate) const override;
        Date maturityDate(const Date& valueDate) const override;
        // @}
        //! \name IborIndex interface
        //@{
        ext::shared_ptr<IborIndex> clone(const Handle<YieldTermStructure>& h) const override;
        // @}
        //! \name Other inspectors
        //@{
        Calendar valueCalendar() const { return valueCalendar_; }
        Calendar maturityCalendar() const { return maturityCalendar_; }
        // @}
      private:
        Calendar valueCalendar_;
        Calendar maturityCalendar_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="16">
    <source>ibor/destr.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2023 Skandinaviska Enskilda Banken AB (publ)

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file destr.hpp
    \brief %DESTR index
*/

#ifndef quantlib_destr_hpp
#define quantlib_destr_hpp

#include <ql/currencies/europe.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/denmark.hpp>
#include <ql/time/daycounters/actual360.hpp>

namespace QuantLib {

    //! %Destr (Denmark Short-Term Rate) index.
    class Destr : public OvernightIndex {
      public:
        explicit Destr(const Handle<YieldTermStructure>& h = {})
        : OvernightIndex("DESTR", 0, DKKCurrency(), Denmark(), Actual360(), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="17">
    <source>ibor/dkklibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file dkklibor.hpp
    \brief %DKK %LIBOR rate
*/

#ifndef quantlib_dkk_libor_hpp
#define quantlib_dkk_libor_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/denmark.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    //! %DKK %LIBOR rate
    /*! Danish Krona LIBOR discontinued as of 2013.
    */
    class DKKLibor : public Libor {
      public:
        DKKLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h = {})
        : Libor("DKKLibor", tenor,
                2,
                DKKCurrency(),
                Denmark(),
                Actual360(), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="18">
    <source>ibor/eonia.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file eonia.hpp
    \brief %Eonia index
*/

#ifndef quantlib_eonia_hpp
#define quantlib_eonia_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! %Eonia (Euro Overnight Index Average) rate fixed by the ECB.
    class Eonia : public OvernightIndex {
      public:
        explicit Eonia(const Handle<YieldTermStructure>& h = {});
    };

}

#endif
]]></document_content>
  </document>
  <document index="19">
    <source>ibor/estr.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Magnus Mencke

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file estr.hpp
    \brief %ESTR index
*/

#ifndef quantlib_estr_hpp
#define quantlib_estr_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! %ESTR (Euro Short-Term Rate) rate fixed by the ECB.
    class Estr : public OvernightIndex {
      public:
        explicit Estr(const Handle<YieldTermStructure>& h = {});
    };

}

#endif
]]></document_content>
  </document>
  <document index="20">
    <source>ibor/euribor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl
 Copyright (C) 2006 Katiuscia Manzoni
 Copyright (C) 2006 Chiara Fornarola
 Copyright (C) 2009 Roland Lichters
 Copyright (C) 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file euribor.hpp
    \brief %Euribor index
*/

#ifndef quantlib_euribor_hpp
#define quantlib_euribor_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! %Euribor index
    /*! Euribor rate fixed by the ECB.

        \warning This is the rate fixed by the ECB. Use EurLibor
                 if you're interested in the London fixing by BBA.
    */
    class Euribor : public IborIndex {
      public:
        Euribor(const Period& tenor,
                const Handle<YieldTermStructure>& h = {});
    };

    //! Actual/365 %Euribor index
    /*! Euribor rate adjusted for the mismatch between the actual/360
        convention used for Euribor and the actual/365 convention
        previously used by a few pre-EUR currencies.
    */
    class Euribor365 : public IborIndex {
      public:
        Euribor365(const Period& tenor,
                   const Handle<YieldTermStructure>& h = {});
    };

    //! 1-week %Euribor index
    class Euribor1W : public Euribor {
      public:
        explicit Euribor1W(const Handle<YieldTermStructure>& h = {})
        : Euribor(Period(1, Weeks), h) {}
    };

    //! 1-month %Euribor index
    class Euribor1M : public Euribor {
      public:
        explicit Euribor1M(const Handle<YieldTermStructure>& h = {})
        : Euribor(Period(1, Months), h) {}
    };

    //! 3-months %Euribor index
    class Euribor3M : public Euribor {
      public:
        explicit Euribor3M(const Handle<YieldTermStructure>& h = {})
        : Euribor(Period(3, Months), h) {}
    };

    //! 6-months %Euribor index
    class Euribor6M : public Euribor {
      public:
        explicit Euribor6M(const Handle<YieldTermStructure>& h = {})
        : Euribor(Period(6, Months), h) {}
    };

    //! 1-year %Euribor index
    class Euribor1Y : public Euribor {
      public:
        explicit Euribor1Y(const Handle<YieldTermStructure>& h = {})
        : Euribor(Period(1, Years), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="21">
    <source>ibor/eurlibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2006, 2007 Chiara Fornarola
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file eurlibor.hpp
    \brief %EUR %LIBOR rate
*/

#ifndef quantlib_eur_libor_hpp
#define quantlib_eur_libor_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! base class for all ICE %EUR %LIBOR indexes but the O/N
    /*! Euro LIBOR fixed by ICE.

        See <https://www.theice.com/marketdata/reports/170>.

        \warning This is the rate fixed in London by BBA. Use Euribor if
                 you're interested in the fixing by the ECB.
    */
    class EURLibor : public IborIndex {
      public:
        EURLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h = {});
        /*! \name Date calculations

            See <https://www.theice.com/marketdata/reports/170>.
            @{
        */
        Date fixingDate(const Date& valueDate) const override;
        Date valueDate(const Date& fixingDate) const override;
        Date maturityDate(const Date& valueDate) const override;
        // @}
        //! \name IborIndex interface
        //@{
        ext::shared_ptr<IborIndex> clone(const Handle<YieldTermStructure>& h) const override;
        // @}
      private:
        Calendar target_;
    };

    //! base class for the one day deposit ICE %EUR %LIBOR indexes
    /*! Euro O/N LIBOR fixed by ICE. It can be also used for T/N and S/N
        indexes, even if such indexes do not have ICE fixing.

        See <https://www.theice.com/marketdata/reports/170>.

        \warning This is the rate fixed in London by ICE. Use Eonia if
                 you're interested in the fixing by the ECB.
    */
    class DailyTenorEURLibor : public IborIndex {
      public:
        DailyTenorEURLibor(Natural settlementDays,
                           const Handle<YieldTermStructure>& h = {});
    };

    //! Overnight %EUR %Libor index
    class EURLiborON : public DailyTenorEURLibor {
      public:
        explicit EURLiborON(const Handle<YieldTermStructure>& h = {})
        : DailyTenorEURLibor(0, h) {}
    };

    //! 1-month %EUR %Libor index
    class EURLibor1M : public EURLibor {
      public:
        explicit EURLibor1M(const Handle<YieldTermStructure>& h = {})
        : EURLibor(Period(1, Months), h) {}
    };

    //! 3-months %EUR %Libor index
    class EURLibor3M : public EURLibor {
      public:
        explicit EURLibor3M(const Handle<YieldTermStructure>& h = {})
        : EURLibor(Period(3, Months), h) {}
    };

    //! 6-months %EUR %Libor index
    class EURLibor6M : public EURLibor {
      public:
        explicit EURLibor6M(const Handle<YieldTermStructure>& h = {})
        : EURLibor(Period(6, Months), h) {}
    };

    //! 1-year %EUR %Libor index
    class EURLibor1Y : public EURLibor {
      public:
        explicit EURLibor1Y(const Handle<YieldTermStructure>& h = {})
        : EURLibor(Period(1, Years), h) {}
    };


}

#endif
]]></document_content>
  </document>
  <document index="22">
    <source>ibor/fedfunds.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fedfunds.hpp
    \brief %FedFunds index
*/

#ifndef quantlib_fed_funds_hpp
#define quantlib_fed_funds_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! %Fed Funds rate fixed by the FED.
    /*! (for balances held at the Federal Reserve) */
    class FedFunds : public OvernightIndex {
      public:
        explicit FedFunds(const Handle<YieldTermStructure>& h = {});
    };

}


#endif
]]></document_content>
  </document>
  <document index="23">
    <source>ibor/gbplibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gbplibor.hpp
    \brief %GBP %LIBOR rate
*/

#ifndef quantlib_gbp_libor_hpp
#define quantlib_gbp_libor_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/unitedkingdom.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    //! %GBP %LIBOR rate
    /*! Pound Sterling LIBOR fixed by ICE.

        See <https://www.theice.com/marketdata/reports/170>.
    */
    class GBPLibor : public Libor {
      public:
        GBPLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h = {})
        : Libor("GBPLibor", tenor,
                0,
                GBPCurrency(),
                UnitedKingdom(UnitedKingdom::Exchange),
                Actual365Fixed(), h) {}
    };

    //! Base class for the one day deposit ICE %GBP %LIBOR indexes
    class DailyTenorGBPLibor : public DailyTenorLibor {
      public:
        DailyTenorGBPLibor(Natural settlementDays,
                           const Handle<YieldTermStructure>& h = {})
        : DailyTenorLibor("GBPLibor", settlementDays,
                          GBPCurrency(),
                          UnitedKingdom(UnitedKingdom::Exchange),
                          Actual365Fixed(), h) {}
    };

    //! Overnight %GBP %Libor index
    class GBPLiborON : public DailyTenorGBPLibor {
      public:
        explicit GBPLiborON(const Handle<YieldTermStructure>& h = {})
        : DailyTenorGBPLibor(0, h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="24">
    <source>ibor/jibar.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005 StatPro Italia srl

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file jibar.hpp
    \brief %JIBAR rate
*/

#ifndef quantlib_jibar_hpp
#define quantlib_jibar_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/southafrica.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/africa.hpp>

namespace QuantLib {

    //! %JIBAR rate
    /*! Johannesburg Interbank Agreed Rate

        \todo check settlement days and day-count convention.
    */
    class Jibar : public IborIndex {
      public:
        Jibar(const Period& tenor,
              const Handle<YieldTermStructure>& h = {})
        : IborIndex("Jibar", tenor, 0, ZARCurrency(),
                SouthAfrica(), ModifiedFollowing, false,
                Actual365Fixed(), h) {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="25">
    <source>ibor/jpylibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file jpylibor.hpp
    \brief %JPY %LIBOR rate
*/

#ifndef quantlib_jpy_libor_hpp
#define quantlib_jpy_libor_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/unitedkingdom.hpp>
#include <ql/time/calendars/japan.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/asia.hpp>

namespace QuantLib {

    //! %JPY %LIBOR rate
    /*! Japanese Yen LIBOR fixed by ICE.

        See <https://www.theice.com/marketdata/reports/170>.

        \warning This is the rate fixed in London by ICE. Use TIBOR if
                 you're interested in the Tokio fixing.
    */
    class JPYLibor : public Libor {
      public:
        JPYLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h = {})
        : Libor("JPYLibor", tenor,
                2,
                JPYCurrency(),
                Japan(),
                Actual360(), h) {}
    };

    //! base class for the one day deposit ICE %JPY %LIBOR indexes
    class DailyTenorJPYLibor : public DailyTenorLibor {
      public:
        DailyTenorJPYLibor(Natural settlementDays,
                           const Handle<YieldTermStructure>& h = {})
        : DailyTenorLibor("JPYLibor", settlementDays,
                          JPYCurrency(),
                          Japan(),
                          Actual360(), h) {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="26">
    <source>ibor/kofr.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2024 Jongbong An

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file kofr.hpp
    \brief %KOFR index
*/

#ifndef quantlib_kofr_hpp
#define quantlib_kofr_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! %KOFR index.
    /*! Korea Overnight Financing Repo Rate (KOFR) published by Korea Securities Depository (KSD)
    Please refer to
    (1) https://www.bok.or.kr/eng/main/contents.do?menuNo=400399 (Overview)
    (2) https://www.kofr.kr/main.jsp (Detailed information)
    */
   class Kofr : public OvernightIndex {
      public:
        explicit Kofr(const Handle<YieldTermStructure>& h = {});
    };
    
}

#endif
]]></document_content>
  </document>
  <document index="27">
    <source>ibor/libor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Chiara Fornarola
 Copyright (C) 2005, 2006, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file libor.hpp
    \brief base class for BBA LIBOR indexes
*/

#ifndef quantlib_libor_hpp
#define quantlib_libor_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! base class for all ICE LIBOR indexes but the EUR, O/N, and S/N ones
    /*! LIBOR fixed by ICE.

        See <https://www.theice.com/marketdata/reports/170>.
    */
    class Libor : public IborIndex {
      public:
        Libor(const std::string& familyName,
              const Period& tenor,
              Natural settlementDays,
              const Currency& currency,
              const Calendar& financialCenterCalendar,
              const DayCounter& dayCounter,
              const Handle<YieldTermStructure>& h = {});
        /*! \name Date calculations

            See <https://www.theice.com/marketdata/reports/170>.
            @{
        */
        Date valueDate(const Date& fixingDate) const override;
        Date maturityDate(const Date& valueDate) const override;
        // @}
        //! \name Other methods
        //@{
        ext::shared_ptr<IborIndex> clone(const Handle<YieldTermStructure>& h) const override;
        // @}
        //! \name Other inspectors
        //@{
        Calendar jointCalendar() const;
        // @}
      private:
        Calendar financialCenterCalendar_;
        Calendar jointCalendar_;
    };

    //! base class for all O/N-S/N BBA LIBOR indexes but the EUR ones
    /*! One day deposit LIBOR fixed by ICE.

        See <https://www.theice.com/marketdata/reports/170>.
    */
    class DailyTenorLibor : public IborIndex {
      public:
        DailyTenorLibor(const std::string& familyName,
                        Natural settlementDays,
                        const Currency& currency,
                        const Calendar& financialCenterCalendar,
                        const DayCounter& dayCounter,
                        const Handle<YieldTermStructure>& h = {});
    };

}

#endif
]]></document_content>
  </document>
  <document index="28">
    <source>ibor/mosprime.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2018 Matthias Lungwitz

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mosprime.hpp
\brief %MOSPRIME rate
*/

#ifndef quantlib_mosprime_hpp
#define quantlib_mosprime_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/russia.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

	//! %MOSPRIME rate
	/*! Moscow Prime Offered Rate fixed by NFEA.

	Conventions are taken from
	http://www.mosprime.com/uploads/files/MosPrime%20Rate%20Rules%20since%2030.01.2014.docx

	\warning Roll convention and EoM not yet checked.
	*/
	class Mosprime : public IborIndex {
	public:
		Mosprime(const Period& tenor,
                 const Handle<YieldTermStructure>& h = {})
			: IborIndex("MOSPRIME", tenor, (tenor == 1 * Days ? 0 : 1), RUBCurrency(),
				Russia(), ModifiedFollowing, false,
				ActualActual(ActualActual::ISDA), h) {}
	};

}


#endif
]]></document_content>
  </document>
  <document index="29">
    <source>ibor/nzdlibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file nzdlibor.hpp
    \brief %NZD %LIBOR rate
*/

#ifndef quantlib_nzd_libor_hpp
#define quantlib_nzd_libor_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/newzealand.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/oceania.hpp>

namespace QuantLib {

    //! %NZD %LIBOR rate
    /*! New Zealand Dollar LIBOR discontinued as of 2013.
    */
    class NZDLibor : public Libor {
      public:
        NZDLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h = {})
        : Libor("NZDLibor", tenor,
                2,
                NZDCurrency(),
                NewZealand(),
                Actual360(), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="30">
    <source>ibor/nzocr.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2016 Fabrice Lecuyer

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file nzocr.hpp
\brief %NZOCR index
*/

#ifndef quantlib_nzocr_hpp
#define quantlib_nzocr_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/newzealand.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/oceania.hpp>

namespace QuantLib {

    //! %Nzocr index
    /*! %Nzocr (New Zealand official cash rate) rate fixed by the RBNZ.

        See <http://www.rbnz.govt.nz/monetary-policy/official-cash-rate-decisions>.
    */
    class Nzocr : public OvernightIndex {
      public:
        explicit Nzocr(const Handle<YieldTermStructure>& h = {})
        : OvernightIndex("Nzocr", 0, NZDCurrency(),
                         NewZealand(),
                         Actual365Fixed(), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="31">
    <source>ibor/pribor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2018 Matthias Lungwitz

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file pribor.hpp
\brief %PRIBOR rate
*/

#ifndef quantlib_pribor_hpp
#define quantlib_pribor_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/czechrepublic.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

	//! %PRIBOR rate
	/*! Prague Interbank Offered Rate fixed by CFBF.

	Conventions are taken from
	OpenGamma "Interest Rate Instruments and Market Conventions
	Guide" as well as
	https://cfbf.cz/wp-content/uploads/2018/02/pribor-rules.pdf

	\warning Roll convention and EoM not yet checked.
	*/
	class Pribor : public IborIndex {
	public:
		Pribor(const Period& tenor,
               const Handle<YieldTermStructure>& h = {})
			: IborIndex("PRIBOR", tenor, (tenor == 1 * Days ? 0 : 2), CZKCurrency(),
				CzechRepublic(), ModifiedFollowing, false,
				Actual360(), h) {}
	};

}


#endif
]]></document_content>
  </document>
  <document index="32">
    <source>ibor/robor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2018 Matthias Lungwitz

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file robor.hpp
\brief %ROBOR rate
*/

#ifndef quantlib_robor_hpp
#define quantlib_robor_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/romania.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

	//! %ROBOR rate
	/*! Romanian Interbank Offered Rate fixed by BNR.

	Conventions are taken from
	http://www.bnr.ro/files/d/Legislatie/En/RRR.pdf

	\warning Roll convention and EoM not yet checked.
	*/
	class Robor : public IborIndex {
	public:
		Robor(const Period& tenor,
              const Handle<YieldTermStructure>& h = {})
			: IborIndex("ROBOR", tenor, (tenor == 1 * Days ? 0 : 2), RONCurrency(),
				Romania(), ModifiedFollowing, false,
				Actual360(), h) {}
	};

}


#endif
]]></document_content>
  </document>
  <document index="33">
    <source>ibor/saron.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2025 Paolo D'Elia

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file saron.hpp
    \brief %SARON index
*/

#ifndef quantlib_saron_hpp
#define quantlib_saron_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! %SARON (Swiss Average Rate Overnight) index.
    class Saron : public OvernightIndex {
      public:
        explicit Saron(const Handle<YieldTermStructure>& h = {});
    };

}

#endif
]]></document_content>
  </document>
  <document index="34">
    <source>ibor/seklibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file seklibor.hpp
    \brief %SEK %LIBOR rate
*/

#ifndef quantlib_sek_libor_hpp
#define quantlib_sek_libor_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/sweden.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    //! %SEK %LIBOR rate
    /*! Sweden Krone LIBOR discontinued as of 2013.
    */
    class SEKLibor : public Libor {
      public:
        SEKLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h = {})
        : Libor("SEKLibor", tenor,
                2,
                SEKCurrency(),
                Sweden(),
                Actual360(), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="35">
    <source>ibor/shibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Cheng Li

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file shibor.hpp
    \brief China Shibor indexes
*/

#ifndef quantlib_shibor_hpp
#define quantlib_shibor_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    class Shibor : public IborIndex {
      public:
        Shibor(
            const Period& tenor,
            const Handle<YieldTermStructure>& h = {});

        ext::shared_ptr<IborIndex>
        clone(const Handle<YieldTermStructure>& forwarding) const override;
    };

}


#endif
]]></document_content>
  </document>
  <document index="36">
    <source>ibor/sofr.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Roy Zywina

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file sofr.hpp
    \brief %SOFR index
*/

#ifndef quantlib_sofr_hpp
#define quantlib_sofr_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! %Sofr (Secured Overnight Financing Rate) index.
    class Sofr : public OvernightIndex {
      public:
        explicit Sofr(const Handle<YieldTermStructure>& h = {});
    };

}

#endif
]]></document_content>
  </document>
  <document index="37">
    <source>ibor/sonia.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file sonia.hpp
    \brief %Sonia index
*/

#ifndef quantlib_sonia_hpp
#define quantlib_sonia_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! %Sonia (Sterling Overnight Index Average) rate.
    class Sonia : public OvernightIndex {
      public:
        explicit Sonia(const Handle<YieldTermStructure>& h = {});
    };

}

#endif
]]></document_content>
  </document>
  <document index="38">
    <source>ibor/swestr.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2023 Skandinaviska Enskilda Banken AB (publ)

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file swestr.hpp
    \brief %SWESTR index
*/

#ifndef quantlib_swestr_hpp
#define quantlib_swestr_hpp

#include <ql/currencies/europe.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/sweden.hpp>
#include <ql/time/daycounters/actual360.hpp>

namespace QuantLib {

    //! %Swestr (Swedish krona Short Term Rate) index.
    class Swestr : public OvernightIndex {
      public:
        explicit Swestr(const Handle<YieldTermStructure>& h = {})
        : OvernightIndex("SWESTR", 0, SEKCurrency(), Sweden(), Actual360(), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="39">
    <source>ibor/thbfix.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Matthias Groncki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file thbfix.hpp
    \brief %THB %THBFIX rate
*/

#ifndef quantlib_thbfix_hpp
#define quantlib_thbfix_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/thailand.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/asia.hpp>

namespace QuantLib {

    //! %THB %THBFIX rate
    /*! THBFIX

    THB interest rate implied by USD/THB foreign exchange swaps

    The Swap Offer Rate represents the cost of
    borrowing a currency synthetically by borrowing USD
    for the same tenor and using the foreign exchange swap
    offer rate on the offer side to swap out the USD in return
    for the foreign currency.

    Fixing is based on average FX Forward rates from 21 banks
    and the USD Libor Fixing.

    Fixing is published at 11:00 am BKK time
    */
    class THBFIX : public IborIndex {
      public:
        THBFIX(const Period& tenor,
               const Handle<YieldTermStructure>& h = {})
        : IborIndex("THBFIX", tenor,
                    2,
                    THBCurrency(),
                    Thailand(),
                    ModifiedFollowing, true,
                    Actual365Fixed(), h) {}
    };
}

#endif
]]></document_content>
  </document>
  <document index="40">
    <source>ibor/tibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file tibor.hpp
    \brief %JPY %TIBOR rate
*/

#ifndef quantlib_tibor_hpp
#define quantlib_tibor_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/japan.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/asia.hpp>

namespace QuantLib {

    //! %JPY %TIBOR index
    /*! Tokyo Interbank Offered Rate.

        \warning This is the rate fixed in Tokio by JBA. Use JPYLibor
                 if you're interested in the London fixing by BBA.

        \todo check settlement days and end-of-month adjustment.
    */
    class Tibor : public IborIndex {
      public:
        Tibor(const Period& tenor,
              const Handle<YieldTermStructure>& h = {})
        : IborIndex("Tibor", tenor, 2, JPYCurrency(),
                    Japan(), ModifiedFollowing,
                    false, Actual365Fixed(), h) {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="41">
    <source>ibor/tona.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2022 Jonghee Lee

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_tona_hpp
#define quantlib_tona_hpp

// Deprecated in version 1.38
#pragma message("Warning: this file will disappear in a future release; include <ql/indexes/ibor/tonar.hpp> instead.")

#include <ql/indexes/ibor/tonar.hpp>

#endif
]]></document_content>
  </document>
  <document index="42">
    <source>ibor/tonar.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2022 Jonghee Lee

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file tonar.hpp
\brief %TONAR index
*/

#ifndef quantlib_tonar_hpp
#define quantlib_tonar_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/japan.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/asia.hpp>

namespace QuantLib {

    //! %TONAR index
    /*! TONAR (Tokyo Overnight Average Rate) fixed by the BOJ.

        See <https://www3.boj.or.jp/market/en/menu_m.htm>.
    */
    class Tonar : public OvernightIndex {
      public:
        explicit Tonar(const Handle<YieldTermStructure>& h = {})
        : OvernightIndex("Tonar", 0, JPYCurrency(),
                         Japan(),
                         Actual365Fixed(), h) {}
    };

    /*! \deprecated Renamed to Tonar.
                    Deprecated in version 1.40.
    */
    [[deprecated("Renamed to Tonar")]] typedef Tonar Tona;

}

#endif
]]></document_content>
  </document>
  <document index="43">
    <source>ibor/trlibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Sercan Atalik

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file trlibor.hpp
    \brief %TRY %LIBOR rate
*/

#ifndef quantlib_try_libor_hpp
#define quantlib_try_libor_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/turkey.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    //! %TRY %LIBOR rate
    /*! TRY LIBOR fixed by TBA.

        See <http://www.trlibor.org/trlibor/english/>

        \todo check end-of-month adjustment.
    */
    class TRLibor : public IborIndex {
      public:
        TRLibor(const Period& tenor,
                const Handle<YieldTermStructure>& h = {})
        : IborIndex("TRLibor", tenor, 0, TRYCurrency(),
                    Turkey(), ModifiedFollowing, false,
                    Actual360(), h) {}
    };

}


#endif

]]></document_content>
  </document>
  <document index="44">
    <source>ibor/usdlibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl
 Copyright (C) 2017 Peter Caspers
 Copyright (C) 2017 Oleg Kulkov

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file usdlibor.hpp
    \brief %USD %LIBOR rate
*/

#ifndef quantlib_usd_libor_hpp
#define quantlib_usd_libor_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/unitedstates.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/america.hpp>

namespace QuantLib {

    //! %USD %LIBOR rate
    /*! US Dollar LIBOR fixed by ICE.

        See <https://www.theice.com/marketdata/reports/170>.
    */
    class USDLibor : public Libor {
      public:
        USDLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h = {})
        : Libor("USDLibor", tenor,
                2,
                USDCurrency(),
                UnitedStates(UnitedStates::LiborImpact),
                Actual360(), h) {}
    };

    //! base class for the one day deposit ICE %USD %LIBOR indexes
    class DailyTenorUSDLibor : public DailyTenorLibor {
      public:
        DailyTenorUSDLibor(Natural settlementDays,
                           const Handle<YieldTermStructure>& h = {})
        : DailyTenorLibor("USDLibor", settlementDays,
                          USDCurrency(),
                          UnitedStates(UnitedStates::LiborImpact),
                          Actual360(), h) {}
    };

    //! Overnight %USD %Libor index
    class USDLiborON : public DailyTenorUSDLibor {
      public:
        explicit USDLiborON(const Handle<YieldTermStructure>& h = {})
        : DailyTenorUSDLibor(0, h) {}
    };
}

#endif
]]></document_content>
  </document>
  <document index="45">
    <source>ibor/wibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2018 Matthias Lungwitz

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file wibor.hpp
\brief %WIBOR rate
*/

#ifndef quantlib_wibor_hpp
#define quantlib_wibor_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/poland.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

	//! %WIBOR rate
	/*! Warsaw Interbank Offered Rate fixed by ACI.

	Conventions are taken from
	http://www.acipolska.pl/images/stories/Rules_for_Fixing_WIBID_and_WIBOR_Reference_Rates_EN.pdf

	\warning Roll convention and EoM not yet checked.
	*/
	class Wibor : public IborIndex {
	public:
		Wibor(const Period& tenor,
              const Handle<YieldTermStructure>& h = {})
			: IborIndex("WIBOR", tenor, (tenor == 1 * Days ? 0 : 2), PLNCurrency(),
				Poland(Poland::Settlement), ModifiedFollowing, false,
				Actual365Fixed(), h) {}
	};

}


#endif
]]></document_content>
  </document>
  <document index="46">
    <source>ibor/zibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file zibor.hpp
    \brief %CHF %ZIBOR rate
*/

#ifndef quantlib_zibor_hpp
#define quantlib_zibor_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/switzerland.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    //! %CHF %ZIBOR rate
    /*! Zurich Interbank Offered Rate.

        \warning This is the rate fixed in Zurich by BBA. Use CHFLibor if
                 you're interested in the London fixing by BBA.

        \todo check settlement days, end-of-month adjustment,
              and day-count convention.
    */
    class Zibor : public IborIndex {
      public:
        Zibor(const Period& tenor,
              const Handle<YieldTermStructure>& h = {})
        : IborIndex("Zibor", tenor, 2, CHFCurrency(),
                Switzerland(), ModifiedFollowing, false,
                Actual360(), h) {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="47">
    <source>iborindex.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009 StatPro Italia srl
 Copyright (C) 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file iborindex.hpp
    \brief base class for Inter-Bank-Offered-Rate indexes
*/

#ifndef quantlib_ibor_index_hpp
#define quantlib_ibor_index_hpp

#include <ql/indexes/interestrateindex.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>

namespace QuantLib {

    //! base class for Inter-Bank-Offered-Rate indexes (e.g. %Libor, etc.)
    class IborIndex : public InterestRateIndex {
      public:
        IborIndex(const std::string& familyName,
                  const Period& tenor,
                  Natural settlementDays,
                  const Currency& currency,
                  const Calendar& fixingCalendar,
                  BusinessDayConvention convention,
                  bool endOfMonth,
                  const DayCounter& dayCounter,
                  Handle<YieldTermStructure> h = {});
        //! \name InterestRateIndex interface
        //@{
        Date maturityDate(const Date& valueDate) const override;
        Rate forecastFixing(const Date& fixingDate) const override;
        // @}
        //! \name Inspectors
        //@{
        BusinessDayConvention businessDayConvention() const;
        bool endOfMonth() const { return endOfMonth_; }
        //! the curve used to forecast fixings
        Handle<YieldTermStructure> forwardingTermStructure() const;
        //@}
        //! \name Other methods
        //@{
        //! returns a copy of itself linked to a different forwarding curve
        virtual ext::shared_ptr<IborIndex> clone(
                        const Handle<YieldTermStructure>& forwarding) const;
        // @}
      protected:
        BusinessDayConvention convention_;
        Handle<YieldTermStructure> termStructure_;
        bool endOfMonth_;
      private:
        // overload to avoid date/time (re)calculation
        /* This can be called with cached coupon dates (and it does
           give quite a performance boost to coupon calculations) but
           is potentially misleading: by passing the wrong dates, one
           can ask a 6-months index for a 1-year fixing.

           For that reason, we're leaving this method private and
           we're declaring the IborCoupon class (which uses it) as a
           friend.  Should the need arise, we might promote it to
           public, but before doing that I'd think hard whether we
           have any other way to get the same results.
        */
        Rate forecastFixing(const Date& valueDate,
                            const Date& endDate,
                            Time t) const;
        friend class IborCoupon;
    };


    class OvernightIndex : public IborIndex {
      public:
        OvernightIndex(const std::string& familyName,
                       Natural settlementDays,
                       const Currency& currency,
                       const Calendar& fixingCalendar,
                       const DayCounter& dayCounter,
                       const Handle<YieldTermStructure>& h = {});
        //! returns a copy of itself linked to a different forwarding curve
        ext::shared_ptr<IborIndex> clone(const Handle<YieldTermStructure>& h) const override;
    };


    // inline

    inline BusinessDayConvention IborIndex::businessDayConvention() const {
        return convention_;
    }

    inline Handle<YieldTermStructure>
    IborIndex::forwardingTermStructure() const {
        return termStructure_;
    }

    inline Rate IborIndex::forecastFixing(const Date& d1,
                                          const Date& d2,
                                          Time t) const {
        QL_REQUIRE(!termStructure_.empty(),
                   "null term structure set to this instance of " << name());
        DiscountFactor disc1 = termStructure_->discount(d1);
        DiscountFactor disc2 = termStructure_->discount(d2);
        return (disc1/disc2 - 1.0) / t;
    }

}

#endif
]]></document_content>
  </document>
  <document index="48">
    <source>indexmanager.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file indexmanager.hpp
    \brief global repository for past index fixings
*/

#ifndef quantlib_index_manager_hpp
#define quantlib_index_manager_hpp

#include <ql/patterns/singleton.hpp>
#include <ql/timeseries.hpp>
#include <ql/math/comparison.hpp>
#include <ql/utilities/observablevalue.hpp>
#include <algorithm>
#include <cctype>

namespace QuantLib {

    //! global repository for past index fixings
    /*! \note index names are case insensitive */
    class IndexManager : public Singleton<IndexManager> {
        friend class Singleton<IndexManager>;
        friend class Index;

      private:
        IndexManager() = default;

      public:
        //! returns all names of the indexes for which fixings were stored
        std::vector<std::string> histories() const;
        //! clears all stored fixings
        void clearHistories();

      private:
        struct CaseInsensitiveCompare {
          bool operator()(const std::string& s1, const std::string& s2) const {
            return std::lexicographical_compare(s1.begin(), s1.end(), s2.begin(), s2.end(), [](const auto& c1, const auto& c2) {
              return std::toupper(static_cast<unsigned char>(c1)) < std::toupper(static_cast<unsigned char>(c2));
            });
          }
        };

        mutable std::map<std::string, TimeSeries<Real>, CaseInsensitiveCompare> data_;
        mutable std::map<std::string, ext::shared_ptr<Observable>> notifiers_;

        //! add a fixing
        void addFixing(const std::string& name,
                       const Date& fixingDate,
                       Real fixing,
                       bool forceOverwrite = false);
        //! add fixings
        template <class DateIterator, class ValueIterator>
        void addFixings(const std::string& name,
                        DateIterator dBegin,
                        DateIterator dEnd,
                        ValueIterator vBegin,
                        bool forceOverwrite = false,
                        const std::function<bool(const Date& d)>& isValidFixingDate = {}) {
            auto& h = data_[name];
            bool noInvalidFixing = true, noDuplicatedFixing = true;
            Date invalidDate, duplicatedDate;
            Real nullValue = Null<Real>();
            Real invalidValue = Null<Real>();
            Real duplicatedValue = Null<Real>();
            while (dBegin != dEnd) {
                bool validFixing = isValidFixingDate ? isValidFixingDate(*dBegin) : true;
                Real currentValue = h[*dBegin];
                bool missingFixing = forceOverwrite || currentValue == nullValue;
                if (validFixing) {
                    if (missingFixing)
                        h[*(dBegin++)] = *(vBegin++);
                    else if (close(currentValue, *(vBegin))) {
                        ++dBegin;
                        ++vBegin;
                    } else {
                        noDuplicatedFixing = false;
                        duplicatedDate = *(dBegin++);
                        duplicatedValue = *(vBegin++);
                    }
                } else {
                    noInvalidFixing = false;
                    invalidDate = *(dBegin++);
                    invalidValue = *(vBegin++);
                }
            }
            QL_DEPRECATED_DISABLE_WARNING
            notifier(name)->notifyObservers();
            QL_DEPRECATED_ENABLE_WARNING
            QL_REQUIRE(noInvalidFixing, "At least one invalid fixing provided: "
                                            << invalidDate.weekday() << " " << invalidDate << ", "
                                            << invalidValue);
            QL_REQUIRE(noDuplicatedFixing, "At least one duplicated fixing provided: "
                                               << duplicatedDate << ", " << duplicatedValue
                                               << " while " << h[duplicatedDate]
                                               << " value is already present");
        }

        bool hasHistory(const std::string& name) const;
        const TimeSeries<Real>& getHistory(const std::string& name) const;
        void clearHistory(const std::string& name);
        bool hasHistoricalFixing(const std::string& name, const Date& fixingDate) const;
        void setHistory(const std::string& name, TimeSeries<Real> history);
        ext::shared_ptr<Observable> notifier(const std::string& name) const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="49">
    <source>inflation/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/indexes/inflation/aucpi.hpp>
#include <ql/indexes/inflation/euhicp.hpp>
#include <ql/indexes/inflation/frhicp.hpp>
#include <ql/indexes/inflation/ukhicp.hpp>
#include <ql/indexes/inflation/ukrpi.hpp>
#include <ql/indexes/inflation/uscpi.hpp>
#include <ql/indexes/inflation/zacpi.hpp>

]]></document_content>
  </document>
  <document index="50">
    <source>inflation/aucpi.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon
 Copyright (C) 2021 Ralf Konrad Eckel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file aucpi.hpp
    \brief Australian CPI inflation indexes
*/

#ifndef quantlib_aucpi_hpp
#define quantlib_aucpi_hpp

#include <ql/currencies/oceania.hpp>
#include <ql/indexes/inflationindex.hpp>

namespace QuantLib {

    //! AU CPI index (either quarterly or annual)
    class AUCPI : public ZeroInflationIndex {
      public:
        AUCPI(Frequency frequency,
              bool revised,
              const Handle<ZeroInflationTermStructure>& ts = {})
        : ZeroInflationIndex(
              "CPI", AustraliaRegion(), revised, frequency, Period(2, Months), AUDCurrency(), ts) {}
    };


    //! Quoted year-on-year AU CPI (i.e. not a ratio)
    class YYAUCPI : public YoYInflationIndex {
      public:
        YYAUCPI(Frequency frequency,
                bool revised,
                const Handle<YoYInflationTermStructure>& ts = {})
        : YoYInflationIndex("YY_CPI",
                            AustraliaRegion(),
                            revised,
                            frequency,
                            Period(2, Months),
                            AUDCurrency(),
                            ts) {}

        QL_DEPRECATED_DISABLE_WARNING

        /*! \deprecated Use the overload without the interpolated parameter.
                        Deprecated in version 1.38.
        */
        [[deprecated("Use the overload without the interpolated parameter")]]
        YYAUCPI(Frequency frequency,
                bool revised,
                bool interpolated,
                const Handle<YoYInflationTermStructure>& ts = {})
        : YoYInflationIndex("YY_CPI",
                            AustraliaRegion(),
                            revised,
                            interpolated,
                            frequency,
                            Period(2, Months),
                            AUDCurrency(),
                            ts) {}

        QL_DEPRECATED_ENABLE_WARNING
    };

}

#endif
]]></document_content>
  </document>
  <document index="51">
    <source>inflation/euhicp.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 Chris Kenyon
 Copyright (C) 2010 StatPro Italia srl
 Copyright (C) 2021 Ralf Konrad Eckel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file euhicp.hpp
    \brief EU HICP index
*/

#ifndef quantlib_euhicp_hpp
#define quantlib_euhicp_hpp

#include <ql/currencies/europe.hpp>
#include <ql/indexes/inflationindex.hpp>

namespace QuantLib {

    //! EU HICP index
    class EUHICP : public ZeroInflationIndex {
      public:
        explicit EUHICP(const Handle<ZeroInflationTermStructure>& ts = {})
        : ZeroInflationIndex("HICP",
                             EURegion(),
                             false,
                             Monthly,
                             Period(1, Months), // availability
                             EURCurrency(),
                             ts) {}
    };

    //! EU HICPXT index
    class EUHICPXT : public ZeroInflationIndex {
      public:
        explicit EUHICPXT(const Handle<ZeroInflationTermStructure>& ts = {})
        : ZeroInflationIndex("HICPXT",
                             EURegion(),
                             false,
                             Monthly,
                             Period(1, Months), // availability
                             EURCurrency(),
                             ts) {}
    };


    //! Quoted year-on-year EU HICP (i.e. not a ratio of EU HICP)
    class YYEUHICP : public YoYInflationIndex {
      public:
        explicit YYEUHICP(const Handle<YoYInflationTermStructure>& ts = {})
        : YoYInflationIndex("YY_HICP",
                            EURegion(),
                            false,
                            Monthly,
                            Period(1, Months),
                            EURCurrency(),
                            ts) {}

        QL_DEPRECATED_DISABLE_WARNING

        /*! \deprecated Use the overload without the interpolated parameter.
                        Deprecated in version 1.38.
        */
        [[deprecated("Use the overload without the interpolated parameter")]]
        explicit YYEUHICP(
            bool interpolated,
            const Handle<YoYInflationTermStructure>& ts = {})
        : YoYInflationIndex("YY_HICP",
                            EURegion(),
                            false,
                            interpolated,
                            Monthly,
                            Period(1, Months),
                            EURCurrency(),
                            ts) {}

        QL_DEPRECATED_ENABLE_WARNING
    };

    //! Quoted year-on-year EU HICPXT
    class YYEUHICPXT : public YoYInflationIndex {
      public:
        explicit YYEUHICPXT(const Handle<YoYInflationTermStructure>& ts = {})
        : YoYInflationIndex("YY_HICPXT",
                            EURegion(),
                            false,
                            Monthly,
                            Period(1, Months),
                            EURCurrency(),
                            ts) {}

        QL_DEPRECATED_DISABLE_WARNING

        /*! \deprecated Use the overload without the interpolated parameter.
                        Deprecated in version 1.38.
        */
        [[deprecated("Use the overload without the interpolated parameter")]]
        explicit YYEUHICPXT(
            bool interpolated,
            const Handle<YoYInflationTermStructure>& ts = {})
        : YoYInflationIndex("YY_HICPXT",
                            EURegion(),
                            false,
                            interpolated,
                            Monthly,
                            Period(1, Months),
                            EURCurrency(),
                            ts) {}

        QL_DEPRECATED_ENABLE_WARNING
    };

}


#endif
]]></document_content>
  </document>
  <document index="52">
    <source>inflation/frhicp.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon
 Copyright (C) 2021 Ralf Konrad Eckel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file frhicp.hpp
    \brief French HICP inflation indexes
*/

#ifndef quantlib_frhicp_hpp
#define quantlib_frhicp_hpp

#include <ql/currencies/europe.hpp>
#include <ql/indexes/inflationindex.hpp>

namespace QuantLib {

    //! FR HICP index
    class FRHICP : public ZeroInflationIndex {
      public:
        explicit FRHICP(const Handle<ZeroInflationTermStructure>& ts = {})
        : ZeroInflationIndex(
              "HICP", FranceRegion(), false, Monthly, Period(1, Months), EURCurrency(), ts) {}
    };


    //! Quoted year-on-year FR HICP (i.e. not a ratio)
    class YYFRHICP : public YoYInflationIndex {
      public:
        explicit YYFRHICP(const Handle<YoYInflationTermStructure>& ts = {})
        : YoYInflationIndex("YY_HICP",
                            FranceRegion(),
                            false,
                            Monthly,
                            Period(1, Months),
                            EURCurrency(),
                            ts) {}

        QL_DEPRECATED_DISABLE_WARNING

        /*! \deprecated Use the overload without the interpolated parameter.
                        Deprecated in version 1.38.
        */
        [[deprecated("Use the overload without the interpolated parameter")]]
        explicit YYFRHICP(
            bool interpolated,
            const Handle<YoYInflationTermStructure>& ts = {})
        : YoYInflationIndex("YY_HICP",
                            FranceRegion(),
                            false,
                            interpolated,
                            Monthly,
                            Period(1, Months),
                            EURCurrency(),
                            ts) {}

        QL_DEPRECATED_ENABLE_WARNING
    };

}

#endif
]]></document_content>
  </document>
  <document index="53">
    <source>inflation/ukhicp.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2022 Skandinaviska Enskilda Banken AB (publ)

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file ukhicp.hpp
    \brief UK HICP index
*/

#ifndef quantlib_ukhicp_hpp
#define quantlib_ukhicp_hpp

#include <ql/currencies/europe.hpp>
#include <ql/indexes/inflationindex.hpp>

namespace QuantLib {

    //! UK HICP index
    class UKHICP : public ZeroInflationIndex {
      public:
        explicit UKHICP(const Handle<ZeroInflationTermStructure>& ts = {})
        : ZeroInflationIndex(
              "HICP", UKRegion(), false, Monthly, Period(1, Months), GBPCurrency(), ts) {}
    };
}

#endif
]]></document_content>
  </document>
  <document index="54">
    <source>inflation/ukrpi.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 Chris Kenyon
 Copyright (C) 2021 Ralf Konrad Eckel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file ukrpi.hpp
    \brief %UKRPI index
*/

#ifndef quantlib_ukrpi_hpp
#define quantlib_ukrpi_hpp

#include <ql/currencies/europe.hpp>
#include <ql/indexes/inflationindex.hpp>

namespace QuantLib {

    //! UK Retail Price Inflation Index
    class UKRPI : public ZeroInflationIndex {
      public:
        explicit UKRPI(const Handle<ZeroInflationTermStructure>& ts = {})
        : ZeroInflationIndex(
              "RPI", UKRegion(), false, Monthly, Period(1, Months), GBPCurrency(), ts) {}
    };


    //! Quoted year-on-year UK RPI (i.e. not a ratio of UK RPI)
    class YYUKRPI : public YoYInflationIndex {
      public:
        explicit YYUKRPI(const Handle<YoYInflationTermStructure>& ts = {})
        : YoYInflationIndex("YY_RPI",
                            UKRegion(),
                            false,
                            Monthly,
                            Period(1, Months),
                            GBPCurrency(),
                            ts) {}

        QL_DEPRECATED_DISABLE_WARNING

        /*! \deprecated Use the overload without the interpolated parameter.
                        Deprecated in version 1.38.
        */
        [[deprecated("Use the overload without the interpolated parameter")]]
        explicit YYUKRPI(
            bool interpolated,
            const Handle<YoYInflationTermStructure>& ts = {})
        : YoYInflationIndex("YY_RPI",
                            UKRegion(),
                            false,
                            interpolated,
                            Monthly,
                            Period(1, Months),
                            GBPCurrency(),
                            ts) {}

        QL_DEPRECATED_ENABLE_WARNING
    };

}


#endif
]]></document_content>
  </document>
  <document index="55">
    <source>inflation/uscpi.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon
 Copyright (C) 2021 Ralf Konrad Eckel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

/*! \file uscpi.hpp
 \brief US CPI index
 */

#ifndef quantlib_uscpi_hpp
#define quantlib_uscpi_hpp

#include <ql/currencies/america.hpp>
#include <ql/indexes/inflationindex.hpp>

namespace QuantLib {

    //! US CPI index
    class USCPI : public ZeroInflationIndex {
      public:
        explicit USCPI(const Handle<ZeroInflationTermStructure>& ts = {})
        : ZeroInflationIndex("CPI",
                             USRegion(),
                             false,
                             Monthly,
                             Period(1, Months), // availability
                             USDCurrency(),
                             ts) {}
    };


    //! Quoted year-on-year US CPI (i.e. not a ratio of US CPI)
    class YYUSCPI : public YoYInflationIndex {
      public:
        explicit YYUSCPI(const Handle<YoYInflationTermStructure>& ts = {})
        : YoYInflationIndex("YY_CPI",
                            USRegion(),
                            false,
                            Monthly,
                            Period(1, Months),
                            USDCurrency(),
                            ts) {}

        QL_DEPRECATED_DISABLE_WARNING

        /*! \deprecated Use the overload without the interpolated parameter.
                        Deprecated in version 1.38.
        */
        [[deprecated("Use the overload without the interpolated parameter")]]
        explicit YYUSCPI(
            bool interpolated,
            const Handle<YoYInflationTermStructure>& ts = {})
        : YoYInflationIndex("YY_CPI",
                            USRegion(),
                            false,
                            interpolated,
                            Monthly,
                            Period(1, Months),
                            USDCurrency(),
                            ts) {}

        QL_DEPRECATED_ENABLE_WARNING
    };

}


#endif
]]></document_content>
  </document>
  <document index="56">
    <source>inflation/zacpi.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 Chris Kenyon
 Copyright (C) 2021 Ralf Konrad Eckel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file zacpi.hpp
    \brief %ZACPI index
*/

#ifndef quantlib_zacpi_hpp
#define quantlib_zacpi_hpp

#include <ql/currencies/africa.hpp>
#include <ql/indexes/inflationindex.hpp>

namespace QuantLib {

    //! South African Consumer Price Inflation Index
    class ZACPI : public ZeroInflationIndex {
      public:
        explicit ZACPI(const Handle<ZeroInflationTermStructure>& ts = {})
        : ZeroInflationIndex(
              "CPI", ZARegion(), false, Monthly, Period(1, Months), ZARCurrency(), ts) {}
    };


    //! Quoted year-on-year South African CPI (i.e. not a ratio of ZA CPI)
    class YYZACPI : public YoYInflationIndex {
      public:
        explicit YYZACPI(
            const Handle<YoYInflationTermStructure>& ts = {})
        : YoYInflationIndex("YY_CPI",
                            ZARegion(),
                            false,
                            Monthly,
                            Period(1, Months),
                            ZARCurrency(),
                            ts) {}

        QL_DEPRECATED_DISABLE_WARNING

        /*! \deprecated Use the overload without the interpolated parameter.
                        Deprecated in version 1.38.
        */
        [[deprecated("Use the overload without the interpolated parameter")]]
        explicit YYZACPI(
            bool interpolated,
            const Handle<YoYInflationTermStructure>& ts = {})
        : YoYInflationIndex("YY_CPI",
                            ZARegion(),
                            false,
                            interpolated,
                            Monthly,
                            Period(1, Months),
                            ZARCurrency(),
                            ts) {}

        QL_DEPRECATED_ENABLE_WARNING
    };

}


#endif
]]></document_content>
  </document>
  <document index="57">
    <source>inflationindex.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Chris Kenyon
 Copyright (C) 2021 Ralf Konrad Eckel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file inflationindex.hpp
    \brief base classes for inflation indexes
*/

#ifndef quantlib_inflation_index_hpp
#define quantlib_inflation_index_hpp

#include <ql/currency.hpp>
#include <ql/handle.hpp>
#include <ql/index.hpp>
#include <ql/indexes/region.hpp>
#include <ql/termstructures/inflationtermstructure.hpp>

namespace QuantLib {

    class ZeroInflationIndex;
    class YoYInflationIndex;

    struct CPI {

        //! when you observe an index, how do you interpolate between fixings?
        enum InterpolationType {
            AsIndex, //!< same interpolation as index
            Flat,    //!< flat from previous fixing
            Linear   //!< linearly between bracketing fixings
        };

        //! interpolated inflation fixing
        /*! \param index              The index whose fixing should be retrieved
            \param date               The date without lag; usually, the payment
                                      date for some inflation-based coupon.
            \param observationLag     The observation lag to be subtracted from the
                                      passed date; for instance, if the passed date is
                                      in May and the lag is three months, the inflation
                                      fixing from February (and March, in case of
                                      interpolation) will be observed.
            \param interpolationType  The interpolation type (flat or linear)
        */
        static Real laggedFixing(const ext::shared_ptr<ZeroInflationIndex>& index,
                                 const Date& date,
                                 const Period& observationLag,
                                 InterpolationType interpolationType);


        //! interpolated year-on-year inflation rate
        /*! \param index              The index whose fixing should be retrieved
            \param date               The date without lag; usually, the payment
                                      date for some inflation-based coupon.
            \param observationLag     The observation lag to be subtracted from the
                                      passed date; for instance, if the passed date is
                                      in May and the lag is three months, the year-on-year
                                      rate from February (and March, in case of
                                      interpolation) will be observed.
            \param interpolationType  The interpolation type (flat or linear)
        */
        static Real laggedYoYRate(const ext::shared_ptr<YoYInflationIndex>& index,
                                  const Date& date,
                                  const Period& observationLag,
                                  InterpolationType interpolationType);
    };


    //! Base class for inflation-rate indexes,
    class InflationIndex : public Index {
      public:
        InflationIndex(std::string familyName,
                       Region region,
                       bool revised,
                       Frequency frequency,
                       const Period& availabilitiyLag,
                       Currency currency);

        //! \name Index interface
        //@{
        std::string name() const override;

        /*! Inflation indices are not associated to a particular day,
            but to months or quarters.  Therefore, they do not have
            fixing calendars.  Since we're forced by the base `Index`
            interface to add one, this method returns a NullCalendar
            instance.
        */
        Calendar fixingCalendar() const override;
        bool isValidFixingDate(const Date&) const override { return true; }

        /*! Forecasting index values requires an inflation term
            structure, with a base date that is earlier than its asof
            date.  This must be so because indices are available only
            with a lag.  Usually, it makes sense for the base date to
            be the first day of the month of the last published
            fixing.
        */
        Real fixing(const Date& fixingDate, bool forecastTodaysFixing = false) const override = 0;

        //! returns a past fixing at the given date
        Real pastFixing(const Date& fixingDate) const override = 0;

        void addFixing(const Date& fixingDate, Rate fixing, bool forceOverwrite = false) override;
        //@}

        //! \name Inspectors
        //@{
        std::string familyName() const;
        Region region() const;
        bool revised() const;
        Frequency frequency() const;
        /*! The availability lag describes when the index might be
            available; for instance, the inflation value for January
            may only be available in April.  This doesn't mean that
            that inflation value is considered as the April fixing; it
            remains the January fixing, independently of the lag in
            availability.
        */
        Period availabilityLag() const;
        Currency currency() const;
        //@}

      protected:
        Date referenceDate_;
        std::string familyName_;
        Region region_;
        bool revised_;
        Frequency frequency_;
        Period availabilityLag_;
        Currency currency_;

      private:
        std::string name_;
    };


    //! Base class for zero inflation indices.
    class ZeroInflationIndex : public InflationIndex {
      public:
        ZeroInflationIndex(
            const std::string& familyName,
            const Region& region,
            bool revised,
            Frequency frequency,
            const Period& availabilityLag,
            const Currency& currency,
            Handle<ZeroInflationTermStructure> ts = {});

        //! \name Index interface
        //@{
        /*! \warning the forecastTodaysFixing parameter (required by
                     the Index interface) is currently ignored.
        */
        Real fixing(const Date& fixingDate, bool forecastTodaysFixing = false) const override;
        Real pastFixing(const Date& fixingDate) const override;
        //@}
        //! \name Other methods
        //@{
        Date lastFixingDate() const;
        Handle<ZeroInflationTermStructure> zeroInflationTermStructure() const;
        ext::shared_ptr<ZeroInflationIndex> clone(const Handle<ZeroInflationTermStructure>& h) const;
        bool needsForecast(const Date& fixingDate) const;
        //@}
      private:
        Real forecastFixing(const Date& fixingDate) const;
        Handle<ZeroInflationTermStructure> zeroInflation_;
    };


    //! Base class for year-on-year inflation indices.
    /*! These may be quoted indices published on, say, Bloomberg, or can be
        defined as the ratio of an index at different time points.
    */
    class YoYInflationIndex : public InflationIndex {
      public:
        //! \name Constructors
        //@{
        //! Constructor for year-on-year indices defined as a ratio.
        /*! An index build with this constructor won't store
            past fixings of its own; they will be calculated as a
            ratio from the past fixings stored in the underlying index.
        */
        explicit YoYInflationIndex(
            const ext::shared_ptr<ZeroInflationIndex>& underlyingIndex,
            Handle<YoYInflationTermStructure> ts = {});

        /*! \deprecated Use the similar overload without the interpolated parameter.
                        Deprecated in version 1.38.
        */
        [[deprecated("Use the similar overload without the interpolated parameter")]]
        YoYInflationIndex(
            const ext::shared_ptr<ZeroInflationIndex>& underlyingIndex,
            bool interpolated,
            Handle<YoYInflationTermStructure> ts = {});

        //! Constructor for quoted year-on-year indices.
        /*! An index built with this constructor needs its past
            fixings (i.e., the past year-on-year values) to be stored
            via the `addFixing` or `addFixings` method.
        */
        YoYInflationIndex(
            const std::string& familyName,
            const Region& region,
            bool revised,
            Frequency frequency,
            const Period& availabilityLag,
            const Currency& currency,
            Handle<YoYInflationTermStructure> ts = {});

        /*! \deprecated Use the similar overload without the interpolated parameter.
                        Deprecated in version 1.38.
        */
        [[deprecated("Use the similar overload without the interpolated parameter")]]
        YoYInflationIndex(
            const std::string& familyName,
            const Region& region,
            bool revised,
            bool interpolated,
            Frequency frequency,
            const Period& availabilityLag,
            const Currency& currency,
            Handle<YoYInflationTermStructure> ts = {});
        //@}

        //! \name Index interface
        //@{
        /*! \warning the forecastTodaysFixing parameter (required by
                     the Index interface) is currently ignored.
        */
        Rate fixing(const Date& fixingDate, bool forecastTodaysFixing = false) const override;
        Real pastFixing(const Date& fixingDate) const override;
        //@}

        //! \name Other methods
        //@{
        Date lastFixingDate() const;
        bool interpolated() const;
        bool ratio() const;
        ext::shared_ptr<ZeroInflationIndex> underlyingIndex() const;
        Handle<YoYInflationTermStructure> yoyInflationTermStructure() const;

        ext::shared_ptr<YoYInflationIndex> clone(const Handle<YoYInflationTermStructure>& h) const;
        bool needsForecast(const Date& fixingDate) const;
        //@}

      protected:
        bool interpolated_;

      private:
        Rate forecastFixing(const Date& fixingDate) const;
        bool ratio_;
        ext::shared_ptr<ZeroInflationIndex> underlyingIndex_;
        Handle<YoYInflationTermStructure> yoyInflation_;
    };


    namespace detail::CPI {

        // Returns either CPI::Flat or CPI::Linear depending on the combination of index and
        // CPI::InterpolationType.
        QuantLib::CPI::InterpolationType
        effectiveInterpolationType(const QuantLib::CPI::InterpolationType& type);

        QuantLib::CPI::InterpolationType
        effectiveInterpolationType(const QuantLib::CPI::InterpolationType& type,
                                   const ext::shared_ptr<YoYInflationIndex>& index);

        // checks whether the combination of index and CPI::InterpolationType results
        // effectively in CPI::Linear
        bool isInterpolated(const QuantLib::CPI::InterpolationType& type);

        bool isInterpolated(const QuantLib::CPI::InterpolationType& type,
                            const ext::shared_ptr<YoYInflationIndex>& index);

    }


    // inline

    inline std::string InflationIndex::name() const {
        return name_;
    }

    inline std::string InflationIndex::familyName() const {
        return familyName_;
    }

    inline Region InflationIndex::region() const {
        return region_;
    }

    inline bool InflationIndex::revised() const {
        return revised_;
    }

    inline Frequency InflationIndex::frequency() const {
        return frequency_;
    }

    inline Period InflationIndex::availabilityLag() const {
        return availabilityLag_;
    }

    inline Currency InflationIndex::currency() const {
        return currency_;
    }

    inline Handle<ZeroInflationTermStructure>
    ZeroInflationIndex::zeroInflationTermStructure() const {
        return zeroInflation_;
    }

    inline bool YoYInflationIndex::interpolated() const {
        return interpolated_;
    }

    inline bool YoYInflationIndex::ratio() const {
        return ratio_;
    }

    inline ext::shared_ptr<ZeroInflationIndex> YoYInflationIndex::underlyingIndex() const {
        return underlyingIndex_;
    }

    inline Handle<YoYInflationTermStructure>
    YoYInflationIndex::yoyInflationTermStructure() const {
        return yoyInflation_;
    }

}

#endif
]]></document_content>
  </document>
  <document index="58">
    <source>interestrateindex.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007, 2009 StatPro Italia srl
 Copyright (C) 2006, 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file interestrateindex.hpp
    \brief base class for interest rate indexes
*/

#ifndef quantlib_interestrateindex_hpp
#define quantlib_interestrateindex_hpp

#include <ql/index.hpp>
#include <ql/time/calendar.hpp>
#include <ql/currency.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/time/period.hpp>

namespace QuantLib {

    //! base class for interest rate indexes
    /*! \todo add methods returning InterestRate */
    class InterestRateIndex : public Index {
      public:
        InterestRateIndex(std::string familyName,
                          const Period& tenor,
                          Natural settlementDays,
                          Currency currency,
                          Calendar fixingCalendar,
                          DayCounter dayCounter);
        //! \name Index interface
        //@{
        std::string name() const override;
        Calendar fixingCalendar() const override;
        bool isValidFixingDate(const Date& fixingDate) const override;
        Rate fixing(const Date& fixingDate, bool forecastTodaysFixing = false) const override;
        //@}
        //! \name Inspectors
        //@{
        std::string familyName() const { return familyName_; }
        Period tenor() const { return tenor_; }
        Natural fixingDays() const { return fixingDays_; }
        const Currency& currency() const { return currency_; }
        const DayCounter& dayCounter() const { return dayCounter_; }
        //@}
        /*! \name Date calculations

            These method can be overridden to implement particular
            conventions (e.g. EurLibor)

            @{
        */
        virtual Date fixingDate(const Date& valueDate) const;
        virtual Date valueDate(const Date& fixingDate) const;
        virtual Date maturityDate(const Date& valueDate) const = 0;
        //@}
        //! \name Fixing calculations
        //@{
        //! It can be overridden to implement particular conventions
        virtual Rate forecastFixing(const Date& fixingDate) const = 0;
        // @}
      protected:
        std::string familyName_;
        Period tenor_;
        Natural fixingDays_;
        Currency currency_;
        DayCounter dayCounter_;
        std::string name_;
      private:
        Calendar fixingCalendar_;
    };


    // inline definitions

    inline std::string InterestRateIndex::name() const {
        return name_;
    }

    inline Calendar InterestRateIndex::fixingCalendar() const {
        return fixingCalendar_;
    }

    inline bool InterestRateIndex::isValidFixingDate(const Date& d) const {
        return fixingCalendar().isBusinessDay(d);
    }

    inline Date InterestRateIndex::fixingDate(const Date& valueDate) const {
        Date fixingDate = fixingCalendar().advance(valueDate,
            -static_cast<Integer>(fixingDays_), Days);
        return fixingDate;
    }

    inline Date InterestRateIndex::valueDate(const Date& fixingDate) const {
        QL_REQUIRE(isValidFixingDate(fixingDate),
                   fixingDate << " is not a valid fixing date");
        return fixingCalendar().advance(fixingDate, fixingDays_, Days);
    }
}

#endif
]]></document_content>
  </document>
  <document index="59">
    <source>region.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Chris Kenyon
 Copyright (C) 2014 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file region.hpp
    \brief Region, i.e. geographical area, specification
*/

#ifndef quantlib_region_hpp
#define quantlib_region_hpp

#include <ql/qldefines.hpp>
#include <ql/shared_ptr.hpp>
#include <string>
#include <utility>

namespace QuantLib {

    //! Region class, used for inflation applicability.
    class Region {
      public:
        //! \name Inspectors
        //@{
        const std::string& name() const;
        const std::string& code() const;
        //@}
      protected:
        Region() = default;
        struct Data;
        ext::shared_ptr<Data> data_;
    };

    struct Region::Data {
        std::string name;
        std::string code;
        Data(std::string name, std::string code) : name(std::move(name)), code(std::move(code)) {}
    };

    //! \relates Region
    bool operator==(const Region&, const Region&);

    //! \relates Region
    bool operator!=(const Region&, const Region&);


    //! Custom geographical/economic region
    /*! This class allows one to create an instance of a particular
        region without having to define and compile a corresponding
        class.
    */
    class CustomRegion : public Region {
      public:
        CustomRegion(const std::string& name,
                     const std::string& code);
    };


    //! Australia as geographical/economic region
    class AustraliaRegion : public Region {
      public:
        AustraliaRegion();
    };

    //! European Union as geographical/economic region
    class EURegion : public Region {
      public:
        EURegion();
    };

    //! France as geographical/economic region
    class FranceRegion : public Region {
      public:
        FranceRegion();
    };

    //! United Kingdom as geographical/economic region
    class UKRegion : public Region {
      public:
        UKRegion();
    };

    //! USA as geographical/economic region
    class USRegion : public Region {
    public:
        USRegion();
    };

    //! South Africa as geographical/economic region
    class ZARegion : public Region {
    public:
        ZARegion();
    };


    // inline definitions

    inline const std::string& Region::name() const {
        return data_->name;
    }

    inline const std::string& Region::code() const {
        return data_->code;
    }

    inline bool operator==(const Region& r1, const Region& r2) {
        return r1.name() == r2.name();
    }

    inline bool operator!=(const Region& r1, const Region& r2) {
        return !(r1.name() == r2.name());
    }

}

#endif
]]></document_content>
  </document>
  <document index="60">
    <source>swap/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/indexes/swap/chfliborswap.hpp>
#include <ql/indexes/swap/euriborswap.hpp>
#include <ql/indexes/swap/eurliborswap.hpp>
#include <ql/indexes/swap/gbpliborswap.hpp>
#include <ql/indexes/swap/jpyliborswap.hpp>
#include <ql/indexes/swap/usdliborswap.hpp>

]]></document_content>
  </document>
  <document index="61">
    <source>swap/chfliborswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file chfliborswap.hpp
    \brief %CHF %Libor %Swap indexes
*/

#ifndef quantlib_chfliborswap_hpp
#define quantlib_chfliborswap_hpp

#include <ql/indexes/swapindex.hpp>

namespace QuantLib {

    //! %ChfLiborSwapIsdaFix index base class
    /*! %CHF %Libor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 11am London.
        Annual 30/360 vs 6M Libor, 1Y vs 3M Libor.
        Reuters page ISDAFIX4 or CHFSFIX=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class ChfLiborSwapIsdaFix : public SwapIndex {
      public:
        ChfLiborSwapIsdaFix(const Period& tenor,
                            const Handle<YieldTermStructure>& h = {});
        ChfLiborSwapIsdaFix(const Period& tenor,
                            const Handle<YieldTermStructure>& forwarding,
                            const Handle<YieldTermStructure>& discounting);
    };

}

#endif
]]></document_content>
  </document>
  <document index="62">
    <source>swap/euriborswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file euriborswap.hpp
    \brief Euribor %Swap indexes
*/

#ifndef quantlib_euriborswap_hpp
#define quantlib_euriborswap_hpp

#include <ql/indexes/swapindex.hpp>

namespace QuantLib {

    //! %EuriborSwapIsdaFixA index base class
    /*! %Euribor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 11am Frankfurt.
        Annual 30/360 vs 6M Euribor, 1Y vs 3M Euribor.
        Reuters page ISDAFIX2 or EURSFIXA=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class EuriborSwapIsdaFixA : public SwapIndex {
      public:
        EuriborSwapIsdaFixA(const Period& tenor,
                            const Handle<YieldTermStructure>& h = {});
        EuriborSwapIsdaFixA(const Period& tenor,
                            const Handle<YieldTermStructure>& forwarding,
                            const Handle<YieldTermStructure>& discounting);
    };

    //! %EuriborSwapIsdaFixB index base class
    /*! %Euribor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 12am Frankfurt.
        Annual 30/360 vs 6M Euribor, 1Y vs 3M Euribor.
        Reuters page ISDAFIX2 or EURSFIXB=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class EuriborSwapIsdaFixB : public SwapIndex {
      public:
        EuriborSwapIsdaFixB(const Period& tenor,
                            const Handle<YieldTermStructure>& h = {});
        EuriborSwapIsdaFixB(const Period& tenor,
                            const Handle<YieldTermStructure>& forwarding,
                            const Handle<YieldTermStructure>& discounting);
    };

    //! %EuriborSwapIfrFix index base class
    /*! %Euribor %Swap indexes published by IFR Markets and
        distributed by Reuters page TGM42281 and by Telerate.
        Annual 30/360 vs 6M Euribor, 1Y vs 3M Euribor.
        For more info see <http://www.ifrmarkets.com>.

    */
    class EuriborSwapIfrFix : public SwapIndex {
      public:
        EuriborSwapIfrFix(const Period& tenor,
                          const Handle<YieldTermStructure>& h = {});
        EuriborSwapIfrFix(const Period& tenor,
                          const Handle<YieldTermStructure>& forwarding,
                          const Handle<YieldTermStructure>& discounting);
    };

}

#endif
]]></document_content>
  </document>
  <document index="63">
    <source>swap/eurliborswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file eurliborswap.hpp
    \brief %EUR %Libor %Swap indexes
*/

#ifndef quantlib_eurliborswap_hpp
#define quantlib_eurliborswap_hpp

#include <ql/indexes/swapindex.hpp>

namespace QuantLib {

    //! %EurLiborSwapIsdaFixA index base class
    /*! %EUR %Libor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 10am London.
        Annual 30/360 vs 6M Libor, 1Y vs 3M Libor.
        Reuters page ISDAFIX2 or EURSFIXLA=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class EurLiborSwapIsdaFixA : public SwapIndex {
      public:
        EurLiborSwapIsdaFixA(const Period& tenor,
                             const Handle<YieldTermStructure>& h = {});
        EurLiborSwapIsdaFixA(const Period& tenor,
                             const Handle<YieldTermStructure>& forwarding,
                             const Handle<YieldTermStructure>& discounting);
    };

    //! %EurLiborSwapIsdaFixB index base class
    /*! %EUR %Libor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 11am London.
        Annual 30/360 vs 6M Libor, 1Y vs 3M Libor.
        Reuters page ISDAFIX2 or EURSFIXLB=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class EurLiborSwapIsdaFixB : public SwapIndex {
      public:
        EurLiborSwapIsdaFixB(const Period& tenor,
                             const Handle<YieldTermStructure>& h = {});
        EurLiborSwapIsdaFixB(const Period& tenor,
                             const Handle<YieldTermStructure>& forwarding,
                             const Handle<YieldTermStructure>& discounting);
    };


    //! %EurLiborSwapIfrFix index base class
    /*! %EUR %Libor %Swap indexes published by IFR Markets and
        distributed by Reuters page TGM42281 and by Telerate.
        Annual 30/360 vs 6M Libor, 1Y vs 3M Libor.
        For more info see <http://www.ifrmarkets.com>.

    */
    class EurLiborSwapIfrFix : public SwapIndex {
      public:
        EurLiborSwapIfrFix(const Period& tenor,
                           const Handle<YieldTermStructure>& h = {});
        EurLiborSwapIfrFix(const Period& tenor,
                           const Handle<YieldTermStructure>& forwarding,
                           const Handle<YieldTermStructure>& discounting);
    };

}

#endif
]]></document_content>
  </document>
  <document index="64">
    <source>swap/gbpliborswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gbpliborswap.hpp
    \brief %GBP %Libor %Swap indexes
*/

#ifndef quantlib_gbpliborswap_hpp
#define quantlib_gbpliborswap_hpp

#include <ql/indexes/swapindex.hpp>

namespace QuantLib {

    //! %GbpLiborSwapIsdaFix index base class
    /*! %GBP %Libor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 11am London.
        Semiannual Actual/365F vs 6M Libor, 1Y Annual vs 3M Libor.
        Reuters page ISDAFIX4 or GBPSFIX=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class GbpLiborSwapIsdaFix : public SwapIndex {
      public:
        GbpLiborSwapIsdaFix(const Period& tenor,
                            const Handle<YieldTermStructure>& h = {});
        GbpLiborSwapIsdaFix(const Period& tenor,
                            const Handle<YieldTermStructure>& forwarding,
                            const Handle<YieldTermStructure>& discounting);
    };

}

#endif
]]></document_content>
  </document>
  <document index="65">
    <source>swap/jpyliborswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file jpyliborswap.hpp
    \brief %JPY %Libor %Swap indexes
*/

#ifndef quantlib_jpyliborswap_hpp
#define quantlib_jpyliborswap_hpp

#include <ql/indexes/swapindex.hpp>

namespace QuantLib {

    //! %JpyLiborSwapIsdaFixAm index base class
    /*! %JPY %Libor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 10am Tokyo.
        Semiannual Act/365 vs 6M Libor. Reuters page ISDAFIX1 or JPYSFIXA=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class JpyLiborSwapIsdaFixAm : public SwapIndex {
      public:
        JpyLiborSwapIsdaFixAm(const Period& tenor,
                              const Handle<YieldTermStructure>& h = {});
        JpyLiborSwapIsdaFixAm(const Period& tenor,
                              const Handle<YieldTermStructure>& forwarding,
                              const Handle<YieldTermStructure>& discounting);
    };

    //! %JpyLiborSwapIsdaFixPm index base class
    /*! %JPY %Libor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 3pm Tokyo.
        Semiannual Act/365 vs 6M Libor. Reuters page ISDAFIX1 or JPYSFIXP=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class JpyLiborSwapIsdaFixPm : public SwapIndex {
      public:
        JpyLiborSwapIsdaFixPm(const Period& tenor,
                              const Handle<YieldTermStructure>& h = {});
        JpyLiborSwapIsdaFixPm(const Period& tenor,
                              const Handle<YieldTermStructure>& forwarding,
                              const Handle<YieldTermStructure>& discounting);
    };

}

#endif
]]></document_content>
  </document>
  <document index="66">
    <source>swap/usdliborswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file usdliborswap.hpp
    \brief %USD %Libor %Swap indexes
*/

#ifndef quantlib_usdliborswap_hpp
#define quantlib_usdliborswap_hpp

#include <ql/indexes/swapindex.hpp>

namespace QuantLib {

    //! %UsdLiborSwapIsdaFixAm index base class
    /*! %USD %Libor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 11am New York.
        Semiannual 30/360 vs 3M Libor. Reuters page ISDAFIX1 or USDSFIX=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class UsdLiborSwapIsdaFixAm : public SwapIndex {
      public:
        UsdLiborSwapIsdaFixAm(const Period& tenor,
                              const Handle<YieldTermStructure>& h = {});
        UsdLiborSwapIsdaFixAm(const Period& tenor,
                              const Handle<YieldTermStructure>& forwarding,
                              const Handle<YieldTermStructure>& discounting);
    };

    //! %UsdLiborSwapIsdaFixPm index base class
    /*! %USD %Libor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 3pm New York.
        Semiannual 30/360 vs 3M Libor. Reuters page ISDAFIX1 or USDSFIXP=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class UsdLiborSwapIsdaFixPm : public SwapIndex {
      public:
        UsdLiborSwapIsdaFixPm(const Period& tenor,
                              const Handle<YieldTermStructure>& h = {});
        UsdLiborSwapIsdaFixPm(const Period& tenor,
                              const Handle<YieldTermStructure>& forwarding,
                              const Handle<YieldTermStructure>& discounting);
    };

}

#endif
]]></document_content>
  </document>
  <document index="67">
    <source>swapindex.hpp</source>
    <document_content><![CDATA[/*
 Copyright (C) 2006, 2009 Ferdinando Ametrano
 Copyright (C) 2006, 2007, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.


 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 or FITNESS FOR A PARTICULAR PURPOSE. See the license for more details. */

/*! \file swapindex.hpp
    \brief swap-rate indexes
*/

#ifndef quantlib_swapindex_hpp
#define quantlib_swapindex_hpp

#include <ql/indexes/interestrateindex.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/cashflows/rateaveraging.hpp>

namespace QuantLib {

    class Schedule;

    class IborIndex;
    class VanillaSwap;

    class OvernightIndex;
    class OvernightIndexedSwap;

    //! base class for swap-rate indexes
    class SwapIndex : public InterestRateIndex {
      public:
        SwapIndex(const std::string& familyName,
                  const Period& tenor,
                  Natural settlementDays,
                  const Currency& currency,
                  const Calendar& fixingCalendar,
                  const Period& fixedLegTenor,
                  BusinessDayConvention fixedLegConvention,
                  const DayCounter& fixedLegDayCounter,
                  ext::shared_ptr<IborIndex> iborIndex);
        SwapIndex(const std::string& familyName,
                  const Period& tenor,
                  Natural settlementDays,
                  const Currency& currency,
                  const Calendar& fixingCalendar,
                  const Period& fixedLegTenor,
                  BusinessDayConvention fixedLegConvention,
                  const DayCounter& fixedLegDayCounter,
                  ext::shared_ptr<IborIndex> iborIndex,
                  Handle<YieldTermStructure> discountingTermStructure);
        //! \name InterestRateIndex interface
        //@{
        Date maturityDate(const Date& valueDate) const override;
        //@}
        //! \name Inspectors
        //@{
        Period fixedLegTenor() const { return fixedLegTenor_; }
        BusinessDayConvention fixedLegConvention() const;
        ext::shared_ptr<IborIndex> iborIndex() const { return iborIndex_; }
        Handle<YieldTermStructure> forwardingTermStructure() const;
        Handle<YieldTermStructure> discountingTermStructure() const;
        bool exogenousDiscount() const;
        /*! \warning Relinking the term structure underlying the index will
                     not have effect on the returned swap.
        */
        ext::shared_ptr<VanillaSwap> underlyingSwap(
                                                const Date& fixingDate) const;
        //@}
        //! \name Other methods
        //@{
        //! returns a copy of itself linked to a different forwarding curve
        virtual ext::shared_ptr<SwapIndex> clone(
                        const Handle<YieldTermStructure>& forwarding) const;
        //! returns a copy of itself linked to different curves
        virtual ext::shared_ptr<SwapIndex> clone(
                        const Handle<YieldTermStructure>& forwarding,
                        const Handle<YieldTermStructure>& discounting) const;
        //! returns a copy of itself with different tenor
        virtual ext::shared_ptr<SwapIndex> clone(
                        const Period& tenor) const;
        // @}
      protected:
        Rate forecastFixing(const Date& fixingDate) const override;
        Period tenor_;
        ext::shared_ptr<IborIndex> iborIndex_;
        Period fixedLegTenor_;
        BusinessDayConvention fixedLegConvention_;
        bool exogenousDiscount_;
        Handle<YieldTermStructure> discount_;
        // cache data to avoid swap recreation when the same fixing date
        // is used multiple time to forecast changing fixing
        mutable ext::shared_ptr<VanillaSwap> lastSwap_;
        mutable Date lastFixingDate_;
    };


    //! base class for overnight indexed swap indexes
    class OvernightIndexedSwapIndex : public SwapIndex {
      public:
        OvernightIndexedSwapIndex(
                  const std::string& familyName,
                  const Period& tenor,
                  Natural settlementDays,
                  const Currency& currency,
                  const ext::shared_ptr<OvernightIndex>& overnightIndex,
                  bool telescopicValueDates = false,
                  RateAveraging::Type averagingMethod = RateAveraging::Compound);
        //! \name Inspectors
        //@{
        ext::shared_ptr<OvernightIndex> overnightIndex() const;
        /*! \warning Relinking the term structure underlying the index will
                     not have effect on the returned swap.
        */
        ext::shared_ptr<OvernightIndexedSwap> underlyingSwap(
                                                const Date& fixingDate) const;
        //@}
      protected:
        ext::shared_ptr<OvernightIndex> overnightIndex_;
        bool telescopicValueDates_;
        RateAveraging::Type averagingMethod_;
        // cache data to avoid swap recreation when the same fixing date
        // is used multiple time to forecast changing fixing
        mutable ext::shared_ptr<OvernightIndexedSwap> lastSwap_;
        mutable Date lastFixingDate_;
    };

    // inline definitions

    inline BusinessDayConvention SwapIndex::fixedLegConvention() const {
        return fixedLegConvention_;
    }

    inline bool SwapIndex::exogenousDiscount() const {
        return exogenousDiscount_;
    }

    inline ext::shared_ptr<OvernightIndex>
    OvernightIndexedSwapIndex::overnightIndex() const {
        return overnightIndex_;
    }

}

#endif
]]></document_content>
  </document>
</documents>