<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/processes/batesprocess.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/coxingersollrossprocess.hpp>
#include <ql/processes/endeulerdiscretization.hpp>
#include <ql/processes/eulerdiscretization.hpp>
#include <ql/processes/forwardmeasureprocess.hpp>
#include <ql/processes/g2process.hpp>
#include <ql/processes/geometricbrownianprocess.hpp>
#include <ql/processes/gjrgarchprocess.hpp>
#include <ql/processes/gsrprocess.hpp>
#include <ql/processes/gsrprocesscore.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <ql/processes/hestonslvprocess.hpp>
#include <ql/processes/hullwhiteprocess.hpp>
#include <ql/processes/hybridhestonhullwhiteprocess.hpp>
#include <ql/processes/jointstochasticprocess.hpp>
#include <ql/processes/merton76process.hpp>
#include <ql/processes/mfstateprocess.hpp>
#include <ql/processes/ornsteinuhlenbeckprocess.hpp>
#include <ql/processes/squarerootprocess.hpp>
#include <ql/processes/stochasticprocessarray.hpp>

]]></document_content>
  </document>
  <document index="2">
    <source>batesprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file batesprocess.hpp
    \brief Bates stochastic process, Heston process plus compound Poisson
    process plus log-normal jump diffusion size
*/

#ifndef quantlib_bates_process_hpp
#define quantlib_bates_process_hpp

#include <ql/processes/hestonprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>


namespace QuantLib {

    //! Square-root stochastic-volatility Bates process
    /*! This class describes the square root stochastic volatility
        process incl jumps governed by
        \f[
        \begin{array}{rcl}
        dS(t, S)  &=& (r-d-\lambda m) S dt +\sqrt{v} S dW_1 + (e^J - 1) S dN \\
        dv(t, S)  &=& \kappa (\theta - v) dt + \sigma \sqrt{v} dW_2 \\
        dW_1 dW_2 &=& \rho dt \\
        \omega(J) &=& \frac{1}{\sqrt{2\pi \delta^2}}
                      \exp\left[-\frac{(J-\nu)^2}{2\delta^2}\right]
        \end{array}
        \f]

        \ingroup processes
    */
    class BatesProcess : public HestonProcess {
    public:
        BatesProcess(const Handle<YieldTermStructure>& riskFreeRate,
                     const Handle<YieldTermStructure>& dividendYield,
                     const Handle<Quote>& s0,
                     Real v0, Real kappa,
                     Real theta, Real sigma, Real rho,
                     Real lambda, Real nu, Real delta,
                     HestonProcess::Discretization d
                         = HestonProcess::FullTruncation);

        Size factors() const override;
        Array drift(Time t, const Array& x) const override;
        Array evolve(Time t0, const Array& x0, Time dt, const Array& dw) const override;

        Real lambda() const;
        Real nu()     const;
        Real delta()  const;
      private:
        const Real lambda_, delta_, nu_, m_;
        const CumulativeNormalDistribution cumNormalDist_;
    };
}


#endif
]]></document_content>
  </document>
  <document index="3">
    <source>blackscholesprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2004, 2005, 2006, 2007, 2009 StatPro Italia srl
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file blackscholesprocess.hpp
    \brief Black-Scholes processes
*/

#ifndef quantlib_black_scholes_process_hpp
#define quantlib_black_scholes_process_hpp

#include <ql/stochasticprocess.hpp>
#include <ql/processes/eulerdiscretization.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/termstructures/volatility/equityfx/blackvoltermstructure.hpp>
#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>
#include <ql/quote.hpp>

namespace QuantLib {

    class LocalConstantVol;
    class LocalVolCurve;

    //! Generalized Black-Scholes stochastic process
    /*! This class describes the stochastic process \f$ S \f$ governed by
        \f[
            d\ln S(t) = (r(t) - q(t) - \frac{\sigma(t, S)^2}{2}) dt
                     + \sigma dW_t.
        \f]

        \warning while the interface is expressed in terms of \f$ S \f$,
                 the internal calculations work on \f$ ln S \f$.

        \ingroup processes
    */
    class GeneralizedBlackScholesProcess : public StochasticProcess1D {
      public:
        GeneralizedBlackScholesProcess(Handle<Quote> x0,
                                       Handle<YieldTermStructure> dividendTS,
                                       Handle<YieldTermStructure> riskFreeTS,
                                       Handle<BlackVolTermStructure> blackVolTS,
                                       const ext::shared_ptr<discretization>& d =
                                           ext::shared_ptr<discretization>(new EulerDiscretization),
                                       bool forceDiscretization = false);

        GeneralizedBlackScholesProcess(Handle<Quote> x0,
                                       Handle<YieldTermStructure> dividendTS,
                                       Handle<YieldTermStructure> riskFreeTS,
                                       Handle<BlackVolTermStructure> blackVolTS,
                                       Handle<LocalVolTermStructure> localVolTS);

        //! \name StochasticProcess1D interface
        //@{
        Real x0() const override;
        /*! \todo revise extrapolation */
        Real drift(Time t, Real x) const override;
        /*! \todo revise extrapolation */
        Real diffusion(Time t, Real x) const override;
        Real apply(Real x0, Real dx) const override;
        /*! \warning in general raises a "not implemented" exception.
                     It should be rewritten to return the expectation E(S)
                     of the process, not exp(E(log S)).
        */
        Real expectation(Time t0, Real x0, Time dt) const override;
        Real stdDeviation(Time t0, Real x0, Time dt) const override;
        Real variance(Time t0, Real x0, Time dt) const override;
        Real evolve(Time t0, Real x0, Time dt, Real dw) const override;
        //@}
        Time time(const Date&) const override;
        //! \name Observer interface
        //@{
        void update() override;
        //@}
        //! \name Inspectors
        //@{
        const Handle<Quote>& stateVariable() const;
        const Handle<YieldTermStructure>& dividendYield() const;
        const Handle<YieldTermStructure>& riskFreeRate() const;
        const Handle<BlackVolTermStructure>& blackVolatility() const;
        const Handle<LocalVolTermStructure>& localVolatility() const;
        //@}
      private:
        Handle<Quote> x0_;
        Handle<YieldTermStructure> riskFreeRate_, dividendYield_;
        Handle<BlackVolTermStructure> blackVolatility_;
        Handle<LocalVolTermStructure> externalLocalVolTS_;
        bool forceDiscretization_;
        bool hasExternalLocalVol_;
        mutable RelinkableHandle<LocalVolTermStructure> localVolatility_;
        mutable bool updated_, isStrikeIndependent_;
    };

    //! Black-Scholes (1973) stochastic process
    /*! This class describes the stochastic process \f$ S \f$ for a stock
        given by
        \f[
            d\ln S(t) = (r(t) - \frac{\sigma(t, S)^2}{2}) dt + \sigma dW_t.
        \f]

        \warning while the interface is expressed in terms of \f$ S \f$,
                 the internal calculations work on \f$ ln S \f$.

        \ingroup processes
    */
    class BlackScholesProcess : public GeneralizedBlackScholesProcess {
      public:
        BlackScholesProcess(
            const Handle<Quote>& x0,
            const Handle<YieldTermStructure>& riskFreeTS,
            const Handle<BlackVolTermStructure>& blackVolTS,
            const ext::shared_ptr<discretization>& d =
                  ext::shared_ptr<discretization>(new EulerDiscretization),
            bool forceDiscretization = false);
    };

    //! Merton (1973) extension to the Black-Scholes stochastic process
    /*! This class describes the stochastic process ln(S) for a stock or
        stock index paying a continuous dividend yield given by
        \f[
            d\ln S(t, S) = (r(t) - q(t) - \frac{\sigma(t, S)^2}{2}) dt
                     + \sigma dW_t.
        \f]

        \ingroup processes
    */
    class BlackScholesMertonProcess : public GeneralizedBlackScholesProcess {
      public:
        BlackScholesMertonProcess(
            const Handle<Quote>& x0,
            const Handle<YieldTermStructure>& dividendTS,
            const Handle<YieldTermStructure>& riskFreeTS,
            const Handle<BlackVolTermStructure>& blackVolTS,
            const ext::shared_ptr<discretization>& d =
                  ext::shared_ptr<discretization>(new EulerDiscretization),
            bool forceDiscretization = false);
    };

    //! Black (1976) stochastic process
    /*! This class describes the stochastic process \f$ S \f$ for a
        forward or futures contract given by
        \f[
            d\ln S(t) = -\frac{\sigma(t, S)^2}{2} dt + \sigma dW_t.
        \f]

        \warning while the interface is expressed in terms of \f$ S \f$,
                 the internal calculations work on \f$ ln S \f$.

        \ingroup processes
    */
    class BlackProcess : public GeneralizedBlackScholesProcess {
      public:
        BlackProcess(
            const Handle<Quote>& x0,
            const Handle<YieldTermStructure>& riskFreeTS,
            const Handle<BlackVolTermStructure>& blackVolTS,
            const ext::shared_ptr<discretization>& d =
                  ext::shared_ptr<discretization>(new EulerDiscretization),
            bool forceDiscretization = false);
    };

    //! Garman-Kohlhagen (1983) stochastic process
    /*! This class describes the stochastic process \f$ S \f$ for an exchange
        rate given by
        \f[
            d\ln S(t) = (r(t) - r_f(t) - \frac{\sigma(t, S)^2}{2}) dt
                     + \sigma dW_t.
        \f]

        \warning while the interface is expressed in terms of \f$ S \f$,
                 the internal calculations work on \f$ ln S \f$.

        \ingroup processes
    */
    class GarmanKohlagenProcess : public GeneralizedBlackScholesProcess {
      public:
        GarmanKohlagenProcess(
            const Handle<Quote>& x0,
            const Handle<YieldTermStructure>& foreignRiskFreeTS,
            const Handle<YieldTermStructure>& domesticRiskFreeTS,
            const Handle<BlackVolTermStructure>& blackVolTS,
            const ext::shared_ptr<discretization>& d =
                  ext::shared_ptr<discretization>(new EulerDiscretization),
            bool forceDiscretization = false);
    };

}


#endif
]]></document_content>
  </document>
  <document index="4">
    <source>coxingersollrossprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Lew Wei Hao
 Copyright (C) 2021 Magnus Mencke

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file coxingersollrossprocess.hpp
    \brief CoxIngersollRoss process
*/

#ifndef quantlib_coxingersollross_process_hpp
#define quantlib_coxingersollross_process_hpp

#include <ql/stochasticprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {

    //! CoxIngersollRoss process class
    /*! This class describes the CoxIngersollRoss process governed by
        \f[
            dx(t) = k (\theta - x(t)) dt + \sigma \sqrt{x(t)} dW(t).
        \f]

        The process is discretized using the Quadratic Exponential scheme.
        For details see Leif Andersen,
        Efficient Simulation of the Heston Stochastic Volatility Model.

        \ingroup processes
    */
    class CoxIngersollRossProcess : public StochasticProcess1D {
      public:

        CoxIngersollRossProcess(Real speed,
                                 Volatility vol,
                                 Real x0 = 0.0,
                                 Real level = 0.0);
        //@{
        Real drift(Time t, Real x) const override;
        Real diffusion(Time t, Real x) const override;
        Real expectation(Time t0, Real x0, Time dt) const override;
        Real stdDeviation(Time t0, Real x0, Time dt) const override;
        //@}
        Real x0() const override;
        Real speed() const;
        Real volatility() const;
        Real level() const;
        Real variance(Time t0, Real x0, Time dt) const override;
        Real evolve (Time t0,
                     Real x0,
                     Time dt,
                     Real dw) const override;
      private:
        Real x0_, speed_, level_;
        Volatility volatility_;
    };

    // inline

    inline Real CoxIngersollRossProcess::x0() const {
        return x0_;
    }

    inline Real CoxIngersollRossProcess::speed() const {
        return speed_;
    }

    inline Real CoxIngersollRossProcess::volatility() const {
        return volatility_;
    }

    inline Real CoxIngersollRossProcess::level() const {
        return level_;
    }

    inline Real CoxIngersollRossProcess::drift(Time, Real x) const {
        return speed_ * (level_ - x);
    }

    inline Real CoxIngersollRossProcess::diffusion(Time, Real) const {
        return volatility_;
    }

    inline Real CoxIngersollRossProcess::expectation(Time, Real x0,
                                               Time dt) const {
        return level_ + (x0 - level_) * std::exp(-speed_*dt);
    }

    inline Real CoxIngersollRossProcess::stdDeviation(Time t, Real x0,
                                                Time dt) const {
        return std::sqrt(variance(t,x0,dt));
    }

    inline Real CoxIngersollRossProcess::evolve (Time t0,
      Real x0,
                                    Time dt,
                                    Real dw) const {
        Real result;

        const Real ex = std::exp(-speed_*dt);

        const Real m  =  level_+(x0-level_)*ex;
        const Real s2 =  x0*volatility_*volatility_*ex/speed_*(1-ex)
                       + level_*volatility_*volatility_/(2*speed_)*(1-ex)*(1-ex);
        const Real psi = s2/(m*m);

        if (psi <= 1.5) {
            const Real b2 = 2/psi-1+std::sqrt(2/psi*(2/psi-1));
            const Real b  = std::sqrt(b2);
            const Real a  = m/(1+b2);

            result = a*(b+dw)*(b+dw);
        }
        else {
            const Real p = (psi-1)/(psi+1);
            const Real beta = (1-p)/m;

            const Real u = CumulativeNormalDistribution()(dw);

            result = ((u <= p) ? 0.0 : Real(std::log((1-p)/(1-u))/beta));
        }

        return result;
    }

}

#endif
]]></document_content>
  </document>
  <document index="5">
    <source>endeulerdiscretization.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Frank Hövermann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file endeulerdiscretization.hpp
    \brief Euler end-point discretization for stochastic processes
*/

#ifndef quantlib_end_euler_discretization_hpp
#define quantlib_end_euler_discretization_hpp

#include <ql/stochasticprocess.hpp>

namespace QuantLib {

    //! Euler end-point discretization for stochastic processes
    /*! \ingroup processes */
    class EndEulerDiscretization
        : public StochasticProcess::discretization,
          public StochasticProcess1D::discretization {
      public:

        /*! Returns an approximation of the drift defined as
            \f$ \mu(t_0 + \Delta t, \mathbf{x}_0) \Delta t \f$.
        */
        Array drift(const StochasticProcess&, Time t0, const Array& x0, Time dt) const override;
        /*! Returns an approximation of the drift defined as
            \f$ \mu(t_0 + \Delta t, x_0) \Delta t \f$.
        */
        Real drift(const StochasticProcess1D&, Time t0, Real x0, Time dt) const override;

        /*! Returns an approximation of the diffusion defined as
            \f$ \sigma(t_0 + \Delta t, \mathbf{x}_0) \sqrt{\Delta t} \f$.
        */
        Matrix diffusion(const StochasticProcess&, Time t0, const Array& x0, Time dt) const override;
        /*! Returns an approximation of the diffusion defined as
            \f$ \sigma(t_0 + \Delta t, x_0) \sqrt{\Delta t} \f$.
        */
        Real diffusion(const StochasticProcess1D&, Time t0, Real x0, Time dt) const override;

        /*! Returns an approximation of the covariance defined as
            \f$ \sigma(t_0 + \Delta t, \mathbf{x}_0)^2 \Delta t \f$.
        */
        Matrix covariance(const StochasticProcess&, Time t0, const Array& x0, Time dt) const override;
        /*! Returns an approximation of the variance defined as
            \f$ \sigma(t_0 + \Delta t, x_0)^2 \Delta t \f$.
        */
        Real variance(const StochasticProcess1D&, Time t0, Real x0, Time dt) const override;
    };

}


#endif

]]></document_content>
  </document>
  <document index="6">
    <source>eulerdiscretization.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file eulerdiscretization.hpp
    \brief Euler discretization for stochastic processes
*/

#ifndef quantlib_euler_discretization_hpp
#define quantlib_euler_discretization_hpp

#include <ql/stochasticprocess.hpp>

namespace QuantLib {

    //! Euler discretization for stochastic processes
    /*! \ingroup processes */
    class EulerDiscretization
        : public StochasticProcess::discretization,
          public StochasticProcess1D::discretization {
      public:

        /*! Returns an approximation of the drift defined as
            \f$ \mu(t_0, \mathbf{x}_0) \Delta t \f$.
        */
        Array drift(const StochasticProcess&, Time t0, const Array& x0, Time dt) const override;
        /*! Returns an approximation of the drift defined as
            \f$ \mu(t_0, x_0) \Delta t \f$.
        */
        Real drift(const StochasticProcess1D&, Time t0, Real x0, Time dt) const override;

        /*! Returns an approximation of the diffusion defined as
            \f$ \sigma(t_0, \mathbf{x}_0) \sqrt{\Delta t} \f$.
        */
        Matrix diffusion(const StochasticProcess&, Time t0, const Array& x0, Time dt) const override;
        /*! Returns an approximation of the diffusion defined as
            \f$ \sigma(t_0, x_0) \sqrt{\Delta t} \f$.
        */
        Real diffusion(const StochasticProcess1D&, Time t0, Real x0, Time dt) const override;

        /*! Returns an approximation of the covariance defined as
            \f$ \sigma(t_0, \mathbf{x}_0)^2 \Delta t \f$.
        */
        Matrix covariance(const StochasticProcess&, Time t0, const Array& x0, Time dt) const override;
        /*! Returns an approximation of the variance defined as
            \f$ \sigma(t_0, x_0)^2 \Delta t \f$.
        */
        Real variance(const StochasticProcess1D&, Time t0, Real x0, Time dt) const override;
    };

}


#endif

]]></document_content>
  </document>
  <document index="7">
    <source>forwardmeasureprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Banca Profilo S.p.A.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file forwardmeasureprocess.hpp
    \brief forward-measure stochastic processes
*/

#ifndef quantlib_forward_measure_processes_hpp
#define quantlib_forward_measure_processes_hpp

#include <ql/stochasticprocess.hpp>

namespace QuantLib {

    //! forward-measure stochastic process
    /*! stochastic process whose dynamics are expressed in the forward
        measure.

        \ingroup processes
    */
    class ForwardMeasureProcess : public StochasticProcess {
      public:
        virtual void setForwardMeasureTime(Time);
        Time getForwardMeasureTime() const;
      protected:
        ForwardMeasureProcess() = default;
        explicit ForwardMeasureProcess(Time T) : T_(T) {}
        explicit ForwardMeasureProcess(
                                   const ext::shared_ptr<discretization>&);
        Time T_;
    };

    //! forward-measure 1-D stochastic process
    /*! 1-D stochastic process whose dynamics are expressed in the
        forward measure.

        \ingroup processes
    */
    class ForwardMeasureProcess1D : public StochasticProcess1D {
      public:
        virtual void setForwardMeasureTime(Time);
        Time getForwardMeasureTime() const;
      protected:
        ForwardMeasureProcess1D() = default;
        explicit ForwardMeasureProcess1D(Time T) : T_(T) {}
        explicit ForwardMeasureProcess1D(
                                    const ext::shared_ptr<discretization>&);
        Time T_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="8">
    <source>g2process.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Banca Profilo S.p.A.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file g2process.hpp
    \brief G2 stochastic processes
*/

#ifndef quantlib_g2_process_hpp
#define quantlib_g2_process_hpp

#include <ql/processes/forwardmeasureprocess.hpp>
#include <ql/processes/ornsteinuhlenbeckprocess.hpp>

namespace QuantLib {

    //! %G2 stochastic process
    /*! \ingroup processes */
    class G2Process : public StochasticProcess {
      public:
        G2Process(Real a, Real sigma, Real b, Real eta, Real rho);
        //! \name StochasticProcess interface
        //@{
        Size size() const override;
        Array initialValues() const override;
        Array drift(Time t, const Array& x) const override;
        Matrix diffusion(Time t, const Array& x) const override;
        Array expectation(Time t0, const Array& x0, Time dt) const override;
        Matrix stdDeviation(Time t0, const Array& x0, Time dt) const override;
        Matrix covariance(Time t0, const Array& x0, Time dt) const override;
        //@}
        Real x0() const;
        Real y0() const;
        Real a() const;
        Real sigma() const;
        Real b() const;
        Real eta() const;
        Real rho() const;
      private:
        Real x0_ = 0.0, y0_ = 0.0, a_, sigma_, b_, eta_, rho_;
        ext::shared_ptr<QuantLib::OrnsteinUhlenbeckProcess> xProcess_;
        ext::shared_ptr<QuantLib::OrnsteinUhlenbeckProcess> yProcess_;
    };

    //! %Forward %G2 stochastic process
    /*! \ingroup processes */
    class G2ForwardProcess : public ForwardMeasureProcess {
      public:
        G2ForwardProcess(Real a, Real sigma, Real b, Real eta, Real rho);
        //! \name StochasticProcess interface
        //@{
        Size size() const override;
        Array initialValues() const override;
        Array drift(Time t, const Array& x) const override;
        Matrix diffusion(Time t, const Array& x) const override;
        Array expectation(Time t0, const Array& x0, Time dt) const override;
        Matrix stdDeviation(Time t0, const Array& x0, Time dt) const override;
        Matrix covariance(Time t0, const Array& x0, Time dt) const override;
        //@}
      protected:
        Real x0_ = 0.0, y0_ = 0.0, a_, sigma_, b_, eta_, rho_;
        ext::shared_ptr<QuantLib::OrnsteinUhlenbeckProcess> xProcess_;
        ext::shared_ptr<QuantLib::OrnsteinUhlenbeckProcess> yProcess_;
        Real xForwardDrift(Time t, Time T) const;
        Real yForwardDrift(Time t, Time T) const;
        Real Mx_T(Real s, Real t, Real T) const;
        Real My_T(Real s, Real t, Real T) const;
    };

}


#endif

]]></document_content>
  </document>
  <document index="9">
    <source>geometricbrownianprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file geometricbrownianprocess.hpp
    \brief Geometric Brownian-motion process
*/

#ifndef quantlib_geometric_brownian_process_hpp
#define quantlib_geometric_brownian_process_hpp

#include <ql/stochasticprocess.hpp>

namespace QuantLib {

    //! Geometric brownian-motion process
    /*! This class describes the stochastic process governed by
        \f[
            dS(t, S)= \mu S dt + \sigma S dW_t.
        \f]

        \ingroup processes
    */
    class GeometricBrownianMotionProcess : public StochasticProcess1D {
      public:
        GeometricBrownianMotionProcess(Real initialValue,
                                       Real mue,
                                       Real sigma);
        Real x0() const override;
        Real drift(Time t, Real x) const override;
        Real diffusion(Time t, Real x) const override;

      protected:
        Real initialValue_;
        Real mue_;
        Real sigma_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="10">
    <source>gjrgarchprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Yee Man Chan

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gjrgarchprocess.hpp
    \brief GJR-GARCH(1,1) stochastic process
*/

#ifndef quantlib_gjrgarch_process_hpp
#define quantlib_gjrgarch_process_hpp

#include <ql/stochasticprocess.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/quote.hpp>

namespace QuantLib {

    //! Stochastic-volatility GJR-GARCH(1,1) process
    // parameters supplied should be daily constants
    // they are annualized by setting the parameter daysPerYear
    /*! This class describes the stochastic volatility
        process governed by
        \f[
        \begin{array}{rcl}
        dS(t, S)  &=& \mu S dt + \sqrt{v} S dW_1 \\
        dv(t, S)  &=& (\omega + (\beta + \alpha * q_{2} 
        + \gamma * q_{3} - 1) v) dt + (\alpha \sigma_{12} 
        + \gamma \sigma_{13}) v dW_1 
        + \sqrt{\alpha^{2} (\sigma^{2}_{2} - \sigma^{2}_{12}) 
        + \gamma^{2} (\sigma^{2}_{3} - \sigma^{2}_{13}) 
        + 2 \alpha \gamma (\sigma_{23} - \sigma_{12} \sigma_{13})} v dW_2 \ \
        N = normalCDF(\lambda) \\
        n &=& \exp{-\lambda^{2}/2} / \sqrt{2 \pi} \\
        q_{2} &=& 1 + \lambda^{2} \\
        q_{3} &=& \lambda n + N + \lambda^2 N \\
        \sigma^{2}_{2} = 2 + 4 \lambda^{4} \\
        \sigma^{2}_{3} = \lambda^{3} n + 5 \lambda n + 3N 
        + \lambda^{4} N + 6 \lambda^{2} N -\\lambda^{2} n^{2} - N^{2} 
        - \lambda^{4} N^{2} - 2 \lambda n N - 2 \lambda^{3} nN 
        - 2 \lambda^{2} N^{2} \                 \
        \sigma_{12} = -2 \lambda \\
        \sigma_{13} = -2 n - 2 \lambda N \\
        \sigma_{23} = 2N + \sigma_{12} \sigma_{13} \\
        \end{array}
        \f]

        \ingroup processes
    */
    class GJRGARCHProcess : public StochasticProcess {
      public:
        enum Discretization { PartialTruncation, FullTruncation,
                              Reflection};

        GJRGARCHProcess(Handle<YieldTermStructure> riskFreeRate,
                        Handle<YieldTermStructure> dividendYield,
                        Handle<Quote> s0,
                        Real v0,
                        Real omega,
                        Real alpha,
                        Real beta,
                        Real gamma,
                        Real lambda,
                        Real daysPerYear = 252.0,
                        Discretization d = FullTruncation);

        Size size() const override;
        Array initialValues() const override;
        Array drift(Time t, const Array& x) const override;
        Matrix diffusion(Time t, const Array& x) const override;
        Array apply(const Array& x0, const Array& dx) const override;
        Array evolve(Time t0, const Array& x0, Time dt, const Array& dw) const override;

        Real v0()     const { return v0_; }
        Real lambda() const { return lambda_; }
        Real omega()  const { return omega_; }
        Real alpha()  const { return alpha_; }
        Real beta()   const { return beta_; }
        Real gamma()  const { return gamma_; }
        Real daysPerYear()  const { return daysPerYear_; }

        const Handle<Quote>& s0() const;
        const Handle<YieldTermStructure>& dividendYield() const;
        const Handle<YieldTermStructure>& riskFreeRate() const;

        Time time(const Date&) const override;

      private:
        Handle<YieldTermStructure> riskFreeRate_, dividendYield_;
        Handle<Quote> s0_;
        Real v0_, omega_, alpha_, beta_, gamma_, lambda_, daysPerYear_;
        Discretization discretization_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="11">
    <source>gsrprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gsrprocess.hpp
    \brief GSR model process with piecewise volatilities and mean reversions,
           the dynamic is expressed in some T-forward measure.
           If a single value for the mean reversion is provided, it is assumed
           constant. Results are cached for performance reasons, so if parameters
           change you need to call flushCache() to avoid inconsistent results.
           For a derivation of the formulas, see http://ssrn.com/abstract=2246013
*/

#ifndef quantlib_gsr_process_hpp
#define quantlib_gsr_process_hpp

#include <ql/processes/forwardmeasureprocess.hpp>
#include <ql/processes/gsrprocesscore.hpp>
#include <ql/time/daycounter.hpp>

namespace QuantLib {

    //! GSR stochastic process
    /*! \ingroup processes */
    class GsrProcess : public ForwardMeasureProcess1D {
      public:
        GsrProcess(Array times,
                   Array vols,
                   Array reversions,
                   Real T = 60.0,
                   const Date& referenceDate = Date(),
                   DayCounter dc = DayCounter());
        //! \name StochasticProcess1D interface
        //@{
        Real x0() const override;
        Real drift(Time t, Real x) const override;
        Real diffusion(Time t, Real) const override;
        Real expectation(Time t0, Real x0, Time dt) const override;
        Real stdDeviation(Time t0, Real x0, Time dt) const override;
        Real variance(Time t0, Real, Time dt) const override;
        Real time(const Date& d) const override;
        //@}
        //! \name ForwardMeasureProcess1D interface
        //@{
        void setForwardMeasureTime(Time t) override;
        //@}
        //! additional inspectors
        //@{
        Real sigma(Time t) const;
        Real reversion(Time t) const;
        Real y(Time t) const;
        Real G(Time t, Time T, Real x) const;
        //@}
        //! reset cache
        void flushCache() const;

      private:
        friend class Gsr;
        void setTimes(Array times) { core_.setTimes(std::move(times)); }
        void setVols(Array vols) { core_.setVols(std::move(vols)); }
        void setReversions(Array reversions) { core_.setReversions(std::move(reversions)); }
        void checkT(Time t) const;
        detail::GsrProcessCore core_;
        Date referenceDate_;
        DayCounter dc_;
    };

    // inline definitions

    inline void GsrProcess::setForwardMeasureTime(Time t) {
        flushCache();
        ForwardMeasureProcess1D::setForwardMeasureTime(t);
    }

    inline void GsrProcess::flushCache() const {
        core_.flushCache();
    }

} // namesapce QuantLib

#endif
]]></document_content>
  </document>
  <document index="12">
    <source>gsrprocesscore.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gsrprocesscore.hpp
    \brief Core computations for the gsr process in risk neutral
           and T-forward measure.
    \warning Results are cached for performance reasons, so if
             parameters change, you need to call flushCache() to
             avoid inconsistent results.
*/

#ifndef quantlib_gsr_process_core_hpp
#define quantlib_gsr_process_core_hpp

#include <ql/math/array.hpp>
#include <ql/math/comparison.hpp>
#include <map>

namespace QuantLib {

class GsrProcess;

namespace detail {

class GsrProcessCore {
  public:
    GsrProcessCore(Array times, Array vols, Array reversions, Real T = 60.0);

    // conditional expectation, x0 dependent part
    Real expectation_x0dep_part(Time w, Real xw, Time dt) const;

    // conditional expectation, x0 independent part
    // in the risk neutral measure
    Real expectation_rn_part(Time w, Time dt) const;

    // conditional expectation, drift adjustment for
    // the T-forward measure
    Real expectation_tf_part(Time w, Time dt) const;

    // conditional variance
    Real variance(Time w, Time dt) const;

    // y(t)
    Real y(Time t) const;

    // G(t,w)
    Real G(Time t, Time w) const;

    // sigma
    Real sigma(Time t) const;

    // reversion
    Real reversion(Time t) const;

    // reset cache
    void flushCache() const;

  protected:
    Array times_, vols_, reversions_;

  private:
    friend class QuantLib::GsrProcess;
    void setTimes(Array times);
    void setVols(Array vols);
    void setReversions(Array reversions);
    void checkTimesVolsReversions() const;
    int lowerIndex(Time t) const;
    int upperIndex(Time t) const;
    Real time2(Size index) const;
    Real cappedTime(Size index, Real cap = Null<Real>()) const;
    Real flooredTime(Size index, Real floor = Null<Real>()) const;
    Real vol(Size index) const;
    Real rev(Size index) const;
    bool revZero(Size index) const;

    mutable std::map<std::pair<Real, Real>, Real> cache1_, cache2a_, cache2b_,
        cache3_, cache5_;
    mutable std::map<Real, Real> cache4_;
    Time T_;
    mutable std::vector<bool> revZero_;
}; // GsrProcessCore

// inline definitions

inline Real GsrProcessCore::sigma(const Time t) const {
    return vol(lowerIndex(t));
}

inline Real GsrProcessCore::reversion(const Time t) const {
    return rev(lowerIndex(t));
}

} // namespace detail
} // namespace QuantLib

#endif
]]></document_content>
  </document>
  <document index="13">
    <source>hestonprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2007, 2009, 2014 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hestonprocess.hpp
    \brief Heston stochastic process
*/

#ifndef quantlib_heston_process_hpp
#define quantlib_heston_process_hpp

#include <ql/stochasticprocess.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/quote.hpp>

namespace QuantLib {

    //! Square-root stochastic-volatility Heston process
    /*! This class describes the square root stochastic volatility
        process governed by
        \f[
        \begin{array}{rcl}
        dS(t, S)  &=& \mu S dt + \sqrt{v} S dW_1 \\
        dv(t, S)  &=& \kappa (\theta - v) dt + \sigma \sqrt{v} dW_2 \\
        dW_1 dW_2 &=& \rho dt
        \end{array}
        \f]

        \ingroup processes
    */
    class HestonProcess : public StochasticProcess {
      public:
        enum Discretization { PartialTruncation,
                              FullTruncation,
                              Reflection,
                              NonCentralChiSquareVariance,
                              QuadraticExponential,
                              QuadraticExponentialMartingale,
                              BroadieKayaExactSchemeLobatto,
                              BroadieKayaExactSchemeLaguerre,
                              BroadieKayaExactSchemeTrapezoidal };

        HestonProcess(Handle<YieldTermStructure> riskFreeRate,
                      Handle<YieldTermStructure> dividendYield,
                      Handle<Quote> s0,
                      Real v0,
                      Real kappa,
                      Real theta,
                      Real sigma,
                      Real rho,
                      Discretization d = QuadraticExponentialMartingale);

        Size size() const override;
        Size factors() const override;

        Array initialValues() const override;
        Array drift(Time t, const Array& x) const override;
        Matrix diffusion(Time t, const Array& x) const override;
        Array apply(const Array& x0, const Array& dx) const override;
        Array evolve(Time t0, const Array& x0, Time dt, const Array& dw) const override;

        Real v0()    const { return v0_; }
        Real rho()   const { return rho_; }
        Real kappa() const { return kappa_; }
        Real theta() const { return theta_; }
        Real sigma() const { return sigma_; }

        const Handle<Quote>& s0() const;
        const Handle<YieldTermStructure>& dividendYield() const;
        const Handle<YieldTermStructure>& riskFreeRate() const;

        Time time(const Date&) const override;

        // probability densitiy function,
        // semi-analytical solution of the Fokker-Planck equation in x=ln(s)
        Real pdf(Real x, Real v, Time t, Real eps=1e-3) const;

      private:
        Real varianceDistribution(Real v, Real dw, Time dt) const;

        Handle<YieldTermStructure> riskFreeRate_, dividendYield_;
        Handle<Quote> s0_;
        Real v0_, kappa_, theta_, sigma_, rho_;
        Discretization discretization_;
    };
}
#endif
]]></document_content>
  </document>
  <document index="14">
    <source>hestonslvprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes Göttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hestonslvprocess.hpp
    \brief Heston stochastic local volatility process
*/

#ifndef quantlib_heston_slv_process_hpp
#define quantlib_heston_slv_process_hpp

#include <ql/processes/hestonprocess.hpp>
#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>

namespace QuantLib {

    class HestonSLVProcess : public StochasticProcess {
      public:
        HestonSLVProcess(const ext::shared_ptr<HestonProcess>& hestonProcess,
                         ext::shared_ptr<LocalVolTermStructure> leverageFct,
                         Real mixingFactor = 1.0);

        Size size() const override { return Size(2); }
        Size factors() const override { return Size(2); }

        void update() override;

        Array initialValues() const override {
            return hestonProcess_->initialValues();
        }
        Array apply(const Array& x0, const Array& dx) const override {
            return hestonProcess_->apply(x0, dx);
        }

        Array drift(Time t, const Array& x) const override;
        Matrix diffusion(Time t, const Array& x) const override;
        Array evolve(Time t0, const Array& x0, Time dt, const Array& dw) const override;

        Real v0()    const { return v0_; }
        Real rho()   const { return rho_; }
        Real kappa() const { return kappa_; }
        Real theta() const { return theta_; }
        Real sigma() const { return sigma_; }
        Real mixingFactor() const { return mixingFactor_; }
        ext::shared_ptr<LocalVolTermStructure> leverageFct() const {
            return leverageFct_;
        }

        const Handle<Quote>& s0() const { return hestonProcess_->s0(); }
        const Handle<YieldTermStructure>& dividendYield() const {
            return hestonProcess_->dividendYield();
        }
        const Handle<YieldTermStructure>& riskFreeRate() const {
            return hestonProcess_->riskFreeRate();
        }

        Time time(const Date& d) const override { return hestonProcess_->time(d); }

      private:
        Real kappa_, theta_, sigma_, rho_, v0_, mixingFactor_, mixedSigma_;

        const ext::shared_ptr<HestonProcess> hestonProcess_;
        const ext::shared_ptr<LocalVolTermStructure> leverageFct_;

        void setParameters();
    };

}

#endif
]]></document_content>
  </document>
  <document index="15">
    <source>hullwhiteprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Banca Profilo S.p.A.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hullwhiteprocess.hpp
    \brief Hull-White stochastic processes
*/

#ifndef quantlib_hull_white_processes_hpp
#define quantlib_hull_white_processes_hpp

#include <ql/processes/forwardmeasureprocess.hpp>
#include <ql/processes/ornsteinuhlenbeckprocess.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>

namespace QuantLib {

    //! Hull-White stochastic process
    /*! \ingroup processes */
    class HullWhiteProcess: public StochasticProcess1D {
      public:
        HullWhiteProcess(const Handle<YieldTermStructure>& h,
                         Real a,
                         Real sigma);
        //! \name StochasticProcess1D interface
        //@{
        Real x0() const override;
        Real drift(Time t, Real x) const override;
        Real diffusion(Time t, Real x) const override;
        Real expectation(Time t0, Real x0, Time dt) const override;
        Real stdDeviation(Time t0, Real x0, Time dt) const override;
        Real variance(Time t0, Real x0, Time dt) const override;

        Real a() const;
        Real sigma() const;
        Real alpha(Time t) const;
        //@}
    protected:
        ext::shared_ptr<QuantLib::OrnsteinUhlenbeckProcess> process_;
        Handle<YieldTermStructure> h_;
        Real a_, sigma_;
    };

    //! %Forward Hull-White stochastic process
    /*! \ingroup processes */
    class HullWhiteForwardProcess: public ForwardMeasureProcess1D {
      public:
        HullWhiteForwardProcess(const Handle<YieldTermStructure>& h,
                                Real a,
                                Real sigma);
        //! \name StochasticProcess1D interface
        //@{
        Real x0() const override;
        Real drift(Time t, Real x) const override;
        Real diffusion(Time t, Real x) const override;
        Real expectation(Time t0, Real x0, Time dt) const override;
        Real stdDeviation(Time t0, Real x0, Time dt) const override;
        Real variance(Time t0, Real x0, Time dt) const override;
        //@}

        Real a() const;
        Real sigma() const;
        Real alpha(Time t) const;
        Real M_T(Real s, Real t, Real T) const;
        Real B(Time t, Time T) const;

    protected:
        ext::shared_ptr<QuantLib::OrnsteinUhlenbeckProcess> process_;
        Handle<YieldTermStructure> h_;
        Real a_, sigma_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="16">
    <source>hybridhestonhullwhiteprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hybridhestonhullwhiteprocess.hpp
    \brief hybrid equity (heston model)
           with stochastic interest rates (hull white model)
*/

#ifndef quantlib_hybrid_heston_hull_white_process_hpp
#define quantlib_hybrid_heston_hull_white_process_hpp

#include <ql/processes/hestonprocess.hpp>
#include <ql/processes/hullwhiteprocess.hpp>
#include <ql/processes/jointstochasticprocess.hpp>
#include <ql/models/shortrate/onefactormodels/hullwhite.hpp>

namespace QuantLib {
    //! Hybrid Heston Hull-White stochastic process
    /*! This class implements a three factor Heston Hull-White model

        \bug This class was not tested enough to guarantee
             its functionality... work in progress

        \ingroup processes
    */
    class HybridHestonHullWhiteProcess : public StochasticProcess {
      public:
        enum Discretization { Euler, BSMHullWhite };

        HybridHestonHullWhiteProcess(
          const ext::shared_ptr<HestonProcess> & hestonProcess,
          const ext::shared_ptr<HullWhiteForwardProcess> & hullWhiteProcess,
          Real corrEquityShortRate,
          Discretization discretization = BSMHullWhite);

        Size size() const override;
        Array initialValues() const override;
        Array drift(Time t, const Array& x) const override;
        Matrix diffusion(Time t, const Array& x) const override;
        Array apply(const Array& x0, const Array& dx) const override;

        Array evolve(Time t0, const Array& x0, Time dt, const Array& dw) const override;

        DiscountFactor numeraire(Time t, const Array& x) const;

        const ext::shared_ptr<HestonProcess>& hestonProcess() const;
        const ext::shared_ptr<HullWhiteForwardProcess>& hullWhiteProcess() const;

        Real eta() const;
        Time time(const Date& date) const override;
        Discretization discretization() const;
        void update() override;

      protected:
        const ext::shared_ptr<HestonProcess> hestonProcess_;
        const ext::shared_ptr<HullWhiteForwardProcess> hullWhiteProcess_;
        
        //model is used to calculate P(t,T)
        const ext::shared_ptr<HullWhite> hullWhiteModel_;

        const Real corrEquityShortRate_;
        const Discretization discretization_;
        const Real maxRho_;
        const Time T_;
        DiscountFactor endDiscount_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="17">
    <source>jointstochasticprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file jointstochasticprocess.hpp
    \brief multi model process for hybrid products
*/

#ifndef quantlib_joint_stochastic_process_hpp
#define quantlib_joint_stochastic_process_hpp

#include <ql/utilities/null.hpp>
#include <ql/stochasticprocess.hpp>
#include <vector>
#include <map>

namespace QuantLib {

    class JointStochasticProcess : public StochasticProcess {
      public:
        JointStochasticProcess(std::vector<ext::shared_ptr<StochasticProcess> > l,
                               Size factors = Null<Size>());

        Size size() const override;
        Size factors() const override;

        Array initialValues() const override;
        Array drift(Time t, const Array& x) const override;
        Array expectation(Time t0, const Array& x0, Time dt) const override;

        Matrix diffusion(Time t, const Array& x) const override;
        Matrix covariance(Time t0, const Array& x0, Time dt) const override;
        Matrix stdDeviation(Time t0, const Array& x0, Time dt) const override;

        Array apply(const Array& x0, const Array& dx) const override;
        Array evolve(Time t0, const Array& x0, Time dt, const Array& dw) const override;

        virtual void preEvolve(Time t0, const Array& x0,
                               Time dt, const Array& dw) const = 0;
        virtual Array postEvolve(Time t0, const Array& x0,
                                 Time dt, const Array& dw,
                                 const Array& y0) const = 0;

        virtual DiscountFactor numeraire(Time t, const Array& x) const = 0;
        virtual bool correlationIsStateDependent() const = 0;
        virtual Matrix crossModelCorrelation(Time t0, const Array& x0) const = 0;

        const std::vector<ext::shared_ptr<StochasticProcess> > &
                                                       constituents() const;

        void update() override;
        Time time(const Date& date) const override;

      protected:
        std::vector<ext::shared_ptr<StochasticProcess> > l_;
        Array slice(const Array& x, Size i) const;

      private:
        typedef
            std::vector<ext::shared_ptr<StochasticProcess> >::const_iterator
            const_iterator;

        typedef std::vector<ext::shared_ptr<StochasticProcess> >::iterator
            iterator;

        Size size_ = 0, factors_, modelFactors_ = 0;
        std::vector<Size> vsize_, vfactors_;

        struct CachingKey {
            CachingKey(const Time t0, const Time dt)
                : t0_(t0), dt_(dt) {}

            bool operator<(const CachingKey& key) const {
                return   t0_ < key.t0_ 
                    || ( t0_ == key.t0_ && dt_ < key.dt_); 
            }
            Time t0_;
            Time dt_;
        };

        mutable std::map<CachingKey, Matrix> correlationCache_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="18">
    <source>merton76process.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file merton76process.hpp
    \brief Merton-76 process
*/

#ifndef quantlib_merton_76_process_hpp
#define quantlib_merton_76_process_hpp

#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/eulerdiscretization.hpp>

namespace QuantLib {

    //! Merton-76 jump-diffusion process
    /*! \ingroup processes */
    class Merton76Process : public StochasticProcess1D {
      public:
        Merton76Process(const Handle<Quote>& stateVariable,
                        const Handle<YieldTermStructure>& dividendTS,
                        const Handle<YieldTermStructure>& riskFreeTS,
                        const Handle<BlackVolTermStructure>& blackVolTS,
                        Handle<Quote> jumpInt,
                        Handle<Quote> logJMean,
                        Handle<Quote> logJVol,
                        const ext::shared_ptr<discretization>& d =
                            ext::shared_ptr<discretization>(new EulerDiscretization));
        //! \name StochasticProcess1D interface
        //@{
        Real x0() const override;
        Real drift(Time, Real) const override { QL_FAIL("Merton76Process does not implement drift"); }
        Real diffusion(Time, Real) const override { QL_FAIL("Merton76Process does not implement diffusion"); }
        Real apply(Real, Real) const override { QL_FAIL("Merton76Process does not implement apply"); }
        //@}
        Time time(const Date&) const override;
        //! \name Inspectors
        //@{
        const Handle<Quote>& stateVariable() const;
        const Handle<YieldTermStructure>& dividendYield() const;
        const Handle<YieldTermStructure>& riskFreeRate() const;
        const Handle<BlackVolTermStructure>& blackVolatility() const;
        const Handle<Quote>& jumpIntensity() const;
        const Handle<Quote>& logMeanJump() const;
        const Handle<Quote>& logJumpVolatility() const;
        //@}
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> blackProcess_;
        Handle<Quote> jumpIntensity_, logMeanJump_, logJumpVolatility_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="19">
    <source>mfstateprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mfstateprocess.hpp
    \brief State process for markov functional model
*/

#ifndef quantlib_mfstateprocess_hpp
#define quantlib_mfstateprocess_hpp

#include <ql/stochasticprocess.hpp>

namespace QuantLib {

    class MarkovFunctional;

    //! Markov functional state process class
    /*! This class describes the process governed by
        \f[ dx = \sigma(t) e^{at} dW(t) \f]
        \ingroup processes
    */
    class MfStateProcess : public StochasticProcess1D {
      public:
        MfStateProcess(Real reversion, Array times, Array vols);

        //! \name StochasticProcess interface
        //@{
        Real x0() const override;
        Real drift(Time t, Real x) const override;
        Real diffusion(Time t, Real x) const override;
        Real expectation(Time t0, Real x0, Time dt) const override;
        Real stdDeviation(Time t0, Real x0, Time dt) const override;
        Real variance(Time t0, Real x0, Time dt) const override;
        //@}

      private:
        friend class MarkovFunctional;
        void setTimes(Array times);
        void setVols(Array vols);
        void checkTimesVols() const;
        Real reversion_;
        bool reversionZero_ = false;
        Array times_;
        Array vols_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="20">
    <source>ornsteinuhlenbeckprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file ornsteinuhlenbeckprocess.hpp
    \brief Ornstein-Uhlenbeck process
*/

#ifndef quantlib_ornstein_uhlenbeck_process_hpp
#define quantlib_ornstein_uhlenbeck_process_hpp

#include <ql/stochasticprocess.hpp>

namespace QuantLib {

    //! Ornstein-Uhlenbeck process class
    /*! This class describes the Ornstein-Uhlenbeck process governed by
        \f[
            dx = a (r - x_t) dt + \sigma dW_t.
        \f]

        \ingroup processes
    */
    class OrnsteinUhlenbeckProcess : public StochasticProcess1D {
      public:
        OrnsteinUhlenbeckProcess(Real speed,
                                 Volatility vol,
                                 Real x0 = 0.0,
                                 Real level = 0.0);
        //! \name StochasticProcess interface
        //@{
        Real drift(Time t, Real x) const override;
        Real diffusion(Time t, Real x) const override;
        Real expectation(Time t0, Real x0, Time dt) const override;
        Real stdDeviation(Time t0, Real x0, Time dt) const override;
        //@}
        Real x0() const override;
        Real speed() const;
        Real volatility() const;
        Real level() const;
        Real variance(Time t0, Real x0, Time dt) const override;

      private:
        Real x0_, speed_, level_;
        Volatility volatility_;
    };

    // inline

    inline Real OrnsteinUhlenbeckProcess::x0() const {
        return x0_;
    }

    inline Real OrnsteinUhlenbeckProcess::speed() const {
        return speed_;
    }

    inline Real OrnsteinUhlenbeckProcess::volatility() const {
        return volatility_;
    }

    inline Real OrnsteinUhlenbeckProcess::level() const {
        return level_;
    }

    inline Real OrnsteinUhlenbeckProcess::drift(Time, Real x) const {
        return speed_ * (level_ - x);
    }

    inline Real OrnsteinUhlenbeckProcess::diffusion(Time, Real) const {
        return volatility_;
    }

    inline Real OrnsteinUhlenbeckProcess::expectation(Time, Real x0,
                                               Time dt) const {
        return level_ + (x0 - level_) * std::exp(-speed_*dt);
    }

    inline Real OrnsteinUhlenbeckProcess::stdDeviation(Time t, Real x0,
                                                Time dt) const {
        return std::sqrt(variance(t,x0,dt));
    }

}

#endif
]]></document_content>
  </document>
  <document index="21">
    <source>squarerootprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file squarerootprocess.hpp
    \brief square-root process
*/

#ifndef quantlib_square_root_process_hpp
#define quantlib_square_root_process_hpp

#include <ql/stochasticprocess.hpp>
#include <ql/processes/eulerdiscretization.hpp>

namespace QuantLib {

    //! Square-root process class
    /*! This class describes a square-root process governed by
        \f[
            dx = a (b - x_t) dt + \sigma \sqrt{x_t} dW_t.
        \f]

        \ingroup processes
    */
    class SquareRootProcess : public StochasticProcess1D {
      public:
        SquareRootProcess(
            Real b, Real a, Volatility sigma, Real x0 = 0.0,
            const ext::shared_ptr<discretization>& d =
                  ext::shared_ptr<discretization>(new EulerDiscretization));
        //! \name StochasticProcess interface
        //@{
        Real x0() const override;
        Real drift(Time t, Real x) const override;
        Real diffusion(Time t, Real x) const override;
        //@}

        Real a() const { return speed_;  }
        Real b() const { return mean_; }
        Real sigma() const { return volatility_; }
      private:
        Real x0_, mean_, speed_;
        Volatility volatility_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="22">
    <source>stochasticprocessarray.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Klaus Spanderen
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file stochasticprocessarray.hpp
    \brief Array of correlated 1-D stochastic processes
*/

#ifndef quantlib_stochastic_process_array_hpp
#define quantlib_stochastic_process_array_hpp

#include <ql/stochasticprocess.hpp>
#include <vector>

namespace QuantLib {

    //! %Array of correlated 1-D stochastic processes
    /*! \ingroup processes */
    class StochasticProcessArray : public StochasticProcess {
      public:
        StochasticProcessArray(
                  const std::vector<ext::shared_ptr<StochasticProcess1D> >&,
                  const Matrix& correlation);
        // stochastic process interface
        Size size() const override;
        Array initialValues() const override;
        Array drift(Time t, const Array& x) const override;
        Array expectation(Time t0, const Array& x0, Time dt) const override;

        Matrix diffusion(Time t, const Array& x) const override;
        Matrix covariance(Time t0, const Array& x0, Time dt) const override;
        Matrix stdDeviation(Time t0, const Array& x0, Time dt) const override;

        Array apply(const Array& x0, const Array& dx) const override;
        Array evolve(Time t0, const Array& x0, Time dt, const Array& dw) const override;

        Time time(const Date&) const override;
        // inspectors
        const ext::shared_ptr<StochasticProcess1D>& process(Size i) const;
        Matrix correlation() const;
      protected:
        std::vector<ext::shared_ptr<StochasticProcess1D> > processes_;
        Matrix sqrtCorrelation_;
    };

}


#endif
]]></document_content>
  </document>
</documents>