<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/calibrationhelper.hpp>
#include <ql/models/model.hpp>
#include <ql/models/parameter.hpp>

#include <ql/models/equity/all.hpp>
#include <ql/models/marketmodels/all.hpp>
#include <ql/models/shortrate/all.hpp>
#include <ql/models/volatility/all.hpp>
]]></document_content>
  </document>
  <document index="2">
    <source>calibrationhelper.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file calibrationhelper.hpp
    \brief Calibration helper class
*/

#ifndef quantlib_interest_rate_modelling_calibration_helper_h
#define quantlib_interest_rate_modelling_calibration_helper_h

#include <ql/patterns/lazyobject.hpp>
#include <ql/quote.hpp>
#include <ql/termstructures/volatility/volatilitytype.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <list>
#include <utility>

namespace QuantLib {

    class PricingEngine;

    //! abstract base class for calibration helpers
    class CalibrationHelper {
      public:
        virtual ~CalibrationHelper() = default;
        //! returns the error resulting from the model valuation
        virtual Real calibrationError() = 0;
    };

    //! liquid Black76 market instrument used during calibration
    class BlackCalibrationHelper : public LazyObject, public CalibrationHelper {
      public:
        enum CalibrationErrorType {
                            RelativePriceError, PriceError, ImpliedVolError};

        BlackCalibrationHelper(Handle<Quote> volatility,
                               CalibrationErrorType calibrationErrorType = RelativePriceError,
                               const VolatilityType type = ShiftedLognormal,
                               const Real shift = 0.0)
        : volatility_(std::move(volatility)), volatilityType_(type), shift_(shift),
          calibrationErrorType_(calibrationErrorType) {
            registerWith(volatility_);
        }

        void performCalculations() const override {
            marketValue_ = blackPrice(volatility_->value());
        }

        //! returns the volatility Handle
        Handle<Quote> volatility() const { return volatility_; }

        //! returns the volatility type
        VolatilityType volatilityType() const { return volatilityType_; }

        //! returns the actual price of the instrument (from volatility)
        Real marketValue() const { calculate(); return marketValue_; }

        //! returns the price of the instrument according to the model
        virtual Real modelValue() const = 0;

        //! returns the error resulting from the model valuation
        Real calibrationError() override;

        virtual void addTimesTo(std::list<Time>& times) const = 0;

        //! Black volatility implied by the model
        Volatility impliedVolatility(Real targetValue,
                                     Real accuracy,
                                     Size maxEvaluations,
                                     Volatility minVol,
                                     Volatility maxVol) const;

        //! Black or Bachelier price given a volatility
        virtual Real blackPrice(Volatility volatility) const = 0;

        void setPricingEngine(const ext::shared_ptr<PricingEngine>& engine) {
            engine_ = engine;
        }

      protected:
        mutable Real marketValue_;
        Handle<Quote> volatility_;
        ext::shared_ptr<PricingEngine> engine_;
        const VolatilityType volatilityType_;
        const Real shift_;

      private:
        const CalibrationErrorType calibrationErrorType_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="3">
    <source>equity/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/equity/batesmodel.hpp>
#include <ql/models/equity/gjrgarchmodel.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/models/equity/hestonmodelhelper.hpp>
#include <ql/models/equity/hestonslvfdmmodel.hpp>
#include <ql/models/equity/hestonslvmcmodel.hpp>
#include <ql/models/equity/piecewisetimedependenthestonmodel.hpp>

]]></document_content>
  </document>
  <document index="4">
    <source>equity/batesmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file batesmodel.hpp
    \brief extended versions of the Heston model
*/

#ifndef quantlib_bates_model_hpp
#define quantlib_bates_model_hpp

#include <ql/processes/batesprocess.hpp>
#include <ql/models/equity/hestonmodel.hpp>

namespace QuantLib {

    //! Bates stochastic-volatility model
    /*! extended versions of Heston model for the stochastic
        volatility of an asset including jumps.

        References:
        A. Sepp, Pricing European-Style Options under Jump Diffusion
        Processes with Stochastic Volatility: Applications of Fourier
        Transform (<http://math.ut.ee/~spartak/papers/stochjumpvols.pdf>)

        \test calibration is tested against known values.
    */
    class BatesModel : public HestonModel {
      public:
        explicit BatesModel(const ext::shared_ptr<BatesProcess> & process);

        Real nu()     const { return arguments_[5](0.0); }
        Real delta()  const { return arguments_[6](0.0); }
        Real lambda() const { return arguments_[7](0.0); }

      protected:
        void generateArguments() override;
    };


    class BatesDetJumpModel : public BatesModel {
      public:
        explicit BatesDetJumpModel(
            const ext::shared_ptr<BatesProcess> & process,
            Real kappaLambda = 1.0, Real thetaLambda = 0.1);

        Real kappaLambda() const { return arguments_[8](0.0); }
        Real thetaLambda() const { return arguments_[9](0.0); }
    };


    class BatesDoubleExpModel : public HestonModel {
      public:
        explicit BatesDoubleExpModel(
            const ext::shared_ptr<HestonProcess> & process,
            Real lambda = 0.1, Real nuUp = 0.1, Real nuDown = 0.1, Real p = 0.5);

        Real p()      const { return arguments_[5](0.0); }
        Real nuDown() const { return arguments_[6](0.0); }
        Real nuUp()   const { return arguments_[7](0.0); }
        Real lambda() const { return arguments_[8](0.0); }
    };


    class BatesDoubleExpDetJumpModel : public BatesDoubleExpModel {
      public:
        explicit BatesDoubleExpDetJumpModel(
            const ext::shared_ptr<HestonProcess> & process,
            Real lambda = 0.1, Real nuUp = 0.1,   Real nuDown = 0.1,
            Real p = 0.5, Real kappaLambda = 1.0, Real thetaLambda = 0.1);

        Real kappaLambda() const { return arguments_[9](0.0); }
        Real thetaLambda() const { return arguments_[10](0.0); }
    };

}


#endif

]]></document_content>
  </document>
  <document index="5">
    <source>equity/gjrgarchmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Yee Man Chan

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gjrgarchmodel.hpp
    \brief GJR-GARCH model for the stochastic volatility of an asset
*/

#ifndef quantlib_gjrgarch_model_hpp
#define quantlib_gjrgarch_model_hpp

#include <ql/models/model.hpp>
#include <ql/processes/gjrgarchprocess.hpp>

namespace QuantLib {

    //! GJR-GARCH model for the stochastic volatility of an asset
    /*! References:

        Glosten, L., Jagannathan, R., Runkle, D., 1993. 
    Relationship between the expected value and the volatility
    of the nominal excess return on stocks. Journal of Finance
    48, 1779-1801

        \test calibration is not implemented for GJR-GARCH
    */
    class GJRGARCHModel : public CalibratedModel {
      public:
        GJRGARCHModel(const ext::shared_ptr<GJRGARCHProcess>& process);

        // variance mean reversion level multiplied by
        // the proportion not accounted by alpha, beta and gamma
        Real omega() const { return arguments_[0](0.0); }
        // proportion attributed to the impact of all innovations
        Real alpha() const { return arguments_[1](0.0); }
        // proportion attributed to the impact of previous variance
        Real beta() const { return arguments_[2](0.0); }
        // proportion attributed to the impact of negative innovations
        Real gamma()   const { return arguments_[3](0.0); }
        // market price of risk
        Real lambda()   const { return arguments_[4](0.0); }
        // spot variance
        Real v0()    const { return arguments_[5](0.0); }

        // underlying process
        ext::shared_ptr<GJRGARCHProcess> process() const { return process_; }

        class VolatilityConstraint;
      protected:
        void generateArguments() override;
        ext::shared_ptr<GJRGARCHProcess> process_;
    };
}


#endif

]]></document_content>
  </document>
  <document index="6">
    <source>equity/hestonmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hestonmodel.hpp
    \brief Heston model for the stochastic volatility of an asset
*/

#ifndef quantlib_heston_model_hpp
#define quantlib_heston_model_hpp

#include <ql/models/model.hpp>
#include <ql/processes/hestonprocess.hpp>

namespace QuantLib {

    //! Heston model for the stochastic volatility of an asset
    /*! References:

        Heston, Steven L., 1993. A Closed-Form Solution for Options
        with Stochastic Volatility with Applications to Bond and
        Currency Options.  The review of Financial Studies, Volume 6,
        Issue 2, 327-343.

        \test calibration is tested against known good values.
    */
    class HestonModel : public CalibratedModel {
      public:
        explicit HestonModel(const ext::shared_ptr<HestonProcess>& process);

        // variance mean version level
        Real theta() const { return arguments_[0](0.0); }
        // variance mean reversion speed
        Real kappa() const { return arguments_[1](0.0); }
        // volatility of the volatility
        Real sigma() const { return arguments_[2](0.0); }
        // correlation
        Real rho()   const { return arguments_[3](0.0); }
        // spot variance
        Real v0()    const { return arguments_[4](0.0); }

        // underlying process
        ext::shared_ptr<HestonProcess> process() const { return process_; }

        class FellerConstraint;
      protected:
        void generateArguments() override;
        ext::shared_ptr<HestonProcess> process_;
    };

    class HestonModel::FellerConstraint : public Constraint {
      private:
        class Impl final : public Constraint::Impl {
          public:
            bool test(const Array& params) const override {
                const Real theta = params[0];
                const Real kappa = params[1];
                const Real sigma = params[2];

                return (sigma >= 0.0 && sigma*sigma < 2.0*kappa*theta);
            }
        };
      public:
        FellerConstraint()
        : Constraint(ext::shared_ptr<Constraint::Impl>(
                                           new FellerConstraint::Impl)) {}
    };
}


#endif

]]></document_content>
  </document>
  <document index="7">
    <source>equity/hestonmodelhelper.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Klaus Spanderen
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hestonmodelhelper.hpp
    \brief Heston-model calibration helper
*/

#ifndef quantlib_heston_option_helper_hpp
#define quantlib_heston_option_helper_hpp

#include <ql/models/calibrationhelper.hpp>
#include <ql/instruments/vanillaoption.hpp>

namespace QuantLib {

    //! calibration helper for Heston model
    class HestonModelHelper : public BlackCalibrationHelper {
      public:
        HestonModelHelper(const Period& maturity,
                          Calendar calendar,
                          Real s0,
                          Real strikePrice,
                          const Handle<Quote>& volatility,
                          const Handle<YieldTermStructure>& riskFreeRate,
                          const Handle<YieldTermStructure>& dividendYield,
                          BlackCalibrationHelper::CalibrationErrorType errorType =
                              BlackCalibrationHelper::RelativePriceError);

        HestonModelHelper(const Period& maturity,
                          Calendar calendar,
                          const Handle<Quote>& s0,
                          Real strikePrice,
                          const Handle<Quote>& volatility,
                          const Handle<YieldTermStructure>& riskFreeRate,
                          const Handle<YieldTermStructure>& dividendYield,
                          BlackCalibrationHelper::CalibrationErrorType errorType =
                              BlackCalibrationHelper::RelativePriceError);

        void addTimesTo(std::list<Time>&) const override {}
        void performCalculations() const override;
        Real modelValue() const override;
        Real blackPrice(Real volatility) const override;
        Time maturity() const  { calculate(); return tau_; }
      private:
        const Period maturity_;
        const Calendar calendar_;
        const Handle<Quote> s0_;
        const Real strikePrice_;
        const Handle<YieldTermStructure> riskFreeRate_;
        const Handle<YieldTermStructure> dividendYield_;
        mutable Date exerciseDate_;
        mutable Time tau_;
        mutable Option::Type type_;
        mutable ext::shared_ptr<VanillaOption> option_;
    };

}


#endif

]]></document_content>
  </document>
  <document index="8">
    <source>equity/hestonslvfdmmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes Göttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hestonslvfdmmodel.hpp
    \brief Heston stochastic local volatility model
*/

#ifndef quantlib_heston_slv_model_hpp
#define quantlib_heston_slv_model_hpp

#include <ql/handle.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/patterns/observable.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmhestongreensfct.hpp>

#include <list>

namespace QuantLib {

class SimpleQuote;
    class HestonModel;
    class LocalVolTermStructure;

    struct HestonSLVFokkerPlanckFdmParams {
         Size xGrid, vGrid;
         Size tMaxStepsPerYear, tMinStepsPerYear;
         Real tStepNumberDecay;

        // Rannacher smoothing steps at the beginning
         Size nRannacherTimeSteps;

         Size predictionCorretionSteps;

        // local volatility forward equation
         Real x0Density;
         Real localVolEpsProb;
         Size maxIntegrationIterations;

        // variance mesher definition
         Real vLowerEps, vUpperEps, vMin;
         Real v0Density, vLowerBoundDensity, vUpperBoundDensity;

        // do not calculate leverage function if prob is smaller than eps
         Real leverageFctPropEps;

        // algorithm to get to the start configuration at time point one
         FdmHestonGreensFct::Algorithm greensAlgorithm;
         FdmSquareRootFwdOp::TransformationType trafoType;

        // define finite difference scheme
         FdmSchemeDesc schemeDesc;
    };

    class HestonSLVFDMModel : public LazyObject {
      public:
        HestonSLVFDMModel(Handle<LocalVolTermStructure> localVol,
                          Handle<HestonModel> hestonModel,
                          const Date& endDate,
                          HestonSLVFokkerPlanckFdmParams params,
                          bool logging = false,
                          std::vector<Date> mandatoryDates = std::vector<Date>(),
                          Real mixingFactor = 1.0);

        ext::shared_ptr<HestonProcess> hestonProcess() const;
        ext::shared_ptr<LocalVolTermStructure> localVol() const;
        ext::shared_ptr<LocalVolTermStructure> leverageFunction() const;

        struct LogEntry {
            const Time t;
            const ext::shared_ptr<Array> prob;
            const ext::shared_ptr<FdmMesherComposite> mesher;
        };

        const std::list<LogEntry>& logEntries() const;

      protected:
        void performCalculations() const override;

        const Handle<LocalVolTermStructure> localVol_;
        const Handle<HestonModel> hestonModel_;
        const Date endDate_;
        const HestonSLVFokkerPlanckFdmParams params_;
        const std::vector<Date> mandatoryDates_;
        const Real mixingFactor_;

        mutable ext::shared_ptr<LocalVolTermStructure> leverageFunction_;

        const bool logging_;
        mutable std::list<LogEntry> logEntries_;
    };
}


#endif

]]></document_content>
  </document>
  <document index="9">
    <source>equity/hestonslvmcmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes Göttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hestonslvmcmodel.hpp
    \brief Calibration of a Heston stochastic local volatility model based on MC
*/

#ifndef quantlib_heston_slv_mc_model_hpp
#define quantlib_heston_slv_mc_model_hpp

#include <ql/handle.hpp>
#include <ql/timegrid.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/models/marketmodels/browniangenerator.hpp>
#include <ql/termstructures/volatility/equityfx/fixedlocalvolsurface.hpp>

namespace QuantLib {
    /*! References:

        Anthonie W. van der Stoep,Lech A. Grzelak, Cornelis W. Oosterlee, 2013,
        The Heston Stochastic-Local Volatility Model: Efficient Monte Carlo Simulation
        http://papers.ssrn.com/sol3/papers.cfm?abstract_id=2278122
    */

    class HestonSLVMCModel : public LazyObject {
      public:
        HestonSLVMCModel(Handle<LocalVolTermStructure> localVol,
                         Handle<HestonModel> hestonModel,
                         ext::shared_ptr<BrownianGeneratorFactory> brownianGeneratorFactory,
                         const Date& endDate,
                         Size timeStepsPerYear = 365,
                         Size nBins = 201,
                         Size calibrationPaths = (1 << 15),
                         const std::vector<Date>& mandatoryDates = std::vector<Date>(),
                         Real mixingFactor = 1.0);

        ext::shared_ptr<HestonProcess> hestonProcess() const;
        ext::shared_ptr<LocalVolTermStructure> localVol() const;
        ext::shared_ptr<LocalVolTermStructure> leverageFunction() const;

      protected:
        void performCalculations() const override;

      private:
        const Handle<LocalVolTermStructure> localVol_;
        const Handle<HestonModel> hestonModel_;
        const ext::shared_ptr<BrownianGeneratorFactory> brownianGeneratorFactory_;
        const Date endDate_;
        const Size nBins_, calibrationPaths_;
        const Real mixingFactor_;
        ext::shared_ptr<TimeGrid> timeGrid_;

        mutable ext::shared_ptr<FixedLocalVolSurface> leverageFunction_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="10">
    <source>equity/piecewisetimedependenthestonmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file piecewisetimedependenthestonmodel.hpp
    \brief piecewise constant time dependent Heston-model
*/

#ifndef quantlib_piecewise_time_dependent_heston_model_hpp
#define quantlib_piecewise_time_dependent_heston_model_hpp

#include <ql/timegrid.hpp>
#include <ql/models/model.hpp>

namespace QuantLib {

    //! Piecewise time dependent Heston model
    /*! References:

        Heston, Steven L., 1993. A Closed-Form Solution for Options
        with Stochastic Volatility with Applications to Bond and
        Currency Options.  The review of Financial Studies, Volume 6,
        Issue 2, 327-343.
        
        A. Elices, Models with time-dependent parameters using 
        transform methods: application to Heston’s model,
        http://arxiv.org/pdf/0708.2020
    */
    class PiecewiseTimeDependentHestonModel : public CalibratedModel {
      public:
        PiecewiseTimeDependentHestonModel(const Handle<YieldTermStructure>& riskFreeRate,
                                          const Handle<YieldTermStructure>& dividendYield,
                                          const Handle<Quote>& s0,
                                          Real v0,
                                          const Parameter& theta,
                                          const Parameter& kappa,
                                          const Parameter& sigma,
                                          const Parameter& rho,
                                          TimeGrid timeGrid);

        // variance mean version level
        Real theta(Time t) const { return arguments_[0](t); }
        // variance mean reversion speed
        Real kappa(Time t) const { return arguments_[1](t); }
        // volatility of the volatility
        Real sigma(Time t) const { return arguments_[2](t); }
        // correlation
        Real rho(Time t)   const { return arguments_[3](t); }
        // spot variance
        Real v0()          const { return arguments_[4](0.0); }
        // spot
        Real s0()          const { return s0_->value(); }

        
        const TimeGrid& timeGrid() const;
        const Handle<YieldTermStructure>& dividendYield() const;
        const Handle<YieldTermStructure>& riskFreeRate() const;
        
      protected:
        const Handle<Quote> s0_;
        const Handle<YieldTermStructure> riskFreeRate_;
        const Handle<YieldTermStructure> dividendYield_;
        const TimeGrid timeGrid_;
    };
}


#endif

]]></document_content>
  </document>
  <document index="11">
    <source>marketmodels/accountingengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_accounting_engine_hpp
#define quantlib_accounting_engine_hpp

// to be removed using forward declaration
#include <ql/models/marketmodels/multiproduct.hpp>
#include <ql/models/marketmodels/discounter.hpp>
#include <ql/math/statistics/sequencestatistics.hpp>

#include <ql/utilities/clone.hpp>
#include <ql/types.hpp>
#include <vector>

namespace QuantLib {

    class MarketModelEvolver;

    //class MarketModelDiscounter;
    //class SequenceStatistics;
    //class MarketModelMultiProduct;
    //struct MarketModelMultiProduct::CashFlow;

    //! Engine collecting cash flows along a market-model simulation
    class AccountingEngine {
      public:
        AccountingEngine(ext::shared_ptr<MarketModelEvolver> evolver,
                         const Clone<MarketModelMultiProduct>& product,
                         Real initialNumeraireValue);
        void multiplePathValues(SequenceStatisticsInc& stats,
                                Size numberOfPaths);
      private:
        Real singlePathValues(std::vector<Real>& values);

        ext::shared_ptr<MarketModelEvolver> evolver_;
        Clone<MarketModelMultiProduct> product_;

        Real initialNumeraireValue_;
        Size numberProducts_;

        // workspace
        std::vector<Real> numerairesHeld_;
        std::vector<Size> numberCashFlowsThisStep_;
        std::vector<std::vector<MarketModelMultiProduct::CashFlow> >
                                                         cashFlowsGenerated_;
        std::vector<MarketModelDiscounter> discounters_;

    };

}

#endif
]]></document_content>
  </document>
  <document index="12">
    <source>marketmodels/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/marketmodels/accountingengine.hpp>
#include <ql/models/marketmodels/browniangenerator.hpp>
#include <ql/models/marketmodels/constrainedevolver.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/discounter.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/evolver.hpp>
#include <ql/models/marketmodels/forwardforwardmappings.hpp>
#include <ql/models/marketmodels/historicalforwardratesanalysis.hpp>
#include <ql/models/marketmodels/historicalratesanalysis.hpp>
#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/marketmodeldifferences.hpp>
#include <ql/models/marketmodels/multiproduct.hpp>
#include <ql/models/marketmodels/pathwiseaccountingengine.hpp>
#include <ql/models/marketmodels/pathwisemultiproduct.hpp>
#include <ql/models/marketmodels/pathwisediscounter.hpp>
#include <ql/models/marketmodels/piecewiseconstantcorrelation.hpp>
#include <ql/models/marketmodels/proxygreekengine.hpp>
#include <ql/models/marketmodels/swapforwardmappings.hpp>
#include <ql/models/marketmodels/utilities.hpp>

#include <ql/models/marketmodels/browniangenerators/all.hpp>
#include <ql/models/marketmodels/callability/all.hpp>
#include <ql/models/marketmodels/correlations/all.hpp>
#include <ql/models/marketmodels/curvestates/all.hpp>
#include <ql/models/marketmodels/driftcomputation/all.hpp>
#include <ql/models/marketmodels/evolvers/all.hpp>
#include <ql/models/marketmodels/models/all.hpp>
#include <ql/models/marketmodels/products/all.hpp>
#include <ql/models/marketmodels/pathwisegreeks/all.hpp>
]]></document_content>
  </document>
  <document index="13">
    <source>marketmodels/browniangenerator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_brownian_generator_hpp
#define quantlib_brownian_generator_hpp

#include <ql/types.hpp>
#include <ql/shared_ptr.hpp>
#include <vector>

namespace QuantLib {

    class BrownianGenerator {
      public:
        virtual ~BrownianGenerator() = default;

        virtual Real nextStep(std::vector<Real>&) = 0;
        virtual Real nextPath() = 0;

        virtual Size numberOfFactors() const = 0;
        virtual Size numberOfSteps() const = 0;
    };

    class BrownianGeneratorFactory {
      public:
        virtual ~BrownianGeneratorFactory() = default;

        virtual ext::shared_ptr<BrownianGenerator> create(Size factors,
                                                            Size steps) const = 0;
    };

}

#endif
]]></document_content>
  </document>
  <document index="14">
    <source>marketmodels/browniangenerators/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/marketmodels/browniangenerators/mtbrowniangenerator.hpp>
#include <ql/models/marketmodels/browniangenerators/sobolbrowniangenerator.hpp>

]]></document_content>
  </document>
  <document index="15">
    <source>marketmodels/browniangenerators/mtbrowniangenerator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_mt_brownian_generator_hpp
#define quantlib_mt_brownian_generator_hpp

#include <ql/models/marketmodels/browniangenerator.hpp>
#include <ql/math/randomnumbers/randomsequencegenerator.hpp>
#include <ql/math/randomnumbers/mt19937uniformrng.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {

    //! Mersenne-twister Brownian generator for market-model simulations
    /*! Incremental Brownian generator using a Mersenne-twister
        uniform generator and inverse-cumulative Gaussian method.

        \note At this time, generation of the underlying uniform
              sequence is eager, while its transformation into
              Gaussian variates is lazy.  Further optimization might
              be possible by using the Mersenne twister directly
              instead of a RandomSequenceGenerator; however, it is not
              clear how much of a difference this would make when
              compared to the inverse-cumulative Gaussian calculation.
    */
    class MTBrownianGenerator : public BrownianGenerator {
      public:
        MTBrownianGenerator(Size factors,
                            Size steps,
                            unsigned long seed = 0);

        Real nextStep(std::vector<Real>&) override;
        Real nextPath() override;

        Size numberOfFactors() const override;
        Size numberOfSteps() const override;

      private:
        Size factors_, steps_;
        Size lastStep_ = 0;
        RandomSequenceGenerator<MersenneTwisterUniformRng> generator_;
        InverseCumulativeNormal inverseCumulative_;
    };

    class MTBrownianGeneratorFactory : public BrownianGeneratorFactory {
      public:
        MTBrownianGeneratorFactory(unsigned long seed = 0);
        ext::shared_ptr<BrownianGenerator> create(Size factors, Size steps) const override;

      private:
        unsigned long seed_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="16">
    <source>marketmodels/browniangenerators/sobolbrowniangenerator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_sobol_brownian_generator_hpp
#define quantlib_sobol_brownian_generator_hpp

#include <ql/models/marketmodels/browniangenerator.hpp>
#include <ql/math/randomnumbers/inversecumulativersg.hpp>
#include <ql/math/randomnumbers/sobolrsg.hpp>
#include <ql/math/randomnumbers/burley2020sobolrsg.hpp>
#include <ql/methods/montecarlo/brownianbridge.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <vector>

namespace QuantLib {

    //! Sobol Brownian generator for market-model simulations
    /*! Incremental Brownian generator using a Sobol generator,
        inverse-cumulative Gaussian method, and Brownian bridging.
    */
    class SobolBrownianGeneratorBase : public BrownianGenerator {
      public:
        enum Ordering {
            Factors,  /*!< The variates with the best quality will be
                           used for the evolution of the first factor. */
            Steps,    /*!< The variates with the best quality will be
                           used for the largest steps of all factors. */
            Diagonal  /*!< A diagonal schema will be used to assign
                           the variates with the best quality to the
                           most important factors and the largest
                           steps. */
        };
        SobolBrownianGeneratorBase(
                           Size factors,
                           Size steps,
                           Ordering ordering);

        Real nextPath() override;
        Real nextStep(std::vector<Real>&) override;

        Size numberOfFactors() const override;
        Size numberOfSteps() const override;

        // test interface
        const std::vector<std::vector<Size> >& orderedIndices() const;
        std::vector<std::vector<Real> > transform(
                              const std::vector<std::vector<Real> >& variates);

      protected:
        virtual const SobolRsg::sample_type& nextSequence() = 0;

      private:
        Size factors_, steps_;
        Ordering ordering_;
        BrownianBridge bridge_;
        // work variables
        Size lastStep_ = 0;
        std::vector<std::vector<Size> > orderedIndices_;
        std::vector<std::vector<Real> > bridgedVariates_;
    };

    class SobolBrownianGenerator : public SobolBrownianGeneratorBase {
      public:
        SobolBrownianGenerator(Size factors,
                               Size steps,
                               Ordering ordering,
                               unsigned long seed = 0,
                               SobolRsg::DirectionIntegers directionIntegers = SobolRsg::Jaeckel);

      private:
        const SobolRsg::sample_type& nextSequence() override;
        InverseCumulativeRsg<SobolRsg, InverseCumulativeNormal> generator_;
    };

    class SobolBrownianGeneratorFactory : public BrownianGeneratorFactory {
      public:
        explicit SobolBrownianGeneratorFactory(
            SobolBrownianGenerator::Ordering ordering,
            unsigned long seed = 0,
            SobolRsg::DirectionIntegers directionIntegers = SobolRsg::Jaeckel);
        ext::shared_ptr<BrownianGenerator> create(Size factors, Size steps) const override;

      private:
        SobolBrownianGenerator::Ordering ordering_;
        unsigned long seed_;
        SobolRsg::DirectionIntegers integers_;
    };

    class Burley2020SobolBrownianGenerator : public SobolBrownianGeneratorBase {
      public:
        Burley2020SobolBrownianGenerator(
            Size factors,
            Size steps,
            Ordering ordering,
            unsigned long seed = 42,
            SobolRsg::DirectionIntegers directionIntegers = SobolRsg::Jaeckel,
            unsigned long scrambleSeed = 43);

      private:
        const Burley2020SobolRsg::sample_type& nextSequence() override;
        InverseCumulativeRsg<Burley2020SobolRsg, InverseCumulativeNormal> generator_;
    };

    class Burley2020SobolBrownianGeneratorFactory : public BrownianGeneratorFactory {
      public:
        explicit Burley2020SobolBrownianGeneratorFactory(
            SobolBrownianGenerator::Ordering ordering,
            unsigned long seed = 42,
            SobolRsg::DirectionIntegers directionIntegers = SobolRsg::Jaeckel,
            unsigned long scrambleSeed = 43);
        ext::shared_ptr<BrownianGenerator> create(Size factors, Size steps) const override;

      private:
        SobolBrownianGenerator::Ordering ordering_;
        unsigned long seed_;
        SobolRsg::DirectionIntegers integers_;
        unsigned long scrambleSeed_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="17">
    <source>marketmodels/callability/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/marketmodels/callability/bermudanswaptionexercisevalue.hpp>
#include <ql/models/marketmodels/callability/collectnodedata.hpp>
#include <ql/models/marketmodels/callability/exercisevalue.hpp>
#include <ql/models/marketmodels/callability/lsstrategy.hpp>
#include <ql/models/marketmodels/callability/marketmodelbasissystem.hpp>
#include <ql/models/marketmodels/callability/marketmodelparametricexercise.hpp>
#include <ql/models/marketmodels/callability/nodedataprovider.hpp>
#include <ql/models/marketmodels/callability/nothingexercisevalue.hpp>
#include <ql/models/marketmodels/callability/parametricexerciseadapter.hpp>
#include <ql/models/marketmodels/callability/swapbasissystem.hpp>
#include <ql/models/marketmodels/callability/swapforwardbasissystem.hpp>
#include <ql/models/marketmodels/callability/swapratetrigger.hpp>
#include <ql/models/marketmodels/callability/triggeredswapexercise.hpp>
#include <ql/models/marketmodels/callability/upperboundengine.hpp>

]]></document_content>
  </document>
  <document index="18">
    <source>marketmodels/callability/bermudanswaptionexercisevalue.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_bermudan_swaption_exercise_value_hpp
#define quantlib_bermudan_swaption_exercise_value_hpp

#include <ql/models/marketmodels/callability/exercisevalue.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/shared_ptr.hpp>
#include <valarray>

namespace QuantLib {

    class Payoff;

    class BermudanSwaptionExerciseValue : public MarketModelExerciseValue {
      public:
        BermudanSwaptionExerciseValue(const std::vector<Time>& rateTimes,
                                      std::vector<ext::shared_ptr<Payoff> >);
        Size numberOfExercises() const override;
        // including any time at which state should be updated
        const EvolutionDescription& evolution() const override;
        std::vector<Time> possibleCashFlowTimes() const override;
        void nextStep(const CurveState&) override;
        void reset() override;
        // whether or not evolution times are exercise times
        std::valarray<bool> isExerciseTime() const override;
        MarketModelMultiProduct::CashFlow value(const CurveState&) const override;
        std::unique_ptr<MarketModelExerciseValue> clone() const override;
      private:
        Size numberOfExercises_;
        std::vector<Time> rateTimes_;
        std::vector<ext::shared_ptr<Payoff> > payoffs_;
        EvolutionDescription evolution_;
        // evolving
        Size currentIndex_ = 0;
        MarketModelMultiProduct::CashFlow cf_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="19">
    <source>marketmodels/callability/collectnodedata.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_collect_node_data_hpp
#define quantlib_collect_node_data_hpp

#include <ql/types.hpp>
#include <vector>

namespace QuantLib {

    class MarketModelEvolver;
    class MarketModelMultiProduct;
    class MarketModelNodeDataProvider;
    class MarketModelExerciseValue;
    struct NodeData;

    void collectNodeData(MarketModelEvolver& evolver,
                         MarketModelMultiProduct& product,
                         MarketModelNodeDataProvider& dataProvider,
                         MarketModelExerciseValue& rebate,
                         MarketModelExerciseValue& control,
                         Size numberOfPaths,
                         std::vector<std::vector<NodeData> >& collectedData);

}

#endif
]]></document_content>
  </document>
  <document index="20">
    <source>marketmodels/callability/exercisevalue.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_market_model_exercise_value_hpp
#define quantlib_market_model_exercise_value_hpp

// to be removed using forward declaration
#include <ql/models/marketmodels/multiproduct.hpp>
#include <memory>
#include <valarray>

namespace QuantLib {

    class CurveState;
    class EvolutionDescription;
    //struct MarketModelMultiProduct::CashFlow;

    class MarketModelExerciseValue {
      public:
        virtual ~MarketModelExerciseValue() = default;
        virtual Size numberOfExercises() const = 0;
        // including any time at which state should be updated
        virtual const EvolutionDescription& evolution() const = 0;
        virtual std::vector<Time> possibleCashFlowTimes() const = 0;
        virtual void nextStep(const CurveState&) = 0;
        virtual void reset() = 0;
        // whether or not evolution times are exercise times
        virtual std::valarray<bool> isExerciseTime() const = 0;
        virtual MarketModelMultiProduct::CashFlow value(const CurveState&) const = 0;
        virtual std::unique_ptr<MarketModelExerciseValue> clone() const = 0;
    };

}


#endif
]]></document_content>
  </document>
  <document index="21">
    <source>marketmodels/callability/lsstrategy.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_longstaff_schwartz_exercise_strategy_hpp
#define quantlib_longstaff_schwartz_exercise_strategy_hpp

#include <ql/methods/montecarlo/exercisestrategy.hpp>
#include <ql/models/marketmodels/callability/marketmodelbasissystem.hpp>
#include <ql/models/marketmodels/callability/exercisevalue.hpp>
#include <ql/utilities/clone.hpp>

namespace QuantLib {

    class MarketModelDiscounter;

    class LongstaffSchwartzExerciseStrategy
        : public ExerciseStrategy<CurveState> {
      public:
        LongstaffSchwartzExerciseStrategy(Clone<MarketModelBasisSystem> basisSystem,
                                          std::vector<std::vector<Real> > basisCoefficients,
                                          const EvolutionDescription& evolution,
                                          const std::vector<Size>& numeraires,
                                          Clone<MarketModelExerciseValue> exercise,
                                          Clone<MarketModelExerciseValue> control);
        std::vector<Time> exerciseTimes() const override;
        std::vector<Time> relevantTimes() const override;
        void reset() override;
        bool exercise(const CurveState& currentState) const override;
        void nextStep(const CurveState& currentState) override;
        std::unique_ptr<ExerciseStrategy<CurveState> > clone() const override;
      private:
        Clone<MarketModelBasisSystem> basisSystem_;
        std::vector<std::vector<Real> > basisCoefficients_;
        Clone<MarketModelExerciseValue> exercise_;
        Clone<MarketModelExerciseValue> control_;
        std::vector<Size> numeraires_;
        // work variable
        Size currentIndex_;
        Real principalInNumerairePortfolio_, newPrincipal_;
        std::vector<Time> exerciseTimes_, relevantTimes_;
        std::valarray<bool> isBasisTime_, isRebateTime_, isControlTime_;
        std::valarray<bool> isExerciseTime_;
        std::vector<MarketModelDiscounter> rebateDiscounters_;
        std::vector<MarketModelDiscounter> controlDiscounters_;
        mutable std::vector<std::vector<Real> > basisValues_;
        std::vector<Size> exerciseIndex_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="22">
    <source>marketmodels/callability/marketmodelbasissystem.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_market_model_basis_system_hpp
#define quantlib_market_model_basis_system_hpp

#include <ql/models/marketmodels/callability/nodedataprovider.hpp>
#include <memory>

namespace QuantLib {

    class MarketModelBasisSystem : public MarketModelNodeDataProvider {
      public:
        // possibly different for each exercise
        virtual std::vector<Size> numberOfFunctions() const = 0;
        std::vector<Size> numberOfData() const override { return numberOfFunctions(); }
        virtual std::unique_ptr<MarketModelBasisSystem> clone() const = 0;
    };

}

#endif
]]></document_content>
  </document>
  <document index="23">
    <source>marketmodels/callability/marketmodelparametricexercise.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_market_model_parametric_exercise_hpp
#define quantlib_market_model_parametric_exercise_hpp

#include <ql/models/marketmodels/callability/nodedataprovider.hpp>
#include <ql/methods/montecarlo/parametricexercise.hpp>
#include <memory>

namespace QuantLib {

    class MarketModelParametricExercise : public MarketModelNodeDataProvider,
                                          public ParametricExercise {
      public:
        std::vector<Size> numberOfData() const override { return numberOfVariables(); }
        virtual std::unique_ptr<MarketModelParametricExercise> clone() const = 0;
    };

}


#endif
]]></document_content>
  </document>
  <document index="24">
    <source>marketmodels/callability/nodedataprovider.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_market_model_node_data_provider_hpp
#define quantlib_market_model_node_data_provider_hpp

#include <ql/types.hpp>
#include <vector>
#include <valarray>

namespace QuantLib {

    class CurveState;
    class EvolutionDescription;

    class MarketModelNodeDataProvider {
      public:
        virtual ~MarketModelNodeDataProvider() = default;
        virtual Size numberOfExercises() const = 0;
        // possibly different for each exercise
        virtual std::vector<Size> numberOfData() const = 0;
        // including any time at which state should be updated
        virtual const EvolutionDescription& evolution() const = 0;
        virtual void nextStep(const CurveState&) = 0;
        virtual void reset() = 0;
        // whether or not evolution times are exercise times
        virtual std::valarray<bool> isExerciseTime() const = 0;
        virtual void values(const CurveState&,
                            std::vector<Real>& results) const = 0;
    };

}


#endif
]]></document_content>
  </document>
  <document index="25">
    <source>marketmodels/callability/nothingexercisevalue.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_nothing_exercise_value_hpp
#define quantlib_nothing_exercise_value_hpp

#include <ql/models/marketmodels/callability/exercisevalue.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>

namespace QuantLib {

    class NothingExerciseValue : public MarketModelExerciseValue {
      public:
        //! \todo use Payoff
        NothingExerciseValue(const std::vector<Time>& rateTimes,
                             std::valarray<bool> isExerciseTime = std::valarray<bool>());
        Size numberOfExercises() const override;
        // including any time at which state should be updated
        const EvolutionDescription& evolution() const override;
        std::vector<Time> possibleCashFlowTimes() const override;
        void nextStep(const CurveState&) override;
        void reset() override;
        // whether or not evolution times are exercise times
        std::valarray<bool> isExerciseTime() const override;
        MarketModelMultiProduct::CashFlow value(const CurveState&) const override;
        std::unique_ptr<MarketModelExerciseValue> clone() const override;
      private:
        Size numberOfExercises_;
        std::vector<Time> rateTimes_;
        std::valarray<bool> isExerciseTime_;
        EvolutionDescription evolution_;
        // evolving
        Size currentIndex_ = 0;
        MarketModelMultiProduct::CashFlow cf_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="26">
    <source>marketmodels/callability/parametricexerciseadapter.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_market_model_parametric_exercise_adapter_hpp
#define quantlib_market_model_parametric_exercise_adapter_hpp

#include <ql/methods/montecarlo/exercisestrategy.hpp>
#include <ql/utilities/clone.hpp>
#include <valarray>

namespace QuantLib {

    class CurveState;
    class MarketModelParametricExercise;

    class ParametricExerciseAdapter : public ExerciseStrategy<CurveState> {
      public:
        ParametricExerciseAdapter(const MarketModelParametricExercise& exercise,
                                  std::vector<std::vector<Real> > parameters);
        std::vector<Time> exerciseTimes() const override;
        std::vector<Time> relevantTimes() const override;
        void reset() override;
        void nextStep(const CurveState& currentState) override;
        bool exercise(const CurveState& currentState) const override;
        std::unique_ptr<ExerciseStrategy<CurveState> > clone() const override;
      private:
        Clone<MarketModelParametricExercise> exercise_;
        std::vector<std::vector<Real> > parameters_;
        std::vector<Time> exerciseTimes_;
        Size currentStep_ = 0, currentExercise_ = 0;
        std::valarray<bool> isExerciseTime_;
        std::vector<Size> numberOfVariables_;
        mutable std::vector<Real> variables_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="27">
    <source>marketmodels/callability/swapbasissystem.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_swap_basis_system_hpp
#define quantlib_swap_basis_system_hpp

#include <ql/models/marketmodels/callability/marketmodelbasissystem.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>

namespace QuantLib {

    class SwapBasisSystem : public MarketModelBasisSystem {
      public:
        SwapBasisSystem(const std::vector<Time>& rateTimes,
                        const std::vector<Time>& exerciseTimes);
        Size numberOfExercises() const override;
        std::vector<Size> numberOfFunctions() const override;
        const EvolutionDescription& evolution() const override;
        void nextStep(const CurveState&) override;
        void reset() override;
        std::valarray<bool> isExerciseTime() const override;
        void values(const CurveState&, std::vector<Real>& results) const override;
        std::unique_ptr<MarketModelBasisSystem> clone() const override;
      private:
        std::vector<Time> rateTimes_, exerciseTimes_;
        Size currentIndex_;
        std::vector<Size> rateIndex_;
        EvolutionDescription evolution_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="28">
    <source>marketmodels/callability/swapforwardbasissystem.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_swap_forward_basis_system_hpp
#define quantlib_swap_forward_basis_system_hpp

#include <ql/models/marketmodels/callability/marketmodelbasissystem.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>

namespace QuantLib {

    class SwapForwardBasisSystem : public MarketModelBasisSystem
    {
      public:
        SwapForwardBasisSystem(const std::vector<Time>& rateTimes,
                                                                    const std::vector<Time>& exerciseTimes);

        Size numberOfExercises() const override;
        std::vector<Size> numberOfFunctions() const override;
        const EvolutionDescription& evolution() const override;
        void nextStep(const CurveState&) override;
        void reset() override;
        std::valarray<bool> isExerciseTime() const override;

        void values(const CurveState&, std::vector<Real>& results) const override;

        std::unique_ptr<MarketModelBasisSystem> clone() const override;
      private:
        std::vector<Time> rateTimes_, exerciseTimes_;
        Size currentIndex_;
        std::vector<Size> rateIndex_;
        EvolutionDescription evolution_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="29">
    <source>marketmodels/callability/swapratetrigger.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_swap_rate_trigger_hpp
#define quantlib_swap_rate_trigger_hpp

#include <ql/methods/montecarlo/exercisestrategy.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <vector>

namespace QuantLib {

    class SwapRateTrigger : public ExerciseStrategy<CurveState> {
      public:
        SwapRateTrigger(const std::vector<Time>& rateTimes,
                        std::vector<Rate> swapTriggers,
                        const std::vector<Time>& exerciseTimes);
        std::vector<Time> exerciseTimes() const override;
        std::vector<Time> relevantTimes() const override;
        void reset() override;
        bool exercise(const CurveState& currentState) const override;
        void nextStep(const CurveState& currentState) override;
        std::unique_ptr<ExerciseStrategy<CurveState> > clone() const override;
      private:
        std::vector<Time> rateTimes_;
        std::vector<Rate> swapTriggers_;
        std::vector<Time> exerciseTimes_;
        Size currentIndex_;
        std::vector<Size> rateIndex_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="30">
    <source>marketmodels/callability/triggeredswapexercise.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_triggered_swap_exercise_hpp
#define quantlib_triggered_swap_exercise_hpp

#include <ql/models/marketmodels/callability/marketmodelparametricexercise.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>

namespace QuantLib {

    class TriggeredSwapExercise : public MarketModelParametricExercise {
      public:
        TriggeredSwapExercise(const std::vector<Time>& rateTimes,
                              const std::vector<Time>& exerciseTimes,
                              std::vector<Rate> strikes);

        // NodeDataProvider interface
        Size numberOfExercises() const override;
        const EvolutionDescription& evolution() const override;
        void nextStep(const CurveState&) override;
        void reset() override;
        std::valarray<bool> isExerciseTime() const override;
        void values(const CurveState&, std::vector<Real>& results) const override;

        // ParametricExercise interface
        std::vector<Size> numberOfVariables() const override;
        std::vector<Size> numberOfParameters() const override;
        bool exercise(Size exerciseNumber,
                      const std::vector<Real>& parameters,
                      const std::vector<Real>& variables) const override;
        void guess(Size exerciseNumber, std::vector<Real>& parameters) const override;

        std::unique_ptr<MarketModelParametricExercise> clone() const override;

      private:
        std::vector<Time> rateTimes_, exerciseTimes_;
        std::vector<Rate> strikes_;
        Size currentStep_ = 0;
        std::vector<Size> rateIndex_;
        EvolutionDescription evolution_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="31">
    <source>marketmodels/callability/upperboundengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_upper_bound_engine_hpp
#define quantlib_upper_bound_engine_hpp

#include <ql/models/marketmodels/products/multiproductcomposite.hpp>
#include <ql/methods/montecarlo/exercisestrategy.hpp>
#include <ql/math/statistics/sequencestatistics.hpp>
#include <ql/utilities/clone.hpp>
#include <utility>
#include <valarray>

namespace QuantLib {

    class MarketModelEvolver;
    class MarketModelDiscounter;
    class MarketModelMultiProduct;
    class MarketModelExerciseValue;

    //! Market-model %engine for upper-bound estimation
    /*! \pre product and hedge must have the same rate times
             and exercise times
    */
    class UpperBoundEngine {
      public:
        UpperBoundEngine(ext::shared_ptr<MarketModelEvolver> evolver,
                         std::vector<ext::shared_ptr<MarketModelEvolver> > innerEvolvers,
                         const MarketModelMultiProduct& underlying,
                         const MarketModelExerciseValue& rebate,
                         const MarketModelMultiProduct& hedge,
                         const MarketModelExerciseValue& hedgeRebate,
                         const ExerciseStrategy<CurveState>& hedgeStrategy,
                         Real initialNumeraireValue);
        void multiplePathValues(Statistics& stats,
                                Size outerPaths,
                                Size innerPaths);
        std::pair<Real,Real> singlePathValue(Size innerPaths);
      private:
        Real collectCashFlows(Size currentStep,
                              Real principalInNumerairePortfolio,
                              Size beginProduct,
                              Size endProduct) const;

        ext::shared_ptr<MarketModelEvolver> evolver_;
        std::vector<ext::shared_ptr<MarketModelEvolver> > innerEvolvers_;
        MultiProductComposite composite_;

        Real initialNumeraireValue_;
        Size underlyingSize_, rebateSize_, hedgeSize_, hedgeRebateSize_;
        Size underlyingOffset_, rebateOffset_, hedgeOffset_, hedgeRebateOffset_;
        Size numberOfProducts_;
        Size numberOfSteps_;
        std::valarray<bool> isExerciseTime_;

        // workspace
        std::vector<Size> numberCashFlowsThisStep_;
        std::vector<std::vector<MarketModelMultiProduct::CashFlow> >
                                                         cashFlowsGenerated_;
        std::vector<MarketModelDiscounter> discounters_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="32">
    <source>marketmodels/constrainedevolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_constrained_evolver_hpp
#define quantlib_constrained_evolver_hpp

#include <ql/models/marketmodels/evolver.hpp>
#include <valarray>

namespace QuantLib {

    //! Constrained market-model evolver
    /*! Abstract base class. Requires extra methods above that of
        marketmodelevolver to let you fix rates via importance sampling.

        The evolver does the actual gritty work of evolving the forward rates
        from one time to the next.

        This is intended to be used for the Fries-Joshi proxy simulation
        approach to Greeks
    */
    class ConstrainedEvolver : public MarketModelEvolver {
      public:
        ~ConstrainedEvolver() override = default;
        //! call once
        virtual void setConstraintType(
            const std::vector<Size>& startIndexOfSwapRate,
            const std::vector<Size>& EndIndexOfSwapRate) = 0;
        //! call before each path
        virtual void setThisConstraint(
            const std::vector<Rate>& rateConstraints,
            const std::valarray<bool>& isConstraintActive) = 0;
    };

}

#endif
]]></document_content>
  </document>
  <document index="33">
    <source>marketmodels/correlations/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/marketmodels/correlations/cotswapfromfwdcorrelation.hpp>
#include <ql/models/marketmodels/correlations/expcorrelations.hpp>
#include <ql/models/marketmodels/correlations/timehomogeneousforwardcorrelation.hpp>

]]></document_content>
  </document>
  <document index="34">
    <source>marketmodels/correlations/cotswapfromfwdcorrelation.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_fra_time_dep_corr_struct_hpp
#define quantlib_fra_time_dep_corr_struct_hpp

#include <ql/models/marketmodels/piecewiseconstantcorrelation.hpp>
#include <vector>

namespace QuantLib {

    class CurveState;

    class CotSwapFromFwdCorrelation : public PiecewiseConstantCorrelation {
      public:
        CotSwapFromFwdCorrelation(
            const ext::shared_ptr<PiecewiseConstantCorrelation>& fwdCorr,
            const CurveState& curveState,
            Spread displacement);
        const std::vector<Time>& times() const override;
        const std::vector<Time>& rateTimes() const override;
        const std::vector<Matrix>& correlations() const override;
        Size numberOfRates() const override;

      private:
        ext::shared_ptr<PiecewiseConstantCorrelation> fwdCorr_;
        Size numberOfRates_;
        std::vector<Matrix> swapCorrMatrices_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="35">
    <source>marketmodels/correlations/expcorrelations.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2007 François du Vignaud

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file expcorrelations.hpp
    \brief exponential correlation matrix
*/

#ifndef quantlib_exp_correlations_hpp
#define quantlib_exp_correlations_hpp

#include <ql/math/matrix.hpp>
#include <ql/models/marketmodels/piecewiseconstantcorrelation.hpp>

namespace QuantLib {

    /*! Exponential correlation
        L = long term correlation
        beta = exponential decay of correlation between far away forward rates
        gamma = exponent for time to go
        t = time dependence
    */
    Matrix exponentialCorrelations(const std::vector<Time>& rateTimes,
                                   Real longTermCorr = 0.5,
                                   Real beta = 0.2,
                                   Real gamma = 1.0,
                                   Time t = 0.0);

    class ExponentialForwardCorrelation :
        public PiecewiseConstantCorrelation {
      public:
        ExponentialForwardCorrelation(const std::vector<Time>& rateTimes,
                                      Real longTermCorr = 0.5,
                                      Real beta = 0.2,
                                      Real gamma = 1.0,
                                      std::vector<Time> times = std::vector<Time>());
        const std::vector<Time>& times() const override;
        const std::vector<Time>& rateTimes() const override;
        const std::vector<Matrix>& correlations() const override;
        Size numberOfRates() const override;

      private:
        Size numberOfRates_;
        Real longTermCorr_, beta_, gamma_;
        std::vector<Time> rateTimes_, times_;
        std::vector<Matrix> correlations_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="36">
    <source>marketmodels/correlations/timehomogeneousforwardcorrelation.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_time_homogeneous_forward_correlation_hpp
#define quantlib_time_homogeneous_forward_correlation_hpp

#include <ql/models/marketmodels/piecewiseconstantcorrelation.hpp>
#include <ql/math/matrix.hpp>
#include <vector>

namespace QuantLib {

    class TimeHomogeneousForwardCorrelation :
                                        public PiecewiseConstantCorrelation {
      public:
        TimeHomogeneousForwardCorrelation(const Matrix& fwdCorrelation,
                                          const std::vector<Time>& rateTimes);
        const std::vector<Time>& times() const override;
        const std::vector<Time>& rateTimes() const override;
        const std::vector<Matrix>& correlations() const override;
        Size numberOfRates() const override;
        static std::vector<Matrix> evolvedMatrices(
                                        const Matrix& fwdCorrelation);
    private:
        Size numberOfRates_;
        Matrix fwdCorrelation_;
        std::vector<Time> rateTimes_, times_;
        std::vector<Matrix> correlations_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="37">
    <source>marketmodels/curvestate.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006, 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_curve_state_hpp
#define quantlib_curve_state_hpp

#include <ql/math/array.hpp>
#include <vector>
#include <memory>

namespace QuantLib {

    //! %Curve state for market-model simulations
    /*! This class stores the state of the yield curve associated to the
        fixed calendar times within the simulation.
        This is the workhorse discounting object associated to the rate times
        of the simulation. It's important to pass the rates via an object like
        this to the product rather than directly to make it easier to switch
        to other engines such as a coterminal swap rate engine.
        Many products will not need expired rates and others will only require
        the first rate.
    */
    class CurveState {
    /* There will n+1 rate times expressing payment and reset times
        of forward rates.

                |-----|-----|-----|-----|-----|      (size = 6)
                t0    t1    t2    t3    t4    t5     rateTimes
                f0    f1    f2    f3    f4           forwardRates
                d0    d1    d2    d3    d4    d5     discountBonds
                d0/d0 d1/d0 d2/d0 d3/d0 d4/d0 d5/d0  discountRatios
                sr0   sr1   sr2   sr3   sr4          cotSwaps
    */
      public:
        CurveState(const std::vector<Time>& rateTimes);
        virtual ~CurveState() = default;

        //! \name Inspectors
        //@{
        Size numberOfRates() const { return numberOfRates_; }

        const std::vector<Time>& rateTimes() const { return rateTimes_; }
        const std::vector<Time>& rateTaus() const { return rateTaus_; }

        virtual Real discountRatio(Size i,
                                   Size j) const = 0;
        virtual Rate forwardRate(Size i) const = 0;
        virtual Rate coterminalSwapAnnuity(Size numeraire,
                                           Size i) const = 0;
        virtual Rate coterminalSwapRate(Size i) const = 0;
        virtual Rate cmSwapAnnuity(Size numeraire,
                                   Size i,
                                   Size spanningForwards) const = 0;
        virtual Rate cmSwapRate(Size i,
                                Size spanningForwards) const = 0;

        virtual const std::vector<Rate>& forwardRates() const = 0;
        virtual const std::vector<Rate>& coterminalSwapRates() const = 0;
        virtual const std::vector<Rate>& cmSwapRates(Size spanningForwards) const = 0;
        Rate swapRate(Size begin,
                      Size end) const;

        virtual std::unique_ptr<CurveState> clone() const = 0;
        //@}
      protected:
        Size numberOfRates_;
        std::vector<Time> rateTimes_, rateTaus_;
    };

    void forwardsFromDiscountRatios(Size firstValidIndex,
                                    const std::vector<DiscountFactor>& ds,
                                    const std::vector<Time>& taus,
                                    std::vector<Rate>& fwds);

    void coterminalFromDiscountRatios(Size firstValidIndex,
                                      const std::vector<DiscountFactor>& ds,
                                      const std::vector<Time>& taus,
                                      std::vector<Rate>& cotSwapRates,
                                      std::vector<Real>& cotSwapAnnuities);

    void constantMaturityFromDiscountRatios( // Size i, // to be added later
        Size spanningForwards,
        Size firstValidIndex,
        const std::vector<DiscountFactor>& ds,
        const std::vector<Time>& taus,
        std::vector<Rate>& cotSwapRates,
        std::vector<Real>& cotSwapAnnuities);
}

#endif
]]></document_content>
  </document>
  <document index="38">
    <source>marketmodels/curvestates/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/marketmodels/curvestates/cmswapcurvestate.hpp>
#include <ql/models/marketmodels/curvestates/coterminalswapcurvestate.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>

]]></document_content>
  </document>
  <document index="39">
    <source>marketmodels/curvestates/cmswapcurvestate.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006, 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_cmswapcurvestate_hpp
#define quantlib_cmswapcurvestate_hpp

#include <ql/models/marketmodels/curvestate.hpp>

namespace QuantLib {

    //! %Curve state for constant-maturity-swap market models
    class CMSwapCurveState : public CurveState {
      public:
        explicit CMSwapCurveState(const std::vector<Time>& rateTimes,
                                  Size spanningForwards);

        //! \name Modifiers
        //@{
        void setOnCMSwapRates(const std::vector<Rate>& cmSwapRates,
                              Size firstValidIndex = 0);
        //@}
        //! \name Inspectors
        //@{
        Real discountRatio(Size i, Size j) const override;
        Rate forwardRate(Size i) const override;

        Rate coterminalSwapRate(Size i) const override;
        Rate coterminalSwapAnnuity(Size numeraire, Size i) const override;

        Rate cmSwapRate(Size i, Size spanningForwards) const override;
        Rate cmSwapAnnuity(Size numeraire, Size i, Size spanningForwards) const override;
        const std::vector<Rate>& forwardRates() const override;
        const std::vector<Rate>& coterminalSwapRates() const override;
        const std::vector<Rate>& cmSwapRates(Size spanningForwards) const override;
        std::unique_ptr<CurveState> clone() const override;
        //@}
      private:
        Size spanningFwds_;
        Size first_;
        std::vector<DiscountFactor> discRatios_;
        mutable std::vector<Rate> forwardRates_;
        // fixed number of spanning forwards
        std::vector<Rate> cmSwapRates_;
        std::vector<Real> cmSwapAnnuities_;
        // irregular number of spanning forwards
        mutable std::vector<Rate> irrCMSwapRates_;
        mutable std::vector<Real> irrCMSwapAnnuities_;
        mutable std::vector<Rate> cotSwapRates_;
        mutable std::vector<Real> cotAnnuities_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="40">
    <source>marketmodels/curvestates/coterminalswapcurvestate.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006, 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_coterminalswapcurvestate_hpp
#define quantlib_coterminalswapcurvestate_hpp

#include <ql/models/marketmodels/curvestate.hpp>

namespace QuantLib {

    //! %Curve state for coterminal-swap market models
    /*! This class stores the state of the yield curve associated to the
        fixed calendar times within the simulation.
        This is the workhorse discounting object associated to the rate times
        of the simulation. It's important to pass the rates via an object like
        this to the product rather than directly to make it easier to switch
        to other engines such as a coterminal swap rate engine.
        Many products will not need expired rates and others will only require
        the first rate.
    */
    class CoterminalSwapCurveState : public CurveState {
    /* There will n+1 rate times expressing payment and reset times
        of coterminal swap rates.

                |-----|-----|-----|-----|-----|      (size = 6)
                0     1     2     3     4     5      index (i)      (i = 0, ..., 5)
                t0    t1    t2    t3    t4    t5     rateTimes      (i = 0, ..., 5; dim = 6)
                tau0  tau1  tau2  tau3  tau4         rateTaus       (i = 0, ..., 4; dim = 5)
                f0    f1    f2    f3    f4           forwardRates   (i = 0, ..., 4; dim = 5)
                d0    d1    d2    d3    d4    d5     discountBonds  (i = 0, ..., 5; dim = 6)
                d0/d0 d1/d0 d2/d0 d3/d0 d4/d0 d5/d0  discountRatios (i = 0, ..., 5; dim = 6)
                sr0   sr1   sr2   sr3   sr4          cotSwapsRates  (i = 0, ..., 4; dim = 5)
                a0    a1    a2    a3    a4           cotAnnuities   (i = 0, ..., 4; dim = 5)
    */
      public:
        explicit CoterminalSwapCurveState(const std::vector<Time>& rateTimes);
        //! \name Modifiers
        //@{
        void setOnCoterminalSwapRates(const std::vector<Rate>& swapRates,
                                      Size firstValidIndex = 0);
        //@}

        //! \name Inspectors
        //@{
        Real discountRatio(Size i, Size j) const override;
        Rate forwardRate(Size i) const override;
        Rate coterminalSwapRate(Size i) const override;
        Rate coterminalSwapAnnuity(Size numeraire, Size i) const override;
        Rate cmSwapRate(Size i, Size spanningForwards) const override;
        Rate cmSwapAnnuity(Size numeraire, Size i, Size spanningForwards) const override;
        const std::vector<Rate>& forwardRates() const override;
        const std::vector<Rate>& coterminalSwapRates() const override;
        const std::vector<Rate>& cmSwapRates(Size spanningForwards) const override;
        //@}
        std::unique_ptr<CurveState> clone() const override;
      private:
        Size first_;
        std::vector<DiscountFactor> discRatios_;
        mutable std::vector<Rate> forwardRates_;
        mutable std::vector<Rate> cmSwapRates_;
        mutable std::vector<Real> cmSwapAnnuities_;
        std::vector<Rate> cotSwapRates_;
        std::vector<Real> cotAnnuities_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="41">
    <source>marketmodels/curvestates/lmmcurvestate.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006, 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_lmmcurvestate_hpp
#define quantlib_lmmcurvestate_hpp

#include <ql/models/marketmodels/curvestate.hpp>

namespace QuantLib {

    //! %Curve state for %Libor market models
    /*! This class stores the state of the yield curve associated to the
        fixed calendar times within the simulation.
        This is the workhorse discounting object associated to the rate times
        of the simulation. It's important to pass the rates via an object like
        this to the product rather than directly to make it easier to switch
        to other engines such as a coterminal swap rate engine.
        Many products will not need expired rates and others will only require
        the first rate.
    */
    class LMMCurveState : public CurveState {
    /* There will n+1 rate times expressing payment and reset times
        of forward rates.

                |-----|-----|-----|-----|-----|      (size = 6)
                t0    t1    t2    t3    t4    t5     rateTimes
                f0    f1    f2    f3    f4           forwardRates
                d0    d1    d2    d3    d4    d5     discountBonds
                d0/d0 d1/d0 d2/d0 d3/d0 d4/d0 d5/d0  discountRatios
                sr0   sr1   sr2   sr3   sr4          cotSwaps
    */
      public:
        explicit LMMCurveState(const std::vector<Time>& rateTimes);
        //! \name Modifiers
        //@{
        void setOnForwardRates(const std::vector<Rate>& fwdRates,
                               Size firstValidIndex = 0);

        void setOnDiscountRatios(const std::vector<DiscountFactor>& discRatios,
                                 Size firstValidIndex = 0);
        //@}

        //! \name Inspectors
        //@{
        Real discountRatio(Size i, Size j) const override;
        Rate forwardRate(Size i) const override;

        Rate coterminalSwapRate(Size i) const override;
        Rate coterminalSwapAnnuity(Size numeraire, Size i) const override;

        Rate cmSwapRate(Size i, Size spanningForwards) const override;
        Rate cmSwapAnnuity(Size numeraire, Size i, Size spanningForwards) const override;
        const std::vector<Rate>& forwardRates() const override;
        const std::vector<Rate>& coterminalSwapRates() const override;
        const std::vector<Rate>& cmSwapRates(Size spanningForwards) const override;
        //@}
        std::unique_ptr<CurveState> clone() const override;

      private:
        Size first_;
        std::vector<DiscountFactor> discRatios_;
        std::vector<Rate> forwardRates_;
        mutable std::vector<Rate> cmSwapRates_;
        mutable std::vector<Real> cmSwapAnnuities_;
        mutable std::vector<Rate> cotSwapRates_;
        mutable std::vector<Real> cotAnnuities_;

        mutable Size firstCotAnnuityComped_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="42">
    <source>marketmodels/discounter.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_market_model_discounter_hpp
#define quantlib_market_model_discounter_hpp

#include <ql/types.hpp>
#include <vector>

namespace QuantLib {

    class CurveState;

    class MarketModelDiscounter {
      public:
        MarketModelDiscounter(Time paymentTime,
                              const std::vector<Time>& rateTimes);
        Real numeraireBonds(const CurveState&,
                            Size numeraire) const;
      private:
        Size before_;
        Real beforeWeight_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="43">
    <source>marketmodels/driftcomputation/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/marketmodels/driftcomputation/cmsmmdriftcalculator.hpp>
#include <ql/models/marketmodels/driftcomputation/lmmdriftcalculator.hpp>
#include <ql/models/marketmodels/driftcomputation/lmmnormaldriftcalculator.hpp>
#include <ql/models/marketmodels/driftcomputation/smmdriftcalculator.hpp>

]]></document_content>
  </document>
  <document index="44">
    <source>marketmodels/driftcomputation/cmsmmdriftcalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 François du Vignaud
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cmsmmdriftcalculator.hpp
    \brief Drift computation for CMS market model
*/

#ifndef quantlib_cms_drift_calculator_hpp
#define quantlib_cms_drift_calculator_hpp

#include <ql/math/matrix.hpp>
#include <vector>

namespace QuantLib {

    class CMSwapCurveState;

    //! Drift computation for CMS market models
    /*! Returns the drift \f$ \mu \Delta t \f$.
        See Mark Joshi, <i>Rapid Computation of Drifts in a
        Reduced Factor Libor Market Model</i>, Wilmott Magazine,
        May 2003.
    */
    class CMSMMDriftCalculator {
      public:
        CMSMMDriftCalculator(const Matrix& pseudo,
                             const std::vector<Spread>& displacements,
                             const std::vector<Time>& taus,
                             Size numeraire,
                             Size alive,
                             Size spanningFwds);
        //! Computes the drifts
        void compute(const CMSwapCurveState& cs,
                     std::vector<Real>& drifts) const;
      private:
        Size numberOfRates_, numberOfFactors_;
        Size numeraire_, alive_;
        std::vector<Spread> displacements_;
        std::vector<Real> oneOverTaus_;
        Matrix C_, pseudo_;
        // temporary variables to be added later
        mutable std::vector<Real> tmp_;
        mutable Matrix PjPnWk_; // < Wk, P_{j}/P_n> (k, j)
        mutable Matrix wkaj_;    // < Wk , Aj/Pn> (k, j)
        mutable Matrix wkajN_;    // < Wk , Aj/PN> (k, j)

        std::vector<Size> downs_, ups_;
        Size spanningFwds_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="45">
    <source>marketmodels/driftcomputation/lmmdriftcalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file lmmdriftcalculator.hpp
    \brief Drift computation for Libor market model
*/

#ifndef quantlib_lmm_drift_calculator_hpp
#define quantlib_lmm_drift_calculator_hpp

#include <ql/math/matrix.hpp>
#include <vector>

namespace QuantLib {

    class LMMCurveState;

    //! Drift computation for log-normal %Libor market models
    /*! Returns the drift \f$ \mu \Delta t \f$.
        See Mark Joshi, <i>Rapid Computation of Drifts in a
        Reduced Factor Libor Market Model</i>, Wilmott Magazine,
        May 2003.
    */
    class LMMDriftCalculator {
      public:
        LMMDriftCalculator(const Matrix& pseudo,
                           const std::vector<Spread>& displacements,
                           const std::vector<Time>& taus,
                           Size numeraire,
                           Size alive);
        //! Computes the drifts
        void compute(const LMMCurveState& cs,
                     std::vector<Real>& drifts) const;
        void compute(const std::vector<Rate>& fwds,
                     std::vector<Real>& drifts) const;

        /*! Computes the drifts without factor reduction as in
            eqs. 2, 4 of ref. [1] (uses the covariance matrix directly). */
        void computePlain(const LMMCurveState& cs,
                          std::vector<Real>& drifts) const;
        void computePlain(const std::vector<Rate>& fwds,
                          std::vector<Real>& drifts) const;

        /*! Computes the drifts with factor reduction as in eq. 7 of ref. [1]
            (uses pseudo square root of the covariance matrix). */
        void computeReduced(const LMMCurveState& cs,
                            std::vector<Real>& drifts) const;
        void computeReduced(const std::vector<Rate>& fwds,
                            std::vector<Real>& drifts) const;

      private:
        Size numberOfRates_, numberOfFactors_;
        bool isFullFactor_;
        Size numeraire_, alive_;
        std::vector<Spread> displacements_;
        std::vector<Real> oneOverTaus_;
        Matrix C_, pseudo_;
        // temporary variables to be added later
        mutable std::vector<Real> tmp_;
        mutable Matrix e_;
        std::vector<Size> downs_, ups_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="46">
    <source>marketmodels/driftcomputation/lmmnormaldriftcalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2007 Chiara Fornarola

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file lmmnormaldriftcalculator.hpp
    \brief Drift computation for normal Libor market model
*/

#ifndef quantlib_lmm_normal_drift_calculator_hpp
#define quantlib_lmm_normal_drift_calculator_hpp

#include <ql/math/matrix.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>
#include <vector>

namespace QuantLib {

    //! Drift computation for normal %Libor market models
    /*! Returns the drift \f$ \mu \Delta t \f$.
        See Mark Joshi, <i>Rapid Computation of Drifts in a
        Reduced Factor Libor Market Model</i>, Wilmott Magazine,
        May 2003.
    */
    class LMMNormalDriftCalculator {
      public:
        LMMNormalDriftCalculator(const Matrix& pseudo,
                                 const std::vector<Time>& taus,
                                 Size numeraire,
                                 Size alive);
        //! Computes the drifts
        void compute(const LMMCurveState& cs,
                     std::vector<Real>& drifts) const;
        void compute(const std::vector<Rate>& fwds,
                     std::vector<Real>& drifts) const;

        /*! Computes the drifts without factor reduction as in
            eqs. 2, 4 of ref. [1], modified for normal forward rates dynamic
            (uses the covariance matrix directly). */
        void computePlain(const LMMCurveState& cs,
                          std::vector<Real>& drifts) const;
        void computePlain(const std::vector<Rate>& fwds,
                          std::vector<Real>& drifts) const;

        /*! Computes the drifts with factor reduction as in
            eq. 7 of ref. [1], modified for normal forward rates dynamic
            (uses pseudo square root of the covariance matrix). */
        void computeReduced(const LMMCurveState& cs,
                            std::vector<Real>& drifts) const;
        void computeReduced(const std::vector<Rate>& fwds,
                            std::vector<Real>& drifts) const;


      private:
        Size numberOfRates_, numberOfFactors_;
        bool isFullFactor_;
        Size numeraire_, alive_;
        std::vector<Real> oneOverTaus_;
        Matrix C_, pseudo_;
        // temporary variables to be added later
        mutable std::vector<Real> tmp_;
        mutable Matrix e_;
        std::vector<Size> downs_, ups_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="47">
    <source>marketmodels/driftcomputation/smmdriftcalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file smmdriftcalculator.hpp
    \brief Drift computation for coterminal-swap market model
*/

#ifndef quantlib_smm_drift_calculator_hpp
#define quantlib_smm_drift_calculator_hpp

#include <ql/math/matrix.hpp>
#include <vector>

namespace QuantLib {

    class CoterminalSwapCurveState;

    //! Drift computation for coterminal swap market models
    /*! Returns the drift \f$ \mu \Delta t \f$.
        See Mark Joshi, Lorenzo Liesch, <i>Effective
        Implementation Of Generic Market Models</i>.
    */
    class SMMDriftCalculator {
      public:
        SMMDriftCalculator(const Matrix& pseudo,
                           const std::vector<Spread>& displacements,
                           const std::vector<Time>& taus,
                           Size numeraire,
                           Size alive);
        //! Computes the drifts
        void compute(const CoterminalSwapCurveState& cs,
                     std::vector<Real>& drifts) const;
      private:
        Size numberOfRates_, numberOfFactors_;
        Size numeraire_, alive_;
        std::vector<Spread> displacements_;
        std::vector<Real> oneOverTaus_;
        Matrix C_, pseudo_;
        // temporary variables to be added later
        mutable std::vector<Real> tmp_;
        mutable Matrix wkaj_;  // < W(k) | A(j)/P(n) >
        mutable Matrix wkpj_; // < W(k) | P(j)/P(n) >
        mutable Matrix wkajshifted_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="48">
    <source>marketmodels/evolutiondescription.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006, 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_evolution_description_hpp
#define quantlib_evolution_description_hpp

#include <ql/types.hpp>
#include <vector>

namespace QuantLib {

    //! Market-model evolution description
    /*! This class stores:
        -# evolutionTimes = the times at which the rates need to be known,
        -# rateTimes = the times defining the rates that are to be evolved,
        -# relevanceRates = which rates need to be known at each time.

        This class is really just a tuple of evolution and rate times;
        - there will be n+1 rate times expressing payment and reset
          times of forward rates.
        - there will be any number of evolution times.
        - we also store which part of the rates are relevant for
          pricing via relevance rates. The important part for the i-th
          step will then range from relevanceRates[i].first to
          relevanceRates[i].second. Default values for relevance rates
          will be 0 and n.
        - example for n = 5:
        <pre>
           |-----|-----|-----|-----|-----|      (size = 6)
           t0    t1    t2    t3    t4    t5     rateTimes
           f0    f1    f2    f3    f4           forwardRates
           d0    d1    d2    d3    d4    d5     discountBonds
           d0/d0 d1/d0 d2/d0 d3/d0 d4/d0 d5/d0  discountRatios
           sr0   sr1   sr2   sr3   sr4          coterminalSwaps
        </pre>
    */
    class EvolutionDescription {
        // This typedef is used so that gcc 3.3 can parse the
        // constructor declaration (not even parenthesizing the
        // default argument worked)
        typedef std::pair<Size,Size> range;
      public:
        EvolutionDescription() = default;
        explicit EvolutionDescription(
            const std::vector<Time>& rateTimes,
            const std::vector<Time>& evolutionTimes = std::vector<Time>(),
            const std::vector<std::pair<Size,Size> >& relevanceRates =
                                                        std::vector<range>());
        const std::vector<Time>& rateTimes() const;
        const std::vector<Time>& rateTaus() const;
        const std::vector<Time>& evolutionTimes() const;
        //const Matrix& effectiveStopTimes() const;
        const std::vector<Size>& firstAliveRate() const;
        const std::vector<std::pair<Size,Size> >& relevanceRates() const;
        Size numberOfRates() const;
        Size numberOfSteps() const;
      private:
        Size numberOfRates_;
        std::vector<Time> rateTimes_, evolutionTimes_;
        std::vector<std::pair<Size,Size> > relevanceRates_;
        // convenience variables
        std::vector<Time> rateTaus_;
        std::vector<Size> firstAliveRate_;
    };

    // Numeraire functions

    /*! Check that there is one numeraire for each evolution time.
        Each numeraire must be an index amongst the rate times so it ranges
        from 0 to n. Each numeraire must not have expired before the end of
        the step.
    */
    void checkCompatibility(const EvolutionDescription& evolution,
                            const std::vector<Size>& numeraires);

    bool isInTerminalMeasure(const EvolutionDescription& evolution,
                             const std::vector<Size>& numeraires);
    bool isInMoneyMarketPlusMeasure(const EvolutionDescription& evolution,
                                    const std::vector<Size>& numeraires,
                                    Size offset = 1);
    bool isInMoneyMarketMeasure(const EvolutionDescription& evolution,
                                const std::vector<Size>& numeraires);

    //! Terminal measure: the last bond is used as numeraire.
    std::vector<Size> terminalMeasure(const EvolutionDescription& evolution);

    /*! Offsetted discretely compounded money market account measure:
        for each step the offset-th unexpired bond is used as numeraire.
        When offset=0 the result is the usual discretely compounded money
        market account measure
    */
    std::vector<Size> moneyMarketPlusMeasure(const EvolutionDescription&,
                                             Size offset = 1);

    /*! Discretely compounded money market account measure:
        for each step the first unexpired bond is used as numeraire.
    */
    std::vector<Size> moneyMarketMeasure(const EvolutionDescription&);

}

#endif
]]></document_content>
  </document>
  <document index="49">
    <source>marketmodels/evolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_market_model_evolver_hpp
#define quantlib_market_model_evolver_hpp

#include <ql/types.hpp>
#include <vector>

namespace QuantLib {

    class CurveState;

    //! Market-model evolver
    /*! Abstract base class. The evolver does the actual gritty work of
        evolving the forward rates from one time to the next.
    */
    class MarketModelEvolver {
      public:
        virtual ~MarketModelEvolver() = default;

        virtual const std::vector<Size>& numeraires() const = 0;
        virtual Real startNewPath() = 0;
        virtual Real advanceStep() = 0;
        virtual Size currentStep() const = 0;
        virtual const CurveState& currentState() const = 0;
        virtual void setInitialState(const CurveState&) = 0;
    };

}

#endif
]]></document_content>
  </document>
  <document index="50">
    <source>marketmodels/evolvers/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/marketmodels/evolvers/lognormalcmswapratepc.hpp>
#include <ql/models/marketmodels/evolvers/lognormalcotswapratepc.hpp>
#include <ql/models/marketmodels/evolvers/lognormalfwdrateballand.hpp>
#include <ql/models/marketmodels/evolvers/lognormalfwdrateeuler.hpp>
#include <ql/models/marketmodels/evolvers/lognormalfwdrateeulerconstrained.hpp>
#include <ql/models/marketmodels/evolvers/lognormalfwdrateiballand.hpp>
#include <ql/models/marketmodels/evolvers/lognormalfwdrateipc.hpp>
#include <ql/models/marketmodels/evolvers/lognormalfwdratepc.hpp>
#include <ql/models/marketmodels/evolvers/marketmodelvolprocess.hpp>
#include <ql/models/marketmodels/evolvers/normalfwdratepc.hpp>
#include <ql/models/marketmodels/evolvers/svddfwdratepc.hpp>

#include <ql/models/marketmodels/evolvers/volprocesses/all.hpp>
]]></document_content>
  </document>
  <document index="51">
    <source>marketmodels/evolvers/lognormalcmswapratepc.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006, 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_swap_rate_pc_evolver_hpp
#define quantlib_swap_rate_pc_evolver_hpp

#include <ql/models/marketmodels/evolver.hpp>
#include <ql/models/marketmodels/curvestates/cmswapcurvestate.hpp>
#include <ql/models/marketmodels/driftcomputation/cmsmmdriftcalculator.hpp>

namespace QuantLib {

    class MarketModel;
    class BrownianGenerator;
    class BrownianGeneratorFactory;

    //! Predictor-Corrector
    class LogNormalCmSwapRatePc : public MarketModelEvolver {
      public:
        LogNormalCmSwapRatePc(Size spanningForwards,
                              const ext::shared_ptr<MarketModel>&,
                              const BrownianGeneratorFactory&,
                              const std::vector<Size>& numeraires,
                              Size initialStep = 0);
        //! \name MarketModel interface
        //@{
        const std::vector<Size>& numeraires() const override;
        Real startNewPath() override;
        Real advanceStep() override;
        Size currentStep() const override;
        const CurveState& currentState() const override;
        void setInitialState(const CurveState&) override;
        //@}
      private:
        void setCMSwapRates(const std::vector<Real>& swapRates);
        // inputs
        Size spanningForwards_;
        ext::shared_ptr<MarketModel> marketModel_;
        std::vector<Size> numeraires_;
        Size initialStep_;
        ext::shared_ptr<BrownianGenerator> generator_;
        // fixed variables
        std::vector<std::vector<Real> > fixedDrifts_;
         // working variables
        Size numberOfRates_, numberOfFactors_;
        CMSwapCurveState curveState_;
        Size currentStep_;
        std::vector<Rate> swapRates_, displacements_, logSwapRates_, initialLogSwapRates_;
        std::vector<Real> drifts1_, drifts2_, initialDrifts_;
        std::vector<Real> brownians_, correlatedBrownians_;
        std::vector<Size> alive_;
        // helper classes
        std::vector<CMSMMDriftCalculator> calculators_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="52">
    <source>marketmodels/evolvers/lognormalcotswapratepc.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2007 Cristina Duminuco

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_coterminalswap_rate_pc_evolver_hpp
#define quantlib_coterminalswap_rate_pc_evolver_hpp

#include <ql/models/marketmodels/evolver.hpp>
#include <ql/models/marketmodels/curvestates/coterminalswapcurvestate.hpp>
#include <ql/models/marketmodels/driftcomputation/smmdriftcalculator.hpp>

namespace QuantLib {

    class MarketModel;
    class BrownianGenerator;
    class BrownianGeneratorFactory;

    //! Predictor-Corrector
    class LogNormalCotSwapRatePc : public MarketModelEvolver {
      public:
        LogNormalCotSwapRatePc(const ext::shared_ptr<MarketModel>&,
                               const BrownianGeneratorFactory&,
                               const std::vector<Size>& numeraires,
                               Size initialStep = 0);
        //! \name MarketModel interface
        //@{
        const std::vector<Size>& numeraires() const override;
        Real startNewPath() override;
        Real advanceStep() override;
        Size currentStep() const override;
        const CurveState& currentState() const override;
        void setInitialState(const CurveState&) override;
        //@}
      private:
        void setCoterminalSwapRates(const std::vector<Real>& swapRates);
        // inputs
        ext::shared_ptr<MarketModel> marketModel_;
        std::vector<Size> numeraires_;
        Size initialStep_;
        ext::shared_ptr<BrownianGenerator> generator_;
        // fixed variables
        std::vector<std::vector<Real> > fixedDrifts_;
         // working variables
        Size numberOfRates_, numberOfFactors_;
        CoterminalSwapCurveState curveState_;
        Size currentStep_;
        std::vector<Rate> swapRates_, displacements_, logSwapRates_, initialLogSwapRates_;
        std::vector<Real> drifts1_, drifts2_, initialDrifts_;
        std::vector<Real> brownians_, correlatedBrownians_;
        std::vector<Size> alive_;
        // helper classes
        std::vector<SMMDriftCalculator> calculators_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="53">
    <source>marketmodels/evolvers/lognormalfwdrateballand.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Sun Xiuxin

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_forward_rate_balland_evolver_hpp
#define quantlib_forward_rate_balland_evolver_hpp

#include <ql/models/marketmodels/evolver.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>

namespace QuantLib {

    class MarketModel;
    class BrownianGenerator;
    class BrownianGeneratorFactory;
    class LMMDriftCalculator;

    //! Iterative Predictor-Corrector
    class LogNormalFwdRateBalland : public MarketModelEvolver {
      public:
        LogNormalFwdRateBalland(const ext::shared_ptr<MarketModel>&,
                            const BrownianGeneratorFactory&,
                            const std::vector<Size>& numeraires,
                            Size initialStep = 0);
        //! \name MarketModel interface
        //@{
        const std::vector<Size>& numeraires() const override;
        Real startNewPath() override;
        Real advanceStep() override;
        Size currentStep() const override;
        const CurveState& currentState() const override;
        void setInitialState(const CurveState&) override;
        //@}
      private:
        void setForwards(const std::vector<Real>& forwards);
        // inputs
        ext::shared_ptr<MarketModel> marketModel_;
        std::vector<Size> numeraires_;
        Size initialStep_;
        ext::shared_ptr<BrownianGenerator> generator_;
        // fixed variables
        std::vector<std::vector<Real> > fixedDrifts_;
         // working variables
        Size numberOfRates_, numberOfFactors_;
        LMMCurveState curveState_;
        Size currentStep_;
        std::vector<Rate> forwards_, displacements_, logForwards_, initialLogForwards_;
        std::vector<Real> drifts1_, drifts2_, initialDrifts_;
        std::vector<Real> brownians_, correlatedBrownians_;
        std::vector<Time> rateTaus_;
        std::vector<Size> alive_;
        //std::vector<Matrix> C_;
        // helper classes
        std::vector<LMMDriftCalculator> calculators_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="54">
    <source>marketmodels/evolvers/lognormalfwdrateeuler.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_forward_rate_euler_evolver_hpp
#define quantlib_forward_rate_euler_evolver_hpp

#include <ql/models/marketmodels/evolver.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>

namespace QuantLib {

    class MarketModel;
    class BrownianGenerator;
    class BrownianGeneratorFactory;
    class LMMDriftCalculator;

    //! Euler
    class LogNormalFwdRateEuler : public MarketModelEvolver {
      public:
        LogNormalFwdRateEuler(const ext::shared_ptr<MarketModel>&,
                              const BrownianGeneratorFactory&,
                              const std::vector<Size>& numeraires,
                              Size initialStep = 0);
        //! \name MarketModel interface
        //@{
        const std::vector<Size>& numeraires() const override;
        Real startNewPath() override;
        Real advanceStep() override;
        Size currentStep() const override;
        const CurveState& currentState() const override;
        void setInitialState(const CurveState&) override;
        //@}

        //! accessor methods useful for doing pathwise vegas
        const std::vector<Real>& browniansThisStep() const
        {
            return brownians_;
        }
     


      private:
        void setForwards(const std::vector<Real>& forwards);
        // inputs
        ext::shared_ptr<MarketModel> marketModel_;
        std::vector<Size> numeraires_;
        Size initialStep_;
        ext::shared_ptr<BrownianGenerator> generator_;
        // fixed variables
        std::vector<std::vector<Real> > fixedDrifts_;
         // working variables
        Size numberOfRates_, numberOfFactors_;
        LMMCurveState curveState_;
        Size currentStep_;
        std::vector<Rate> forwards_, displacements_, logForwards_, initialLogForwards_;
        std::vector<Real> drifts1_, initialDrifts_;
        std::vector<Real> brownians_, correlatedBrownians_;
        std::vector<Size> alive_;
        // helper classes
        std::vector<LMMDriftCalculator> calculators_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="55">
    <source>marketmodels/evolvers/lognormalfwdrateeulerconstrained.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_forward_rate_euler_constrained_evolver_hpp
#define quantlib_forward_rate_euler_constrained_evolver_hpp

#include <ql/models/marketmodels/constrainedevolver.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>
#include <ql/models/marketmodels/driftcomputation/lmmdriftcalculator.hpp>
#include <valarray>

namespace QuantLib {

    class MarketModel;
    class BrownianGenerator;
    class BrownianGeneratorFactory;

    //! euler stepping
    class LogNormalFwdRateEulerConstrained : public ConstrainedEvolver
        {
      public:
        LogNormalFwdRateEulerConstrained(const ext::shared_ptr<MarketModel>&,
                                         const BrownianGeneratorFactory&,
                                         const std::vector<Size>& numeraires,
                                         Size initialStep = 0);
        //! \name MarketModelConstrained interface
        //@{
        void setConstraintType(const std::vector<Size>& startIndexOfSwapRate,
                               const std::vector<Size>& endIndexOfSwapRate) override;
        void setThisConstraint(const std::vector<Rate>& rateConstraints,
                               const std::valarray<bool>& isConstraintActive) override;
        //@}
        //! \name MarketModel interface
        //@{
        const std::vector<Size>& numeraires() const override;
        Real startNewPath() override;
        Real advanceStep() override;
        Size currentStep() const override;
        const CurveState& currentState() const override;
        void setInitialState(const CurveState&) override;
        //@}
      private:
        void setForwards(const std::vector<Real>& forwards);
        // inputs
        ext::shared_ptr<MarketModel> marketModel_;
        std::vector<Size> numeraires_;
        Size initialStep_;
        ext::shared_ptr<BrownianGenerator> generator_;

        std::vector<Size> startIndexOfSwapRate_;
        std::vector<Size> endIndexOfSwapRate_;

        //often changing inputs
        std::vector<Rate> rateConstraints_;
        std::valarray<bool> isConstraintActive_;

        // fixed variables
        std::vector<std::vector<Real> > fixedDrifts_;
        std::vector<std::vector<Real> > variances_;

        // working variables
        std::vector<std::vector<Real> > covariances_; // covariance of constrained rate with other rates on same step
                                                                                          // step first index
        Size numberOfRates_, numberOfFactors_;
        LMMCurveState curveState_;
        Size currentStep_;
        std::vector<Rate> forwards_, displacements_, logForwards_, initialLogForwards_;
        std::vector<Real> drifts1_, initialDrifts_;
        std::vector<Real> brownians_, correlatedBrownians_;
        std::vector<Size> alive_;
         // helper classes
        std::vector<LMMDriftCalculator> calculators_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="56">
    <source>marketmodels/evolvers/lognormalfwdrateiballand.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Sun Xiuxin

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_forward_rate_iballand_evolver_hpp
#define quantlib_forward_rate_iballand_evolver_hpp

#include <ql/models/marketmodels/evolver.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>

namespace QuantLib {

    class MarketModel;
    class BrownianGenerator;
    class BrownianGeneratorFactory;
    class LMMDriftCalculator;

    //! Iterative Predictor-Corrector
    class LogNormalFwdRateiBalland : public MarketModelEvolver {
      public:
        LogNormalFwdRateiBalland(const ext::shared_ptr<MarketModel>&,
                            const BrownianGeneratorFactory&,
                            const std::vector<Size>& numeraires,
                            Size initialStep = 0);
        //! \name MarketModel interface
        //@{
        const std::vector<Size>& numeraires() const override;
        Real startNewPath() override;
        Real advanceStep() override;
        Size currentStep() const override;
        const CurveState& currentState() const override;
        void setInitialState(const CurveState&) override;
        //@}
      private:
        void setForwards(const std::vector<Real>& forwards);
        // inputs
        ext::shared_ptr<MarketModel> marketModel_;
        std::vector<Size> numeraires_;
        Size initialStep_;
        ext::shared_ptr<BrownianGenerator> generator_;
        // fixed variables
        std::vector<std::vector<Real> > fixedDrifts_;
         // working variables
        Size numberOfRates_, numberOfFactors_;
        LMMCurveState curveState_;
        Size currentStep_;
        std::vector<Rate> forwards_, displacements_, logForwards_, initialLogForwards_;
        std::vector<Real> initialDrifts_;
        std::vector<Real> brownians_, correlatedBrownians_;
        std::vector<Time> rateTaus_;
        std::vector<Size> alive_;
        //std::vector<Matrix> C_;
        // helper classes
        std::vector<LMMDriftCalculator> calculators_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="57">
    <source>marketmodels/evolvers/lognormalfwdrateipc.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_forward_rate_ipc_evolver_hpp
#define quantlib_forward_rate_ipc_evolver_hpp

#include <ql/models/marketmodels/evolver.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>

namespace QuantLib {

    class MarketModel;
    class BrownianGenerator;
    class BrownianGeneratorFactory;
    class LMMDriftCalculator;

    //! Iterative Predictor-Corrector
    class LogNormalFwdRateIpc : public MarketModelEvolver {
      public:
        LogNormalFwdRateIpc(const ext::shared_ptr<MarketModel>&,
                            const BrownianGeneratorFactory&,
                            const std::vector<Size>& numeraires,
                            Size initialStep = 0);
        //! \name MarketModel interface
        //@{
        const std::vector<Size>& numeraires() const override;
        Real startNewPath() override;
        Real advanceStep() override;
        Size currentStep() const override;
        const CurveState& currentState() const override;
        void setInitialState(const CurveState&) override;
        //@}
      private:
        void setForwards(const std::vector<Real>& forwards);
        // inputs
        ext::shared_ptr<MarketModel> marketModel_;
        std::vector<Size> numeraires_;
        Size initialStep_;
        ext::shared_ptr<BrownianGenerator> generator_;
        // fixed variables
        std::vector<std::vector<Real> > fixedDrifts_;
         // working variables
        Size numberOfRates_, numberOfFactors_;
        LMMCurveState curveState_;
        Size currentStep_;
        std::vector<Rate> forwards_, displacements_, logForwards_, initialLogForwards_;
        std::vector<Real> drifts1_, initialDrifts_, g_;
        std::vector<Real> brownians_, correlatedBrownians_;
        std::vector<Time> rateTaus_;
        std::vector<Size> alive_;
        //std::vector<Matrix> C_;
        // helper classes
        std::vector<LMMDriftCalculator> calculators_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="58">
    <source>marketmodels/evolvers/lognormalfwdratepc.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_forward_rate_pc_evolver_hpp
#define quantlib_forward_rate_pc_evolver_hpp

#include <ql/models/marketmodels/evolver.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>
#include <ql/models/marketmodels/driftcomputation/lmmdriftcalculator.hpp>

namespace QuantLib {

    class MarketModel;
    class BrownianGenerator;
    class BrownianGeneratorFactory;

    //! Predictor-Corrector
    class LogNormalFwdRatePc : public MarketModelEvolver {
      public:
        LogNormalFwdRatePc(const ext::shared_ptr<MarketModel>&,
                           const BrownianGeneratorFactory&,
                           const std::vector<Size>& numeraires,
                           Size initialStep = 0);
        //! \name MarketModel interface
        //@{
        const std::vector<Size>& numeraires() const override;
        Real startNewPath() override;
        Real advanceStep() override;
        Size currentStep() const override;
        const CurveState& currentState() const override;
        void setInitialState(const CurveState&) override;
        //@}
      private:
        void setForwards(const std::vector<Real>& forwards);
        // inputs
        ext::shared_ptr<MarketModel> marketModel_;
        std::vector<Size> numeraires_;
        Size initialStep_;
        ext::shared_ptr<BrownianGenerator> generator_;
        // fixed variables
        std::vector<std::vector<Real> > fixedDrifts_;
         // working variables
        Size numberOfRates_, numberOfFactors_;
        LMMCurveState curveState_;
        Size currentStep_;
        std::vector<Rate> forwards_, displacements_, logForwards_, initialLogForwards_;
        std::vector<Real> drifts1_, drifts2_, initialDrifts_;
        std::vector<Real> brownians_, correlatedBrownians_;
        std::vector<Size> alive_;
        // helper classes
        std::vector<LMMDriftCalculator> calculators_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="59">
    <source>marketmodels/evolvers/marketmodelvolprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_market_model_vol_process_hpp
#define quantlib_market_model_vol_process_hpp
#include <ql/types.hpp>
#include <vector>

namespace QuantLib 
{

  
    /*!
   Displaced diffusion LMM with uncorrelated vol process. Called "Shifted BGM" with Heston vol by Brace in "Engineering BGM."
   Vol process is an external input.
    
    */
    class MarketModelVolProcess 
    {
      public:
          MarketModelVolProcess() = default;
          virtual ~MarketModelVolProcess() = default;

          virtual Size variatesPerStep()=0;
          virtual Size numberSteps()=0;

          virtual void nextPath() =0;
          virtual Real nextstep(const std::vector<Real>& variates)=0;
          virtual Real stepSd() const =0;

          virtual const std::vector<Real>& stateVariables() const=0;
          virtual Size numberStateVariables() const=0;
     
      private:
 
    };

}

#endif
]]></document_content>
  </document>
  <document index="60">
    <source>marketmodels/evolvers/normalfwdratepc.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2007 Chiara Fornarola

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_forward_rate_normal_pc_evolver_hpp
#define quantlib_forward_rate_normal_pc_evolver_hpp

#include <ql/models/marketmodels/evolver.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>
#include <ql/models/marketmodels/driftcomputation/lmmnormaldriftcalculator.hpp>

namespace QuantLib {

    class MarketModel;
    class BrownianGenerator;
    class BrownianGeneratorFactory;

    //! Predictor-Corrector
    class NormalFwdRatePc : public MarketModelEvolver {
      public:
        NormalFwdRatePc(const ext::shared_ptr<MarketModel>&,
                        const BrownianGeneratorFactory&,
                        const std::vector<Size>& numeraires,
                        Size initialStep = 0);
        //! \name MarketModel interface
        //@{
        const std::vector<Size>& numeraires() const override;
        Real startNewPath() override;
        Real advanceStep() override;
        Size currentStep() const override;
        const CurveState& currentState() const override;
        void setInitialState(const CurveState&) override;
        //@}
      private:
        void setForwards(const std::vector<Real>& forwards);
        // inputs
        ext::shared_ptr<MarketModel> marketModel_;
        std::vector<Size> numeraires_;
        Size initialStep_;
        ext::shared_ptr<BrownianGenerator> generator_;
         // working variables
        Size numberOfRates_, numberOfFactors_;
        LMMCurveState curveState_;
        Size currentStep_;
        std::vector<Rate> forwards_, initialForwards_;
        std::vector<Real> drifts1_, drifts2_, initialDrifts_;
        std::vector<Real> brownians_, correlatedBrownians_;
        std::vector<Size> alive_;
        // helper classes
        std::vector<LMMNormalDriftCalculator> calculators_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="61">
    <source>marketmodels/evolvers/svddfwdratepc.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_svdd_forward_rate_pc_evolver_hpp
#define quantlib_svdd_forward_rate_pc_evolver_hpp

#include <ql/models/marketmodels/evolver.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>
#include <ql/models/marketmodels/driftcomputation/lmmdriftcalculator.hpp>
#include <valarray>

namespace QuantLib {

    class MarketModel;
    class BrownianGenerator;
    class BrownianGeneratorFactory;
    class MarketModelVolProcess;

    /*!
   Displaced diffusion LMM with uncorrelated vol process. Called "Shifted BGM" with Heston vol by Brac in "Engineering BGM."
   Vol process is an external input.
    
    */
    class SVDDFwdRatePc : public MarketModelEvolver 
    {
      public:
    
          SVDDFwdRatePc(const ext::shared_ptr<MarketModel>&,
                           const BrownianGeneratorFactory&,
                           const ext::shared_ptr<MarketModelVolProcess>& volProcess,
                           Size firstVolatilityFactor, 
                           Size volatilityFactorStep,
                           const std::vector<Size>& numeraires,
                           Size initialStep = 0);
        //! \name MarketModel interface
        //@{
          const std::vector<Size>& numeraires() const override;
          Real startNewPath() override;
          Real advanceStep() override;
          Size currentStep() const override;
          const CurveState& currentState() const override;
          void setInitialState(const CurveState&) override;
          //@}
        private:
          void setForwards(const std::vector<Real>& forwards);
          // inputs
          ext::shared_ptr<MarketModel> marketModel_;
          ext::shared_ptr<BrownianGenerator> generator_;
          ext::shared_ptr<MarketModelVolProcess> volProcess_;

          Size firstVolatilityFactor_;
          Size volFactorsPerStep_;

          std::vector<Size> numeraires_;
          Size initialStep_;


          // fixed variables
          std::vector<std::vector<Real> > fixedDrifts_;
          std::valarray<bool> isVolVariate_;
          // working variables
          Size numberOfRates_, numberOfFactors_;
          LMMCurveState curveState_;
          Size currentStep_;
          std::vector<Rate> forwards_, displacements_, logForwards_, initialLogForwards_;
          std::vector<Real> drifts1_, drifts2_, initialDrifts_;
          std::vector<Real> allBrownians_, brownians_, volBrownians_, correlatedBrownians_;
          std::vector<Size> alive_;
          // helper classes
          std::vector<LMMDriftCalculator> calculators_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="62">
    <source>marketmodels/evolvers/volprocesses/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/marketmodels/evolvers/volprocesses/squarerootandersen.hpp>

]]></document_content>
  </document>
  <document index="63">
    <source>marketmodels/evolvers/volprocesses/squarerootandersen.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_square_root_andersen_hpp
#define quantlib_square_root_andersen_hpp

#include <ql/models/marketmodels/evolvers/marketmodelvolprocess.hpp>

namespace QuantLib 
{

  
    /*!
   Displaced diffusion LMM with uncorrelated vol process. Called "Shifted BGM" with Heston vol by Brace in "Engineering BGM."
   Vol process is an external input.
    
    */
    class SquareRootAndersen  : public MarketModelVolProcess
    {
      public:
          SquareRootAndersen(Real meanLevel,
                             Real reversionSpeed,
                             Real volVar,
                             Real v0,
                             const std::vector<Real>& evolutionTimes,
                             Size numberSubSteps_,
                             Real w1,
                             Real w2,
                             Real cutPoint = 1.5);

          Size variatesPerStep() override;
          Size numberSteps() override;

          void nextPath() override;
          Real nextstep(const std::vector<Real>& variates) override;
          Real stepSd() const override;

          const std::vector<Real>& stateVariables() const override;
          Size numberStateVariables() const override;

        private:

          void DoOneSubStep(Real& v, Real variate, Size j);

          Real theta_; // mean level

          Real k_; // reversion speed
          Real epsilon_; // volvar

          Real v0_; // initial value of instantaneous variance
          Size numberSubSteps_; // sub steps per evolution time 


          std::vector<Real> dt_; // time step lengths
          std::vector<Real> eMinuskDt_; // exp( - k * dt) 

          Real w1_; // weights to use for computing variance across step
          Real w2_; 
          Real PsiC_; // cut-off between two types of evolution

          //! evolving values
          Real v_;
          Size currentStep_;
          Size subStep_;
          std::vector<Real> vPath_;

          mutable std::vector<Real> state_;
 
    };

}

#endif
]]></document_content>
  </document>
  <document index="64">
    <source>marketmodels/forwardforwardmappings.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2007 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file forwardforwardmappings.hpp
\brief Utility functions for mapping between forward rates of varying tenor
*/

#ifndef quantlib_forward_forward_mappings_hpp
#define quantlib_forward_forward_mappings_hpp

#include <ql/math/matrix.hpp>

namespace QuantLib {

    class CurveState;
    class LMMCurveState;

    namespace ForwardForwardMappings 
        {
            /*! Returns the dg[i]/df[j] jacobian between
            forward rates with tenor multipler and forward rates with tenor 1*/
            Matrix ForwardForwardJacobian(const CurveState& cs, 
                                          Size multiplier,
                                          Size offset);

            /*! Returns the Y matrix to switch base          
            forward rates with tenor multipler and forward rates with tenor 1*/

            Matrix YMatrix(const CurveState& cs,
                           const std::vector<Spread>& shortDisplacements,
                           const std::vector<Spread>& longDisplacements,
                           Size Multiplier,
                           Size offset);

            /*! 
            replaces curve state with curve state based on periodic subset of times

            */
            LMMCurveState RestrictCurveState(const CurveState& cs,
                                             Size multiplier,
                                             Size offSet);

        }

    }

#endif
]]></document_content>
  </document>
  <document index="65">
    <source>marketmodels/historicalforwardratesanalysis.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 François du Vignaud
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2007 Katiuscia Manzoni

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file historicalforwardratesanalysis.hpp
    \brief Statistical analysis of historical forward rates
*/

#ifndef quantlib_historical_forward_rates_analysis_hpp
#define quantlib_historical_forward_rates_analysis_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/math/matrix.hpp>
#include <ql/math/statistics/sequencestatistics.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/yield/piecewiseyieldcurve.hpp>
#include <ql/termstructures/yield/ratehelpers.hpp>
#include <ql/time/calendar.hpp>
#include <ql/time/date.hpp>
#include <utility>

namespace QuantLib {

    template<class Traits, class Interpolator>
    void historicalForwardRatesAnalysis(
                SequenceStatistics& statistics,
                std::vector<Date>& skippedDates,
                std::vector<std::string>& skippedDatesErrorMessage,
                std::vector<Date>& failedDates,
                std::vector<std::string>& failedDatesErrorMessage,
                std::vector<Period>& fixingPeriods,
                const Date& startDate,
                const Date& endDate,
                const Period& step,
                const ext::shared_ptr<InterestRateIndex>& fwdIndex,
                const Period& initialGap,
                const Period& horizon,
                const std::vector<ext::shared_ptr<IborIndex> >& iborIndexes,
                const std::vector<ext::shared_ptr<SwapIndex> >& swapIndexes,
                const DayCounter& yieldCurveDayCounter,
                Real yieldCurveAccuracy = 1.0e-12,
                const Interpolator& i = Interpolator()) {


        statistics.reset();
        skippedDates.clear();
        skippedDatesErrorMessage.clear();
        failedDates.clear();
        failedDatesErrorMessage.clear();
        fixingPeriods.clear();

        SavedSettings backup;
        Settings::instance().enforcesTodaysHistoricFixings() = true;

        std::vector<ext::shared_ptr<RateHelper> > rateHelpers;

        // Create DepositRateHelper
        std::vector<ext::shared_ptr<SimpleQuote> > iborQuotes;
        std::vector<ext::shared_ptr<IborIndex> >::const_iterator ibor;
        for (ibor=iborIndexes.begin(); ibor!=iborIndexes.end(); ++ibor) {
            ext::shared_ptr<SimpleQuote> quote(new SimpleQuote);
            iborQuotes.push_back(quote);
            Handle<Quote> quoteHandle(quote);
            rateHelpers.push_back(ext::shared_ptr<RateHelper> (new
                DepositRateHelper(quoteHandle,
                                  (*ibor)->tenor(),
                                  (*ibor)->fixingDays(),
                                  (*ibor)->fixingCalendar(),
                                  (*ibor)->businessDayConvention(),
                                  (*ibor)->endOfMonth(),
                                  (*ibor)->dayCounter())));
        }

        // Create SwapRateHelper
        std::vector<ext::shared_ptr<SimpleQuote> > swapQuotes;
        std::vector<ext::shared_ptr<SwapIndex> >::const_iterator swap;
        for (swap=swapIndexes.begin(); swap!=swapIndexes.end(); ++swap) {
            ext::shared_ptr<SimpleQuote> quote(new SimpleQuote);
            swapQuotes.push_back(quote);
            Handle<Quote> quoteHandle(quote);
            rateHelpers.push_back(ext::shared_ptr<RateHelper> (new
                SwapRateHelper(quoteHandle,
                               (*swap)->tenor(),
                               (*swap)->fixingCalendar(),
                               (*swap)->fixedLegTenor().frequency(),
                               (*swap)->fixedLegConvention(),
                               (*swap)->dayCounter(),
                               (*swap)->iborIndex())));
        }

        // Set up the forward rates time grid
        Period indexTenor = fwdIndex->tenor();
        Period fixingPeriod = initialGap;
        while (fixingPeriod<=horizon) {
            fixingPeriods.push_back(fixingPeriod);
            fixingPeriod += indexTenor;
        }

        Size nRates = fixingPeriods.size();
        statistics.reset(nRates);
        std::vector<Rate> fwdRates(nRates);
        std::vector<Rate> prevFwdRates(nRates);
        std::vector<Rate> fwdRatesDiff(nRates);
        DayCounter indexDayCounter = fwdIndex->dayCounter();
        Calendar cal = fwdIndex->fixingCalendar();

        // Bootstrap the yield curve at the currentDate
        Natural settlementDays = 0;
        typename PiecewiseYieldCurve<Traits, Interpolator>::bootstrap_type bootstrap(yieldCurveAccuracy);
        PiecewiseYieldCurve<Traits, Interpolator> yc(settlementDays,
                                                     cal,
                                                     rateHelpers,
                                                     yieldCurveDayCounter,
                                                     std::vector<Handle<Quote> >(),
                                                     std::vector<Date>(),
                                                     i,
                                                     bootstrap);

        // start with a valid business date
        Date currentDate = cal.advance(startDate, 1*Days, Following);
        bool isFirst = true;
        // Loop over the historical dataset
        for (; currentDate<=endDate;
            currentDate = cal.advance(currentDate, step, Following)) {

            // move the evaluationDate to currentDate
            // and update ratehelpers dates...
            Settings::instance().evaluationDate() = currentDate;

            try {
                // update the quotes...
                for (Size i=0; i<iborIndexes.size(); ++i) {
                    Rate fixing = iborIndexes[i]->fixing(currentDate, false);
                    iborQuotes[i]->setValue(fixing);
                }
                for (Size i=0; i<swapIndexes.size(); ++i) {
                    Rate fixing = swapIndexes[i]->fixing(currentDate, false);
                    swapQuotes[i]->setValue(fixing);
                }
            } catch (std::exception& e) {
                skippedDates.push_back(currentDate);
                skippedDatesErrorMessage.emplace_back(e.what());
                continue;
            }

            try {
                for (Size i=0; i<nRates; ++i) {
                    // Time-to-go forwards
                    Date d = currentDate + fixingPeriods[i];
                    fwdRates[i] = yc.forwardRate(d,
                                                 indexTenor,
                                                 indexDayCounter,
                                                 Simple);
                }
            } catch (std::exception& e) {
                failedDates.push_back(currentDate);
                failedDatesErrorMessage.emplace_back(e.what());
                continue;
            }

            // From 2nd step onwards, calculate forward rate
            // relative differences
            if (!isFirst){
                for (Size i=0; i<nRates; ++i)
                    fwdRatesDiff[i] = fwdRates[i]/prevFwdRates[i] -1.0;
                // add observation
                statistics.add(fwdRatesDiff.begin(), fwdRatesDiff.end());
            }
            else
                isFirst = false;

            // Store last calculated forward rates
            std::swap(prevFwdRates, fwdRates);

        }
    }

    class HistoricalForwardRatesAnalysis {
      public:
        virtual ~HistoricalForwardRatesAnalysis() = default;
        virtual const std::vector<Date>& skippedDates() const = 0;
        virtual const std::vector<std::string>& skippedDatesErrorMessage() const = 0;
        virtual const std::vector<Date>& failedDates() const = 0;
        virtual const std::vector<std::string>& failedDatesErrorMessage() const = 0;
        virtual const std::vector<Period>& fixingPeriods() const = 0;
    };

    //! %Historical correlation class
    template<class Traits, class Interpolator>
    class HistoricalForwardRatesAnalysisImpl : public HistoricalForwardRatesAnalysis {
      public:
        HistoricalForwardRatesAnalysisImpl(
            ext::shared_ptr<SequenceStatistics> stats,
            const Date& startDate,
            const Date& endDate,
            const Period& step,
            const ext::shared_ptr<InterestRateIndex>& fwdIndex,
            const Period& initialGap,
            const Period& horizon,
            const std::vector<ext::shared_ptr<IborIndex> >& iborIndexes,
            const std::vector<ext::shared_ptr<SwapIndex> >& swapIndexes,
            const DayCounter& yieldCurveDayCounter,
            Real yieldCurveAccuracy);
        HistoricalForwardRatesAnalysisImpl() = default;
        ;
        const std::vector<Date>& skippedDates() const override;
        const std::vector<std::string>& skippedDatesErrorMessage() const override;
        const std::vector<Date>& failedDates() const override;
        const std::vector<std::string>& failedDatesErrorMessage() const override;
        const std::vector<Period>& fixingPeriods() const override;
        //const ext::shared_ptr<SequenceStatistics>& stats() const;
      private:
        // calculated data
        ext::shared_ptr<SequenceStatistics> stats_;
        std::vector<Date> skippedDates_;
        std::vector<std::string> skippedDatesErrorMessage_;
        std::vector<Date> failedDates_;
        std::vector<std::string> failedDatesErrorMessage_;
        std::vector<Period> fixingPeriods_;
    };

    // inline
    template<class Traits, class Interpolator>
    const std::vector<Period>&
    HistoricalForwardRatesAnalysisImpl<Traits, Interpolator>::fixingPeriods() const {
        return fixingPeriods_;
    }

    template<class Traits, class Interpolator>
    inline const std::vector<Date>&
    HistoricalForwardRatesAnalysisImpl<Traits, Interpolator>::skippedDates() const {
        return skippedDates_;
    }

    template<class Traits, class Interpolator>
    inline const std::vector<std::string>&
    HistoricalForwardRatesAnalysisImpl<Traits, Interpolator>::skippedDatesErrorMessage() const {
        return skippedDatesErrorMessage_;
    }

    template<class Traits, class Interpolator>
    inline const std::vector<Date>&
    HistoricalForwardRatesAnalysisImpl<Traits, Interpolator>::failedDates() const {
        return failedDates_;
    }

    template<class Traits, class Interpolator>
    inline const std::vector<std::string>&
    HistoricalForwardRatesAnalysisImpl<Traits, Interpolator>::failedDatesErrorMessage() const {
        return failedDatesErrorMessage_;
    }

    //inline const ext::shared_ptr<SequenceStatistics>&
    //HistoricalForwardRatesAnalysis::stats() const {
    //    return stats_;
    //}
    template <class Traits, class Interpolator>
    HistoricalForwardRatesAnalysisImpl<Traits, Interpolator>::HistoricalForwardRatesAnalysisImpl(
        ext::shared_ptr<SequenceStatistics> stats,
        const Date& startDate,
        const Date& endDate,
        const Period& step,
        const ext::shared_ptr<InterestRateIndex>& fwdIndex,
        const Period& initialGap,
        const Period& horizon,
        const std::vector<ext::shared_ptr<IborIndex> >& iborIndexes,
        const std::vector<ext::shared_ptr<SwapIndex> >& swapIndexes,
        const DayCounter& yieldCurveDayCounter,
        Real yieldCurveAccuracy)
    : stats_(std::move(stats)) {
        historicalForwardRatesAnalysis<Traits,
                                       Interpolator>(
                    *stats_,
                    skippedDates_, skippedDatesErrorMessage_,
                    failedDates_, failedDatesErrorMessage_,
                    fixingPeriods_, startDate, endDate, step,
                    fwdIndex, initialGap, horizon,
                    iborIndexes, swapIndexes,
                    yieldCurveDayCounter, yieldCurveAccuracy);
    }
}

#endif
]]></document_content>
  </document>
  <document index="66">
    <source>marketmodels/historicalratesanalysis.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file historicalratesanalysis.hpp
    \brief Statistical analysis of historical rates
*/

#ifndef quantlib_historical_rates_analysis_hpp
#define quantlib_historical_rates_analysis_hpp

#include <ql/math/statistics/sequencestatistics.hpp>
#include <ql/time/date.hpp>

namespace QuantLib {

    class InterestRateIndex;

    void historicalRatesAnalysis(
                SequenceStatistics& statistics,
                std::vector<Date>& skippedDates,
                std::vector<std::string>& skippedDatesErrorMessage,
                const Date& startDate,
                const Date& endDate,
                const Period& step,
                const std::vector<ext::shared_ptr<InterestRateIndex> >& indexes);

    //! %Historical rate analysis class
    class HistoricalRatesAnalysis {
      public:
        HistoricalRatesAnalysis(ext::shared_ptr<SequenceStatistics> stats,
                                const Date& startDate,
                                const Date& endDate,
                                const Period& step,
                                const std::vector<ext::shared_ptr<InterestRateIndex> >& indexes);
        const std::vector<Date>& skippedDates() const;
        const std::vector<std::string>& skippedDatesErrorMessage() const;
        const ext::shared_ptr<SequenceStatistics>& stats() const;
      private:
        // calculated data
        ext::shared_ptr<SequenceStatistics> stats_;
        std::vector<Date> skippedDates_;
        std::vector<std::string> skippedDatesErrorMessage_;
    };

    // inline

    inline const std::vector<Date>&
    HistoricalRatesAnalysis::skippedDates() const {
        return skippedDates_;
    }

    inline const std::vector<std::string>&
    HistoricalRatesAnalysis::skippedDatesErrorMessage() const {
        return skippedDatesErrorMessage_;
    }

    inline const ext::shared_ptr<SequenceStatistics>&
    HistoricalRatesAnalysis::stats() const {
        return stats_;
    }

}

#endif
]]></document_content>
  </document>
  <document index="67">
    <source>marketmodels/marketmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006, 2007 Mark Joshi
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_marketmodel_hpp
#define quantlib_marketmodel_hpp

#include <ql/math/matrix.hpp>
#include <ql/utilities/null.hpp>
#include <ql/patterns/observable.hpp>
#include <vector>

namespace QuantLib {

    class EvolutionDescription;

    //! base class for market models
    /*! For each time step, generates the pseudo-square root of the covariance
        matrix for that time step.
    */
    class MarketModel {
      public:
        virtual ~MarketModel() = default;
        virtual const std::vector<Rate>& initialRates() const = 0;
        virtual const std::vector<Spread>& displacements() const = 0;
        virtual const EvolutionDescription& evolution() const = 0;
        virtual Size numberOfRates() const = 0;
        virtual Size numberOfFactors() const = 0;
        virtual Size numberOfSteps() const = 0;
        virtual const Matrix& pseudoRoot(Size i) const = 0;
        virtual const Matrix& covariance(Size i) const;
        virtual const Matrix& totalCovariance(Size endIndex) const;
        std::vector<Volatility> timeDependentVolatility(Size i) const;
    private:
        mutable std::vector<Matrix> covariance_, totalCovariance_;
    };

    //! base class for market-model factories
    class MarketModelFactory : public Observable {
      public:
        ~MarketModelFactory() override = default;
        virtual ext::shared_ptr<MarketModel> create(
                                              const EvolutionDescription&,
                                              Size numberOfFactors) const = 0;
    };
    

}

#endif
]]></document_content>
  </document>
  <document index="68">
    <source>marketmodels/marketmodeldifferences.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 François du Vignaud

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_market_model_differences_hpp
#define quantlib_market_model_differences_hpp

#include <ql/types.hpp>
#include <ql/shared_ptr.hpp>
#include <vector>

namespace QuantLib {
    class MarketModel;
    class PiecewiseConstantCorrelation;
    class PiecewiseConstantVariance;

    std::vector<Volatility> rateVolDifferences(
                                           const MarketModel& marketModel1,
                                           const MarketModel& marketModel2);

    std::vector<Spread> rateInstVolDifferences(
                                           const MarketModel& marketModel1,
                                           const MarketModel& marketModel2,
                                           Size index);

    std::vector<Real> coterminalSwapPseudoRoots(
            const PiecewiseConstantCorrelation&,
            const std::vector<ext::shared_ptr<PiecewiseConstantVariance> >&,
            const std::vector<Time>&);
}

#endif
]]></document_content>
  </document>
  <document index="69">
    <source>marketmodels/models/abcdvol.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi
 Copyright (C) 2005, 2006 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_exp_corr_abcd_vol_hpp
#define quantlib_exp_corr_abcd_vol_hpp

#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/math/matrix.hpp>
#include <vector>

namespace QuantLib {

    class PiecewiseConstantCorrelation;

    //! %Abcd-interpolated volatility structure
    class AbcdVol : public MarketModel {
      public:
        AbcdVol(Real a,
                Real b,
                Real c,
                Real d,
                const std::vector<Real>& ks,
                const ext::shared_ptr<PiecewiseConstantCorrelation>& corr,
                const EvolutionDescription& evolution,
                Size numberOfFactors,
                const std::vector<Rate>& initialRates,
                const std::vector<Spread>& displacements);
        //! \name MarketModel interface
        //@{
        const std::vector<Rate>& initialRates() const override;
        const std::vector<Spread>& displacements() const override;
        const EvolutionDescription& evolution() const override;
        Size numberOfRates() const override;
        Size numberOfFactors() const override;
        Size numberOfSteps() const override;
        const Matrix& pseudoRoot(Size i) const override;
        //@}
      private:
        Size numberOfFactors_, numberOfRates_, numberOfSteps_;
        std::vector<Rate> initialRates_;
        std::vector<Spread> displacements_;
        EvolutionDescription evolution_;
        std::vector<Matrix> pseudoRoots_;
    };

    // inline

    inline const std::vector<Rate>& AbcdVol::initialRates() const {
        return initialRates_;
    }

    inline const std::vector<Spread>& AbcdVol::displacements() const {
        return displacements_;
    }

    inline const EvolutionDescription& AbcdVol::evolution() const {
        return evolution_;
    }

    inline Size AbcdVol::numberOfRates() const {
        return numberOfRates_;
    }

    inline Size AbcdVol::numberOfFactors() const {
        return numberOfFactors_;
    }

    inline Size AbcdVol::numberOfSteps() const {
        return numberOfSteps_;
    }

    inline const Matrix& AbcdVol::pseudoRoot(Size i) const {
        QL_REQUIRE(i<numberOfSteps_,
                   "the index " << i << " is invalid: it must be less than "
                   "number of steps (" << numberOfSteps_ << ")");
        return pseudoRoots_[i];
    }
}

#endif
]]></document_content>
  </document>
  <document index="70">
    <source>marketmodels/models/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/marketmodels/models/abcdvol.hpp>
#include <ql/models/marketmodels/models/alphafinder.hpp>
#include <ql/models/marketmodels/models/alphaform.hpp>
#include <ql/models/marketmodels/models/alphaformconcrete.hpp>
#include <ql/models/marketmodels/models/capletcoterminalalphacalibration.hpp>
#include <ql/models/marketmodels/models/capletcoterminalmaxhomogeneity.hpp>
#include <ql/models/marketmodels/models/capletcoterminalperiodic.hpp>
#include <ql/models/marketmodels/models/capletcoterminalswaptioncalibration.hpp>
#include <ql/models/marketmodels/models/cotswaptofwdadapter.hpp>
#include <ql/models/marketmodels/models/ctsmmcapletcalibration.hpp>
#include <ql/models/marketmodels/models/flatvol.hpp>
#include <ql/models/marketmodels/models/fwdperiodadapter.hpp>
#include <ql/models/marketmodels/models/fwdtocotswapadapter.hpp>
#include <ql/models/marketmodels/models/piecewiseconstantabcdvariance.hpp>
#include <ql/models/marketmodels/models/piecewiseconstantvariance.hpp>
#include <ql/models/marketmodels/models/pseudorootfacade.hpp>
#include <ql/models/marketmodels/models/volatilityinterpolationspecifier.hpp>
#include <ql/models/marketmodels/models/volatilityinterpolationspecifierabcd.hpp>

]]></document_content>
  </document>
  <document index="71">
    <source>marketmodels/models/alphafinder.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_alpha_finder_hpp
#define quantlib_alpha_finder_hpp

#include <ql/models/marketmodels/models/alphaform.hpp>
#include <ql/shared_ptr.hpp>
#include <vector>

namespace QuantLib {

    class AlphaFinder {
      public:
        AlphaFinder(ext::shared_ptr<AlphaForm> parametricform);

        bool solve(Real alpha0,
                   Integer stepindex,
                   const std::vector<Volatility>& rateonevols,
                   const std::vector<Volatility>& ratetwohomogeneousvols,
                   const std::vector<Real>& correlations,
                   Real w0,
                   Real w1,
                   Real targetVariance,
                   Real tolerance,
                   Real alphaMax,
                   Real alphaMin,
                   Integer steps,
                   Real& alpha,
                   Real& a,
                   Real& b,
                   std::vector<Volatility>& ratetwovols);

        bool solveWithMaxHomogeneity(
                        Real alpha0,
                        Integer stepindex,
                        const std::vector<Volatility>& rateonevols,
                        const std::vector<Volatility>& ratetwohomogeneousvols,
                        const std::vector<Real>& correlations,
                        Real w0,
                        Real w1,
                        Real targetVariance,
                        Real tolerance,
                        Real alphaMax,
                        Real alphaMin,
                        Integer steps,
                        Real& alpha,
                        Real& a,
                        Real& b,
                        std::vector<Volatility>& ratetwovols);
      private:
        Real computeLinearPart(Real alpha);
        Real computeQuadraticPart(Real alpha);
        Real valueAtTurningPoint(Real alpha);
        Real minusValueAtTurningPoint(Real alpha);
        bool testIfSolutionExists(Real alpha);
        bool finalPart(Real alphaFound,
                       Integer stepindex,
                       const std::vector<Volatility>& ratetwohomogeneousvols,
                       Real quadraticPart,
                       Real linearPart,
                       Real constantPart,
                       Real& alpha,
                       Real& a,
                       Real& b,
                       std::vector<Volatility>& ratetwovols);
        Real homogeneityfailure(Real alpha);
        ext::shared_ptr<AlphaForm> parametricform_;
        Integer stepindex_;
        std::vector<Volatility> rateonevols_, ratetwohomogeneousvols_;
        std::vector<Volatility> putativevols_;
        std::vector<Real> correlations_;
        Real w0_, w1_;
        Real constantPart_, linearPart_, quadraticPart_;
        Real totalVar_, targetVariance_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="72">
    <source>marketmodels/models/alphaform.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_alpha_form_hpp
#define quantlib_alpha_form_hpp

#include <ql/types.hpp>

namespace QuantLib {

    class AlphaForm {
      public:
        virtual ~AlphaForm() = default;
        virtual Real operator()(Integer i) const=0;
        virtual void setAlpha(Real alpha)=0;
    };

}

#endif
]]></document_content>
  </document>
  <document index="73">
    <source>marketmodels/models/alphaformconcrete.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_alpha_form_concrete_hpp
#define quantlib_alpha_form_concrete_hpp

#include <ql/models/marketmodels/models/alphaform.hpp>
#include <vector>

namespace QuantLib {

    class AlphaFormInverseLinear : public AlphaForm {
      public:
        AlphaFormInverseLinear(std::vector<Time> times, Real alpha = 0.0);
        ~AlphaFormInverseLinear() override = default;
        Real operator()(Integer i) const override;
        void setAlpha(Real alpha_) override;

      private:
        std::vector<Time> times_;
        Real alpha_;
    };

    class AlphaFormLinearHyperbolic : public AlphaForm {
      public:
        AlphaFormLinearHyperbolic(std::vector<Time> times, Real alpha = 0.0);
        ~AlphaFormLinearHyperbolic() override = default;
        Real operator()(Integer i) const override;
        void setAlpha(Real alpha_) override;

      private:
        std::vector<Time> times_;
        Real alpha_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="74">
    <source>marketmodels/models/capletcoterminalalphacalibration.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_ctsmm_caplet_calibration_alfa_form_hpp
#define quantlib_ctsmm_caplet_calibration_alfa_form_hpp

#include <ql/models/marketmodels/models/ctsmmcapletcalibration.hpp>

namespace QuantLib {

    class AlphaForm;

    class CTSMMCapletAlphaFormCalibration : public CTSMMCapletCalibration {
      public:
        CTSMMCapletAlphaFormCalibration(
            const EvolutionDescription& evolution,
            const ext::shared_ptr<PiecewiseConstantCorrelation>& corr,
            const std::vector<ext::shared_ptr<PiecewiseConstantVariance> >& displacedSwapVariances,
            const std::vector<Volatility>& capletVols,
            const ext::shared_ptr<CurveState>& cs,
            Spread displacement,
            const std::vector<Real>& alphaInitial,
            const std::vector<Real>& alphaMax,
            const std::vector<Real>& alphaMin,
            bool maximizeHomogeneity,
            ext::shared_ptr<AlphaForm> parametricForm = ext::shared_ptr<AlphaForm>());
        // inspector
        const std::vector<Real>& alpha() const;
        // actual calibration function
        static Natural capletAlphaFormCalibration(
            const EvolutionDescription& evolution,
            const PiecewiseConstantCorrelation& corr,
            const std::vector<ext::shared_ptr<PiecewiseConstantVariance> >& displacedSwapVariances,
            const std::vector<Volatility>& capletVols,
            const CurveState& cs,
            Spread displacement,

            const std::vector<Real>& alphaInitial,
            const std::vector<Real>& alphaMax,
            const std::vector<Real>& alphaMin,
            bool maximizeHomogeneity,
            const ext::shared_ptr<AlphaForm>& parametricForm,

            Size numberOfFactors,
            Integer steps,
            Real toleranceForAlphaSolving,

            std::vector<Real>& alpha,
            std::vector<Real>& a,
            std::vector<Real>& b,

            std::vector<Matrix>& swapCovariancePseudoRoots);

      private:
        Natural
        calibrationImpl_(Natural numberOfFactors, Natural maxIterations, Real tolerance) override;
        // input
        std::vector<Real> alphaInitial_, alphaMax_, alphaMin_;
        bool maximizeHomogeneity_;
        ext::shared_ptr<AlphaForm> parametricForm_;
        // results
        std::vector<Real> alpha_, a_, b_;
    };

    inline const std::vector<Real>&
    CTSMMCapletAlphaFormCalibration::alpha() const {
        QL_REQUIRE(calibrated_, "not successfully calibrated yet");
        return alpha_;
    }

}

#endif
]]></document_content>
  </document>
  <document index="75">
    <source>marketmodels/models/capletcoterminalmaxhomogeneity.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_ctsmm_caplet_calibration_max_homogeneity_hpp
#define quantlib_ctsmm_caplet_calibration_max_homogeneity_hpp

#include <ql/models/marketmodels/models/ctsmmcapletcalibration.hpp>

namespace QuantLib {

    class CTSMMCapletMaxHomogeneityCalibration : public CTSMMCapletCalibration {
      public:
        CTSMMCapletMaxHomogeneityCalibration(
            const EvolutionDescription& evolution,
            const ext::shared_ptr<PiecewiseConstantCorrelation>& corr,
            const std::vector<ext::shared_ptr<
                        PiecewiseConstantVariance> >&
                                    displacedSwapVariances,
            const std::vector<Volatility>& capletVols,
            const ext::shared_ptr<CurveState>& cs,
            Spread displacement,
            Real caplet0Swaption1Priority = 1.0);

        // actual calibration function
        static Natural capletMaxHomogeneityCalibration(
            const EvolutionDescription& evolution,
            const PiecewiseConstantCorrelation& corr,
            const std::vector<ext::shared_ptr<PiecewiseConstantVariance> >& displacedSwapVariances,
            const std::vector<Volatility>& capletVols,
            const CurveState& cs,
            Spread displacement,
            Real caplet0Swaption1Priority,
            Size numberOfFactors,
            Size maxIterations,
            Real tolerance,
            Real& deformationSize,
            Real& totalSwaptionError,                        // ?
            std::vector<Matrix>& swapCovariancePseudoRoots); // the thing we really want the pseudo
                                                             // root for each time step

      private:
        Natural
        calibrationImpl_(Natural numberOfFactors, Natural maxIterations, Real tolerance) override;
        // input
        Real caplet0Swaption1Priority_;
        // results
        Real totalSwaptionError_; // ??
    };

}

#endif
]]></document_content>
  </document>
  <document index="76">
    <source>marketmodels/models/capletcoterminalperiodic.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*

 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_ctsmm_caplet_calibration_periodic_hpp
#define quantlib_ctsmm_caplet_calibration_periodic_hpp


#include <ql/models/marketmodels/models/piecewiseconstantvariance.hpp>
#include <ql/models/marketmodels/models/volatilityinterpolationspecifier.hpp>
#include <ql/math/matrix.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/piecewiseconstantcorrelation.hpp>
#include <ql/shared_ptr.hpp>
#include <vector>

namespace QuantLib {


    Integer capletSwaptionPeriodicCalibration(
        const EvolutionDescription& evolution,
        const ext::shared_ptr<PiecewiseConstantCorrelation>& corr,
        VolatilityInterpolationSpecifier& displacedSwapVariances,
        const std::vector<Volatility>& capletVols,
        const ext::shared_ptr<CurveState>& cs,
        Spread displacement,
        Real caplet0Swaption1Priority,
        Size numberOfFactors,
        Size period,
        Size max1dIterations,
        Real tolerance1d,
        Size maxUnperiodicIterations,
        Real toleranceUnperiodic,
        Size maxPeriodIterations,
        Real periodTolerance,
        Real& deformationSize,                          // used to return information, not set yet
        Real& totalSwaptionError,                       // ?
        std::vector<Matrix>& swapCovariancePseudoRoots, // the thing we really want the pseudo root
                                                        // for each time step
        std::vector<Real>& finalScales,                 // scalings used for matching
        Size& iterationsDone,                           // number of  period iteratations done
        Real& errorImprovement,                         // improvement in error for last iteration
        Matrix&
            modelSwaptionVolsMatrix // the swaption vols calibrated to at each step of the iteration
    );
}

#endif
]]></document_content>
  </document>
  <document index="77">
    <source>marketmodels/models/capletcoterminalswaptioncalibration.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_ctsmm_caplet_original_calibration_hpp
#define quantlib_ctsmm_caplet_original_calibration_hpp

#include <ql/models/marketmodels/models/ctsmmcapletcalibration.hpp>

namespace QuantLib {

    class CTSMMCapletOriginalCalibration : public CTSMMCapletCalibration {
      public:
        CTSMMCapletOriginalCalibration(
            const EvolutionDescription& evolution,
            const ext::shared_ptr<PiecewiseConstantCorrelation>& corr,
            const std::vector<ext::shared_ptr<
                        PiecewiseConstantVariance> >&
                                    displacedSwapVariances,
            const std::vector<Volatility>& capletVols,
            const ext::shared_ptr<CurveState>& cs,
            Spread displacement,
            const std::vector<Real>& alpha,
            bool lowestRoot,
            bool useFullApprox);
        // actual calibration function
        static Natural calibrationFunction(
                            const EvolutionDescription& evolution,
                            const PiecewiseConstantCorrelation& corr,
                            const std::vector<ext::shared_ptr<
                                PiecewiseConstantVariance> >&
                                    displacedSwapVariances,
                            const std::vector<Volatility>& capletVols,
                            const CurveState& cs,
                            Spread displacement,

                            const std::vector<Real>& alpha,
                            bool lowestRoot,
                            bool useFullApprox,

                            Size numberOfFactors,
                            //Size maxIterations,
                            //Real tolerance,

                            std::vector<Matrix>& swapCovariancePseudoRoots);
      private:
        Natural calibrationImpl_(Natural numberOfFactors, Natural, Real) override;
        // input
        std::vector<Real> alpha_;
        bool lowestRoot_, useFullApprox_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="78">
    <source>marketmodels/models/cotswaptofwdadapter.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_coterminal_to_forward_adapter_hpp
#define quantlib_coterminal_to_forward_adapter_hpp

#include <ql/models/marketmodels/marketmodel.hpp>

namespace QuantLib {

    class EvolutionDescription;

    class CotSwapToFwdAdapter : public MarketModel {
      public:
        CotSwapToFwdAdapter(
                       const ext::shared_ptr<MarketModel>& coterminalModel);
        //! \name MarketModel interface
        //@{
        const std::vector<Rate>& initialRates() const override;
        const std::vector<Spread>& displacements() const override;
        const EvolutionDescription& evolution() const override;
        Size numberOfRates() const override;
        Size numberOfFactors() const override;
        Size numberOfSteps() const override;
        const Matrix& pseudoRoot(Size i) const override;
        //@}
      private:
        ext::shared_ptr<MarketModel> coterminalModel_;
        Size numberOfFactors_, numberOfRates_, numberOfSteps_;
        std::vector<Rate> initialRates_;
        std::vector<Matrix> pseudoRoots_;
    };


    class CotSwapToFwdAdapterFactory : public MarketModelFactory,
                                              public Observer {
      public:
        CotSwapToFwdAdapterFactory(
              const ext::shared_ptr<MarketModelFactory>& coterminalFactory);
        ext::shared_ptr<MarketModel> create(const EvolutionDescription&,
                                            Size numberOfFactors) const override;
        void update() override;

      private:
        ext::shared_ptr<MarketModelFactory> coterminalFactory_;
    };


    // inline definitions

    inline const std::vector<Rate>&
    CotSwapToFwdAdapter::initialRates() const {
        return initialRates_;
    }

    inline const std::vector<Spread>&
    CotSwapToFwdAdapter::displacements() const {
        return coterminalModel_->displacements();
    }

    inline const EvolutionDescription&
    CotSwapToFwdAdapter::evolution() const {
        return coterminalModel_->evolution();
    }

    inline Size CotSwapToFwdAdapter::numberOfRates() const {
        return coterminalModel_->numberOfRates();
    }

    inline Size CotSwapToFwdAdapter::numberOfFactors() const {
        return coterminalModel_->numberOfFactors();
    }

    inline Size CotSwapToFwdAdapter::numberOfSteps() const {
        return coterminalModel_->numberOfSteps();
    }

    inline const Matrix& CotSwapToFwdAdapter::pseudoRoot(Size i) const {
        return pseudoRoots_[i];
    }

}

#endif
]]></document_content>
  </document>
  <document index="79">
    <source>marketmodels/models/ctsmmcapletcalibration.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_ctsmm_caplet_calibration_hpp
#define quantlib_ctsmm_caplet_calibration_hpp

#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/piecewiseconstantcorrelation.hpp>
#include <ql/shared_ptr.hpp>
#include <vector>

namespace QuantLib {

    class PiecewiseConstantVariance;
    class Matrix;

    class CTSMMCapletCalibration {
      public:
        virtual ~CTSMMCapletCalibration() = default;
        CTSMMCapletCalibration(
            EvolutionDescription evolution,
            ext::shared_ptr<PiecewiseConstantCorrelation> corr,
            std::vector<ext::shared_ptr<PiecewiseConstantVariance> > displacedSwapVariances,
            std::vector<Volatility> mktCapletVols, // displaced??
            ext::shared_ptr<CurveState> cs,
            Spread displacement); // ??
        // modifiers
        bool calibrate(Natural numberOfFactors,

                       Natural maxIterations,
                       Real tolerance,

                       Natural innerMaxIterations = 100,
                       Real innerTolerance = 1e-8);
        // inspectors
        Natural failures() const;
        Real deformationSize() const;

        Real capletRmsError() const;
        Real capletMaxError() const;
        Real swaptionRmsError() const;
        Real swaptionMaxError() const;

        const std::vector<Matrix>& swapPseudoRoots() const;
        const Matrix& swapPseudoRoot(Size i) const;

        const std::vector<Volatility>& mktCapletVols() const;
        const std::vector<Volatility>& mdlCapletVols() const;
        const std::vector<Volatility>& mktSwaptionVols() const;
        const std::vector<Volatility>& mdlSwaptionVols() const;
        const std::vector<Volatility>& timeDependentCalibratedSwaptionVols(Size i) const;
        const std::vector<Volatility>& timeDependentUnCalibratedSwaptionVols(Size i) const;


        static void performChecks(
            const EvolutionDescription& evolution,
            const PiecewiseConstantCorrelation& corr,
            const std::vector<ext::shared_ptr<
                        PiecewiseConstantVariance> >&
                                    displacedSwapVariances,
            const std::vector<Volatility>& mktCapletVols,
            const CurveState& cs);

        const ext::shared_ptr<CurveState>& curveState() const;
        std::vector<Spread> displacements() const;
      protected:
        virtual Natural calibrationImpl_(Natural numberOfFactors,

                                         Natural innerMaxIterations,
                                         Real innerTolerance) = 0;
        // input
        EvolutionDescription evolution_;
        ext::shared_ptr<PiecewiseConstantCorrelation> corr_;
        std::vector<ext::shared_ptr<PiecewiseConstantVariance> >
                                                displacedSwapVariances_;
        
        std::vector<Volatility> mktCapletVols_, mdlCapletVols_;
        std::vector<Volatility> mktSwaptionVols_, mdlSwaptionVols_;
        std::vector<std::vector<Volatility> > timeDependentCalibratedSwaptionVols_;
        
        ext::shared_ptr<CurveState> cs_;
        Spread displacement_;
        Size numberOfRates_;
        // working variables
        std::vector<Volatility> usedCapletVols_;
        // results
        bool calibrated_;
        Natural failures_;
        Real deformationSize_;
        Real capletRmsError_, capletMaxError_;
        Real swaptionRmsError_, swaptionMaxError_;
        std::vector<Matrix> swapCovariancePseudoRoots_;
    };

    // inline

    inline const std::vector<Volatility>&
    CTSMMCapletCalibration::mktCapletVols() const {
        return mktCapletVols_;
    }

    inline const std::vector<Volatility>&
    CTSMMCapletCalibration::mdlCapletVols() const {
        QL_REQUIRE(calibrated_, "not successfully calibrated yet");
        return mdlCapletVols_;
    }

    inline const std::vector<Volatility>&
    CTSMMCapletCalibration::mktSwaptionVols() const {
        return mktSwaptionVols_;
    }

    inline const std::vector<Volatility>&
    CTSMMCapletCalibration::mdlSwaptionVols() const {
        QL_REQUIRE(calibrated_, "not successfully calibrated yet");
        return mdlSwaptionVols_;
    }

    inline Natural CTSMMCapletCalibration::failures() const {
        QL_REQUIRE(calibrated_, "not successfully calibrated yet");
        return failures_;
    }

    inline Real CTSMMCapletCalibration::deformationSize() const {
        QL_REQUIRE(calibrated_, "not successfully calibrated yet");
        return deformationSize_;
    }

    inline Real CTSMMCapletCalibration::capletRmsError() const {
        QL_REQUIRE(calibrated_, "not successfully calibrated yet");
        return capletRmsError_;
    }

    inline Real CTSMMCapletCalibration::capletMaxError() const {
        QL_REQUIRE(calibrated_, "not successfully calibrated yet");
        return capletMaxError_;
    }

    inline Real CTSMMCapletCalibration::swaptionRmsError() const {
        QL_REQUIRE(calibrated_, "not successfully calibrated yet");
        return swaptionRmsError_;
    }

    inline Real CTSMMCapletCalibration::swaptionMaxError() const {
        QL_REQUIRE(calibrated_, "not successfully calibrated yet");
        return swaptionMaxError_;
    }

    inline const std::vector<Matrix>&
    CTSMMCapletCalibration::swapPseudoRoots() const {
        QL_REQUIRE(calibrated_, "not successfully calibrated yet");
        return swapCovariancePseudoRoots_;
    }

    inline const Matrix&
    CTSMMCapletCalibration::swapPseudoRoot(Size i) const {
        QL_REQUIRE(calibrated_, "not successfully calibrated yet");
        QL_REQUIRE(i<swapCovariancePseudoRoots_.size(),
                   i << "is an invalid index, must be less than "
                   << swapCovariancePseudoRoots_.size());
        return swapCovariancePseudoRoots_[i];
    }

    inline const ext::shared_ptr<CurveState>&
    CTSMMCapletCalibration::curveState() const {
        return cs_;
    }

    inline std::vector<Spread>
    CTSMMCapletCalibration::displacements() const {
        return std::vector<Volatility>(numberOfRates_, displacement_);
    }

}

#endif
]]></document_content>
  </document>
  <document index="80">
    <source>marketmodels/models/flatvol.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006 Chiara Fornarola
 Copyright (C) 2006, 2007 StatPro Italia srl
 Copyright (C) 2006 Katiuscia Manzoni

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_exp_corr_flat_vol_hpp
#define quantlib_exp_corr_flat_vol_hpp

#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/math/matrix.hpp>
#include <ql/math/interpolation.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/handle.hpp>
#include <vector>

namespace QuantLib {

    class PiecewiseConstantCorrelation;

    class FlatVol : public MarketModel {
      public:
        FlatVol(
            const std::vector<Volatility>& volatilities,
            const ext::shared_ptr<PiecewiseConstantCorrelation>& corr,
            const EvolutionDescription& evolution,
            Size numberOfFactors,
            const std::vector<Rate>& initialRates,
            const std::vector<Spread>& displacements);
        //! \name MarketModel interface
        //@{
        const std::vector<Rate>& initialRates() const override;
        const std::vector<Spread>& displacements() const override;
        const EvolutionDescription& evolution() const override;
        Size numberOfRates() const override;
        Size numberOfFactors() const override;
        Size numberOfSteps() const override;
        const Matrix& pseudoRoot(Size i) const override;
        //@}
      private:
        Size numberOfFactors_, numberOfRates_, numberOfSteps_;
        std::vector<Rate> initialRates_;
        std::vector<Spread> displacements_;
        EvolutionDescription evolution_;
        std::vector<Matrix> pseudoRoots_;
    };

    class FlatVolFactory : public MarketModelFactory,
                                  public Observer {
      public:
        FlatVolFactory(Real longTermCorrelation,
                       Real beta,
                       // this is just to make it work---it
                       // should be replaced with something
                       // else (such as some kind of volatility
                       // structure)
                       std::vector<Time> times,
                       std::vector<Volatility> vols,
                       // this is OK
                       Handle<YieldTermStructure> yieldCurve,
                       // this might have a structure
                       Spread displacement);
        ext::shared_ptr<MarketModel> create(const EvolutionDescription&,
                                            Size numberOfFactors) const override;
        void update() override;

      private:
        Real longTermCorrelation_, beta_;
        // <to be changed>
        std::vector<Time> times_;
        std::vector<Volatility> vols_;
        Interpolation volatility_;
        // </to be changed>
        Handle<YieldTermStructure> yieldCurve_;
        Spread displacement_;
    };


    // inline definitions

    inline const std::vector<Rate>& FlatVol::initialRates() const {
        return initialRates_;
    }

    inline const std::vector<Spread>& FlatVol::displacements() const {
        return displacements_;
    }

    inline const EvolutionDescription& FlatVol::evolution() const {
        return evolution_;
    }

    inline Size FlatVol::numberOfRates() const {
        return initialRates_.size();
    }

    inline Size FlatVol::numberOfFactors() const {
        return numberOfFactors_;
    }

    inline Size FlatVol::numberOfSteps() const {
        return numberOfSteps_;
    }

    inline const Matrix& FlatVol::pseudoRoot(Size i) const {
        QL_REQUIRE(i<numberOfSteps_,
                   "the index " << i << " is invalid: it must be less than "
                   "number of steps (" << numberOfSteps_ << ")");
        return pseudoRoots_[i];
    }
}

#endif
]]></document_content>
  </document>
  <document index="81">
    <source>marketmodels/models/fwdperiodadapter.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_forward_period_adapter_hpp
#define quantlib_forward_period_adapter_hpp

#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>

namespace QuantLib {

 
    class FwdPeriodAdapter : public MarketModel {
      public:
        FwdPeriodAdapter(const ext::shared_ptr<MarketModel>& largeModel,
                         Size period,
                         Size offset,
                         std::vector<Spread> newDisplacements_);
        //! \name MarketModel interface
        //@{
        const std::vector<Rate>& initialRates() const override;
        const std::vector<Spread>& displacements() const override;
        const EvolutionDescription& evolution() const override;
        Size numberOfRates() const override;
        Size numberOfFactors() const override;
        Size numberOfSteps() const override;
        const Matrix& pseudoRoot(Size i) const override;
        //@}
      private:
        EvolutionDescription evolution_;
        Size numberOfFactors_, numberOfRates_, numberOfSteps_;
        std::vector<Rate> initialRates_;
        std::vector<Matrix> pseudoRoots_;
        std::vector<Spread> displacements_;
    };


   

    // inline definitions

    inline const std::vector<Rate>&
    FwdPeriodAdapter::initialRates() const {
        return initialRates_;
    }

    inline const std::vector<Spread>&
    FwdPeriodAdapter::displacements() const {
        return displacements_;
    }

    inline const EvolutionDescription&
    FwdPeriodAdapter::evolution() const {
        return evolution_;
    }

    inline Size FwdPeriodAdapter::numberOfRates() const {
        return numberOfRates_;
    }

    inline Size FwdPeriodAdapter::numberOfFactors() const {
        return numberOfFactors_;
    }

    inline Size FwdPeriodAdapter::numberOfSteps() const {
        return numberOfSteps_;
    }

    inline const Matrix& FwdPeriodAdapter::pseudoRoot(Size i) const {
        return pseudoRoots_[i];
    }

}

#endif
]]></document_content>
  </document>
  <document index="82">
    <source>marketmodels/models/fwdtocotswapadapter.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_forward_to_coterminal_adapter_hpp
#define quantlib_forward_to_coterminal_adapter_hpp

#include <ql/models/marketmodels/marketmodel.hpp>

namespace QuantLib {

    class EvolutionDescription;

    class FwdToCotSwapAdapter : public MarketModel {
      public:
        FwdToCotSwapAdapter(
                          const ext::shared_ptr<MarketModel>& forwardModel);
        //! \name MarketModel interface
        //@{
        const std::vector<Rate>& initialRates() const override;
        const std::vector<Spread>& displacements() const override;
        const EvolutionDescription& evolution() const override;
        Size numberOfRates() const override;
        Size numberOfFactors() const override;
        Size numberOfSteps() const override;
        const Matrix& pseudoRoot(Size i) const override;
        //@}
      private:
        ext::shared_ptr<MarketModel> fwdModel_;
        Size numberOfFactors_, numberOfRates_, numberOfSteps_;
        std::vector<Rate> initialRates_;
        std::vector<Matrix> pseudoRoots_;
    };


    class FwdToCotSwapAdapterFactory : public MarketModelFactory,
                                              public Observer {
      public:
        FwdToCotSwapAdapterFactory(
              const ext::shared_ptr<MarketModelFactory>& forwardFactory);
        ext::shared_ptr<MarketModel> create(const EvolutionDescription&,
                                            Size numberOfFactors) const override;
        void update() override;

      private:
        ext::shared_ptr<MarketModelFactory> forwardFactory_;
    };


    // inline definitions

    inline const std::vector<Rate>&
    FwdToCotSwapAdapter::initialRates() const {
        return initialRates_;
    }

    inline const std::vector<Spread>&
    FwdToCotSwapAdapter::displacements() const {
        return fwdModel_->displacements();
    }

    inline const EvolutionDescription&
    FwdToCotSwapAdapter::evolution() const {
        return fwdModel_->evolution();
    }

    inline Size FwdToCotSwapAdapter::numberOfRates() const {
        return fwdModel_->numberOfRates();
    }

    inline Size FwdToCotSwapAdapter::numberOfFactors() const {
        return fwdModel_->numberOfFactors();
    }

    inline Size FwdToCotSwapAdapter::numberOfSteps() const {
        return fwdModel_->numberOfSteps();
    }

    inline const Matrix& FwdToCotSwapAdapter::pseudoRoot(Size i) const {
        return pseudoRoots_[i];
    }

}

#endif
]]></document_content>
  </document>
  <document index="83">
    <source>marketmodels/models/piecewiseconstantabcdvariance.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_piecewise_const_abcd_variance_hpp
#define quantlib_piecewise_const_abcd_variance_hpp

#include <ql/models/marketmodels/models/piecewiseconstantvariance.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>

namespace QuantLib {

    class PiecewiseConstantAbcdVariance : public PiecewiseConstantVariance {
      public:
        PiecewiseConstantAbcdVariance(Real a, Real b, Real c, Real d,
                                      Size resetIndex,
                                      const std::vector<Time>& rateTimes);
        const std::vector<Real>& variances() const override;
        const std::vector<Real>& volatilities() const override;
        const std::vector<Time>& rateTimes() const override;
        void getABCD(Real& a, Real& b, Real& c, Real& d) const;
      private:
        std::vector<Real> variances_;
        std::vector<Real> volatilities_;
        std::vector<Time> rateTimes_;
        Real a_;
        Real b_;
        Real c_;
        Real d_;

    };

}

#endif
]]></document_content>
  </document>
  <document index="84">
    <source>marketmodels/models/piecewiseconstantvariance.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_piecewise_const_variance_hpp
#define quantlib_piecewise_const_variance_hpp

#include <ql/types.hpp>
#include <vector>

namespace QuantLib {

    class EvolutionDescription;
    class Matrix;

    class PiecewiseConstantVariance {
      public:
        virtual ~PiecewiseConstantVariance() = default;
        virtual const std::vector<Real>& variances() const = 0;
        virtual const std::vector<Volatility>& volatilities() const = 0;
        virtual const std::vector<Time>& rateTimes() const = 0;
        Real variance(Size i) const;
        Volatility volatility(Size i) const;
        //const std::vector<Real>& totalVariances() const;
        //const std::vector<Volatility>& totalVolatilities() const;
        Real totalVariance(Size i) const;
        Volatility totalVolatility(Size i) const;
    };

}

#endif
]]></document_content>
  </document>
  <document index="85">
    <source>marketmodels/models/pseudorootfacade.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_pseudoroot_facade_hpp
#define quantlib_pseudoroot_facade_hpp

#include <ql/models/marketmodels/models/ctsmmcapletcalibration.hpp>
#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/math/matrix.hpp>
#include <vector>

namespace QuantLib
{
    class PseudoRootFacade : public MarketModel {
      public:
        PseudoRootFacade(const ext::shared_ptr<CTSMMCapletCalibration>& calibrator);
        PseudoRootFacade(const std::vector<Matrix>& covariancePseudoRoots,
                         const std::vector<Rate>& rateTimes,
                         std::vector<Rate> initialRates,
                         const std::vector<Spread>& displacements);
        //! \name MarketModel interface
        //@{
        const std::vector<Rate>& initialRates() const override;
        const std::vector<Spread>& displacements() const override;
        const EvolutionDescription& evolution() const override;
        Size numberOfRates() const override;
        Size numberOfFactors() const override;
        Size numberOfSteps() const override;
        const Matrix& pseudoRoot(Size i) const override;
        //@}
      private:
        Size numberOfFactors_, numberOfRates_, numberOfSteps_;
        std::vector<Rate> initialRates_;
        std::vector<Spread> displacements_;
        EvolutionDescription evolution_;
        std::vector<Matrix> covariancePseudoRoots_;
    };

    // inline

    inline const std::vector<Rate>& PseudoRootFacade::initialRates() const {
        return initialRates_;
    }

    inline const std::vector<Spread>& PseudoRootFacade::displacements() const {
        return displacements_;
    }

    inline const EvolutionDescription& PseudoRootFacade::evolution() const {
        return evolution_;
    }

    inline Size PseudoRootFacade::numberOfRates() const {
        return numberOfRates_;
    }

    inline Size PseudoRootFacade::numberOfFactors() const {
        return numberOfFactors_;
    }

    inline Size PseudoRootFacade::numberOfSteps() const {
        return numberOfSteps_;
    }

    inline const Matrix& PseudoRootFacade::pseudoRoot(Size i) const {
        QL_REQUIRE(i<numberOfSteps_,
                   "the index " << i << " is invalid: it must be less than "
                   "number of steps (" << numberOfSteps_ << ")");
        return covariancePseudoRoots_[i];
    }
}

#endif
]]></document_content>
  </document>
  <document index="86">
    <source>marketmodels/models/volatilityinterpolationspecifier.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*

Copyright (C) 2007 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/
/*! abstract base class
implementation specifies how to decide volatility structure for additional
synthetic rates which are interleaved

*/

#ifndef volatility_interpolation_specifier_hpp
#define  volatility_interpolation_specifier_hpp



#include <ql/models/marketmodels/models/piecewiseconstantvariance.hpp>
#include <ql/types.hpp>
#include <ql/shared_ptr.hpp>
#include <vector>


namespace QuantLib
{
    class VolatilityInterpolationSpecifier
    {
      public:
        VolatilityInterpolationSpecifier() = default;
        virtual ~VolatilityInterpolationSpecifier() = default;
        virtual void setScalingFactors(const std::vector<Real>& scales)=0;
        virtual void setLastCapletVol(Real vol)=0;


        virtual const std::vector<ext::shared_ptr<PiecewiseConstantVariance> >& interpolatedVariances() const=0;
        virtual const std::vector<ext::shared_ptr<PiecewiseConstantVariance> >& originalVariances() const=0;

        virtual Size getPeriod() const=0;
        virtual Size getOffset() const=0;
        virtual Size getNoBigRates() const=0;
        virtual Size getNoSmallRates() const=0;
    };
}

#endif
]]></document_content>
  </document>
  <document index="87">
    <source>marketmodels/models/volatilityinterpolationspecifierabcd.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef volatility_interpolation_specifier_abcd_hpp
#define volatility_interpolation_specifier_abcd_hpp

#include <ql/models/marketmodels/models/volatilityinterpolationspecifier.hpp>
#include <ql/models/marketmodels/models/piecewiseconstantabcdvariance.hpp>
#include <ql/types.hpp>
#include <ql/shared_ptr.hpp>
#include <vector>


namespace QuantLib
{
    class VolatilityInterpolationSpecifierabcd : public VolatilityInterpolationSpecifier
    {
    public:
        VolatilityInterpolationSpecifierabcd(Size period,
                                                                   Size offset,
                                                                   const std::vector< PiecewiseConstantAbcdVariance>& originalVariances, // these should be associated with the long rates
                                                                   const std::vector<Time>& timesForSmallRates, // these should be associated with the shorter rates
                                                                   Real lastCapletVol=0.0
                                                                   );

        ~VolatilityInterpolationSpecifierabcd() override = default;
        void setScalingFactors(const std::vector<Real>& scales) override;
        void setLastCapletVol(Real vol) override;


        const std::vector<ext::shared_ptr<PiecewiseConstantVariance> >&
        interpolatedVariances() const override;
        const std::vector<ext::shared_ptr<PiecewiseConstantVariance> >&
        originalVariances() const override;

        Size getPeriod() const override;
        Size getOffset() const override;
        Size getNoBigRates() const override;
        Size getNoSmallRates() const override;

      private:
        Size period_;
        Size offset_;

         std::vector<ext::shared_ptr<PiecewiseConstantVariance> > interpolatedVariances_;
         std::vector<ext::shared_ptr<PiecewiseConstantVariance> > originalVariances_;
         std::vector< PiecewiseConstantAbcdVariance> originalABCDVariances_;
         std::vector< PiecewiseConstantAbcdVariance> originalABCDVariancesScaled_;
         Real lastCapletVol_;
         std::vector<Time> timesForSmallRates_;
         std::vector<Real> scalingFactors_;

         Size noBigRates_;
         Size noSmallRates_;

         void recompute();

    };
}

#endif
]]></document_content>
  </document>
  <document index="88">
    <source>marketmodels/multiproduct.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_market_model_multi_product_hpp
#define quantlib_market_model_multi_product_hpp

#include <ql/types.hpp>
#include <vector>
#include <memory>

namespace QuantLib {

    class EvolutionDescription;
    class CurveState;

    //! market-model product
    /*! This is the abstract base class that encapsulates the notion of a
        product: it contains the information that would be in the termsheet
        of the product.

        It's useful to have it be able to do several products simultaneously.
        The products would have to have the same underlying rate times of
        course. The class is therefore really encapsulating the notion of a
        multi-product.

        For each time evolved to, it generates the cash flows associated to
        that time for the state of the yield curve. If one was doing a
        callable product then this would encompass the product and its
        exercise strategy.

    */

    class MarketModelMultiProduct {
     public:
        struct CashFlow {
            Size timeIndex;
            Real amount;
        };
        virtual ~MarketModelMultiProduct() = default;

        virtual std::vector<Size> suggestedNumeraires() const = 0;
        virtual const EvolutionDescription& evolution() const = 0;
        virtual std::vector<Time> possibleCashFlowTimes() const = 0;
        virtual Size numberOfProducts() const = 0;
        virtual Size maxNumberOfCashFlowsPerProductPerStep() const = 0;
        //! during simulation put product at start of path
        virtual void reset() = 0;
        //! return value indicates whether path is finished, TRUE means done
        virtual bool nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<CashFlow> >& cashFlowsGenerated) = 0;
        //! returns a newly-allocated copy of itself
        virtual std::unique_ptr<MarketModelMultiProduct> clone() const = 0;
    };

}


#endif
]]></document_content>
  </document>
  <document index="89">
    <source>marketmodels/pathwiseaccountingengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*

 Copyright (C) 2008 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_pathwise_accounting_engine_hpp
#define quantlib_pathwise_accounting_engine_hpp

#include <ql/models/marketmodels/pathwisemultiproduct.hpp>
#include <ql/models/marketmodels/pathwisediscounter.hpp>
#include <ql/math/statistics/sequencestatistics.hpp>
#include <ql/models/marketmodels/pathwisegreeks/ratepseudorootjacobian.hpp>

#include <ql/utilities/clone.hpp>
#include <ql/types.hpp>
#include <vector>

namespace QuantLib {

    class LogNormalFwdRateEuler;
    class MarketModel;


    //! Engine collecting cash flows along a market-model simulation for doing pathwise computation of Deltas
    // using Giles--Glasserman smoking adjoints method
    // note only works with displaced LMM, and requires knowledge of pseudo-roots and displacements 
    // This is tested in MarketModelTest::testPathwiseGreeks
    class PathwiseAccountingEngine 
    {
      public:
        PathwiseAccountingEngine(
            ext::shared_ptr<LogNormalFwdRateEuler> evolver, // method relies heavily on LMM Euler
            const Clone<MarketModelPathwiseMultiProduct>& product,
            ext::shared_ptr<MarketModel>
                pseudoRootStructure, // we need pseudo-roots and displacements
            Real initialNumeraireValue);

        void multiplePathValues(SequenceStatisticsInc& stats,
                                Size numberOfPaths);
      private:
          Real singlePathValues(std::vector<Real>& values);

        ext::shared_ptr<LogNormalFwdRateEuler> evolver_;
        Clone<MarketModelPathwiseMultiProduct> product_;
        ext::shared_ptr<MarketModel> pseudoRootStructure_;

        Real initialNumeraireValue_;
        Size numberProducts_;
        Size numberRates_;
        Size numberCashFlowTimes_;
        Size numberSteps_;

        std::vector<Real> currentForwards_, lastForwards_;

        bool doDeflation_;


        // workspace
        std::vector<Real> numerairesHeld_;
        std::vector<Size> numberCashFlowsThisStep_;
        std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >
                                                         cashFlowsGenerated_;
        std::vector<MarketModelPathwiseDiscounter> discounters_;

        std::vector<Matrix> V_;  // one V for each product, with components for each time step and rate

   //     std::vector<std::vector<std::vector<Real> > > V_; // one V for each product, with components for each time step and rate

        Matrix LIBORRatios_; // dimensions are step and rate number
        Matrix Discounts_; // dimensions are step and rate number, goes from 0 to n. P(t_0, t_j)

        Matrix StepsDiscountsSquared_; // dimensions are step and rate number

        Matrix LIBORRates_; // dimensions are step and rate number
        Matrix partials_; // dimensions are factor and rate

        std::vector<Real> deflatorAndDerivatives_;
        
        std::vector<std::vector<Size> > numberCashFlowsThisIndex_;
        std::vector<Matrix> totalCashFlowsThisIndex_; // need product cross times cross which sensitivity

        std::vector<std::vector<Size> > cashFlowIndicesThisStep_;

    };


   //! Engine collecting cash flows along a market-model simulation for doing pathwise computation of Deltas and vegas
    // using Giles--Glasserman smoking adjoints method
    // note only works with displaced LMM, 
    // 
    // The method is intimately connected with log-normal Euler evolution 
    // 
    // We must work with discretely compounding MM account
    // To compute a vega means changing the pseudo-square root at each time step
    // So for each vega, we have a vector of matrices. So we need a vector of vectors of matrices to compute all the vegas.
    // We do the outermost vector by time step and inner one by which vega.
    // This is tested in MarketModelTest::testPathwiseVegas

    class PathwiseVegasAccountingEngine 
    {
      public:
        PathwiseVegasAccountingEngine(
            ext::shared_ptr<LogNormalFwdRateEuler> evolver, // method relies heavily on LMM Euler
            const Clone<MarketModelPathwiseMultiProduct>& product,
            ext::shared_ptr<MarketModel>
                pseudoRootStructure, // we need pseudo-roots and displacements
            const std::vector<std::vector<Matrix> >& VegaBumps,
            Real initialNumeraireValue);

        void multiplePathValues(std::vector<Real>& means,
                                std::vector<Real>& errors,
                                Size numberOfPaths);
      private:
          Real singlePathValues(std::vector<Real>& values);

        ext::shared_ptr<LogNormalFwdRateEuler> evolver_;
        Clone<MarketModelPathwiseMultiProduct> product_;
        ext::shared_ptr<MarketModel> pseudoRootStructure_;
        std::vector<Size> numeraires_;

        Real initialNumeraireValue_;
        Size numberProducts_;
        Size numberRates_;
        Size numberCashFlowTimes_;
        Size numberSteps_;
        Size numberBumps_;

        std::vector<RatePseudoRootJacobian> jacobianComputers_;

        
        bool doDeflation_;


        // workspace
        std::vector<Real> currentForwards_, lastForwards_;
        std::vector<Real> numerairesHeld_;
        std::vector<Size> numberCashFlowsThisStep_;
        std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >
                                                         cashFlowsGenerated_;
        std::vector<MarketModelPathwiseDiscounter> discounters_;

        std::vector<Matrix> V_;  // one V for each product, with components for each time step and rate

        Matrix LIBORRatios_; // dimensions are step and rate number
        Matrix Discounts_; // dimensions are step and rate number, goes from 0 to n. P(t_0, t_j)

        Matrix StepsDiscountsSquared_; // dimensions are step and rate number
        std::vector<Real> stepsDiscounts_;

        Matrix LIBORRates_; // dimensions are step and rate number
        Matrix partials_; // dimensions are factor and rate

        Matrix vegasThisPath_; // dimensions are product and which vega
        std::vector<Matrix> jacobiansThisPaths_; // dimensions are step, rate and factor

        std::vector<Real> deflatorAndDerivatives_;
        std::vector<Real> fullDerivatives_;
        
        std::vector<std::vector<Size> > numberCashFlowsThisIndex_;
        std::vector<Matrix> totalCashFlowsThisIndex_; // need product cross times cross which sensitivity

        std::vector<std::vector<Size> > cashFlowIndicesThisStep_;

    };

   //! Engine collecting cash flows along a market-model simulation for doing pathwise computation of Deltas and vegas
    // using Giles--Glasserman smoking adjoints method
    // note only works with displaced LMM, 
    // 
    // The method is intimately connected with log-normal Euler evolution 
    // 
    // We must work with discretely compounding MM account
    // To compute a vega means changing the pseudo-square root at each time step
    // So for each vega, we have a vector of matrices. So we need a vector of vectors of matrices to compute all the vegas.
    // We do the outermost vector by time step and inner one by which vega.
    // This implementation is different in that all the linear combinations by the bumps are done as late as possible,
    // whereas PathwiseVegasAccountingEngine does them as early as possible. 
    // This is tested in MarketModelTest::testPathwiseVegas

    class PathwiseVegasOuterAccountingEngine 
    {
      public:
        PathwiseVegasOuterAccountingEngine(
            ext::shared_ptr<LogNormalFwdRateEuler> evolver, // method relies heavily on LMM Euler
            const Clone<MarketModelPathwiseMultiProduct>& product,
            ext::shared_ptr<MarketModel>
                pseudoRootStructure, // we need pseudo-roots and displacements
            const std::vector<std::vector<Matrix> >& VegaBumps,
            Real initialNumeraireValue);

        //! Use to get vegas with respect to VegaBumps
        void multiplePathValues(std::vector<Real>& means,
                                std::vector<Real>& errors,
                                Size numberOfPaths);

        //! Use to get vegas with respect to pseudo-root-elements
        void multiplePathValuesElementary(std::vector<Real>& means,
                                std::vector<Real>& errors,
                                Size numberOfPaths);

      private:
          Real singlePathValues(std::vector<Real>& values);

        ext::shared_ptr<LogNormalFwdRateEuler> evolver_;
        Clone<MarketModelPathwiseMultiProduct> product_;
        ext::shared_ptr<MarketModel> pseudoRootStructure_;
        std::vector<std::vector<Matrix> > vegaBumps_; 
        std::vector<Size> numeraires_;

        Real initialNumeraireValue_;
        Size numberProducts_;
        Size numberRates_;
        Size numberCashFlowTimes_;
        Size numberSteps_;
        Size factors_;
        Size numberBumps_;
        Size numberElementaryVegas_;

        std::vector<RatePseudoRootJacobianAllElements> jacobianComputers_;

        
        bool doDeflation_;


        // workspace
        std::vector<Real> currentForwards_, lastForwards_;
        std::vector<Real> numerairesHeld_;
        std::vector<Size> numberCashFlowsThisStep_;
        std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >
                                                         cashFlowsGenerated_;
        std::vector<MarketModelPathwiseDiscounter> discounters_;

        std::vector<Matrix> V_;  // one V for each product, with components for each time step and rate

        Matrix LIBORRatios_; // dimensions are step and rate number
        Matrix Discounts_; // dimensions are step and rate number, goes from 0 to n. P(t_0, t_j)

        Matrix StepsDiscountsSquared_; // dimensions are step and rate number
        std::vector<Real> stepsDiscounts_;

        Matrix LIBORRates_; // dimensions are step and rate number
        Matrix partials_; // dimensions are factor and rate

        std::vector<std::vector<Matrix>   > elementary_vegas_ThisPath_;  // dimensions are product, step,  rate and factor
        std::vector<std::vector<Matrix> > jacobiansThisPaths_;                      // dimensions are step, rate, rate and factor

        std::vector<Real> deflatorAndDerivatives_;
        std::vector<Real> fullDerivatives_;
        
        std::vector<std::vector<Size> > numberCashFlowsThisIndex_;
        std::vector<Matrix> totalCashFlowsThisIndex_; // need product cross times cross which sensitivity

        std::vector<std::vector<Size> > cashFlowIndicesThisStep_;
/*
        // experimental

        std::vector<std::vector<Real> > gaussians_;
        int distinguishedFactor_;
        int distinguishedRate_;
        int  distinguishedStep_;

*/
    };

}

#endif
]]></document_content>
  </document>
  <document index="90">
    <source>marketmodels/pathwisediscounter.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_pathwise_market_model_discounter_hpp
#define quantlib_pathwise_market_model_discounter_hpp

#include <ql/types.hpp>
#include <ql/math/matrix.hpp>
#include <vector>

namespace QuantLib {

    class CurveState;
    /*!
    this class returns the number of units of the discretely compounding money
    market account that 1 unit of cash at the payment can buy using the LIBOR
    rates from current step.

    It also returns the derivative of this number with respect to each of the
    rates.

    Discounting is purely based on the simulation LIBOR rates,
    to get a discounting back to zero you need to multiply by
    the discount factor of t_0.
    */
    class MarketModelPathwiseDiscounter {
      public:
        MarketModelPathwiseDiscounter(Time paymentTime,
                                      const std::vector<Time>& rateTimes);
        void getFactors(const Matrix& LIBORRates, // LIBOR rate values for all steps
                        const Matrix& Discounts, // P(t_0, t_j) for j=0,...n for each step
                        Size currentStep,
                        std::vector<Real>& factors) const;
      private:
        Size before_;
        Size numberRates_;
        Real beforeWeight_;
        Real postWeight_;
        std::vector<Real> taus_;

    };

}

#endif
]]></document_content>
  </document>
  <document index="91">
    <source>marketmodels/pathwisegreeks/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/marketmodels/pathwisegreeks/bumpinstrumentjacobian.hpp>
#include <ql/models/marketmodels/pathwisegreeks/ratepseudorootjacobian.hpp>
#include <ql/models/marketmodels/pathwisegreeks/swaptionpseudojacobian.hpp>
#include <ql/models/marketmodels/pathwisegreeks/vegabumpcluster.hpp>

]]></document_content>
  </document>
  <document index="92">
    <source>marketmodels/pathwisegreeks/bumpinstrumentjacobian.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*

 Copyright (C) 2008 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_bump_instrument_jacobian_hpp
#define quantlib_bump_instrument_jacobian_hpp


#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/pathwisegreeks/vegabumpcluster.hpp>
#include <valarray>

namespace QuantLib
{   
    class VolatilityBumpInstrumentJacobian
    {
    public:

        struct Swaption
        {
            Size startIndex_;
            Size endIndex_;
        };

        struct Cap
        {
            Size startIndex_;
            Size endIndex_;
            Real strike_;

        };

    
        VolatilityBumpInstrumentJacobian(const VegaBumpCollection& bumps,
            const std::vector<Swaption>& swaptions,
            const std::vector<Cap>& caps);


        const VegaBumpCollection& getInputBumps() const
        {
            return bumps_;
        }

        std::vector<Real> derivativesVolatility(Size j) const;

        std::vector<Real> onePercentBump(
            Size j) const; // vector of smallest size that changes instrument implied vol by 1
                           // percent i.e. 0.01 v / <v,v> with v result of derivativesVolatility

        const Matrix& getAllOnePercentBumps() const;

    private:
         VegaBumpCollection bumps_;
         std::vector<Swaption> swaptions_;
         std::vector<Cap> caps_;
         mutable std::valarray<bool> computed_;
         mutable bool allComputed_;
         mutable std::vector<std::vector<Real> > derivatives_;
         
         mutable std::vector<std::vector<Real> > onePercentBumps_;
         mutable Matrix bumpMatrix_;
    };

    /*!
    Pass in a market model, a list of instruments, and possible bumps.

    Get out pseudo-root bumps that shift each implied vol by one percent, and leave the other instruments fixed. 

    If the contribution of an instrument is too correlated with other instruments used, discard it. 

    */

    class OrthogonalizedBumpFinder
    {
        public:
            OrthogonalizedBumpFinder(const VegaBumpCollection& bumps,
                                     const std::vector<VolatilityBumpInstrumentJacobian::Swaption>& swaptions,
                                     const std::vector<VolatilityBumpInstrumentJacobian::Cap>& caps,
                                     Real multiplierCutOff, // if vector length grows by more than this discard
                                     Real tolerance);      // if vector projection before scaling less than this discard

            void GetVegaBumps(std::vector<std::vector<Matrix> >& theBumps) const; // this is precisely the vector to pass into PathwiseVegasAccountingEngine
             

        private:

            VolatilityBumpInstrumentJacobian derivativesProducer_;
            Real multiplierCutOff_;
            Real tolerance_;


    };


  

}

#endif
]]></document_content>
  </document>
  <document index="93">
    <source>marketmodels/pathwisegreeks/ratepseudorootjacobian.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*

 Copyright (C) 2008 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_rate_pseudo_root_hpp
#define quantlib_rate_pseudo_root_hpp

// to be removed using forward declaration


#include <ql/models/marketmodels/driftcomputation/lmmdriftcalculator.hpp>

/*! Classes for computing derivative of the map taking rates one step 
to the next with respect to a change in the pseudo-root. We do it both
numerically and analytically to provide an easy test of the analytic method.
This is useful for pathwise vegas.

Evolution is log Euler. 

One is tested against the other in MarketModelTest::testPathwiseVegas
*/

namespace QuantLib
{

    class RatePseudoRootJacobianNumerical
    {
    public:
        RatePseudoRootJacobianNumerical(const Matrix& pseudoRoot,
                                        Size aliveIndex, 
                                        Size numeraire,
                                        const std::vector<Time>& taus,
                                        const std::vector<Matrix>& pseudoBumps,
                                        const std::vector<Spread>& displacements);

        void getBumps(const std::vector<Rate>& oldRates,
            const std::vector<Real>& oneStepDFs, // redundant info but saves time to pass in since will have been needed elsewhere
            const std::vector<Rate>& newRates,   // redundant info but saves time to pass in since will have been needed elsewhere
            const std::vector<Real>& gaussians,
            Matrix& B); // B as in page 95 of the GG paper, rows should be number rates long, one row for bump

    private:

        //! this data is always the same
        Matrix pseudoRoot_;
        Size aliveIndex_; 
        std::vector<Time> taus_;
        std::vector<Matrix> pseudoBumped_;
        std::vector<Spread> displacements_; 
        Size numberBumps_;
        std::vector<LMMDriftCalculator> driftsComputers_;
        Size factors_;

        //! workspace variables
        std::vector<Real> drifts_;
        std::vector<Real> bumpedRates_;
   
    };


    

    class RatePseudoRootJacobian
    {
    public:
      RatePseudoRootJacobian(const Matrix& pseudoRoot,
                             Size aliveIndex,
                             Size numeraire,
                             const std::vector<Time>& taus,
                             const std::vector<Matrix>& pseudoBumps,
                             std::vector<Spread> displacements);

      void getBumps(const std::vector<Rate>& oldRates,
                    const std::vector<Real>& oneStepDFs, // redundant info but saves time to pass in
                                                         // since will have been needed elsewhere
                    const std::vector<Rate>& newRates,   // redundant info but saves time to pass in
                                                         // since will have been needed elsewhere
                    const std::vector<Real>& gaussians,
                    Matrix& B); // B as in page 95 of the GG paper, rows should be number rates
                                // long, one row for each bump

    private:

        //! this data does not change after construction
        Matrix pseudoRoot_;
        Size aliveIndex_; 
        std::vector<Time> taus_;
        std::vector<Matrix> pseudoBumps_;
        std::vector<Spread> displacements_; 
        Size numberBumps_;
        Size factors_;

        //! workspace variables

        std::vector<Matrix> allDerivatives_; 
    //    std::vector<Real> bumpedRates_;
        Matrix e_;
        std::vector<Real> ratios_;
   
    };

    
    class RatePseudoRootJacobianAllElements
    {
    public:
      RatePseudoRootJacobianAllElements(const Matrix& pseudoRoot,
                                        Size aliveIndex,
                                        Size numeraire,
                                        const std::vector<Time>& taus,
                                        std::vector<Spread> displacements);

      void getBumps(const std::vector<Rate>& oldRates,
                    const std::vector<Real>& oneStepDFs, // redundant info but saves time to pass in
                                                         // since will have been needed elsewhere
                    const std::vector<Rate>& newRates,   // redundant info but saves time to pass in
                                                         // since will have been needed elsewhere
                    const std::vector<Real>& gaussians,
                    std::vector<Matrix>&
                        B); // one Matrix for each rate, the elements of the matrix are the
                            // derivatives of that rate with respect to each pseudo-root element

    private:

        //! this data does not change after construction
        Matrix pseudoRoot_;
        Size aliveIndex_; 
        std::vector<Time> taus_;
        std::vector<Matrix> pseudoBumps_;
        std::vector<Spread> displacements_; 
        Size factors_;

        //! workspace

        Matrix e_;
        std::vector<Real> ratios_;
   
    };

}

#endif
]]></document_content>
  </document>
  <document index="94">
    <source>marketmodels/pathwisegreeks/swaptionpseudojacobian.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*

 Copyright (C) 2008 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_swaption_pseudo_jacobian_hpp
#define quantlib_swaption_pseudo_jacobian_hpp


#include <ql/models/marketmodels/marketmodel.hpp>

/*! In order to compute market vegas, we need a class that gives the
derivative of a swaption implied vol against changes in pseudo-root elements.
This is that class.

This is tested in the pathwise vegas routine in MarketModels.cpp

*/

namespace QuantLib
{
    class SwaptionPseudoDerivative
    {

        public:
          SwaptionPseudoDerivative(const ext::shared_ptr<MarketModel>& inputModel,
                                   Size startIndex,
                                   Size endIndex);

          const Matrix& varianceDerivative(Size i) const;
          const Matrix& volatilityDerivative(Size i) const;

          Real impliedVolatility() const;
          Real variance() const;
          Real expiry() const;



        private:
            ext::shared_ptr<MarketModel> inputModel_;
            std::vector<Matrix> varianceDerivatives_;
            std::vector<Matrix> volatilityDerivatives_;

            Real impliedVolatility_;
            Real expiry_;
            Real variance_;


    };

/*! In order to compute market vegas, we need a class that gives the
derivative of a cap implied vol against changes in pseudo-root elements.
This is that class.

The operation is non-trivial because the cap implied vol has a complicated
relationship with the caplet implied vols. 

This is  tested in the pathwise vegas routine in MarketModels.cpp

*/

   class CapPseudoDerivative
    {

        public:
          CapPseudoDerivative(const ext::shared_ptr<MarketModel>& inputModel,
                              Real strike,
                              Size startIndex,
                              Size endIndex,
                              Real firstDF);

          const Matrix& volatilityDerivative(Size i) const;
          const Matrix& priceDerivative(Size i) const;

          Real impliedVolatility() const;



        private:
            ext::shared_ptr<MarketModel> inputModel_;
      
            std::vector<Matrix> volatilityDerivatives_;
            
            std::vector<Matrix> priceDerivatives_;

            Real impliedVolatility_;
            Real vega_;
            Real firstDF_;



    };

}

#endif
]]></document_content>
  </document>
  <document index="95">
    <source>marketmodels/pathwisegreeks/vegabumpcluster.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*

 Copyright (C) 2008 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_vega_bump_cluster_hpp
#define quantlib_vega_bump_cluster_hpp

#include <ql/types.hpp>
#include <ql/models/marketmodels/marketmodel.hpp>

/*! When bumping vols, bumping every pseudo-root element individually seems 
excessive so we need to couple some together. 

*/

namespace QuantLib
{
    class VegaBumpCluster
    {
    public:

        VegaBumpCluster(Size factorBegin,
                        Size factorEnd,
                        Size rateBegin,
                        Size rateEnd,
                        Size stepBegin,
                        Size stepEnd);

        bool doesIntersect(const VegaBumpCluster& comparee) const;

        bool isCompatible(const ext::shared_ptr<MarketModel>& volStructure) const;
        Size factorBegin() const
        {
            return factorBegin_;
        }

        Size factorEnd() const
        {
            return factorEnd_;
        }
        
            
        Size rateBegin() const
        {
            return rateBegin_;
        }
        Size rateEnd() const
        {
            return rateEnd_;
        }

        Size stepBegin() const
        {
            return stepBegin_;
        }

        Size stepEnd() const
        {
            return stepEnd_;
        }


    private:
        
        Size factorBegin_;
        Size factorEnd_;       
        Size rateBegin_;
        Size rateEnd_;       
        Size stepBegin_;
        Size stepEnd_;

    };

    /*! 
    There are too many pseudo-root elements to allow bumping them all independently so we cluster them together and 
    then divide all elements into a collection of such clusters. 
   


    */

    class VegaBumpCollection
    {
    public:

        VegaBumpCollection(const ext::shared_ptr<MarketModel>& volStructure, 
                           bool allowFactorwiseBumping = true);

        VegaBumpCollection(std::vector<VegaBumpCluster> allBumps,
                           ext::shared_ptr<MarketModel> volStructure);

        Size numberBumps() const;

        const ext::shared_ptr<MarketModel>& associatedModel() const
        {
            return associatedVolStructure_;
        }


        const std::vector<VegaBumpCluster>& allBumps() const;

        bool isFull() const; // i.e. is every alive pseudo-root element bumped at least once
        bool isNonOverlapping() const; // i.e. is every alive pseudo-root element bumped at most once
        bool isSensible() const; // i.e. is every alive pseudo-root element bumped precisely once

    
    private:

        std::vector<VegaBumpCluster> allBumps_;
        ext::shared_ptr<MarketModel> associatedVolStructure_;
        mutable bool checked_;
        mutable bool nonOverlapped_;
        mutable bool full_;


    };

}

#endif
]]></document_content>
  </document>
  <document index="96">
    <source>marketmodels/pathwisemultiproduct.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2006, 2008 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_market_model_pathwise_multi_product_hpp
#define quantlib_market_model_pathwise_multi_product_hpp

#include <ql/types.hpp>
#include <vector>
#include <memory>

namespace QuantLib {

    class EvolutionDescription;
    class CurveState;

    //! market-model pathwise product
    /*! This is the abstract base class that encapsulates the notion of a
    product: it contains the information that would be in the termsheet
    of the product.

    It's useful to have it be able to do several products simultaneously.
    The products would have to have the same underlying rate times of
    course. The class is therefore really encapsulating the notion of a
    multi-product.

    For each time evolved to, it generates the cash flows associated to
    that time for the state of the yield curve. If one was doing a
    callable product then this would encompass the product and its
    exercise strategy.

    This class differs from market-model multi-product in that it also returns the
    derivative of the pay-off with respect to each forward rate

    */

    class MarketModelPathwiseMultiProduct 
    {
    public:
        struct CashFlow {
            Size timeIndex = 0;
            std::vector<Real > amount;
        };
        virtual ~MarketModelPathwiseMultiProduct() = default;

        virtual std::vector<Size> suggestedNumeraires() const = 0;
        virtual const EvolutionDescription& evolution() const = 0;
        virtual std::vector<Time> possibleCashFlowTimes() const = 0;
        virtual Size numberOfProducts() const = 0;
        virtual Size maxNumberOfCashFlowsPerProductPerStep() const = 0;

        virtual bool alreadyDeflated() const =0;

        //! during simulation put product at start of path
        virtual void reset() = 0;
        //! return value indicates whether path is finished, TRUE means done
        virtual bool nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >& cashFlowsGenerated) = 0;
        //! returns a newly-allocated copy of itself
        virtual std::unique_ptr<MarketModelPathwiseMultiProduct> clone() const = 0;
    };

}


#endif
]]></document_content>
  </document>
  <document index="97">
    <source>marketmodels/piecewiseconstantcorrelation.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_piecewise_constant_correlation_hpp
#define quantlib_piecewise_constant_correlation_hpp

#include <ql/math/matrix.hpp>
#include <vector>

namespace QuantLib {

    class Matrix;

    // corrTimes must include all rateTimes but the last
    class PiecewiseConstantCorrelation {
      public:
        virtual ~PiecewiseConstantCorrelation() = default;
        virtual const std::vector<Time>& times() const = 0;
        virtual const std::vector<Time>& rateTimes() const = 0;
        virtual const std::vector<Matrix>& correlations() const = 0;
        virtual const Matrix& correlation(Size i) const;
        virtual Size numberOfRates() const = 0;
    };

    inline const Matrix&
    PiecewiseConstantCorrelation::correlation(Size i) const {
        const std::vector<Matrix>& results = correlations();
        QL_REQUIRE(i<results.size(),
                   "index (" << i <<
                   ") must be less than correlations vector size (" <<
                   results.size() << ")");
        return results[i];
    }

}

#endif
]]></document_content>
  </document>
  <document index="98">
    <source>marketmodels/products/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/marketmodels/products/compositeproduct.hpp>
#include <ql/models/marketmodels/products/multiproductcomposite.hpp>
#include <ql/models/marketmodels/products/multiproductmultistep.hpp>
#include <ql/models/marketmodels/products/multiproductonestep.hpp>
#include <ql/models/marketmodels/products/singleproductcomposite.hpp>

#include <ql/models/marketmodels/products/onestep/all.hpp>
#include <ql/models/marketmodels/products/multistep/all.hpp>
#include <ql/models/marketmodels/products/pathwise/all.hpp>
]]></document_content>
  </document>
  <document index="99">
    <source>marketmodels/products/compositeproduct.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_market_model_composite_product_hpp
#define quantlib_market_model_composite_product_hpp

#include <ql/models/marketmodels/multiproduct.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/utilities/clone.hpp>
#include <valarray>

namespace QuantLib {

    //! Composition of two or more market-model products
    /*! Instances of this class build a market-model product by
        composing one or more subproducts.

        \pre All subproducts must have the same rate times.
    */
    class MarketModelComposite : public MarketModelMultiProduct {
      public:
        MarketModelComposite() = default;
        //! \name MarketModelMultiProduct interface
        //@{
        const EvolutionDescription& evolution() const override;
        std::vector<Size> suggestedNumeraires() const override;
        std::vector<Time> possibleCashFlowTimes() const override;
        void reset() override;
        //@}
        //! \name Composite facilities
        //@{
        void add(const Clone<MarketModelMultiProduct>&,
                 Real multiplier = 1.0);
        void subtract(const Clone<MarketModelMultiProduct>&,
                      Real multiplier = 1.0);
        void finalize();
        Size size() const;
        const MarketModelMultiProduct& item(Size i) const;
        MarketModelMultiProduct& item(Size i);
        Real multiplier(Size i) const;
        //@}
      protected:
        // subproducts
        struct SubProduct {
            Clone<MarketModelMultiProduct> product;
            Real multiplier;
            std::vector<Size> numberOfCashflows;
            std::vector<std::vector<CashFlow> > cashflows;
            std::vector<Size> timeIndices;
            bool done;
        };
        std::vector<SubProduct> components_;
        typedef std::vector<SubProduct>::iterator iterator;
        typedef std::vector<SubProduct>::const_iterator const_iterator;
        // common evolution data
        std::vector<Time> rateTimes_;
        std::vector<Time> evolutionTimes_;
        EvolutionDescription evolution_;
        // working variables
        bool finalized_ = false;
        Size currentIndex_;
        std::vector<Time> cashflowTimes_;
        std::vector<std::vector<Time> > allEvolutionTimes_;
        std::vector<std::valarray<bool> > isInSubset_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="100">
    <source>marketmodels/products/multiproductcomposite.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_multi_product_composite_hpp
#define quantlib_multi_product_composite_hpp

#include <ql/models/marketmodels/products/compositeproduct.hpp>

namespace QuantLib {

    //! Composition of one or more market-model products
    /*! Instances of this class build a multiple market-model product by
        composing two or more subproducts.

        \pre All subproducts must have the same rate times.
    */
    class MultiProductComposite : public MarketModelComposite {
      public:
        //! \name MarketModelMultiProduct interface
        //@{
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        //@}
    };

}


#endif
]]></document_content>
  </document>
  <document index="101">
    <source>marketmodels/products/multiproductmultistep.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_multiproduct_multistep_hpp
#define quantlib_multiproduct_multistep_hpp

#include <ql/models/marketmodels/multiproduct.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>

namespace QuantLib {

    //! Multiple-step market-model product
    /*! This is the abstract base class that encapsulates the notion
        of a MarketModelMultiProduct which can be evaluated in a more
        than one step (aka Rebonato's long jump).
    */
    class MultiProductMultiStep : public MarketModelMultiProduct {
      public:
        explicit MultiProductMultiStep(std::vector<Time> rateTimes);
        //! \name MarketModelMultiProduct interface
        //@{
        std::vector<Size> suggestedNumeraires() const override;
        const EvolutionDescription& evolution() const override;
        //@}
      protected:
        std::vector<Time> rateTimes_;
        EvolutionDescription evolution_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="102">
    <source>marketmodels/products/multiproductonestep.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_multiproduct_onestep_hpp
#define quantlib_multiproduct_onestep_hpp

#include <ql/models/marketmodels/multiproduct.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>

namespace QuantLib {

    //! Single-step market-model product
    /*! This is the abstract base class that encapsulates the notion
        of a MarketModelMultiProduct which can be evaluated in one step
        (aka Rebonato's very long jump).
    */
    class MultiProductOneStep : public MarketModelMultiProduct {
      public:
        explicit MultiProductOneStep(std::vector<Time> rateTimes);
        //! \name MarketModelMultiProduct interface
        //@{
        const EvolutionDescription& evolution() const override;
        std::vector<Size> suggestedNumeraires() const override;
        //@}
      protected:
        std::vector<Time> rateTimes_;
        EvolutionDescription evolution_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="103">
    <source>marketmodels/products/multistep/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/marketmodels/products/multistep/callspecifiedmultiproduct.hpp>
#include <ql/models/marketmodels/products/multistep/cashrebate.hpp>
#include <ql/models/marketmodels/products/multistep/exerciseadapter.hpp>
#include <ql/models/marketmodels/products/multistep/multistepcoinitialswaps.hpp>
#include <ql/models/marketmodels/products/multistep/multistepcoterminalswaps.hpp>
#include <ql/models/marketmodels/products/multistep/multistepcoterminalswaptions.hpp>
#include <ql/models/marketmodels/products/multistep/multistepforwards.hpp>
#include <ql/models/marketmodels/products/multistep/multistepinversefloater.hpp>
#include <ql/models/marketmodels/products/multistep/multistepnothing.hpp>
#include <ql/models/marketmodels/products/multistep/multistepoptionlets.hpp>
#include <ql/models/marketmodels/products/multistep/multisteppathwisewrapper.hpp>
#include <ql/models/marketmodels/products/multistep/multistepperiodcapletswaptions.hpp>
#include <ql/models/marketmodels/products/multistep/multistepratchet.hpp>
#include <ql/models/marketmodels/products/multistep/multistepswap.hpp>
#include <ql/models/marketmodels/products/multistep/multistepswaption.hpp>
#include <ql/models/marketmodels/products/multistep/multisteptarn.hpp>

]]></document_content>
  </document>
  <document index="104">
    <source>marketmodels/products/multistep/callspecifiedmultiproduct.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_callspecified_multiproduct_hpp
#define quantlib_callspecified_multiproduct_hpp

#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/multiproduct.hpp>
#include <ql/methods/montecarlo/exercisestrategy.hpp>
#include <ql/utilities/clone.hpp>
#include <valarray>

namespace QuantLib {

    class CallSpecifiedMultiProduct : public MarketModelMultiProduct {
     public:
       CallSpecifiedMultiProduct(
           const Clone<MarketModelMultiProduct>& underlying,
           const Clone<ExerciseStrategy<CurveState> >&,
           Clone<MarketModelMultiProduct> rebate = Clone<MarketModelMultiProduct>());
       //! \name MarketModelMultiProduct interface
       //@{
       std::vector<Size> suggestedNumeraires() const override;
       const EvolutionDescription& evolution() const override;
       std::vector<Time> possibleCashFlowTimes() const override;
       Size numberOfProducts() const override;
       Size maxNumberOfCashFlowsPerProductPerStep() const override;
       void reset() override;
       bool nextTimeStep(const CurveState& currentState,
                         std::vector<Size>& numberCashFlowsThisStep,
                         std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        //@}
        const MarketModelMultiProduct& underlying() const;
        const ExerciseStrategy<CurveState>& strategy() const;
        const MarketModelMultiProduct& rebate() const;
        void enableCallability();
        void disableCallability();
      private:
        Clone<MarketModelMultiProduct> underlying_;
        Clone<ExerciseStrategy<CurveState> > strategy_;
        Clone<MarketModelMultiProduct> rebate_;
        EvolutionDescription evolution_;
        std::vector<std::valarray<bool> > isPresent_;
        std::vector<Time> cashFlowTimes_;
        Size rebateOffset_ = 0UL;
        bool wasCalled_ = false;
        std::vector<Size> dummyCashFlowsThisStep_;
        std::vector<std::vector<CashFlow> > dummyCashFlowsGenerated_;
        Size currentIndex_ = 0UL;
        bool callable_ = true;
    };

}

#endif
]]></document_content>
  </document>
  <document index="105">
    <source>marketmodels/products/multistep/cashrebate.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_market_model_cash_rebate_hpp
#define quantlib_market_model_cash_rebate_hpp

#include <ql/models/marketmodels/multiproduct.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/math/matrix.hpp>

namespace QuantLib 
{
    /*!
    Class to model receipt of a fixed cash amount once. Product terminates immediately. 
    Mainly useful as rebate received when another product is cancelled. 

    */

    class MarketModelCashRebate : public MarketModelMultiProduct 
    {
      public:
        MarketModelCashRebate(EvolutionDescription evolution,
                              const std::vector<Time>& paymentTimes,
                              Matrix amounts,
                              Size numberOfProducts);
        //! \name MarketModelMultiProduct interface
        //@{
        std::vector<Size> suggestedNumeraires() const override;
        const EvolutionDescription& evolution() const override;
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;
        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        //@}
      private:
        EvolutionDescription evolution_;
        std::vector<Time> paymentTimes_;
        Matrix amounts_;
        Size numberOfProducts_;
        // things that vary in a path
        Size currentIndex_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="106">
    <source>marketmodels/products/multistep/exerciseadapter.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_multistep_exercise_adapter_hpp
#define quantlib_multistep_exercise_adapter_hpp

#include <ql/models/marketmodels/products/multiproductmultistep.hpp>
#include <ql/models/marketmodels/callability/exercisevalue.hpp>
#include <ql/utilities/clone.hpp>

namespace QuantLib {

    class ExerciseAdapter : public MultiProductMultiStep {
      public:
        ExerciseAdapter(const Clone<MarketModelExerciseValue>& exercise,
                        Size numberOfProducts = 1);
        //! \name MarketModelMultiProduct interface
        //@{
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        const EvolutionDescription& evolution() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;
        bool nextTimeStep(const CurveState&,
                          std::vector<Size>&,
                          std::vector<std::vector<CashFlow> >&) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        //@}
        //! \name inspectors
        //@{
        const MarketModelExerciseValue& exerciseValue() const;
        //@}
      private:
        Clone<MarketModelExerciseValue> exercise_;
        Size numberOfProducts_;
        std::valarray<bool> isExerciseTime_;
        Size currentIndex_;
    };

    // inline definition

    inline std::vector<Time>
    ExerciseAdapter::possibleCashFlowTimes() const {
        return exercise_->possibleCashFlowTimes();
    }

    inline Size ExerciseAdapter::numberOfProducts() const {
        return numberOfProducts_;
    }

    inline const EvolutionDescription& ExerciseAdapter::evolution() const {
        return exercise_->evolution();
    }

    inline Size
    ExerciseAdapter::maxNumberOfCashFlowsPerProductPerStep() const {
        return 1;
    }

    inline void ExerciseAdapter::reset() {
        exercise_->reset();
        currentIndex_ = 0;
    }

    inline const MarketModelExerciseValue&
    ExerciseAdapter::exerciseValue() const {
        return *exercise_;
    }

}

#endif
]]></document_content>
  </document>
  <document index="107">
    <source>marketmodels/products/multistep/multistepcoinitialswaps.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_multistep_coinitial_swaps_hpp
#define quantlib_multistep_coinitial_swaps_hpp

#include <ql/models/marketmodels/products/multiproductmultistep.hpp>

namespace QuantLib {

    class MultiStepCoinitialSwaps : public MultiProductMultiStep {
      public:
        MultiStepCoinitialSwaps(const std::vector<Time>& rateTimes,
                                std::vector<Real> fixedAccruals,
                                std::vector<Real> floatingAccruals,
                                const std::vector<Time>& paymentTimes,
                                Real fixedRate);
        //! \name MarketModelMultiProduct interface
        //@{
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;
        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        //@}
      private:
        std::vector<Real> fixedAccruals_, floatingAccruals_;
        std::vector<Time> paymentTimes_;
        Real fixedRate_;
        Size lastIndex_;
        // things that vary in a path
        Size currentIndex_;
    };

    // inline

    inline std::vector<Time>
    MultiStepCoinitialSwaps::possibleCashFlowTimes() const {
        return paymentTimes_;
    }

    inline Size MultiStepCoinitialSwaps::numberOfProducts() const {
        return lastIndex_;
    }

    inline Size
    MultiStepCoinitialSwaps::maxNumberOfCashFlowsPerProductPerStep() const {
        return 2;
    }

    inline void MultiStepCoinitialSwaps::reset() {
       currentIndex_=0;
    }

}

#endif
]]></document_content>
  </document>
  <document index="108">
    <source>marketmodels/products/multistep/multistepcoterminalswaps.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_multistep_coterminal_swaps_hpp
#define quantlib_multistep_coterminal_swaps_hpp

#include <ql/models/marketmodels/products/multiproductmultistep.hpp>

namespace QuantLib {

    class MultiStepCoterminalSwaps : public MultiProductMultiStep {
      public:
        MultiStepCoterminalSwaps(const std::vector<Time>& rateTimes,
                                 std::vector<Real> fixedAccruals,
                                 std::vector<Real> floatingAccruals,
                                 const std::vector<Time>& paymentTimes,
                                 Real fixedRate);
        //! \name MarketModelMultiProduct interface
        //@{
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;
        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        //@}
      private:
        std::vector<Real> fixedAccruals_, floatingAccruals_;
        std::vector<Time> paymentTimes_;
        Real fixedRate_;
        Size lastIndex_;
        // things that vary in a path
        Size currentIndex_;
    };

    // Inline definitions

    inline std::vector<Time>
    MultiStepCoterminalSwaps::possibleCashFlowTimes() const {
        return paymentTimes_;
    }

    inline Size MultiStepCoterminalSwaps::numberOfProducts() const {
        return lastIndex_;
    }

    inline Size
    MultiStepCoterminalSwaps::maxNumberOfCashFlowsPerProductPerStep() const {
        return 2;
    }

    inline void MultiStepCoterminalSwaps::reset() {
       currentIndex_=0;
    }

}

#endif
]]></document_content>
  </document>
  <document index="109">
    <source>marketmodels/products/multistep/multistepcoterminalswaptions.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_multistep_coterminal_swaptions_hpp
#define quantlib_multistep_coterminal_swaptions_hpp

#include <ql/models/marketmodels/products/multiproductmultistep.hpp>
#include <ql/shared_ptr.hpp>

namespace QuantLib {

    class StrikedTypePayoff;

    class MultiStepCoterminalSwaptions : public MultiProductMultiStep {
      public:
        MultiStepCoterminalSwaptions(const std::vector<Time>& rateTimes,
                                     const std::vector<Time>& paymentTimes,
                                     std::vector<ext::shared_ptr<StrikedTypePayoff> >);
        //! \name MarketModelMultiProduct interface
        //@{
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;
        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
         //@}

      private:
        std::vector<Time> paymentTimes_;
        std::vector<ext::shared_ptr<StrikedTypePayoff> > payoffs_;
        Size lastIndex_;
        // things that vary in a path
        Size currentIndex_;
    };

    // Inline definitions

    inline std::vector<Time>
    MultiStepCoterminalSwaptions::possibleCashFlowTimes() const {
        return paymentTimes_;
    }

    inline Size MultiStepCoterminalSwaptions::numberOfProducts() const {
        return lastIndex_;
    }

    inline Size
    MultiStepCoterminalSwaptions::maxNumberOfCashFlowsPerProductPerStep() const {
        return 1;
    }

    inline void MultiStepCoterminalSwaptions::reset() {
       currentIndex_=0;
    }

}

#endif
]]></document_content>
  </document>
  <document index="110">
    <source>marketmodels/products/multistep/multistepforwards.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_multistep_forwards_hpp
#define quantlib_multistep_forwards_hpp

#include <ql/models/marketmodels/products/multiproductmultistep.hpp>

namespace QuantLib {

    class MultiStepForwards : public MultiProductMultiStep {
      public:
        MultiStepForwards(const std::vector<Time>& rateTimes,
                          std::vector<Real> accruals,
                          const std::vector<Time>& paymentTimes,
                          std::vector<Rate> strikes);
        //! \name MarketModelMultiProduct interface
        //@{
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;
        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        //@}
      private:
        std::vector<Real> accruals_;
        std::vector<Time> paymentTimes_;
        std::vector<Rate> strikes_;
        // things that vary in a path
        Size currentIndex_;
    };

    // inline

    inline std::vector<Time>
    MultiStepForwards::possibleCashFlowTimes() const {
        return paymentTimes_;
    }

    inline Size MultiStepForwards::numberOfProducts() const {
        return strikes_.size();
    }

    inline Size
    MultiStepForwards::maxNumberOfCashFlowsPerProductPerStep() const {
        return 1;
    }

    inline void MultiStepForwards::reset() {
       currentIndex_=0;
    }

}

#endif
]]></document_content>
  </document>
  <document index="111">
    <source>marketmodels/products/multistep/multistepinversefloater.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_multistep_inverse_floater_hpp
#define quantlib_multistep_inverse_floater_hpp

#include <ql/models/marketmodels/products/multiproductmultistep.hpp>

namespace QuantLib {

    /*
    Tested in MarketModels::testInverseFloater()

    */

    class MultiStepInverseFloater : public MultiProductMultiStep {
      public:
        MultiStepInverseFloater(const std::vector<Time>& rateTimes,
                                std::vector<Real> fixedAccruals,
                                const std::vector<Real>& floatingAccruals,
                                const std::vector<Real>& fixedStrikes,
                                const std::vector<Real>& fixedMultipliers,
                                const std::vector<Real>& floatingSpreads,
                                const std::vector<Time>& paymentTimes,
                                bool payer = true);
        //! \name MarketModelMultiProduct interface
        //@{
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;
        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        //@}
      private:
        std::vector<Real> fixedAccruals_, floatingAccruals_,fixedStrikes_, fixedMultipliers_, floatingSpreads_;
        std::vector<Time> paymentTimes_;
    
        Real multiplier_;
        Size lastIndex_;
        // things that vary in a path
        Size currentIndex_;
    };


    // inline definitions

    inline std::vector<Time>
    MultiStepInverseFloater::possibleCashFlowTimes() const {
        return paymentTimes_;
    }

    inline Size MultiStepInverseFloater::numberOfProducts() const {
        return 1;
    }

    inline Size
    MultiStepInverseFloater::maxNumberOfCashFlowsPerProductPerStep() const {
        return 1;
    }

    inline void MultiStepInverseFloater::reset() {
       currentIndex_=0;
    }

}

#endif
]]></document_content>
  </document>
  <document index="112">
    <source>marketmodels/products/multistep/multistepnothing.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_multistep_nothing_hpp
#define quantlib_multistep_nothing_hpp

#include <ql/models/marketmodels/products/multiproductmultistep.hpp>

namespace QuantLib {

    class MultiStepNothing : public MultiProductMultiStep {
      public:
        MultiStepNothing(const EvolutionDescription& evolution,
                         Size numberOfProducts = 1,
                         Size doneIndex = 0);
        //! \name MarketModelMultiProduct interface
        //@{
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;
        bool nextTimeStep(const CurveState&,
                          std::vector<Size>&,
                          std::vector<std::vector<CashFlow> >&) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        //@}
      private:
        Size numberOfProducts_, doneIndex_;
        // things that vary in a path
        Size currentIndex_;
    };

    // inline definitions

    inline std::vector<Time>
    MultiStepNothing::possibleCashFlowTimes() const {
        return std::vector<Time>();
    }

    inline Size MultiStepNothing::numberOfProducts() const {
        return numberOfProducts_;
    }

    inline Size
    MultiStepNothing::maxNumberOfCashFlowsPerProductPerStep() const {
        return 0;
    }

    inline void MultiStepNothing::reset() {
       currentIndex_=0;
    }

}

#endif
]]></document_content>
  </document>
  <document index="113">
    <source>marketmodels/products/multistep/multistepoptionlets.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_multistep_optionlets_hpp
#define quantlib_multistep_optionlets_hpp

#include <ql/models/marketmodels/products/multiproductmultistep.hpp>
#include <ql/shared_ptr.hpp>

namespace QuantLib {

    class Payoff;

    class MultiStepOptionlets : public MultiProductMultiStep {
      public:
        MultiStepOptionlets(const std::vector<Time>& rateTimes,
                            std::vector<Real> accruals,
                            const std::vector<Time>& paymentTimes,
                            std::vector<ext::shared_ptr<Payoff> >);
        //! \name MarketModelMultiProduct interface
        //@{
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;
        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        //@}
      private:
        std::vector<Real> accruals_;
        std::vector<Time> paymentTimes_;
        std::vector<ext::shared_ptr<Payoff> > payoffs_;
        // things that vary in a path
        Size currentIndex_;
    };

    // inline definitions

    inline std::vector<Time>
    MultiStepOptionlets::possibleCashFlowTimes() const {
      return paymentTimes_;
    }

    inline Size MultiStepOptionlets::numberOfProducts() const {
        return payoffs_.size();
    }

    inline Size
    MultiStepOptionlets::maxNumberOfCashFlowsPerProductPerStep() const {
        return 1;
    }

    inline void MultiStepOptionlets::reset() {
       currentIndex_=0;
    }

}

#endif
]]></document_content>
  </document>
  <document index="114">
    <source>marketmodels/products/multistep/multisteppathwisewrapper.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_multistep_pathwise_wrapper_hpp
#define quantlib_multistep_pathwise_wrapper_hpp


#include <ql/models/marketmodels/multiproduct.hpp>
#include <ql/models/marketmodels/pathwisemultiproduct.hpp>
#include <ql/utilities/clone.hpp>

namespace QuantLib 
{
/*! MultiStepPathwiseWrapper
    Pathwise products do everything that ordinary products do and more. This lets
    you treat a pathwise product as an ordinary product. So you only have to write the 
    product once. 

    Tested in MarketModels::testInverseFloater()

*/

    class MultiProductPathwiseWrapper : public MarketModelMultiProduct
    {
      public:
        MultiProductPathwiseWrapper(const MarketModelPathwiseMultiProduct& innerProduct_);
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;
        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        std::vector<Size> suggestedNumeraires() const override;
        const EvolutionDescription& evolution() const override;

      private:
          Clone<MarketModelPathwiseMultiProduct> innerProduct_;
          std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> > cashFlowsGenerated_;
          Size numberOfProducts_;
     
    };


}

#endif
]]></document_content>
  </document>
  <document index="115">
    <source>marketmodels/products/multistep/multistepperiodcapletswaptions.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_multistep_period_caplets_swaptions_hpp
#define quantlib_multistep_period_caplets_swaptions_hpp

#include <ql/models/marketmodels/products/multiproductmultistep.hpp>
#include <ql/shared_ptr.hpp>
#include <vector>
namespace QuantLib {

    class StrikedTypePayoff;

    class MultiStepPeriodCapletSwaptions : public MultiProductMultiStep 
    {
      public:
        MultiStepPeriodCapletSwaptions(
            const std::vector<Time>& rateTimes,
            const std::vector<Time>& forwardOptionPaymentTimes,
            const std::vector<Time>& swaptionPaymentTimes,
            std::vector<ext::shared_ptr<StrikedTypePayoff> > forwardPayOffs,
            std::vector<ext::shared_ptr<StrikedTypePayoff> > swapPayOffs,
            Size period,
            Size offset);
        //! \name MarketModelMultiProduct interface
        //@{
          std::vector<Time> possibleCashFlowTimes() const override;
          Size numberOfProducts() const override;
          Size maxNumberOfCashFlowsPerProductPerStep() const override;
          void reset() override;
          bool nextTimeStep(const CurveState& currentState,
                            std::vector<Size>& numberCashFlowsThisStep,
                            std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
          std::unique_ptr<MarketModelMultiProduct> clone() const override;
         //@}

      private:
        std::vector<Time> paymentTimes_;
        std::vector<Time> forwardOptionPaymentTimes_;
        std::vector<Time> swaptionPaymentTimes_;
        std::vector<ext::shared_ptr<StrikedTypePayoff> > forwardPayOffs_;
        std::vector<ext::shared_ptr<StrikedTypePayoff> > swapPayOffs_;
        Size lastIndex_;
        Size period_;
        Size offset_;
        Size numberFRAs_;
        Size  numberBigFRAs_; 

        // things that vary in a path
        Size currentIndex_;
        Size productIndex_;
    };

    // Inline definitions

    inline std::vector<Time>
    MultiStepPeriodCapletSwaptions::possibleCashFlowTimes() const {
        return paymentTimes_;
    }

    inline Size MultiStepPeriodCapletSwaptions::numberOfProducts() const {
        return numberBigFRAs_*2;
    }

    inline Size
    MultiStepPeriodCapletSwaptions::maxNumberOfCashFlowsPerProductPerStep() const {
        return 1;
    }

    inline void MultiStepPeriodCapletSwaptions::reset() {
       currentIndex_=0;
       productIndex_=0;
    }

}

#endif
]]></document_content>
  </document>
  <document index="116">
    <source>marketmodels/products/multistep/multistepratchet.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_multistep_ratchet_hpp
#define quantlib_multistep_ratchet_hpp

#include <ql/models/marketmodels/products/multiproductmultistep.hpp>

namespace QuantLib {

    class MultiStepRatchet : public MultiProductMultiStep {
      public:
        MultiStepRatchet(const std::vector<Time>& rateTimes,
                         std::vector<Real> accruals,
                         const std::vector<Time>& paymentTimes,
                         Real gearingOfFloor,
                         Real gearingOfFixing,
                         Rate spreadOfFloor,
                         Rate spreadOfFixing,
                         Real initialFloor,
                         bool payer = true);
        //! \name MarketModelMultiProduct interface
        //@{
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;
        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        //@}
      private:
        std::vector<Real> accruals_;
        std::vector<Time> paymentTimes_;
        Real gearingOfFloor_, gearingOfFixing_;
        Rate spreadOfFloor_, spreadOfFixing_;
        Real multiplier_;
        Size lastIndex_;
        Real initialFloor_;
        // things that vary in a path
        Real floor_;
        Size currentIndex_;
    };


    // inline definitions

    inline std::vector<Time>
    MultiStepRatchet::possibleCashFlowTimes() const {
        return paymentTimes_;
    }

    inline Size MultiStepRatchet::numberOfProducts() const {
        return 1;
    }

    inline Size
    MultiStepRatchet::maxNumberOfCashFlowsPerProductPerStep() const {
        return 1;
    }

    inline void MultiStepRatchet::reset() 
    {
       currentIndex_=0;
       floor_ = initialFloor_;
    }

}

#endif
]]></document_content>
  </document>
  <document index="117">
    <source>marketmodels/products/multistep/multistepswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_multistep_swap_hpp
#define quantlib_multistep_swap_hpp

#include <ql/models/marketmodels/products/multiproductmultistep.hpp>

namespace QuantLib {

    // TODO: add payer/receiver choice

    class MultiStepSwap : public MultiProductMultiStep {
      public:
        MultiStepSwap(const std::vector<Time>& rateTimes,
                      std::vector<Real> fixedAccruals,
                      std::vector<Real> floatingAccruals,
                      const std::vector<Time>& paymentTimes,
                      Rate fixedRate,
                      bool payer = true);
        //! \name MarketModelMultiProduct interface
        //@{
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;
        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        //@}
      private:
        std::vector<Real> fixedAccruals_, floatingAccruals_;
        std::vector<Time> paymentTimes_;
        Rate fixedRate_;
        Real multiplier_;
        Size lastIndex_;
        // things that vary in a path
        Size currentIndex_;
    };


    // inline definitions

    inline std::vector<Time>
    MultiStepSwap::possibleCashFlowTimes() const {
        return paymentTimes_;
    }

    inline Size MultiStepSwap::numberOfProducts() const {
        return 1;
    }

    inline Size
    MultiStepSwap::maxNumberOfCashFlowsPerProductPerStep() const {
        return 2;
    }

    inline void MultiStepSwap::reset() {
       currentIndex_=0;
    }

}

#endif
]]></document_content>
  </document>
  <document index="118">
    <source>marketmodels/products/multistep/multistepswaption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_multistep_multistep_swaption_hpp
#define quantlib_multistep_multistep_swaption_hpp

#include <ql/models/marketmodels/products/multiproductmultistep.hpp>
#include <ql/shared_ptr.hpp>

namespace QuantLib {

    class StrikedTypePayoff;

    /*!
    Price a swaption associated to a contiguous subset of rates. Useful only for
    testing purposes. Steps through all rate times up to start of swap. 
    */

    class MultiStepSwaption : public MultiProductMultiStep {
      public:
        MultiStepSwaption(const std::vector<Time>& rateTimes,
                                     Size startIndex,
                                     Size endIndex,
                                     ext::shared_ptr<StrikedTypePayoff> &);
        //! \name MarketModelMultiProduct interface
        //@{
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;
        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
         //@}

      private:
    
        Size startIndex_;
        Size endIndex_;
        ext::shared_ptr<StrikedTypePayoff> payoff_;
        std::vector<Time> paymentTimes_;
        // things that vary in a path
        Size currentIndex_;
    };

    // Inline definitions

    inline std::vector<Time>
    MultiStepSwaption::possibleCashFlowTimes() const 
    {
        return paymentTimes_;
    }

    inline Size MultiStepSwaption::numberOfProducts() const {
        return 1UL;
    }

    inline Size
    MultiStepSwaption::maxNumberOfCashFlowsPerProductPerStep() const {
        return 1;
    }

    inline void MultiStepSwaption::reset()
    {
       currentIndex_=0;
    }

}

#endif
]]></document_content>
  </document>
  <document index="119">
    <source>marketmodels/products/multistep/multisteptarn.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_multistep_tarn_hpp
#define quantlib_multistep_tarn_hpp

#include <ql/models/marketmodels/products/multiproductmultistep.hpp>

namespace QuantLib {

    class MultiStepTarn : public MultiProductMultiStep {
      public:
        MultiStepTarn(const std::vector<Time>& rateTimes,
                      const std::vector<Real>& accruals,
                      const std::vector<Real>& accrualsFloating,
                      const std::vector<Time>& paymentTimes,
                      const std::vector<Time>& paymentTimesFloating,
                      Real totalCoupon,
                      const std::vector<Real>& strikes,
                      std::vector<Real> multipliers,
                      const std::vector<Real>& floatingSpreads);
        //! \name MarketModelMultiProduct interface
        //@{
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;
        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        //@}
      private:
        std::vector<Real> accruals_;
        std::vector<Real> accrualsFloating_;
        std::vector<Time> paymentTimes_;
        std::vector<Time> paymentTimesFloating_;
        std::vector<Time> allPaymentTimes_;
        Real totalCoupon_;
        std::vector<Real> strikes_;
        std::vector<Real> multipliers_;
        std::vector<Real> floatingSpreads_;
        Size lastIndex_;
      
        // things that vary in a path
        Real couponPaid_;
        Size currentIndex_;
    };




}

#endif
]]></document_content>
  </document>
  <document index="120">
    <source>marketmodels/products/onestep/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/marketmodels/products/onestep/onestepcoinitialswaps.hpp>
#include <ql/models/marketmodels/products/onestep/onestepcoterminalswaps.hpp>
#include <ql/models/marketmodels/products/onestep/onestepforwards.hpp>
#include <ql/models/marketmodels/products/onestep/onestepoptionlets.hpp>

]]></document_content>
  </document>
  <document index="121">
    <source>marketmodels/products/onestep/onestepcoinitialswaps.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_onestep_coinitialswaps_hpp
#define quantlib_onestep_coinitialswaps_hpp

#include <ql/models/marketmodels/products/multiproductonestep.hpp>

namespace QuantLib {
    class OneStepCoinitialSwaps : public MultiProductOneStep {
      public:
        OneStepCoinitialSwaps(const std::vector<Time>& rateTimes,
                              std::vector<Real> fixedAccruals,
                              std::vector<Real> floatingAccruals,
                              const std::vector<Time>& paymentTimes,
                              Real fixedRate);
        //! \name MarketModelMultiProduct interface
        //@{
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;
        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        //@}
      private:
        std::vector<Real> fixedAccruals_, floatingAccruals_;
        std::vector<Time> paymentTimes_;
        Real fixedRate_;
        Size lastIndex_;
    };


    // inline definitions

    inline std::vector<Time>
    OneStepCoinitialSwaps::possibleCashFlowTimes() const {
        return paymentTimes_;
    }

    inline Size OneStepCoinitialSwaps::numberOfProducts() const {
        return lastIndex_;
    }

    inline Size
    OneStepCoinitialSwaps::maxNumberOfCashFlowsPerProductPerStep() const {
        return 2*lastIndex_;
    }

    inline void OneStepCoinitialSwaps::reset() {
        // nothing to do
    }

}


#endif

]]></document_content>
  </document>
  <document index="122">
    <source>marketmodels/products/onestep/onestepcoterminalswaps.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_onestep_coterminalswaps_hpp
#define quantlib_onestep_coterminalswaps_hpp

#include <ql/models/marketmodels/products/multiproductonestep.hpp>

namespace QuantLib {

    class OneStepCoterminalSwaps : public MultiProductOneStep {
      public:
        OneStepCoterminalSwaps(const std::vector<Time>& rateTimes,
                               std::vector<Real> fixedAccruals,
                               std::vector<Real> floatingAccruals,
                               const std::vector<Time>& paymentTimes,
                               Real fixedRate);
        //! \name MarketModelMultiProduct interface
        //@{
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;
        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        //@}
      private:
        std::vector<Real> fixedAccruals_, floatingAccruals_;
        std::vector<Time> paymentTimes_;
        Real fixedRate_;
        Size lastIndex_;
    };

    // inline definitions

    inline std::vector<Time>
    OneStepCoterminalSwaps::possibleCashFlowTimes() const {
        return paymentTimes_;
    }

    inline Size OneStepCoterminalSwaps::numberOfProducts() const {
        return lastIndex_;
    }

    inline Size
    OneStepCoterminalSwaps::maxNumberOfCashFlowsPerProductPerStep() const {
        return 2*lastIndex_;
    }

    inline void OneStepCoterminalSwaps::reset() {
       // nothing to do
    }

}


#endif
]]></document_content>
  </document>
  <document index="123">
    <source>marketmodels/products/onestep/onestepforwards.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_onestep_forwards_hpp
#define quantlib_onestep_forwards_hpp

#include <ql/models/marketmodels/products/multiproductonestep.hpp>

namespace QuantLib {

    class OneStepForwards : public MultiProductOneStep {
      public:
        OneStepForwards(const std::vector<Time>& rateTimes,
                        std::vector<Real> accruals,
                        const std::vector<Time>& paymentTimes,
                        std::vector<Rate> strikes);
        //! \name MarketModelMultiProduct interface
        //@{
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;
        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        //@}
      private:
        std::vector<Real> accruals_;
        std::vector<Time> paymentTimes_;
        std::vector<Rate> strikes_;
    };

    // inline definitions

    inline std::vector<Time>
    OneStepForwards::possibleCashFlowTimes() const {
      return paymentTimes_;
    }

    inline Size
    OneStepForwards::numberOfProducts() const {
        return strikes_.size();
    }

    inline Size
    OneStepForwards::maxNumberOfCashFlowsPerProductPerStep() const {
        return 1;
    }

    inline void
    OneStepForwards::reset() {
        // nothing to do
    }

}


#endif

]]></document_content>
  </document>
  <document index="124">
    <source>marketmodels/products/onestep/onestepoptionlets.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_onestep_optionlets_hpp
#define quantlib_onestep_optionlets_hpp

#include <ql/models/marketmodels/products/multiproductonestep.hpp>
#include <ql/shared_ptr.hpp>

namespace QuantLib {

    class Payoff;

    class OneStepOptionlets : public MultiProductOneStep {
      public:
        OneStepOptionlets(const std::vector<Time>& rateTimes,
                          std::vector<Real> accruals,
                          const std::vector<Time>& paymentTimes,
                          std::vector<ext::shared_ptr<Payoff> >);
        //! \name MarketModelMultiProduct interface
        //@{
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;
        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        //@}
      private:
        std::vector<Real> accruals_;
        std::vector<Time> paymentTimes_;
        std::vector<ext::shared_ptr<Payoff> > payoffs_;
    };

    // inline definitions

    inline std::vector<Time>
    OneStepOptionlets::possibleCashFlowTimes() const {
      return paymentTimes_;
    }

    inline Size OneStepOptionlets::numberOfProducts() const {
        return payoffs_.size();
    }

    inline Size
    OneStepOptionlets::maxNumberOfCashFlowsPerProductPerStep() const {
        return 1;
    }

    inline void OneStepOptionlets::reset() {
        // nothing to do
    }

}

#endif
]]></document_content>
  </document>
  <document index="125">
    <source>marketmodels/products/pathwise/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/marketmodels/products/pathwise/pathwiseproductcallspecified.hpp>
#include <ql/models/marketmodels/products/pathwise/pathwiseproductcaplet.hpp>
#include <ql/models/marketmodels/products/pathwise/pathwiseproductcashrebate.hpp>
#include <ql/models/marketmodels/products/pathwise/pathwiseproductinversefloater.hpp>
#include <ql/models/marketmodels/products/pathwise/pathwiseproductswap.hpp>
#include <ql/models/marketmodels/products/pathwise/pathwiseproductswaption.hpp>

]]></document_content>
  </document>
  <document index="126">
    <source>marketmodels/products/pathwise/pathwiseproductcallspecified.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2009 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_market_model_pathwise_call_specified_hpp
#define quantlib_market_model_pathwise_call_specified_hpp

#include <ql/methods/montecarlo/exercisestrategy.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/pathwisemultiproduct.hpp>
#include <ql/types.hpp>
#include <ql/utilities/clone.hpp>
#include <memory>
#include <valarray>
#include <vector>

namespace QuantLib
{
    class curveState;


    class CallSpecifiedPathwiseMultiProduct : public MarketModelPathwiseMultiProduct
    {
    public:
      CallSpecifiedPathwiseMultiProduct(
          const Clone<MarketModelPathwiseMultiProduct>& underlying,
          const Clone<ExerciseStrategy<CurveState> >&,
          Clone<MarketModelPathwiseMultiProduct> rebate = Clone<MarketModelPathwiseMultiProduct>());
      //! \name MarketModelPathwiseMultiProduct interface
      //@{
      std::vector<Size> suggestedNumeraires() const override;
      const EvolutionDescription& evolution() const override;
      std::vector<Time> possibleCashFlowTimes() const override;
      Size numberOfProducts() const override;
      Size maxNumberOfCashFlowsPerProductPerStep() const override;
      void reset() override;
      bool nextTimeStep(const CurveState& currentState,
                        std::vector<Size>& numberCashFlowsThisStep,
                        std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >&
                            cashFlowsGenerated) override;

        std::unique_ptr<MarketModelPathwiseMultiProduct> clone() const override;

        bool alreadyDeflated() const override;
        //@}
        const MarketModelPathwiseMultiProduct& underlying() const;
        const ExerciseStrategy<CurveState>& strategy() const;
        const MarketModelPathwiseMultiProduct& rebate() const;
        void enableCallability();
        void disableCallability();
              

    private:
        Clone<MarketModelPathwiseMultiProduct> underlying_;
        Clone<ExerciseStrategy<CurveState> > strategy_;
        Clone<MarketModelPathwiseMultiProduct> rebate_;
        EvolutionDescription evolution_;
        std::vector<std::valarray<bool> > isPresent_;
        std::vector<Time> cashFlowTimes_;
        Size rebateOffset_ = 0UL;
        bool wasCalled_ = false;
        std::vector<Size> dummyCashFlowsThisStep_;
        std::vector<std::vector<CashFlow> > dummyCashFlowsGenerated_;
        Size currentIndex_ = 0UL;
        bool callable_ = true;
    };

}

#endif
]]></document_content>
  </document>
  <document index="127">
    <source>marketmodels/products/pathwise/pathwiseproductcaplet.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_market_model_pathwise_caplet_hpp
#define quantlib_market_model_pathwise_caplet_hpp

#include <ql/types.hpp>
#include <ql/models/marketmodels/pathwisemultiproduct.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <vector>
#include <memory>

namespace QuantLib {

    class EvolutionDescription;
    class CurveState;

    //! market-model pathwise caplet
    /*! implementation of path wise methodology for caplets, essentially a test class
    since we have better ways of computing Greeks of caplets

    used in   MarketModelTest::testPathwiseVegas
    and       MarketModelTest::testPathwiseGreeks

    */

    class MarketModelPathwiseMultiCaplet : public MarketModelPathwiseMultiProduct
    {
     public:

       MarketModelPathwiseMultiCaplet(
                          const std::vector<Time>& rateTimes,
                          const std::vector<Real>& accruals,
                          const std::vector<Time>& paymentTimes,
                          const std::vector<Rate>& strikes);

       ~MarketModelPathwiseMultiCaplet() override = default;

       std::vector<Size> suggestedNumeraires() const override;
       const EvolutionDescription& evolution() const override;
       std::vector<Time> possibleCashFlowTimes() const override;
       Size numberOfProducts() const override;
       Size maxNumberOfCashFlowsPerProductPerStep() const override;

       // has division by the numeraire already been done?
       bool alreadyDeflated() const override;


       //! during simulation put product at start of path
       void reset() override;

       //! return value indicates whether path is finished, TRUE means done

       bool nextTimeStep(const CurveState& currentState,
                         std::vector<Size>& numberCashFlowsThisStep,
                         std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >&
                             cashFlowsGenerated) override;

        //! returns a newly-allocated copy of itself
        std::unique_ptr<MarketModelPathwiseMultiProduct> clone() const override;

    private:
        std::vector<Real> rateTimes_;
        std::vector<Real> accruals_;
        std::vector<Time> paymentTimes_;
        std::vector<Rate> strikes_;
        Size numberRates_;
        // things that vary in a path
        Size currentIndex_;

        EvolutionDescription evolution_;
    };

    class MarketModelPathwiseMultiDeflatedCaplet : public MarketModelPathwiseMultiProduct
    {
     public:

       MarketModelPathwiseMultiDeflatedCaplet(
                          const std::vector<Time>& rateTimes,
                          const std::vector<Real>& accruals,
                          const std::vector<Time>& paymentTimes,
                          const std::vector<Rate>& strikes);

       MarketModelPathwiseMultiDeflatedCaplet(const std::vector<Time>& rateTimes,
                                     const std::vector<Real>& accruals,
                                     const std::vector<Time>& paymentTimes,
                                     Rate strike);

       ~MarketModelPathwiseMultiDeflatedCaplet() override = default;

       std::vector<Size> suggestedNumeraires() const override;
       const EvolutionDescription& evolution() const override;
       std::vector<Time> possibleCashFlowTimes() const override;
       Size numberOfProducts() const override;
       Size maxNumberOfCashFlowsPerProductPerStep() const override;

       // has division by the numeraire already been done?
       bool alreadyDeflated() const override;


       //! during simulation put product at start of path
       void reset() override;

       //! return value indicates whether path is finished, TRUE means done

       bool nextTimeStep(const CurveState& currentState,
                         std::vector<Size>& numberCashFlowsThisStep,
                         std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >&
                             cashFlowsGenerated) override;

        //! returns a newly-allocated copy of itself
        std::unique_ptr<MarketModelPathwiseMultiProduct> clone() const override;

    private:
        std::vector<Real> rateTimes_;
        std::vector<Real> accruals_;
        std::vector<Time> paymentTimes_;
        std::vector<Rate> strikes_;
        Size numberRates_;
        // things that vary in a path
        Size currentIndex_;

        EvolutionDescription evolution_;
    };

    /*! MarketModelPathwiseMultiDeflatedCap to price several caps and get their derivatives
    simultaneously. Mainly useful for testing pathwise market vegas code.

    */

  class MarketModelPathwiseMultiDeflatedCap : public MarketModelPathwiseMultiProduct
    {
     public:
       MarketModelPathwiseMultiDeflatedCap(const std::vector<Time>& rateTimes,
                                           const std::vector<Real>& accruals,
                                           const std::vector<Time>& paymentTimes,
                                           Rate strike,
                                           std::vector<std::pair<Size, Size> > startsAndEnds);


       ~MarketModelPathwiseMultiDeflatedCap() override = default;

       std::vector<Size> suggestedNumeraires() const override;
       const EvolutionDescription& evolution() const override;
       std::vector<Time> possibleCashFlowTimes() const override;
       Size numberOfProducts() const override;
       Size maxNumberOfCashFlowsPerProductPerStep() const override;

       // has division by the numeraire already been done?
       bool alreadyDeflated() const override;


       //! during simulation put product at start of path
       void reset() override;

       //! return value indicates whether path is finished, TRUE means done

       bool nextTimeStep(const CurveState& currentState,
                         std::vector<Size>& numberCashFlowsThisStep,
                         std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >&
                             cashFlowsGenerated) override;

        //! returns a newly-allocated copy of itself
        std::unique_ptr<MarketModelPathwiseMultiProduct> clone() const override;

    private:
        MarketModelPathwiseMultiDeflatedCaplet underlyingCaplets_;

        Size numberRates_;

        std::vector<std::pair<Size,Size> > startsAndEnds_;

        // things that vary in a path
        Size currentIndex_;
        std::vector<Size> innerCashFlowSizes_;
        std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> > innerCashFlowsGenerated_;

    };


}
#endif
]]></document_content>
  </document>
  <document index="128">
    <source>marketmodels/products/pathwise/pathwiseproductcashrebate.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_market_model_pathwise_cash_rebate_hpp
#define quantlib_market_model_pathwise_cash_rebate_hpp

#include <ql/types.hpp>
#include <ql/models/marketmodels/pathwisemultiproduct.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>
#include <ql/math/matrix.hpp>
#include <vector>
#include <memory>

namespace QuantLib {

    class EvolutionDescription;
    class CurveState;

    /*!
    Swap for doing simple cash rebate. Fairly useless when used directly, but if we want to look a breakable swap
    it becomes useful.

    */
    class MarketModelPathwiseCashRebate : public MarketModelPathwiseMultiProduct

     {
      public:
        MarketModelPathwiseCashRebate(EvolutionDescription evolution,
                                      const std::vector<Time>& paymentTimes,
                                      Matrix amounts,
                                      Size numberOfProducts);

        std::vector<Size> suggestedNumeraires() const override;
        const EvolutionDescription& evolution() const override;
        std::vector<Time> possibleCashFlowTimes() const override;
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        void reset() override;


        bool alreadyDeflated() const override;

        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >&
                              cashFlowsGenerated) override;

        std::unique_ptr<MarketModelPathwiseMultiProduct> clone() const override;

      private:
        EvolutionDescription evolution_;
        std::vector<Time> paymentTimes_;
        Matrix amounts_;
        Size numberOfProducts_;
        // things that vary in a path
        Size currentIndex_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="129">
    <source>marketmodels/products/pathwise/pathwiseproductinversefloater.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_market_model_pathwise_inverse_floater_hpp
#define quantlib_market_model_pathwise_inverse_floater_hpp

#include <ql/types.hpp>
#include <ql/models/marketmodels/pathwisemultiproduct.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>
#include <vector>
#include <memory>

namespace QuantLib 
{

    class EvolutionDescription;
    class CurveState;

    /*!
    Pathwise product inverse floater for doing Greeks
    Tested in MarketModels::testInverseFloater()

    */
class MarketModelPathwiseInverseFloater : public MarketModelPathwiseMultiProduct
    {
     public:
       MarketModelPathwiseInverseFloater(const std::vector<Time>& rateTimes,
                                         std::vector<Real> fixedAccruals,
                                         const std::vector<Real>& floatingAccruals,
                                         const std::vector<Real>& fixedStrikes,
                                         const std::vector<Real>& fixedMultipliers,
                                         const std::vector<Real>& floatingSpreads,
                                         const std::vector<Time>& paymentTimes,
                                         bool payer = true);

       ~MarketModelPathwiseInverseFloater() override = default;

       std::vector<Size> suggestedNumeraires() const override;
       const EvolutionDescription& evolution() const override;
       std::vector<Time> possibleCashFlowTimes() const override;
       Size numberOfProducts() const override;
       Size maxNumberOfCashFlowsPerProductPerStep() const override;

       // has division by the numeraire already been done?
       bool alreadyDeflated() const override;


       //! during simulation put product at start of path
       void reset() override;

       //! return value indicates whether path is finished, TRUE means done
       bool nextTimeStep(const CurveState& currentState,
                         std::vector<Size>& numberCashFlowsThisStep,
                         std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >&
                             cashFlowsGenerated) override;

        //! returns a newly-allocated copy of itself
        std::unique_ptr<MarketModelPathwiseMultiProduct> clone() const override;

    private:
        std::vector<Real> rateTimes_,fixedAccruals_, floatingAccruals_,fixedStrikes_, fixedMultipliers_, floatingSpreads_;
        std::vector<Time> paymentTimes_;
    
        Real multiplier_;
        Size lastIndex_;
        
        EvolutionDescription evolution_;

        // things that vary in a path
        Size currentIndex_;

    };
}

#endif
]]></document_content>
  </document>
  <document index="130">
    <source>marketmodels/products/pathwise/pathwiseproductswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_market_model_pathwise_swap_hpp
#define quantlib_market_model_pathwise_swap_hpp

#include <ql/types.hpp>
#include <ql/models/marketmodels/pathwisemultiproduct.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>
#include <vector>
#include <memory>

namespace QuantLib {

    class EvolutionDescription;
    class CurveState;

    /*!
    Swap for doing Greeks. Fairly useless when used directly, but if we want to look a breakable swap
    it becomes useful. 
   
    */
class MarketModelPathwiseSwap : public MarketModelPathwiseMultiProduct
    {
     public:

       MarketModelPathwiseSwap(
                          const std::vector<Time>& rateTimes,
                          const std::vector<Time>& accruals,
                          const std::vector<Rate>& strikes,
                          Real multiplier = 1.0 // easy way to swtich between payer and receiver
                          );

       ~MarketModelPathwiseSwap() override = default;

       std::vector<Size> suggestedNumeraires() const override;
       const EvolutionDescription& evolution() const override;
       std::vector<Time> possibleCashFlowTimes() const override;
       Size numberOfProducts() const override;
       Size maxNumberOfCashFlowsPerProductPerStep() const override;

       // has division by the numeraire already been done?
       bool alreadyDeflated() const override;


       //! during simulation put product at start of path
       void reset() override;

       //! return value indicates whether path is finished, TRUE means done
       bool nextTimeStep(const CurveState& currentState,
                         std::vector<Size>& numberCashFlowsThisStep,
                         std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >&
                             cashFlowsGenerated) override;

        //! returns a newly-allocated copy of itself
        std::unique_ptr<MarketModelPathwiseMultiProduct> clone() const override;

    private:
        std::vector<Real> rateTimes_;
        std::vector<Real> accruals_;
        std::vector<Rate> strikes_;
        Size numberRates_;
        Real multiplier_;

        // things that vary in a path
        Size currentIndex_;

        EvolutionDescription evolution_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="131">
    <source>marketmodels/products/pathwise/pathwiseproductswaption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_market_model_pathwise_swaption_hpp
#define quantlib_market_model_pathwise_swaption_hpp

#include <ql/types.hpp>
#include <ql/models/marketmodels/pathwisemultiproduct.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>
#include <vector>
#include <memory>

namespace QuantLib {

    class EvolutionDescription;
    class CurveState;

    /*!
    Main use is to test market pathwise vegas. The swaptions are payers and co-terminal.
    The class is tested in TestPathwiseVegas by running against the numerical version below.
    */
class MarketModelPathwiseCoterminalSwaptionsDeflated : public MarketModelPathwiseMultiProduct
    {
     public:

       MarketModelPathwiseCoterminalSwaptionsDeflated(
                          const std::vector<Time>& rateTimes,
                          const std::vector<Rate>& strikes);

       ~MarketModelPathwiseCoterminalSwaptionsDeflated() override = default;

       std::vector<Size> suggestedNumeraires() const override;
       const EvolutionDescription& evolution() const override;
       std::vector<Time> possibleCashFlowTimes() const override;
       Size numberOfProducts() const override;
       Size maxNumberOfCashFlowsPerProductPerStep() const override;

       // has division by the numeraire already been done?
       bool alreadyDeflated() const override;


       //! during simulation put product at start of path
       void reset() override;

       //! return value indicates whether path is finished, TRUE means done
       bool nextTimeStep(const CurveState& currentState,
                         std::vector<Size>& numberCashFlowsThisStep,
                         std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >&
                             cashFlowsGenerated) override;

        //! returns a newly-allocated copy of itself
        std::unique_ptr<MarketModelPathwiseMultiProduct> clone() const override;

    private:
        std::vector<Real> rateTimes_;
        std::vector<Rate> strikes_;
        Size numberRates_;
        // things that vary in a path
        Size currentIndex_;

        EvolutionDescription evolution_;
    };

  /*!
  Easiest way to test MarketModelPathwiseCoterminalSwaptionsDeflated is by doing a numerical differentiation version.

  */
class MarketModelPathwiseCoterminalSwaptionsNumericalDeflated : public MarketModelPathwiseMultiProduct
    {
     public:

       MarketModelPathwiseCoterminalSwaptionsNumericalDeflated(
                          const std::vector<Time>& rateTimes,
                          const std::vector<Rate>& strikes,
                          Real bumpSize_);

       ~MarketModelPathwiseCoterminalSwaptionsNumericalDeflated() override = default;

       std::vector<Size> suggestedNumeraires() const override;
       const EvolutionDescription& evolution() const override;
       std::vector<Time> possibleCashFlowTimes() const override;
       Size numberOfProducts() const override;
       Size maxNumberOfCashFlowsPerProductPerStep() const override;

       // has division by the numeraire already been done?
       bool alreadyDeflated() const override;


       //! during simulation put product at start of path
       void reset() override;

       //! return value indicates whether path is finished, TRUE means done
       bool nextTimeStep(const CurveState& currentState,
                         std::vector<Size>& numberCashFlowsThisStep,
                         std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >&
                             cashFlowsGenerated) override;

        //! returns a newly-allocated copy of itself
        std::unique_ptr<MarketModelPathwiseMultiProduct> clone() const override;

    private:
        std::vector<Real> rateTimes_;
        std::vector<Rate> strikes_;
        Size numberRates_;
        // things that vary in a path
        Size currentIndex_;

        EvolutionDescription evolution_;

        Real bumpSize_;
        LMMCurveState up_;
        LMMCurveState down_;
        std::vector<Rate> forwards_;
    };




}


#endif
]]></document_content>
  </document>
  <document index="132">
    <source>marketmodels/products/singleproductcomposite.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_single_product_composite_hpp
#define quantlib_single_product_composite_hpp

#include <ql/models/marketmodels/products/compositeproduct.hpp>

namespace QuantLib {

    //! Composition of one or more market-model products
    /*! Instances of this class build a single market-model product by
        composing two or more subproducts.

        \pre All subproducts must have the same rate times.
    */
    class SingleProductComposite : public MarketModelComposite {
      public:
        //! \name MarketModelMultiProduct interface
        //@{
        Size numberOfProducts() const override;
        Size maxNumberOfCashFlowsPerProductPerStep() const override;
        bool nextTimeStep(const CurveState& currentState,
                          std::vector<Size>& numberCashFlowsThisStep,
                          std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override;
        std::unique_ptr<MarketModelMultiProduct> clone() const override;
        //@}
    };

}


#endif
]]></document_content>
  </document>
  <document index="133">
    <source>marketmodels/proxygreekengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_proxy_greek_engine_hpp
#define quantlib_proxy_greek_engine_hpp

// to be removed using forward declaration
#include <ql/models/marketmodels/multiproduct.hpp>

#include <ql/math/statistics/sequencestatistics.hpp>
#include <ql/utilities/clone.hpp>
#include <valarray>

namespace QuantLib {

    class MarketModelEvolver;
    class ConstrainedEvolver;
    class MarketModelDiscounter;

    class ProxyGreekEngine {
      public:
        ProxyGreekEngine(
            ext::shared_ptr<MarketModelEvolver> evolver,
            std::vector<std::vector<ext::shared_ptr<ConstrainedEvolver> > > constrainedEvolvers,
            std::vector<std::vector<std::vector<Real> > > diffWeights,
            std::vector<Size> startIndexOfConstraint,
            std::vector<Size> endIndexOfConstraint,
            const Clone<MarketModelMultiProduct>& product,
            Real initialNumeraireValue);
        void multiplePathValues(
                  SequenceStatisticsInc& stats,
                  std::vector<std::vector<SequenceStatisticsInc> >& modifiedStats,
                  Size numberOfPaths);
        void singlePathValues(
                std::vector<Real>& values,
                std::vector<std::vector<std::vector<Real> > >& modifiedValues);
      private:
        void singleEvolverValues(MarketModelEvolver& evolver,
                                 std::vector<Real>& values,
                                 bool storeRates = false);
        ext::shared_ptr<MarketModelEvolver> originalEvolver_;
        std::vector<std::vector<ext::shared_ptr<ConstrainedEvolver> > >
            constrainedEvolvers_;
        std::vector<std::vector<std::vector<Real> > > diffWeights_;
        std::vector<Size> startIndexOfConstraint_;
        std::vector<Size> endIndexOfConstraint_;
        Clone<MarketModelMultiProduct> product_;

        Real initialNumeraireValue_;
        Size numberProducts_;

        // workspace
        std::vector<Rate> constraints_;
        std::valarray<bool> constraintsActive_;
        std::vector<Real> numerairesHeld_;
        std::vector<Size> numberCashFlowsThisStep_;
        std::vector<std::vector<MarketModelMultiProduct::CashFlow> >
                                                         cashFlowsGenerated_;
        std::vector<MarketModelDiscounter> discounters_;

    };

}

#endif
]]></document_content>
  </document>
  <document index="134">
    <source>marketmodels/swapforwardmappings.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006, 2008 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file swapforwardmappings.hpp
    \brief Utility functions for mapping between swap rate and forward rate
*/

#ifndef quantlib_swap_forward_mappings_hpp
#define quantlib_swap_forward_mappings_hpp

#include <ql/math/matrix.hpp>

namespace QuantLib {

    class CurveState;
    class MarketModel;

    class SwapForwardMappings {
      public:

        //! compute annuity of arbitrary swap-rate
        static Real annuity(const CurveState& cs,
                            Size startIndex,
                            Size endIndex,
                            Size numeraireIndex);

        //! compute derivative of swap-rate to underlying forward rate
        static Real swapDerivative(const CurveState& cs,
                                   Size startIndex,
                                   Size endIndex,
                                   Size forwardIndex);

        /*! Returns the dsr[i]/df[j] jacobian between
            coterminal swap rates and forward rates */
        static Matrix coterminalSwapForwardJacobian(const CurveState& cs);

        /*! Returns the Z matrix to switch base from forward to
            coterminal swap rates */
        static Matrix coterminalSwapZedMatrix(const CurveState& cs, Spread displacement);

        /*! Returns the dsr[i]/df[j] jacobian between
            coinitial swap rates and forward rates */
        static Matrix coinitialSwapForwardJacobian(const CurveState& cs);

        /*! Returns the Z matrix to switch base from forward to
            coinitial swap rates */
        static Matrix coinitialSwapZedMatrix(const CurveState& cs, Spread displacement);


        /*! Returns the dsr[i]/df[j] jacobian between
            constant maturity swap rates and forward rates */
        static Matrix cmSwapForwardJacobian(const CurveState& cs,
                                            Size spanningForwards);

        /*! Returns the Z matrix to switch base from forward to
            constant maturity swap rates */
        static Matrix cmSwapZedMatrix(const CurveState& cs, Size spanningForwards, Spread displacement);

        /*! computes the implied vol of a swaption specified by two indices
        using the freezing coefficients methdodology. This routine is easy to use but not very efficient
        and if you want to do a lot of cases, then a different approach should be used. 

        Tested in SwapForwardMappingsTest::testSwaptionImpliedVolatility() in swapforwardmappings.cpp
        */
        static Real 
        swaptionImpliedVolatility(const MarketModel& volStructure,
                                  Size startIndex,
                                  Size endIndex);

    };

}

#endif
]]></document_content>
  </document>
  <document index="135">
    <source>marketmodels/utilities.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_market_model_utilities_hpp
#define quantlib_market_model_utilities_hpp

#include <ql/types.hpp>
#include <vector>
#include <valarray>

namespace QuantLib {

    void mergeTimes(const std::vector<std::vector<Time> >& times,
                    std::vector<Time>& mergedTimes,
                    std::vector<std::valarray<bool> >& isPresent);

    /*! Look for elements of a set in a subset.
        Returns a vector of booleans such that:
        element set[i] present/not present in subset.

       \pre both vectors must be strictly increasing.
    */
    std::valarray<bool> isInSubset(const std::vector<Time>& set,
                                 const std::vector<Time>& subset);

    //! check for strictly increasing times, first time greater than zero
    void checkIncreasingTimes(const std::vector<Time>& times);
    void checkIncreasingTimesAndCalculateTaus(const std::vector<Time>& times,
                                              std::vector<Time>& taus);
}

#endif
]]></document_content>
  </document>
  <document index="136">
    <source>model.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2005, 2007 StatPro Italia srl
 Copyright (C) 2013, 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file model.hpp
    \brief Abstract interest rate model class
*/

#ifndef quantlib_interest_rate_model_hpp
#define quantlib_interest_rate_model_hpp

#include <ql/math/optimization/endcriteria.hpp>
#include <ql/methods/lattices/lattice.hpp>
#include <ql/models/calibrationhelper.hpp>
#include <ql/models/parameter.hpp>
#include <ql/option.hpp>
#include <utility>

namespace QuantLib {

    class OptimizationMethod;

    //! Affine model class
    /*! Base class for analytically tractable models.

        \ingroup shortrate
    */
    class AffineModel : public virtual Observable {
      public:
        //! Implied discount curve
        virtual DiscountFactor discount(Time t) const = 0;

        virtual Real discountBond(Time now,
                                  Time maturity,
                                  Array factors) const = 0;

        virtual Real discountBondOption(Option::Type type,
                                        Real strike,
                                        Time maturity,
                                        Time bondMaturity) const = 0;

        virtual Real discountBondOption(Option::Type type,
                                        Real strike,
                                        Time maturity,
                                        Time bondStart,
                                        Time bondMaturity) const;
    };


    //! Term-structure consistent model class
    /*! This is a base class for models that can reprice exactly
        any discount bond.

        \ingroup shortrate
    */
    class TermStructureConsistentModel : public virtual Observable {
      public:
        TermStructureConsistentModel(Handle<YieldTermStructure> termStructure)
        : termStructure_(std::move(termStructure)) {}
        const Handle<YieldTermStructure>& termStructure() const {
            return termStructure_;
        }
      private:
        Handle<YieldTermStructure> termStructure_;
    };


    //! Calibrated model class
    class CalibratedModel : public virtual Observer, public virtual Observable {
      public:
        CalibratedModel(Size nArguments);

        void update() override {
            generateArguments();
            notifyObservers();
        }

        //! Calibrate to a set of market instruments (usually caps/swaptions)
        /*! An additional constraint can be passed which must be
            satisfied in addition to the constraints of the model.
        */
        virtual void calibrate(
                const std::vector<ext::shared_ptr<CalibrationHelper> >&,
                OptimizationMethod& method,
                const EndCriteria& endCriteria,
                const Constraint& constraint = Constraint(),
                const std::vector<Real>& weights = std::vector<Real>(),
                const std::vector<bool>& fixParameters = std::vector<bool>());

        Real value(const Array& params,
                   const std::vector<ext::shared_ptr<CalibrationHelper> >&);

        const ext::shared_ptr<Constraint>& constraint() const;

        //! Returns end criteria result
        EndCriteria::Type endCriteria() const { return shortRateEndCriteria_; }

        //! Returns the problem values
        const Array& problemValues() const { return problemValues_; }

        //! Returns array of arguments on which calibration is done
        Array params() const;

        virtual void setParams(const Array& params);
        Integer functionEvaluation() const { return functionEvaluation_; }

      protected:
        virtual void generateArguments() {}
        std::vector<Parameter> arguments_;
        ext::shared_ptr<Constraint> constraint_;
        EndCriteria::Type shortRateEndCriteria_ = EndCriteria::None;
        Array problemValues_;
        Integer functionEvaluation_;

      private:
        //! Constraint imposed on arguments
        class PrivateConstraint;
        //! Calibration cost function class
        class CalibrationFunction;
    };

    //! Abstract short-rate model class
    /*! \ingroup shortrate */
    class ShortRateModel : public CalibratedModel {
      public:
        explicit ShortRateModel(Size nArguments);
        virtual ext::shared_ptr<Lattice> tree(const TimeGrid&) const = 0;
    };


    // inline definitions


    inline Real AffineModel::discountBondOption(Option::Type type,
                                                Real strike,
                                                Time maturity,
                                                Time,
                                                Time bondMaturity) const {
        return discountBondOption(type, strike, maturity, bondMaturity);
    }

    inline const ext::shared_ptr<Constraint>&
    CalibratedModel::constraint() const {
        return constraint_;
    }

    class CalibratedModel::PrivateConstraint : public Constraint {
      private:
        class Impl final : public Constraint::Impl {
          public:
            explicit Impl(const std::vector<Parameter>& arguments)
            : arguments_(arguments) {}

            bool test(const Array& params) const override {
                Size k=0;
                for (const auto& argument : arguments_) {
                    Size size = argument.size();
                    Array testParams(size);
                    for (Size j=0; j<size; j++, k++)
                        testParams[j] = params[k];
                    if (!argument.testParams(testParams))
                        return false;
                }
                return true;
            }

            Array upperBound(const Array& params) const override {
                Size k = 0, k2 = 0;
                Size totalSize = 0;
                for (const auto& argument : arguments_) {
                    totalSize += argument.size();
                }
                Array result(totalSize);
                for (const auto& argument : arguments_) {
                    Size size = argument.size();
                    Array partialParams(size);
                    for (Size j = 0; j < size; j++, k++)
                        partialParams[j] = params[k];
                    Array tmpBound = argument.constraint().upperBound(partialParams);
                    for (Size j = 0; j < size; j++, k2++)
                        result[k2] = tmpBound[j];
                }
                return result;
            }

            Array lowerBound(const Array& params) const override {
                Size k = 0, k2 = 0;
                Size totalSize = 0;
                for (const auto& argument : arguments_) {
                    totalSize += argument.size();
                }
                Array result(totalSize);
                for (const auto& argument : arguments_) {
                    Size size = argument.size();
                    Array partialParams(size);
                    for (Size j = 0; j < size; j++, k++)
                        partialParams[j] = params[k];
                    Array tmpBound = argument.constraint().lowerBound(partialParams);
                    for (Size j = 0; j < size; j++, k2++)
                        result[k2] = tmpBound[j];
                }
                return result;
            }

          private:
            const std::vector<Parameter>& arguments_;
        };
      public:
        explicit PrivateConstraint(const std::vector<Parameter>& arguments)
        : Constraint(ext::shared_ptr<Constraint::Impl>(
                                   new PrivateConstraint::Impl(arguments))) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="137">
    <source>parameter.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file parameter.hpp
    \brief Model parameter classes
*/

#ifndef quantlib_interest_rate_modelling_parameter_hpp
#define quantlib_interest_rate_modelling_parameter_hpp

#include <ql/handle.hpp>
#include <ql/math/optimization/constraint.hpp>
#include <ql/qldefines.hpp>
#include <utility>
#include <vector>

namespace QuantLib {

    class YieldTermStructure;

    //! Base class for model arguments
    class Parameter {
      protected:
        //! Base class for model parameter implementation
        class Impl {
          public:
            virtual ~Impl() = default;
            virtual Real value(const Array& params, Time t) const = 0;
        };
        ext::shared_ptr<Impl> impl_;
      public:
        Parameter()
        : constraint_(NoConstraint()) {}
        const Array& params() const { return params_; }
        void setParam(Size i, Real x) { params_[i] = x; }
        bool testParams(const Array& params) const {
            return constraint_.test(params);
        }
        Size size() const { return params_.size(); }
        Real operator()(Time t) const {
            return impl_->value(params_, t);
        }
        const ext::shared_ptr<Impl>& implementation() const {
            return impl_;
        }
        const Constraint& constraint() const { return constraint_; }
      protected:
        Parameter(Size size, ext::shared_ptr<Impl> impl, Constraint constraint)
        : impl_(std::move(impl)), params_(size), constraint_(std::move(constraint)) {}
        Array params_;
        Constraint constraint_;
    };

    //! Standard constant parameter \f$ a(t) = a \f$
    class ConstantParameter : public Parameter {
      private:
        class Impl final : public Parameter::Impl {
          public:
            Real value(const Array& params, Time) const override { return params[0]; }
        };
      public:
        ConstantParameter(const Constraint& constraint)
        : Parameter(
              1,
              ext::shared_ptr<Parameter::Impl>(new ConstantParameter::Impl),
              constraint)
        {}

        ConstantParameter(Real value,
                          const Constraint& constraint)
        : Parameter(
              1,
              ext::shared_ptr<Parameter::Impl>(new ConstantParameter::Impl),
              constraint) {
            params_[0] = value;
            QL_REQUIRE(testParams(params_),
                       value << ": invalid value");
        }

    };

    //! %Parameter which is always zero \f$ a(t) = 0 \f$
    class NullParameter : public Parameter {
      private:
        class Impl final : public Parameter::Impl {
          public:
            Real value(const Array&, Time) const override { return 0.0; }
        };
      public:
        NullParameter()
        : Parameter(
                  0,
                  ext::shared_ptr<Parameter::Impl>(new NullParameter::Impl),
                  NoConstraint())
        {}
    };

    //! Piecewise-constant parameter
    /*! \f$ a(t) = a_i if t_{i-1} \geq t < t_i \f$.
        This kind of parameter is usually used to enhance the fitting of a
        model
    */
    class PiecewiseConstantParameter : public Parameter {
      private:
        class Impl final : public Parameter::Impl {
          public:
            explicit Impl(std::vector<Time> times) : times_(std::move(times)) {}

            Real value(const Array& params, Time t) const override {
                Size i = std::upper_bound(times_.begin(), times_.end(), t) - times_.begin();
                return params[i];
            }

          private:
            std::vector<Time> times_;
        };
      public:
        PiecewiseConstantParameter(const std::vector<Time>& times,
                                   const Constraint& constraint =
                                                             NoConstraint())
        : Parameter(times.size()+1,
                    ext::shared_ptr<Parameter::Impl>(
                                 new PiecewiseConstantParameter::Impl(times)),
                    constraint)
        {}
    };

    //! Deterministic time-dependent parameter used for yield-curve fitting
    class TermStructureFittingParameter : public Parameter {
      public:
        class NumericalImpl : public Parameter::Impl {
          public:
            NumericalImpl(Handle<YieldTermStructure> termStructure)
            : times_(0), values_(0), termStructure_(std::move(termStructure)) {}

            void set(Time t, Real x) {
                times_.push_back(t);
                values_.push_back(x);
            }
            void change(Real x) {
                values_.back() = x;
            }
            void reset() {
                times_.clear();
                values_.clear();
            }
            Real value(const Array&, Time t) const override {
                auto result = std::find(times_.begin(), times_.end(), t);
                QL_REQUIRE(result!=times_.end(),
                           "fitting parameter not set!");
                return values_[result - times_.begin()];
            }
            const Handle<YieldTermStructure>& termStructure() const {
                return termStructure_;
            }
          private:
            std::vector<Time> times_;
            std::vector<Real> values_;
            Handle<YieldTermStructure> termStructure_;
        };

        TermStructureFittingParameter(
                               const ext::shared_ptr<Parameter::Impl>& impl)
        : Parameter(0, impl, NoConstraint()) {}

        TermStructureFittingParameter(const Handle<YieldTermStructure>& term)
        : Parameter(
                  0,
                  ext::shared_ptr<Parameter::Impl>(new NumericalImpl(term)),
                  NoConstraint())
        {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="138">
    <source>shortrate/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/shortrate/onefactormodel.hpp>
#include <ql/models/shortrate/twofactormodel.hpp>

#include <ql/models/shortrate/calibrationhelpers/all.hpp>
#include <ql/models/shortrate/onefactormodels/all.hpp>
#include <ql/models/shortrate/twofactormodels/all.hpp>
]]></document_content>
  </document>
  <document index="139">
    <source>shortrate/calibrationhelpers/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/shortrate/calibrationhelpers/caphelper.hpp>
#include <ql/models/shortrate/calibrationhelpers/swaptionhelper.hpp>

]]></document_content>
  </document>
  <document index="140">
    <source>shortrate/calibrationhelpers/caphelper.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file caphelper.hpp
    \brief CapHelper calibration helper
*/

#ifndef quantlib_cap_calibration_helper_hpp
#define quantlib_cap_calibration_helper_hpp

#include <ql/models/calibrationhelper.hpp>
#include <ql/instruments/capfloor.hpp>
#include <ql/termstructures/volatility/volatilitytype.hpp>

namespace QuantLib {

    //! calibration helper for ATM cap

    class CapHelper : public BlackCalibrationHelper {
      public:
        CapHelper(const Period& length,
                  const Handle<Quote>& volatility,
                  ext::shared_ptr<IborIndex> index,
                  // data for ATM swap-rate calculation
                  Frequency fixedLegFrequency,
                  DayCounter fixedLegDayCounter,
                  bool includeFirstSwaplet,
                  Handle<YieldTermStructure> termStructure,
                  BlackCalibrationHelper::CalibrationErrorType errorType =
                      BlackCalibrationHelper::RelativePriceError,
                  VolatilityType type = ShiftedLognormal,
                  Real shift = 0.0);
        void addTimesTo(std::list<Time>& times) const override;
        Real modelValue() const override;
        Real blackPrice(Volatility volatility) const override;

      private:
        void performCalculations() const override;
        mutable ext::shared_ptr<Cap> cap_;
        const Period length_;
        const ext::shared_ptr<IborIndex> index_;
        const Handle<YieldTermStructure> termStructure_;
        const Frequency fixedLegFrequency_;
        const DayCounter fixedLegDayCounter_;
        const bool includeFirstSwaplet_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="141">
    <source>shortrate/calibrationhelpers/swaptionhelper.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file swaptionhelper.hpp
    \brief Swaption calibration helper
*/

#ifndef quantlib_swaption_calibration_helper_hpp
#define quantlib_swaption_calibration_helper_hpp

#include <ql/models/calibrationhelper.hpp>
#include <ql/instruments/swaption.hpp>
#include <ql/termstructures/volatility/volatilitytype.hpp>
#include <ql/cashflows/rateaveraging.hpp>

namespace QuantLib {

    //! calibration helper for interest-rate swaptions
    /*! \warning passing an overnight index to the constructor will
                 result in an overnight-indexed swap being built, but
                 model-based engines will treat it as a vanilla swap.
                 This is at best a decent proxy, at worst simply wrong.
                 Use with caution.
    */
    class SwaptionHelper : public BlackCalibrationHelper {
      public:
        SwaptionHelper(const Period& maturity,
                       const Period& length,
                       const Handle<Quote>& volatility,
                       ext::shared_ptr<IborIndex> index,
                       const Period& fixedLegTenor,
                       DayCounter fixedLegDayCounter,
                       DayCounter floatingLegDayCounter,
                       Handle<YieldTermStructure> termStructure,
                       CalibrationErrorType errorType = RelativePriceError,
                       Real strike = Null<Real>(),
                       Real nominal = 1.0,
                       VolatilityType type = ShiftedLognormal,
                       Real shift = 0.0,
                       Natural settlementDays = Null<Size>(),
                       RateAveraging::Type averagingMethod = RateAveraging::Compound);

        SwaptionHelper(const Date& exerciseDate,
                       const Period& length,
                       const Handle<Quote>& volatility,
                       ext::shared_ptr<IborIndex> index,
                       const Period& fixedLegTenor,
                       DayCounter fixedLegDayCounter,
                       DayCounter floatingLegDayCounter,
                       Handle<YieldTermStructure> termStructure,
                       CalibrationErrorType errorType = RelativePriceError,
                       Real strike = Null<Real>(),
                       Real nominal = 1.0,
                       VolatilityType type = ShiftedLognormal,
                       Real shift = 0.0,
                       Natural settlementDays = Null<Size>(),
                       RateAveraging::Type averagingMethod = RateAveraging::Compound);

        SwaptionHelper(const Date& exerciseDate,
                       const Date& endDate,
                       const Handle<Quote>& volatility,
                       ext::shared_ptr<IborIndex> index,
                       const Period& fixedLegTenor,
                       DayCounter fixedLegDayCounter,
                       DayCounter floatingLegDayCounter,
                       Handle<YieldTermStructure> termStructure,
                       CalibrationErrorType errorType = RelativePriceError,
                       Real strike = Null<Real>(),
                       Real nominal = 1.0,
                       VolatilityType type = ShiftedLognormal,
                       Real shift = 0.0,
                       Natural settlementDays = Null<Size>(),
                       RateAveraging::Type averagingMethod = RateAveraging::Compound);

        void addTimesTo(std::list<Time>& times) const override;
        Real modelValue() const override;
        Real blackPrice(Volatility volatility) const override;

        const ext::shared_ptr<FixedVsFloatingSwap>& underlying() const {
            calculate();
            return swap_;
        }
        ext::shared_ptr<Swaption> swaption() const { calculate(); return swaption_; }

      private:
        void performCalculations() const override;
        ext::shared_ptr<FixedVsFloatingSwap> makeSwap(Schedule fixedSchedule,
                                                      Schedule floatSchedule,
                                                      Rate exerciseRate,
                                                      Swap::Type type) const;
        mutable Date exerciseDate_, endDate_;
        const Period maturity_, length_, fixedLegTenor_;
        const ext::shared_ptr<IborIndex> index_;
        const Handle<YieldTermStructure> termStructure_;
        const DayCounter fixedLegDayCounter_, floatingLegDayCounter_;
        const Real strike_, nominal_;
        const Natural settlementDays_;
        const RateAveraging::Type averagingMethod_;
        mutable Rate exerciseRate_;
        mutable ext::shared_ptr<FixedVsFloatingSwap> swap_;
        mutable ext::shared_ptr<Swaption> swaption_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="142">
    <source>shortrate/onefactormodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file onefactormodel.hpp
    \brief Abstract one-factor interest rate model class
*/

#ifndef quantlib_one_factor_model_hpp
#define quantlib_one_factor_model_hpp

#include <ql/methods/lattices/lattice1d.hpp>
#include <ql/methods/lattices/trinomialtree.hpp>
#include <ql/models/model.hpp>
#include <utility>

namespace QuantLib {
    class StochasticProcess1D;

    //! Single-factor short-rate model abstract class
    /*! \ingroup shortrate */
    class OneFactorModel : public ShortRateModel {
      public:
        explicit OneFactorModel(Size nArguments);
        ~OneFactorModel() override = default;

        class ShortRateDynamics;
        class ShortRateTree;

        //! returns the short-rate dynamics
        virtual ext::shared_ptr<ShortRateDynamics> dynamics() const = 0;

        //! Return by default a trinomial recombining tree
        ext::shared_ptr<Lattice> tree(const TimeGrid& grid) const override;
    };

    //! Base class describing the short-rate dynamics
    class OneFactorModel::ShortRateDynamics {
      public:
        explicit ShortRateDynamics(ext::shared_ptr<StochasticProcess1D> process)
        : process_(std::move(process)) {}
        virtual ~ShortRateDynamics() = default;

        //! Compute state variable from short rate
        virtual Real variable(Time t, Rate r) const = 0;

        //! Compute short rate from state variable
        virtual Rate shortRate(Time t, Real variable) const = 0;

        //! Returns the risk-neutral dynamics of the state variable
        const ext::shared_ptr<StochasticProcess1D>& process() {
            return process_;
        }
      private:
        ext::shared_ptr<StochasticProcess1D> process_;
    };

    //! Recombining trinomial tree discretizing the state variable
    class OneFactorModel::ShortRateTree
        : public TreeLattice1D<OneFactorModel::ShortRateTree> {
      public:
        //! Plain tree build-up from short-rate dynamics
        ShortRateTree(const ext::shared_ptr<TrinomialTree>& tree,
                      ext::shared_ptr<ShortRateDynamics> dynamics,
                      const TimeGrid& timeGrid);
        //! Tree build-up + numerical fitting to term-structure
        ShortRateTree(const ext::shared_ptr<TrinomialTree>& tree,
                      ext::shared_ptr<ShortRateDynamics> dynamics,
                      const ext::shared_ptr<TermStructureFittingParameter::NumericalImpl>& phi,
                      const TimeGrid& timeGrid);

        Size size(Size i) const {
            return tree_->size(i);
        }
        DiscountFactor discount(Size i, Size index) const {
            Real x = tree_->underlying(i, index);
            Rate r = dynamics_->shortRate(timeGrid()[i], x) +spread_;
            return std::exp(-r*timeGrid().dt(i));
        }
        Real underlying(Size i, Size index) const {
            return tree_->underlying(i, index);
        }
        Size descendant(Size i, Size index, Size branch) const {
            return tree_->descendant(i, index, branch);
        }
        Real probability(Size i, Size index, Size branch) const {
            return tree_->probability(i, index, branch);
        }
        void setSpread(Spread spread)
        {
            spread_=spread;
        }
      private:
        ext::shared_ptr<TrinomialTree> tree_;
        ext::shared_ptr<ShortRateDynamics> dynamics_;
        class Helper;
        Spread spread_;
    };

    //! Single-factor affine base class
    /*! Single-factor models with an analytical formula for discount bonds
        should inherit from this class. They must then implement the
        functions \f$ A(t,T) \f$ and \f$ B(t,T) \f$ such that
        \f[
            P(t, T, r_t) = A(t,T)e^{ -B(t,T) r_t}.
        \f]

        \ingroup shortrate
    */
    class OneFactorAffineModel : public OneFactorModel,
                                 public AffineModel {
      public:
        explicit OneFactorAffineModel(Size nArguments)
        : OneFactorModel(nArguments) {}

        Real discountBond(Time now, Time maturity, Array factors) const override {
            return discountBond(now, maturity, factors[0]);
        }

        Real discountBond(Time now, Time maturity, Rate rate) const {
            return A(now, maturity)*std::exp(-B(now, maturity)*rate);
        }

        DiscountFactor discount(Time t) const override;

      protected:
        virtual Real A(Time t, Time T) const = 0;
        virtual Real B(Time t, Time T) const = 0;
    };

}

#endif

]]></document_content>
  </document>
  <document index="143">
    <source>shortrate/onefactormodels/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/shortrate/onefactormodels/blackkarasinski.hpp>
#include <ql/models/shortrate/onefactormodels/coxingersollross.hpp>
#include <ql/models/shortrate/onefactormodels/extendedcoxingersollross.hpp>
#include <ql/models/shortrate/onefactormodels/gaussian1dmodel.hpp>
#include <ql/models/shortrate/onefactormodels/gsr.hpp>
#include <ql/models/shortrate/onefactormodels/hullwhite.hpp>
#include <ql/models/shortrate/onefactormodels/markovfunctional.hpp>
#include <ql/models/shortrate/onefactormodels/vasicek.hpp>

]]></document_content>
  </document>
  <document index="144">
    <source>shortrate/onefactormodels/blackkarasinski.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file blackkarasinski.hpp
    \brief Black-Karasinski model
*/

#ifndef quantlib_black_karasinski_hpp
#define quantlib_black_karasinski_hpp

#include <ql/models/shortrate/onefactormodel.hpp>
#include <ql/processes/ornsteinuhlenbeckprocess.hpp>
#include <utility>

namespace QuantLib {

    //! Standard Black-Karasinski model class.
    /*! This class implements the standard Black-Karasinski model defined by
        \f[
            d\ln r_t = (\theta(t) - \alpha \ln r_t)dt + \sigma dW_t,
        \f]
        where \f$ alpha \f$ and \f$ sigma \f$ are constants.

        \ingroup shortrate
    */
    class BlackKarasinski : public OneFactorModel,
                            public TermStructureConsistentModel {
      public:
        BlackKarasinski(const Handle<YieldTermStructure>& termStructure,
                        Real a = 0.1, Real sigma = 0.1);

        ext::shared_ptr<ShortRateDynamics> dynamics() const override;

        ext::shared_ptr<Lattice> tree(const TimeGrid& grid) const override;

      private:
        class Dynamics;
        class Helper;

        Real a() const { return a_(0.0); }
        Real sigma() const { return sigma_(0.0); }

        Parameter& a_;
        Parameter& sigma_;
        Parameter phi_;
    };

    //! Short-rate dynamics in the Black-Karasinski model
    /*! The short-rate is here
        \f[
            r_t = e^{\varphi(t) + x_t}
         \f]
         where \f$ \varphi(t) \f$ is the deterministic time-dependent
         parameter (which can not be determined analytically)
         used for term-structure fitting and \f$ x_t \f$ is the state
         variable following an Ornstein-Uhlenbeck process.
    */
    class BlackKarasinski::Dynamics
        : public BlackKarasinski::ShortRateDynamics {
      public:
        Dynamics(Parameter fitting, Real alpha, Real sigma)
        : ShortRateDynamics(
              ext::shared_ptr<StochasticProcess1D>(new OrnsteinUhlenbeckProcess(alpha, sigma))),
          fitting_(std::move(fitting)) {}

        Real variable(Time t, Rate r) const override { return std::log(r) - fitting_(t); }

        Real shortRate(Time t, Real x) const override { return std::exp(x + fitting_(t)); }

      private:
        Parameter fitting_;
    };

}

#endif

]]></document_content>
  </document>
  <document index="145">
    <source>shortrate/onefactormodels/coxingersollross.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2021 Magnus Mencke

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file coxingersollross.hpp
    \brief Cox-Ingersoll-Ross model
*/

#ifndef quantlib_cox_ingersoll_ross_hpp
#define quantlib_cox_ingersoll_ross_hpp

#include <ql/models/shortrate/onefactormodel.hpp>
#include <ql/processes/coxingersollrossprocess.hpp>

namespace QuantLib {

    //! Cox-Ingersoll-Ross model class.
    /*! This class implements the Cox-Ingersoll-Ross model defined by
        \f[
            dr(t) = k(\theta - r(t))dt + \sigma \sqrt{r(t)} dW(t)
        \f]

        \bug this class was not tested enough to guarantee
             its functionality.

        \ingroup shortrate
    */
    class CoxIngersollRoss : public OneFactorAffineModel {
      public:
        CoxIngersollRoss(Rate r0 = 0.05,
                         Real theta = 0.1,
                         Real k = 0.1,
                         Real sigma = 0.1,
                         bool withFellerConstraint = true);

        Real discountBondOption(Option::Type type,
                                Real strike,
                                Time maturity,
                                Time bondMaturity) const override;

        ext::shared_ptr<ShortRateDynamics> dynamics() const override;

        ext::shared_ptr<Lattice> tree(const TimeGrid& grid) const override;


        class Dynamics;
      protected:
        Real A(Time t, Time T) const override;
        Real B(Time t, Time T) const override;

        Real theta() const { return theta_(0.0); }
        Real k() const { return k_(0.0); }
        Real sigma() const { return sigma_(0.0); }
        Real x0() const { return r0_(0.0); }

      private:
        class VolatilityConstraint;

        Parameter& theta_;
        Parameter& k_;
        Parameter& sigma_;
        Parameter& r0_;
    };

    //! %Dynamics of the short-rate under the Cox-Ingersoll-Ross model
    /*! The short-rate is simulated directly using the Quadratic Exponential
        discretization scheme as described in Leif Andersen,
        Efficient Simulation of the Heston Stochastic Volatility Model.
    */
    class CoxIngersollRoss::Dynamics :
        public OneFactorModel::ShortRateDynamics {
      public:
        Dynamics(Real theta,
                 Real k,
                 Real sigma,
                 Real x0)
        : ShortRateDynamics(ext::shared_ptr<StochasticProcess1D>(
                        new CoxIngersollRossProcess(k, sigma, x0, theta))) {}

        Real variable(Time, Rate r) const override { return r; }
        Real shortRate(Time, Real y) const override { return y; }
    };

}


#endif
]]></document_content>
  </document>
  <document index="146">
    <source>shortrate/onefactormodels/extendedcoxingersollross.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2021 Magnus Mencke

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file extendedcoxingersollross.hpp
    \brief Extended Cox-Ingersoll-Ross model
*/

#ifndef quantlib_extended_cox_ingersoll_ross_hpp
#define quantlib_extended_cox_ingersoll_ross_hpp

#include <ql/models/shortrate/onefactormodels/coxingersollross.hpp>
#include <utility>

namespace QuantLib {

    //! Extended Cox-Ingersoll-Ross model class.
    /*! This class implements the extended Cox-Ingersoll-Ross model
        defined by
        \f[
            r(t) = \varphi(t)+y(t)
        \f]
        where \f$ \varphi(t) \f$ is the deterministic time-dependent
        parameter used for term-structure fitting and \f$ y_t \f$ is a standard CIR process.

        \bug this class was not tested enough to guarantee
             its functionality.

        \ingroup shortrate
    */
    class ExtendedCoxIngersollRoss : public CoxIngersollRoss,
                                     public TermStructureConsistentModel {
      public:
        ExtendedCoxIngersollRoss(
                              const Handle<YieldTermStructure>& termStructure,
                              Real theta = 0.1,
                              Real k = 0.1,
                              Real sigma = 0.1,
                              Real x0 = 0.05,
                              bool withFellerConstraint = true);

        ext::shared_ptr<Lattice> tree(const TimeGrid& grid) const override;

        ext::shared_ptr<ShortRateDynamics> dynamics() const override;

        Real discountBondOption(Option::Type type,
                                Real strike,
                                Time maturity,
                                Time bondMaturity) const override;

      protected:
        void generateArguments() override;
        Real A(Time t, Time T) const override;

      private:
        class Dynamics;
        class FittingParameter;

        Parameter phi_;
    };

    //! Short-rate dynamics in the extended Cox-Ingersoll-Ross model
    /*! The short-rate is here
        \f[
            r(t) = \varphi(t) + y(t)
        \f]
        where \f$ \varphi(t) \f$ is the deterministic time-dependent
        parameter used for term-structure fitting and \f$ y_t \f$ is a standard CIR process
        with dynamics
        \f[
            dy(t)=k(\theta-y(t))dt+\sigma \sqrt{y(t)}dW(t)
        \f]
    */
    class ExtendedCoxIngersollRoss::Dynamics
        : public CoxIngersollRoss::Dynamics {
      public:
        Dynamics(Parameter phi, Real theta, Real k, Real sigma, Real x0)
        : CoxIngersollRoss::Dynamics(theta, k, sigma, x0), phi_(std::move(phi)) {}

        Real variable(Time t, Rate r) const override { return r - phi_(t); }
        Real shortRate(Time t, Real y) const override { return y + phi_(t); }

      private:
        Parameter phi_;
    };

    //! Analytical term-structure fitting parameter \f$ \varphi(t) \f$.
    /*! \f$ \varphi(t) \f$ is analytically defined by
        \f[
            \varphi(t) = f(t) -
                         \frac{2k\theta(e^{th}-1)}{2h+(k+h)(e^{th}-1)} -
                         \frac{4 x_0 h^2 e^{th}}{(2h+(k+h)(e^{th}-1))^1},
        \f]
        where \f$ f(t) \f$ is the instantaneous forward rate at \f$ t \f$
        and \f$ h = \sqrt{k^2 + 2\sigma^2} \f$.
    */
    class ExtendedCoxIngersollRoss::FittingParameter
        : public TermStructureFittingParameter {
      private:
        class Impl final : public Parameter::Impl {
          public:
            Impl(Handle<YieldTermStructure> termStructure, Real theta, Real k, Real sigma, Real x0)
            : termStructure_(std::move(termStructure)), theta_(theta), k_(k), sigma_(sigma),
              x0_(x0) {}

            Real value(const Array&, Time t) const override {
                Rate forwardRate =
                    termStructure_->forwardRate(t, t, Continuous, NoFrequency);
                Real h = std::sqrt(k_*k_ + 2.0*sigma_*sigma_);
                Real expth = std::exp(t*h);
                Real temp = 2.0*h + (k_+h)*(expth-1.0);
                Real phi = forwardRate -
                    2.0*k_*theta_*(expth - 1.0)/temp -
                    x0_*4.0*h*h*expth/(temp*temp);
                return phi;
            }

          private:
            Handle<YieldTermStructure> termStructure_;
            Real theta_, k_, sigma_, x0_;
        };
      public:
        FittingParameter(const Handle<YieldTermStructure>& termStructure,
                         Real theta, Real k, Real sigma, Real x0)
        : TermStructureFittingParameter(ext::shared_ptr<Parameter::Impl>(
                 new FittingParameter::Impl(
                                     termStructure, theta, k, sigma, x0))) {}
    };

    // inline definitions

    inline ext::shared_ptr<OneFactorModel::ShortRateDynamics>
    ExtendedCoxIngersollRoss::dynamics() const {
        return ext::shared_ptr<ShortRateDynamics>(
                            new Dynamics(phi_, theta(), k() , sigma(), x0()));
    }

    inline void ExtendedCoxIngersollRoss::generateArguments() {
        phi_ = FittingParameter(termStructure(), theta(), k(), sigma(), x0());
    }

}


#endif
]]></document_content>
  </document>
  <document index="147">
    <source>shortrate/onefactormodels/gaussian1dmodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gaussian1dmodel.hpp
    \brief basic interface for one factor interest rate models
*/

// uncomment to enable NTL support (see below for more details and references)
// #define GAUSS1D_ENABLE_NTL

#ifndef quantlib_gaussian1dmodel_hpp
#define quantlib_gaussian1dmodel_hpp

#include <ql/models/model.hpp>
#include <ql/models/parameter.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/instruments/vanillaswap.hpp>
#include <ql/time/date.hpp>
#include <ql/time/period.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/stochasticprocess.hpp>
#include <ql/utilities/null.hpp>
#include <ql/patterns/lazyobject.hpp>

#ifdef GAUSS1D_ENABLE_NTL
#include <boost/math/bindings/rr.hpp>
#endif

#if BOOST_VERSION < 106700
#include <boost/functional/hash.hpp>
#else
#include <boost/container_hash/hash.hpp>
#endif

#include <unordered_map>

namespace QuantLib {

/*! One factor interest rate model interface class
    The only methods that must be implemented by subclasses
    are the numeraire and zerobond methods for an input array
    of state variable values. The variable $y$ is understood
    to be the standardized (zero mean, unit variance) version
    of the model's original state variable $x$.

    NTL support may be enabled by defining GAUSS1D_ENABLE_NTL in this
    file. For details on NTL see
             http://www.shoup.net/ntl/

    \warning the variance of the state process conditional on
    $x(t)=x$ must be independent of the value of $x$

*/

class Gaussian1dModel : public TermStructureConsistentModel, public LazyObject {
  public:
    ext::shared_ptr<StochasticProcess1D> stateProcess() const;

    Real numeraire(Time t,
                   Real y = 0.0,
                   const Handle<YieldTermStructure>& yts = Handle<YieldTermStructure>()) const;

    Real zerobond(Time T,
                  Time t = 0.0,
                  Real y = 0.0,
                  const Handle<YieldTermStructure>& yts = Handle<YieldTermStructure>()) const;

    Real numeraire(const Date& referenceDate,
                   Real y = 0.0,
                   const Handle<YieldTermStructure>& yts = Handle<YieldTermStructure>()) const;

    Real zerobond(const Date& maturity,
                  const Date& referenceDate = Date(),
                  Real y = 0.0,
                  const Handle<YieldTermStructure>& yts = Handle<YieldTermStructure>()) const;

    Real zerobondOption(const Option::Type& type,
                        const Date& expiry,
                        const Date& valueDate,
                        const Date& maturity,
                        Rate strike,
                        const Date& referenceDate = Date(),
                        Real y = 0.0,
                        const Handle<YieldTermStructure>& yts = Handle<YieldTermStructure>(),
                        Real yStdDevs = 7.0,
                        Size yGridPoints = 64,
                        bool extrapolatePayoff = true,
                        bool flatPayoffExtrapolation = false) const;

    Real
    forwardRate(const Date& fixing,
                const Date& referenceDate = Date(),
                Real y = 0.0,
                const ext::shared_ptr<IborIndex>& iborIdx = ext::shared_ptr<IborIndex>()) const;

    Real swapRate(const Date& fixing,
                  const Period& tenor,
                  const Date& referenceDate = Date(),
                  Real y = 0.0,
                  const ext::shared_ptr<SwapIndex>& swapIdx = ext::shared_ptr<SwapIndex>()) const;

    Real
    swapAnnuity(const Date& fixing,
                const Period& tenor,
                const Date& referenceDate = Date(),
                Real y = 0.0,
                const ext::shared_ptr<SwapIndex>& swapIdx = ext::shared_ptr<SwapIndex>()) const;

    /*! Computes the integral
    \f[ {2\pi}^{-0.5} \int_{a}^{b} p(x) \exp{-0.5*x*x} \mathrm{d}x \f]
    with
    \f[ p(x) = ax^4+bx^3+cx^2+dx+e \f].
    */
    static Real
    gaussianPolynomialIntegral(Real a, Real b, Real c, Real d, Real e, Real x0, Real x1);

    /*! Computes the integral
    \f[ {2\pi}^{-0.5} \int_{a}^{b} p(x) \exp{-0.5*x*x} \mathrm{d}x \f]
    with
    \f[ p(x) = a(x-h)^4+b(x-h)^3+c(x-h)^2+d(x-h)+e \f].
    */
    static Real gaussianShiftedPolynomialIntegral(
        Real a, Real b, Real c, Real d, Real e, Real h, Real x0, Real x1);

    /*! Generates a grid of values for the standardized state variable $y$
       at time $T$
        conditional on $y(t)=y$, covering yStdDevs standard deviations
       consisting of
        2*gridPoints+1 points */

    Array yGrid(Real yStdDevs, int gridPoints, Real T = 1.0, Real t = 0, Real y = 0) const;

  private:
    // It is of great importance for performance reasons to cache underlying
    // swaps generated from indexes. In addition the indexes may only be given
    // as templates for the conventions with the tenor replaced by the actual
    // one later on.

    struct CachedSwapKey {
        const ext::shared_ptr<SwapIndex> index;
        const Date fixing;
        const Period tenor;
        bool operator==(const CachedSwapKey &o) const {
            return index->name() == o.index->name() && fixing == o.fixing &&
                   tenor == o.tenor;
        }
    };

    struct CachedSwapKeyHasher {
        std::size_t operator()(CachedSwapKey const &x) const {
            std::size_t seed = 0;
            boost::hash_combine(seed, x.index->name());
            boost::hash_combine(seed, x.fixing.serialNumber());
            boost::hash_combine(seed, x.tenor.length());
            boost::hash_combine(seed, x.tenor.units());
            return seed;
        }
    };

    mutable std::unordered_map<CachedSwapKey, ext::shared_ptr<VanillaSwap>, CachedSwapKeyHasher> swapCache_;

  protected:
    // we let derived classes register with the termstructure
    Gaussian1dModel(const Handle<YieldTermStructure> &yieldTermStructure)
        : TermStructureConsistentModel(yieldTermStructure) {
        registerWith(Settings::instance().evaluationDate());
    }

    virtual Real numeraireImpl(Time t, Real y, const Handle<YieldTermStructure>& yts) const = 0;

    virtual Real
    zerobondImpl(Time T, Time t, Real y, const Handle<YieldTermStructure>& yts) const = 0;

    void performCalculations() const override {
        evaluationDate_ = Settings::instance().evaluationDate();
        enforcesTodaysHistoricFixings_ =
            Settings::instance().enforcesTodaysHistoricFixings();
    }

    void generateArguments() {
        calculate();
        notifyObservers();
    }

    // retrieve underlying swap from cache if possible, otherwise
    // create it and store it in the cache
    ext::shared_ptr<VanillaSwap>
    underlyingSwap(const ext::shared_ptr<SwapIndex> &index,
                   const Date &expiry, const Period &tenor) const {

        CachedSwapKey k = {index, expiry, tenor};
        auto i = swapCache_.find(k);
        if (i == swapCache_.end()) {
            ext::shared_ptr<VanillaSwap> underlying =
                index->clone(tenor)->underlyingSwap(expiry);
            swapCache_.insert(std::make_pair(k, underlying));
            return underlying;
        }
        return i->second;
    }

    ext::shared_ptr<StochasticProcess1D> stateProcess_;
    mutable Date evaluationDate_;
    mutable bool enforcesTodaysHistoricFixings_;
};

inline ext::shared_ptr<StochasticProcess1D> Gaussian1dModel::stateProcess() const {

    QL_REQUIRE(stateProcess_ != nullptr, "state process not set");
    return stateProcess_;
}

inline Real
Gaussian1dModel::numeraire(const Time t, const Real y,
                           const Handle<YieldTermStructure> &yts) const {

    return numeraireImpl(t, y, yts);
}

inline Real
Gaussian1dModel::zerobond(const Time T, const Time t, const Real y,
                          const Handle<YieldTermStructure> &yts) const {
    return zerobondImpl(T, t, y, yts);
}

inline Real
Gaussian1dModel::numeraire(const Date &referenceDate, const Real y,
                           const Handle<YieldTermStructure> &yts) const {

    return numeraire(termStructure()->timeFromReference(referenceDate), y, yts);
}

inline Real
Gaussian1dModel::zerobond(const Date &maturity, const Date &referenceDate,
                          const Real y, const Handle<YieldTermStructure> &yts) const {

    return zerobond(termStructure()->timeFromReference(maturity),
                    referenceDate != Date()
                        ? termStructure()->timeFromReference(referenceDate)
                        : 0.0,
                    y, yts);
}
}

#endif
]]></document_content>
  </document>
  <document index="148">
    <source>shortrate/onefactormodels/gsr.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gsr.hpp
    \brief GSR 1 factor model
*/

#ifndef quantlib_gsr_hpp
#define quantlib_gsr_hpp

#include <ql/models/shortrate/onefactormodels/gaussian1dmodel.hpp>
#include <ql/processes/gsrprocess.hpp>

namespace QuantLib {

//! One factor gsr model, formulation is in forward measure

class Gsr : public Gaussian1dModel, public CalibratedModel {

  public:
    // constant mean reversion
    Gsr(const Handle<YieldTermStructure>& termStructure,
        std::vector<Date> volstepdates,
        const std::vector<Real>& volatilities,
        Real reversion,
        Real T = 60.0);
    // piecewise mean reversion (with same step dates as volatilities)
    Gsr(const Handle<YieldTermStructure>& termStructure,
        std::vector<Date> volstepdates,
        const std::vector<Real>& volatilities,
        const std::vector<Real>& reversions,
        Real T = 60.0);
    // constant mean reversion with floating model data
    Gsr(const Handle<YieldTermStructure>& termStructure,
        std::vector<Date> volstepdates,
        std::vector<Handle<Quote> > volatilities,
        const Handle<Quote>& reversion,
        Real T = 60.0);
    // piecewise mean reversion with floating model data
    Gsr(const Handle<YieldTermStructure>& termStructure,
        std::vector<Date> volstepdates,
        std::vector<Handle<Quote> > volatilities,
        std::vector<Handle<Quote> > reversions,
        Real T = 60.0);

    Real numeraireTime() const;
    void numeraireTime(Real T);

    const Array &reversion() const { return reversion_.params(); }
    const Array &volatility() const { return sigma_.params(); }

    // calibration constraints

    // fixed reversions, only volatilities are free
    std::vector<bool> FixedReversions() {
        std::vector<bool> res(reversions_.size(), true);
        std::vector<bool> vol(volatilities_.size(), false);
        res.insert(res.end(), vol.begin(), vol.end());
        return res;
    }

    // fixed volatilities, only reversions are free
    std::vector<bool> FixedVolatilities() {
        std::vector<bool> res(reversions_.size(), false);
        std::vector<bool> vol(volatilities_.size(), true);
        res.insert(res.end(), vol.begin(), vol.end());
        return res;
    }

    std::vector<bool> MoveVolatility(Size i) {
        QL_REQUIRE(i < volatilities_.size(),
                   "volatility with index " << i << " does not exist (0..."
                                            << volatilities_.size() - 1 << ")");
        std::vector<bool> res(reversions_.size() + volatilities_.size(), true);
        res[reversions_.size() + i] = false;
        return res;
    }

    std::vector<bool> MoveReversion(Size i) {
        QL_REQUIRE(i < reversions_.size(),
                   "reversion with index " << i << " does not exist (0..."
                                           << reversions_.size() - 1 << ")");
        std::vector<bool> res(reversions_.size() + volatilities_.size(), true);
        res[i] = false;
        return res;
    }

    // With fixed reversion calibrate the volatilities one by one
    // to the given helpers. It is assumed that that volatility step
    // dates are suitable for this, i.e. they should be identical to
    // the fixing dates of the helpers (except for the last one where
    // we do not need a step). Also note that the endcritera reflect
    // only the status of the last calibration when using this method.
    void calibrateVolatilitiesIterative(
        const std::vector<ext::shared_ptr<BlackCalibrationHelper> > &helpers,
        OptimizationMethod &method, const EndCriteria &endCriteria,
        const Constraint &constraint = Constraint(),
        const std::vector<Real> &weights = std::vector<Real>()) {

        for (Size i = 0; i < helpers.size(); i++) {
            std::vector<ext::shared_ptr<CalibrationHelper> > h(1, helpers[i]);
            calibrate(h, method, endCriteria, constraint, weights,
                      MoveVolatility(i));
        }
    }

    // With fixed volatility calibrate the reversions one by one
    // to the given helpers. In this case the step dates must be chosen
    // according to the maturities of the calibration instruments.
    void calibrateReversionsIterative(
        const std::vector<ext::shared_ptr<BlackCalibrationHelper> > &helpers,
        OptimizationMethod &method, const EndCriteria &endCriteria,
        const Constraint &constraint = Constraint(),
        const std::vector<Real> &weights = std::vector<Real>()) {

        for (Size i = 0; i < helpers.size(); i++) {
            std::vector<ext::shared_ptr<CalibrationHelper> > h(1, helpers[i]);
            calibrate(h, method, endCriteria, constraint, weights,
                      MoveReversion(i));
        }
    }

  protected:
    Real numeraireImpl(Time t, Real y, const Handle<YieldTermStructure>& yts) const override;

    Real zerobondImpl(Time T, Time t, Real y, const Handle<YieldTermStructure>& yts) const override;

    void generateArguments() override {
        ext::static_pointer_cast<GsrProcess>(stateProcess_)->flushCache();
        ext::static_pointer_cast<GsrProcess>(stateProcess_)->setVols(sigma_.params());
        ext::static_pointer_cast<GsrProcess>(stateProcess_)->setReversions(reversion_.params());
        notifyObservers();
    }

    void update() override;

    void performCalculations() const override {
        Gaussian1dModel::performCalculations();
        updateTimes();
    }

  private:
    void updateTimes() const;
    void updateVolatility();
    void updateReversion();

    void initialize(Real);

    Parameter &reversion_, &sigma_;

    std::vector<Handle<Quote> > volatilities_;
    std::vector<Handle<Quote> > reversions_;
    std::vector<Date> volstepdates_; // this is shared between vols,
                                     // adjusters and reverisons in
                                     // case of piecewise reversions
    mutable std::vector<Time> volsteptimes_;
    mutable Array volsteptimesArray_; // FIXME this is redundant (just a copy of
                                      // volsteptimes_)

    struct VolatilityObserver : public Observer {
        explicit VolatilityObserver(Gsr *p) : p_(p) {}
        void update() override { p_->updateVolatility(); }
        Gsr *p_;
    };
    struct ReversionObserver : public Observer {
        explicit ReversionObserver(Gsr *p) : p_(p) {}
        void update() override { p_->updateReversion(); }
        Gsr *p_;
    };

    ext::shared_ptr<VolatilityObserver> volatilityObserver_;
    ext::shared_ptr<ReversionObserver> reversionObserver_;
};

inline Real Gsr::numeraireTime() const {
    return ext::dynamic_pointer_cast<GsrProcess>(stateProcess_)
        ->getForwardMeasureTime();
}

inline void Gsr::numeraireTime(const Real T) {
    ext::dynamic_pointer_cast<GsrProcess>(stateProcess_)
        ->setForwardMeasureTime(T);
}
}

#endif
]]></document_content>
  </document>
  <document index="149">
    <source>shortrate/onefactormodels/hullwhite.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2006 Chiara Fornarola
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hullwhite.hpp
    \brief Hull & White (HW) model
*/

#ifndef quantlib_hull_white_hpp
#define quantlib_hull_white_hpp

#include <ql/models/shortrate/onefactormodels/vasicek.hpp>
#include <utility>

namespace QuantLib {

    //! Single-factor Hull-White (extended %Vasicek) model class.
    /*! This class implements the standard single-factor Hull-White model
        defined by
        \f[
            dr_t = (\theta(t) - \alpha r_t)dt + \sigma dW_t
        \f]
        where \f$ \alpha \f$ and \f$ \sigma \f$ are constants.

        \test calibration results are tested against cached values

        \bug When the term structure is relinked, the r0 parameter of
             the underlying Vasicek model is not updated.

        \ingroup shortrate
    */
    class HullWhite : public Vasicek, public TermStructureConsistentModel {
      public:
        HullWhite(const Handle<YieldTermStructure>& termStructure,
                  Real a = 0.1, Real sigma = 0.01);

        ext::shared_ptr<Lattice> tree(const TimeGrid& grid) const override;

        ext::shared_ptr<ShortRateDynamics> dynamics() const override;

        Real discountBondOption(Option::Type type,
                                Real strike,
                                Time maturity,
                                Time bondMaturity) const override;

        Real discountBondOption(Option::Type type,
                                Real strike,
                                Time maturity,
                                Time bondStart,
                                Time bondMaturity) const override;

        /*! Futures convexity bias (i.e., the difference between
            futures implied rate and forward rate) calculated as in
            G. Kirikos, D. Novak, "Convexity Conundrums", Risk
            Magazine, March 1997.

            \note t and T should be expressed in yearfraction using
                  deposit day counter, F_quoted is futures' market price.
        */
        static Rate convexityBias(Real futurePrice,
                                  Time t,
                                  Time T,
                                  Real sigma,
                                  Real a);

        static std::vector<bool> FixedReversion() {
            std::vector<bool> c(2);
            c[0] = true; c[1] = false;
            return c;
        }

      protected:
        void generateArguments() override;

        Real A(Time t, Time T) const override;

      private:
        class Dynamics;
        class FittingParameter;

        Parameter phi_;
    };

    //! Short-rate dynamics in the Hull-White model
    /*! The short-rate is here
        \f[
            r_t = \varphi(t) + x_t
        \f]
        where \f$ \varphi(t) \f$ is the deterministic time-dependent
        parameter used for term-structure fitting and \f$ x_t \f$ is the
        state variable following an Ornstein-Uhlenbeck process.
    */
    class HullWhite::Dynamics : public OneFactorModel::ShortRateDynamics {
      public:
        Dynamics(Parameter fitting, Real a, Real sigma)
        : ShortRateDynamics(
              ext::shared_ptr<StochasticProcess1D>(new OrnsteinUhlenbeckProcess(a, sigma))),
          fitting_(std::move(fitting)) {}

        Real variable(Time t, Rate r) const override { return r - fitting_(t); }
        Real shortRate(Time t, Real x) const override { return x + fitting_(t); }

      private:
        Parameter fitting_;
    };

    //! Analytical term-structure fitting parameter \f$ \varphi(t) \f$.
    /*! \f$ \varphi(t) \f$ is analytically defined by
        \f[
            \varphi(t) = f(t) + \frac{1}{2}[\frac{\sigma(1-e^{-at})}{a}]^2,
        \f]
        where \f$ f(t) \f$ is the instantaneous forward rate at \f$ t \f$.
    */
    class HullWhite::FittingParameter
        : public TermStructureFittingParameter {
      private:
        class Impl final : public Parameter::Impl {
          public:
            Impl(Handle<YieldTermStructure> termStructure, Real a, Real sigma)
            : termStructure_(std::move(termStructure)), a_(a), sigma_(sigma) {}

            Real value(const Array&, Time t) const override {
                Rate forwardRate =
                    termStructure_->forwardRate(t, t, Continuous, NoFrequency);
                Real temp = a_ < std::sqrt(QL_EPSILON) ?
                            Real(sigma_*t) :
                            Real(sigma_*(1.0 - std::exp(-a_*t))/a_);
                return (forwardRate + 0.5*temp*temp);
            }

          private:
            Handle<YieldTermStructure> termStructure_;
            Real a_, sigma_;
        };
      public:
        FittingParameter(const Handle<YieldTermStructure>& termStructure,
                         Real a, Real sigma)
        : TermStructureFittingParameter(ext::shared_ptr<Parameter::Impl>(
                      new FittingParameter::Impl(termStructure, a, sigma))) {}
    };


    // inline definitions

    inline ext::shared_ptr<OneFactorModel::ShortRateDynamics>
    HullWhite::dynamics() const {
        return ext::shared_ptr<ShortRateDynamics>(
                                            new Dynamics(phi_, a(), sigma()));
    }

}


#endif

]]></document_content>
  </document>
  <document index="150">
    <source>shortrate/onefactormodels/markovfunctional.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2018 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file markovfunctional.hpp
    \brief Markov Functional 1 Factor Model
*/

#ifndef quantlib_markovfunctional_hpp
#define quantlib_markovfunctional_hpp

#include <ql/math/interpolation.hpp>
#include <ql/models/shortrate/onefactormodels/gaussian1dmodel.hpp>
#include <ql/processes/mfstateprocess.hpp>
#include <ql/termstructures/volatility/optionlet/optionletvolatilitystructure.hpp>
#include <ql/termstructures/volatility/smilesection.hpp>
#include <ql/termstructures/volatility/swaption/swaptionvolstructure.hpp>
#include <utility>

namespace QuantLib {

    /*! One factor Markov Functional model class. Some documentation is
        available here
        http://ssrn.com/abstract_id=2183721
        http://quantlib.org/slides/qlws13/caspers.pdf
    */

    /*! The model requires a suitable input smile which means it should be
      arbitrage free, smooth (at least implying a C^1 call price function) and
      with a call price function not decreasing too slow in strike  direction.

      A method for arbitrage free extra- and interpolation due to Kahale is
      provided and may be used to improve an input smile. Alternatively a
      SABR smile with arbitrage free wings can be fitted to the input smile
      to provide an appropriate input smile.

      If you use the Kahale or SABR method for smile pretreatment then this
      implies zero density for underlying rates below minus the displacement
      parameter. This means that in this case the market yield term structure
      must imply underlying atm forward rates greater than minus displacement.

      If you do not use a smile pretreatment you should ensure that the input
      smileSection is arbitrage free and  that the input smileSection covers the
      strikes from lowerRateBound to upperRateBound.

      During calibration a monocurve setup is assumed with the given yield term
      structure determining the rates throughout, no matter what curves are
      linked to the indices in the volatility term structures. The yield term
      structure should therefore be the main risk curve, i.e. the forwarding curve
      for the respective swaption or cap underlyings.

      The model uses a simplified formula for the npv of a swaps floating leg
      namely $P(t,T_0)-P(t,T_1)$ with  $T_0$ being the start date of the leg
      and $T_1$ being the last payment date, which is an approximation to the
      true npv.

      The model calibrates to slightly modified market options in the sense that
      the start date is set equal to the  fixing date, i.e. there is no delay.
      The model diagnostic outputs refer to this modified instrument. In general
      the actual market instrument including the delay is still matched very
      well though the calibration is done on a slightly different instrument.

      AdjustYts and AdjustDigitals are experimental options. Specifying
      AdjustYts may have a negative impact on the volatility smile match, so
      it should be used with special care. For long term calibration it seems
      an interesting option though.

      A bad fit to the initial yield term structure may be due to a non suitable
      input smile or accumulating numerical errors in very long term calibrations.
      The former point is addressed by smile pretreatment options. The latter point
      may be tackled by higher values for the numerical parameters possibly
      together with NTL high precision computing.

      When using a shifted lognormal smile input the lower rate bound is adjusted
      by the shift so that a lower bound of 0.0 always corresponds to the lower
      bound of the shifted distribution.

      If a custom smile is used, this will take full responsibility of inverting
      digital prices to market rates, so digitalGap, marketRateAccuracy,
      lowerRateBound, upperRateBound are irrelavant and the smile moneyness
      checkpoints are only used for the debug model output in this setup.
    */

    class MarkovFunctional : public Gaussian1dModel, public CalibratedModel {

      public:

        class CustomSmileSection : public SmileSection {
        public:
          virtual Real inverseDigitalCall(Real price, Real discount = 1.0) const = 0;
        };

        class CustomSmileFactory {
        public:
          virtual ~CustomSmileFactory() = default;
          virtual ext::shared_ptr<CustomSmileSection>
          smileSection(const ext::shared_ptr<SmileSection>& source, Real atm) const = 0;
        };

        struct ModelSettings {

            // NoPayoffExtrapolation overrides ExtrapolatePayoffFlat
            enum Adjustments {
                AdjustNone = 0,
                AdjustDigitals = 1 << 0,
                AdjustYts = 1 << 1,
                ExtrapolatePayoffFlat = 1 << 2,
                NoPayoffExtrapolation = 1 << 3,
                KahaleSmile = 1 << 4,
                SmileExponentialExtrapolation = 1 << 5,
                KahaleInterpolation = 1 << 6,
                SmileDeleteArbitragePoints = 1 << 7,
                SabrSmile = 1 << 8,
                CustomSmile = 1 << 9
            };

            ModelSettings() : adjustments_(KahaleSmile | SmileExponentialExtrapolation) {}

            ModelSettings(Size yGridPoints,
                          Real yStdDevs,
                          Size gaussHermitePoints,
                          Real digitalGap,
                          Real marketRateAccuracy,
                          Real lowerRateBound,
                          Real upperRateBound,
                          int adjustments,
                          std::vector<Real> smileMoneyCheckpoints = std::vector<Real>(),
                          ext::shared_ptr<CustomSmileFactory> customSmileFactory =
                              ext::shared_ptr<CustomSmileFactory>())
            : yGridPoints_(yGridPoints), yStdDevs_(yStdDevs),
              gaussHermitePoints_(gaussHermitePoints), digitalGap_(digitalGap),
              marketRateAccuracy_(marketRateAccuracy), lowerRateBound_(lowerRateBound),
              upperRateBound_(upperRateBound), adjustments_(adjustments),
              smileMoneynessCheckpoints_(std::move(smileMoneyCheckpoints)),
              customSmileFactory_(std::move(customSmileFactory)) {}

            void validate() {

                if ((adjustments_ & KahaleInterpolation) != 0)
                    addAdjustment(KahaleSmile);

                if ((adjustments_ & KahaleSmile) != 0 &&
                    (adjustments_ & SmileDeleteArbitragePoints) != 0) {
                    addAdjustment(KahaleInterpolation);
                }

                QL_REQUIRE((adjustments_ & SabrSmile) == 0 ||
                           (adjustments_ & KahaleSmile) == 0 ||
                           (adjustments_ & CustomSmile) == 0
                           ,
                           "Only one of KahaleSmile, SabrSmile and CustomSmile"
                           "can be specified at the same time");
                QL_REQUIRE(yGridPoints_ > 0, "At least one grid point ("
                                                 << yGridPoints_
                                                 << ") for the state process "
                                                    "discretization must be "
                                                    "given");
                QL_REQUIRE(yStdDevs_ > 0.0,
                           "Multiple of standard deviations covered by state "
                           "process discretization ("
                               << yStdDevs_ << ") must be positive");
                QL_REQUIRE(gaussHermitePoints_ > 0,
                           "Number of gauss hermite integration points ("
                               << gaussHermitePoints_ << ") must be positive");
                QL_REQUIRE(digitalGap_ > 0.0, "Digital gap ("
                                                  << digitalGap_
                                                  << ") must be positive");
                QL_REQUIRE(marketRateAccuracy_ > 0.0,
                           "Market rate accuracy (" << marketRateAccuracy_
                                                    << ") must be positive");
                QL_REQUIRE(
                    (adjustments_ & KahaleSmile) == 0 || lowerRateBound_ == 0.0,
                    "If Kahale extrapolation is used, the lower rate bound ("
                        << lowerRateBound_ << ") must be zero.");
                QL_REQUIRE(
                    lowerRateBound_ < upperRateBound_,
                    "Lower rate bound ("
                        << lowerRateBound_
                        << ") must be strictly less than upper rate bound ("
                        << upperRateBound_ << ")");
                QL_REQUIRE(((adjustments_ & CustomSmile) == 0) ||
                           customSmileFactory_,
                           "missing CustomSmileFactoy");
            }

            ModelSettings &withYGridPoints(Size n) {
                yGridPoints_ = n;
                return *this;
            }
            ModelSettings &withYStdDevs(Real s) {
                yStdDevs_ = s;
                return *this;
            }
            ModelSettings &withGaussHermitePoints(Size n) {
                gaussHermitePoints_ = n;
                return *this;
            }
            ModelSettings &withDigitalGap(Real d) {
                digitalGap_ = d;
                return *this;
            }
            ModelSettings &withMarketRateAccuracy(Real a) {
                marketRateAccuracy_ = a;
                return *this;
            }
            ModelSettings &withUpperRateBound(Real u) {
                upperRateBound_ = u;
                return *this;
            }
            ModelSettings &withLowerRateBound(Real l) {
                lowerRateBound_ = l;
                return *this;
            }
            ModelSettings &withAdjustments(int a) {
                adjustments_ = a;
                return *this;
            }
            ModelSettings &addAdjustment(int a) {
                adjustments_ |= a;
                return *this;
            }
            ModelSettings &removeAdjustment(int a) {
                adjustments_ &= ~a;
                return *this;
            }
            ModelSettings &withSmileMoneynessCheckpoints(const std::vector<Real>& m) {
                smileMoneynessCheckpoints_ = m;
                return *this;
            }
            ModelSettings &withCustomSmileFactory(const ext::shared_ptr<CustomSmileFactory>& f) {
                customSmileFactory_ = f;
                return *this;
            }

            Size yGridPoints_ = 64;
            Real yStdDevs_ = 7.0;
            Size gaussHermitePoints_ = 32;
            Real digitalGap_ = 1E-5, marketRateAccuracy_ = 1E-7;
            Real lowerRateBound_ = 0.0, upperRateBound_ = 2.0;
            int adjustments_;
            std::vector<Real> smileMoneynessCheckpoints_;
            ext::shared_ptr<CustomSmileFactory> customSmileFactory_;
        };

        struct CalibrationPoint {
            bool isCaplet_;
            Period tenor_;
            std::vector<Date> paymentDates_;
            std::vector<Real> yearFractions_;
            Real atm_ = Null<Real>();
            Real annuity_ = Null<Real>();
            ext::shared_ptr<SmileSection> smileSection_;
            ext::shared_ptr<SmileSection> rawSmileSection_;
            Real minRateDigital_ = Null<Real>();
            Real maxRateDigital_ = Null<Real>();
        };

// utility macro to write messages to the model outputs

#define QL_MFMESSAGE(o, message)                                               \
    {                                                                          \
        std::ostringstream os;                                                 \
        os << message;                                                         \
        o.messages_.push_back(os.str());                                       \
    }

        struct ModelOutputs {
            bool dirty_;
            ModelSettings settings_;
            std::vector<Date> expiries_;
            std::vector<Period> tenors_;
            std::vector<Real> atm_;
            std::vector<Real> annuity_;
            std::vector<Real> adjustmentFactors_;
            std::vector<Real> digitalsAdjustmentFactors_;
            std::vector<std::string> messages_;
            std::vector<std::vector<Real> > smileStrikes_;
            std::vector<std::vector<Real> > marketRawCallPremium_;
            std::vector<std::vector<Real> > marketRawPutPremium_;
            std::vector<std::vector<Real> > marketCallPremium_;
            std::vector<std::vector<Real> > marketPutPremium_;
            std::vector<std::vector<Real> > modelCallPremium_;
            std::vector<std::vector<Real> > modelPutPremium_;
            std::vector<std::vector<Real> > marketVega_;
            std::vector<Real> marketZerorate_;
            std::vector<Real> modelZerorate_;
        };

        // Constructor for a swaption smile calibrated model
        MarkovFunctional(const Handle<YieldTermStructure>& termStructure,
                         Real reversion,
                         std::vector<Date> volstepdates,
                         std::vector<Real> volatilities,
                         const Handle<SwaptionVolatilityStructure>& swaptionVol,
                         const std::vector<Date>& swaptionExpiries,
                         const std::vector<Period>& swaptionTenors,
                         const ext::shared_ptr<SwapIndex>& swapIndexBase,
                         MarkovFunctional::ModelSettings modelSettings = ModelSettings());

        // Constructor for a caplet smile calibrated model
        MarkovFunctional(const Handle<YieldTermStructure>& termStructure,
                         Real reversion,
                         std::vector<Date> volstepdates,
                         std::vector<Real> volatilities,
                         const Handle<OptionletVolatilityStructure>& capletVol,
                         const std::vector<Date>& capletExpiries,
                         ext::shared_ptr<IborIndex> iborIndex,
                         MarkovFunctional::ModelSettings modelSettings = ModelSettings());

        const ModelSettings &modelSettings() const { return modelSettings_; }
        const ModelOutputs &modelOutputs() const;

        const Date &numeraireDate() const { return numeraireDate_; }
        const Time &numeraireTime() const { return numeraireTime_; }

        const Array &volatility() const { return sigma_.params(); }

        void calibrate(const std::vector<ext::shared_ptr<CalibrationHelper> >& helpers,
                       OptimizationMethod& method,
                       const EndCriteria& endCriteria,
                       const Constraint& constraint = Constraint(),
                       const std::vector<Real>& weights = std::vector<Real>(),
                       const std::vector<bool>& fixParameters = std::vector<bool>()) override {

            CalibratedModel::calibrate(helpers, method, endCriteria, constraint, weights,
                                       fixParameters.empty() ? FixedFirstVolatility() :
                                                               fixParameters);
        }

        void calibrate(const std::vector<ext::shared_ptr<BlackCalibrationHelper> >& helpers,
                       OptimizationMethod& method,
                       const EndCriteria& endCriteria,
                       const Constraint& constraint = Constraint(),
                       const std::vector<Real>& weights = std::vector<Real>(),
                       const std::vector<bool>& fixParameters = std::vector<bool>()) {

            std::vector<ext::shared_ptr<CalibrationHelper> > tmp(helpers.size());
            for (Size i=0; i<helpers.size(); ++i)
                tmp[i] = ext::static_pointer_cast<CalibrationHelper>(helpers[i]);

            calibrate(tmp, method, endCriteria, constraint, weights, fixParameters);
        }

        void update() override { LazyObject::update(); }

        // returns the indices of the af region from the last smile update
        std::vector<std::pair<Size, Size> > arbitrageIndices() const {
            calculate();
            return arbitrageIndices_;
        }

        // forces the indices of the af region (useful for sensitivity calculation)
        // if an empty vector is given, the dynamic calculation is used again
        void forceArbitrageIndices(const std::vector<std::pair<Size,Size> >& indices) {
            forcedArbitrageIndices_ = indices;
            this->update();
        }

      protected:
        Real numeraireImpl(Time t, Real y, const Handle<YieldTermStructure>& yts) const override;

        Real
        zerobondImpl(Time T, Time t, Real y, const Handle<YieldTermStructure>& yts) const override;

        void generateArguments() override {
            ext::static_pointer_cast<MfStateProcess>(stateProcess_)->setVols(sigma_.params());
            if(isCalculated())
                updateNumeraireTabulation();
            else
                calculate();
            notifyObservers();
        }

        void performCalculations() const override {
            Gaussian1dModel::performCalculations();
            updateTimes();
            updateSmiles();
            updateNumeraireTabulation();
        }

        std::vector<bool> FixedFirstVolatility() const {
            std::vector<bool> c(volatilities_.size(), false);
            c[0] = true;
            return c;
        }

      private:

        void initialize();
        void updateTimes() const;
        void updateTimes1() const;
        void updateTimes2() const;

        void updateSmiles() const;
        void updateNumeraireTabulation() const;

        void makeSwaptionCalibrationPoint(const Date &expiry,
                                          const Period &tenor);
        void makeCapletCalibrationPoint(const Date &expiry);

        Real marketSwapRate(const Date& expiry,
                            const CalibrationPoint& p,
                            Real digitalPrice,
                            Real guess = 0.03,
                            Real shift = 0.0) const;
        Real marketDigitalPrice(const Date& expiry,
                                const CalibrationPoint& p,
                                const Option::Type& type,
                                Real strike) const;

        Array deflatedZerobondArray(Time T, Time t, const Array& y) const;
        Array numeraireArray(Time t, const Array& y) const;
        Array zerobondArray(Time T, Time t, const Array& y) const;

        Real deflatedZerobond(Time T, Time t = 0.0, Real y = 0.0) const;

        // the following methods (tagged internal) are indended only to produce
        // the volatility diagnostics in the model outputs
        // due to the special convention of the instruments used for numeraire
        // calibration there is on direct way to use the usual pricing engines
        // for this purpose

        Real forwardRateInternal(
            const Date& fixing,
            const Date& referenceDate = Date(),
            Real y = 0.0,
            bool zeroFixingDays = false,
            ext::shared_ptr<IborIndex> iborIdx = ext::shared_ptr<IborIndex>()) const;

        Real
        swapRateInternal(const Date& fixing,
                         const Period& tenor,
                         const Date& referenceDate = Date(),
                         Real y = 0.0,
                         bool zeroFixingDays = false,
                         ext::shared_ptr<SwapIndex> swapIdx = ext::shared_ptr<SwapIndex>()) const;

        Real swapAnnuityInternal(
            const Date& fixing,
            const Period& tenor,
            const Date& referenceDate = Date(),
            Real y = 0.0,
            bool zeroFixingDays = false,
            ext::shared_ptr<SwapIndex> swapIdx = ext::shared_ptr<SwapIndex>()) const;

        Real capletPriceInternal(
            const Option::Type& type,
            const Date& expiry,
            Rate strike,
            const Date& referenceDate = Date(),
            Real y = 0.0,
            bool zeroFixingDays = false,
            ext::shared_ptr<IborIndex> iborIdx = ext::shared_ptr<IborIndex>()) const;

        Real swaptionPriceInternal(
            const Option::Type& type,
            const Date& expiry,
            const Period& tenor,
            Rate strike,
            const Date& referenceDate = Date(),
            Real y = 0.0,
            bool zeroFixingDays = false,
            const ext::shared_ptr<SwapIndex>& swapIdx = ext::shared_ptr<SwapIndex>()) const;

        class ZeroHelper {
          public:
            ZeroHelper(const MarkovFunctional *model, const Date &expiry,
                       const CalibrationPoint &p, const Real marketPrice)
                : model_(model), marketPrice_(marketPrice), expiry_(expiry),
                  p_(p) {}
            Real operator()(Real strike) const {
                Real modelPrice = model_->marketDigitalPrice(
                    expiry_, p_, Option::Call, strike);
                return modelPrice - marketPrice_;
            };
            const MarkovFunctional *model_;
            const Real marketPrice_;
            const Date &expiry_;
            const CalibrationPoint &p_;
        };

        ModelSettings modelSettings_;
        mutable ModelOutputs modelOutputs_;

        const bool capletCalibrated_;

        ext::shared_ptr<Matrix> discreteNumeraire_;
        // vector of interpolated numeraires in y direction for all calibration
        // times
        std::vector<ext::shared_ptr<Interpolation> > numeraire_;

        Parameter reversion_;
        Parameter &sigma_;

        std::vector<Date> volstepdates_;
        mutable std::vector<Time> volsteptimes_;
        mutable Array volsteptimesArray_; // FIXME this is redundant (just a copy of
                                  // volsteptimes_)
        std::vector<Real> volatilities_;

        Date numeraireDate_;
        mutable Time numeraireTime_;

        Handle<SwaptionVolatilityStructure> swaptionVol_;
        Handle<OptionletVolatilityStructure> capletVol_;

        std::vector<Date> swaptionExpiries_, capletExpiries_;
        std::vector<Period> swaptionTenors_;
        ext::shared_ptr<SwapIndex> swapIndexBase_;
        ext::shared_ptr<IborIndex> iborIndex_;

        mutable std::map<Date, CalibrationPoint> calibrationPoints_;
        mutable std::vector<Real> times_;
        Array y_;

        Array normalIntegralX_;
        Array normalIntegralW_;

        mutable std::vector<std::pair<Size,Size> > arbitrageIndices_;
        std::vector<std::pair<Size,Size> > forcedArbitrageIndices_;
    };

    std::ostream &operator<<(std::ostream &out,
                             const MarkovFunctional::ModelOutputs &m);
}

#endif
]]></document_content>
  </document>
  <document index="151">
    <source>shortrate/onefactormodels/vasicek.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vasicek.hpp
    \brief Vasicek model class
*/

#ifndef quantlib_vasicek_hpp
#define quantlib_vasicek_hpp

#include <ql/models/shortrate/onefactormodel.hpp>
#include <ql/processes/ornsteinuhlenbeckprocess.hpp>

namespace QuantLib {

    //! %Vasicek model class
    /*! This class implements the Vasicek model defined by
        \f[
            dr_t = a(b - r_t)dt + \sigma dW_t ,
        \f]
        where \f$ a \f$, \f$ b \f$ and \f$ \sigma \f$ are constants;
        a risk premium \f$ \lambda \f$ can also be specified.

        \ingroup shortrate
    */
    class Vasicek : public OneFactorAffineModel {
      public:
        Vasicek(Rate r0 = 0.05,
                Real a = 0.1, Real b = 0.05, Real sigma = 0.01,
                Real lambda = 0.0);
        Real discountBondOption(Option::Type type,
                                Real strike,
                                Time maturity,
                                Time bondMaturity) const override;

        ext::shared_ptr<ShortRateDynamics> dynamics() const override;

        Real a() const { return a_(0.0); }
        Real b() const { return b_(0.0); }
        Real lambda() const { return lambda_(0.0); }
        Real sigma() const { return sigma_(0.0); }
        Real r0() const { return r0_;}

      protected:
        Real A(Time t, Time T) const override;
        Real B(Time t, Time T) const override;

        Real r0_;
        Parameter& a_;
        Parameter& b_;
        Parameter& sigma_;
        Parameter& lambda_;
      private:
        class Dynamics;

    };

    //! Short-rate dynamics in the %Vasicek model
    /*! The short-rate follows an Ornstein-Uhlenbeck process with mean
        \f$ b \f$.
    */
    class Vasicek::Dynamics : public OneFactorModel::ShortRateDynamics {
      public:
        Dynamics(Real a,
                 Real b,
                 Real sigma,
                 Real r0)
        : ShortRateDynamics(ext::shared_ptr<StochasticProcess1D>(
                             new OrnsteinUhlenbeckProcess(a, sigma, r0 - b))),
          b_(b) {}

        Real variable(Time, Rate r) const override { return r - b_; }
        Real shortRate(Time, Real x) const override { return x + b_; }

      private:
        Real b_;
    };


    // inline definitions

    inline ext::shared_ptr<OneFactorModel::ShortRateDynamics>
    Vasicek::dynamics() const {
        return ext::shared_ptr<ShortRateDynamics>(
                                     new Dynamics(a(), b() , sigma(), r0_));
    }

}


#endif

]]></document_content>
  </document>
  <document index="152">
    <source>shortrate/twofactormodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file twofactormodel.hpp
    \brief Abstract two-factor interest rate model class
*/

#ifndef quantlib_two_factor_model_hpp
#define quantlib_two_factor_model_hpp

#include <ql/methods/lattices/lattice2d.hpp>
#include <ql/models/model.hpp>
#include <utility>

namespace QuantLib {
    class StochasticProcess1D;
    class StochasticProcess;
    //! Abstract base-class for two-factor models
    /*! \ingroup shortrate */
    class TwoFactorModel : public ShortRateModel {
      public:
        explicit TwoFactorModel(Size nParams);

        class ShortRateDynamics;
        class ShortRateTree;

        //! Returns the short-rate dynamics
        virtual ext::shared_ptr<ShortRateDynamics> dynamics() const = 0;

        //! Returns a two-dimensional trinomial tree
        ext::shared_ptr<Lattice> tree(const TimeGrid& grid) const override;
    };

    //! Class describing the dynamics of the two state variables
    /*! We assume here that the short-rate is a function of two state
        variables x and y.
        \f[
            r_t = f(t, x_t, y_t)
        \f]
        of two state variables \f$ x_t \f$ and \f$ y_t \f$. These stochastic
        processes satisfy
        \f[
            x_t = \mu_x(t, x_t)dt + \sigma_x(t, x_t) dW_t^x
        \f]
        and
        \f[
            y_t = \mu_y(t,y_t)dt + \sigma_y(t, y_t) dW_t^y
        \f]
        where \f$ W^x \f$ and \f$ W^y \f$ are two brownian motions
        satisfying
        \f[
            dW^x_t dW^y_t = \rho dt
        \f].
    */
    class TwoFactorModel::ShortRateDynamics {
      public:
        ShortRateDynamics(ext::shared_ptr<StochasticProcess1D> xProcess,
                          ext::shared_ptr<StochasticProcess1D> yProcess,
                          Real correlation)
        : xProcess_(std::move(xProcess)), yProcess_(std::move(yProcess)),
          correlation_(correlation) {}
        virtual ~ShortRateDynamics() = default;

        virtual Rate shortRate(Time t, Real x, Real y) const = 0;

        //! Risk-neutral dynamics of the first state variable x
        const ext::shared_ptr<StochasticProcess1D>& xProcess() const {
            return xProcess_;
        }

        //! Risk-neutral dynamics of the second state variable y
        const ext::shared_ptr<StochasticProcess1D>& yProcess() const {
            return yProcess_;
        }

        //! Correlation \f$ \rho \f$ between the two brownian motions.
        Real correlation() const {
            return correlation_;
        }

        //! Joint process of the two variables
        ext::shared_ptr<StochasticProcess> process() const;

      private:
        ext::shared_ptr<StochasticProcess1D> xProcess_, yProcess_;
        Real correlation_;
    };

    //! Recombining two-dimensional tree discretizing the state variable
    class TwoFactorModel::ShortRateTree
        : public TreeLattice2D<TwoFactorModel::ShortRateTree,TrinomialTree> {
      public:
        //! Plain tree build-up from short-rate dynamics
        ShortRateTree(const ext::shared_ptr<TrinomialTree>& tree1,
                      const ext::shared_ptr<TrinomialTree>& tree2,
                      const ext::shared_ptr<ShortRateDynamics>& dynamics);

        DiscountFactor discount(Size i, Size index) const {
            Size modulo = tree1_->size(i);
            Size index1 = index % modulo;
            Size index2 = index / modulo;

            Real x = tree1_->underlying(i, index1);
            Real y = tree2_->underlying(i, index2);

            Rate r = dynamics_->shortRate(timeGrid()[i], x, y);
            return std::exp(-r*timeGrid().dt(i));
        }
      private:
        ext::shared_ptr<ShortRateDynamics> dynamics_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="153">
    <source>shortrate/twofactormodels/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/shortrate/twofactormodels/g2.hpp>

]]></document_content>
  </document>
  <document index="154">
    <source>shortrate/twofactormodels/g2.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004 Mike Parker

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file g2.hpp
    \brief Two-factor additive Gaussian Model G2++
*/

#ifndef quantlib_two_factor_models_g2_h
#define quantlib_two_factor_models_g2_h

#include <ql/instruments/swaption.hpp>
#include <ql/models/shortrate/twofactormodel.hpp>
#include <ql/processes/ornsteinuhlenbeckprocess.hpp>
#include <utility>

namespace QuantLib {

    //! Two-additive-factor gaussian model class.
    /*! This class implements a two-additive-factor model defined by
        \f[
            dr_t = \varphi(t) + x_t + y_t
        \f]
        where \f$ x_t \f$ and \f$ y_t \f$ are defined by
        \f[
            dx_t = -a x_t dt + \sigma dW^1_t, x_0 = 0
        \f]
        \f[
            dy_t = -b y_t dt + \sigma dW^2_t, y_0 = 0
        \f]
        and \f$ dW^1_t dW^2_t = \rho dt \f$.

        \bug This class was not tested enough to guarantee
             its functionality.

        \ingroup shortrate
    */
    class G2 : public TwoFactorModel,
               public AffineModel,
               public TermStructureConsistentModel {
      public:
        G2(const Handle<YieldTermStructure>& termStructure,
           Real a = 0.1,
           Real sigma = 0.01,
           Real b = 0.1,
           Real eta = 0.01,
           Real rho = -0.75);

        ext::shared_ptr<ShortRateDynamics> dynamics() const override;

        Real discountBond(Time now, Time maturity, Array factors) const override {
            QL_REQUIRE(factors.size()>1,
                       "g2 model needs two factors to compute discount bond");
            return discountBond(now, maturity, factors[0], factors[1]);
        }

        Real discountBond(Time, Time, Rate, Rate) const;

        Real discountBondOption(Option::Type type,
                                Real strike,
                                Time maturity,
                                Time bondMaturity) const override;

        Real swaption(const Swaption::arguments& arguments,
                      Rate fixedRate,
                      Real range,
                      Size intervals) const;

        DiscountFactor discount(Time t) const override { return termStructure()->discount(t); }

        Real a() const { return a_(0.0); }
        Real sigma() const { return sigma_(0.0); }
        Real b() const { return b_(0.0); }
        Real eta() const { return eta_(0.0); }
        Real rho() const { return rho_(0.0); }

      protected:
        void generateArguments() override;

        Real A(Time t, Time T) const;
        Real B(Real x, Time t) const;

      private:
        class Dynamics;
        class FittingParameter;

        Real sigmaP(Time t, Time s) const;

        Parameter& a_;
        Parameter& sigma_;
        Parameter& b_;
        Parameter& eta_;
        Parameter& rho_;

        Parameter phi_;

        Real V(Time t) const;

        class SwaptionPricingFunction;
    };

    class G2::Dynamics : public TwoFactorModel::ShortRateDynamics {
      public:
        Dynamics(Parameter fitting, Real a, Real sigma, Real b, Real eta, Real rho)
        : ShortRateDynamics(
              ext::shared_ptr<StochasticProcess1D>(new OrnsteinUhlenbeckProcess(a, sigma)),
              ext::shared_ptr<StochasticProcess1D>(new OrnsteinUhlenbeckProcess(b, eta)),
              rho),
          fitting_(std::move(fitting)) {}
        Rate shortRate(Time t, Real x, Real y) const override { return fitting_(t) + x + y; }

      private:
        Parameter fitting_;
    };

    //! Analytical term-structure fitting parameter \f$ \varphi(t) \f$.
    /*! \f$ \varphi(t) \f$ is analytically defined by
        \f[
            \varphi(t) = f(t) +
                 \frac{1}{2}(\frac{\sigma(1-e^{-at})}{a})^2 +
                 \frac{1}{2}(\frac{\eta(1-e^{-bt})}{b})^2 +
                 \rho\frac{\sigma(1-e^{-at})}{a}\frac{\eta(1-e^{-bt})}{b},
        \f]
        where \f$ f(t) \f$ is the instantaneous forward rate at \f$ t \f$.
    */
    class G2::FittingParameter : public TermStructureFittingParameter {
      private:
        class Impl final : public Parameter::Impl {
          public:
            Impl(Handle<YieldTermStructure> termStructure,
                 Real a,
                 Real sigma,
                 Real b,
                 Real eta,
                 Real rho)
            : termStructure_(std::move(termStructure)), a_(a), sigma_(sigma), b_(b), eta_(eta),
              rho_(rho) {}

            Real value(const Array&, Time t) const override {
                Rate forward = termStructure_->forwardRate(t, t,
                                                           Continuous,
                                                           NoFrequency);
                Real temp1 = sigma_*(1.0-std::exp(-a_*t))/a_;
                Real temp2 = eta_*(1.0-std::exp(-b_*t))/b_;
                Real value = 0.5*temp1*temp1 + 0.5*temp2*temp2 +
                    rho_*temp1*temp2 + forward;
                return value;
            }

          private:
            Handle<YieldTermStructure> termStructure_;
            Real a_, sigma_, b_, eta_, rho_;
        };
      public:
        FittingParameter(const Handle<YieldTermStructure>& termStructure,
                         Real a,
                         Real sigma,
                         Real b,
                         Real eta,
                         Real rho)
        : TermStructureFittingParameter(ext::shared_ptr<Parameter::Impl>(
                          new FittingParameter::Impl(termStructure, a, sigma,
                                                     b, eta, rho))) {}
    };

}


#endif

]]></document_content>
  </document>
  <document index="155">
    <source>volatility/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/models/volatility/constantestimator.hpp>
#include <ql/models/volatility/simplelocalestimator.hpp>
#include <ql/models/volatility/garmanklass.hpp>
#include <ql/models/volatility/garch.hpp>

]]></document_content>
  </document>
  <document index="156">
    <source>volatility/constantestimator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file constantestimator.hpp
    \brief Constant volatility estimator
*/

#ifndef quantlib_constant_estimator_hpp
#define quantlib_constant_estimator_hpp

#include <ql/volatilitymodel.hpp>
#include <vector>

namespace QuantLib {

    //! Constant-estimator volatility model
    /*! Volatilities are assumed to be expressed on an annual basis.
    */
    class ConstantEstimator : public VolatilityCompositor {
      private:
        Size size_;
      public:
        ConstantEstimator(Size size)
        : size_(size) {}
        TimeSeries<Volatility> calculate(const TimeSeries<Volatility>&) override;
        void calibrate(const TimeSeries<Volatility>&) override {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="157">
    <source>volatility/garch.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Joseph Wang
 Copyright (C) 2012 Liquidnet Holdings, Inc.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file garch.hpp
    \brief GARCH volatility model
*/

#ifndef quantlib_garch_volatility_model_hpp
#define quantlib_garch_volatility_model_hpp

#include <ql/volatilitymodel.hpp>
#include <ql/math/optimization/problem.hpp>
#include <ql/math/optimization/constraint.hpp>
#include <vector>

namespace QuantLib {

    //! GARCH volatility model
    /*! Volatilities are assumed to be expressed on an annual basis.
    */
    class Garch11 : public VolatilityCompositor {
      public:
        typedef TimeSeries<Volatility> time_series;

        enum Mode {
            MomentMatchingGuess,   /*!< The initial guess is a moment
                                        matching estimates for
                                        mean(r2), acf(0), and acf(1). */
            GammaGuess,            /*!< The initial guess is an
                                        estimate of gamma based on the
                                        property:
                                        acf(i+1) = gamma*acf(i) for i > 1. */
            BestOfTwo,             /*!< The best of the two above modes */
            DoubleOptimization     /*!< Double optimization */
        };

        //! \name Constructors
        //@{
        Garch11(Real a, Real b, Real vl)
        : alpha_(a), beta_(b), gamma_(1 - a - b),
          vl_(vl), logLikelihood_(0), mode_(BestOfTwo) {}

        Garch11(const time_series& qs, Mode mode = BestOfTwo)
        : alpha_(0), beta_(0), vl_(0), logLikelihood_(0), mode_(mode) {
            calibrate(qs);
        };
        //@}

        //! \name Inspectors
        //@{
        Real alpha() const { return alpha_; }
        Real beta() const { return beta_; }
        Real omega() const { return vl_ * gamma_; }
        Real ltVol() const { return vl_; }
        Real logLikelihood() const { return logLikelihood_; }
        Mode mode() const { return mode_; }
        //@}

        //! \name VolatilityCompositor interface
        //@{
        time_series calculate(const time_series& quoteSeries) override {
            return calculate(quoteSeries, alpha(), beta(), omega());
        }
        void calibrate(const time_series& quoteSeries) override {
            const auto values = quoteSeries.values();
            calibrate(values.cbegin(), values.cend());
        }
        //@}

        //! \name Additional interface
        //@{
        static time_series calculate(const time_series& quoteSeries,
                                     Real alpha, Real beta, Real omega);

        void calibrate(const time_series& quoteSeries,
                       OptimizationMethod& method,
                       const EndCriteria& endCriteria) {
            const auto values = quoteSeries.values();
            calibrate(values.cbegin(), values.cend(),
                      method, endCriteria);
        }

        void calibrate(const time_series& quoteSeries,
                       OptimizationMethod& method,
                       const EndCriteria& endCriteria,
                       const Array& initialGuess) {
            const auto values = quoteSeries.values();
            calibrate(values.cbegin(), values.cend(),
                      method, endCriteria, initialGuess);
        }

        template <typename ForwardIterator>
        void calibrate(ForwardIterator begin, ForwardIterator end) {
            std::vector<Volatility> r2;
            Real mean_r2 = to_r2(begin, end, r2);
            ext::shared_ptr<Problem> p =
                calibrate_r2(mode_, r2, mean_r2, alpha_, beta_, vl_);
            gamma_ = 1 - alpha_ - beta_;
            vl_ /= gamma_;
            logLikelihood_ = p ? -p->functionValue() :
                                 -costFunction(begin, end);
        }

        template <typename ForwardIterator>
        void calibrate(ForwardIterator begin, ForwardIterator end,
                       OptimizationMethod& method,
                       EndCriteria endCriteria) {
            std::vector<Volatility> r2;
            Real mean_r2 = to_r2(begin, end, r2);
            ext::shared_ptr<Problem> p =
                calibrate_r2(mode_, r2, mean_r2, method,
                             endCriteria, alpha_, beta_, vl_);
            gamma_ = 1 - alpha_ - beta_;
            vl_ /= gamma_;
            logLikelihood_ = p ? -p->functionValue() :
                                 -costFunction(begin, end);
        }

        template <typename ForwardIterator>
        void calibrate(ForwardIterator begin, ForwardIterator end,
                       OptimizationMethod& method,
                       EndCriteria endCriteria,
                       const Array& initialGuess) {
            std::vector<Volatility> r2;
            to_r2(begin, end, r2);
            ext::shared_ptr<Problem> p =
                calibrate_r2(r2, method, endCriteria, initialGuess,
                             alpha_, beta_, vl_);
            gamma_ = 1 - alpha_ - beta_;
            vl_ /= gamma_;
            logLikelihood_ = p ? -p->functionValue() :
                                 -costFunction(begin, end);
        }

        Real forecast(Real r, Real sigma2) const {
            return gamma_* vl_ + alpha_ * r * r + beta_ * sigma2;
        }

        // a helper for calculation of r^2 and <r^2>
        template <typename InputIterator>
        static Real to_r2(InputIterator begin, InputIterator end,
                          std::vector<Volatility>& r2) {
            Real u2(0.0), mean_r2(0.0), w(1.0);
            for (; begin != end; ++begin) {
                u2 = *begin; u2 *= u2;
                mean_r2 = (1.0 - w) * mean_r2 + w * u2;
                r2.push_back(u2);
                w /= (w + 1.0);
            }
            return mean_r2;
        }

        /*! calibrates GARCH for r^2 */
        static ext::shared_ptr<Problem> calibrate_r2(
                                        Mode mode,
                                        const std::vector<Volatility>& r2,
                                        Real mean_r2,
                                        Real& alpha,
                                        Real& beta,
                                        Real& omega);

        /*! calibrates GARCH for r^2 with user-defined optimization
            method and end criteria */
        static ext::shared_ptr<Problem> calibrate_r2(
                                        Mode mode,
                                        const std::vector<Volatility>& r2,
                                        Real mean_r2,
                                        OptimizationMethod& method,
                                        const EndCriteria& endCriteria,
                                        Real& alpha,
                                        Real& beta,
                                        Real& omega);

        /*! calibrates GARCH for r^2 with user-defined optimization
            method, end criteria and initial guess */
        static ext::shared_ptr<Problem> calibrate_r2(
                                        const std::vector<Volatility>& r2,
                                        Real mean_r2,
                                        OptimizationMethod& method,
                                        const EndCriteria& endCriteria,
                                        const Array& initialGuess,
                                        Real& alpha,
                                        Real& beta,
                                        Real& omega);

        /*! calibrates GARCH for r^2 with user-defined optimization
            method, end criteria and initial guess */
        static ext::shared_ptr<Problem> calibrate_r2(
                                        const std::vector<Volatility> &r2,
                                        OptimizationMethod& method,
                                        const EndCriteria& endCriteria,
                                        const Array& initialGuess,
                                        Real& alpha,
                                        Real& beta,
                                        Real& omega);

        /*! calibrates GARCH for r^2 with user-defined optimization
            method, end criteria, constraints and initial guess */
        static ext::shared_ptr<Problem> calibrate_r2(
                                        const std::vector<Volatility>& r2,
                                        Real mean_r2,
                                        OptimizationMethod& method,
                                        Constraint& constraints,
                                        const EndCriteria& endCriteria,
                                        const Array& initialGuess,
                                        Real& alpha,
                                        Real& beta,
                                        Real& omega);

        static ext::shared_ptr<Problem> calibrate_r2(
                                        const std::vector<Volatility> &r2,
                                        OptimizationMethod& method,
                                        Constraint& constraints,
                                        const EndCriteria& endCriteria,
                                        const Array& initialGuess,
                                        Real& alpha,
                                        Real& beta,
                                        Real& omega);

        template<class InputIterator>
        static Real costFunction(InputIterator begin, InputIterator end,
                                 Real alpha, Real beta, Real omega) {
            Real retval(0.0);
            Real u2(0.0), sigma2(0.0);
            Size N = 0;
            for (; begin != end; ++begin, ++N) {
                sigma2 = omega + alpha * u2 + beta * sigma2;
                u2 = *begin; u2 *= u2;
                retval += std::log(sigma2) + u2 / sigma2;
            }
            return N > 0 ? Real(retval / (2*N)) : 0.0;
        }
        //@}
      private:
        Real alpha_, beta_, gamma_, vl_;
        Real logLikelihood_;
        Mode mode_;

        template<class InputIterator>
        Real costFunction(InputIterator begin, InputIterator end) const {
            return costFunction(begin, end, alpha(), beta(), omega());
        }
    };

}


#endif
]]></document_content>
  </document>
  <document index="158">
    <source>volatility/garmanklass.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file garmanklass.hpp
    \brief Volatility estimators using high low data
*/

#ifndef quantlib_garman_klass_hpp
#define quantlib_garman_klass_hpp

#include <ql/volatilitymodel.hpp>
#include <ql/prices.hpp>

namespace QuantLib {

    //! Garman-Klass volatility model
    /*! This class implements a concrete volatility model based on
        high low formulas using the method of Garman and Klass in
        their paper "On the Estimation of the Security Price from
        Historical Data" at
        http://www.fea.com/resources/pdf/a_estimation_of_security_price.pdf

        Volatilities are assumed to be expressed on an annual basis.
    */
    class GarmanKlassAbstract :
        public LocalVolatilityEstimator<IntervalPrice> {
    protected:
        Real yearFraction_;
        virtual Real calculatePoint(const IntervalPrice &p) = 0;
    public:
        explicit GarmanKlassAbstract(Real y) :
        yearFraction_(y) {}
        TimeSeries<Volatility> calculate(const TimeSeries<IntervalPrice>& quoteSeries) override {
            TimeSeries<Volatility> retval;
            TimeSeries<IntervalPrice>::const_iterator prev, next, cur, start;
            start = quoteSeries.begin();
            for (cur = start; cur != quoteSeries.end(); ++cur) {
                retval[cur->first] =
                    std::sqrt(std::fabs(calculatePoint(cur->second))/
                              yearFraction_);
            }
            return retval;
        }
    };

    class GarmanKlassSimpleSigma :
        public GarmanKlassAbstract {
    public:
        GarmanKlassSimpleSigma(Real y) :
            GarmanKlassAbstract(y) {};
    protected:
      Real calculatePoint(const IntervalPrice& p) override {
          Real c = std::log(p.close() / p.open());
          return c * c;
      }
    };

    /* This template factors out common functionality found in
       classes which rely on the difference between the previous day's
       close price and today's open price. */
    template <class T>
    class GarmanKlassOpenClose : public T {
    protected:
        Real f_;
        Real a_;
    public:
        GarmanKlassOpenClose(Real y, Real marketOpenFraction,
                             Real a) :
        T(y), f_(marketOpenFraction), a_(a) {};
        TimeSeries<Volatility> calculate(const TimeSeries<IntervalPrice>& quoteSeries) override {
            TimeSeries<Volatility> retval;
            TimeSeries<IntervalPrice>::const_iterator prev, next, cur, start;
            start = quoteSeries.begin();
            ++start;
            for (cur = start; cur != quoteSeries.end(); ++cur) {
                prev = cur; --prev;
                Real c0 = std::log(prev->second.close());
                Real o1 = std::log(cur->second.open());
                Real sigma2 =
                    a_ * (o1 - c0) * (o1 - c0) / f_ +
                    (1-a_) * T::calculatePoint(cur->second) /
                    (1-f_);

                retval[cur->first] = std::sqrt(sigma2/T::yearFraction_);
            }
            return retval;
        }
    };


    class GarmanKlassSigma1 :
        public GarmanKlassOpenClose<GarmanKlassSimpleSigma> {
    public:
        GarmanKlassSigma1(Real y, Real marketOpenFraction) :
            GarmanKlassOpenClose<GarmanKlassSimpleSigma>(y,
                                                         marketOpenFraction,
                                                         0.5) {};
    };


    class ParkinsonSigma :
        public GarmanKlassAbstract {
    public:
        ParkinsonSigma(Real y) :
            GarmanKlassAbstract(y) {};
    protected:
      Real calculatePoint(const IntervalPrice& p) override {
          Real u = std::log(p.high() / p.open());
          Real d = std::log(p.low() / p.open());
          return (u - d) * (u - d) / 4.0 / std::log(2.0);
      }
    };


    class GarmanKlassSigma3 :
        public GarmanKlassOpenClose<ParkinsonSigma> {
    public:
        GarmanKlassSigma3(Real y, Real marketOpenFraction) :
            GarmanKlassOpenClose<ParkinsonSigma>(y,
                                                 marketOpenFraction,
                                                 0.17) {};
    };



    class GarmanKlassSigma4 :
        public GarmanKlassAbstract {
    public:
        GarmanKlassSigma4(Real y) :
            GarmanKlassAbstract(y) {};
    protected:
      Real calculatePoint(const IntervalPrice& p) override {
          Real u = std::log(p.high() / p.open());
          Real d = std::log(p.low() / p.open());
          Real c = std::log(p.close() / p.open());
          return 0.511 * (u - d) * (u - d) - 0.019 * (c * (u + d) - 2 * u * d) - 0.383 * c * c;
      }
    };

    class GarmanKlassSigma5 :
        public GarmanKlassAbstract {
    public:
        GarmanKlassSigma5(Real y) :
            GarmanKlassAbstract(y) {};
    protected:
      Real calculatePoint(const IntervalPrice& p) override {
          Real u = std::log(p.high() / p.open());
          Real d = std::log(p.low() / p.open());
          Real c = std::log(p.close() / p.open());
          return 0.5 * (u - d) * (u - d) - (2.0 * std::log(2.0) - 1.0) * c * c;
      }
    };

    class GarmanKlassSigma6 :
        public GarmanKlassOpenClose<GarmanKlassSigma4> {
    public:
        GarmanKlassSigma6(Real y, Real marketOpenFraction) :
        GarmanKlassOpenClose<GarmanKlassSigma4>(y,
                                                marketOpenFraction,
                                                0.012) {};
    };
}


#endif
]]></document_content>
  </document>
  <document index="159">
    <source>volatility/simplelocalestimator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file simplelocalestimator.hpp
    \brief Constant volatility estimator
*/

#ifndef quantlib_simple_local_estimator_hpp
#define quantlib_simple_local_estimator_hpp

#include <ql/volatilitymodel.hpp>
#include <map>

namespace QuantLib {

    //! Local-estimator volatility model
    /*! Volatilities are assumed to be expressed on an annual basis.
    */
    class SimpleLocalEstimator :
        public LocalVolatilityEstimator<Real> {
    private:
        Real yearFraction_;
      public:
        SimpleLocalEstimator(Real y) :
        yearFraction_(y) {}
        TimeSeries<Volatility> calculate(const TimeSeries<Real>& quoteSeries) override {
            TimeSeries<Volatility> retval;
            TimeSeries<Real>::const_iterator prev, next, cur, start;
            start = quoteSeries.begin();
            ++start;
            for (cur = start; cur != quoteSeries.end(); ++cur) {
                prev = cur; --prev;
                retval[cur->first] =
                    std::fabs(std::log(cur->second/prev->second))/
                    std::sqrt(yearFraction_);
            }
            return retval;
        }
    };

}


#endif
]]></document_content>
  </document>
</documents>