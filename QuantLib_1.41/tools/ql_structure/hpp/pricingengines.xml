<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/pricingengines/americanpayoffatexpiry.hpp>
#include <ql/pricingengines/americanpayoffathit.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/pricingengines/blackdeltacalculator.hpp>
#include <ql/pricingengines/bacheliercalculator.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/pricingengines/blackscholescalculator.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/pricingengines/greeks.hpp>
#include <ql/pricingengines/latticeshortratemodelengine.hpp>
#include <ql/pricingengines/mclongstaffschwartzengine.hpp>
#include <ql/pricingengines/mcsimulation.hpp>

#include <ql/pricingengines/asian/all.hpp>
#include <ql/pricingengines/barrier/all.hpp>
#include <ql/pricingengines/basket/all.hpp>
#include <ql/pricingengines/bond/all.hpp>
#include <ql/pricingengines/capfloor/all.hpp>
#include <ql/pricingengines/cliquet/all.hpp>
#include <ql/pricingengines/credit/all.hpp>
#include <ql/pricingengines/exotic/all.hpp>
#include <ql/pricingengines/forward/all.hpp>
#include <ql/pricingengines/futures/all.hpp>
#include <ql/pricingengines/inflation/all.hpp>
#include <ql/pricingengines/lookback/all.hpp>
#include <ql/pricingengines/quanto/all.hpp>
#include <ql/pricingengines/swap/all.hpp>
#include <ql/pricingengines/swaption/all.hpp>
#include <ql/pricingengines/vanilla/all.hpp>
]]></document_content>
  </document>
  <document index="2">
    <source>americanpayoffatexpiry.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file americanpayoffatexpiry.hpp
    \brief Analytical formulae for american exercise with payoff at expiry
*/

#ifndef quantlib_americanpayoffatexpiry_h
#define quantlib_americanpayoffatexpiry_h

#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    //! Analytic formula for American exercise payoff at-expiry options
    /*! \todo calculate greeks */
    class AmericanPayoffAtExpiry {
      public:
        AmericanPayoffAtExpiry(
                          Real spot,
                          DiscountFactor discount,
                          DiscountFactor dividendDiscount,
                          Real variance,
                          const ext::shared_ptr<StrikedTypePayoff>& payoff,
                          bool knock_in = true);
        Real value() const;
      private:
        Real spot_;
        DiscountFactor discount_, dividendDiscount_;
        Real variance_;

        Real forward_;
        Volatility stdDev_;

        Real strike_, K_;

        Real mu_, log_H_S_;

        Real D1_, D2_, cum_d1_, cum_d2_, n_d1_, n_d2_;

        bool inTheMoney_;
        Real Y_, X_;
        bool knock_in_;
    };


    // inline definitions

    inline Real AmericanPayoffAtExpiry::value() const {
        return discount_ * K_ * (X_ * cum_d1_ + Y_ * cum_d2_);
    }

}


#endif
]]></document_content>
  </document>
  <document index="3">
    <source>americanpayoffathit.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file americanpayoffathit.hpp
    \brief Analytical formulae for american exercise with payoff at hit
*/

#ifndef quantlib_americanpayoffathit_h
#define quantlib_americanpayoffathit_h

#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    //! Analytic formula for American exercise payoff at-hit options
    /*! \todo calculate greeks */
    class AmericanPayoffAtHit {
      public:
        AmericanPayoffAtHit(
                          Real spot,
                          DiscountFactor discount,
                          DiscountFactor dividendDiscount,
                          Real variance,
                          const ext::shared_ptr<StrikedTypePayoff>& payoff);
        Real value() const;
        Real delta() const;
        Real gamma() const;
        Real rho(Time maturity) const;
      private:
        Real spot_;
        DiscountFactor discount_, dividendDiscount_;
        Real variance_;
        Volatility stdDev_;

        Real strike_, K_, DKDstrike_;

        Real mu_, lambda_, muPlusLambda_, muMinusLambda_, log_H_S_;

        Real D1_, D2_, cum_d1_, cum_d2_;

        Real alpha_, beta_, DalphaDd1_, DbetaDd2_;

        bool inTheMoney_;
        Real forward_, X_, DXDstrike_;
    };


    // inline definitions

    inline Real AmericanPayoffAtHit::value() const {
        return K_ * (forward_ * alpha_ + X_ * beta_);
    }

}


#endif
]]></document_content>
  </document>
  <document index="4">
    <source>asian/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/pricingengines/asian/analytic_cont_geom_av_price.hpp>
#include <ql/pricingengines/asian/analytic_discr_geom_av_price.hpp>
#include <ql/pricingengines/asian/analytic_discr_geom_av_strike.hpp>
#include <ql/pricingengines/asian/choiasianengine.hpp>
#include <ql/pricingengines/asian/continuousarithmeticasianlevyengine.hpp>
#include <ql/pricingengines/asian/fdblackscholesasianengine.hpp>
#include <ql/pricingengines/asian/mc_discr_arith_av_price.hpp>
#include <ql/pricingengines/asian/mc_discr_arith_av_price_heston.hpp>
#include <ql/pricingengines/asian/mc_discr_arith_av_strike.hpp>
#include <ql/pricingengines/asian/mc_discr_geom_av_price.hpp>
#include <ql/pricingengines/asian/mc_discr_geom_av_price_heston.hpp>
#include <ql/pricingengines/asian/mcdiscreteasianenginebase.hpp>
#include <ql/pricingengines/asian/turnbullwakemanasianengine.hpp>

]]></document_content>
  </document>
  <document index="5">
    <source>asian/analytic_cont_geom_av_price.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analytic_cont_geom_av_price.hpp
    \brief Analytic engine for continuous geometric average price Asian
*/

#ifndef quantlib_analytic_continuous_geometric_average_price_asian_engine_hpp
#define quantlib_analytic_continuous_geometric_average_price_asian_engine_hpp

#include <ql/instruments/asianoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Pricing engine for European continuous geometric average price Asian
    /*! This class implements a continuous geometric average price
        Asian option with European exercise.  The formula is from
        "Option Pricing Formulas", E. G. Haug (1997) pag 96-97.

        \ingroup asianengines

        \test
        - the correctness of the returned value is tested by
          reproducing results available in literature, and results
          obtained using a discrete average approximation.
        - the correctness of the returned greeks is tested by
          reproducing numerical derivatives.

        \todo handle seasoned options
    */
    class AnalyticContinuousGeometricAveragePriceAsianEngine
        : public ContinuousAveragingAsianOption::engine {
      public:
        AnalyticContinuousGeometricAveragePriceAsianEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="6">
    <source>asian/analytic_discr_geom_av_price.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analytic_discr_geom_av_price.hpp
    \brief Analytic engine for discrete geometric average price Asian
*/

#ifndef quantlib_analytic_discrete_geometric_average_price_asian_engine_hpp
#define quantlib_analytic_discrete_geometric_average_price_asian_engine_hpp

#include <ql/instruments/asianoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Pricing engine for European discrete geometric average price Asian
    /*! This class implements a discrete geometric average price Asian
        option, with European exercise.  The formula is from "Asian
        Option", E. Levy (1997) in "Exotic Options: The State of the
        Art", edited by L. Clewlow, C. Strickland, pag 65-97

        \todo implement correct theta, rho, and dividend-rho calculation

        \test
        - the correctness of the returned value is tested by
          reproducing results available in literature.
        - the correctness of the available greeks is tested against
          numerical calculations.

        \ingroup asianengines
    */
    class AnalyticDiscreteGeometricAveragePriceAsianEngine
        : public DiscreteAveragingAsianOption::engine {
      public:
        AnalyticDiscreteGeometricAveragePriceAsianEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="7">
    <source>asian/analytic_discr_geom_av_strike.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analytic_discr_geom_av_strike.hpp
    \brief Analytic engine for discrete geometric average-strike Asian option
*/

#ifndef quantlib_analytic_discrete_geometric_average_strike_asian_engine_hpp
#define quantlib_analytic_discrete_geometric_average_strike_asian_engine_hpp

#include <ql/instruments/asianoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Pricing engine for European discrete geometric average-strike Asian option
    /*! This class implements a discrete geometric average-strike Asian
        option, with European exercise.  The formula is from "Asian
        Option", E. Levy (1997) in "Exotic Options: The State of the
        Art", edited by L. Clewlow, C. Strickland, pag 65-97

        \test
        - the correctness of the returned value is tested by
          reproducing known good results.

        \ingroup asianengines
    */

    class AnalyticDiscreteGeometricAverageStrikeAsianEngine
        : public DiscreteAveragingAsianOption::engine{
      public:
        AnalyticDiscreteGeometricAverageStrikeAsianEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="8">
    <source>asian/choiasianengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2025 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file choiasianengine.hpp
    \brief Black Scholes arithmetic Asian option engine
*/

#ifndef quantlib_choi_asian_engine_hpp
#define quantlib_choi_asian_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/instruments/asianoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {
    //! Pricing engine for arithmetic Asian options
    /*! This class replicates an arithmetic Asian option using a basket option.
        The pricing of an arithmetic Asian option is substituted with the pricing
        of a basket option.
    */
        
    /*! References:
        "Sum of all Black-Scholes-Merton Models: An efficient Pricing Method for
        Spread, Basket and Asian Options", Jaehyuk Choi, 2018
        https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2913048

        A Python implementation from the author of the paper is also available
        https://github.com/PyFE/PyFENG

        \ingroup asianengines
    */
    
    class ChoiAsianEngine : public DiscreteAveragingAsianOption::engine {
      public:
        explicit ChoiAsianEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> p,
            Real lambda = 15,
            Size maxNrIntegrationSteps = 2 << 21);

        void calculate() const override;

      private:
        const ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        const Real lambda_;
        const Size maxNrIntegrationSteps_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="9">
    <source>asian/continuousarithmeticasianlevyengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file continuousarithmeticasianlevyengine.hpp
    \brief Levy engine for continuous arithmetic Asian options
*/

#ifndef quantlib_continuous_arithmetic_asian_levy_engine_hpp
#define quantlib_continuous_arithmetic_asian_levy_engine_hpp

#include <ql/instruments/asianoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Levy engine for continuously averaged arithmetic Asian options
    /*! Formulas from Haug, "Option Pricing Formulas".
        \ingroup asianengines
    */
    class ContinuousArithmeticAsianLevyEngine
        : public ContinuousAveragingAsianOption::engine {
      public:
        ContinuousArithmeticAsianLevyEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                                            Handle<Quote> currentAverage);

        /*! \deprecated Use the other constructor and pass the start date to the option instead.
                        Deprecated in version 1.41.
        */
        [[deprecated("Use the other constructor and pass the start date to the option instead")]]
        ContinuousArithmeticAsianLevyEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                                            Handle<Quote> currentAverage,
                                            Date startDate);

        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Handle<Quote> currentAverage_ ;
        Date startDate_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="10">
    <source>asian/fdblackscholesasianengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Ralph Schreyer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdblackscholesasianengine.hpp
    \brief Finite-Differences Black Scholes arithmentic asian option engine
*/

#ifndef quantlib_fd_black_scholes_asian_engine_hpp
#define quantlib_fd_black_scholes_asian_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/instruments/asianoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    //! Finite-Differences Black Scholes arithmetic asian option engine

    /*! \ingroup asianengines
    */

    class GeneralizedBlackScholesProcess;
    
    class FdBlackScholesAsianEngine
        : public GenericEngine<DiscreteAveragingAsianOption::arguments,
                               DiscreteAveragingAsianOption::results> {
      public:
        // Constructor
        explicit FdBlackScholesAsianEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess>,
            Size tGrid = 100,
            Size xGrid = 100,
            Size aGrid = 50,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas());

        void calculate() const override;

      private:
        const ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        const Size tGrid_, xGrid_, aGrid_;
        const FdmSchemeDesc schemeDesc_;
    };


}

#endif
]]></document_content>
  </document>
  <document index="11">
    <source>asian/mc_discr_arith_av_price.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mc_discr_arith_av_price.hpp
    \brief Monte Carlo engine for discrete arithmetic average price Asian
*/

#ifndef quantlib_mc_discrete_arithmetic_average_price_asian_engine_hpp
#define quantlib_mc_discrete_arithmetic_average_price_asian_engine_hpp

#include <ql/exercise.hpp>
#include <ql/pricingengines/asian/analytic_discr_geom_av_price.hpp>
#include <ql/pricingengines/asian/mc_discr_geom_av_price.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    //!  Monte Carlo pricing engine for discrete arithmetic average price Asian
    /*!  Monte Carlo pricing engine for discrete arithmetic average price
         Asian options. It can use MCDiscreteGeometricAPEngine (Monte Carlo
         discrete arithmetic average price engine) and
         AnalyticDiscreteGeometricAveragePriceAsianEngine (analytic discrete
         arithmetic average price engine) for control variation.

         \ingroup asianengines

         \test the correctness of the returned value is tested by
               reproducing results available in literature.
    */
    template <class RNG = PseudoRandom, class S = Statistics>
    class MCDiscreteArithmeticAPEngine
        : public MCDiscreteAveragingAsianEngineBase<SingleVariate,RNG,S> {
      public:
        typedef
        typename MCDiscreteAveragingAsianEngineBase<SingleVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef
        typename MCDiscreteAveragingAsianEngineBase<SingleVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename MCDiscreteAveragingAsianEngineBase<SingleVariate,RNG,S>::stats_type
            stats_type;
        // constructor
        MCDiscreteArithmeticAPEngine(
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             bool brownianBridge,
             bool antitheticVariate,
             bool controlVariate,
             Size requiredSamples,
             Real requiredTolerance,
             Size maxSamples,
             BigNatural seed);
      protected:
        ext::shared_ptr<path_pricer_type> pathPricer() const override;
        ext::shared_ptr<path_pricer_type> controlPathPricer() const override;
        ext::shared_ptr<PricingEngine> controlPricingEngine() const override {
            ext::shared_ptr<GeneralizedBlackScholesProcess> process =
                ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                    this->process_);
            QL_REQUIRE(process, "Black-Scholes process required");
            return ext::shared_ptr<PricingEngine>(new
                AnalyticDiscreteGeometricAveragePriceAsianEngine(process));
        }
    };


    class ArithmeticAPOPathPricer : public PathPricer<Path> {
      public:
        ArithmeticAPOPathPricer(Option::Type type,
                                Real strike,
                                DiscountFactor discount,
                                Real runningSum = 0.0,
                                Size pastFixings = 0);
        Real operator()(const Path& path) const override;

      private:
        PlainVanillaPayoff payoff_;
        DiscountFactor discount_;
        Real runningSum_;
        Size pastFixings_;
    };


    // inline definitions

    template <class RNG, class S>
    inline
    MCDiscreteArithmeticAPEngine<RNG,S>::MCDiscreteArithmeticAPEngine(
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             bool brownianBridge,
             bool antitheticVariate,
             bool controlVariate,
             Size requiredSamples,
             Real requiredTolerance,
             Size maxSamples,
             BigNatural seed)
    : MCDiscreteAveragingAsianEngineBase<SingleVariate,RNG,S>(process,
                                                              brownianBridge,
                                                              antitheticVariate,
                                                              controlVariate,
                                                              requiredSamples,
                                                              requiredTolerance,
                                                              maxSamples,
                                                              seed) {}

    template <class RNG, class S>
    inline
    ext::shared_ptr<
            typename MCDiscreteArithmeticAPEngine<RNG,S>::path_pricer_type>
        MCDiscreteArithmeticAPEngine<RNG,S>::pathPricer() const {

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                this->arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(
                this->arguments_.exercise);
        QL_REQUIRE(exercise, "wrong exercise given");

        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                this->process_);
        QL_REQUIRE(process, "Black-Scholes process required");

        return ext::shared_ptr<typename
            MCDiscreteArithmeticAPEngine<RNG,S>::path_pricer_type>(
                new ArithmeticAPOPathPricer(
                    payoff->optionType(),
                    payoff->strike(),
                    process->riskFreeRate()->discount(exercise->lastDate()),
                    this->arguments_.runningAccumulator,
                    this->arguments_.pastFixings));
    }

    template <class RNG, class S>
    inline
    ext::shared_ptr<
            typename MCDiscreteArithmeticAPEngine<RNG,S>::path_pricer_type>
        MCDiscreteArithmeticAPEngine<RNG,S>::controlPathPricer() const {

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                this->arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(
                this->arguments_.exercise);
        QL_REQUIRE(exercise, "wrong exercise given");

        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                this->process_);
        QL_REQUIRE(process, "Black-Scholes process required");

        // for seasoned option the geometric strike might be rescaled
        // to obtain an equivalent arithmetic strike.
        // Any change applied here MUST be applied to the analytic engine too
        return ext::shared_ptr<typename
            MCDiscreteArithmeticAPEngine<RNG,S>::path_pricer_type>(
            new GeometricAPOPathPricer(
              payoff->optionType(),
              payoff->strike(),
              process->riskFreeRate()->discount(this->timeGrid().back())));
    }

    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCDiscreteArithmeticAPEngine {
      public:
        explicit MakeMCDiscreteArithmeticAPEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        // named parameters
        MakeMCDiscreteArithmeticAPEngine& withBrownianBridge(bool b = true);
        MakeMCDiscreteArithmeticAPEngine& withSamples(Size samples);
        MakeMCDiscreteArithmeticAPEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCDiscreteArithmeticAPEngine& withMaxSamples(Size samples);
        MakeMCDiscreteArithmeticAPEngine& withSeed(BigNatural seed);
        MakeMCDiscreteArithmeticAPEngine& withAntitheticVariate(bool b = true);
        MakeMCDiscreteArithmeticAPEngine& withControlVariate(bool b = true);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        bool antithetic_ = false, controlVariate_ = false;
        Size samples_, maxSamples_;
        Real tolerance_;
        bool brownianBridge_ = true;
        BigNatural seed_ = 0;
    };

    template <class RNG, class S>
    inline MakeMCDiscreteArithmeticAPEngine<RNG, S>::MakeMCDiscreteArithmeticAPEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)), samples_(Null<Size>()), maxSamples_(Null<Size>()),
      tolerance_(Null<Real>()) {}

    template <class RNG, class S>
    inline MakeMCDiscreteArithmeticAPEngine<RNG,S>&
    MakeMCDiscreteArithmeticAPEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDiscreteArithmeticAPEngine<RNG,S>&
    MakeMCDiscreteArithmeticAPEngine<RNG,S>::withAbsoluteTolerance(
                                                             Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDiscreteArithmeticAPEngine<RNG,S>&
    MakeMCDiscreteArithmeticAPEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDiscreteArithmeticAPEngine<RNG,S>&
    MakeMCDiscreteArithmeticAPEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDiscreteArithmeticAPEngine<RNG,S>&
    MakeMCDiscreteArithmeticAPEngine<RNG,S>::withBrownianBridge(bool b) {
        brownianBridge_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDiscreteArithmeticAPEngine<RNG,S>&
    MakeMCDiscreteArithmeticAPEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDiscreteArithmeticAPEngine<RNG,S>&
    MakeMCDiscreteArithmeticAPEngine<RNG,S>::withControlVariate(bool b) {
        controlVariate_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCDiscreteArithmeticAPEngine<RNG,S>::operator ext::shared_ptr<PricingEngine>()
                                                                      const {
        return ext::shared_ptr<PricingEngine>(new
            MCDiscreteArithmeticAPEngine<RNG,S>(process_,
                                                brownianBridge_,
                                                antithetic_, controlVariate_,
                                                samples_, tolerance_,
                                                maxSamples_,
                                                seed_));
    }



}


#endif
]]></document_content>
  </document>
  <document index="12">
    <source>asian/mc_discr_arith_av_price_heston.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mc_discr_arith_av_price_heston.hpp
    \brief Heston MC engine for discrete arithmetic average price Asian
*/

#ifndef quantlib_mc_discrete_arithmetic_average_price_asian_heston_engine_hpp
#define quantlib_mc_discrete_arithmetic_average_price_asian_heston_engine_hpp

#include <ql/exercise.hpp>
#include <ql/experimental/asian/analytic_discr_geom_av_price_heston.hpp>
#include <ql/pricingengines/asian/mc_discr_geom_av_price_heston.hpp>
#include <ql/pricingengines/asian/mcdiscreteasianenginebase.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <utility>

namespace QuantLib {

    //!  Heston MC pricing engine for discrete arithmetic average price Asian
    /*!
         By default, the MC discretization will use 1 time step per fixing date, but
         this can be controlled via timeSteps or timeStepsPerYear parameter, which
         will provide additional timesteps. The grid tries to space as evenly as it
         can and does not guarantee to match an exact number of steps, the precise
         grid used can be found in results_.additionalResults["TimeGrid"]

         Some performance metrics/graphs for the Control Variate are shown in the
         pull request: https://github.com/lballabio/QuantLib/pull/966

         \ingroup asianengines
         \test the correctness of the returned value is tested by
               reproducing results available in literature.
    */
    template <class RNG = PseudoRandom,
              class S = Statistics, class P = HestonProcess>
    class MCDiscreteArithmeticAPHestonEngine
        : public MCDiscreteAveragingAsianEngineBase<MultiVariate,RNG,S> {
      public:
        typedef typename MCDiscreteAveragingAsianEngineBase<MultiVariate,RNG,S>::path_generator_type path_generator_type;
        typedef typename MCDiscreteAveragingAsianEngineBase<MultiVariate,RNG,S>::path_pricer_type path_pricer_type;
        typedef typename MCDiscreteAveragingAsianEngineBase<MultiVariate,RNG,S>::stats_type stats_type;
        // constructor
        MCDiscreteArithmeticAPHestonEngine(
             const ext::shared_ptr<P>& process,
             bool antitheticVariate,
             Size requiredSamples,
             Real requiredTolerance,
             Size maxSamples,
             BigNatural seed,
             Size timeSteps = Null<Size>(),
             Size timeStepsPerYear = Null<Size>(),
             bool controlVariate = false);
      protected:
        ext::shared_ptr<path_pricer_type> pathPricer() const override;

        // Use the experimental analytic geometric asian option as a control variate.
        ext::shared_ptr<path_pricer_type> controlPathPricer() const override;
        ext::shared_ptr<PricingEngine> controlPricingEngine() const override {
            ext::shared_ptr<P> process = ext::dynamic_pointer_cast<P>(this->process_);
            QL_REQUIRE(process, "Heston-like process required");

            return ext::shared_ptr<PricingEngine>(new
                AnalyticDiscreteGeometricAveragePriceAsianHestonEngine(process));
        }
    };


    template <class RNG = PseudoRandom,
              class S = Statistics, class P = HestonProcess>
    class MakeMCDiscreteArithmeticAPHestonEngine {
      public:
        explicit MakeMCDiscreteArithmeticAPHestonEngine(ext::shared_ptr<P> process);
        // named parameters
        MakeMCDiscreteArithmeticAPHestonEngine& withSamples(Size samples);
        MakeMCDiscreteArithmeticAPHestonEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCDiscreteArithmeticAPHestonEngine& withMaxSamples(Size samples);
        MakeMCDiscreteArithmeticAPHestonEngine& withSeed(BigNatural seed);
        MakeMCDiscreteArithmeticAPHestonEngine& withAntitheticVariate(bool b = true);
        MakeMCDiscreteArithmeticAPHestonEngine& withSteps(Size steps);
        MakeMCDiscreteArithmeticAPHestonEngine& withStepsPerYear(Size steps);
        MakeMCDiscreteArithmeticAPHestonEngine& withControlVariate(bool b = false);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<P> process_;
        bool antithetic_ = false, controlVariate_ = false;
        Size samples_, maxSamples_, steps_, stepsPerYear_;
        Real tolerance_;
        BigNatural seed_ = 0;
    };


    class ArithmeticAPOHestonPathPricer : public PathPricer<MultiPath> {
      public:
        ArithmeticAPOHestonPathPricer(Option::Type type,
                                      Real strike,
                                      DiscountFactor discount,
                                      std::vector<Size> fixingIndices,
                                      Real runningSum = 0.0,
                                      Size pastFixings = 0);
        Real operator()(const MultiPath& multiPath) const override;

      private:
        PlainVanillaPayoff payoff_;
        DiscountFactor discount_;
        std::vector<Size> fixingIndices_;
        Real runningSum_;
        Size pastFixings_;
    };


    // inline definitions

    template <class RNG, class S, class P>
    inline
    MCDiscreteArithmeticAPHestonEngine<RNG,S,P>::MCDiscreteArithmeticAPHestonEngine(
             const ext::shared_ptr<P>& process,
             bool antitheticVariate,
             Size requiredSamples,
             Real requiredTolerance,
             Size maxSamples,
             BigNatural seed,
             Size timeSteps,
             Size timeStepsPerYear,
             bool controlVariate)
    : MCDiscreteAveragingAsianEngineBase<MultiVariate,RNG,S>(process,
                                                             false,
                                                             antitheticVariate,
                                                             controlVariate,
                                                             requiredSamples,
                                                             requiredTolerance,
                                                             maxSamples,
                                                             seed,
                                                             timeSteps,
                                                             timeStepsPerYear) {
        QL_REQUIRE(timeSteps == Null<Size>() || timeStepsPerYear == Null<Size>(),
                   "both time steps and time steps per year were provided");
    }

    template <class RNG, class S, class P>
    inline ext::shared_ptr<
            typename MCDiscreteArithmeticAPHestonEngine<RNG,S,P>::path_pricer_type>
        MCDiscreteArithmeticAPHestonEngine<RNG,S,P>::pathPricer() const {

        // Keep track of the fixing indices, the path pricer will need to sum only these
        TimeGrid timeGrid = this->timeGrid();
        std::vector<Time> fixingTimes = timeGrid.mandatoryTimes();
        std::vector<Size> fixingIndexes;
        fixingIndexes.reserve(fixingTimes.size());
        for (Real fixingTime : fixingTimes) {
            fixingIndexes.push_back(timeGrid.closestIndex(fixingTime));
        }

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                this->arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(
                this->arguments_.exercise);
        QL_REQUIRE(exercise, "wrong exercise given");

        ext::shared_ptr<P> process =
            ext::dynamic_pointer_cast<P>(this->process_);
        QL_REQUIRE(process, "Heston like process required");

        return ext::shared_ptr<typename
            MCDiscreteArithmeticAPHestonEngine<RNG,S,P>::path_pricer_type>(
                new ArithmeticAPOHestonPathPricer(
                    payoff->optionType(),
                    payoff->strike(),
                    process->riskFreeRate()->discount(exercise->lastDate()),
                    fixingIndexes,
                    this->arguments_.runningAccumulator,
                    this->arguments_.pastFixings));
    }

    template <class RNG, class S, class P>
    inline ext::shared_ptr<
            typename MCDiscreteArithmeticAPHestonEngine<RNG,S,P>::path_pricer_type>
        MCDiscreteArithmeticAPHestonEngine<RNG,S,P>::controlPathPricer() const {

        // Keep track of the fixing indices, the path pricer will need to prod only these
        TimeGrid timeGrid = this->timeGrid();
        std::vector<Time> fixingTimes = timeGrid.mandatoryTimes();
        std::vector<Size> fixingIndexes;
        fixingIndexes.reserve(fixingTimes.size());
        for (Real fixingTime : fixingTimes) {
            fixingIndexes.push_back(timeGrid.closestIndex(fixingTime));
        }

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                this->arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(
                this->arguments_.exercise);
        QL_REQUIRE(exercise, "wrong exercise given");

        ext::shared_ptr<P> process =
            ext::dynamic_pointer_cast<P>(this->process_);
        QL_REQUIRE(process, "Heston like process required");

        // TODO: Currently the analytic pricer does not support seasoned asian
        // options (coming soon). Once that is available, we will be able to
        // pass seasoning details to the path pricer (NB. NEED to pass them to
        // the analytic pricer as well in that case).

        return ext::shared_ptr<typename
            MCDiscreteArithmeticAPHestonEngine<RNG,S,P>::path_pricer_type>(
                new GeometricAPOHestonPathPricer(
                    payoff->optionType(),
                    payoff->strike(),
                    process->riskFreeRate()->discount(exercise->lastDate()),
                    fixingIndexes));
    }

    template <class RNG, class S, class P>
    inline MakeMCDiscreteArithmeticAPHestonEngine<RNG, S, P>::
        MakeMCDiscreteArithmeticAPHestonEngine(ext::shared_ptr<P> process)
    : process_(std::move(process)), samples_(Null<Size>()), maxSamples_(Null<Size>()),
      steps_(Null<Size>()), stepsPerYear_(Null<Size>()), tolerance_(Null<Real>()) {}

    template<class RNG, class S, class P>
    inline MakeMCDiscreteArithmeticAPHestonEngine<RNG,S,P>&
    MakeMCDiscreteArithmeticAPHestonEngine<RNG,S,P>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCDiscreteArithmeticAPHestonEngine<RNG,S,P>&
    MakeMCDiscreteArithmeticAPHestonEngine<RNG,S,P>::withAbsoluteTolerance(
                                                             Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCDiscreteArithmeticAPHestonEngine<RNG,S,P>&
    MakeMCDiscreteArithmeticAPHestonEngine<RNG,S,P>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCDiscreteArithmeticAPHestonEngine<RNG,S,P>&
    MakeMCDiscreteArithmeticAPHestonEngine<RNG,S,P>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCDiscreteArithmeticAPHestonEngine<RNG,S,P>&
    MakeMCDiscreteArithmeticAPHestonEngine<RNG,S,P>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template<class RNG, class S, class P>
    inline MakeMCDiscreteArithmeticAPHestonEngine<RNG,S,P>&
    MakeMCDiscreteArithmeticAPHestonEngine<RNG,S,P>::withSteps(Size steps) {
        QL_REQUIRE(stepsPerYear_ == Null<Size>(),
                   "number of steps per year already set");
        steps_ = steps;
        return *this;
    }

    template<class RNG, class S, class P>
    inline MakeMCDiscreteArithmeticAPHestonEngine<RNG,S,P>&
    MakeMCDiscreteArithmeticAPHestonEngine<RNG,S,P>::withStepsPerYear(Size steps) {
        QL_REQUIRE(steps_ == Null<Size>(),
                   "number of steps already set");
        stepsPerYear_ = steps;
        return *this;
    }

    template<class RNG, class S, class P>
    inline MakeMCDiscreteArithmeticAPHestonEngine<RNG,S,P>&
    MakeMCDiscreteArithmeticAPHestonEngine<RNG,S,P>::withControlVariate(bool b) {
        controlVariate_ = b;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCDiscreteArithmeticAPHestonEngine<RNG,S,P>::operator ext::shared_ptr<PricingEngine>() const {
        return ext::shared_ptr<PricingEngine>(new
            MCDiscreteArithmeticAPHestonEngine<RNG,S,P>(process_,
                                                        antithetic_,
                                                        samples_,
                                                        tolerance_,
                                                        maxSamples_,
                                                        seed_,
                                                        steps_,
                                                        stepsPerYear_,
                                                        controlVariate_));
    }
}

#endif
]]></document_content>
  </document>
  <document index="13">
    <source>asian/mc_discr_arith_av_strike.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mc_discr_arith_av_strike.hpp
    \brief Monte Carlo engine for discrete arithmetic average-strike Asian
*/

#ifndef quantlib_mc_discrete_arithmetic_average_strike_asian_engine_hpp
#define quantlib_mc_discrete_arithmetic_average_strike_asian_engine_hpp

#include <ql/exercise.hpp>
#include <ql/pricingengines/asian/mcdiscreteasianenginebase.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    //!  Monte Carlo pricing engine for discrete arithmetic average-strike Asian
    /*!  \ingroup asianengines */
    template <class RNG = PseudoRandom, class S = Statistics>
    class MCDiscreteArithmeticASEngine
        : public MCDiscreteAveragingAsianEngineBase<SingleVariate,RNG,S> {
      public:
        typedef
        typename MCDiscreteAveragingAsianEngineBase<SingleVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef typename MCDiscreteAveragingAsianEngineBase<SingleVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename MCDiscreteAveragingAsianEngineBase<SingleVariate,RNG,S>::stats_type
            stats_type;
        // constructor
        MCDiscreteArithmeticASEngine(
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             bool brownianBridge,
             bool antitheticVariate,
             Size requiredSamples,
             Real requiredTolerance,
             Size maxSamples,
             BigNatural seed);
      protected:
        ext::shared_ptr<path_pricer_type> pathPricer() const override;
    };


    class ArithmeticASOPathPricer : public PathPricer<Path> {
      public:
        ArithmeticASOPathPricer(Option::Type type,
                                DiscountFactor discount,
                                Real runningSum = 0.0,
                                Size pastFixings = 0);
        Real operator()(const Path& path) const override;

      private:
        Option::Type type_;
        DiscountFactor discount_;
        Real runningSum_;
        Size pastFixings_;
    };



    // inline definitions

    template <class RNG, class S>
    inline
    MCDiscreteArithmeticASEngine<RNG,S>::MCDiscreteArithmeticASEngine(
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             bool brownianBridge,
             bool antitheticVariate,
             Size requiredSamples,
             Real requiredTolerance,
             Size maxSamples,
             BigNatural seed)
    : MCDiscreteAveragingAsianEngineBase<SingleVariate,RNG,S>(process,
                                                              brownianBridge,
                                                              antitheticVariate,
                                                              false,
                                                              requiredSamples,
                                                              requiredTolerance,
                                                              maxSamples,
                                                              seed) {}

    template <class RNG, class S>
    inline
    ext::shared_ptr<
               typename MCDiscreteArithmeticASEngine<RNG,S>::path_pricer_type>
    MCDiscreteArithmeticASEngine<RNG,S>::pathPricer() const {

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                this->arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(
                this->arguments_.exercise);
        QL_REQUIRE(exercise, "wrong exercise given");

        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                this->process_);
        QL_REQUIRE(process, "Black-Scholes process required");

        return ext::shared_ptr<typename
            MCDiscreteArithmeticASEngine<RNG,S>::path_pricer_type>(
                new ArithmeticASOPathPricer(
                    payoff->optionType(),
                    process->riskFreeRate()->discount(exercise->lastDate()),
                    this->arguments_.runningAccumulator,
                    this->arguments_.pastFixings));
    }



    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCDiscreteArithmeticASEngine {
      public:
        explicit MakeMCDiscreteArithmeticASEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        // named parameters
        MakeMCDiscreteArithmeticASEngine& withBrownianBridge(bool b = true);
        MakeMCDiscreteArithmeticASEngine& withSamples(Size samples);
        MakeMCDiscreteArithmeticASEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCDiscreteArithmeticASEngine& withMaxSamples(Size samples);
        MakeMCDiscreteArithmeticASEngine& withSeed(BigNatural seed);
        MakeMCDiscreteArithmeticASEngine& withAntitheticVariate(bool b = true);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        bool antithetic_ = false;
        Size samples_, maxSamples_;
        Real tolerance_;
        bool brownianBridge_ = true;
        BigNatural seed_ = 0;
    };

    template <class RNG, class S>
    inline MakeMCDiscreteArithmeticASEngine<RNG, S>::MakeMCDiscreteArithmeticASEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)), samples_(Null<Size>()), maxSamples_(Null<Size>()),
      tolerance_(Null<Real>()) {}

    template <class RNG, class S>
    inline MakeMCDiscreteArithmeticASEngine<RNG,S>&
    MakeMCDiscreteArithmeticASEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDiscreteArithmeticASEngine<RNG,S>&
    MakeMCDiscreteArithmeticASEngine<RNG,S>::withAbsoluteTolerance(
                                                             Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDiscreteArithmeticASEngine<RNG,S>&
    MakeMCDiscreteArithmeticASEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDiscreteArithmeticASEngine<RNG,S>&
    MakeMCDiscreteArithmeticASEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDiscreteArithmeticASEngine<RNG,S>&
    MakeMCDiscreteArithmeticASEngine<RNG,S>::withBrownianBridge(bool b) {
        brownianBridge_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDiscreteArithmeticASEngine<RNG,S>&
    MakeMCDiscreteArithmeticASEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCDiscreteArithmeticASEngine<RNG,S>::
    operator ext::shared_ptr<PricingEngine>() const {
        return ext::shared_ptr<PricingEngine>(
            new MCDiscreteArithmeticASEngine<RNG,S>(process_,
                                                    brownianBridge_,
                                                    antithetic_,
                                                    samples_, tolerance_,
                                                    maxSamples_,
                                                    seed_));
    }

}


#endif
]]></document_content>
  </document>
  <document index="14">
    <source>asian/mc_discr_geom_av_price.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2007, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mc_discr_geom_av_price.hpp
    \brief Monte Carlo engine for discrete geometric average price Asian
*/

#ifndef quantlib_mc_discrete_geometric_average_price_asian_engine_h
#define quantlib_mc_discrete_geometric_average_price_asian_engine_h

#include <ql/exercise.hpp>
#include <ql/pricingengines/asian/mcdiscreteasianenginebase.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/termstructures/volatility/equityfx/blackvariancecurve.hpp>
#include <utility>

namespace QuantLib {

    //!  Monte Carlo pricing engine for discrete geometric average price Asian
    /*! \ingroup asianengines

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    template <class RNG = PseudoRandom, class S = Statistics>
    class MCDiscreteGeometricAPEngine
        : public MCDiscreteAveragingAsianEngineBase<SingleVariate,RNG,S> {
      public:
        typedef
        typename MCDiscreteAveragingAsianEngineBase<SingleVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef
        typename MCDiscreteAveragingAsianEngineBase<SingleVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename MCDiscreteAveragingAsianEngineBase<SingleVariate,RNG,S>::stats_type
            stats_type;
        // constructor
        MCDiscreteGeometricAPEngine(
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             bool brownianBridge,
             bool antitheticVariate,
             Size requiredSamples,
             Real requiredTolerance,
             Size maxSamples,
             BigNatural seed);
      protected:
        ext::shared_ptr<path_pricer_type> pathPricer() const override;
    };


    class GeometricAPOPathPricer : public PathPricer<Path> {
      public:
        GeometricAPOPathPricer(Option::Type type,
                               Real strike,
                               DiscountFactor discount,
                               Real runningProduct = 1.0,
                               Size pastFixings = 0);
        Real operator()(const Path& path) const override;

      private:
        PlainVanillaPayoff payoff_;
        DiscountFactor discount_;
        Real runningProduct_;
        Size pastFixings_;
    };


    // inline definitions

    template <class RNG, class S>
    inline
    MCDiscreteGeometricAPEngine<RNG,S>::MCDiscreteGeometricAPEngine(
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             bool brownianBridge,
             bool antitheticVariate,
             Size requiredSamples,
             Real requiredTolerance,
             Size maxSamples,
             BigNatural seed)
    : MCDiscreteAveragingAsianEngineBase<SingleVariate,RNG,S>(process,
                                                              brownianBridge,
                                                              antitheticVariate,
                                                              false,
                                                              requiredSamples,
                                                              requiredTolerance,
                                                              maxSamples,
                                                              seed) {}



    template <class RNG, class S>
    inline
    ext::shared_ptr<
            typename MCDiscreteGeometricAPEngine<RNG,S>::path_pricer_type>
        MCDiscreteGeometricAPEngine<RNG,S>::pathPricer() const {

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                this->arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(
                this->arguments_.exercise);
        QL_REQUIRE(exercise, "wrong exercise given");

        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                this->process_);
        QL_REQUIRE(process, "Black-Scholes process required");

        return ext::shared_ptr<typename
            MCDiscreteGeometricAPEngine<RNG,S>::path_pricer_type>(
                new GeometricAPOPathPricer(
                    payoff->optionType(),
                    payoff->strike(),
                    process->riskFreeRate()->discount(exercise->lastDate()),
                    this->arguments_.runningAccumulator,
                    this->arguments_.pastFixings));
    }


    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCDiscreteGeometricAPEngine {
      public:
        explicit MakeMCDiscreteGeometricAPEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        // named parameters
        MakeMCDiscreteGeometricAPEngine& withBrownianBridge(bool b = true);
        MakeMCDiscreteGeometricAPEngine& withSamples(Size samples);
        MakeMCDiscreteGeometricAPEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCDiscreteGeometricAPEngine& withMaxSamples(Size samples);
        MakeMCDiscreteGeometricAPEngine& withSeed(BigNatural seed);
        MakeMCDiscreteGeometricAPEngine& withAntitheticVariate(bool b = true);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        bool antithetic_ = false;
        Size samples_, maxSamples_;
        Real tolerance_;
        bool brownianBridge_ = true;
        BigNatural seed_ = 0;
    };

    template <class RNG, class S>
    inline MakeMCDiscreteGeometricAPEngine<RNG, S>::MakeMCDiscreteGeometricAPEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)), samples_(Null<Size>()), maxSamples_(Null<Size>()),
      tolerance_(Null<Real>()) {}

    template <class RNG, class S>
    inline MakeMCDiscreteGeometricAPEngine<RNG,S>&
    MakeMCDiscreteGeometricAPEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDiscreteGeometricAPEngine<RNG,S>&
    MakeMCDiscreteGeometricAPEngine<RNG,S>::withAbsoluteTolerance(
                                                             Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDiscreteGeometricAPEngine<RNG,S>&
    MakeMCDiscreteGeometricAPEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDiscreteGeometricAPEngine<RNG,S>&
    MakeMCDiscreteGeometricAPEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDiscreteGeometricAPEngine<RNG,S>&
    MakeMCDiscreteGeometricAPEngine<RNG,S>::withBrownianBridge(bool b) {
        brownianBridge_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDiscreteGeometricAPEngine<RNG,S>&
    MakeMCDiscreteGeometricAPEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCDiscreteGeometricAPEngine<RNG,S>::operator ext::shared_ptr<PricingEngine>()
                                                                      const {
        return ext::shared_ptr<PricingEngine>(new
            MCDiscreteGeometricAPEngine<RNG,S>(process_,
                                               brownianBridge_,
                                               antithetic_,
                                               samples_, tolerance_,
                                               maxSamples_,
                                               seed_));
    }

}


#endif
]]></document_content>
  </document>
  <document index="15">
    <source>asian/mc_discr_geom_av_price_heston.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Jack Gillett
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mc_discr_geom_av_price_heston.hpp
    \brief Heston MC engine for discrete geometric average price Asian
*/

#ifndef quantlib_mc_discrete_geometric_average_price_asian_heston_engine_hpp
#define quantlib_mc_discrete_geometric_average_price_asian_heston_engine_hpp

#include <ql/exercise.hpp>
#include <ql/pricingengines/asian/mcdiscreteasianenginebase.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <utility>

namespace QuantLib {

    //!  Heston MC pricing engine for discrete geometric average price Asian
    /*!
         By default, the MC discretization will use 1 time step per fixing date, but
         this can be controlled via timeSteps or timeStepsPerYear parameter, which
         will provide additional timesteps. The grid tries to space as evenly as it
         can and does not guarantee to match an exact number of steps, the precise
         grid used can be found in results_.additionalResults["TimeGrid"]

         \ingroup asianengines
         \test the correctness of the returned value is tested by
               reproducing results available in literature.
    */
    template <class RNG = PseudoRandom,
              class S = Statistics, class P = HestonProcess>
    class MCDiscreteGeometricAPHestonEngine
        : public MCDiscreteAveragingAsianEngineBase<MultiVariate,RNG,S> {
      public:
        typedef typename MCDiscreteAveragingAsianEngineBase<MultiVariate,RNG,S>::path_generator_type path_generator_type;
        typedef typename MCDiscreteAveragingAsianEngineBase<MultiVariate,RNG,S>::path_pricer_type path_pricer_type;
        typedef typename MCDiscreteAveragingAsianEngineBase<MultiVariate,RNG,S>::stats_type stats_type;
        // constructor
        MCDiscreteGeometricAPHestonEngine(const ext::shared_ptr<P>& process,
                                          bool antitheticVariate,
                                          Size requiredSamples,
                                          Real requiredTolerance,
                                          Size maxSamples,
                                          BigNatural seed,
                                          Size timeSteps = Null<Size>(),
                                          Size timeStepsPerYear = Null<Size>());
      protected:
        ext::shared_ptr<path_pricer_type> pathPricer() const override;
    };


    template <class RNG = PseudoRandom,
              class S = Statistics, class P = HestonProcess>
    class MakeMCDiscreteGeometricAPHestonEngine {
      public:
        explicit MakeMCDiscreteGeometricAPHestonEngine(ext::shared_ptr<P> process);
        // named parameters
        MakeMCDiscreteGeometricAPHestonEngine& withSamples(Size samples);
        MakeMCDiscreteGeometricAPHestonEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCDiscreteGeometricAPHestonEngine& withMaxSamples(Size samples);
        MakeMCDiscreteGeometricAPHestonEngine& withSeed(BigNatural seed);
        MakeMCDiscreteGeometricAPHestonEngine& withAntitheticVariate(bool b = true);
        MakeMCDiscreteGeometricAPHestonEngine& withSteps(Size steps);
        MakeMCDiscreteGeometricAPHestonEngine& withStepsPerYear(Size steps);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<P> process_;
        bool antithetic_ = false;
        Size samples_, maxSamples_, steps_, stepsPerYear_;
        Real tolerance_;
        BigNatural seed_ = 0;
    };

    class GeometricAPOHestonPathPricer : public PathPricer<MultiPath> {
      public:
        GeometricAPOHestonPathPricer(Option::Type type,
                                     Real strike,
                                     DiscountFactor discount,
                                     std::vector<Size> fixingIndices,
                                     Real runningProduct = 1.0,
                                     Size pastFixings = 0);
        Real operator()(const MultiPath& multiPath) const override;

      private:
        PlainVanillaPayoff payoff_;
        DiscountFactor discount_;
        std::vector<Size> fixingIndices_;
        Real runningProduct_;
        Size pastFixings_;
    };


    // inline definitions

    template <class RNG, class S, class P>
    inline
    MCDiscreteGeometricAPHestonEngine<RNG,S,P>::MCDiscreteGeometricAPHestonEngine(
             const ext::shared_ptr<P>& process,
             bool antitheticVariate,
             Size requiredSamples,
             Real requiredTolerance,
             Size maxSamples,
             BigNatural seed,
             Size timeSteps,
             Size timeStepsPerYear)
    : MCDiscreteAveragingAsianEngineBase<MultiVariate,RNG,S>(process,
                                                             false,
                                                             antitheticVariate,
                                                             false,
                                                             requiredSamples,
                                                             requiredTolerance,
                                                             maxSamples,
                                                             seed,
                                                             timeSteps,
                                                             timeStepsPerYear) {
        QL_REQUIRE(timeSteps == Null<Size>() || timeStepsPerYear == Null<Size>(),
                   "both time steps and time steps per year were provided");
    }

    template <class RNG, class S, class P>
    inline ext::shared_ptr<
            typename MCDiscreteGeometricAPHestonEngine<RNG,S,P>::path_pricer_type>
        MCDiscreteGeometricAPHestonEngine<RNG,S,P>::pathPricer() const {

        // Keep track of the fixing indices, the path pricer will need to sum only these
        TimeGrid timeGrid = this->timeGrid();
        std::vector<Time> fixingTimes = timeGrid.mandatoryTimes();
        std::vector<Size> fixingIndexes;
        fixingIndexes.reserve(fixingTimes.size());
        for (Real fixingTime : fixingTimes) {
            fixingIndexes.push_back(timeGrid.closestIndex(fixingTime));
        }

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                this->arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(
                this->arguments_.exercise);
        QL_REQUIRE(exercise, "wrong exercise given");

        ext::shared_ptr<P> process =
            ext::dynamic_pointer_cast<P>(this->process_);
        QL_REQUIRE(process, "Heston like process required");

        return ext::shared_ptr<typename
            MCDiscreteGeometricAPHestonEngine<RNG,S,P>::path_pricer_type>(
                new GeometricAPOHestonPathPricer(
                    payoff->optionType(),
                    payoff->strike(),
                    process->riskFreeRate()->discount(exercise->lastDate()),
                    fixingIndexes,
                    this->arguments_.runningAccumulator,
                    this->arguments_.pastFixings));
    }

    template <class RNG, class S, class P>
    inline MakeMCDiscreteGeometricAPHestonEngine<RNG, S, P>::MakeMCDiscreteGeometricAPHestonEngine(
        ext::shared_ptr<P> process)
    : process_(std::move(process)), samples_(Null<Size>()), maxSamples_(Null<Size>()),
      steps_(Null<Size>()), stepsPerYear_(Null<Size>()), tolerance_(Null<Real>()) {}

    template<class RNG, class S, class P>
    inline MakeMCDiscreteGeometricAPHestonEngine<RNG,S,P>&
    MakeMCDiscreteGeometricAPHestonEngine<RNG,S,P>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCDiscreteGeometricAPHestonEngine<RNG,S,P>&
    MakeMCDiscreteGeometricAPHestonEngine<RNG,S,P>::withAbsoluteTolerance(
                                                             Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCDiscreteGeometricAPHestonEngine<RNG,S,P>&
    MakeMCDiscreteGeometricAPHestonEngine<RNG,S,P>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCDiscreteGeometricAPHestonEngine<RNG,S,P>&
    MakeMCDiscreteGeometricAPHestonEngine<RNG,S,P>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCDiscreteGeometricAPHestonEngine<RNG,S,P>&
    MakeMCDiscreteGeometricAPHestonEngine<RNG,S,P>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template<class RNG, class S, class P>
    inline MakeMCDiscreteGeometricAPHestonEngine<RNG,S,P>&
    MakeMCDiscreteGeometricAPHestonEngine<RNG,S,P>::withSteps(Size steps) {
        QL_REQUIRE(stepsPerYear_ == Null<Size>(),
                   "number of steps per year already set");
        steps_ = steps;
        return *this;
    }

    template<class RNG, class S, class P>
    inline MakeMCDiscreteGeometricAPHestonEngine<RNG,S,P>&
    MakeMCDiscreteGeometricAPHestonEngine<RNG,S,P>::withStepsPerYear(Size steps) {
        QL_REQUIRE(steps_ == Null<Size>(),
                   "number of steps already set");
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCDiscreteGeometricAPHestonEngine<RNG,S,P>::operator ext::shared_ptr<PricingEngine>() const {
        return ext::shared_ptr<PricingEngine>(new
            MCDiscreteGeometricAPHestonEngine<RNG,S,P>(process_,
                                                       antithetic_,
                                                       samples_,
                                                       tolerance_,
                                                       maxSamples_,
                                                       seed_,
                                                       steps_,
                                                       stepsPerYear_));
    }
}

#endif
]]></document_content>
  </document>
  <document index="16">
    <source>asian/mcdiscreteasianenginebase.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2007, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mcdiscreteasianenginebase.hpp
    \brief Monte Carlo pricing engine for discrete average Asians
*/

#ifndef quantlib_mcdiscreteasian_engine_base_hpp
#define quantlib_mcdiscreteasian_engine_base_hpp

#include <ql/exercise.hpp>
#include <ql/instruments/asianoption.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <utility>

namespace QuantLib {


    namespace detail {

        class PastFixingsOnly : public Error {
          public:
            PastFixingsOnly()
            : Error("n/a", 0, "n/a",
                    "all fixings are in the past") {}
        };

    }

    //! Pricing engine for discrete average Asians using Monte Carlo simulation
    /*! \warning control-variate calculation is disabled under VC++6.
        \ingroup asianengines
    */

    template<template <class> class MC,
             class RNG = PseudoRandom, class S = Statistics>
    class MCDiscreteAveragingAsianEngineBase :
                                public DiscreteAveragingAsianOption::engine,
                                public McSimulation<MC,RNG,S> {
      public:
        typedef
        typename McSimulation<MC,RNG,S>::path_generator_type
            path_generator_type;
        typedef typename McSimulation<MC,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename McSimulation<MC,RNG,S>::stats_type
            stats_type;
        // constructor
        MCDiscreteAveragingAsianEngineBase(ext::shared_ptr<StochasticProcess> process,
                                           bool brownianBridge,
                                           bool antitheticVariate,
                                           bool controlVariate,
                                           Size requiredSamples,
                                           Real requiredTolerance,
                                           Size maxSamples,
                                           BigNatural seed,
                                           Size timeSteps = Null<Size>(),
                                           Size timeStepsPerYear = Null<Size>());
        void calculate() const override {
            try {
                McSimulation<MC,RNG,S>::calculate(requiredTolerance_,
                                                  requiredSamples_,
                                                  maxSamples_);
            } catch (detail::PastFixingsOnly&) {
                // Ideally, here we could calculate the payoff (which
                // is fully determine) and write it into the results.
                // This would probably need a new virtual method that
                // derived engines should implement.
                throw;
            }

            results_.value = this->mcModel_->sampleAccumulator().mean();

            if (this->controlVariate_) {
                // control variate might lead to small negative
                // option values for deep OTM options
                this->results_.value = std::max(0.0, this->results_.value);
            }

            if constexpr (RNG::allowsErrorEstimate)
                results_.errorEstimate =
                    this->mcModel_->sampleAccumulator().errorEstimate();

            // Allow inspection of the timeGrid via additional results
            this->results_.additionalResults["TimeGrid"] = this->timeGrid();
        }

      protected:
        // McSimulation implementation
        TimeGrid timeGrid() const override;
        ext::shared_ptr<path_generator_type> pathGenerator() const override {

            Size dimensions = process_->factors();
            TimeGrid grid = this->timeGrid();
            typename RNG::rsg_type gen =
                RNG::make_sequence_generator(dimensions*(grid.size()-1),seed_);
            return ext::shared_ptr<path_generator_type>(
                         new path_generator_type(process_, grid,
                                                 gen, brownianBridge_));
        }
        Real controlVariateValue() const override;
        // data members
        ext::shared_ptr<StochasticProcess> process_;
        Size requiredSamples_, maxSamples_, timeSteps_, timeStepsPerYear_;
        Real requiredTolerance_;
        bool brownianBridge_;
        BigNatural seed_;
    };


    // template definitions

    template <template <class> class MC, class RNG, class S>
    inline MCDiscreteAveragingAsianEngineBase<MC, RNG, S>::MCDiscreteAveragingAsianEngineBase(
        ext::shared_ptr<StochasticProcess> process,
        bool brownianBridge,
        bool antitheticVariate,
        bool controlVariate,
        Size requiredSamples,
        Real requiredTolerance,
        Size maxSamples,
        BigNatural seed,
        Size timeSteps,
        Size timeStepsPerYear)
    : McSimulation<MC, RNG, S>(antitheticVariate, controlVariate), process_(std::move(process)),
      requiredSamples_(requiredSamples), maxSamples_(maxSamples), timeSteps_(timeSteps),
      timeStepsPerYear_(timeStepsPerYear), requiredTolerance_(requiredTolerance),
      brownianBridge_(brownianBridge), seed_(seed) {
        registerWith(process_);
    }

    template <template <class> class MC, class RNG, class S>
    inline TimeGrid MCDiscreteAveragingAsianEngineBase<MC,RNG,S>::timeGrid() const {

        std::vector<Time> fixingTimes;
        Size i;
        for (i=0; i<arguments_.fixingDates.size(); i++) {
            Time t = process_->time(arguments_.fixingDates[i]);
            if (t>=0) {
                fixingTimes.push_back(t);
            }
        }

        if (fixingTimes.empty() ||
            (fixingTimes.size() == 1 && fixingTimes.front() == 0.0))
            throw detail::PastFixingsOnly();

        // Some models (eg. Heston) might request additional points in
        // the time grid to improve the accuracy of the discretization
        Date lastExerciseDate = this->arguments_.exercise->lastDate();
        Time t = process_->time(lastExerciseDate);

        if (this->timeSteps_ != Null<Size>()) {
            return TimeGrid(fixingTimes.begin(), fixingTimes.end(), timeSteps_);
        } else if (this->timeStepsPerYear_ != Null<Size>()) {
            return TimeGrid(fixingTimes.begin(), fixingTimes.end(),
                static_cast<Size>(this->timeStepsPerYear_*t));
        }

        return TimeGrid(fixingTimes.begin(), fixingTimes.end());
    }

    template<template <class> class MC, class RNG, class S>
    inline
    Real MCDiscreteAveragingAsianEngineBase<MC,RNG,S>::controlVariateValue() const {

        ext::shared_ptr<PricingEngine> controlPE =
                this->controlPricingEngine();
            QL_REQUIRE(controlPE,
                       "engine does not provide "
                       "control variation pricing engine");

            auto* controlArguments =
                dynamic_cast<DiscreteAveragingAsianOption::arguments*>(controlPE->getArguments());
            *controlArguments = arguments_;
            controlPE->calculate();

            const auto* controlResults =
                dynamic_cast<const DiscreteAveragingAsianOption::results*>(controlPE->getResults());

            return controlResults->value;
    }

}


#endif
]]></document_content>
  </document>
  <document index="17">
    <source>asian/turnbullwakemanasianengine.hpp</source>
    <document_content><![CDATA[/*
 Copyright (C) 2021 Skandinaviska Enskilda Banken AB (publ)

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file ql/pricingengines/asian/turnbullwakemanasianengine.hpp
    \brief Turnbull Wakeman moment-matching Asian option Engine
    \ingroup asianengines
*/

#ifndef quantlib_turnbull_wakeman_asian_engine_hpp
#define quantlib_turnbull_wakeman_asian_engine_hpp

#include <ql/instruments/asianoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    /*! Turnbull Wakeman two moment-matching Asian option Engine
        Analytical pricing based on the two-moment Turnbull-Wakeman
        approximation.
        References: "Commodity Option Pricing", Iain Clark, Wiley, section 2.7.4.
                    "Option Pricing Formulas, Second Edition", E.G. Haug, 2006, pp. 192-202.
                    Some parts of the implementation were modeled after calculations from the
                    CommodityAveragePriceOptionAnalyticalEngine class in Open Source Risk Engine
                    (https://github.com/OpenSourceRisk/Engine).

        \test
        - the correctness of the returned value is tested by reproducing
          results in literature with flat as well as upward and downward
          sloping volatility term structures.
        - the pricing of trades with guaranteed exercise/OTM is also tested.
    */
    class TurnbullWakemanAsianEngine : public DiscreteAveragingAsianOption::engine {
      public:
        explicit TurnbullWakemanAsianEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process)
        : process_(std::move(process)) {
            registerWith(process_);
        }

        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="18">
    <source>bacheliercalculator.hpp</source>
    <document_content><![CDATA[﻿/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004, 2005, 2006 Ferdinando Ametrano
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bacheliercalculator.hpp
    \brief Bachelier-formula calculator class
*/

#ifndef quantlib_bacheliercalculator_hpp
#define quantlib_bacheliercalculator_hpp

#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    //! Bachelier calculator class
    class BachelierCalculator {
      private:
        class Calculator;
      public:
        BachelierCalculator(const ext::shared_ptr<StrikedTypePayoff>& payoff,
                           Real forward,
                           Real stdDev,
                           Real discount = 1.0);
        BachelierCalculator(Option::Type optionType,
                           Real strike,
                           Real forward,
                           Real stdDev,
                           Real discount = 1.0);
        ~BachelierCalculator() = default;

        Real value() const;

        /*! Sensitivity to change in the underlying forward price. */
        Real deltaForward() const;
        /*! Sensitivity to change in the underlying spot price. */
        Real delta(Real spot) const;

        /*! Sensitivity in percent to a percent change in the
            underlying forward price. */
        Real elasticityForward() const;
        /*! Sensitivity in percent to a percent change in the
            underlying spot price. */
        Real elasticity(Real spot) const;

        /*! Second order derivative with respect to change in the
            underlying forward price. */
        Real gammaForward() const;
        /*! Second order derivative with respect to change in the
            underlying spot price. */
        Real gamma(Real spot) const;

        /*! Sensitivity to time to maturity. */
        Real theta(Real spot,
                          Time maturity) const;
        /*! Sensitivity to time to maturity per day,
            assuming 365 day per year. */
        Real thetaPerDay(Real spot,
                                Time maturity) const;

        /*! Sensitivity to volatility. */
        Real vega(Time maturity) const;

        /*! Sensitivity to discounting rate. */
        Real rho(Time maturity) const;

        /*! Sensitivity to dividend/growth rate. */
        Real dividendRho(Time maturity) const;

        /*! Probability of being in the money in the bond martingale
            measure, i.e. N(d).
            It is a risk-neutral probability, not the real world one.
        */
        Real itmCashProbability() const;

        /*! Probability of being in the money in the asset martingale
            measure, i.e. N(d).
            It is a risk-neutral probability, not the real world one.
        */
        Real itmAssetProbability() const;

        /*! Sensitivity to strike. */
        Real strikeSensitivity() const;

        /*! gamma w.r.t. strike. */
        Real strikeGamma() const;

        /*! Sensitivity of vega to spot (Vanna) */
        Real vanna(Time maturity) const;

        /*! Sensitivity of volga to volatility (Volga) */
        Real volga(Time maturity) const;

        Real alpha() const;
        Real beta() const;
        
      protected:
        void initialize(const ext::shared_ptr<StrikedTypePayoff>& p);
        
        //! Member variables
        Real strike_, forward_, stdDev_, discount_, variance_;
        Real d_;  // Single d parameter for Bachelier model
        Real alpha_, beta_, DalphaDd_, DbetaDd_;  // Simplified derivative names
        Real n_d_, cum_d_;  // Single normal distribution values
        Real x_, DxDs_, DxDstrike_;
    };

    // inline
    inline Real BachelierCalculator::thetaPerDay(Real spot,
                                               Time maturity) const {
        return theta(spot, maturity)/365.0;
    }

    inline Real BachelierCalculator::itmCashProbability() const {
        // For Bachelier model:
        // Call ITM probability: P(F > K) = N(d) where d = (F-K)/σ
        // Put ITM probability:  P(F < K) = N(-d) = 1 - N(d) where d = (F-K)/σ
        
        if (alpha_ >= 0) { // Call option (alpha_ = N(d) >= 0)
            return cum_d_;  // N(d)
        } else { // Put option (alpha_ = N(d) - 1 < 0)
            return 1.0 - cum_d_;  // N(-d) = 1 - N(d)
        }
    }

    inline Real BachelierCalculator::itmAssetProbability() const {
        // In Bachelier model, asset probability is the same as cash probability
        // since there's no drift adjustment like in Black-Scholes
        // Call ITM probability: P(F > K) = N(d) where d = (F-K)/σ  
        // Put ITM probability:  P(F < K) = N(-d) = 1 - N(d) where d = (F-K)/σ
        
        if (alpha_ >= 0) { // Call option
            return cum_d_;  // N(d)
        } else { // Put option
            return 1.0 - cum_d_;  // N(-d) = 1 - N(d)
        }
    }

    inline Real BachelierCalculator::alpha() const {
        return alpha_;
    }

    inline Real BachelierCalculator::beta() const {
        return beta_;
    }

}

#endif
]]></document_content>
  </document>
  <document index="19">
    <source>barrier/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/pricingengines/barrier/analyticbarrierengine.hpp>
#include <ql/pricingengines/barrier/analyticbinarybarrierengine.hpp>
#include <ql/pricingengines/barrier/analyticdoublebarrierbinaryengine.hpp>
#include <ql/pricingengines/barrier/analyticdoublebarrierengine.hpp>
#include <ql/pricingengines/barrier/analyticpartialtimebarrieroptionengine.hpp>
#include <ql/pricingengines/barrier/analyticsoftbarrierengine.hpp>
#include <ql/pricingengines/barrier/analytictwoassetbarrierengine.hpp>
#include <ql/pricingengines/barrier/binomialbarrierengine.hpp>
#include <ql/pricingengines/barrier/discretizedbarrieroption.hpp>
#include <ql/pricingengines/barrier/fdblackscholesbarrierengine.hpp>
#include <ql/pricingengines/barrier/fdblackscholesrebateengine.hpp>
#include <ql/pricingengines/barrier/fdhestonbarrierengine.hpp>
#include <ql/pricingengines/barrier/fdhestondoublebarrierengine.hpp>
#include <ql/pricingengines/barrier/fdhestonrebateengine.hpp>
#include <ql/pricingengines/barrier/mcbarrierengine.hpp>

]]></document_content>
  </document>
  <document index="20">
    <source>barrier/analyticbarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2002, 2003 Ferdinando Ametrano
 Copyright (C) 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2003 Neil Firth
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticbarrierengine.hpp
    \brief Analytic barrier option engines
*/

#ifndef quantlib_analytic_barrier_engine_hpp
#define quantlib_analytic_barrier_engine_hpp

#include <ql/instruments/barrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {

    //! Pricing engine for barrier options using analytical formulae
    /*! The formulas are taken from "Option pricing formulas",
         E.G. Haug, McGraw-Hill, p.69 and following.

        \ingroup barrierengines

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class AnalyticBarrierEngine : public BarrierOption::engine {
      public:
        AnalyticBarrierEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        CumulativeNormalDistribution f_;
        // helper methods
        Real underlying() const;
        Real strike() const;
        Volatility volatility() const;
        Real barrier() const;
        Real rebate() const;
        Real stdDeviation() const;
        Rate riskFreeRate() const;
        DiscountFactor riskFreeDiscount() const;
        Rate dividendYield() const;
        DiscountFactor dividendDiscount() const;
        Rate mu() const;
        Real muSigma() const;
        Real A(Real phi) const;
        Real B(Real phi) const;
        Real C(Real eta, Real phi) const;
        Real D(Real eta, Real phi) const;
        Real E(Real eta) const;
        Real F(Real eta) const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="21">
    <source>barrier/analyticbinarybarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticbinarybarrierengine.hpp
    \brief analytic binary barrier (cash/asset or nothing plus in-the-money check) option engine
*/

#ifndef quantlib_binary_barrier_engine_hpp
#define quantlib_binary_barrier_engine_hpp

#include <ql/instruments/barrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic pricing engine for American binary barriers options
    /*! The formulas are taken from "The complete guide to option pricing formulas 2nd Ed",
         E.G. Haug, McGraw-Hill, p.176 and following. 

        \ingroup barrierengines

        \test
        - the correctness of the returned value in case of
          cash-or-nothing at-expiry binary payoff is tested by
          reproducing results available in literature.
        - the correctness of the returned value in case of
          asset-or-nothing at-expiry binary payoff is tested by
          reproducing results available in literature.
    */
    class AnalyticBinaryBarrierEngine : public BarrierOption::engine {
      public:
        AnalyticBinaryBarrierEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="22">
    <source>barrier/analyticdoublebarrierbinaryengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticdoublebarrierbinaryengine.hpp
    \brief analytic binary double barrier (one-touch double barrier) option engine
*/

#ifndef quantlib_binary_double_barrier_engine_hpp
#define quantlib_binary_double_barrier_engine_hpp

#include <ql/instruments/doublebarrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic pricing engine for double barrier binary options
    /*! This engine implements C.H.Hui series ("One-Touch Double Barrier 
        Binary Option Values", Applied Financial Economics 6/1996), as
        described in "The complete guide to option pricing formulas 2nd Ed", 
        E.G. Haug, McGraw-Hill, p.180

        The Knock In part of KI+KO and KO+KI options pays at hit, while the
        Double Knock In pays at end. 
        This engine thus requires European esercise for Double Knock options, 
        and American exercise for KIKO/KOKI.

        \ingroup barrierengines

        greeks are calculated by simple numeric derivation

        \test
        - the correctness of the returned value is tested by reproducing 
          results available in literature.
    */
    class AnalyticDoubleBarrierBinaryEngine : public DoubleBarrierOption::engine {
      public:
        explicit AnalyticDoubleBarrierBinaryEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="23">
    <source>barrier/analyticdoublebarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticdoublebarrierengine.hpp
    \brief Analytic double barrier european option engines

  ! Valid only if strike is in barrier range
*/

#ifndef quantlib_analytic_double_barrier_engine_hpp
#define quantlib_analytic_double_barrier_engine_hpp

#include <ql/instruments/doublebarrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {

    //! Pricing engine for double barrier european options using analytical formulae
    /*! The formulas are taken from "The complete guide to option pricing formulas 2nd Ed",
         E.G. Haug, McGraw-Hill, p.156 and following.
         Implements the Ikeda and Kunitomo series (see "Pricing Options with 
         Curved Boundaries" Mathematical Finance 2/1992").
         This code handles only flat barriers

        \ingroup barrierengines

        \note the formula holds only when strike is in the barrier range

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class AnalyticDoubleBarrierEngine : public DoubleBarrierOption::engine {
      public:
        explicit AnalyticDoubleBarrierEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process, int series = 5);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        CumulativeNormalDistribution f_;
        int series_;
        // helper methods
        Real underlying() const;
        Real strike() const;
        Time residualTime() const;
        Volatility volatility() const;
        Real volatilitySquared() const;
        Real barrierLo() const;
        Real barrierHi() const;
        Real stdDeviation() const;
        Rate riskFreeRate() const;
        DiscountFactor riskFreeDiscount() const;
        Rate dividendYield() const;
        Rate costOfCarry() const;
        DiscountFactor dividendDiscount() const;
        Real vanillaEquivalent() const;
        Real callKO() const;
        Real putKO() const;
        Real callKI() const;
        Real putKI() const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="24">
    <source>barrier/analyticpartialtimebarrieroptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticpartialtimebarrieroptionengine.hpp
    \brief Analytic engine for partial-time barrier options
*/

#ifndef quantlib_analytic_partial_time_barrier_option_engine_hpp
#define quantlib_analytic_partial_time_barrier_option_engine_hpp

#include <ql/instruments/partialtimebarrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! analytic engine for partial-time %barrier %options.
    /*! Formulas from Haug, Option Pricing Formulas.

        It doesn't currently cover the case of knock-in
        partial-time end options.
    */
    class AnalyticPartialTimeBarrierOptionEngine
        : public PartialTimeBarrierOption::engine {
      public:
        explicit AnalyticPartialTimeBarrierOptionEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Real calculate(PartialTimeBarrierOption::arguments& arguments,
                      const ext::shared_ptr<PlainVanillaPayoff>& payoff, 
                      const ext::shared_ptr<GeneralizedBlackScholesProcess>& process) const;
        Real underlying() const;
        Time residualTime() const;
        Time coverEventTime() const;
        Volatility volatility(Time t, Real strike) const;
        Real M(Real a,Real b,Real rho) const;
        Real d1(Real strike, Rate b)const;
        Real d2(Real strike, Rate b)const;
        Real e1(Real barrier, Real strike, Rate b) const;
        Real e2(Real barrier, Real strike, Rate b) const;
        Real e3(Real barrier, Real strike, Rate b) const;
        Real e4(Real barrier, Real strike, Rate b) const;
        Real f1(Real barrier, Real strike, Rate b) const;
        Real f2(Real barrier, Real strike, Rate b) const;
        Real rho() const;
        Rate mu(Real strike, Rate b) const;
        Real CoB2(Barrier::Type barrierType, Real barrier, Real strike, Rate r, Rate q) const;
        Real CoB1(Real barrier, Real strike, Rate r, Rate q) const;
        Real CA(Integer n, Real barrier, Real strike, Rate r, Rate q) const;
        Real CIA(Integer n, Real barrier, Real strike, Rate r, Rate q) const;
        Real g1(Real barrier, Real strike, Rate b)const;
        Real g2(Real barrier, Real strike, Rate b)const;
        Real g3(Real barrier, Real strike, Rate b)const;
        Real g4(Real barrier, Real strike, Rate b)const;
        Real HS(Real S, Real H, Real power)const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="25">
    <source>barrier/analyticsoftbarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2025 William Day

 This file is part of QuantLib, a free-software/open-source librarys
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticsoftbarrierengine.hpp
    \brief Analytic soft barrier european option pricing engine
*/

#ifndef quantlib_analytic_soft_barrier_engine_hpp
#define quantlib_analytic_soft_barrier_engine_hpp

#include <ql/instruments/softbarrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {

    //! Pricing engine for soft barrier european options using an analytical formula
    /*! Formulas are taken from "The complete guide to option pricing formulas 2nd Ed", E.G. Haug, p.165.
        Implements a closed form solution for soft barrier options originally introduced by Hart and Ross (1994).
    */

    class AnalyticSoftBarrierEngine : public SoftBarrierOption::engine {
      public:
        explicit AnalyticSoftBarrierEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);

        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        CumulativeNormalDistribution f_;

        void validateInputs(Real S, Real X, Rate r, Rate q, Time T, Real U, Real L,
                    Option::Type optionType, Barrier::Type barrierType,
                    Real sigma) const;


        // Helper methods to extract parameters
        Real underlying() const;
        Real strike() const;
        Time residualTime() const;
        Volatility volatility() const;
        Real volatilitySquared() const;
        Real barrierLo() const;
        Real barrierHi() const;
        Real stdDeviation() const;
        Rate riskFreeRate() const;
        DiscountFactor riskFreeDiscount() const;
        Rate dividendYield() const; 
        Rate costOfCarry() const;  
        DiscountFactor dividendDiscount() const;

        // Pricing helpers 
        Real vanillaEquivalent() const;    // Computes the equivalent vanilla  option price (with no barriers)
        Real standardBarrierEquivalent() const; // for when U=L
        Real knockInValue(Real S, Real X, Rate r, Volatility sigma, Time T, Real U, Real L, Real b, Option::Type optionType, Integer eta) const;

    };

}

#endif]]></document_content>
  </document>
  <document index="26">
    <source>barrier/analytictwoassetbarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analytictwoassetbarrierengine.hpp
    \brief Analytic engine for barrier option on two assets
*/

#ifndef quantlib_analytic_two_asset_barrier_engine_hpp
#define quantlib_analytic_two_asset_barrier_engine_hpp

#include <ql/instruments/twoassetbarrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic engine for %barrier %option on two assets
    /*! The formulas by Heynen and Kat are taken from Haug, "Option
        pricing formulas".

        \ingroup barrierengines

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
     */
    class AnalyticTwoAssetBarrierEngine
        : public TwoAssetBarrierOption::engine {
      public:
        AnalyticTwoAssetBarrierEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
                                      ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
                                      Handle<Quote> rho);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2_;
        Handle<Quote> rho_;

        // helper methods
        Real underlying1() const;
        Real underlying2() const;

        Real strike() const;
        Time residualTime() const;

        Volatility volatility1() const;
        Volatility volatility2() const;

        Real barrier() const;
        Real rho() const;

        Rate riskFreeRate() const;

        Rate dividendYield1() const;
        Rate dividendYield2() const;

        Rate costOfCarry1() const;
        Rate costOfCarry2() const;

        Real mu(Real b, Real vol) const;

        Real d1() const;
        Real d2() const;
        Real d3() const;
        Real d4() const;

        Real e1() const;
        Real e2() const;
        Real e3() const;
        Real e4() const;

        Real call() const;
        Real put() const;

        Real A(Real eta, Real phi) const;
        Real B(Real eta, Real phi) const;

        Real M(Real m_a, Real m_b,Real rho) const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="27">
    <source>barrier/binomialbarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file binomialbarrierengine.hpp
    \brief Binomial Barrier option engine
*/

#ifndef quantlib_binomial_barrier_engine_hpp
#define quantlib_binomial_barrier_engine_hpp

#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/methods/lattices/binomialtree.hpp>
#include <ql/methods/lattices/bsmlattice.hpp>
#include <ql/pricingengines/barrier/discretizedbarrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <type_traits>
#include <utility>

namespace QuantLib {

    //! Pricing engine for barrier options using binomial trees
    /*! \ingroup barrierengines

        \note Timesteps for Cox-Ross-Rubinstein trees are adjusted using Boyle and Lau algorithm.
              See Journal of Derivatives, 1/1994,
              "Bumping up against the barrier with the binomial method"

        \test the correctness of the returned values is tested by
              checking it against analytic european results.
    */
    template <class T, class D>
    class BinomialBarrierEngine : public BarrierOption::engine {
      public:
        /*! The maxTimeSteps parameter is used to limit timeSteps when
            using Boyle-Lau optimization. If zero (the default) the
            maximum number of steps is calculated by an heuristic:
            anything when < 1000, otherwise no more than 5*timeSteps.
            If maxTimeSteps is equal to timeSteps, Boyle-Lau is
            disabled.  Likewise if the lattice is not
            CoxRossRubinstein Boyle-Lau is disabled and maxTimeSteps
            ignored.
        */
        BinomialBarrierEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                              Size timeSteps,
                              Size maxTimeSteps = 0)
        : process_(std::move(process)), timeSteps_(timeSteps), maxTimeSteps_(maxTimeSteps) {
            QL_REQUIRE(timeSteps>0,
                       "timeSteps must be positive, " << timeSteps <<
                       " not allowed");
            QL_REQUIRE(maxTimeSteps==0 || maxTimeSteps>=timeSteps,
                       "maxTimeSteps must be zero or "
                       "greater than or equal to timeSteps, "
                       << maxTimeSteps << " not allowed");
            if (maxTimeSteps_==0)
               maxTimeSteps_ = std::max( (Size)1000, timeSteps_*5);
            registerWith(process_);
        }
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Size timeSteps_;
        Size maxTimeSteps_;
    };


    // template definitions

    template <class T, class D>
    void BinomialBarrierEngine<T,D>::calculate() const {

        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");
        QL_REQUIRE(payoff->strike() > 0.0, "strike must be positive");

        Real s0 = process_->stateVariable()->value();
        QL_REQUIRE(s0 > 0.0, "negative or null underlying given");
        QL_REQUIRE(!triggered(s0), "barrier touched");

        DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
        DayCounter divdc = process_->dividendYield()->dayCounter();
        DayCounter voldc = process_->blackVolatility()->dayCounter();
        Calendar volcal = process_->blackVolatility()->calendar();

        Volatility v = process_->blackVolatility()->blackVol(
            arguments_.exercise->lastDate(), s0);
        Date maturityDate = arguments_.exercise->lastDate();
        Rate r = process_->riskFreeRate()->zeroRate(maturityDate,
            rfdc, Continuous, NoFrequency);
        Rate q = process_->dividendYield()->zeroRate(maturityDate,
            divdc, Continuous, NoFrequency);
        Date referenceDate = process_->riskFreeRate()->referenceDate();

        // binomial trees with constant coefficient
        Handle<YieldTermStructure> flatRiskFree(
            ext::shared_ptr<YieldTermStructure>(
                new FlatForward(referenceDate, r, rfdc)));
        Handle<YieldTermStructure> flatDividends(
            ext::shared_ptr<YieldTermStructure>(
                new FlatForward(referenceDate, q, divdc)));
        Handle<BlackVolTermStructure> flatVol(
            ext::shared_ptr<BlackVolTermStructure>(
                new BlackConstantVol(referenceDate, volcal, v, voldc)));

        Time maturity = rfdc.yearFraction(referenceDate, maturityDate);

        ext::shared_ptr<StochasticProcess1D> bs(
                         new GeneralizedBlackScholesProcess(
                                      process_->stateVariable(),
                                      flatDividends, flatRiskFree, flatVol));

        // correct timesteps to ensure a (local) minimum, using Boyle and Lau
        // approach. See Journal of Derivatives, 1/1994,
        // "Bumping up against the barrier with the binomial method"
        // Note: this approach works only for CoxRossRubinstein lattices, so
        // is disabled if T is not a CoxRossRubinstein or derived from it.
        Size optimum_steps = timeSteps_;
        if (std::is_base_of_v<CoxRossRubinstein, T> &&
            maxTimeSteps_ > timeSteps_ && s0 > 0 && arguments_.barrier > 0) {
            Real divisor;
            if (s0 > arguments_.barrier)
               divisor = std::pow(std::log(s0 / arguments_.barrier), 2);
            else
               divisor = std::pow(std::log(arguments_.barrier / s0), 2);
            if (!close(divisor,0)) {
                for (Size i=1; i < timeSteps_ ; ++i) {
                    Size optimum = Size(( i*i * v*v * maturity) / divisor);
                    if (timeSteps_ < optimum) {
                        optimum_steps = optimum;
                        break; // found first minimum with iterations>=timesteps
                    }
                }
            }

            if (optimum_steps > maxTimeSteps_) 
               optimum_steps = maxTimeSteps_; // too high, limit
        }

        TimeGrid grid(maturity, optimum_steps);

        ext::shared_ptr<T> tree(new T(bs, maturity, optimum_steps,
                                        payoff->strike()));

        ext::shared_ptr<BlackScholesLattice<T> > lattice(
            new BlackScholesLattice<T>(tree, r, maturity, optimum_steps));

        D option(arguments_, *process_, grid);
        option.initialize(lattice, maturity);

        // Partial derivatives calculated from various points in the
        // binomial tree 
        // (see J.C.Hull, "Options, Futures and other derivatives", 6th edition, pp 397/398)

        // Rollback to third-last step, and get underlying prices (s2) &
        // option values (p2) at this point
        option.rollback(grid[2]);
        Array va2(option.values());
        QL_ENSURE(va2.size() == 3, "Expect 3 nodes in grid at second step");
        Real p2u = va2[2]; // up
        Real p2m = va2[1]; // mid
        Real p2d = va2[0]; // down (low)
        Real s2u = lattice->underlying(2, 2); // up price
        Real s2m = lattice->underlying(2, 1); // middle price
        Real s2d = lattice->underlying(2, 0); // down (low) price

        // calculate gamma by taking the first derivate of the two deltas
        Real delta2u = (p2u - p2m)/(s2u-s2m);
        Real delta2d = (p2m-p2d)/(s2m-s2d);
        Real gamma = (delta2u - delta2d) / ((s2u-s2d)/2);

        // Rollback to second-last step, and get option values (p1) at
        // this point
        option.rollback(grid[1]);
        Array va(option.values());
        QL_ENSURE(va.size() == 2, "Expect 2 nodes in grid at first step");
        Real p1u = va[1];
        Real p1d = va[0];
        Real s1u = lattice->underlying(1, 1); // up (high) price
        Real s1d = lattice->underlying(1, 0); // down (low) price

        Real delta = (p1u - p1d) / (s1u - s1d);

        // Finally, rollback to t=0
        option.rollback(0.0);
        Real p0 = option.presentValue();

        // Store results
        results_.value = p0;
        results_.delta = delta;
        results_.gamma = gamma;
        // theta can be approximated by calculating the numerical derivative
        // between mid value at third-last step and at t0. The underlying price
        // is the same, only time varies.
        results_.theta = (p2m - p0) / grid[2];
    }

}


#endif
]]></document_content>
  </document>
  <document index="28">
    <source>barrier/discretizedbarrieroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file discretizedbarrieroption.hpp
    \brief discretized barrier option
*/

#ifndef quantlib_discretized_barrier_option_h
#define quantlib_discretized_barrier_option_h

#include <ql/discretizedasset.hpp>
#include <ql/methods/lattices/bsmlattice.hpp>
#include <ql/instruments/barrieroption.hpp>
#include <ql/pricingengines/vanilla/discretizedvanillaoption.hpp>

namespace QuantLib {

    class DiscretizedBarrierOption : public DiscretizedAsset {
      public:
        DiscretizedBarrierOption(const BarrierOption::arguments&,
                                 const StochasticProcess& process,
                                 const TimeGrid& grid = TimeGrid());

        void reset(Size size) override;

        const Array& vanilla() const { 
            return vanilla_.values(); 
        }

        const BarrierOption::arguments& arguments() const {
           return arguments_;
        }

        std::vector<Time> mandatoryTimes() const override { return stoppingTimes_; }

        void checkBarrier(Array &optvalues, const Array &grid) const;
      protected:
        void postAdjustValuesImpl() override;

      private:
        BarrierOption::arguments arguments_;
        std::vector<Time> stoppingTimes_;
        DiscretizedVanillaOption vanilla_; 
    };

    class DiscretizedDermanKaniBarrierOption : public DiscretizedAsset {
      public:
        DiscretizedDermanKaniBarrierOption(const BarrierOption::arguments&,
                                 const StochasticProcess& process,
                                 const TimeGrid& grid = TimeGrid());

        void reset(Size size) override;

        std::vector<Time> mandatoryTimes() const override { return unenhanced_.mandatoryTimes(); }

      protected:
        void postAdjustValuesImpl() override;

      private:
        void adjustBarrier(Array &optvalues, const Array &grid);
        DiscretizedBarrierOption unenhanced_;
    };
}





#endif
]]></document_content>
  </document>
  <document index="29">
    <source>barrier/fdblackscholesbarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdblackscholesbarrierengine.hpp
    \brief Finite-differences Black/Scholes barrier-option engine
*/

#ifndef quantlib_fd_black_scholes_barrier_engine_hpp
#define quantlib_fd_black_scholes_barrier_engine_hpp

#include <ql/processes/blackscholesprocess.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/instruments/barrieroption.hpp>

namespace QuantLib {

    //! Finite-differences Black/Scholes barrier-option engine
    /*! \ingroup barrierengines

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature
              and comparison with Black pricing.
    */
    class FdBlackScholesBarrierEngine : public BarrierOption::engine {
      public:
        explicit FdBlackScholesBarrierEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process,
            Size tGrid = 100,
            Size xGrid = 100,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas(),
            bool localVol = false,
            Real illegalLocalVolOverwrite = -Null<Real>());

        explicit FdBlackScholesBarrierEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process,
            DividendSchedule dividends,
            Size tGrid = 100,
            Size xGrid = 100,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas(),
            bool localVol = false,
            Real illegalLocalVolOverwrite = -Null<Real>());

        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        DividendSchedule dividends_;
        Size tGrid_, xGrid_, dampingSteps_;
        FdmSchemeDesc schemeDesc_;
        bool localVol_;
        Real illegalLocalVolOverwrite_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="30">
    <source>barrier/fdblackscholesrebateengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdblackscholesrebateengine.hpp
    \brief Finite-differences Black/Scholes barrier option rebate helper engine
*/

#ifndef quantlib_fd_black_scholes_rebate_engine_hpp
#define quantlib_fd_black_scholes_rebate_engine_hpp

#include <ql/processes/blackscholesprocess.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/instruments/barrieroption.hpp>

namespace QuantLib {

    //! Finite-differences Black/Scholes barrier-option rebate helper engine
    /*! \ingroup barrierengines */
    class FdBlackScholesRebateEngine : public BarrierOption::engine {
      public:
        explicit FdBlackScholesRebateEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process,
            Size tGrid = 100,
            Size xGrid = 100,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas(),
            bool localVol = false,
            Real illegalLocalVolOverwrite = -Null<Real>());

        explicit FdBlackScholesRebateEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process,
            DividendSchedule dividends,
            Size tGrid = 100,
            Size xGrid = 100,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas(),
            bool localVol = false,
            Real illegalLocalVolOverwrite = -Null<Real>());

        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        DividendSchedule dividends_;
        Size tGrid_, xGrid_, dampingSteps_;
        FdmSchemeDesc schemeDesc_;
        bool localVol_;
        Real illegalLocalVolOverwrite_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="31">
    <source>barrier/fdhestonbarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdhestonbarrierengine.hpp
    \brief Finite-differences Heston barrier-option engine
*/

#ifndef quantlib_fd_heston_barrier_engine_hpp
#define quantlib_fd_heston_barrier_engine_hpp

#include <ql/models/equity/hestonmodel.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/methods/finitedifferences/solvers/fdmhestonsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>
#include <ql/instruments/barrieroption.hpp>

namespace QuantLib {

    //! Finite-differences Heston barrier-option engine
    /*! \ingroup barrierengines

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature
              and comparison with Black pricing.
    */
    class FdHestonBarrierEngine
        : public GenericModelEngine<HestonModel,
                                    BarrierOption::arguments,
                                    BarrierOption::results> {
      public:
        explicit FdHestonBarrierEngine(
            const ext::shared_ptr<HestonModel>& model,
            Size tGrid = 100,
            Size xGrid = 100,
            Size vGrid = 50,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer(),
            ext::shared_ptr<LocalVolTermStructure> leverageFct = {},
            Real mixingFactor = 1.0);

        explicit FdHestonBarrierEngine(
            const ext::shared_ptr<HestonModel>& model,
            DividendSchedule dividends,
            Size tGrid = 100,
            Size xGrid = 100,
            Size vGrid = 50,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer(),
            ext::shared_ptr<LocalVolTermStructure> leverageFct = {},
            Real mixingFactor = 1.0);

        void calculate() const override;

      private:
        DividendSchedule dividends_;
        Size tGrid_, xGrid_, vGrid_, dampingSteps_;
        FdmSchemeDesc schemeDesc_;
        ext::shared_ptr<LocalVolTermStructure> leverageFct_;
        Real mixingFactor_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="32">
    <source>barrier/fdhestondoublebarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdhestondoublebarrierengine.hpp
    \brief Finite-Differences Heston double barrier option engine
*/

#ifndef quantlib_fd_heston_double_barrier_engine_hpp
#define quantlib_fd_heston_double_barrier_engine_hpp

#include <ql/instruments/doublebarrieroption.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/methods/finitedifferences/solvers/fdmhestonsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>


namespace QuantLib {

    //! Finite-Differences Heston Double Barrier Option engine

    /*!
        \ingroup barrierengines
    */
    class FdHestonDoubleBarrierEngine
        : public GenericModelEngine<HestonModel,
                                    DoubleBarrierOption::arguments,
                                    DoubleBarrierOption::results> {
      public:
        // Constructor
        explicit FdHestonDoubleBarrierEngine(
            const ext::shared_ptr<HestonModel>& model,
            Size tGrid = 100,
            Size xGrid = 100,
            Size vGrid = 50,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer(),
            ext::shared_ptr<LocalVolTermStructure> leverageFct =
                ext::shared_ptr<LocalVolTermStructure>(),
            Real mixingFactor = 1.0);

        void calculate() const override;

      private:
        const Size tGrid_, xGrid_, vGrid_, dampingSteps_;
        const FdmSchemeDesc schemeDesc_;
        const ext::shared_ptr<LocalVolTermStructure> leverageFct_;
        const Real mixingFactor_;
    };


}

#endif
]]></document_content>
  </document>
  <document index="33">
    <source>barrier/fdhestonrebateengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdhestonrebateengine.hpp
    \brief Finite-differences Heston barrier-option rebate helper engine
*/

#ifndef quantlib_fd_heston_rebate_engine_hpp
#define quantlib_fd_heston_rebate_engine_hpp

#include <ql/models/equity/hestonmodel.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/methods/finitedifferences/solvers/fdmhestonsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/instruments/barrieroption.hpp>
#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>

namespace QuantLib {

    //! Finite-differences Heston barrier-option rebate helper engine
    /*! \ingroup barrierengines */
    class FdHestonRebateEngine
        : public GenericModelEngine<HestonModel,
                                    BarrierOption::arguments,
                                    BarrierOption::results> {
      public:
        explicit FdHestonRebateEngine(
            const ext::shared_ptr<HestonModel>& model,
            Size tGrid = 100,
            Size xGrid = 100,
            Size vGrid = 50,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer(),
                ext::shared_ptr<LocalVolTermStructure> leverageFct = {},
            Real mixingFactor = 1.0);

        explicit FdHestonRebateEngine(
            const ext::shared_ptr<HestonModel>& model,
            DividendSchedule dividends,
            Size tGrid = 100,
            Size xGrid = 100,
            Size vGrid = 50,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer(),
                ext::shared_ptr<LocalVolTermStructure> leverageFct = {},
            Real mixingFactor = 1.0);

        void calculate() const override;

      private:
        DividendSchedule dividends_;
        const Size tGrid_, xGrid_, vGrid_, dampingSteps_;
        const FdmSchemeDesc schemeDesc_;
        const ext::shared_ptr<LocalVolTermStructure> leverageFct_;
        const Real mixingFactor_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="34">
    <source>barrier/mcbarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Neil Firth
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2003, 2004, 2005, 2007, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mcbarrierengine.hpp
    \brief Monte Carlo barrier option engines
*/

#ifndef quantlib_mc_barrier_engines_hpp
#define quantlib_mc_barrier_engines_hpp

#include <ql/exercise.hpp>
#include <ql/instruments/barrieroption.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    //! Pricing engine for barrier options using Monte Carlo simulation
    /*! Uses the Brownian-bridge correction for the barrier found in
        <i>
        Going to Extremes: Correcting Simulation Bias in Exotic
        Option Valuation - D.R. Beaglehole, P.H. Dybvig and G. Zhou
        Financial Analysts Journal; Jan/Feb 1997; 53, 1. pg. 62-68
        </i>
        and
        <i>
        Simulating path-dependent options: A new approach -
        M. El Babsiri and G. Noel
        Journal of Derivatives; Winter 1998; 6, 2; pg. 65-83
        </i>

        \ingroup barrierengines

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    template <class RNG = PseudoRandom, class S = Statistics>
    class MCBarrierEngine : public BarrierOption::engine,
                            public McSimulation<SingleVariate,RNG,S> {
      public:
        typedef
        typename McSimulation<SingleVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef typename McSimulation<SingleVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename McSimulation<SingleVariate,RNG,S>::stats_type
            stats_type;
        // constructor
        MCBarrierEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                        Size timeSteps,
                        Size timeStepsPerYear,
                        bool brownianBridge,
                        bool antitheticVariate,
                        Size requiredSamples,
                        Real requiredTolerance,
                        Size maxSamples,
                        bool isBiased,
                        BigNatural seed);
        void calculate() const override {
            Real spot = process_->x0();
            QL_REQUIRE(spot > 0.0, "negative or null underlying given");
            QL_REQUIRE(!triggered(spot), "barrier touched");
            McSimulation<SingleVariate,RNG,S>::calculate(requiredTolerance_,
                                                         requiredSamples_,
                                                         maxSamples_);
            results_.value = this->mcModel_->sampleAccumulator().mean();
            if constexpr (RNG::allowsErrorEstimate)
                results_.errorEstimate =
                    this->mcModel_->sampleAccumulator().errorEstimate();
        }

      protected:
        // McSimulation implementation
        TimeGrid timeGrid() const override;
        ext::shared_ptr<path_generator_type> pathGenerator() const override {
            TimeGrid grid = timeGrid();
            typename RNG::rsg_type gen =
                RNG::make_sequence_generator(grid.size()-1,seed_);
            return ext::shared_ptr<path_generator_type>(
                         new path_generator_type(process_,
                                                 grid, gen, brownianBridge_));
        }
        ext::shared_ptr<path_pricer_type> pathPricer() const override;
        // data members
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Size timeSteps_, timeStepsPerYear_;
        Size requiredSamples_, maxSamples_;
        Real requiredTolerance_;
        bool isBiased_;
        bool brownianBridge_;
        BigNatural seed_;
    };


    //! Monte Carlo barrier-option engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCBarrierEngine {
      public:
        MakeMCBarrierEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);
        // named parameters
        MakeMCBarrierEngine& withSteps(Size steps);
        MakeMCBarrierEngine& withStepsPerYear(Size steps);
        MakeMCBarrierEngine& withBrownianBridge(bool b = true);
        MakeMCBarrierEngine& withAntitheticVariate(bool b = true);
        MakeMCBarrierEngine& withSamples(Size samples);
        MakeMCBarrierEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCBarrierEngine& withMaxSamples(Size samples);
        MakeMCBarrierEngine& withBias(bool b = true);
        MakeMCBarrierEngine& withSeed(BigNatural seed);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        bool brownianBridge_ = false, antithetic_ = false, biased_ = false;
        Size steps_, stepsPerYear_, samples_, maxSamples_;
        Real tolerance_;
        BigNatural seed_ = 0;
    };


    class BarrierPathPricer : public PathPricer<Path> {
      public:
        BarrierPathPricer(Barrier::Type barrierType,
                          Real barrier,
                          Real rebate,
                          Option::Type type,
                          Real strike,
                          std::vector<DiscountFactor> discounts,
                          ext::shared_ptr<StochasticProcess1D> diffProcess,
                          PseudoRandom::ursg_type sequenceGen);
        Real operator()(const Path& path) const override;

      private:
        Barrier::Type barrierType_;
        Real barrier_;
        Real rebate_;
        ext::shared_ptr<StochasticProcess1D> diffProcess_;
        PseudoRandom::ursg_type sequenceGen_;
        PlainVanillaPayoff payoff_;
        std::vector<DiscountFactor> discounts_;
    };


    class BiasedBarrierPathPricer : public PathPricer<Path> {
      public:
        BiasedBarrierPathPricer(Barrier::Type barrierType,
                                Real barrier,
                                Real rebate,
                                Option::Type type,
                                Real strike,
                                std::vector<DiscountFactor> discounts);
        Real operator()(const Path& path) const override;

      private:
        Barrier::Type barrierType_;
        Real barrier_;
        Real rebate_;
        PlainVanillaPayoff payoff_;
        std::vector<DiscountFactor> discounts_;
    };



    // template definitions

    template <class RNG, class S>
    inline MCBarrierEngine<RNG, S>::MCBarrierEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Size timeSteps,
        Size timeStepsPerYear,
        bool brownianBridge,
        bool antitheticVariate,
        Size requiredSamples,
        Real requiredTolerance,
        Size maxSamples,
        bool isBiased,
        BigNatural seed)
    : McSimulation<SingleVariate, RNG, S>(antitheticVariate, false), process_(std::move(process)),
      timeSteps_(timeSteps), timeStepsPerYear_(timeStepsPerYear), requiredSamples_(requiredSamples),
      maxSamples_(maxSamples), requiredTolerance_(requiredTolerance), isBiased_(isBiased),
      brownianBridge_(brownianBridge), seed_(seed) {
        QL_REQUIRE(timeSteps != Null<Size>() ||
                   timeStepsPerYear != Null<Size>(),
                   "no time steps provided");
        QL_REQUIRE(timeSteps == Null<Size>() ||
                   timeStepsPerYear == Null<Size>(),
                   "both time steps and time steps per year were provided");
        QL_REQUIRE(timeSteps != 0,
                   "timeSteps must be positive, " << timeSteps <<
                   " not allowed");
        QL_REQUIRE(timeStepsPerYear != 0,
                   "timeStepsPerYear must be positive, " << timeStepsPerYear <<
                   " not allowed");
        registerWith(process_);
    }

    template <class RNG, class S>
    inline TimeGrid MCBarrierEngine<RNG,S>::timeGrid() const {

        Time residualTime = process_->time(arguments_.exercise->lastDate());
        if (timeSteps_ != Null<Size>()) {
            return TimeGrid(residualTime, timeSteps_);
        } else if (timeStepsPerYear_ != Null<Size>()) {
            Size steps = static_cast<Size>(timeStepsPerYear_*residualTime);
            return TimeGrid(residualTime, std::max<Size>(steps, 1));
        } else {
            QL_FAIL("time steps not specified");
        }
    }


    template <class RNG, class S>
    inline
    ext::shared_ptr<typename MCBarrierEngine<RNG,S>::path_pricer_type>
    MCBarrierEngine<RNG,S>::pathPricer() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        TimeGrid grid = timeGrid();
        std::vector<DiscountFactor> discounts(grid.size());
        for (Size i=0; i<grid.size(); i++)
            discounts[i] = process_->riskFreeRate()->discount(grid[i]);

        // do this with template parameters?
        if (isBiased_) {
            return ext::shared_ptr<
                        typename MCBarrierEngine<RNG,S>::path_pricer_type>(
                new BiasedBarrierPathPricer(
                       arguments_.barrierType,
                       arguments_.barrier,
                       arguments_.rebate,
                       payoff->optionType(),
                       payoff->strike(),
                       discounts));
        } else {
            PseudoRandom::ursg_type sequenceGen(grid.size()-1,
                                                PseudoRandom::urng_type(5));
            return ext::shared_ptr<
                        typename MCBarrierEngine<RNG,S>::path_pricer_type>(
                new BarrierPathPricer(
                    arguments_.barrierType,
                    arguments_.barrier,
                    arguments_.rebate,
                    payoff->optionType(),
                    payoff->strike(),
                    discounts,
                    process_,
                    sequenceGen));
        }
    }


    template <class RNG, class S>
    inline MakeMCBarrierEngine<RNG, S>::MakeMCBarrierEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)), steps_(Null<Size>()), stepsPerYear_(Null<Size>()),
      samples_(Null<Size>()), maxSamples_(Null<Size>()), tolerance_(Null<Real>()) {}

    template <class RNG, class S>
    inline MakeMCBarrierEngine<RNG,S>&
    MakeMCBarrierEngine<RNG,S>::withSteps(Size steps) {
        steps_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCBarrierEngine<RNG,S>&
    MakeMCBarrierEngine<RNG,S>::withStepsPerYear(Size steps) {
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCBarrierEngine<RNG,S>&
    MakeMCBarrierEngine<RNG,S>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCBarrierEngine<RNG,S>&
    MakeMCBarrierEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCBarrierEngine<RNG,S>&
    MakeMCBarrierEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCBarrierEngine<RNG,S>&
    MakeMCBarrierEngine<RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCBarrierEngine<RNG,S>&
    MakeMCBarrierEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCBarrierEngine<RNG,S>&
    MakeMCBarrierEngine<RNG,S>::withBias(bool biased) {
        biased_ = biased;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCBarrierEngine<RNG,S>&
    MakeMCBarrierEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCBarrierEngine<RNG,S>::operator ext::shared_ptr<PricingEngine>()
                                                                      const {
        QL_REQUIRE(steps_ != Null<Size>() || stepsPerYear_ != Null<Size>(),
                   "number of steps not given");
        QL_REQUIRE(steps_ == Null<Size>() || stepsPerYear_ == Null<Size>(),
                   "number of steps overspecified");
        return ext::shared_ptr<PricingEngine>(new
            MCBarrierEngine<RNG,S>(process_,
                                   steps_,
                                   stepsPerYear_,
                                   brownianBridge_,
                                   antithetic_,
                                   samples_, tolerance_,
                                   maxSamples_,
                                   biased_,
                                   seed_));
    }

}


#endif
]]></document_content>
  </document>
  <document index="35">
    <source>basket/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/pricingengines/basket/bjerksundstenslandspreadengine.hpp>
#include <ql/pricingengines/basket/choibasketengine.hpp>
#include <ql/pricingengines/basket/denglizhoubasketengine.hpp>
#include <ql/pricingengines/basket/fd2dblackscholesvanillaengine.hpp>
#include <ql/pricingengines/basket/fdndimblackscholesvanillaengine.hpp>
#include <ql/pricingengines/basket/kirkengine.hpp>
#include <ql/pricingengines/basket/mcamericanbasketengine.hpp>
#include <ql/pricingengines/basket/mceuropeanbasketengine.hpp>
#include <ql/pricingengines/basket/operatorsplittingspreadengine.hpp>
#include <ql/pricingengines/basket/singlefactorbsmbasketengine.hpp>
#include <ql/pricingengines/basket/spreadblackscholesvanillaengine.hpp>
#include <ql/pricingengines/basket/stulzengine.hpp>
#include <ql/pricingengines/basket/vectorbsmprocessextractor.hpp>

]]></document_content>
  </document>
  <document index="36">
    <source>basket/bjerksundstenslandspreadengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2024 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bjerksundstenslandspreadengine.hpp
    \brief Bjerksund and Stensland formulae (2006)
*/

#ifndef quantlib_bjerksund_stensland_spread_engine_hpp
#define quantlib_bjerksund_stensland_spread_engine_hpp

#include <ql/pricingengines/basket/spreadblackscholesvanillaengine.hpp>

namespace QuantLib {

    //! Pricing engine for spread option on two futures
    /*! P. Bjerksund and G. Stensland,
        Closed form spread option valuation,
        Quantitative Finance, 14 (2014), pp. 1785–1794.

        \ingroup basketengines
    */
    class BjerksundStenslandSpreadEngine : public SpreadBlackScholesVanillaEngine {
      public:
        BjerksundStenslandSpreadEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
            ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
            Real correlation);

      protected:
        Real calculate(Real f1, Real f2, Real strike, Option::Type optionType,
            Real variance1, Real variance2, DiscountFactor df) const override;
    };
}


#endif
]]></document_content>
  </document>
  <document index="37">
    <source>basket/choibasketengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2024 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file choibasketengine.hpp
    \brief Jaehyuk Choi: Sum of all Black-Scholes-Merton Models
*/

#ifndef quantlib_choi_basket_engine_hpp
#define quantlib_choi_basket_engine_hpp

#include <ql/instruments/basketoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Pricing engine for basket option on multiple underlyings
    /*! This class implements the pricing formula from
        "Sum of all Black-Scholes-Merton Models: An efficient Pricing Method for
        Spread, Basket and Asian Options", Jaehyuk Choi, 2018
        https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2913048

        A Python implementation from the author of the paper is also available
        https://github.com/PyFE/PyFENG

        \ingroup basketengines

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class ChoiBasketEngine : public BasketOption::engine {
      public:
        // lambda controls the integration order and the precision of the result.
        ChoiBasketEngine(
            std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > processes,
            Matrix rho,
            Real lambda = 10.0,
            Size maxNrIntegrationSteps = std::numeric_limits<Size>::max(),
            bool calcfwdDelta = false,
            bool controlVariate = false);

        void calculate() const override;

      private:
        const Size n_;
        const std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > processes_;
        const Matrix rho_;
        const Real lambda_;
        const Size maxNrIntegrationSteps_;
        const bool calcFwdDelta_, controlVariate_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="38">
    <source>basket/denglizhoubasketengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2024 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file denglizhoubasketengine.hpp
    \brief Deng, Li and Zhou: Closed-Form Approximation for Spread option pricing
*/

#ifndef quantlib_deng_li_zhou_basket_engine_hpp
#define quantlib_deng_li_zhou_basket_engine_hpp

#include <ql/instruments/basketoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Pricing engine for basket option on multiple underlyings
    /*! This class implements the pricing formula from
        "Multi-asset Spread Option Pricing and Hedging",
        S. Deng, M. Li, J.Zhou, 2008
        https://mpra.ub.uni-muenchen.de/8259/1/MPRA_paper_8259.pdf

        The typo in formula (37) for J^2 is corrected

        This pricing formula only works if exactly one asset weight is positive.
        If more than one weight is positive then a mapping of the sum of correlated
        log-normal processes onto one log-normal process has to be carried out.
        This implementation is using:
        "WKB Approximation for the Sum of Two Correlated Lognormal Random Variables",
        C.F. Lo 2013
        https://www.m-hikari.com/ams/ams-2013/ams-125-128-2013/loAMS125-128-2013.pdf
        for this task.

        \ingroup basketengines

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class DengLiZhouBasketEngine : public BasketOption::engine {
      public:
        DengLiZhouBasketEngine(
            std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > processes,
            Matrix rho);

        void calculate() const override;

      private:
        static Real calculate_vanilla_call(
            const Array& s, DiscountFactor dr, const Array& dq,
            const Array& v, const Matrix& rho, Time T);

        static Real I(Real u, Real tF2, const Matrix& D, const Matrix& DF, Size i);

        const Size n_;
        const std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > processes_;
        const Matrix rho_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="39">
    <source>basket/fd2dblackscholesvanillaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fd2dblackscholesvanillaengine.hpp
    \brief Finite-Differences 2 dim Black Scholes vanilla option engine
*/

#ifndef quantlib_fd_2d_black_scholes_vanilla_engine_hpp
#define quantlib_fd_2d_black_scholes_vanilla_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/instruments/basketoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    //! Two dimensional finite-differences Black Scholes vanilla option engine

    /*! \ingroup basketengines

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature
              and comparison with Kirk approximation.
    */
    class Fd2dBlackScholesVanillaEngine : public BasketOption::engine {
      public:
          Fd2dBlackScholesVanillaEngine(
                const ext::shared_ptr<GeneralizedBlackScholesProcess>& p1,
                const ext::shared_ptr<GeneralizedBlackScholesProcess>& p2,
                Real correlation,
                Size xGrid = 100, Size yGrid = 100, 
                Size tGrid = 50, Size dampingSteps = 0,
                const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer(),
                bool localVol = false,
                Real illegalLocalVolOverwrite = -Null<Real>());

          void calculate() const override;

        private:
          const ext::shared_ptr<GeneralizedBlackScholesProcess> p1_;
          const ext::shared_ptr<GeneralizedBlackScholesProcess> p2_;
          const Real correlation_;
          const Size xGrid_, yGrid_, tGrid_;
          const Size dampingSteps_;
          const FdmSchemeDesc schemeDesc_;
          const bool localVol_;
          const Real illegalLocalVolOverwrite_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="40">
    <source>basket/fdndimblackscholesvanillaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2024 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdndimblackscholesvanillaengine.hpp
    \brief Finite-Differences n-dimensional Black-Scholes vanilla option engine
*/

#ifndef quantlib_fd_ndim_black_scholes_vanilla_engine_hpp
#define quantlib_fd_ndim_black_scholes_vanilla_engine_hpp

#include <ql/math/matrix.hpp>
#include <ql/instruments/basketoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    class GeneralizedBlackScholesProcess;

    //! n-dimensional finite-differences Black Scholes vanilla option engine

    /*! \ingroup basketengines

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature
              and comparison with the PyFENG python package.
    */
    class FdndimBlackScholesVanillaEngine : public BasketOption::engine {
      public:
        FdndimBlackScholesVanillaEngine(
            std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > processes,
            Matrix rho,
            std::vector<Size> xGrids,
            Size tGrid = 50, Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas());


        // Auto-scaling of grids, largest eigenvalue gets xGrid size.
        FdndimBlackScholesVanillaEngine(
            std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > processes,
            Matrix rho,
            Size xGrid, Size tGrid = 50, Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas());

        void calculate() const override;

      private:
        const std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > processes_;
        const Matrix rho_;
        const std::vector<Size> xGrids_;
        const Size tGrid_, dampingSteps_;
        const FdmSchemeDesc schemeDesc_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="41">
    <source>basket/kirkengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file kirkengine.hpp
    \brief kirk formulae, due to Kirk (1995)
*/

#ifndef quantlib_kirk_engine_hpp
#define quantlib_kirk_engine_hpp

#include <ql/pricingengines/basket/spreadblackscholesvanillaengine.hpp>

namespace QuantLib {

    //! Pricing engine for spread option on two futures
    /*! This class implements formulae from
        "Correlation in the Energy Markets", E. Kirk
        Managing Energy Price Risk. 
        London: Risk Publications and Enron, pp. 71-78

        \ingroup basketengines

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class KirkEngine : public SpreadBlackScholesVanillaEngine {
      public:
        KirkEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
                   ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
                   Real correlation);

      protected:
        Real calculate(Real f1, Real f2, Real strike, Option::Type optionType,
            Real variance1, Real variance2, DiscountFactor df) const override;
    };
}


#endif
]]></document_content>
  </document>
  <document index="42">
    <source>basket/mcamericanbasketengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Neil Firth
 Copyright (C) 2006 Klaus Spanderen
 Copyright (C) 2007, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mcamericanbasketengine.hpp
    \brief Least-square Monte Carlo engines
*/

#ifndef quantlib_american_basket_montecarlo_engine_hpp
#define quantlib_american_basket_montecarlo_engine_hpp

#include <ql/exercise.hpp>
#include <ql/instruments/basketoption.hpp>
#include <ql/methods/montecarlo/lsmbasissystem.hpp>
#include <ql/pricingengines/mclongstaffschwartzengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/stochasticprocessarray.hpp>
#include <functional>
#include <utility>

namespace QuantLib {

    //! least-square Monte Carlo engine
    /*! \warning This method is intrinsically weak for out-of-the-money
                 options.

        \ingroup basketengines
    */
    template <class RNG = PseudoRandom>
    class MCAmericanBasketEngine
        : public MCLongstaffSchwartzEngine<BasketOption::engine,
                                           MultiVariate,RNG> {
      public:
        MCAmericanBasketEngine(const ext::shared_ptr<StochasticProcessArray>&,
                               Size timeSteps,
                               Size timeStepsPerYear,
                               bool brownianBridge,
                               bool antitheticVariate,
                               Size requiredSamples,
                               Real requiredTolerance,
                               Size maxSamples,
                               BigNatural seed,
                               Size nCalibrationSamples = Null<Size>(),
                               Size polynomialOrder = 2,
                               LsmBasisSystem::PolynomialType polynomialType = LsmBasisSystem::Monomial);
      protected:
        ext::shared_ptr<LongstaffSchwartzPathPricer<MultiPath> > lsmPathPricer() const override;

      private:
        const Size polynomialOrder_;
        const LsmBasisSystem::PolynomialType polynomialType_;
    };


    //! Monte Carlo American basket-option engine factory
    template <class RNG = PseudoRandom>
    class MakeMCAmericanBasketEngine {
      public:
        MakeMCAmericanBasketEngine(ext::shared_ptr<StochasticProcessArray>);
        // named parameters
        MakeMCAmericanBasketEngine& withSteps(Size steps);
        MakeMCAmericanBasketEngine& withStepsPerYear(Size steps);
        MakeMCAmericanBasketEngine& withBrownianBridge(bool b = true);
        MakeMCAmericanBasketEngine& withAntitheticVariate(bool b = true);
        MakeMCAmericanBasketEngine& withSamples(Size samples);
        MakeMCAmericanBasketEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCAmericanBasketEngine& withMaxSamples(Size samples);
        MakeMCAmericanBasketEngine& withSeed(BigNatural seed);
        MakeMCAmericanBasketEngine& withCalibrationSamples(Size samples);
        MakeMCAmericanBasketEngine& withPolynomialOrder(Size polynmOrder);
        MakeMCAmericanBasketEngine& withBasisSystem(LsmBasisSystem::PolynomialType polynomialType);

        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<StochasticProcessArray> process_;
        bool brownianBridge_ = false, antithetic_ = false;
        Size steps_, stepsPerYear_, samples_, maxSamples_, calibrationSamples_,
            polynomialOrder_ = 2;
        LsmBasisSystem::PolynomialType polynomialType_ = LsmBasisSystem::Monomial;
        Real tolerance_;
        BigNatural seed_ = 0;
    };


    class AmericanBasketPathPricer
        : public EarlyExercisePathPricer<MultiPath>  {
      public:
        AmericanBasketPathPricer(
            Size assetNumber,
            ext::shared_ptr<Payoff> payoff,
            Size polynomialOrder = 2,
            LsmBasisSystem::PolynomialType polynomialType = LsmBasisSystem::Monomial);

        Array state(const MultiPath& path, Size t) const override;
        Real operator()(const MultiPath& path, Size t) const override;

        std::vector<std::function<Real(Array)> > basisSystem() const override;

      protected:
        Real payoff(const Array& state) const;

        const Size assetNumber_;
        const ext::shared_ptr<Payoff> payoff_;

        Real scalingValue_ = 1.0;
        std::vector<std::function<Real(Array)> > v_;
    };

    template <class RNG> inline
    MCAmericanBasketEngine<RNG>::MCAmericanBasketEngine(
                   const ext::shared_ptr<StochasticProcessArray>& processes,
                   Size timeSteps,
                   Size timeStepsPerYear,
                   bool brownianBridge,
                   bool antitheticVariate,
                   Size requiredSamples,
                   Real requiredTolerance,
                   Size maxSamples,
                   BigNatural seed,
                   Size nCalibrationSamples,
                   Size polynomialOrder,
                   LsmBasisSystem::PolynomialType polynomialType)
        : MCLongstaffSchwartzEngine<BasketOption::engine,
                                    MultiVariate,RNG>(processes,
                                                      timeSteps,
                                                      timeStepsPerYear,
                                                      brownianBridge,
                                                      antitheticVariate,
                                                      false,
                                                      requiredSamples,
                                                      requiredTolerance,
                                                      maxSamples,
                                                      seed,
                                                      nCalibrationSamples),
          polynomialOrder_(polynomialOrder), polynomialType_(polynomialType) {}

    template <class RNG>
    inline ext::shared_ptr<LongstaffSchwartzPathPricer<MultiPath> >
    MCAmericanBasketEngine<RNG>::lsmPathPricer() const {

        ext::shared_ptr<StochasticProcessArray> processArray =
            ext::dynamic_pointer_cast<StochasticProcessArray>(
                                                              this->process_);
        QL_REQUIRE(processArray && processArray->size()>0,
                   "Stochastic process array required");

        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
               processArray->process(0));
        QL_REQUIRE(process, "generalized Black-Scholes process required");

        ext::shared_ptr<EarlyExercise> exercise =
            ext::dynamic_pointer_cast<EarlyExercise>(
                this->arguments_.exercise);
        QL_REQUIRE(exercise, "wrong exercise given");
        QL_REQUIRE(!exercise->payoffAtExpiry(),
                   "payoff at expiry not handled");

        ext::shared_ptr<AmericanBasketPathPricer> earlyExercisePathPricer(
            new AmericanBasketPathPricer(processArray->size(),
                                         this->arguments_.payoff,
                                         polynomialOrder_,
                                         polynomialType_));

        return ext::make_shared<LongstaffSchwartzPathPricer<MultiPath> > (
             
                     this->timeGrid(),
                     earlyExercisePathPricer,
                     *(process->riskFreeRate()));
    }


    template <class RNG>
    inline MakeMCAmericanBasketEngine<RNG>::MakeMCAmericanBasketEngine(
        ext::shared_ptr<StochasticProcessArray> process)
    : process_(std::move(process)), steps_(Null<Size>()), stepsPerYear_(Null<Size>()),
      samples_(Null<Size>()), maxSamples_(Null<Size>()), calibrationSamples_(Null<Size>()),
      tolerance_(Null<Real>()) {}

    template <class RNG>
    inline MakeMCAmericanBasketEngine<RNG>&
    MakeMCAmericanBasketEngine<RNG>::withSteps(Size steps) {
        steps_ = steps;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanBasketEngine<RNG>&
    MakeMCAmericanBasketEngine<RNG>::withStepsPerYear(Size steps) {
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanBasketEngine<RNG>&
    MakeMCAmericanBasketEngine<RNG>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanBasketEngine<RNG>&
    MakeMCAmericanBasketEngine<RNG>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanBasketEngine<RNG>&
    MakeMCAmericanBasketEngine<RNG>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanBasketEngine<RNG>&
    MakeMCAmericanBasketEngine<RNG>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanBasketEngine<RNG>&
    MakeMCAmericanBasketEngine<RNG>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanBasketEngine<RNG>&
    MakeMCAmericanBasketEngine<RNG>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanBasketEngine<RNG>&
    MakeMCAmericanBasketEngine<RNG>::withCalibrationSamples(Size samples) {
        calibrationSamples_ = samples;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanBasketEngine<RNG>&
    MakeMCAmericanBasketEngine<RNG>::withPolynomialOrder(Size polynomialOrder) {
        polynomialOrder_ = polynomialOrder;
        return *this;
    }

    template <class RNG>
    inline MakeMCAmericanBasketEngine<RNG>&
    MakeMCAmericanBasketEngine<RNG>::withBasisSystem(LsmBasisSystem::PolynomialType polynomialType) {
        polynomialType_ = polynomialType;
        return *this;
    }

    template <class RNG>
    inline
    MakeMCAmericanBasketEngine<RNG>::operator
    ext::shared_ptr<PricingEngine>() const {
        QL_REQUIRE(steps_ != Null<Size>() || stepsPerYear_ != Null<Size>(),
                   "number of steps not given");
        QL_REQUIRE(steps_ == Null<Size>() || stepsPerYear_ == Null<Size>(),
                   "number of steps overspecified");
        return ext::shared_ptr<PricingEngine>(new
            MCAmericanBasketEngine<RNG>(process_,
                                        steps_,
                                        stepsPerYear_,
                                        brownianBridge_,
                                        antithetic_,
                                        samples_,
                                        tolerance_,
                                        maxSamples_,
                                        seed_,
                                        calibrationSamples_,
                                        polynomialOrder_,
                                        polynomialType_));
    }

}

#endif
]]></document_content>
  </document>
  <document index="43">
    <source>basket/mceuropeanbasketengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Neil Firth
 Copyright (C) 2007, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mceuropeanbasketengine.hpp
    \brief European basket MC Engine
*/

#ifndef quantlib_mc_european_basket_engine_hpp
#define quantlib_mc_european_basket_engine_hpp

#include <ql/exercise.hpp>
#include <ql/instruments/basketoption.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/stochasticprocessarray.hpp>
#include <utility>

namespace QuantLib {

    //! Pricing engine for European basket options using Monte Carlo simulation
    /*! \ingroup basketengines

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    template <class RNG = PseudoRandom, class S = Statistics>
    class MCEuropeanBasketEngine  : public BasketOption::engine,
                                    public McSimulation<MultiVariate,RNG,S> {
      public:
        typedef typename McSimulation<MultiVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef typename McSimulation<MultiVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename McSimulation<MultiVariate,RNG,S>::stats_type
            stats_type;
        // constructor
        MCEuropeanBasketEngine(ext::shared_ptr<StochasticProcessArray>,
                               Size timeSteps,
                               Size timeStepsPerYear,
                               bool brownianBridge,
                               bool antitheticVariate,
                               Size requiredSamples,
                               Real requiredTolerance,
                               Size maxSamples,
                               BigNatural seed);
        void calculate() const override {
            McSimulation<MultiVariate,RNG,S>::calculate(requiredTolerance_,
                                                        requiredSamples_,
                                                        maxSamples_);
            results_.value = this->mcModel_->sampleAccumulator().mean();
            if constexpr (RNG::allowsErrorEstimate)
                results_.errorEstimate =
                    this->mcModel_->sampleAccumulator().errorEstimate();
        }

      protected:
        // McSimulation implementation
        TimeGrid timeGrid() const override;
        ext::shared_ptr<path_generator_type> pathGenerator() const override {
            Size numAssets = processes_->size();

            TimeGrid grid = timeGrid();
            typename RNG::rsg_type gen =
                RNG::make_sequence_generator(numAssets*(grid.size()-1),seed_);

            return ext::shared_ptr<path_generator_type>(
                         new path_generator_type(processes_,
                                                 grid, gen, brownianBridge_));
        }
        ext::shared_ptr<path_pricer_type> pathPricer() const override;
        // data members
        ext::shared_ptr<StochasticProcessArray> processes_;
        Size timeSteps_, timeStepsPerYear_;
        Size requiredSamples_;
        Size maxSamples_;
        Real requiredTolerance_;
        bool brownianBridge_;
        BigNatural seed_;
    };


    //! Monte Carlo basket-option engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCEuropeanBasketEngine {
      public:
        MakeMCEuropeanBasketEngine(ext::shared_ptr<StochasticProcessArray>);
        // named parameters
        MakeMCEuropeanBasketEngine& withSteps(Size steps);
        MakeMCEuropeanBasketEngine& withStepsPerYear(Size steps);
        MakeMCEuropeanBasketEngine& withBrownianBridge(bool b = true);
        MakeMCEuropeanBasketEngine& withAntitheticVariate(bool b = true);
        MakeMCEuropeanBasketEngine& withSamples(Size samples);
        MakeMCEuropeanBasketEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCEuropeanBasketEngine& withMaxSamples(Size samples);
        MakeMCEuropeanBasketEngine& withSeed(BigNatural seed);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<StochasticProcessArray> process_;
        bool brownianBridge_ = false, antithetic_ = false;
        Size steps_, stepsPerYear_, samples_, maxSamples_;
        Real tolerance_;
        BigNatural seed_ = 0;
    };


    class EuropeanMultiPathPricer : public PathPricer<MultiPath> {
      public:
        EuropeanMultiPathPricer(ext::shared_ptr<BasketPayoff> payoff, DiscountFactor discount);
        Real operator()(const MultiPath& multiPath) const override;

      private:
        ext::shared_ptr<BasketPayoff> payoff_;
        DiscountFactor discount_;
    };


    // template definitions

    template <class RNG, class S>
    inline MCEuropeanBasketEngine<RNG, S>::MCEuropeanBasketEngine(
        ext::shared_ptr<StochasticProcessArray> processes,
        Size timeSteps,
        Size timeStepsPerYear,
        bool brownianBridge,
        bool antitheticVariate,
        Size requiredSamples,
        Real requiredTolerance,
        Size maxSamples,
        BigNatural seed)
    : McSimulation<MultiVariate, RNG, S>(antitheticVariate, false),
      processes_(std::move(processes)), timeSteps_(timeSteps), timeStepsPerYear_(timeStepsPerYear),
      requiredSamples_(requiredSamples), maxSamples_(maxSamples),
      requiredTolerance_(requiredTolerance), brownianBridge_(brownianBridge), seed_(seed) {
        QL_REQUIRE(timeSteps != Null<Size>() ||
                   timeStepsPerYear != Null<Size>(),
                   "no time steps provided");
        QL_REQUIRE(timeSteps == Null<Size>() ||
                   timeStepsPerYear == Null<Size>(),
                   "both time steps and time steps per year were provided");
        QL_REQUIRE(timeSteps != 0,
                   "timeSteps must be positive, " << timeSteps <<
                   " not allowed");
        QL_REQUIRE(timeStepsPerYear != 0,
                   "timeStepsPerYear must be positive, " << timeStepsPerYear <<
                   " not allowed");
        registerWith(processes_);
    }

    template <class RNG, class S>
    inline TimeGrid MCEuropeanBasketEngine<RNG,S>::timeGrid() const {

        Time residualTime = processes_->time(
                                       this->arguments_.exercise->lastDate());
        if (timeSteps_ != Null<Size>()) {
            return TimeGrid(residualTime, timeSteps_);
        } else if (timeStepsPerYear_ != Null<Size>()) {
            Size steps = static_cast<Size>(timeStepsPerYear_*residualTime);
            return TimeGrid(residualTime, std::max<Size>(steps, 1));
        } else {
            QL_FAIL("time steps not specified");
        }
    }

    template <class RNG, class S>
    inline
    ext::shared_ptr<typename MCEuropeanBasketEngine<RNG,S>::path_pricer_type>
    MCEuropeanBasketEngine<RNG,S>::pathPricer() const {

        ext::shared_ptr<BasketPayoff> payoff =
            ext::dynamic_pointer_cast<BasketPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-basket payoff given");

        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                                                      processes_->process(0));
        QL_REQUIRE(process, "Black-Scholes process required");

        return ext::shared_ptr<
                    typename MCEuropeanBasketEngine<RNG,S>::path_pricer_type>(
            new EuropeanMultiPathPricer(payoff,
                                        process->riskFreeRate()->discount(
                                           arguments_.exercise->lastDate())));
    }


    template <class RNG, class S>
    inline MakeMCEuropeanBasketEngine<RNG, S>::MakeMCEuropeanBasketEngine(
        ext::shared_ptr<StochasticProcessArray> process)
    : process_(std::move(process)), steps_(Null<Size>()), stepsPerYear_(Null<Size>()),
      samples_(Null<Size>()), maxSamples_(Null<Size>()), tolerance_(Null<Real>()) {}

    template <class RNG, class S>
    inline MakeMCEuropeanBasketEngine<RNG,S>&
    MakeMCEuropeanBasketEngine<RNG,S>::withSteps(Size steps) {
        steps_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanBasketEngine<RNG,S>&
    MakeMCEuropeanBasketEngine<RNG,S>::withStepsPerYear(Size steps) {
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanBasketEngine<RNG,S>&
    MakeMCEuropeanBasketEngine<RNG,S>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanBasketEngine<RNG,S>&
    MakeMCEuropeanBasketEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanBasketEngine<RNG,S>&
    MakeMCEuropeanBasketEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanBasketEngine<RNG,S>&
    MakeMCEuropeanBasketEngine<RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanBasketEngine<RNG,S>&
    MakeMCEuropeanBasketEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanBasketEngine<RNG,S>&
    MakeMCEuropeanBasketEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCEuropeanBasketEngine<RNG,S>::operator
    ext::shared_ptr<PricingEngine>() const {
        QL_REQUIRE(steps_ != Null<Size>() || stepsPerYear_ != Null<Size>(),
                   "number of steps not given");
        QL_REQUIRE(steps_ == Null<Size>() || stepsPerYear_ == Null<Size>(),
                   "number of steps overspecified");
        return ext::shared_ptr<PricingEngine>(new
            MCEuropeanBasketEngine<RNG,S>(process_,
                                          steps_,
                                          stepsPerYear_,
                                          brownianBridge_,
                                          antithetic_,
                                          samples_, tolerance_,
                                          maxSamples_,
                                          seed_));
    }

}


#endif
]]></document_content>
  </document>
  <document index="44">
    <source>basket/operatorsplittingspreadengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2024 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file operatorsplittingspreadengine.hpp
    \brief Analytic operator splitting approximation by Chi-Fai Lo (2015)
*/

#ifndef quantlib_operator_splitting_spread_engine_hpp
#define quantlib_operator_splitting_spread_engine_hpp

#include <ql/pricingengines/basket/spreadblackscholesvanillaengine.hpp>

namespace QuantLib {

    //! Pricing engine for spread options with two assets
    /*! Chi-Fai Lo,
        Pricing Spread Options by the Operator Splitting Method,
        https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2429696

        \ingroup basketengines
    */
    class OperatorSplittingSpreadEngine : public SpreadBlackScholesVanillaEngine {
      public:
        enum Order {First, Second};
        OperatorSplittingSpreadEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
            ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
            Real correlation,
            Order order = Second);

      protected:
        Real calculate(Real f1, Real f2, Real strike, Option::Type optionType,
            Real variance1, Real variance2, DiscountFactor df) const override;

        const Order order_;
    };
}


#endif
]]></document_content>
  </document>
  <document index="45">
    <source>basket/singlefactorbsmbasketengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2024 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file singlefactorbsmbasketengine.hpp
    \brief Basket engine where all underlyings are driven by one stochastic factor
*/

#ifndef quantlib_single_factor_bsm_basket_engine_hpp
#define quantlib_single_factor_bsm_basket_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/instruments/basketoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Pricing engine for baskets where all underlyings are driven by one stochastic factor
    /*! Jaehyuk Choi,
        Sum of all Black-Scholes-Merton Models:
        An efficient Pricing Method for Spread, Basket and Asian Options,
        https://arxiv.org/pdf/1805.03172

        \ingroup basketengines
    */

    class SingleFactorBsmBasketEngine : public BasketOption::engine {
      public:
        explicit SingleFactorBsmBasketEngine(
            std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > p,
            Real xTol = 1e4*QL_EPSILON);

        void calculate() const override;

      private:
        const Real xTol_;
        const Size n_;
        const std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > processes_;
    };

    namespace detail {
        class SumExponentialsRootSolver {
          public:
            enum Strategy {Ridder, Newton, Brent, Halley};

            SumExponentialsRootSolver(Array a, Array sig, Real K);

            Real operator()(Real x) const;
            Real derivative(Real x) const;
            Real secondDerivative(Real x) const;

            Real getRoot(Real xTol = 1e6*QL_EPSILON, Strategy strategy = Brent) const;

            Size getFCtr() const;
            Size getDerivativeCtr() const;
            Size getSecondDerivativeCtr() const;

          private:
            const Array a_, sig_;
            const Real K_;
            mutable Size fCtr_ = 0, fPrimeCtr_ = 0, fDoublePrimeCtr_ = 0;
        };
    }
}


#endif
]]></document_content>
  </document>
  <document index="46">
    <source>basket/spreadblackscholesvanillaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2024 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file spreadblackscholesvanillaengine.hpp
    \brief base class for 2d spread pricing engines using the Black-Scholes model.
*/

#ifndef quantlib_spread_black_scholes_vanilla_engine_hpp
#define quantlib_spread_black_scholes_vanilla_engine_hpp

#include <ql/instruments/basketoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    class SpreadBlackScholesVanillaEngine : public BasketOption::engine {
      public:
        SpreadBlackScholesVanillaEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
            ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
            Real correlation);

        void calculate() const override;

      protected:
        virtual Real calculate(
           Real f1, Real f2, Real strike, Option::Type optionType,
           Real variance1, Real variance2, DiscountFactor df) const = 0;

        const ext::shared_ptr<GeneralizedBlackScholesProcess> process1_;
        const ext::shared_ptr<GeneralizedBlackScholesProcess> process2_;
        const Real rho_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="47">
    <source>basket/stulzengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Neil Firth
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file stulzengine.hpp
    \brief 2D European Basket formulae, due to Stulz (1982)
*/

#ifndef quantlib_stulz_engine_hpp
#define quantlib_stulz_engine_hpp

#include <ql/instruments/basketoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Pricing engine for 2D European Baskets
    /*! This class implements formulae from
        "Options on the Minimum or the Maximum of Two Risky Assets",
            Rene Stulz,
            Journal of Financial Ecomomics (1982) 10, 161-185.

        \ingroup basketengines

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class StulzEngine : public BasketOption::engine {
      public:
        StulzEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
                    ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
                    Real correlation);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2_;
        Real rho_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="48">
    <source>basket/vectorbsmprocessextractor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2024 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vectorbsmprocessextractor.hpp
    \brief helper class to extract underlying, volatility etc from a vector of processes
*/

#ifndef quantlib_vector_bsm_process_extractor_hpp
#define quantlib_vector_bsm_process_extractor_hpp

#include <ql/processes/blackscholesprocess.hpp>
#include <functional>

namespace QuantLib::detail {

        class VectorBsmProcessExtractor {
          public:
            explicit VectorBsmProcessExtractor(
                std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > p);

            Array getSpot() const;
            Array getBlackStdDev(const Date& maturityDate) const;
            Array getBlackVariance(const Date& maturityDate) const;
            Array getDividendYieldDf(const Date& maturityDate) const;
            DiscountFactor getInterestRateDf(const Date& maturityDate) const;

          private:
            Array extractProcesses(
                const std::function<Real(const ext::shared_ptr<GeneralizedBlackScholesProcess>&)>& f) const;

            const std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > processes_;
        };

}


#endif
]]></document_content>
  </document>
  <document index="49">
    <source>blackcalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004, 2005, 2006 Ferdinando Ametrano
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file blackcalculator.hpp
    \brief Black-formula calculator class
*/

#ifndef quantlib_blackcalculator_hpp
#define quantlib_blackcalculator_hpp

#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    //! Black 1976 calculator class
    class BlackCalculator {
      private:
        class Calculator;
      public:
        BlackCalculator(const ext::shared_ptr<StrikedTypePayoff>& payoff,
                        Real forward,
                        Real stdDev,
                        Real discount = 1.0);
        BlackCalculator(Option::Type optionType,
                        Real strike,
                        Real forward,
                        Real stdDev,
                        Real discount = 1.0);
        virtual ~BlackCalculator() = default;

        Real value() const;

        /*! Sensitivity to change in the underlying forward price. */
        Real deltaForward() const;
        /*! Sensitivity to change in the underlying spot price. */
        virtual Real delta(Real spot) const;

        /*! Sensitivity in percent to a percent change in the
            underlying forward price. */
        Real elasticityForward() const;
        /*! Sensitivity in percent to a percent change in the
            underlying spot price. */
        virtual Real elasticity(Real spot) const;

        /*! Second order derivative with respect to change in the
            underlying forward price. */
        Real gammaForward() const;
        /*! Second order derivative with respect to change in the
            underlying spot price. */
        virtual Real gamma(Real spot) const;

        /*! Sensitivity to time to maturity. */
        virtual Real theta(Real spot,
                           Time maturity) const;
        /*! Sensitivity to time to maturity per day,
            assuming 365 day per year. */
        virtual Real thetaPerDay(Real spot,
                                 Time maturity) const;

        /*! Sensitivity to volatility. */
        Real vega(Time maturity) const;

        /*! Sensitivity to discounting rate. */
        Real rho(Time maturity) const;

        /*! Sensitivity to dividend/growth rate. */
        Real dividendRho(Time maturity) const;

        /*! Probability of being in the money in the bond martingale
            measure, i.e. N(d2).
            It is a risk-neutral probability, not the real world one.
        */
        Real itmCashProbability() const;

        /*! Probability of being in the money in the asset martingale
            measure, i.e. N(d1).
            It is a risk-neutral probability, not the real world one.
        */
        Real itmAssetProbability() const;

        /*! Sensitivity to strike. */
        Real strikeSensitivity() const;

        /*! gamma w.r.t. strike. */
        Real strikeGamma() const;

        /*! Sensitivity of vega to spot (Vanna) */
        Real vanna(Real spot, Time maturity) const;

        /*! Sensitivity of vega to volatility (Volga) */
        Real volga(Time maturity) const;

        Real alpha() const;
        Real beta() const;
        
      protected:
        void initialize(const ext::shared_ptr<StrikedTypePayoff>& p);
        
        Real strike_, forward_, stdDev_, discount_, variance_;
        Real d1_, d2_;
        Real alpha_, beta_, DalphaDd1_, DbetaDd2_;
        Real n_d1_, cum_d1_, n_d2_, cum_d2_;
        Real x_, DxDs_, DxDstrike_;
    };

    // inline
    inline Real BlackCalculator::thetaPerDay(Real spot,
                                             Time maturity) const {
        return theta(spot, maturity)/365.0;
    }

    inline Real BlackCalculator::itmCashProbability() const {
        return cum_d2_;
    }

    inline Real BlackCalculator::itmAssetProbability() const {
        return cum_d1_;
    }

    inline Real BlackCalculator::alpha() const {
        return alpha_;
    }

    inline Real BlackCalculator::beta() const {
        return beta_;
    }

}

#endif
]]></document_content>
  </document>
  <document index="50">
    <source>blackdeltacalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file blackdeltacalculator.hpp
    \brief Black-Scholes formula delta calculator class
*/

#ifndef quantlib_black_delta_calculator_hpp
#define quantlib_black_delta_calculator_hpp

#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/quotes/deltavolquote.hpp>

namespace QuantLib {

    //! Black delta calculator class
    /*! Class includes many operations needed for different applications
        in FX markets, which has special quotation mechanisms, since
        every price can be expressed in both numeraires.
    */
    class BlackDeltaCalculator {
      public:
        //! \name Constructors
        //@{
        /*!
            \brief Constructs a BlackDeltaCalculator object 
            This class provides methods to calculate option delta and strike values
            using the Black-Scholes formula, supporting various FX delta conventions
            (spot, forward, premium-adjusted, etc.). It is designed for efficient
            repeated calculations across different strikes, which is useful in
            volatility smile construction and calibration routines.

            \param ot Option type (call or put)
            \param dt Delta type (spot, forward, premium-adjusted, etc.)
            \param spot Spot FX rate
            \param dDiscount Domestic discount factor
            \param fDiscount Foreign discount factor
            \param stdDev Standard deviation of the underlying
            
            \warning instead of volatility it uses standard deviation,
                 i.e. volatility*sqrt(timeToMaturity)
        */
        BlackDeltaCalculator(Option::Type ot,
                             DeltaVolQuote::DeltaType dt,
                             Real spot,
                             DiscountFactor dDiscount,   // domestic discount
                             DiscountFactor fDiscount,   // foreign discount
                             Real stdDev);
        //@}

        /*!
            \brief Computes the option delta for a given strike.

            Calculates the delta of an option using the Black-Scholes formula,
            according to the delta convention specified at construction (spot, forward, premium-adjusted, etc.).

            \param strike The option strike price.
            \return       The option delta under the chosen convention.
        */
        Real deltaFromStrike(Real strike) const;

        /*!
            \brief Computes the strike corresponding to a given delta.

            Inverts the Black-Scholes formula to find the strike that yields the specified delta,
            according to the delta convention set at construction. Used for constructing volatility smiles
            and for quoting FX options by delta.

            \param delta  The target option delta (under the chosen convention).
            \return       The strike price corresponding to the given delta.
        */
        Real strikeFromDelta(Real delta) const;

        /*!
            \brief Calculates the at-the-money (ATM) strike for the given ATM convention.
            
            Computes the strike price that corresponds to "at-the-money" under different conventions
            commonly used in FX markets. This method does not require an explicit strike input
            as it determines the ATM level based on the specified convention.
            
            \param atmT The ATM convention to use:
                       - AtmNull: No ATM convention (returns null)
                       - AtmSpot: ATM strike equals the current spot rate
                       - AtmForward: ATM strike equals the forward rate
                       - AtmDeltaNeutral: ATM strike where call and put deltas sum to zero
                       - AtmVegaMax: ATM strike that maximizes vega (typically close to forward)
                       - AtmGammaMax: ATM strike that maximizes gamma
                       - AtmPutCall25: ATM strike where 25-delta call and put have equal volatility
            
            \return The ATM strike price according to the specified convention.
            
            \note This calculation is independent of the strike and uses the forward rate,
                  volatility, and time to expiration set at construction.
        */
        Real atmStrike(DeltaVolQuote::AtmType atmT) const;

        /*!
            \brief Sets the delta calculation convention.
            
            \param dt The new delta type convention:
        */
        void setDeltaType(DeltaVolQuote::DeltaType dt);

        /*!
            \brief Sets the option type (call or put).
                      
            \param ot The option type
        */
        void setOptionType(Option::Type ot);

        /*! \deprecated Internal: do not use.
                        Deprecated in version 1.40.
                        This method will be moved in the private section  
        */
        [[deprecated("Internal: do not use")]]
        Real cumD1(Real strike) const;    // N(d1) or N(-d1)

        /*! \deprecated Internal: do not use.
                        Deprecated in version 1.40.
                        This method will be moved in the private section  
        */
        [[deprecated("Internal: do not use")]]
        Real cumD2(Real strike) const;    // N(d2) or N(-d2)
        
        /*! \deprecated Internal: do not use.
                        Deprecated in version 1.40.
                        This method will be moved in the private section  
        */
        [[deprecated("Internal: do not use")]]
        Real nD1(Real strike) const;      // n(d1)

        /*! \deprecated Internal: do not use.
                        Deprecated in version 1.40.
                        This method will be moved in the private section  
        */
        [[deprecated("Internal: do not use")]]
        Real nD2(Real strike) const;      // n(d2)

      private:
        // alternative delta type
        Real strikeFromDelta(Real delta, DeltaVolQuote::DeltaType dt) const;

        DeltaVolQuote::DeltaType dt_;
        Option::Type ot_;
        DiscountFactor dDiscount_, fDiscount_;
        Real stdDev_, spot_, forward_;
        Integer phi_;
        Real fExpPos_,fExpNeg_;
    };


    /*! \deprecated Obsolete: do not use.
                    Deprecated in version 1.40.
    */
    class [[deprecated("Obsolete: do not use")]] BlackDeltaPremiumAdjustedSolverClass {
      public:
        BlackDeltaPremiumAdjustedSolverClass(
                        Option::Type ot,
                        DeltaVolQuote::DeltaType dt,
                        Real spot,
                        DiscountFactor dDiscount,   // domestic discount
                        DiscountFactor fDiscount,   // foreign  discount
                        Real stdDev,
                        Real delta);

        Real operator()(Real strike) const;

      private:
        BlackDeltaCalculator bdc_;
        Real delta_;
    };


    /*! \deprecated Obsolete: do not use.
                    Deprecated in version 1.40.
    */
    class [[deprecated("Obsolete: do not use")]] BlackDeltaPremiumAdjustedMaxStrikeClass {
      public:
        BlackDeltaPremiumAdjustedMaxStrikeClass(
                        Option::Type ot,
                        DeltaVolQuote::DeltaType dt,
                        Real spot,
                        DiscountFactor dDiscount,   // domestic discount
                        DiscountFactor fDiscount,   // foreign  discount
                        Real stdDev);

        Real operator()(Real strike) const;

      private:
        BlackDeltaCalculator bdc_;
        Real stdDev_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="51">
    <source>blackformula.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2003, 2004, 2005, 2006, 2008 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi
 Copyright (C) 2006 StatPro Italia srl
 Copyright (C) 2007 Cristina Duminuco
 Copyright (C) 2007 Chiara Fornarola
 Copyright (C) 2013 Gary Kennedy
 Copyright (C) 2015, 2024 Peter Caspers
 Copyright (C) 2017 Klaus Spanderen
 Copyright (C) 2019 Wojciech Ślusarski
 Copyright (C) 2020 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file blackformula.hpp
    \brief Black formula
*/

#ifndef quantlib_blackformula_hpp
#define quantlib_blackformula_hpp

#include <ql/instruments/payoffs.hpp>
#include <ql/option.hpp>

namespace QuantLib {

    /*! Black 1976 formula
        \warning instead of volatility it uses standard deviation,
                 i.e. volatility*sqrt(timeToMaturity)
    */
    Real blackFormula(Option::Type optionType,
                      Real strike,
                      Real forward,
                      Real stdDev,
                      Real discount = 1.0,
                      Real displacement = 0.0);

    /*! Black 1976 formula
        \warning instead of volatility it uses standard deviation,
                 i.e. volatility*sqrt(timeToMaturity)
    */
    Real blackFormula(const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                      Real forward,
                      Real stdDev,
                      Real discount = 1.0,
                      Real displacement = 0.0);

    /*! Black 1976 model forward derivative
        \warning instead of volatility it uses standard deviation,
                 i.e. volatility*sqrt(timeToMaturity)
    */
    Real blackFormulaForwardDerivative(Option::Type optionType,
                                       Real strike,
                                       Real forward,
                                       Real stdDev,
                                       Real discount = 1.0,
                                       Real displacement = 0.0);

    /*! Black 1976 model forward derivative
        \warning instead of volatility it uses standard deviation,
                 i.e. volatility*sqrt(timeToMaturity)
    */
    Real blackFormulaForwardDerivative(const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                                       Real forward,
                                       Real stdDev,
                                       Real discount = 1.0,
                                       Real displacement = 0.0);

    /*! Approximated Black 1976 implied standard deviation,
        i.e. volatility*sqrt(timeToMaturity).

        It is calculated using Brenner and Subrahmanyan (1988) and Feinstein
        (1988) approximation for at-the-money forward option, with the
        extended moneyness approximation by Corrado and Miller (1996)
    */
    Real blackFormulaImpliedStdDevApproximation(Option::Type optionType,
                                                Real strike,
                                                Real forward,
                                                Real blackPrice,
                                                Real discount = 1.0,
                                                Real displacement = 0.0);

    /*! Approximated Black 1976 implied standard deviation,
        i.e. volatility*sqrt(timeToMaturity).

        It is calculated using Brenner and Subrahmanyan (1988) and Feinstein
        (1988) approximation for at-the-money forward option, with the
        extended moneyness approximation by Corrado and Miller (1996)
    */
    Real blackFormulaImpliedStdDevApproximation(const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                                                Real forward,
                                                Real blackPrice,
                                                Real discount = 1.0,
                                                Real displacement = 0.0);

    /*! Approximated Black 1976 implied standard deviation,
        i.e. volatility*sqrt(timeToMaturity).

        It is calculated following "An improved approach to computing
        implied volatility", Chambers, Nawalkha, The Financial Review,
        2001, 89-100. The atm option price must be known to use this
        method.
    */
    Real blackFormulaImpliedStdDevChambers(Option::Type optionType,
                                           Real strike,
                                           Real forward,
                                           Real blackPrice,
                                           Real blackAtmPrice,
                                           Real discount = 1.0,
                                           Real displacement = 0.0);

    /*! Approximated Black 1976 implied standard deviation,
        i.e. volatility*sqrt(timeToMaturity).

        It is calculated following "An improved approach to computing
        implied volatility", Chambers, Nawalkha, The Financial Review,
        2001, 89-100. The atm option price must be known to use this
        method.
    */
    Real blackFormulaImpliedStdDevChambers(const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                                           Real forward,
                                           Real blackPrice,
                                           Real blackAtmPrice,
                                           Real discount = 1.0,
                                           Real displacement = 0.0);

    /*! Approximated Black 1976 implied standard deviation,
        i.e. volatility*sqrt(timeToMaturity).

        It is calculated using

        "An Explicit Implicit Volatility Formula"
        R. Radoicic, D. Stefanica,
        https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2908494

        "Tighter Bounds for Implied Volatility",
        J. Gatheral, I. Matic, R. Radoicic, D. Stefanica
        https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2922742
    */
    Real blackFormulaImpliedStdDevApproximationRS(Option::Type optionType,
                                                  Real strike,
                                                  Real forward,
                                                  Real blackPrice,
                                                  Real discount = 1.0,
                                                  Real displacement = 0.0);

    Real blackFormulaImpliedStdDevApproximationRS(const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                                                  Real forward,
                                                  Real blackPrice,
                                                  Real discount = 1.0,
                                                  Real displacement = 0.0);


    /*! Black 1976 implied standard deviation,
        i.e. volatility*sqrt(timeToMaturity)
    */
    Real blackFormulaImpliedStdDev(Option::Type optionType,
                                   Real strike,
                                   Real forward,
                                   Real blackPrice,
                                   Real discount = 1.0,
                                   Real displacement = 0.0,
                                   Real guess = Null<Real>(),
                                   Real accuracy = 1.0e-6,
                                   Natural maxIterations = 100);

    /*! Black 1976 implied standard deviation,
        i.e. volatility*sqrt(timeToMaturity)
    */
    Real blackFormulaImpliedStdDev(const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                                   Real forward,
                                   Real blackPrice,
                                   Real discount = 1.0,
                                   Real displacement = 0.0,
                                   Real guess = Null<Real>(),
                                   Real accuracy = 1.0e-6,
                                   Natural maxIterations = 100);

    /*! Black 1976 implied standard deviation,
         i.e. volatility*sqrt(timeToMaturity)

        "An Adaptive Successive Over-relaxation Method for Computing the
        Black-Scholes Implied Volatility"
        M. Li, http://mpra.ub.uni-muenchen.de/6867/


        Starting point of the iteration is calculated based on

        "An Explicit Implicit Volatility Formula"
        R. Radoicic, D. Stefanica,
        https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2908494
    */
    Real blackFormulaImpliedStdDevLiRS(Option::Type optionType,
                                       Real strike,
                                       Real forward,
                                       Real blackPrice,
                                       Real discount = 1.0,
                                       Real displacement = 0.0,
                                       Real guess = Null<Real>(),
                                       Real omega = 1.0,
                                       Real accuracy = 1.0e-6,
                                       Natural maxIterations = 100);

    Real blackFormulaImpliedStdDevLiRS(const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                                       Real forward,
                                       Real blackPrice,
                                       Real discount = 1.0,
                                       Real displacement = 0.0,
                                       Real guess = Null<Real>(),
                                       Real omega = 1.0,
                                       Real accuracy = 1.0e-6,
                                       Natural maxIterations = 100);

    /*! Black 1976 probability of being in the money (in the bond martingale
        measure), i.e. N(d2).
        It is a risk-neutral probability, not the real world one.
        \warning instead of volatility it uses standard deviation,
                 i.e. volatility*sqrt(timeToMaturity)
    */
    Real blackFormulaCashItmProbability(
        Option::Type optionType, Real strike, Real forward, Real stdDev, Real displacement = 0.0);

    /*! Black 1976 probability of being in the money (in the bond martingale
        measure), i.e. N(d2).
        It is a risk-neutral probability, not the real world one.
        \warning instead of volatility it uses standard deviation,
                 i.e. volatility*sqrt(timeToMaturity)
    */
    Real blackFormulaCashItmProbability(const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                                        Real forward,
                                        Real stdDev,
                                        Real displacement = 0.0);

    /*! Black 1976 probability of being in the money in the asset martingale
        measure, i.e. N(d1).
        It is a risk-neutral probability, not the real world one.
    */
    Real blackFormulaAssetItmProbability(
        Option::Type optionType, Real strike, Real forward, Real stdDev, Real displacement = 0.0);

    /*! Black 1976 probability of being in the money in the asset martingale
        measure, i.e. N(d1).
        It is a risk-neutral probability, not the real world one.
    */
    Real blackFormulaAssetItmProbability(const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                                         Real forward,
                                         Real stdDev,
                                         Real displacement = 0.0);

    /*! Black 1976 formula for standard deviation derivative
        \warning instead of volatility it uses standard deviation, i.e.
                 volatility*sqrt(timeToMaturity), and it returns the
                 derivative with respect to the standard deviation.
                 If T is the time to maturity Black vega would be
                 blackStdDevDerivative(strike, forward, stdDev)*sqrt(T)
    */
    Real blackFormulaStdDevDerivative(
        Real strike, Real forward, Real stdDev, Real discount = 1.0, Real displacement = 0.0);

    /*! Black 1976 formula for  derivative with respect to implied vol, this
        is basically the vega, but if you want 1% change multiply by 1%
   */
    Real blackFormulaVolDerivative(Real strike,
                                   Real forward,
                                   Real stdDev,
                                   Real expiry,
                                   Real discount = 1.0,
                                   Real displacement = 0.0);


    /*! Black 1976 formula for standard deviation derivative
        \warning instead of volatility it uses standard deviation, i.e.
                 volatility*sqrt(timeToMaturity), and it returns the
                 derivative with respect to the standard deviation.
                 If T is the time to maturity Black vega would be
                 blackStdDevDerivative(strike, forward, stdDev)*sqrt(T)
    */
    Real blackFormulaStdDevDerivative(const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                                      Real forward,
                                      Real stdDev,
                                      Real discount = 1.0,
                                      Real displacement = 0.0);

    /*! Black 1976 formula for second derivative by standard deviation
        \warning instead of volatility it uses standard deviation, i.e.
                 volatility*sqrt(timeToMaturity), and it returns the
                 derivative with respect to the standard deviation.
    */
    Real blackFormulaStdDevSecondDerivative(
        Rate strike, Rate forward, Real stdDev, Real discount, Real displacement);

    /*! Black 1976 formula for second derivative by standard deviation
        \warning instead of volatility it uses standard deviation, i.e.
                 volatility*sqrt(timeToMaturity), and it returns the
                 derivative with respect to the standard deviation.
    */
    Real blackFormulaStdDevSecondDerivative(const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                                            Real forward,
                                            Real stdDev,
                                            Real discount = 1.0,
                                            Real displacement = 0.0);

    /*! Black style formula when forward is normal rather than
        log-normal. This is essentially the model of Bachelier.

        \warning Bachelier model needs absolute volatility, not
                 percentage volatility. Standard deviation is
                 absoluteVolatility*sqrt(timeToMaturity)
    */
    Real bachelierBlackFormula(
        Option::Type optionType, Real strike, Real forward, Real stdDev, Real discount = 1.0);

    /*! Black style formula when forward is normal rather than
        log-normal. This is essentially the model of Bachelier.

        \warning Bachelier model needs absolute volatility, not
                 percentage volatility. Standard deviation is
                 absoluteVolatility*sqrt(timeToMaturity)
    */
    Real bachelierBlackFormula(const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                               Real forward,
                               Real stdDev,
                               Real discount = 1.0);

    /*! Bachelier Black model forward derivative.

        \warning Bachelier model needs absolute volatility, not
                 percentage volatility. Standard deviation is
                 absoluteVolatility*sqrt(timeToMaturity)
    */
    Real bachelierBlackFormulaForwardDerivative(
        Option::Type optionType, Real strike, Real forward, Real stdDev, Real discount = 1.0);

    /*! Bachelier Black model forward derivative.

        \warning Bachelier model needs absolute volatility, not
                 percentage volatility. Standard deviation is
                 absoluteVolatility*sqrt(timeToMaturity)
    */
    Real bachelierBlackFormulaForwardDerivative(
        const ext::shared_ptr<PlainVanillaPayoff>& payoff,
        Real forward,
        Real stdDev,
        Real discount = 1.0);

    /*! Approximated Bachelier implied volatility

        It is calculated using  the analytic implied volatility approximation
        of J. Choi, K Kim and M. Kwak (2009), “Numerical Approximation of the
        Implied Volatility Under Arithmetic Brownian Motion”,
        Applied Math. Finance, 16(3), pp. 261-268.
    */
    Real bachelierBlackFormulaImpliedVolChoi(Option::Type optionType,
                                             Real strike,
                                             Real forward,
                                             Real tte,
                                             Real bachelierPrice,
                                             Real discount = 1.0);

    /*! Exact Bachelier implied volatility

        It is calculated using the analytic implied volatility formula
        of Jaeckel (2017), "Implied Normal Volatility"
    */
    Real bachelierBlackFormulaImpliedVol(Option::Type optionType,
                                         Real strike,
                                         Real forward,
                                         Real tte,
                                         Real bachelierPrice,
                                         Real discount = 1.0);

    /*! Bachelier formula for standard deviation derivative
        \warning instead of volatility it uses standard deviation, i.e.
                 volatility*sqrt(timeToMaturity), and it returns the
                 derivative with respect to the standard deviation.
                 If T is the time to maturity Black vega would be
                 blackStdDevDerivative(strike, forward, stdDev)*sqrt(T)
    */

    Real bachelierBlackFormulaStdDevDerivative(Real strike,
                                               Real forward,
                                               Real stdDev,
                                               Real discount = 1.0);

    Real bachelierBlackFormulaStdDevDerivative(const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                                               Real forward,
                                               Real stdDev,
                                               Real discount = 1.0);

    /*! Bachelier formula for probability of being in the money in the asset martingale
        measure, i.e. N(d).
        It is a risk-neutral probability, not the real world one.
    */
    Real bachelierBlackFormulaAssetItmProbability(Option::Type optionType,
                                                  Real strike,
                                                  Real forward,
                                                  Real stdDev);

    /*! Bachelier formula for of being in the money in the asset martingale
        measure, i.e. N(d).
        It is a risk-neutral probability, not the real world one.
    */
    Real bachelierBlackFormulaAssetItmProbability(const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                                                  Real forward,
                                                  Real stdDev);

}

#endif
]]></document_content>
  </document>
  <document index="52">
    <source>blackscholescalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file blackscholescalculator.hpp
    \brief Black-Scholes formula calculator class
*/

#ifndef quantlib_blackscholescalculator_hpp
#define quantlib_blackscholescalculator_hpp

#include <ql/pricingengines/blackcalculator.hpp>

namespace QuantLib {

    //! Black-Scholes 1973 calculator class
    class BlackScholesCalculator : public BlackCalculator {
      public:
        BlackScholesCalculator(
                        const ext::shared_ptr<StrikedTypePayoff>& payoff,
                        Real spot,
                        DiscountFactor growth,
                        Real stdDev,
                        DiscountFactor discount);
        BlackScholesCalculator(Option::Type optionType,
                               Real strike,
                               Real spot,
                               DiscountFactor growth,
                               Real stdDev,
                               DiscountFactor discount);
        ~BlackScholesCalculator() override = default;
        /*! Sensitivity to change in the underlying spot price. */
        Real delta() const;
        /*! Sensitivity in percent to a percent change in the
            underlying spot price. */
        Real elasticity() const;
        /*! Second order derivative with respect to change in the
            underlying spot price. */
        Real gamma() const;
        /*! Sensitivity to time to maturity. */
        Real theta(Time maturity) const;
        /*! Sensitivity to time to maturity per day
            (assuming 365 day in a year). */
        Real thetaPerDay(Time maturity) const;
        // also un-hide overloads taking a spot
        using BlackCalculator::delta;
        using BlackCalculator::elasticity;
        using BlackCalculator::gamma;
        using BlackCalculator::theta;
        using BlackCalculator::thetaPerDay;
      protected:
        Real spot_;
        DiscountFactor growth_;
    };

    // inline
    inline Real BlackScholesCalculator::delta() const {
        return BlackCalculator::delta(spot_);
    }

    inline Real BlackScholesCalculator::elasticity() const {
        return BlackCalculator::elasticity(spot_);
    }

    inline Real BlackScholesCalculator::gamma() const {
        return BlackCalculator::gamma(spot_);
    }

    inline Real BlackScholesCalculator::theta(Time maturity) const {
        return BlackCalculator::theta(spot_, maturity);
    }

    inline Real BlackScholesCalculator::thetaPerDay(Time maturity) const {
        return BlackCalculator::thetaPerDay(spot_, maturity);
    }

}

#endif
]]></document_content>
  </document>
  <document index="53">
    <source>bond/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/pricingengines/bond/binomialconvertibleengine.hpp>
#include <ql/pricingengines/bond/bondfunctions.hpp>
#include <ql/pricingengines/bond/discountingbondengine.hpp>
#include <ql/pricingengines/bond/discretizedconvertible.hpp>
#include <ql/pricingengines/bond/riskybondengine.hpp>

]]></document_content>
  </document>
  <document index="54">
    <source>bond/binomialconvertibleengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2006 Theo Boafo
 Copyright (C) 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file binomialconvertibleengine.hpp
    \brief binomial engine for convertible bonds
*/

#ifndef quantlib_binomial_convertible_engine_hpp
#define quantlib_binomial_convertible_engine_hpp

#include <ql/instruments/bonds/convertiblebonds.hpp>
#include <ql/pricingengines/bond/discretizedconvertible.hpp>
#include <ql/methods/lattices/tflattice.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <utility>

namespace QuantLib {

    //! Binomial Tsiveriotis-Fernandes engine for convertible bonds
    /*  \ingroup bondengines

        \test the correctness of the returned value is tested by
              checking it against known results in a few corner cases.
    */
    template <class T>
    class BinomialConvertibleEngine : public ConvertibleBond::engine {
      public:
        BinomialConvertibleEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                                  Size timeSteps,
                                  const Handle<Quote>& creditSpread,
                                  DividendSchedule dividends = DividendSchedule())
        : process_(std::move(process)), timeSteps_(timeSteps),
          dividends_(std::move(dividends)), creditSpread_(creditSpread)
           {
            QL_REQUIRE(timeSteps>0,
                       "timeSteps must be positive, " << timeSteps <<
                       " not allowed");

            registerWith(process_);
            registerWith(creditSpread);
        }
        void calculate() const override;
        const Handle<Quote>& creditSpread() const { return creditSpread_; }
        const DividendSchedule& dividends() const { return dividends_; }

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Size timeSteps_;
        DividendSchedule dividends_;
        Handle<Quote> creditSpread_;
    };


    template <class T>
    void BinomialConvertibleEngine<T>::calculate() const {

        DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
        DayCounter divdc = process_->dividendYield()->dayCounter();
        DayCounter voldc = process_->blackVolatility()->dayCounter();
        Calendar volcal = process_->blackVolatility()->calendar();

        Real s0 = process_->x0();
        QL_REQUIRE(s0 > 0.0, "negative or null underlying");
        Volatility v = process_->blackVolatility()->blackVol(
            arguments_.exercise->lastDate(), s0);
        Date maturityDate = arguments_.exercise->lastDate();
        Rate riskFreeRate = process_->riskFreeRate()->zeroRate(
            maturityDate, rfdc, Continuous, NoFrequency);
        Rate q = process_->dividendYield()->zeroRate(
            maturityDate, divdc, Continuous, NoFrequency);
        Date referenceDate = process_->riskFreeRate()->referenceDate();

        // subtract dividends
        Size i;
        for (i=0; i<dividends_.size(); i++) {
            if (dividends_[i]->date() >= referenceDate)
                s0 -= dividends_[i]->amount() *
                      process_->riskFreeRate()->discount(dividends_[i]->date());
        }
        QL_REQUIRE(s0 > 0.0,
            "negative value after subtracting dividends");

        // binomial trees with constant coefficient
        Handle<Quote> underlying(ext::shared_ptr<Quote>(new SimpleQuote(s0)));
        Handle<YieldTermStructure> flatRiskFree(ext::shared_ptr<YieldTermStructure>(
            new FlatForward(referenceDate, riskFreeRate, rfdc)));
        Handle<YieldTermStructure> flatDividends(
            ext::shared_ptr<YieldTermStructure>(new FlatForward(referenceDate, q, divdc)));
        Handle<BlackVolTermStructure> flatVol(ext::shared_ptr<BlackVolTermStructure>(
            new BlackConstantVol(referenceDate, volcal, v, voldc)));

        Time maturity = rfdc.yearFraction(arguments_.settlementDate, maturityDate);
        Real strike = arguments_.redemption / arguments_.conversionRatio ;

        ext::shared_ptr<GeneralizedBlackScholesProcess> bs(
            new GeneralizedBlackScholesProcess(underlying, flatDividends, flatRiskFree, flatVol));
        ext::shared_ptr<T> tree(new T(bs, maturity, timeSteps_, strike));

        Real creditSpread = creditSpread_->value();

        ext::shared_ptr<Lattice> lattice(new TsiveriotisFernandesLattice<T>(
            tree, riskFreeRate, maturity, timeSteps_, creditSpread, v, q));

        DiscretizedConvertible convertible(arguments_, bs, dividends_, creditSpread_, TimeGrid(maturity, timeSteps_));

        convertible.initialize(lattice, maturity);
        convertible.rollback(0.0);
        results_.value = results_.settlementValue = convertible.presentValue();
        QL_ENSURE(results_.value < std::numeric_limits<Real>::max(),
                  "floating-point overflow on tree grid");
    }

}


#endif
]]></document_content>
  </document>
  <document index="55">
    <source>bond/bondfunctions.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2008, 2009, 2010 Ferdinando Ametrano
 Copyright (C) 2007 Chiara Fornarola
 Copyright (C) 2009 StatPro Italia srl
 Copyright (C) 2009 Nathan Abbott

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bondfunctions.hpp
    \brief bond functions
*/

#ifndef quantlib_bond_functions_hpp
#define quantlib_bond_functions_hpp

#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/duration.hpp>
#include <ql/cashflow.hpp>
#include <ql/interestrate.hpp>
#include <ql/instruments/bond.hpp>
#include <ql/shared_ptr.hpp>

namespace QuantLib {

    // forward declarations
    class Bond;
    class DayCounter;
    class YieldTermStructure;

    //! Bond adapters of CashFlows functions
    /*! See CashFlows for functions' documentation.

        These adapters calls into CashFlows functions passing as input the
        Bond cashflows, the dirty price (i.e. npv) calculated from clean
        price, the bond settlement date (unless another date is given), zero
        ex-dividend days, and excluding any cashflow on the settlement date.

        Prices are always clean, as per market convention.
    */
    struct BondFunctions {
        //! \name Date inspectors
        //@{
        static Date startDate(const Bond& bond);
        static Date maturityDate(const Bond& bond);
        static bool isTradable(const Bond& bond,
                               Date settlementDate = Date());
        //@}

        //! \name CashFlow inspectors
        //@{
        static Leg::const_reverse_iterator
        previousCashFlow(const Bond& bond,
                         Date refDate = Date());
        static Leg::const_iterator nextCashFlow(const Bond& bond,
                                                Date refDate = Date());
        static Date previousCashFlowDate(const Bond& bond,
                                         Date refDate = Date());
        static Date nextCashFlowDate(const Bond& bond,
                                     Date refDate = Date());
        static Real previousCashFlowAmount(const Bond& bond,
                                           Date refDate = Date());
        static Real nextCashFlowAmount(const Bond& bond,
                                       Date refDate = Date());
        //@}

        //! \name Coupon inspectors
        //@{
        static Rate previousCouponRate(const Bond& bond,
                                       Date settlementDate = Date());
        static Rate nextCouponRate(const Bond& bond,
                                   Date settlementDate = Date());
        static Date accrualStartDate(const Bond& bond,
                                     Date settlementDate = Date());
        static Date accrualEndDate(const Bond& bond,
                                   Date settlementDate = Date());
        static Date referencePeriodStart(const Bond& bond,
                                         Date settlementDate = Date());
        static Date referencePeriodEnd(const Bond& bond,
                                       Date settlementDate = Date());
        static Time accrualPeriod(const Bond& bond,
                                  Date settlementDate = Date());
        static Date::serial_type accrualDays(const Bond& bond,
                                             Date settlementDate = Date());
        static Time accruedPeriod(const Bond& bond,
                                  Date settlementDate = Date());
        static Date::serial_type accruedDays(const Bond& bond,
                                             Date settlementDate = Date());
        static Real accruedAmount(const Bond& bond,
                                  Date settlementDate = Date());
        //@}

        //! \name YieldTermStructure functions
        //@{
        static Real cleanPrice(const Bond& bond,
                               const YieldTermStructure& discountCurve,
                               Date settlementDate = Date());
        static Real dirtyPrice(const Bond& bond,
                               const YieldTermStructure& discountCurve,
                               Date settlementDate = Date());
        static Real bps(const Bond& bond,
                        const YieldTermStructure& discountCurve,
                        Date settlementDate = Date());

        static Rate atmRate(const Bond& bond,
                            const YieldTermStructure& discountCurve,
                            Date settlementDate = Date(),
                            Bond::Price price = {});
        //@}

        //! \name Yield (a.k.a. Internal Rate of Return, i.e. IRR) functions
        //@{
        static Real cleanPrice(const Bond& bond,
                               const InterestRate& yield,
                               Date settlementDate = Date());
        static Real cleanPrice(const Bond& bond,
                               Rate yield,
                               const DayCounter& dayCounter,
                               Compounding compounding,
                               Frequency frequency,
                               Date settlementDate = Date());
        static Real dirtyPrice(const Bond& bond,
                               const InterestRate& yield,
                               Date settlementDate = Date());
        static Real dirtyPrice(const Bond& bond,
                               Rate yield,
                               const DayCounter& dayCounter,
                               Compounding compounding,
                               Frequency frequency,
                               Date settlementDate = Date());
        static Real bps(const Bond& bond,
                        const InterestRate& yield,
                        Date settlementDate = Date());
        static Real bps(const Bond& bond,
                        Rate yield,
                        const DayCounter& dayCounter,
                        Compounding compounding,
                        Frequency frequency,
                        Date settlementDate = Date());
        static Rate yield(const Bond& bond,
                          Bond::Price price,
                          const DayCounter& dayCounter,
                          Compounding compounding,
                          Frequency frequency,
                          Date settlementDate = Date(),
                          Real accuracy = 1.0e-10,
                          Size maxIterations = 100,
                          Rate guess = 0.05);
        template <typename Solver>
        static Rate yield(const Solver& solver,
                          const Bond& bond,
                          Bond::Price price,
                          const DayCounter& dayCounter,
                          Compounding compounding,
                          Frequency frequency,
                          Date settlementDate = Date(),
                          Real accuracy = 1.0e-10,
                          Rate guess = 0.05) {
            if (settlementDate == Date())
                settlementDate = bond.settlementDate();

            QL_REQUIRE(BondFunctions::isTradable(bond, settlementDate),
                       "non tradable at " << settlementDate <<
                       " (maturity being " << bond.maturityDate() << ")");

            Real amount = price.amount();

            if (price.type() == Bond::Price::Clean)
                amount += bond.accruedAmount(settlementDate);

            amount /= 100.0 / bond.notional(settlementDate);

            return CashFlows::yield<Solver>(solver, bond.cashflows(), amount, dayCounter,
                                            compounding,
                                            frequency, false, settlementDate,
                                            settlementDate, accuracy, guess);
        }
        static Time duration(const Bond& bond,
                             const InterestRate& yield,
                             Duration::Type type = Duration::Modified,
                             Date settlementDate = Date() );
        static Time duration(const Bond& bond,
                             Rate yield,
                             const DayCounter& dayCounter,
                             Compounding compounding,
                             Frequency frequency,
                             Duration::Type type = Duration::Modified,
                             Date settlementDate = Date() );
        static Real convexity(const Bond& bond,
                              const InterestRate& yield,
                              Date settlementDate = Date());
        static Real convexity(const Bond& bond,
                              Rate yield,
                              const DayCounter& dayCounter,
                              Compounding compounding,
                              Frequency frequency,
                              Date settlementDate = Date());
        static Real basisPointValue(const Bond& bond,
                                    const InterestRate& yield,
                                    Date settlementDate = Date());
        static Real basisPointValue(const Bond& bond,
                                    Rate yield,
                                    const DayCounter& dayCounter,
                                    Compounding compounding,
                                    Frequency frequency,
                                    Date settlementDate = Date());
        static Real yieldValueBasisPoint(const Bond& bond,
                                         const InterestRate& yield,
                                         Date settlementDate = Date());
        static Real yieldValueBasisPoint(const Bond& bond,
                                         Rate yield,
                                         const DayCounter& dayCounter,
                                         Compounding compounding,
                                         Frequency frequency,
                                         Date settlementDate = Date());
        //@}

        //! \name Z-spread functions
        //@{
        static Real cleanPrice(const Bond& bond,
                               const ext::shared_ptr<YieldTermStructure>& discount,
                               Spread zSpread,
                               const DayCounter& dayCounter,
                               Compounding compounding,
                               Frequency frequency,
                               Date settlementDate = Date());
        static Real dirtyPrice(const Bond& bond,
                               const ext::shared_ptr<YieldTermStructure>& discount,
                               Spread zSpread,
                               const DayCounter& dayCounter,
                               Compounding compounding,
                               Frequency frequency,
                               Date settlementDate = Date());
        static Spread zSpread(const Bond& bond,
                              Bond::Price price,
                              const ext::shared_ptr<YieldTermStructure>&,
                              const DayCounter& dayCounter,
                              Compounding compounding,
                              Frequency frequency,
                              Date settlementDate = Date(),
                              Real accuracy = 1.0e-10,
                              Size maxIterations = 100,
                              Rate guess = 0.0);
        //@}

    };

}

#endif
]]></document_content>
  </document>
  <document index="56">
    <source>bond/discountingbondengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file discountingbondengine.hpp
    \brief discounting bond engine
*/

#ifndef quantlib_discounting_bond_engine_hpp
#define quantlib_discounting_bond_engine_hpp

#include <ql/instruments/bond.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/handle.hpp>
#include <ql/optional.hpp>

namespace QuantLib {

    //! Discounting engine for bonds
    /*! This engine discounts future bond cashflows to the settlement date.
        \ingroup bondengines
    */
    class DiscountingBondEngine : public Bond::engine {
      public:
        DiscountingBondEngine(
            Handle<YieldTermStructure> discountCurve = Handle<YieldTermStructure>(),
            const ext::optional<bool>& includeSettlementDateFlows = ext::nullopt);
        void calculate() const override;
        Handle<YieldTermStructure> discountCurve() const {
            return discountCurve_;
        }
      private:
        Handle<YieldTermStructure> discountCurve_;
        ext::optional<bool> includeSettlementDateFlows_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="57">
    <source>bond/discretizedconvertible.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2006 Theo Boafo
 Copyright (C) 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file discretizedconvertible.hpp
    \brief discretized convertible
*/

#ifndef quantlib_discretized_convertible_hpp
#define quantlib_discretized_convertible_hpp

#include <ql/discretizedasset.hpp>
#include <ql/instruments/bonds/convertiblebonds.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    class DiscretizedConvertible : public DiscretizedAsset {
      public:
        DiscretizedConvertible(ConvertibleBond::arguments,
                               ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                               DividendSchedule dividends,
                               Handle<Quote> creditSpread,
                               const TimeGrid& grid = TimeGrid());

        void reset(Size size) override;

        const Array& conversionProbability() const {
            return conversionProbability_;
        }
        Array& conversionProbability() { return conversionProbability_; }

        const Array& spreadAdjustedRate() const { return spreadAdjustedRate_; }
        Array& spreadAdjustedRate() { return spreadAdjustedRate_; }

        const Array& dividendValues() const { return dividendValues_; }
        Array& dividendValues() { return dividendValues_; }

        std::vector<Time> mandatoryTimes() const override {
            std::vector<Time> result;
            std::copy(stoppingTimes_.begin(), stoppingTimes_.end(),
                      std::back_inserter(result));
            std::copy(callabilityTimes_.begin(), callabilityTimes_.end(),
                      std::back_inserter(result));
            std::copy(couponTimes_.begin(), couponTimes_.end(),
                      std::back_inserter(result));
            return result;
        }

      protected:
        void postAdjustValuesImpl() override;
        Array conversionProbability_, spreadAdjustedRate_, dividendValues_;

      private:
        Array adjustedGrid() const;
        void applyConvertibility();
        void applyCallability(Size, bool convertible);
        void addCoupon(Size);
        ConvertibleBond::arguments arguments_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        std::vector<Time> stoppingTimes_;
        std::vector<Time> callabilityTimes_;
        std::vector<Time> couponTimes_;
        std::vector<Real> couponAmounts_;
        std::vector<Time> dividendTimes_;
        Handle<Quote> creditSpread_;
        DividendSchedule dividends_;
        std::vector<Date> dividendDates_; 
    };

}


#endif

]]></document_content>
  </document>
  <document index="58">
    <source>bond/riskybondengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2021 Lew Wei Hao

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file riskybondengine.hpp
    \brief risky bond engine
*/

#ifndef quantlib_risky_bond_engine_hpp
#define quantlib_risky_bond_engine_hpp

#include <ql/instruments/bond.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/termstructures/defaulttermstructure.hpp>
#include <ql/handle.hpp>

namespace QuantLib {

    //! Risky pricing engine for bonds
    /*! The value of each cashflow is contingent to survival, i.e., the knockout
        probability is considered.

        In each of the \f$n\f$ coupon periods, we can calculate the value
        in the case of survival and default, assuming that the issuer
        can only default in the middle of a coupon period. We denote this time
        \f$T_{i}^{mid}=\frac{T_{i-1}+T_{i}}{2}\f$.

        Given survival we receive the full cash flow (both coupons and notional).
        The time \f$t\f$ value of these payments are given by
        \f[
            \sum_{i=1}^{n}CF_{i}P(t,T_{i})Q(T_{i}<\tau)
        \f]
        where \f$P(t,T)\f$ is the time \f$T\f$ discount bond
        and \f$Q(T<\tau)\f$ is the time \f$T\f$ survival probability.
        \f$n\f$ is the number of coupon periods. This takes care of the payments
        in the case of survival.

        Given default we receive only a fraction of the notional at default.
        \f[
            \sum_{i=1}^{n}Rec N(T_{i}^{mid}) P(t,T_{i}^{mid})Q(T_{i-1}<\tau\leq T_{i})
        \f]
        where \f$Rec\f$ is the recovery rate and \f$N(T)\f$ is the time T notional. The default probability can be
        rewritten as
        \f[
            Q(T_{i-1}<\tau\leq T_{i})=Q(T_{i}<\tau)-Q(T_{i-1}<\tau)=(1-Q(T_{i}\geq\tau))-(1-Q(T_{i-1}\geq\tau))=Q(T_{i-1}\geq\tau)-Q(T_{i}\geq\tau)
        \f]
    */
    class RiskyBondEngine : public Bond::engine {
      public:
        RiskyBondEngine(Handle<DefaultProbabilityTermStructure> defaultTS,
                        Real recoveryRate,
                        Handle<YieldTermStructure> yieldTS);
        void calculate() const override;
        Handle<DefaultProbabilityTermStructure> defaultTS() const;
        Real recoveryRate() const;
        Handle<YieldTermStructure> yieldTS() const;
      private:
        Handle<DefaultProbabilityTermStructure> defaultTS_;
        Real recoveryRate_;
        Handle<YieldTermStructure> yieldTS_;
    };


    inline Handle<DefaultProbabilityTermStructure> RiskyBondEngine::defaultTS() const {
        return defaultTS_;
    }

    inline Real RiskyBondEngine::recoveryRate() const { return recoveryRate_; }

    inline Handle<YieldTermStructure> RiskyBondEngine::yieldTS() const { return yieldTS_; }

}

#endif
]]></document_content>
  </document>
  <document index="59">
    <source>capfloor/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/pricingengines/capfloor/analyticcapfloorengine.hpp>
#include <ql/pricingengines/capfloor/blackcapfloorengine.hpp>
#include <ql/pricingengines/capfloor/bacheliercapfloorengine.hpp>
#include <ql/pricingengines/capfloor/discretizedcapfloor.hpp>
#include <ql/pricingengines/capfloor/gaussian1dcapfloorengine.hpp>
#include <ql/pricingengines/capfloor/mchullwhiteengine.hpp>
#include <ql/pricingengines/capfloor/treecapfloorengine.hpp>

]]></document_content>
  </document>
  <document index="60">
    <source>capfloor/analyticcapfloorengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticcapfloorengine.hpp
    \brief Analytic engine for caps/floors
*/

#ifndef quantlib_pricers_analytical_cap_floor_hpp
#define quantlib_pricers_analytical_cap_floor_hpp

#include <ql/instruments/capfloor.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/models/model.hpp>

namespace QuantLib {

    //! Analytic engine for cap/floor
    /*! \ingroup capfloorengines */
    class AnalyticCapFloorEngine
        : public GenericModelEngine<AffineModel,
                                    CapFloor::arguments,
                                    CapFloor::results > {
      public:
        /*! \note the term structure is only needed when the short-rate
                  model cannot provide one itself.
        */
        AnalyticCapFloorEngine(
            const ext::shared_ptr<AffineModel>& model,
            Handle<YieldTermStructure> termStructure = Handle<YieldTermStructure>());
        void calculate() const override;

      private:
        Handle<YieldTermStructure> termStructure_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="61">
    <source>capfloor/bacheliercapfloorengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Michael von den Driesch

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bacheliercapfloorengine.hpp
    \brief Bachelier-Black-formula cap/floor engine
*/

#ifndef quantlib_pricers_bachelier_capfloor_hpp
#define quantlib_pricers_bachelier_capfloor_hpp

#include <ql/instruments/capfloor.hpp>
#include <ql/termstructures/volatility/optionlet/optionletvolatilitystructure.hpp>

namespace QuantLib {

    class Quote;

    //! Bachelier-Black-formula cap/floor engine
    /*! \ingroup capfloorengines */
    class BachelierCapFloorEngine : public CapFloor::engine {
      public:
        BachelierCapFloorEngine(Handle<YieldTermStructure> discountCurve,
                                Volatility vol,
                                const DayCounter& dc = Actual365Fixed());
        BachelierCapFloorEngine(Handle<YieldTermStructure> discountCurve,
                                const Handle<Quote>& vol,
                                const DayCounter& dc = Actual365Fixed());
        BachelierCapFloorEngine(Handle<YieldTermStructure> discountCurve,
                                Handle<OptionletVolatilityStructure> vol);
        void calculate() const override;
        Handle<YieldTermStructure> termStructure() { return discountCurve_; }
        Handle<OptionletVolatilityStructure> volatility() { return vol_; }
      private:
        Handle<YieldTermStructure> discountCurve_;
        Handle<OptionletVolatilityStructure> vol_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="62">
    <source>capfloor/blackcapfloorengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file blackcapfloorengine.hpp
    \brief Black-formula cap/floor engine
*/

#ifndef quantlib_pricers_black_capfloor_hpp
#define quantlib_pricers_black_capfloor_hpp

#include <ql/instruments/capfloor.hpp>
#include <ql/termstructures/volatility/optionlet/optionletvolatilitystructure.hpp>

namespace QuantLib {

    class Quote;

    //! Black-formula cap/floor engine
    /*! \ingroup capfloorengines */
    class BlackCapFloorEngine : public CapFloor::engine {
      public:
        BlackCapFloorEngine(Handle<YieldTermStructure> discountCurve,
                            Volatility vol,
                            const DayCounter& dc = Actual365Fixed(),
                            Real displacement = 0.0);
        BlackCapFloorEngine(Handle<YieldTermStructure> discountCurve,
                            const Handle<Quote>& vol,
                            const DayCounter& dc = Actual365Fixed(),
                            Real displacement = 0.0);
        BlackCapFloorEngine(Handle<YieldTermStructure> discountCurve,
                            Handle<OptionletVolatilityStructure> vol,
                            Real displacement = Null<Real>());
        void calculate() const override;
        Handle<YieldTermStructure> termStructure() { return discountCurve_; }
        Handle<OptionletVolatilityStructure> volatility() { return vol_; }
        Real displacement() const { return displacement_; }

      private:
        Handle<YieldTermStructure> discountCurve_;
        Handle<OptionletVolatilityStructure> vol_;
        Real displacement_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="63">
    <source>capfloor/discretizedcapfloor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file discretizedcapfloor.hpp
    \brief discretized cap/floor
*/

#ifndef quantlib_pricers_capfloor_pricer_h
#define quantlib_pricers_capfloor_pricer_h

#include <ql/instruments/capfloor.hpp>
#include <ql/discretizedasset.hpp>

namespace QuantLib {

    class DiscretizedCapFloor : public DiscretizedAsset {
      public:
        DiscretizedCapFloor(const CapFloor::arguments& args,
                            const Date& referenceDate,
                            const DayCounter& dayCounter);
        void reset(Size size) override;
        std::vector<Time> mandatoryTimes() const override;

      protected:
        void preAdjustValuesImpl() override;
        void postAdjustValuesImpl() override;

      private:
        CapFloor::arguments arguments_;
        std::vector<Time> startTimes_;
        std::vector<Time> endTimes_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="64">
    <source>capfloor/gaussian1dcapfloorengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gaussian1dcapfloorengine.hpp
    \brief
*/

#ifndef quantlib_pricers_gaussian1d_capfloor_hpp
#define quantlib_pricers_gaussian1d_capfloor_hpp

#include <ql/instruments/capfloor.hpp>
#include <ql/models/shortrate/onefactormodels/gaussian1dmodel.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>
#include <utility>

namespace QuantLib {

    //! Gaussian1d cap/floor engine
    /*! \ingroup capfloorengines
    */

    class Gaussian1dCapFloorEngine
        : public GenericModelEngine<Gaussian1dModel, CapFloor::arguments,
                                    CapFloor::results> {
      public:
        Gaussian1dCapFloorEngine(
            const ext::shared_ptr<Gaussian1dModel>& model,
            const int integrationPoints = 64,
            const Real stddevs = 7.0,
            const bool extrapolatePayoff = true,
            const bool flatPayoffExtrapolation = false,
            Handle<YieldTermStructure> discountCurve = Handle<YieldTermStructure>())
        : GenericModelEngine<Gaussian1dModel, CapFloor::arguments, CapFloor::results>(model),
          integrationPoints_(integrationPoints), stddevs_(stddevs),
          extrapolatePayoff_(extrapolatePayoff), flatPayoffExtrapolation_(flatPayoffExtrapolation),
          discountCurve_(std::move(discountCurve)) {}
        void calculate() const override;

      private:
        const int integrationPoints_;
        const Real stddevs_;
        const bool extrapolatePayoff_, flatPayoffExtrapolation_;
        const Handle<YieldTermStructure> discountCurve_;
    };
}

#endif

]]></document_content>
  </document>
  <document index="65">
    <source>capfloor/mchullwhiteengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Banca Profilo S.p.A.
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mchullwhiteengine.hpp
    \brief Monte Carlo Hull-White engine for cap/floors
*/

#ifndef quantlib_mc_hull_white_cap_floor_engine_hpp
#define quantlib_mc_hull_white_cap_floor_engine_hpp

#include <ql/instruments/capfloor.hpp>
#include <ql/models/shortrate/onefactormodels/hullwhite.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <ql/processes/hullwhiteprocess.hpp>
#include <utility>

namespace QuantLib {

    namespace detail {

        class HullWhiteCapFloorPricer : public PathPricer<Path> {
          public:
            HullWhiteCapFloorPricer(const CapFloor::arguments&,
                                    ext::shared_ptr<HullWhite>,
                                    Time forwardMeasureTime);
            Real operator()(const Path& path) const override;

          private:
            CapFloor::arguments args_;
            ext::shared_ptr<HullWhite> model_;
            Time forwardMeasureTime_;
            DiscountFactor endDiscount_;
            std::vector<Time> startTimes_, endTimes_, fixingTimes_;
        };

    }


    //! Monte Carlo Hull-White engine for cap/floors
    /*! \ingroup capfloorengines */
    template <class RNG = PseudoRandom, class S = Statistics>
    class MCHullWhiteCapFloorEngine
        : public CapFloor::engine,
          public McSimulation<SingleVariate,RNG,S> {
      private:
        typedef McSimulation<SingleVariate,RNG,S> simulation;
        ext::shared_ptr<HullWhite> model_;
        Size requiredSamples_, maxSamples_;
        Real requiredTolerance_;
        bool brownianBridge_;
        BigNatural seed_;
      public:
        typedef typename simulation::path_generator_type path_generator_type;
        typedef typename simulation::path_pricer_type path_pricer_type;
        typedef typename simulation::stats_type stats_type;

        MCHullWhiteCapFloorEngine(ext::shared_ptr<HullWhite> model,
                                  bool brownianBridge,
                                  bool antitheticVariate,
                                  Size requiredSamples,
                                  Real requiredTolerance,
                                  Size maxSamples,
                                  BigNatural seed)
        : McSimulation<SingleVariate, RNG, S>(antitheticVariate, false), model_(std::move(model)),
          requiredSamples_(requiredSamples), maxSamples_(maxSamples),
          requiredTolerance_(requiredTolerance), brownianBridge_(brownianBridge), seed_(seed) {
            registerWith(model_);
        }

        void calculate() const override {
            simulation::calculate(requiredTolerance_,
                                  requiredSamples_,
                                  maxSamples_);
            results_.value = this->mcModel_->sampleAccumulator().mean();
            if constexpr (RNG::allowsErrorEstimate)
                results_.errorEstimate =
                    this->mcModel_->sampleAccumulator().errorEstimate();
        }

      protected:
        ext::shared_ptr<path_pricer_type> pathPricer() const {
            Date referenceDate = model_->termStructure()->referenceDate();
            DayCounter dayCounter = model_->termStructure()->dayCounter();
            Time forwardMeasureTime =
                dayCounter.yearFraction(referenceDate,
                                        arguments_.endDates.back());
            return ext::shared_ptr<path_pricer_type>(
                     new detail::HullWhiteCapFloorPricer(arguments_, model_,
                                                         forwardMeasureTime));
        }

        TimeGrid timeGrid() const {

            Date referenceDate = model_->termStructure()->referenceDate();
            DayCounter dayCounter = model_->termStructure()->dayCounter();

            // only add future fixing times...
            std::vector<Time> times;
            for (Size i=0; i<arguments_.fixingDates.size(); i++) {
                if (arguments_.fixingDates[i] > referenceDate)
                    times.push_back(
                          dayCounter.yearFraction(referenceDate,
                                                  arguments_.fixingDates[i]));
            }
            // ...and maturity.
            times.push_back(
                        dayCounter.yearFraction(referenceDate,
                                                arguments_.endDates.back()));
            return TimeGrid(times.begin(), times.end());
        }

        ext::shared_ptr<path_generator_type> pathGenerator() const {

            Handle<YieldTermStructure> curve = model_->termStructure();
            Date referenceDate = curve->referenceDate();
            DayCounter dayCounter = curve->dayCounter();

            Time forwardMeasureTime =
                dayCounter.yearFraction(referenceDate,
                                        arguments_.endDates.back());
            Array parameters = model_->params();
            Real a = parameters[0], sigma = parameters[1];
            ext::shared_ptr<HullWhiteForwardProcess> process(
                                new HullWhiteForwardProcess(curve, a, sigma));
            process->setForwardMeasureTime(forwardMeasureTime);

            TimeGrid grid = this->timeGrid();
            typename RNG::rsg_type generator =
                RNG::make_sequence_generator(grid.size()-1,seed_);
            return ext::shared_ptr<path_generator_type>(
                             new path_generator_type(process, grid, generator,
                                                     brownianBridge_));
        }
    };



    //! Monte Carlo Hull-White cap-floor engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCHullWhiteCapFloorEngine {
      public:
        MakeMCHullWhiteCapFloorEngine(ext::shared_ptr<HullWhite>);
        // named parameters
        MakeMCHullWhiteCapFloorEngine& withBrownianBridge(bool b = true);
        MakeMCHullWhiteCapFloorEngine& withSamples(Size samples);
        MakeMCHullWhiteCapFloorEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCHullWhiteCapFloorEngine& withMaxSamples(Size samples);
        MakeMCHullWhiteCapFloorEngine& withSeed(BigNatural seed);
        MakeMCHullWhiteCapFloorEngine& withAntitheticVariate(bool b = true);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<HullWhite> model_;
        bool antithetic_ = false;
        Size samples_, maxSamples_;
        Real tolerance_;
        bool brownianBridge_ = false;
        BigNatural seed_ = 0;
    };


    // inline definitions

    template <class RNG, class S>
    inline MakeMCHullWhiteCapFloorEngine<RNG, S>::MakeMCHullWhiteCapFloorEngine(
        ext::shared_ptr<HullWhite> model)
    : model_(std::move(model)), samples_(Null<Size>()), maxSamples_(Null<Size>()),
      tolerance_(Null<Real>()) {}

    template <class RNG, class S>
    inline MakeMCHullWhiteCapFloorEngine<RNG,S>&
    MakeMCHullWhiteCapFloorEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHullWhiteCapFloorEngine<RNG,S>&
    MakeMCHullWhiteCapFloorEngine<RNG,S>::withAbsoluteTolerance(
                                                             Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHullWhiteCapFloorEngine<RNG,S>&
    MakeMCHullWhiteCapFloorEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHullWhiteCapFloorEngine<RNG,S>&
    MakeMCHullWhiteCapFloorEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHullWhiteCapFloorEngine<RNG,S>&
    MakeMCHullWhiteCapFloorEngine<RNG,S>::withBrownianBridge(bool b) {
        brownianBridge_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHullWhiteCapFloorEngine<RNG,S>&
    MakeMCHullWhiteCapFloorEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHullWhiteCapFloorEngine<RNG,S>::
    operator ext::shared_ptr<PricingEngine>() const {
        return ext::shared_ptr<PricingEngine>(new
            MCHullWhiteCapFloorEngine<RNG,S>(model_,
                                             brownianBridge_, antithetic_,
                                             samples_, tolerance_,
                                             maxSamples_, seed_));
    }

}


#endif
]]></document_content>
  </document>
  <document index="66">
    <source>capfloor/treecapfloorengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file treecapfloorengine.hpp
    \brief Numerical lattice engine for cap/floors
*/

#ifndef quantlib_pricers_tree_cap_floor_hpp
#define quantlib_pricers_tree_cap_floor_hpp

#include <ql/instruments/capfloor.hpp>
#include <ql/pricingengines/latticeshortratemodelengine.hpp>

namespace QuantLib {

    //! Numerical lattice engine for cap/floors
    /*! \ingroup capfloorengines */
    class TreeCapFloorEngine
        : public LatticeShortRateModelEngine<CapFloor::arguments,
                                             CapFloor::results> {
      public:
        /*! \name Constructors
            \note the term structure is only needed when the short-rate
                  model cannot provide one itself.
        */
        //@{
        TreeCapFloorEngine(const ext::shared_ptr<ShortRateModel>& model,
                           Size timeSteps,
                           Handle<YieldTermStructure> termStructure = Handle<YieldTermStructure>());
        TreeCapFloorEngine(const ext::shared_ptr<ShortRateModel>& model,
                           const TimeGrid& timeGrid,
                           Handle<YieldTermStructure> termStructure = Handle<YieldTermStructure>());
        //@}
        void calculate() const override;

      private:
        Handle<YieldTermStructure> termStructure_;
    };

}


#endif

]]></document_content>
  </document>
  <document index="67">
    <source>cliquet/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/pricingengines/cliquet/analyticcliquetengine.hpp>
#include <ql/pricingengines/cliquet/analyticperformanceengine.hpp>
#include <ql/pricingengines/cliquet/mcperformanceengine.hpp>

]]></document_content>
  </document>
  <document index="68">
    <source>cliquet/analyticcliquetengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticcliquetengine.hpp
    \brief Analytic Cliquet engine
*/

#ifndef quantlib_analytic_cliquet_engine_hpp
#define quantlib_analytic_cliquet_engine_hpp

#include <ql/instruments/cliquetoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Pricing engine for Cliquet options using analytical formulae
    /*! \ingroup cliquetengines

        \test
        - the correctness of the returned value is tested by
          reproducing results available in literature.
        - the correctness of the returned greeks is tested by
          reproducing numerical derivatives.
    */
    class AnalyticCliquetEngine : public CliquetOption::engine {
      public:
        AnalyticCliquetEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="69">
    <source>cliquet/analyticperformanceengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticperformanceengine.hpp
    \brief Analytic performance engine
*/

#ifndef quantlib_analytic_performance_engine_hpp
#define quantlib_analytic_performance_engine_hpp

#include <ql/instruments/cliquetoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Pricing engine for performance options using analytical formulae
    /*! \ingroup cliquetengines

        \test the correctness of the returned greeks is tested by
              reproducing numerical derivatives.
    */
    class AnalyticPerformanceEngine : public CliquetOption::engine {
      public:
        AnalyticPerformanceEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="70">
    <source>cliquet/mcperformanceengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_mc_performance_engine_hpp
#define quantlib_mc_performance_engine_hpp

#include <ql/exercise.hpp>
#include <ql/instruments/cliquetoption.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    //! Pricing engine for performance options using Monte Carlo simulation
    template<class RNG = PseudoRandom, class S = Statistics>
    class MCPerformanceEngine : public CliquetOption::engine,
                                public McSimulation<SingleVariate,RNG,S> {
      public:
        typedef
        typename McSimulation<SingleVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef typename McSimulation<SingleVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename McSimulation<SingleVariate,RNG,S>::stats_type
            stats_type;
        // constructor
        MCPerformanceEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                            bool brownianBridge,
                            bool antitheticVariate,
                            Size requiredSamples,
                            Real requiredTolerance,
                            Size maxSamples,
                            BigNatural seed);
        void calculate() const override {
            McSimulation<SingleVariate,RNG,S>::calculate(requiredTolerance_,
                                                         requiredSamples_,
                                                         maxSamples_);
            results_.value = this->mcModel_->sampleAccumulator().mean();
            if constexpr (RNG::allowsErrorEstimate)
                results_.errorEstimate =
                    this->mcModel_->sampleAccumulator().errorEstimate();
        }

      protected:
        // McSimulation implementation
        TimeGrid timeGrid() const override;
        ext::shared_ptr<path_generator_type> pathGenerator() const override {

            TimeGrid grid = this->timeGrid();
            typename RNG::rsg_type gen =
                RNG::make_sequence_generator(grid.size()-1,seed_);
            return ext::shared_ptr<path_generator_type>(
                         new path_generator_type(process_, grid,
                                                 gen, brownianBridge_));
        }
        ext::shared_ptr<path_pricer_type> pathPricer() const override;
        // data members
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Size requiredSamples_, maxSamples_;
        Real requiredTolerance_;
        bool brownianBridge_;
        BigNatural seed_;
    };


    //! Monte Carlo performance-option engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCPerformanceEngine {
      public:
        MakeMCPerformanceEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);
        // named parameters
        MakeMCPerformanceEngine& withBrownianBridge(bool b = true);
        MakeMCPerformanceEngine& withAntitheticVariate(bool b = true);
        MakeMCPerformanceEngine& withSamples(Size samples);
        MakeMCPerformanceEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCPerformanceEngine& withMaxSamples(Size samples);
        MakeMCPerformanceEngine& withSeed(BigNatural seed);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        bool brownianBridge_ = false, antithetic_ = false;
        Size samples_, maxSamples_;
        Real tolerance_;
        BigNatural seed_ = 0;
    };



    class PerformanceOptionPathPricer : public PathPricer<Path> {
      public:
        PerformanceOptionPathPricer(Option::Type type,
                                    Real strike,
                                    std::vector<DiscountFactor> discounts);
        Real operator()(const Path& path) const override;

      private:
        Real strike_;
        Option::Type type_;
        std::vector<DiscountFactor> discounts_;
    };


    // template definitions

    template <class RNG, class S>
    inline MCPerformanceEngine<RNG, S>::MCPerformanceEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        bool brownianBridge,
        bool antitheticVariate,
        Size requiredSamples,
        Real requiredTolerance,
        Size maxSamples,
        BigNatural seed)
    : McSimulation<SingleVariate, RNG, S>(antitheticVariate, false), process_(std::move(process)),
      requiredSamples_(requiredSamples), maxSamples_(maxSamples),
      requiredTolerance_(requiredTolerance), brownianBridge_(brownianBridge), seed_(seed) {
        registerWith(process_);
    }


    template <class RNG, class S>
    inline TimeGrid MCPerformanceEngine<RNG,S>::timeGrid() const {

        std::vector<Time> fixingTimes;
        fixingTimes.reserve(arguments_.resetDates.size());
        for (Size i=0; i<arguments_.resetDates.size(); i++)
            fixingTimes.push_back(process_->time(arguments_.resetDates[i]));
        fixingTimes.push_back(process_->time(arguments_.exercise->lastDate()));

        return TimeGrid(fixingTimes.begin(), fixingTimes.end());
    }


    template <class RNG, class S>
    inline
    ext::shared_ptr<typename MCPerformanceEngine<RNG,S>::path_pricer_type>
    MCPerformanceEngine<RNG,S>::pathPricer() const {

        ext::shared_ptr<PercentageStrikePayoff> payoff =
            ext::dynamic_pointer_cast<PercentageStrikePayoff>(
                this->arguments_.payoff);
        QL_REQUIRE(payoff, "non-percentage payoff given");

        ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(
                this->arguments_.exercise);
        QL_REQUIRE(exercise, "wrong exercise given");

        std::vector<DiscountFactor> discounts;

        discounts.reserve(arguments_.resetDates.size());
        for (Size k=0;k<arguments_.resetDates.size();k++) {
            discounts.push_back(this->process_->riskFreeRate()->discount(
                                                   arguments_.resetDates[k]));
        }
        discounts.push_back(this->process_->riskFreeRate()->discount(
                                            arguments_.exercise->lastDate()));

        return ext::shared_ptr<
            typename MCPerformanceEngine<RNG,S>::path_pricer_type>(
                         new PerformanceOptionPathPricer(payoff->optionType(),
                                                         payoff->strike(),
                                                         discounts));
    }


    template <class RNG, class S>
    inline MakeMCPerformanceEngine<RNG, S>::MakeMCPerformanceEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)), samples_(Null<Size>()), maxSamples_(Null<Size>()),
      tolerance_(Null<Real>()) {}

    template <class RNG, class S>
    inline MakeMCPerformanceEngine<RNG,S>&
    MakeMCPerformanceEngine<RNG,S>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPerformanceEngine<RNG,S>&
    MakeMCPerformanceEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPerformanceEngine<RNG,S>&
    MakeMCPerformanceEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPerformanceEngine<RNG,S>&
    MakeMCPerformanceEngine<RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPerformanceEngine<RNG,S>&
    MakeMCPerformanceEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPerformanceEngine<RNG,S>&
    MakeMCPerformanceEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCPerformanceEngine<RNG,S>::operator ext::shared_ptr<PricingEngine>()
                                                                      const {
        return ext::shared_ptr<PricingEngine>(new
            MCPerformanceEngine<RNG,S>(process_,
                                       brownianBridge_,
                                       antithetic_,
                                       samples_,
                                       tolerance_,
                                       maxSamples_,
                                       seed_));
    }

}


#endif
]]></document_content>
  </document>
  <document index="71">
    <source>credit/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/pricingengines/credit/integralcdsengine.hpp>
#include <ql/pricingengines/credit/isdacdsengine.hpp>
#include <ql/pricingengines/credit/midpointcdsengine.hpp>

]]></document_content>
  </document>
  <document index="72">
    <source>credit/integralcdsengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2008, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file integralcdsengine.hpp
    \brief Integral engine for credit default swaps
*/

#ifndef quantlib_integral_cds_engine_hpp
#define quantlib_integral_cds_engine_hpp

#include <ql/instruments/creditdefaultswap.hpp>
#include <ql/optional.hpp>

namespace QuantLib {

    class IntegralCdsEngine : public CreditDefaultSwap::engine {
      public:
        IntegralCdsEngine(const Period& integrationStep,
                          Handle<DefaultProbabilityTermStructure>,
                          Real recoveryRate,
                          Handle<YieldTermStructure> discountCurve,
                          const ext::optional<bool>& includeSettlementDateFlows = ext::nullopt);
        void calculate() const override;

      private:
        Period integrationStep_;
        Handle<DefaultProbabilityTermStructure> probability_;
        Real recoveryRate_;
        Handle<YieldTermStructure> discountCurve_;
        ext::optional<bool> includeSettlementDateFlows_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="73">
    <source>credit/isdacdsengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file isdacdsengine.hpp
    \brief ISDA engine for credit default swaps
*/

#ifndef quantlib_isda_cds_engine_hpp
#define quantlib_isda_cds_engine_hpp

#include <ql/instruments/creditdefaultswap.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/termstructures/defaulttermstructure.hpp>
#include <ql/optional.hpp>

namespace QuantLib {

    /*! References:

        [1] The Pricing and Risk Management of Credit Default Swaps, with a
            Focus on the ISDA Model,
            OpenGamma Quantitative Research, Version as of 15-Oct-2013

        [2] ISDA CDS Standard Model Proposed Numerical Fix \ Thursday,
            November 15, 2012, Markit

        [3] Markit Interest Rate Curve XML Specifications,
            Version 1.16, Tuesday, 15 October 2013

    */

    class IsdaCdsEngine : public CreditDefaultSwap::engine {

      public:
        /*! According to [1] the settings for the flags
            AccrualBias / ForwardsInCouponPeriod corresponding
            to the standard model implementation C code are

            prior 1.8.2    HalfDayBias / Flat
            1.8.2          NoBias / Flat

            The theoretical correct setting would be NoBias / Piecewise

            Todo: Clarify in which version of the standard model
            implementation C code the numerical problem of zero denominators
            is solved and how exactly.
        */

        enum NumericalFix {
            None,  // as in [1] footnote 26 (i.e. 10^{-50} is added to
                   // denominators $f_i+h_i$$)
            Taylor // as in [2] i.e. for $f_i+h_i < 10^{-4}$ a Taylor expansion
                   // is used to avoid zero denominators
        };

        enum AccrualBias {
            HalfDayBias, // as in [1] formula (50), second (error) term is
                         // included
            NoBias // as in [1], but second term in formula (50) is not included
        };

        enum ForwardsInCouponPeriod {
            Flat, // as in [1], formula (52), second (error) term is included
            Piecewise // as in [1], but second term in formula (52) is not
                      // included
        };

        /*! Constructor where the client code is responsible for providing a
            default curve and an interest rate curve compliant with the ISDA
            specifications.

            To be precisely consistent with the ISDA specification
                bool IborCoupon::Settings::usingAtParCoupons();
            must be true. This is not checked in order not to
            kill the engine completely in this case.

            Furthermore, the ibor index in the swap rate helpers should not
            provide the evaluation date's fixing.
        */

        IsdaCdsEngine(Handle<DefaultProbabilityTermStructure> probability,
                      Real recoveryRate,
                      Handle<YieldTermStructure> discountCurve,
                      const ext::optional<bool>& includeSettlementDateFlows = ext::nullopt,
                      NumericalFix numericalFix = Taylor,
                      AccrualBias accrualBias = HalfDayBias,
                      ForwardsInCouponPeriod forwardsInCouponPeriod = Piecewise);

        Handle<YieldTermStructure> isdaRateCurve() const { return discountCurve_; }
        Handle<DefaultProbabilityTermStructure> isdaCreditCurve() const { return probability_; }

        void calculate() const override;

      private:
        Handle<DefaultProbabilityTermStructure> probability_;
        const Real recoveryRate_;
        Handle<YieldTermStructure> discountCurve_;
        const ext::optional<bool> includeSettlementDateFlows_;
        const NumericalFix numericalFix_;
        const AccrualBias accrualBias_;
        const ForwardsInCouponPeriod forwardsInCouponPeriod_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="74">
    <source>credit/midpointcdsengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Jose Aparicio
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2008, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file midpointcdsengine.hpp
    \brief Mid-point engine for credit default swaps
*/

#ifndef quantlib_mid_point_cds_engine_hpp
#define quantlib_mid_point_cds_engine_hpp

#include <ql/instruments/creditdefaultswap.hpp>
#include <ql/optional.hpp>

namespace QuantLib {

    class MidPointCdsEngine : public CreditDefaultSwap::engine {
      public:
        MidPointCdsEngine(Handle<DefaultProbabilityTermStructure>,
                          Real recoveryRate,
                          Handle<YieldTermStructure> discountCurve,
                          const ext::optional<bool>& includeSettlementDateFlows = ext::nullopt);
        void calculate() const override;

      private:
        Handle<DefaultProbabilityTermStructure> probability_;
        Real recoveryRate_;
        Handle<YieldTermStructure> discountCurve_;
        ext::optional<bool> includeSettlementDateFlows_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="75">
    <source>exotic/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/pricingengines/exotic/analyticamericanmargrabeengine.hpp>
#include <ql/pricingengines/exotic/analyticcomplexchooserengine.hpp>
#include <ql/pricingengines/exotic/analyticcompoundoptionengine.hpp>
#include <ql/pricingengines/exotic/analyticeuropeanmargrabeengine.hpp>
#include <ql/pricingengines/exotic/analyticholderextensibleoptionengine.hpp>
#include <ql/pricingengines/exotic/analyticsimplechooserengine.hpp>
#include <ql/pricingengines/exotic/analytictwoassetcorrelationengine.hpp>
#include <ql/pricingengines/exotic/analyticwriterextensibleoptionengine.hpp>

]]></document_content>
  </document>
  <document index="76">
    <source>exotic/analyticamericanmargrabeengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticamericanmargrabeengine.hpp
    \brief Analytic engine for American Margrabe option
*/

#ifndef quantlib_analytic_american_margrabe_engine_hpp
#define quantlib_analytic_american_margrabe_engine_hpp

#include <ql/instruments/margrabeoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic engine for American Margrabe option
    /*! This class implements formulae from
        "The Value of an American Option to Exchange One Asset for Another",
        W. Margrabe,
        Journal of Finance, 33, 177-86.

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class AnalyticAmericanMargrabeEngine : public MargrabeOption::engine {
      public:
        AnalyticAmericanMargrabeEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
                                       ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
                                       Real correlation);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2_;
        Real rho_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="77">
    <source>exotic/analyticcomplexchooserengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticcomplexchooserengine.hpp
    \brief Analytic engine for complex chooser option
*/

#ifndef quantlib_analytic_complex_chooser_engine_hpp
#define quantlib_analytic_complex_chooser_engine_hpp

#include <ql/instruments/complexchooseroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/pricingengines/blackscholescalculator.hpp>

namespace QuantLib {

    class AnalyticComplexChooserEngine : public ComplexChooserOption::engine {
      public:
        explicit AnalyticComplexChooserEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;

        Real strike(Option::Type optionType) const;
        Time choosingTime() const;
        Time putMaturity() const;
        Time callMaturity() const;
        Volatility volatility(Time t) const;

        Rate dividendYield(Time t) const;
        DiscountFactor dividendDiscount(Time t) const;

        Rate riskFreeRate(Time t) const;
        DiscountFactor riskFreeDiscount(Time t) const;

        BlackScholesCalculator bsCalculator(Real spot,
                                            Option::Type optionType) const;
        Real criticalValue() const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="78">
    <source>exotic/analyticcompoundoptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticcompoundoptionengine.hpp
    \brief Analytic compound option engines
*/

#ifndef quantlib_analytic_compound_option_engine_hpp
#define quantlib_analytic_compound_option_engine_hpp

#include <ql/instruments/compoundoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>

namespace QuantLib {

    //! Pricing engine for compound options using analytical formulae
    /*! The formulas are taken from "Foreign Exchange Risk",
        Uwe Wystup, Risk 2002, where closed form Greeks are available.
        (not available in Haug 2007).
        Value: Page 84, Greeks: Pages 94-95.

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class AnalyticCompoundOptionEngine : public CompoundOption::engine {
      public:
        explicit AnalyticCompoundOptionEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        CumulativeNormalDistribution N_;
        NormalDistribution n_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;

        // helper methods
        Time residualTimeMother() const;
        Time residualTimeDaughter() const;
        Time residualTimeMotherDaughter() const;

        Date maturityMother() const;
        Date maturityDaughter() const;

        Real dPlus() const;
        Real dMinus() const;

        Real dPlusTau12(Real S) const;
        Real dMinusTau12() const;

        Real strikeDaughter() const;
        Real strikeMother() const;

        Real spot() const;

        Real volatilityDaughter() const;
        Real volatilityMother() const;

        Real riskFreeRateDaughter() const;
        Real dividendRateDaughter() const;

        Real stdDeviationDaughter() const;
        Real stdDeviationMother() const;

        Real typeDaughter() const;
        Real typeMother() const;

        Real transformX(Real X) const;
        Real e(Real X) const;

        DiscountFactor riskFreeDiscountDaughter() const;
        DiscountFactor riskFreeDiscountMother() const;
        DiscountFactor riskFreeDiscountMotherDaughter() const;

        DiscountFactor dividendDiscountDaughter() const;
        DiscountFactor dividendDiscountMother() const;
        DiscountFactor dividendDiscountMotherDaughter() const;

        ext::shared_ptr<PlainVanillaPayoff> payoffMother() const;
        ext::shared_ptr<PlainVanillaPayoff> payoffDaughter() const;
    };

}

#endif
]]></document_content>
  </document>
  <document index="79">
    <source>exotic/analyticeuropeanmargrabeengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticeuropeanmargrabeengine.hpp
    \brief Analytic engine for European Margrabe option
*/

#ifndef quantlib_analytic_european_margrabe_engine_hpp
#define quantlib_analytic_european_margrabe_engine_hpp

#include <ql/instruments/margrabeoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic engine for European Margrabe option
    /*! This class implements formulae from
        "The Value of an Option to Exchange One Asset for Another",
        W. Margrabe,
        Journal of Finance, 33 (March 1978), 177-186.

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class AnalyticEuropeanMargrabeEngine : public MargrabeOption::engine {
      public:
        AnalyticEuropeanMargrabeEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
                                       ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
                                       Real correlation);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2_;
        Real rho_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="80">
    <source>exotic/analyticholderextensibleoptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticholderextensibleoptionengine.hpp
    \brief Analytic engine for holder-extensible options
*/

#ifndef quantlib_analytic_holder_extensible_option_engine_hpp
#define quantlib_analytic_holder_extensible_option_engine_hpp

#include <ql/instruments/holderextensibleoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/pricingengines/blackscholescalculator.hpp>

namespace QuantLib {

    //! Analytic enging for holder-extensible options
    /*! Formulas from Haug, "Option Pricing Formulas". */
    class AnalyticHolderExtensibleOptionEngine
        : public HolderExtensibleOption::engine {
      public:
        explicit AnalyticHolderExtensibleOptionEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Real strike() const;
        Time firstExpiryTime() const;
        Time secondExpiryTime() const;
        Volatility volatility() const;
        Rate riskFreeRate() const;
        Rate dividendYield() const;
        DiscountFactor dividendDiscount(Time t) const;
        DiscountFactor riskFreeDiscount(Time t) const;
        Real I1Call() const;
        Real I2Call() const;
        Real I1Put() const;
        Real I2Put() const;
        BlackScholesCalculator bsCalculator(Real spot, Option::Type optionType) const;
        Real M2(Real a, Real b, Real c, Real d, Real rho) const;
        Real N2(Real a, Real b) const;
        Real y1(Option::Type) const;
        Real y2(Option::Type) const;
        Real z1() const;
        Real z2() const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="81">
    <source>exotic/analyticsimplechooserengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticsimplechooserengine.hpp
    \brief Analytic engine for simple chooser option
*/

#ifndef quantlib_analytic_simple_chooser_engine_hpp
#define quantlib_analytic_simple_chooser_engine_hpp

#include <ql/instruments/simplechooseroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Pricing engine for European simple chooser option
    class AnalyticSimpleChooserEngine : public SimpleChooserOption::engine {
      public:
        explicit AnalyticSimpleChooserEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="82">
    <source>exotic/analytictwoassetcorrelationengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analytictwoassetcorrelationengine.hpp
    \brief Analytic engine for two-asset correlation options
*/

#ifndef quantlib_analytic_two_asset_correlation_option_engine_hpp
#define quantlib_analytic_two_asset_correlation_option_engine_hpp

#include <ql/instruments/twoassetcorrelationoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic two-asset correlation %option engine
    /*! Formulas by Zhang, from Haug's "Option Pricing Formulas". */
    class AnalyticTwoAssetCorrelationEngine
        : public TwoAssetCorrelationOption::engine {
      public:
        AnalyticTwoAssetCorrelationEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> p1,
                                          ext::shared_ptr<GeneralizedBlackScholesProcess> p2,
                                          Handle<Quote> correlation);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> p1_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> p2_;
        Handle<Quote> correlation_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="83">
    <source>exotic/analyticwriterextensibleoptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticwriterextensibleoptionengine.hpp
    \brief Analytic engine for writer-extensible options
*/

#ifndef quantlib_analytic_writer_extensible_option_engine_hpp
#define quantlib_analytic_writer_extensible_option_engine_hpp

#include <ql/instruments/writerextensibleoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic engine for writer-extensible options
    /*! Formulas from Haug, "Option Pricing Formulas". */
    class AnalyticWriterExtensibleOptionEngine
        : public WriterExtensibleOption::engine {
      public:
        explicit AnalyticWriterExtensibleOptionEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="84">
    <source>forward/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/pricingengines/forward/forwardengine.hpp>
#include <ql/pricingengines/forward/forwardperformanceengine.hpp>
#include <ql/pricingengines/forward/mcvarianceswapengine.hpp>
#include <ql/pricingengines/forward/replicatingvarianceswapengine.hpp>
#include <ql/pricingengines/forward/mcforwardvanillaengine.hpp>
#include <ql/pricingengines/forward/mcforwardeuropeanbsengine.hpp>
#include <ql/pricingengines/forward/mcforwardeuropeanhestonengine.hpp>

]]></document_content>
  </document>
  <document index="85">
    <source>forward/forwardengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file forwardengine.hpp
    \brief Forward (strike-resetting) vanilla-option engine
*/

#ifndef quantlib_forward_engine_hpp
#define quantlib_forward_engine_hpp

#include <ql/exercise.hpp>
#include <ql/instruments/forwardvanillaoption.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/termstructures/volatility/equityfx/impliedvoltermstructure.hpp>
#include <ql/termstructures/yield/impliedtermstructure.hpp>
#include <utility>

namespace QuantLib {

    //! %Forward engine for vanilla options
    /*! \ingroup forwardengines

        \test
        - the correctness of the returned value is tested by
          reproducing results available in literature.
        - the correctness of the returned greeks is tested by
          reproducing numerical derivatives.
    */
    template <class Engine>
    class ForwardVanillaEngine
        : public GenericEngine<ForwardOptionArguments<VanillaOption::arguments>,
                               VanillaOption::results> {
      public:
        ForwardVanillaEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);
        void calculate() const override;

      protected:
        void setup() const;
        void getOriginalResults() const;
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        mutable ext::shared_ptr<Engine> originalEngine_;
        mutable VanillaOption::arguments* originalArguments_;
        mutable const VanillaOption::results* originalResults_;
    };


    // template definitions

    template <class Engine>
    ForwardVanillaEngine<Engine>::ForwardVanillaEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }


    template <class Engine>
    void ForwardVanillaEngine<Engine>::setup() const {

        ext::shared_ptr<StrikedTypePayoff> argumentsPayoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(
                this->arguments_.payoff);
        QL_REQUIRE(argumentsPayoff, "wrong payoff given");

        ext::shared_ptr<StrikedTypePayoff> payoff(
                   new PlainVanillaPayoff(argumentsPayoff->optionType(),
                                          this->arguments_.moneyness *
                                          process_->x0()));

        // maybe the forward value is "better", in some fashion
        // the right level is needed in order to interpolate
        // the vol
        Handle<Quote> spot = process_->stateVariable();
        QL_REQUIRE(spot->value() > 0.0, "negative or null underlying given");
        Handle<YieldTermStructure> dividendYield(
            ext::shared_ptr<YieldTermStructure>(
               new ImpliedTermStructure(process_->dividendYield(),
                                        this->arguments_.resetDate)));
        Handle<YieldTermStructure> riskFreeRate(
            ext::shared_ptr<YieldTermStructure>(
               new ImpliedTermStructure(process_->riskFreeRate(),
                                        this->arguments_.resetDate)));
        // The following approach is ok if the vol is at most
        // time-dependent. It is plain wrong if it is asset-dependent.
        // In the latter case the right solution would be stochastic
        // volatility or at least local volatility (which unfortunately
        // implies an unrealistic time-decreasing smile)
        Handle<BlackVolTermStructure> blackVolatility(
            ext::shared_ptr<BlackVolTermStructure>(
                new ImpliedVolTermStructure(process_->blackVolatility(),
                                            this->arguments_.resetDate)));

        ext::shared_ptr<GeneralizedBlackScholesProcess> fwdProcess(
                       new GeneralizedBlackScholesProcess(spot, dividendYield,
                                                          riskFreeRate,
                                                          blackVolatility));

        originalEngine_ = ext::shared_ptr<Engine>(new Engine(fwdProcess));
        originalEngine_->reset();

        originalArguments_ =
            dynamic_cast<VanillaOption::arguments*>(
                                             originalEngine_->getArguments());
        QL_REQUIRE(originalArguments_, "wrong engine type");
        originalResults_ =
            dynamic_cast<const VanillaOption::results*>(
                                               originalEngine_->getResults());
        QL_REQUIRE(originalResults_, "wrong engine type");

        originalArguments_->payoff = payoff;
        originalArguments_->exercise = this->arguments_.exercise;

        originalArguments_->validate();
    }

    template <class Engine>
    void ForwardVanillaEngine<Engine>::calculate() const {
        setup();
        originalEngine_->calculate();
        getOriginalResults();
    }

    template <class Engine>
    void ForwardVanillaEngine<Engine>::getOriginalResults() const {

        DayCounter rfdc = process_->riskFreeRate()->dayCounter();
        DayCounter divdc = process_->dividendYield()->dayCounter();
        Time resetTime = rfdc.yearFraction(
                                     process_->riskFreeRate()->referenceDate(),
                                     this->arguments_.resetDate);
        DiscountFactor discQ = process_->dividendYield()->discount(
                                                  this->arguments_.resetDate);

        this->results_.value = discQ * originalResults_->value;
        // I need the strike derivative here ...
        if (originalResults_->delta != Null<Real>() &&
            originalResults_->strikeSensitivity != Null<Real>()) {
            this->results_.delta = discQ * (originalResults_->delta +
                  this->arguments_.moneyness * 
                        originalResults_->strikeSensitivity);
        }
        this->results_.gamma = 0.0;
        this->results_.theta = process_->dividendYield()->
            zeroRate(this->arguments_.resetDate, divdc, Continuous, NoFrequency)
            * this->results_.value;
        if (originalResults_->vega != Null<Real>())
            this->results_.vega  = discQ * originalResults_->vega;
        if (originalResults_->rho != Null<Real>())
            this->results_.rho   = discQ *  originalResults_->rho;
        if (originalResults_->dividendRho != Null<Real>()) {
            this->results_.dividendRho = - resetTime * this->results_.value
               + discQ * originalResults_->dividendRho;
        }
    }

}


#endif
]]></document_content>
  </document>
  <document index="86">
    <source>forward/forwardperformanceengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file forwardperformanceengine.hpp
    \brief Forward (strike-resetting) performance vanilla-option engine
*/

#ifndef quantlib_forward_performance_engine_hpp
#define quantlib_forward_performance_engine_hpp

#include <ql/pricingengines/forward/forwardengine.hpp>

namespace QuantLib {

    //! %Forward performance engine for vanilla options
    /*! \ingroup forwardengines

        \test
        - the correctness of the returned value is tested by
          reproducing results available in literature.
        - the correctness of the returned greeks is tested by
          reproducing numerical derivatives.
    */
    template <class Engine>
    class ForwardPerformanceVanillaEngine
        : public ForwardVanillaEngine<Engine> {
      public:
        ForwardPerformanceVanillaEngine(
                    const ext::shared_ptr<GeneralizedBlackScholesProcess>&);
        void calculate() const override;

      protected:
        void getOriginalResults() const;
    };


    // template definitions

    template <class Engine>
    ForwardPerformanceVanillaEngine<Engine>::ForwardPerformanceVanillaEngine(
        const ext::shared_ptr<GeneralizedBlackScholesProcess>& process)
    : ForwardVanillaEngine<Engine>(process) {}

    template <class Engine>
    void ForwardPerformanceVanillaEngine<Engine>::calculate() const {
        this->setup();
        this->originalEngine_->calculate();
        getOriginalResults();
    }

    template <class Engine>
    void ForwardPerformanceVanillaEngine<Engine>::getOriginalResults() const {

        DayCounter rfdc = this->process_->riskFreeRate()->dayCounter();
        Time resetTime = rfdc.yearFraction(
            this->process_->riskFreeRate()->referenceDate(),
            this->arguments_.resetDate);
        DiscountFactor discR = this->process_->riskFreeRate()->discount(
                                                  this->arguments_.resetDate);
        // it's a performance option
        discR /= this->process_->stateVariable()->value();

        Real temp = this->originalResults_->value;
        this->results_.value = discR * temp;
        this->results_.delta = 0.0;
        this->results_.gamma = 0.0;
        this->results_.theta = this->process_->riskFreeRate()->
            zeroRate(this->arguments_.resetDate, rfdc, Continuous, NoFrequency)
            * this->results_.value;
        this->results_.vega = discR * this->originalResults_->vega;
        this->results_.rho = - resetTime * this->results_.value +
            discR * this->originalResults_->rho;
        this->results_.dividendRho = discR * this->originalResults_->dividendRho;
    }

}


#endif
]]></document_content>
  </document>
  <document index="87">
    <source>forward/mcforwardeuropeanbsengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/
 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.
 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mcforwardeuropeanbsengine.hpp
    \brief Monte Carlo engine for forward-starting strike-reset European options using BS process
*/

#ifndef quantlib_mc_forward_european_bs_engine_hpp
#define quantlib_mc_forward_european_bs_engine_hpp

#include <ql/pricingengines/forward/mcforwardvanillaengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    /*! \ingroup forwardengines
        \test
        - the correctness of the returned value is tested by
          comparing prices to the analytic pricer for a range
          of moneynesses
    */
    template <class RNG = PseudoRandom, class S = Statistics>
    class MCForwardEuropeanBSEngine
        : public MCForwardVanillaEngine<SingleVariate,RNG,S> {
      public:
        typedef
        typename MCForwardVanillaEngine<SingleVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef
        typename MCForwardVanillaEngine<SingleVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename MCForwardVanillaEngine<SingleVariate,RNG,S>::stats_type
            stats_type;
        // constructor
        MCForwardEuropeanBSEngine(
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             Size timeSteps,
             Size timeStepsPerYear,
             bool brownianBridge,
             bool antitheticVariate,
             Size requiredSamples,
             Real requiredTolerance,
             Size maxSamples,
             BigNatural seed);
      protected:
        ext::shared_ptr<path_pricer_type> pathPricer() const override;
    };


    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCForwardEuropeanBSEngine {
      public:
        explicit MakeMCForwardEuropeanBSEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        // named parameters
        MakeMCForwardEuropeanBSEngine& withSteps(Size steps);
        MakeMCForwardEuropeanBSEngine& withStepsPerYear(Size steps);
        MakeMCForwardEuropeanBSEngine& withBrownianBridge(bool b = false);
        MakeMCForwardEuropeanBSEngine& withSamples(Size samples);
        MakeMCForwardEuropeanBSEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCForwardEuropeanBSEngine& withMaxSamples(Size samples);
        MakeMCForwardEuropeanBSEngine& withSeed(BigNatural seed);
        MakeMCForwardEuropeanBSEngine& withAntitheticVariate(bool b = true);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        bool antithetic_ = false;
        Size steps_, stepsPerYear_, samples_, maxSamples_;
        Real tolerance_;
        bool brownianBridge_ = false;
        BigNatural seed_ = 0;
    };


    class ForwardEuropeanBSPathPricer : public PathPricer<Path> {
      public:
        ForwardEuropeanBSPathPricer(Option::Type type,
                                   Real moneyness,
                                   Size resetIndex,
                                   DiscountFactor discount);
        Real operator()(const Path& path) const override;

      private:
        Option::Type type_;
        Real moneyness_;
        Size resetIndex_;
        DiscountFactor discount_;
    };


    // inline definitions

    template <class RNG, class S>
    inline
    MCForwardEuropeanBSEngine<RNG,S>::MCForwardEuropeanBSEngine(
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             Size timeSteps,
             Size timeStepsPerYear,
             bool brownianBridge,
             bool antitheticVariate,
             Size requiredSamples,
             Real requiredTolerance,
             Size maxSamples,
             BigNatural seed)
    : MCForwardVanillaEngine<SingleVariate,RNG,S>(process,
                                                  timeSteps,
                                                  timeStepsPerYear,
                                                  brownianBridge,
                                                  antitheticVariate,
                                                  requiredSamples,
                                                  requiredTolerance,
                                                  maxSamples,
                                                  seed) {}


    template <class RNG, class S>
    inline
    ext::shared_ptr<typename MCForwardEuropeanBSEngine<RNG,S>::path_pricer_type>
        MCForwardEuropeanBSEngine<RNG,S>::pathPricer() const {

        TimeGrid timeGrid = this->timeGrid();

        Time resetTime = this->process_->time(this->arguments_.resetDate);
        Size resetIndex = timeGrid.closestIndex(resetTime);

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                this->arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(
                this->arguments_.exercise);
        QL_REQUIRE(exercise, "wrong exercise given");

        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                this->process_);
        QL_REQUIRE(process, "Black-Scholes process required");

        return ext::shared_ptr<typename
            MCForwardEuropeanBSEngine<RNG,S>::path_pricer_type>(
                new ForwardEuropeanBSPathPricer(
                                        payoff->optionType(),
                                        this->arguments_.moneyness,
                                        resetIndex,
                                        process->riskFreeRate()->discount(
                                                   timeGrid.back())));
    }


    template <class RNG, class S>
    inline MakeMCForwardEuropeanBSEngine<RNG, S>::MakeMCForwardEuropeanBSEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)), steps_(Null<Size>()), stepsPerYear_(Null<Size>()),
      samples_(Null<Size>()), maxSamples_(Null<Size>()), tolerance_(Null<Real>()) {}

    template <class RNG, class S>
    inline MakeMCForwardEuropeanBSEngine<RNG,S>&
    MakeMCForwardEuropeanBSEngine<RNG,S>::withSteps(Size steps) {
        steps_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCForwardEuropeanBSEngine<RNG,S>&
    MakeMCForwardEuropeanBSEngine<RNG,S>::withStepsPerYear(Size steps) {
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCForwardEuropeanBSEngine<RNG,S>&
    MakeMCForwardEuropeanBSEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCForwardEuropeanBSEngine<RNG,S>&
    MakeMCForwardEuropeanBSEngine<RNG,S>::withAbsoluteTolerance(
                                                             Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCForwardEuropeanBSEngine<RNG,S>&
    MakeMCForwardEuropeanBSEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCForwardEuropeanBSEngine<RNG,S>&
    MakeMCForwardEuropeanBSEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCForwardEuropeanBSEngine<RNG,S>&
    MakeMCForwardEuropeanBSEngine<RNG,S>::withBrownianBridge(bool b) {
        brownianBridge_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCForwardEuropeanBSEngine<RNG,S>&
    MakeMCForwardEuropeanBSEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCForwardEuropeanBSEngine<RNG,S>::operator ext::shared_ptr<PricingEngine>()
                                                                      const {
        QL_REQUIRE(steps_ != Null<Size>() || stepsPerYear_ != Null<Size>(),
                   "number of steps not given");
        QL_REQUIRE(steps_ == Null<Size>() || stepsPerYear_ == Null<Size>(),
                   "number of steps overspecified - set EITHER steps OR stepsPerYear");
        return ext::shared_ptr<PricingEngine>(new
            MCForwardEuropeanBSEngine<RNG,S>(process_,
                                             steps_,
                                             stepsPerYear_,
                                             brownianBridge_,
                                             antithetic_,
                                             samples_, tolerance_,
                                             maxSamples_,
                                             seed_));
    }

}


#endif
]]></document_content>
  </document>
  <document index="88">
    <source>forward/mcforwardeuropeanhestonengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/
 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.
 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mcforwardeuropeanhestonengine.hpp
    \brief Monte Carlo engine for forward-starting strike-reset European options using Heston-like process
*/

#ifndef quantlib_mc_forward_european_heston_engine_hpp
#define quantlib_mc_forward_european_heston_engine_hpp

#include <ql/models/equity/hestonmodel.hpp>
#include <ql/pricingengines/forward/mcforwardvanillaengine.hpp>
#include <ql/pricingengines/vanilla/analytichestonengine.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <utility>

namespace QuantLib {

    /*! References:

        Control Variate trade-off considerations discussed in pull request:
        https://github.com/lballabio/QuantLib/pull/948

        \ingroup forwardengines

        \test
        - Heston MC prices for a flat Heston process are
          compared to analytical BS prices with the same
          volatility for a range of moneynesses
        - Heston MC prices for a forward-starting option
          resetting at  t=0 are compared to semi-analytical
          Heston prices for a range of moneynesses
    */
    template <class RNG = PseudoRandom,
              class S = Statistics, class P = HestonProcess>
    class MCForwardEuropeanHestonEngine
        : public MCForwardVanillaEngine<MultiVariate,RNG,S> {
      public:
        typedef
        typename MCForwardVanillaEngine<MultiVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef
        typename MCForwardVanillaEngine<MultiVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename MCForwardVanillaEngine<MultiVariate,RNG,S>::stats_type
            stats_type;
        // constructor
        MCForwardEuropeanHestonEngine(
             const ext::shared_ptr<P>& process,
             Size timeSteps,
             Size timeStepsPerYear,
             bool antitheticVariate,
             Size requiredSamples,
             Real requiredTolerance,
             Size maxSamples,
             BigNatural seed,
             bool controlVariate = false);
      protected:
        ext::shared_ptr<path_pricer_type> pathPricer() const override;

        // Use the vanilla option running from t=0 to t=expiryTime with an analytic Heston pricer
        // as a control variate. Works well if resetTime small.
        ext::shared_ptr<path_pricer_type> controlPathPricer() const override;
        ext::shared_ptr<PricingEngine> controlPricingEngine() const override {
            ext::shared_ptr<P> process = ext::dynamic_pointer_cast<P>(this->process_);
            QL_REQUIRE(process, "Heston-like process required");

            ext::shared_ptr<HestonModel> hestonModel(new HestonModel(process));
            return ext::shared_ptr<PricingEngine>(new
                AnalyticHestonEngine(hestonModel));
        }
    };


    template <class RNG = PseudoRandom,
              class S = Statistics, class P = HestonProcess>
    class MakeMCForwardEuropeanHestonEngine {
      public:
        explicit MakeMCForwardEuropeanHestonEngine(ext::shared_ptr<P> process);
        // named parameters
        MakeMCForwardEuropeanHestonEngine& withSteps(Size steps);
        MakeMCForwardEuropeanHestonEngine& withStepsPerYear(Size steps);
        MakeMCForwardEuropeanHestonEngine& withSamples(Size samples);
        MakeMCForwardEuropeanHestonEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCForwardEuropeanHestonEngine& withMaxSamples(Size samples);
        MakeMCForwardEuropeanHestonEngine& withSeed(BigNatural seed);
        MakeMCForwardEuropeanHestonEngine& withAntitheticVariate(bool b = true);
        MakeMCForwardEuropeanHestonEngine& withControlVariate(bool b = false);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<P> process_;
        bool antithetic_ = false, controlVariate_ = false;
        Size steps_, stepsPerYear_, samples_, maxSamples_;
        Real tolerance_;
        BigNatural seed_ = 0;
    };


    class ForwardEuropeanHestonPathPricer : public PathPricer<MultiPath> {
      public:
        ForwardEuropeanHestonPathPricer(Option::Type type,
                                   Real moneyness,
                                   Size resetIndex,
                                   DiscountFactor discount);
        Real operator()(const MultiPath& multiPath) const override;

      private:
        Option::Type type_;
        Real moneyness_;
        Size resetIndex_;
        DiscountFactor discount_;
    };


    // inline definitions

    template <class RNG, class S, class P>
    inline MCForwardEuropeanHestonEngine<RNG,S,P>::MCForwardEuropeanHestonEngine(
             const ext::shared_ptr<P>& process,
             Size timeSteps,
             Size timeStepsPerYear,
             bool antitheticVariate,
             Size requiredSamples,
             Real requiredTolerance,
             Size maxSamples,
             BigNatural seed,
             bool controlVariate)
    : MCForwardVanillaEngine<MultiVariate,RNG,S>(process,
                                                 timeSteps,
                                                 timeStepsPerYear,
                                                 false,
                                                 antitheticVariate,
                                                 requiredSamples,
                                                 requiredTolerance,
                                                 maxSamples,
                                                 seed,
                                                 controlVariate) {}


    template <class RNG, class S, class P>
    inline ext::shared_ptr<typename MCForwardEuropeanHestonEngine<RNG,S,P>::path_pricer_type>
        MCForwardEuropeanHestonEngine<RNG,S,P>::pathPricer() const {

        TimeGrid timeGrid = this->timeGrid();

        Time resetTime = this->process_->time(this->arguments_.resetDate);
        Size resetIndex = timeGrid.closestIndex(resetTime);

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                this->arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(
                this->arguments_.exercise);
        QL_REQUIRE(exercise, "wrong exercise given");

        ext::shared_ptr<P> process =
            ext::dynamic_pointer_cast<P>(this->process_);
        QL_REQUIRE(process, "Heston like process required");

        return ext::shared_ptr<typename
            MCForwardEuropeanHestonEngine<RNG,S,P>::path_pricer_type>(
                new ForwardEuropeanHestonPathPricer(
                                        payoff->optionType(),
                                        this->arguments_.moneyness,
                                        resetIndex,
                                        process->riskFreeRate()->discount(
                                                   timeGrid.back())));
    }

    template <class RNG, class S, class P>
    inline ext::shared_ptr<typename MCForwardEuropeanHestonEngine<RNG,S,P>::path_pricer_type>
        MCForwardEuropeanHestonEngine<RNG,S,P>::controlPathPricer() const {

        // Control variate prices a vanilla option on the path, and compares to analytical Heston
        // vanilla price. First entry in TimeGrid is 0, so use the existing path pricer reset at 0
        Size resetIndex = 0;
        TimeGrid timeGrid = this->timeGrid();

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                this->arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(
                this->arguments_.exercise);
        QL_REQUIRE(exercise, "wrong exercise given");

        ext::shared_ptr<P> process =
            ext::dynamic_pointer_cast<P>(this->process_);
        QL_REQUIRE(process, "Heston like process required");

        return ext::shared_ptr<typename
            MCForwardEuropeanHestonEngine<RNG,S,P>::path_pricer_type>(
                new ForwardEuropeanHestonPathPricer(
                                        payoff->optionType(),
                                        this->arguments_.moneyness,
                                        resetIndex,
                                        process->riskFreeRate()->discount(
                                                   timeGrid.back())));
    }

    template <class RNG, class S, class P>
    inline MakeMCForwardEuropeanHestonEngine<RNG, S, P>::MakeMCForwardEuropeanHestonEngine(
        ext::shared_ptr<P> process)
    : process_(std::move(process)), steps_(Null<Size>()), stepsPerYear_(Null<Size>()),
      samples_(Null<Size>()), maxSamples_(Null<Size>()), tolerance_(Null<Real>()) {}

    template <class RNG, class S, class P>
    inline MakeMCForwardEuropeanHestonEngine<RNG,S,P>&
    MakeMCForwardEuropeanHestonEngine<RNG,S,P>::withSteps(Size steps) {
        steps_ = steps;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCForwardEuropeanHestonEngine<RNG,S,P>&
    MakeMCForwardEuropeanHestonEngine<RNG,S,P>::withStepsPerYear(Size steps) {
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCForwardEuropeanHestonEngine<RNG,S,P>&
    MakeMCForwardEuropeanHestonEngine<RNG,S,P>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCForwardEuropeanHestonEngine<RNG,S,P>&
    MakeMCForwardEuropeanHestonEngine<RNG,S,P>::withAbsoluteTolerance(
                                                             Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCForwardEuropeanHestonEngine<RNG,S,P>&
    MakeMCForwardEuropeanHestonEngine<RNG,S,P>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCForwardEuropeanHestonEngine<RNG,S,P>&
    MakeMCForwardEuropeanHestonEngine<RNG,S,P>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCForwardEuropeanHestonEngine<RNG,S,P>&
    MakeMCForwardEuropeanHestonEngine<RNG,S,P>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCForwardEuropeanHestonEngine<RNG,S,P>&
    MakeMCForwardEuropeanHestonEngine<RNG,S,P>::withControlVariate(bool b) {
        controlVariate_ = b;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCForwardEuropeanHestonEngine<RNG,S,P>::operator ext::shared_ptr<PricingEngine>()
                                                                      const {
        QL_REQUIRE(steps_ != Null<Size>() || stepsPerYear_ != Null<Size>(),
                   "number of steps not given");
        QL_REQUIRE(steps_ == Null<Size>() || stepsPerYear_ == Null<Size>(),
                   "number of steps overspecified - set EITHER steps OR stepsPerYear");
        return ext::shared_ptr<PricingEngine>(new
            MCForwardEuropeanHestonEngine<RNG,S,P>(process_,
                                                   steps_,
                                                   stepsPerYear_,
                                                   antithetic_,
                                                   samples_,
                                                   tolerance_,
                                                   maxSamples_,
                                                   seed_,
                                                   controlVariate_));
    }
}


#endif
]]></document_content>
  </document>
  <document index="89">
    <source>forward/mcforwardvanillaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/
 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.
 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mcforwardvanillaengine.hpp
    \brief Monte Carlo engine for forward-starting strike-reset vanilla options
*/

#ifndef quantlib_mcforwardvanilla_engine_hpp
#define quantlib_mcforwardvanilla_engine_hpp

#include <ql/instruments/forwardvanillaoption.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <utility>

namespace QuantLib {

    //! Monte Carlo engine for forward-starting vanilla options
    /*! \ingroup forwardengines
    */
    template<template <class> class MC,
             class RNG = PseudoRandom, class S = Statistics>
    class MCForwardVanillaEngine : public GenericEngine<ForwardOptionArguments<VanillaOption::arguments>,
                                                        VanillaOption::results>,
                                   public McSimulation<MC,RNG,S>
    {
      public:
        typedef typename McSimulation<MC,RNG,S>::path_generator_type
            path_generator_type;
        typedef typename McSimulation<MC,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename McSimulation<MC,RNG,S>::stats_type
            stats_type;
        // constructor
        MCForwardVanillaEngine(ext::shared_ptr<StochasticProcess> process,
                               Size timeSteps,
                               Size timeStepsPerYear,
                               bool brownianBridge,
                               bool antitheticVariate,
                               Size requiredSamples,
                               Real requiredTolerance,
                               Size maxSamples,
                               BigNatural seed,
                               bool controlVariate = false);
        void calculate() const override {
            McSimulation<MC,RNG,S>::calculate(requiredTolerance_,
                                              requiredSamples_,
                                              maxSamples_);
            this->results_.value = this->mcModel_->sampleAccumulator().mean();
            if constexpr (RNG::allowsErrorEstimate)
                this->results_.errorEstimate =
                    this->mcModel_->sampleAccumulator().errorEstimate();
        }

      protected:
        // McSimulation implementation
        TimeGrid timeGrid() const override;
        Real controlVariateValue() const override;
        ext::shared_ptr<path_generator_type> pathGenerator() const override {

            Size dimensions = process_->factors();
            TimeGrid grid = this->timeGrid();
            typename RNG::rsg_type gen =
                RNG::make_sequence_generator(dimensions*(grid.size()-1),seed_);
            return ext::shared_ptr<path_generator_type>(
                         new path_generator_type(process_, grid,
                                                 gen, brownianBridge_));
        }
        // data members
        ext::shared_ptr<StochasticProcess> process_;
        Size timeSteps_, timeStepsPerYear_, requiredSamples_, maxSamples_;
        Real requiredTolerance_;
        bool brownianBridge_;
        BigNatural seed_;
    };

    template <template <class> class MC, class RNG, class S>
    inline MCForwardVanillaEngine<MC, RNG, S>::MCForwardVanillaEngine(
        ext::shared_ptr<StochasticProcess> process,
        Size timeSteps,
        Size timeStepsPerYear,
        bool brownianBridge,
        bool antitheticVariate,
        Size requiredSamples,
        Real requiredTolerance,
        Size maxSamples,
        BigNatural seed,
        bool controlVariate)
    : McSimulation<MC, RNG, S>(antitheticVariate, controlVariate), process_(std::move(process)),
      timeSteps_(timeSteps), timeStepsPerYear_(timeStepsPerYear), requiredSamples_(requiredSamples),
      maxSamples_(maxSamples), requiredTolerance_(requiredTolerance),
      brownianBridge_(brownianBridge), seed_(seed) {
        QL_REQUIRE(timeSteps != Null<Size>() ||
                   timeStepsPerYear != Null<Size>(),
                   "no time steps provided");
        QL_REQUIRE(timeSteps == Null<Size>() ||
                   timeStepsPerYear == Null<Size>(),
                   "both time steps and time steps per year were provided");
        QL_REQUIRE(timeSteps != 0,
                   "timeSteps must be positive, " << timeSteps <<
                   " not allowed");
        QL_REQUIRE(timeStepsPerYear != 0,
                   "timeStepsPerYear must be positive, " << timeStepsPerYear <<
                   " not allowed");
        registerWith(process_);
    }

    template <template <class> class MC, class RNG, class S>
    inline TimeGrid MCForwardVanillaEngine<MC,RNG,S>::timeGrid() const {

        Date resetDate = arguments_.resetDate;
        Date lastExerciseDate = arguments_.exercise->lastDate();

        Time t1 = process_->time(resetDate);
        Time t2 = process_->time(lastExerciseDate);

        Size totalSteps = Null<Size>();
        if (this->timeSteps_ != Null<Size>()) {
            totalSteps = timeSteps_;
        } else if (this->timeStepsPerYear_ != Null<Size>()) {
            totalSteps = static_cast<Size>(this->timeStepsPerYear_*t2);
        }

        std::vector<Time> fixingTimes;
        fixingTimes.push_back(t1);
        fixingTimes.push_back(t2);

        return TimeGrid(fixingTimes.begin(), fixingTimes.end(), totalSteps);
    }

    template <template <class> class MC, class RNG, class S>
    inline Real MCForwardVanillaEngine<MC,RNG,S>::controlVariateValue() const {

        ext::shared_ptr<PricingEngine> controlPE =
                this->controlPricingEngine();
        QL_REQUIRE(controlPE, "engine does not provide "
                              "control variation pricing engine");

        // Create vanilla option arguments with the same payoff and expiry, but with
        // strike-reset equal to initial spot*moneyness, price analytically
        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(
                this->arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        Real spot = this->process_->initialValues()[0];
        Real moneyness = this->arguments_.moneyness;
        Real strike = moneyness * spot;

        ext::shared_ptr<StrikedTypePayoff> newPayoff(new
            PlainVanillaPayoff(payoff->optionType(), strike));

        auto* controlArguments = dynamic_cast<VanillaOption::arguments*>(controlPE->getArguments());

        controlArguments->payoff = newPayoff;
        controlArguments->exercise = this->arguments_.exercise;
        controlPE->calculate();

        const auto* controlResults =
            dynamic_cast<const VanillaOption::results*>(controlPE->getResults());

        return controlResults->value;
    }
}


#endif
]]></document_content>
  </document>
  <document index="90">
    <source>forward/mcvarianceswapengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mcvarianceswapengine.hpp
    \brief Monte Carlo variance-swap engine
*/

#ifndef quantlib_mc_varianceswap_engine_hpp
#define quantlib_mc_varianceswap_engine_hpp

#include <ql/instruments/varianceswap.hpp>
#include <ql/math/integrals/segmentintegral.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    //! Variance-swap pricing engine using Monte Carlo simulation,
    /*! as described in Demeterfi, Derman, Kamal & Zou,
        "A Guide to Volatility and Variance Swaps", 1999

        \ingroup forwardengines

        \todo define tolerance of numerical integral and incorporate it
              in errorEstimate

        \test returned fair variances checked for consistency with
              implied volatility curve.
    */
    template <class RNG = PseudoRandom, class S = Statistics>
    class MCVarianceSwapEngine : public VarianceSwap::engine,
                                 public McSimulation<SingleVariate,RNG,S> {
      public:
        typedef
        typename McSimulation<SingleVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef
        typename McSimulation<SingleVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename McSimulation<SingleVariate,RNG,S>::stats_type
            stats_type;
        // constructor
        MCVarianceSwapEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                             Size timeSteps,
                             Size timeStepsPerYear,
                             bool brownianBridge,
                             bool antitheticVariate,
                             Size requiredSamples,
                             Real requiredTolerance,
                             Size maxSamples,
                             BigNatural seed);
        // calculate variance via Monte Carlo
        void calculate() const override {
            McSimulation<SingleVariate,RNG,S>::calculate(requiredTolerance_,
                                                         requiredSamples_,
                                                         maxSamples_);
            results_.variance =
                     this->mcModel_->sampleAccumulator().mean();

            DiscountFactor riskFreeDiscount =
                process_->riskFreeRate()->discount(arguments_.maturityDate);
            Real multiplier;
            switch (arguments_.position) {
              case Position::Long:
                multiplier = 1.0;
                break;
              case Position::Short:
                multiplier = -1.0;
                break;
              default:
                QL_FAIL("Unknown position");
            }
            multiplier *= riskFreeDiscount * arguments_.notional;

            results_.value =
                multiplier * (results_.variance - arguments_.strike);

            if constexpr (RNG::allowsErrorEstimate) {
                Real varianceError =
                    this->mcModel_->sampleAccumulator().errorEstimate();
                results_.errorEstimate = multiplier * varianceError;
            }
        }

      protected:
        // McSimulation implementation
        ext::shared_ptr<path_pricer_type> pathPricer() const override;
        TimeGrid timeGrid() const override;

        ext::shared_ptr<path_generator_type> pathGenerator() const override {

            Size dimensions = process_->factors();

            TimeGrid grid = timeGrid();
            typename RNG::rsg_type gen =
                RNG::make_sequence_generator(dimensions*(grid.size()-1),seed_);

            return ext::shared_ptr<path_generator_type>(
                         new path_generator_type(process_, grid, gen,
                                                 brownianBridge_));
        }
        // data members
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Size timeSteps_, timeStepsPerYear_;
        Size requiredSamples_, maxSamples_;
        Real requiredTolerance_;
        bool brownianBridge_;
        BigNatural seed_;
    };


    //! Monte Carlo variance-swap engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCVarianceSwapEngine {
      public:
        MakeMCVarianceSwapEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        // named parameters
        MakeMCVarianceSwapEngine& withSteps(Size steps);
        MakeMCVarianceSwapEngine& withStepsPerYear(Size steps);
        MakeMCVarianceSwapEngine& withBrownianBridge(bool b = true);
        MakeMCVarianceSwapEngine& withSamples(Size samples);
        MakeMCVarianceSwapEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCVarianceSwapEngine& withMaxSamples(Size samples);
        MakeMCVarianceSwapEngine& withSeed(BigNatural seed);
        MakeMCVarianceSwapEngine& withAntitheticVariate(bool b = true);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        bool antithetic_ = false;
        Size steps_, stepsPerYear_, samples_, maxSamples_;
        Real tolerance_;
        bool brownianBridge_ = false;
        BigNatural seed_ = 0;
    };

    class VariancePathPricer : public PathPricer<Path> {
      public:
        VariancePathPricer(ext::shared_ptr<GeneralizedBlackScholesProcess> process)
        : process_(std::move(process)) {}
        Real operator()(const Path& path) const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

    // inline definitions

    template <class RNG, class S>
    inline MCVarianceSwapEngine<RNG, S>::MCVarianceSwapEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Size timeSteps,
        Size timeStepsPerYear,
        bool brownianBridge,
        bool antitheticVariate,
        Size requiredSamples,
        Real requiredTolerance,
        Size maxSamples,
        BigNatural seed)
    : McSimulation<SingleVariate, RNG, S>(antitheticVariate, false), process_(std::move(process)),
      timeSteps_(timeSteps), timeStepsPerYear_(timeStepsPerYear), requiredSamples_(requiredSamples),
      maxSamples_(maxSamples), requiredTolerance_(requiredTolerance),
      brownianBridge_(brownianBridge), seed_(seed) {
        QL_REQUIRE(timeSteps != Null<Size>() ||
                   timeStepsPerYear != Null<Size>(),
                   "no time steps provided");
        QL_REQUIRE(timeSteps == Null<Size>() ||
                   timeStepsPerYear == Null<Size>(),
                   "both time steps and time steps per year were provided");
        QL_REQUIRE(timeSteps != 0,
                   "timeSteps must be positive, " << timeSteps <<
                   " not allowed");
        QL_REQUIRE(timeStepsPerYear != 0,
                   "timeStepsPerYear must be positive, " << timeStepsPerYear <<
                   " not allowed");
    }


    template <class RNG, class S>
    inline TimeGrid MCVarianceSwapEngine<RNG,S>::timeGrid() const {

        Time t = this->process_->time(this->arguments_.maturityDate);

        if (timeSteps_ != Null<Size>()) {
            return TimeGrid(t, this->timeSteps_);
        } else if (timeStepsPerYear_ != Null<Size>()) {
            Size steps = static_cast<Size>(timeStepsPerYear_*t);
            return TimeGrid(t, std::max<Size>(steps, 1));
        } else {
            QL_FAIL("time steps not specified");
        }
    }


    template <class RNG, class S>
    inline
    ext::shared_ptr<
        typename MCVarianceSwapEngine<RNG,S>::path_pricer_type>
    MCVarianceSwapEngine<RNG,S>::pathPricer() const {

        return ext::shared_ptr<
            typename MCVarianceSwapEngine<RNG,S>::path_pricer_type>(
                                            new VariancePathPricer(process_));
    }


    template <class RNG, class S>
    inline MakeMCVarianceSwapEngine<RNG, S>::MakeMCVarianceSwapEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)), steps_(Null<Size>()), stepsPerYear_(Null<Size>()),
      samples_(Null<Size>()), maxSamples_(Null<Size>()), tolerance_(Null<Real>()) {}

    template <class RNG, class S>
    inline MakeMCVarianceSwapEngine<RNG,S>&
    MakeMCVarianceSwapEngine<RNG,S>::withSteps(Size steps) {
        steps_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCVarianceSwapEngine<RNG,S>&
    MakeMCVarianceSwapEngine<RNG,S>::withStepsPerYear(Size steps) {
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCVarianceSwapEngine<RNG,S>&
    MakeMCVarianceSwapEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCVarianceSwapEngine<RNG,S>&
    MakeMCVarianceSwapEngine<RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCVarianceSwapEngine<RNG,S>&
    MakeMCVarianceSwapEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCVarianceSwapEngine<RNG,S>&
    MakeMCVarianceSwapEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCVarianceSwapEngine<RNG,S>&
    MakeMCVarianceSwapEngine<RNG,S>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCVarianceSwapEngine<RNG,S>&
    MakeMCVarianceSwapEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCVarianceSwapEngine<RNG,S>::
    operator ext::shared_ptr<PricingEngine>() const {
        QL_REQUIRE(steps_ != Null<Size>() || stepsPerYear_ != Null<Size>(),
                   "number of steps not given");
        QL_REQUIRE(steps_ == Null<Size>() || stepsPerYear_ == Null<Size>(),
                   "number of steps overspecified");
        return ext::shared_ptr<PricingEngine>(
                         new MCVarianceSwapEngine<RNG,S>(process_,
                                                         steps_,
                                                         stepsPerYear_,
                                                         brownianBridge_,
                                                         antithetic_,
                                                         samples_, tolerance_,
                                                         maxSamples_,
                                                         seed_));
    }


    namespace detail {

        class Integrand {
          public:
            Integrand(Path path, ext::shared_ptr<GeneralizedBlackScholesProcess> process)
            : path_(std::move(path)), process_(std::move(process)) {}
            Real operator()(Time t) const {
                Size i =  static_cast<Size>(t/path_.timeGrid().dt(0));
                Real sigma = process_->diffusion(t,path_[i]);
                return sigma*sigma;
            }
          private:
            Path path_;
            ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        };

    }


    inline Real VariancePathPricer::operator()(const Path& path) const {
        QL_REQUIRE(!path.empty(), "the path cannot be empty");
        Time t0 = path.timeGrid().front();
        Time t = path.timeGrid().back();
        Time dt = path.timeGrid().dt(0);
        SegmentIntegral integrator(static_cast<Size>(t/dt));
        detail::Integrand f(path, process_);
        return integrator(f,t0,t)/t;
    }

}


#endif
]]></document_content>
  </document>
  <document index="91">
    <source>forward/replicatingvarianceswapengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2007, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file replicatingvarianceswapengine.hpp
    \brief Replicating engine for variance swaps
*/

#ifndef quantlib_replicating_varianceswap_engine_hpp
#define quantlib_replicating_varianceswap_engine_hpp

#include <ql/exercise.hpp>
#include <ql/instruments/europeanoption.hpp>
#include <ql/instruments/varianceswap.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <utility>

namespace QuantLib {

    //! Variance-swap pricing engine using replicating cost,
    /*! as described in Demeterfi, Derman, Kamal & Zou,
        "A Guide to Volatility and Variance Swaps", 1999

        \ingroup forwardengines

        \test returned variances verified against results from literature
    */
    class ReplicatingVarianceSwapEngine : public VarianceSwap::engine {
      public:
        typedef std::vector<std::pair<
                   ext::shared_ptr<StrikedTypePayoff>, Real> > weights_type;
        // constructor
        ReplicatingVarianceSwapEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                                      Real dk = 5.0,
                                      const std::vector<Real>& callStrikes = std::vector<Real>(),
                                      const std::vector<Real>& putStrikes = std::vector<Real>());
        void calculate() const override;

      protected:
        // helper methods
        void computeOptionWeights(const std::vector<Real>&,
                                  Option::Type,
                                  weights_type& optionWeights) const;
        Real computeLogPayoff(Real, Real) const;
        Real computeReplicatingPortfolio(
                                     const weights_type& optionWeights) const;
        Rate riskFreeRate() const;
        DiscountFactor riskFreeDiscount() const;
        Real underlying() const;
        Time residualTime() const;
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Real dk_;
        std::vector<Real> callStrikes_, putStrikes_;
    };


    // inline definitions

    inline ReplicatingVarianceSwapEngine::ReplicatingVarianceSwapEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Real dk,
        const std::vector<Real>& callStrikes,
        const std::vector<Real>& putStrikes)
    : process_(std::move(process)), dk_(dk), callStrikes_(callStrikes), putStrikes_(putStrikes) {

        QL_REQUIRE(process_, "no process given");
        QL_REQUIRE(!callStrikes.empty() && !putStrikes.empty(),
                   "no strike(s) given");
        QL_REQUIRE(*std::min_element(putStrikes.begin(),putStrikes.end())>0.0,
                   "min put strike must be positive");
        QL_REQUIRE(*std::min_element(callStrikes.begin(), callStrikes.end())==
                   *std::max_element(putStrikes.begin(), putStrikes.end()),
                   "min call and max put strikes differ");
    }


    inline void ReplicatingVarianceSwapEngine::computeOptionWeights(
                                    const std::vector<Real>& availStrikes,
                                    const Option::Type type,
                                    weights_type& optionWeights) const {
        if (availStrikes.empty())
            return;

        std::vector<Real> strikes = availStrikes;

        // add end-strike for piecewise approximation
        switch (type) {
          case Option::Call:
            std::sort(strikes.begin(), strikes.end());
            strikes.push_back(strikes.back() + dk_);
            break;
          case Option::Put:
            std::sort(strikes.begin(), strikes.end(), std::greater<>());
            strikes.push_back(std::max(strikes.back() - dk_, 0.0));
            break;
          default:
            QL_FAIL("invalid option type");
        }

        // remove duplicate strikes
        auto last = std::unique(strikes.begin(), strikes.end());
        strikes.erase(last, strikes.end());

        // compute weights
        Real f = strikes.front();
        Real slope, prevSlope = 0.0;




        for (auto k=strikes.begin();
             // added end-strike discarded
             k<strikes.end()-1;
             ++k) {
            slope = std::fabs((computeLogPayoff(*(k+1), f) -
                               computeLogPayoff(*k, f))/
                              (*(k+1) - *k));
            ext::shared_ptr<StrikedTypePayoff> payoff(
                                            new PlainVanillaPayoff(type, *k));
            if ( k == strikes.begin() )
                optionWeights.emplace_back(payoff,slope);
            else
                optionWeights.emplace_back(payoff, slope - prevSlope);
            prevSlope = slope;
        }
    }


    inline Real ReplicatingVarianceSwapEngine::computeLogPayoff(
                         const Real strike,
                         const Real callPutStrikeBoundary) const {
        Real f = callPutStrikeBoundary;
        return (2.0/residualTime()) * (((strike - f)/f) - std::log(strike/f));
    }


    inline
    Real ReplicatingVarianceSwapEngine::computeReplicatingPortfolio(
                                    const weights_type& optionWeights) const {

        ext::shared_ptr<Exercise> exercise(
                               new EuropeanExercise(arguments_.maturityDate));
        ext::shared_ptr<PricingEngine> optionEngine(
                                        new AnalyticEuropeanEngine(process_));
        Real optionsValue = 0.0;

        for (auto i = optionWeights.begin(); i < optionWeights.end(); ++i) {
            ext::shared_ptr<StrikedTypePayoff> payoff = i->first;
            EuropeanOption option(payoff, exercise);
            option.setPricingEngine(optionEngine);
            Real weight = i->second;
            optionsValue += option.NPV() * weight;
        }

        Real f = optionWeights.front().first->strike();
        return 2.0 * riskFreeRate() -
            2.0/residualTime() *
            (((underlying()/riskFreeDiscount() - f)/f) +
             std::log(f/underlying())) +
            optionsValue/riskFreeDiscount();
    }


     // calculate variance via replicating portfolio
    inline void ReplicatingVarianceSwapEngine::calculate() const {
        weights_type optionWeigths;
        computeOptionWeights(callStrikes_, Option::Call, optionWeigths);
        computeOptionWeights(putStrikes_, Option::Put, optionWeigths);

        results_.variance = computeReplicatingPortfolio(optionWeigths);

        DiscountFactor riskFreeDiscount =
            process_->riskFreeRate()->discount(arguments_.maturityDate);
        Real multiplier;
        switch (arguments_.position) {
          case Position::Long:
            multiplier = 1.0;
            break;
          case Position::Short:
            multiplier = -1.0;
            break;
          default:
            QL_FAIL("Unknown position");
        }
        results_.value = multiplier * riskFreeDiscount * arguments_.notional *
            (results_.variance - arguments_.strike);

        results_.additionalResults["optionWeights"] = optionWeigths;
    }


    inline Real ReplicatingVarianceSwapEngine::underlying() const {
        return process_->x0();
    }


    inline Time ReplicatingVarianceSwapEngine::residualTime() const {
        return process_->time(arguments_.maturityDate);
    }


    inline Rate ReplicatingVarianceSwapEngine::riskFreeRate() const {
        return process_->riskFreeRate()->zeroRate(residualTime(), Continuous,
                                                  NoFrequency, true);
    }


    inline
    DiscountFactor ReplicatingVarianceSwapEngine::riskFreeDiscount() const {
        return process_->riskFreeRate()->discount(residualTime());
    }

}


#endif
]]></document_content>
  </document>
  <document index="92">
    <source>futures/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/pricingengines/futures/discountingperpetualfuturesengine.hpp>

]]></document_content>
  </document>
  <document index="93">
    <source>futures/discountingperpetualfuturesengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2025 Hiroto Ogawa

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file discountingperpetualfuturesengine.hpp
    \brief discounting perpetual futures engine
*/

#ifndef quantlib_discounting_perpetual_futures_engine_hpp
#define quantlib_discounting_perpetual_futures_engine_hpp

#include <ql/instruments/perpetualfutures.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/handle.hpp>
#include <ql/optional.hpp>
#include <ql/math/interpolation.hpp>

namespace QuantLib {

    //! Discounting engine for perpetual futures
    /*! This engine discounts perpetual futures cashflows
        to the reference date.
    */
    class DiscountingPerpetualFuturesEngine : public PerpetualFutures::engine {
      public:
        enum InterpolationType { PiecewiseConstant, Linear, CubicSpline };
        DiscountingPerpetualFuturesEngine(
            const Handle<YieldTermStructure>& domesticDiscountCurve,
            const Handle<YieldTermStructure>& foreignDiscountCurve,
            const Handle<Quote>& assetSpot,
            const std::vector<Time>& fundingTimes,
            const std::vector<Rate>& fundingRates,
            const std::vector<Spread>& interestRateDiffs,
            InterpolationType fundingInterpType = PiecewiseConstant,
            Real maxT = 60.);
        void calculate() const override;
        Handle<YieldTermStructure> domesticDiscountCurve() const { return domesticDiscountCurve_; }
        Handle<YieldTermStructure> foreignDiscountCurve() const { return foreignDiscountCurve_; }
        Handle<Quote> assetSpot() const { return assetSpot_; }
        const std::vector<Time>& fundingTimes() const { return fundingTimes_; }
        const std::vector<Rate>& fundingRates() const { return fundingRates_; }
        const std::vector<Spread>& interestRateDiffs() const { return interestRateDiffs_; }

      private:
        Interpolation selectInterpolation(const std::vector<Time>& times, const std::vector<Real>& values) const;
        Handle<YieldTermStructure> domesticDiscountCurve_, foreignDiscountCurve_;
        Handle<Quote> assetSpot_;
        std::vector<Time> fundingTimes_;
        std::vector<Rate> fundingRates_;
        std::vector<Spread> interestRateDiffs_;
        InterpolationType fundingInterpType_;
        Real maxT_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="94">
    <source>genericmodelengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Ferdinando Ametrano
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file genericmodelengine.hpp
    \brief Generic option engine based on a model
*/

#ifndef quantlib_generic_model_engine_hpp
#define quantlib_generic_model_engine_hpp

#include <ql/handle.hpp>
#include <ql/pricingengine.hpp>
#include <utility>

namespace QuantLib {

    //! Base class for some pricing engine on a particular model
    /*! Derived engines only need to implement the <tt>calculate()</tt>
        method
    */
    template<class ModelType, class ArgumentsType, class ResultsType>
    class GenericModelEngine
        : public GenericEngine<ArgumentsType, ResultsType> {
      public:
        explicit GenericModelEngine(Handle<ModelType> model = Handle<ModelType>())
        : model_(std::move(model)) {
            this->registerWith(model_);
        }
        explicit GenericModelEngine(const ext::shared_ptr<ModelType>& model)
        : model_(model) {
            this->registerWith(model_);
        }
      protected:
        Handle<ModelType> model_;
    };

}


#endif

]]></document_content>
  </document>
  <document index="95">
    <source>greeks.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file greeks.hpp
    \brief default greek calculations
*/

#ifndef quantlib_greeks_hpp
#define quantlib_greeks_hpp

#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! default theta calculation for Black-Scholes options
    Real blackScholesTheta(
                     const ext::shared_ptr<GeneralizedBlackScholesProcess>&,
                     Real value, Real delta, Real gamma);

    //! default theta-per-day calculation
    Real defaultThetaPerDay(Real theta);

}


#endif
]]></document_content>
  </document>
  <document index="96">
    <source>inflation/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/pricingengines/inflation/inflationcapfloorengines.hpp>

]]></document_content>
  </document>
  <document index="97">
    <source>inflation/inflationcapfloorengines.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

/*! \file inflationcapfloorengines.hpp
    \brief Inflation cap/floor engines
 */

#ifndef quantlib_pricers_inflation_capfloor_hpp
#define quantlib_pricers_inflation_capfloor_hpp

#include <ql/instruments/inflationcapfloor.hpp>
#include <ql/termstructures/volatility/inflation/yoyinflationoptionletvolatilitystructure.hpp>
#include <ql/option.hpp>

namespace QuantLib {

    class Quote;
    class YoYOptionletVolatilitySurface;
    class YoYInflationIndex;

    //! Base YoY inflation cap/floor engine
    /*! This class doesn't know yet what sort of vol it is.  The
        inflation index must be linked to a yoy inflation term
        structure.

        \ingroup inflationcapfloorengines
    */
    class YoYInflationCapFloorEngine : public YoYInflationCapFloor::engine {
      public:
        YoYInflationCapFloorEngine(ext::shared_ptr<YoYInflationIndex>,
                                   Handle<YoYOptionletVolatilitySurface> vol,
                                   Handle<YieldTermStructure> nominalTermStructure);

        ext::shared_ptr<YoYInflationIndex> index() const { return index_;}
        Handle<YoYOptionletVolatilitySurface> volatility() const { return volatility_; }
        Handle<YieldTermStructure> nominalTermStructure() const { return nominalTermStructure_; }

        void setVolatility(const Handle<YoYOptionletVolatilitySurface>& vol);

        void calculate() const override;

      protected:
        //! descendents only need to implement this
        virtual Real optionletImpl(Option::Type type, Rate strike,
                                   Rate forward, Real stdDev,
                                   Real d) const = 0;

        ext::shared_ptr<YoYInflationIndex> index_;
        Handle<YoYOptionletVolatilitySurface> volatility_;
        Handle<YieldTermStructure> nominalTermStructure_;
    };



    //! Black-formula inflation cap/floor engine (standalone, i.e. no coupon pricer)
    class YoYInflationBlackCapFloorEngine
    : public YoYInflationCapFloorEngine {
      public:
        YoYInflationBlackCapFloorEngine(const ext::shared_ptr<YoYInflationIndex>&,
                                        const Handle<YoYOptionletVolatilitySurface>& vol,
                                        const Handle<YieldTermStructure>& nominalTermStructure);
      protected:
        Real
        optionletImpl(Option::Type, Real strike, Real forward, Real stdDev, Real d) const override;
    };


    //! Unit Displaced Black-formula inflation cap/floor engine (standalone, i.e. no coupon pricer)
    class YoYInflationUnitDisplacedBlackCapFloorEngine
    : public YoYInflationCapFloorEngine {
      public:
        YoYInflationUnitDisplacedBlackCapFloorEngine(
                    const ext::shared_ptr<YoYInflationIndex>&,
                    const Handle<YoYOptionletVolatilitySurface>& vol,
                    const Handle<YieldTermStructure>& nominalTermStructure);
      protected:
        Real
        optionletImpl(Option::Type, Real strike, Real forward, Real stdDev, Real d) const override;
    };


    //! Unit Displaced Black-formula inflation cap/floor engine (standalone, i.e. no coupon pricer)
    class YoYInflationBachelierCapFloorEngine
    : public YoYInflationCapFloorEngine {
      public:
        YoYInflationBachelierCapFloorEngine(
                    const ext::shared_ptr<YoYInflationIndex>&,
                    const Handle<YoYOptionletVolatilitySurface>& vol,
                    const Handle<YieldTermStructure>& nominalTermStructure);
      protected:
        Real
        optionletImpl(Option::Type, Real strike, Real forward, Real stdDev, Real d) const override;
    };

}

#endif
]]></document_content>
  </document>
  <document index="98">
    <source>latticeshortratemodelengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file latticeshortratemodelengine.hpp
    \brief Engine for a short-rate model specialized on a lattice
*/

#ifndef quantlib_short_rate_model_engine_hpp
#define quantlib_short_rate_model_engine_hpp

#include <ql/models/model.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>

namespace QuantLib {

    //! Engine for a short-rate model specialized on a lattice
    /*! Derived engines only need to implement the <tt>calculate()</tt>
        method
    */
    template <class Arguments, class Results>
    class LatticeShortRateModelEngine
        : public GenericModelEngine<ShortRateModel, Arguments, Results> {
      public:
        LatticeShortRateModelEngine(
                               const ext::shared_ptr<ShortRateModel>& model,
                               Size timeSteps);
        LatticeShortRateModelEngine(
                               const Handle<ShortRateModel>& model,
                               Size timeSteps);
        LatticeShortRateModelEngine(
                               const ext::shared_ptr<ShortRateModel>& model,
                               const TimeGrid& timeGrid);
        void update() override;

      protected:
        TimeGrid timeGrid_;
        Size timeSteps_;
        ext::shared_ptr<Lattice> lattice_;
    };

    template <class Arguments, class Results>
    LatticeShortRateModelEngine<Arguments, Results>::LatticeShortRateModelEngine(
            const ext::shared_ptr<ShortRateModel>& model,
            Size timeSteps)
    : GenericModelEngine<ShortRateModel, Arguments, Results>(model),
      timeSteps_(timeSteps) {
        QL_REQUIRE(timeSteps>0,
                   "timeSteps must be positive, " << timeSteps <<
                   " not allowed");
    }

    template <class Arguments, class Results>
    LatticeShortRateModelEngine<Arguments, Results>::LatticeShortRateModelEngine(
            const Handle<ShortRateModel>& model,
            Size timeSteps)
    : GenericModelEngine<ShortRateModel, Arguments, Results>(model),
      timeSteps_(timeSteps) {
        QL_REQUIRE(timeSteps>0,
                   "timeSteps must be positive, " << timeSteps <<
                   " not allowed");
    }

    template <class Arguments, class Results>
    LatticeShortRateModelEngine<Arguments, Results>::LatticeShortRateModelEngine(
            const ext::shared_ptr<ShortRateModel>& model,
            const TimeGrid& timeGrid)
    : GenericModelEngine<ShortRateModel, Arguments, Results>(model),
      timeGrid_(timeGrid), timeSteps_(0) {
        lattice_ = this->model_->tree(timeGrid);
    }

    template <class Arguments, class Results>
    void LatticeShortRateModelEngine<Arguments, Results>::update()
    {
        if (!timeGrid_.empty())
            lattice_ = this->model_->tree(timeGrid_);
        GenericModelEngine<ShortRateModel, Arguments, Results>::update();
    }

}


#endif
]]></document_content>
  </document>
  <document index="99">
    <source>lookback/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/pricingengines/lookback/analyticcontinuousfixedlookback.hpp>
#include <ql/pricingengines/lookback/analyticcontinuousfloatinglookback.hpp>
#include <ql/pricingengines/lookback/analyticcontinuouspartialfixedlookback.hpp>
#include <ql/pricingengines/lookback/analyticcontinuouspartialfloatinglookback.hpp>
#include <ql/pricingengines/lookback/mclookbackengine.hpp>

]]></document_content>
  </document>
  <document index="100">
    <source>lookback/analyticcontinuousfixedlookback.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticcontinuousfixedlookback.hpp
    \brief Analytic engine for continuous fixed-strike lookback
*/

#ifndef quantlib_analytic_continuous_fixed_lookback_engine_hpp
#define quantlib_analytic_continuous_fixed_lookback_engine_hpp

#include <ql/instruments/lookbackoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {

    //! Pricing engine for European continuous fixed-strike lookback
    /*! Formula from "Option Pricing Formulas",
        E.G. Haug, McGraw-Hill, 1998, p.63-64

        \ingroup lookbackengines

        \test returned values are verified against results from literature
    */
    class AnalyticContinuousFixedLookbackEngine
        : public ContinuousFixedLookbackOption::engine {
      public:
        AnalyticContinuousFixedLookbackEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        CumulativeNormalDistribution f_;
        // helper methods
        Real underlying() const;
        Real strike() const;
        Time residualTime() const;
        Volatility volatility() const;
        Real minmax() const;
        Real stdDeviation() const;
        Rate riskFreeRate() const;
        DiscountFactor riskFreeDiscount() const;
        Rate dividendYield() const;
        DiscountFactor dividendDiscount() const;
        Real A(Real eta) const;
        Real B(Real eta) const;
        Real C(Real eta) const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="101">
    <source>lookback/analyticcontinuousfloatinglookback.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticcontinuousfloatinglookback.hpp
    \brief Analytic engine for continuous floating-strike lookback
*/

#ifndef quantlib_analytic_continuous_floating_lookback_engine_hpp
#define quantlib_analytic_continuous_floating_lookback_engine_hpp

#include <ql/instruments/lookbackoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {

    //! Pricing engine for European continuous floating-strike lookback
    /*! Formula from "Option Pricing Formulas",
        E.G. Haug, McGraw-Hill, 1998, p.61-62

        \ingroup lookbackengines

        \test returned values verified against results from literature
    */
    class AnalyticContinuousFloatingLookbackEngine
        : public ContinuousFloatingLookbackOption::engine {
      public:
        AnalyticContinuousFloatingLookbackEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        CumulativeNormalDistribution f_;
        // helper methods
        Real underlying() const;
        Time residualTime() const;
        Volatility volatility() const;
        Real minmax() const;
        Real stdDeviation() const;
        Rate riskFreeRate() const;
        DiscountFactor riskFreeDiscount() const;
        Rate dividendYield() const;
        DiscountFactor dividendDiscount() const;
        Real A(Real eta) const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="102">
    <source>lookback/analyticcontinuouspartialfixedlookback.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2014 Francois Botha

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticcontinuouspartialfixedlookback.hpp
    \brief Analytic engine for continuous fixed-strike lookback
*/

#ifndef quantlib_analytic_continuous_partial_fixed_lookback_engine_hpp
#define quantlib_analytic_continuous_partial_fixed_lookback_engine_hpp

#include <ql/instruments/lookbackoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>

namespace QuantLib {

    //! Pricing engine for European continuous partial-time fixed-strike lookback options
    /*! Formula from "Option Pricing Formulas, Second Edition",
        E.G. Haug, 2006, p.148

        \ingroup lookbackengines

        \test returned values are verified against results from literature
    */
    class AnalyticContinuousPartialFixedLookbackEngine
        : public ContinuousPartialFixedLookbackOption::engine {
      public:
        AnalyticContinuousPartialFixedLookbackEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        CumulativeNormalDistribution f_;
        // helper methods
        Real underlying() const;
        Real strike() const;
        Time residualTime() const;
        Volatility volatility() const;
        Time lookbackPeriodStartTime() const;
        Real stdDeviation() const;
        Rate riskFreeRate() const;
        DiscountFactor riskFreeDiscount() const;
        Rate dividendYield() const;
        DiscountFactor dividendDiscount() const;
        Real A(Real eta) const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="103">
    <source>lookback/analyticcontinuouspartialfloatinglookback.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2014 Francois Botha

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticcontinuouspartialfloatinglookback.hpp
    \brief Analytic engine for continuous floating-strike lookback
*/

#ifndef quantlib_analytic_continuous_partial_floating_lookback_engine_hpp
#define quantlib_analytic_continuous_partial_floating_lookback_engine_hpp

#include <ql/instruments/lookbackoption.hpp>
#include <ql/pricingengines/lookback/analyticcontinuousfloatinglookback.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>


namespace QuantLib {

    //! Pricing engine for European continuous partial-time floating-strike lookback option
    /*! Formula from "Option Pricing Formulas, Second Edition",
        E.G. Haug, 2006, p.146

        \ingroup lookbackengines

        \test returned values verified against results from literature
    */
    class AnalyticContinuousPartialFloatingLookbackEngine
        : public ContinuousPartialFloatingLookbackOption::engine {
      public:
        AnalyticContinuousPartialFloatingLookbackEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        CumulativeNormalDistribution f_;
        // helper methods
        Real underlying() const;
        Time residualTime() const;
        Volatility volatility() const;
        Real minmax() const;
        Real lambda() const;
        Time lookbackPeriodEndTime() const;
        Real stdDeviation() const;
        Rate riskFreeRate() const;
        DiscountFactor riskFreeDiscount() const;
        Rate dividendYield() const;
        DiscountFactor dividendDiscount() const;
        Real A(Real eta) const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="104">
    <source>lookback/mclookbackengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Lew Wei Hao

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mclookbackengine.hpp
    \brief Monte Carlo lookback fixed engines
*/

#ifndef quantlib_mc_lookback_engines_hpp
#define quantlib_mc_lookback_engines_hpp

#include <ql/exercise.hpp>
#include <ql/instruments/lookbackoption.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    //! Monte Carlo lookback-option engine
    template <class I, class RNG = PseudoRandom, class S = Statistics>
    class MCLookbackEngine : public I::engine,
                             public McSimulation<SingleVariate,RNG,S> {
      public:
        typedef typename McSimulation<SingleVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef typename McSimulation<SingleVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        // constructor
        MCLookbackEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                         Size timeSteps,
                         Size timeStepsPerYear,
                         bool brownianBridge,
                         bool antithetic,
                         Size requiredSamples,
                         Real requiredTolerance,
                         Size maxSamples,
                         BigNatural seed);
        void calculate() const override {
            Real spot = process_->x0();
            QL_REQUIRE(spot > 0.0, "negative or null underlying given");
            McSimulation<SingleVariate,RNG,S>::calculate(requiredTolerance_,
                                                         requiredSamples_,
                                                         maxSamples_);
            this->results_.value = this->mcModel_->sampleAccumulator().mean();
            if constexpr (RNG::allowsErrorEstimate)
                this->results_.errorEstimate =
                    this->mcModel_->sampleAccumulator().errorEstimate();
        }

      protected:
        // McSimulation implementation
        TimeGrid timeGrid() const override;
        ext::shared_ptr<path_generator_type> pathGenerator() const override {
            TimeGrid grid = timeGrid();
            typename RNG::rsg_type gen =
                RNG::make_sequence_generator(grid.size()-1,seed_);
            return ext::shared_ptr<path_generator_type>(
                         new path_generator_type(process_,
                                                 grid, gen, brownianBridge_));
        }
        ext::shared_ptr<path_pricer_type> pathPricer() const override;
        // data members
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Size timeSteps_, timeStepsPerYear_;
        Size requiredSamples_, maxSamples_;
        Real requiredTolerance_;
        bool antithetic_;
        bool brownianBridge_;
        BigNatural seed_;
    };


    //! Monte Carlo lookback-option engine factory
    template <class I, class RNG = PseudoRandom, class S = Statistics>
    class MakeMCLookbackEngine {
      public:
        explicit MakeMCLookbackEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);
        // named parameters
        MakeMCLookbackEngine& withSteps(Size steps);
        MakeMCLookbackEngine& withStepsPerYear(Size steps);
        MakeMCLookbackEngine& withBrownianBridge(bool b = true);
        MakeMCLookbackEngine& withAntitheticVariate(bool b = true);
        MakeMCLookbackEngine& withSamples(Size samples);
        MakeMCLookbackEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCLookbackEngine& withMaxSamples(Size samples);
        MakeMCLookbackEngine& withSeed(BigNatural seed);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        bool brownianBridge_ = false, antithetic_ = false;
        Size steps_, stepsPerYear_, samples_, maxSamples_;
        Real tolerance_;
        BigNatural seed_ = 0;
    };


    // template definitions

    template <class I, class RNG, class S>
    inline MCLookbackEngine<I, RNG, S>::MCLookbackEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Size timeSteps,
        Size timeStepsPerYear,
        bool brownianBridge,
        bool antitheticVariate,
        Size requiredSamples,
        Real requiredTolerance,
        Size maxSamples,
        BigNatural seed)
    : McSimulation<SingleVariate, RNG, S>(antitheticVariate, false), process_(std::move(process)),
      timeSteps_(timeSteps), timeStepsPerYear_(timeStepsPerYear), requiredSamples_(requiredSamples),
      maxSamples_(maxSamples), requiredTolerance_(requiredTolerance),
      brownianBridge_(brownianBridge), seed_(seed) {
        QL_REQUIRE(timeSteps != Null<Size>() ||
                   timeStepsPerYear != Null<Size>(),
                   "no time steps provided");
        QL_REQUIRE(timeSteps == Null<Size>() ||
                   timeStepsPerYear == Null<Size>(),
                   "both time steps and time steps per year were provided");
        QL_REQUIRE(timeSteps != 0,
                   "timeSteps must be positive, " << timeSteps <<
                   " not allowed");
        QL_REQUIRE(timeStepsPerYear != 0,
                   "timeStepsPerYear must be positive, " << timeStepsPerYear <<
                   " not allowed");
        this->registerWith(process_);
    }


    template <class I, class RNG, class S>
    inline TimeGrid MCLookbackEngine<I,RNG,S>::timeGrid() const {

        Time residualTime = process_->time(this->arguments_.exercise->lastDate());
        if (timeSteps_ != Null<Size>()) {
            return TimeGrid(residualTime, timeSteps_);
        } else if (timeStepsPerYear_ != Null<Size>()) {
            Size steps = static_cast<Size>(timeStepsPerYear_*residualTime);
            return TimeGrid(residualTime, std::max<Size>(steps, 1));
        } else {
            QL_FAIL("time steps not specified");
        }
    }


    namespace detail {

        // these functions are specialized for each of the instruments.

        ext::shared_ptr<PathPricer<Path> >
        mc_lookback_path_pricer(
               const ContinuousFixedLookbackOption::arguments& args,
               const GeneralizedBlackScholesProcess& process,
               DiscountFactor discount);

        ext::shared_ptr<PathPricer<Path> >
        mc_lookback_path_pricer(
               const ContinuousPartialFixedLookbackOption::arguments& args,
               const GeneralizedBlackScholesProcess& process,
               DiscountFactor discount);

        ext::shared_ptr<PathPricer<Path> >
        mc_lookback_path_pricer(
               const ContinuousFloatingLookbackOption::arguments& args,
               const GeneralizedBlackScholesProcess& process,
               DiscountFactor discount);

        ext::shared_ptr<PathPricer<Path> >
        mc_lookback_path_pricer(
               const ContinuousPartialFloatingLookbackOption::arguments& args,
               const GeneralizedBlackScholesProcess& process,
               DiscountFactor discount);

    }


    template <class I, class RNG, class S>
    inline ext::shared_ptr<typename MCLookbackEngine<I,RNG,S>::path_pricer_type>
    MCLookbackEngine<I,RNG,S>::pathPricer() const {
        TimeGrid grid = this->timeGrid();
        DiscountFactor discount = this->process_->riskFreeRate()->discount(grid.back());

        return detail::mc_lookback_path_pricer(this->arguments_,
                                               *(this->process_),
                                               discount);
    }


    template <class I, class RNG, class S>
    inline MakeMCLookbackEngine<I, RNG, S>::MakeMCLookbackEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)), steps_(Null<Size>()), stepsPerYear_(Null<Size>()),
      samples_(Null<Size>()), maxSamples_(Null<Size>()), tolerance_(Null<Real>()) {}

    template <class I, class RNG, class S>
    inline MakeMCLookbackEngine<I,RNG,S>&
    MakeMCLookbackEngine<I,RNG,S>::withSteps(Size steps) {
        steps_ = steps;
        return *this;
    }

    template <class I, class RNG, class S>
    inline MakeMCLookbackEngine<I,RNG,S>&
    MakeMCLookbackEngine<I,RNG,S>::withStepsPerYear(Size steps) {
        stepsPerYear_ = steps;
        return *this;
    }

    template <class I, class RNG, class S>
    inline MakeMCLookbackEngine<I,RNG,S>&
    MakeMCLookbackEngine<I,RNG,S>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class I, class RNG, class S>
    inline MakeMCLookbackEngine<I,RNG,S>&
    MakeMCLookbackEngine<I,RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class I, class RNG, class S>
    inline MakeMCLookbackEngine<I,RNG,S>&
    MakeMCLookbackEngine<I,RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class I, class RNG, class S>
    inline MakeMCLookbackEngine<I,RNG,S>&
    MakeMCLookbackEngine<I,RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class I, class RNG, class S>
    inline MakeMCLookbackEngine<I,RNG,S>&
    MakeMCLookbackEngine<I,RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class I, class RNG, class S>
    inline MakeMCLookbackEngine<I,RNG,S>&
    MakeMCLookbackEngine<I,RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class I, class RNG, class S>
    inline MakeMCLookbackEngine<I,RNG,S>::operator ext::shared_ptr<PricingEngine>() const {
        QL_REQUIRE(steps_ != Null<Size>() || stepsPerYear_ != Null<Size>(),
                   "number of steps not given");
        QL_REQUIRE(steps_ == Null<Size>() || stepsPerYear_ == Null<Size>(),
                   "number of steps overspecified");

        return ext::shared_ptr<PricingEngine>(
            new MCLookbackEngine<I,RNG,S>(process_,
                                          steps_,
                                          stepsPerYear_,
                                          brownianBridge_,
                                          antithetic_,
                                          samples_,
                                          tolerance_,
                                          maxSamples_,
                                          seed_));
    }

}

#endif
]]></document_content>
  </document>
  <document index="105">
    <source>mclongstaffschwartzengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Klaus Spanderen
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2015, 2016 Peter Caspers
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mclongstaffschwartzengine.hpp
    \brief Longstaff Schwartz Monte Carlo engine for early exercise options
*/

#ifndef quantlib_mc_longstaff_schwartz_engine_hpp
#define quantlib_mc_longstaff_schwartz_engine_hpp

#include <ql/exercise.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <ql/methods/montecarlo/longstaffschwartzpathpricer.hpp>
#include <ql/optional.hpp>

namespace QuantLib {

    //! Longstaff-Schwarz Monte Carlo engine for early exercise options
    /*! References:

        Francis Longstaff, Eduardo Schwartz, 2001. Valuing American Options
        by Simulation: A Simple Least-Squares Approach, The Review of
        Financial Studies, Volume 14, No. 1, 113-147

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature
    */
    template <class GenericEngine, template <class> class MC,
              class RNG, class S = Statistics, class RNG_Calibration = RNG>
    class MCLongstaffSchwartzEngine : public GenericEngine,
                                      public McSimulation<MC,RNG,S> {
      public:
        typedef typename MC<RNG>::path_type path_type;
        typedef typename McSimulation<MC,RNG,S>::stats_type
            stats_type;
        typedef typename McSimulation<MC,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename McSimulation<MC,RNG,S>::path_generator_type
            path_generator_type;
        typedef
            typename McSimulation<MC, RNG_Calibration, S>::path_generator_type
                path_generator_type_calibration;

        /*! If the parameters brownianBridge and antitheticVariate are
          not given they are chosen to be identical to the respective
          parameters for pricing; the seed for calibration is chosen
          to be zero if the pricing seed is zero and otherwise as the
          pricing seed plus some offset to avoid identical paths in
          calibration and pricing; note however that this has no effect
          for low discrepancy RNGs usually, it is therefore recommended
          to use pseudo random generators for the calibration phase always
          (and possibly quasi monte carlo in the subsequent pricing). */
        MCLongstaffSchwartzEngine(ext::shared_ptr<StochasticProcess> process,
                                  Size timeSteps,
                                  Size timeStepsPerYear,
                                  bool brownianBridge,
                                  bool antitheticVariate,
                                  bool controlVariate,
                                  Size requiredSamples,
                                  Real requiredTolerance,
                                  Size maxSamples,
                                  BigNatural seed,
                                  Size nCalibrationSamples = Null<Size>(),
                                  ext::optional<bool> brownianBridgeCalibration = ext::nullopt,
                                  ext::optional<bool> antitheticVariateCalibration = ext::nullopt,
                                  BigNatural seedCalibration = Null<Size>());

        void calculate() const override;

      protected:
        virtual ext::shared_ptr<LongstaffSchwartzPathPricer<path_type> >
                                                   lsmPathPricer() const = 0;

        TimeGrid timeGrid() const override;
        ext::shared_ptr<path_pricer_type> pathPricer() const override;
        ext::shared_ptr<path_generator_type> pathGenerator() const override;

        ext::shared_ptr<StochasticProcess> process_;
        const Size timeSteps_;
        const Size timeStepsPerYear_;
        const bool brownianBridge_;
        const Size requiredSamples_;
        const Real requiredTolerance_;
        const Size maxSamples_;
        const BigNatural seed_;
        const Size nCalibrationSamples_;
        const bool brownianBridgeCalibration_;
        const bool antitheticVariateCalibration_;
        const BigNatural seedCalibration_;

        mutable ext::shared_ptr<LongstaffSchwartzPathPricer<path_type> >
            pathPricer_;
        mutable ext::shared_ptr<MonteCarloModel<MC, RNG_Calibration, S> >
            mcModelCalibration_;
    };

    template <class GenericEngine,
              template <class>
              class MC,
              class RNG,
              class S,
              class RNG_Calibration>
    inline MCLongstaffSchwartzEngine<GenericEngine, MC, RNG, S, RNG_Calibration>::
        MCLongstaffSchwartzEngine(ext::shared_ptr<StochasticProcess> process,
                                  Size timeSteps,
                                  Size timeStepsPerYear,
                                  bool brownianBridge,
                                  bool antitheticVariate,
                                  bool controlVariate,
                                  Size requiredSamples,
                                  Real requiredTolerance,
                                  Size maxSamples,
                                  BigNatural seed,
                                  Size nCalibrationSamples,
                                  ext::optional<bool> brownianBridgeCalibration,
                                  ext::optional<bool> antitheticVariateCalibration,
                                  BigNatural seedCalibration)
    : McSimulation<MC, RNG, S>(antitheticVariate, controlVariate), process_(std::move(process)),
      timeSteps_(timeSteps), timeStepsPerYear_(timeStepsPerYear), brownianBridge_(brownianBridge),
      requiredSamples_(requiredSamples), requiredTolerance_(requiredTolerance),
      maxSamples_(maxSamples), seed_(seed),
      nCalibrationSamples_((nCalibrationSamples == Null<Size>()) ? 2048 : nCalibrationSamples),
      // NOLINTNEXTLINE(readability-implicit-bool-conversion)
      brownianBridgeCalibration_(brownianBridgeCalibration ? *brownianBridgeCalibration :
                                                             brownianBridge),
      antitheticVariateCalibration_(
          // NOLINTNEXTLINE(readability-implicit-bool-conversion)
          antitheticVariateCalibration ? *antitheticVariateCalibration : antitheticVariate),
      seedCalibration_(seedCalibration != Null<Real>() ? seedCalibration :
                                                         (seed == 0 ? 0 : seed + 1768237423L)) {
        QL_REQUIRE(timeSteps != Null<Size>() ||
                   timeStepsPerYear != Null<Size>(),
                   "no time steps provided");
        QL_REQUIRE(timeSteps == Null<Size>() ||
                   timeStepsPerYear == Null<Size>(),
                   "both time steps and time steps per year were provided");
        QL_REQUIRE(timeSteps != 0,
                   "timeSteps must be positive, " << timeSteps <<
                   " not allowed");
        QL_REQUIRE(timeStepsPerYear != 0,
                   "timeStepsPerYear must be positive, " << timeStepsPerYear <<
                   " not allowed");
        this->registerWith(process_);
    }

    template <class GenericEngine, template <class> class MC, class RNG,
              class S, class RNG_Calibration>
    inline ext::shared_ptr<typename MCLongstaffSchwartzEngine<
        GenericEngine, MC, RNG, S, RNG_Calibration>::path_pricer_type>
    MCLongstaffSchwartzEngine<GenericEngine, MC, RNG, S,
                              RNG_Calibration>::pathPricer() const {

        QL_REQUIRE(pathPricer_, "path pricer unknown");
        return pathPricer_;
    }

    template <class GenericEngine, template <class> class MC, class RNG,
              class S, class RNG_Calibration>
    inline void MCLongstaffSchwartzEngine<GenericEngine, MC, RNG, S,
                                          RNG_Calibration>::calculate() const {
        // calibration
        pathPricer_ = this->lsmPathPricer();
        Size dimensions = process_->factors();
        TimeGrid grid = this->timeGrid();
        typename RNG_Calibration::rsg_type generator =
            RNG_Calibration::make_sequence_generator(
                dimensions * (grid.size() - 1), seedCalibration_);
        ext::shared_ptr<path_generator_type_calibration>
            pathGeneratorCalibration =
                ext::make_shared<path_generator_type_calibration>(
                    process_, grid, generator, brownianBridgeCalibration_);
        mcModelCalibration_ =
            ext::shared_ptr<MonteCarloModel<MC, RNG_Calibration, S> >(
                new MonteCarloModel<MC, RNG_Calibration, S>(
                    pathGeneratorCalibration, pathPricer_, stats_type(),
                    this->antitheticVariateCalibration_));

        mcModelCalibration_->addSamples(nCalibrationSamples_);
        pathPricer_->calibrate();
        // pricing
        McSimulation<MC,RNG,S>::calculate(requiredTolerance_,
                                          requiredSamples_,
                                          maxSamples_);
        this->results_.value = this->mcModel_->sampleAccumulator().mean();
        this->results_.additionalResults["exerciseProbability"] =
            this->pathPricer_->exerciseProbability();
        if constexpr (RNG::allowsErrorEstimate) {
            this->results_.errorEstimate =
                this->mcModel_->sampleAccumulator().errorEstimate();
        }
    }

    template <class GenericEngine, template <class> class MC, class RNG,
              class S, class RNG_Calibration>
    inline TimeGrid
    MCLongstaffSchwartzEngine<GenericEngine, MC, RNG, S,
                              RNG_Calibration>::timeGrid() const {
        std::vector<Time> requiredTimes;
        if (this->arguments_.exercise->type() == Exercise::American) {
            Date lastExerciseDate = this->arguments_.exercise->lastDate();
            requiredTimes.push_back(process_->time(lastExerciseDate));
        } else {
            for (Size i = 0; i < this->arguments_.exercise->dates().size();
                 ++i) {
                Time t = process_->time(this->arguments_.exercise->date(i));
                if (t > 0.0)
                    requiredTimes.push_back(t);
            }
        }
        if (this->timeSteps_ != Null<Size>()) {
            return TimeGrid(requiredTimes.begin(), requiredTimes.end(),
                            this->timeSteps_);
        } else if (this->timeStepsPerYear_ != Null<Size>()) {
            Size steps = static_cast<Size>(this->timeStepsPerYear_ *
                                           requiredTimes.back());
            return TimeGrid(requiredTimes.begin(), requiredTimes.end(),
                            std::max<Size>(steps, 1));
        } else {
            QL_FAIL("time steps not specified");
        }
    }

    template <class GenericEngine, template <class> class MC, class RNG,
              class S, class RNG_Calibration>
    inline ext::shared_ptr<typename MCLongstaffSchwartzEngine<
        GenericEngine, MC, RNG, S, RNG_Calibration>::path_generator_type>
    MCLongstaffSchwartzEngine<GenericEngine, MC, RNG, S,
                              RNG_Calibration>::pathGenerator() const {

        Size dimensions = process_->factors();
        TimeGrid grid = this->timeGrid();
        typename RNG::rsg_type generator =
            RNG::make_sequence_generator(dimensions*(grid.size()-1),seed_);
        return ext::shared_ptr<path_generator_type>(
                   new path_generator_type(process_,
                                           grid, generator, brownianBridge_));
    }

}


#endif
]]></document_content>
  </document>
  <document index="106">
    <source>mcsimulation.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mcsimulation.hpp
    \brief framework for Monte Carlo engines
*/

#ifndef quantlib_montecarlo_engine_hpp
#define quantlib_montecarlo_engine_hpp

#include <ql/methods/montecarlo/montecarlomodel.hpp>

namespace QuantLib {

    //! base class for Monte Carlo engines
    /*! Eventually this class might offer greeks methods.  Deriving a
        class from McSimulation gives an easy way to write a Monte
        Carlo engine.

        See McVanillaEngine as an example.
    */

    template <template <class> class MC, class RNG, class S = Statistics>
    class McSimulation {
      public:
        typedef typename MonteCarloModel<MC,RNG,S>::path_generator_type
            path_generator_type;
        typedef typename MonteCarloModel<MC,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename MonteCarloModel<MC,RNG,S>::stats_type
            stats_type;
        typedef typename MonteCarloModel<MC,RNG,S>::result_type result_type;

        virtual ~McSimulation() = default;
        //! add samples until the required absolute tolerance is reached
        result_type value(Real tolerance,
                          Size maxSamples = QL_MAX_INTEGER,
                          Size minSamples = 1023) const;
        //! simulate a fixed number of samples
        result_type valueWithSamples(Size samples) const;
        //! error estimated using the samples simulated so far
        result_type errorEstimate() const;
        //! access to the sample accumulator for richer statistics
        const stats_type& sampleAccumulator() const;
        //! basic calculate method provided to inherited pricing engines
        void calculate(Real requiredTolerance,
                       Size requiredSamples,
                       Size maxSamples) const;
      protected:
        McSimulation(bool antitheticVariate,
                     bool controlVariate)
        : antitheticVariate_(antitheticVariate),
          controlVariate_(controlVariate) {}
        virtual ext::shared_ptr<path_pricer_type> pathPricer() const = 0;
        virtual ext::shared_ptr<path_generator_type> pathGenerator()
                                                                   const = 0;
        virtual TimeGrid timeGrid() const = 0;
        virtual ext::shared_ptr<path_pricer_type> controlPathPricer() const {
            return ext::shared_ptr<path_pricer_type>();
        }
        virtual ext::shared_ptr<path_generator_type> 
        controlPathGenerator() const {
            return ext::shared_ptr<path_generator_type>();
        }
        virtual ext::shared_ptr<PricingEngine> controlPricingEngine() const {
            return ext::shared_ptr<PricingEngine>();
        }
        virtual result_type controlVariateValue() const {
            return Null<result_type>();
        }
        template <class Sequence>
        static Real maxError(const Sequence& sequence) {
            return *std::max_element(sequence.begin(), sequence.end());
        }
        static Real maxError(Real error) {
            return error;
        }
        
        mutable ext::shared_ptr<MonteCarloModel<MC,RNG,S> > mcModel_;
        bool antitheticVariate_, controlVariate_;
    };


    // inline definitions
    template <template <class> class MC, class RNG, class S>
    inline typename McSimulation<MC,RNG,S>::result_type
        McSimulation<MC,RNG,S>::value(Real tolerance,
                                              Size maxSamples,
                                              Size minSamples) const {
        Size sampleNumber =
            mcModel_->sampleAccumulator().samples();
        if (sampleNumber<minSamples) {
            mcModel_->addSamples(minSamples-sampleNumber);
            sampleNumber = mcModel_->sampleAccumulator().samples();
        }

        Size nextBatch;
        Real order;
        result_type error(mcModel_->sampleAccumulator().errorEstimate());
        while (maxError(error) > tolerance) {
            QL_REQUIRE(sampleNumber<maxSamples,
                       "max number of samples (" << maxSamples
                       << ") reached, while error (" << error
                       << ") is still above tolerance (" << tolerance << ")");

            // conservative estimate of how many samples are needed
            order = maxError(Real(error*error))/tolerance/tolerance;
            nextBatch =
                Size(std::max<Real>(static_cast<Real>(sampleNumber)*order*0.8 - static_cast<Real>(sampleNumber),
                                    static_cast<Real>(minSamples)));

            // do not exceed maxSamples
            nextBatch = std::min(nextBatch, maxSamples-sampleNumber);
            sampleNumber += nextBatch;
            mcModel_->addSamples(nextBatch);
            error = result_type(mcModel_->sampleAccumulator().errorEstimate());
        }

        return result_type(mcModel_->sampleAccumulator().mean());
    }


    template <template <class> class MC, class RNG, class S>
    inline typename McSimulation<MC,RNG,S>::result_type
        McSimulation<MC,RNG,S>::valueWithSamples(Size samples) const {

        Size sampleNumber = mcModel_->sampleAccumulator().samples();

        QL_REQUIRE(samples>=sampleNumber,
                   "number of already simulated samples (" << sampleNumber
                   << ") greater than requested samples (" << samples << ")");

        mcModel_->addSamples(samples-sampleNumber);

        return result_type(mcModel_->sampleAccumulator().mean());
    }


    template <template <class> class MC, class RNG, class S>
    inline void McSimulation<MC,RNG,S>::calculate(Real requiredTolerance,
                                                  Size requiredSamples,
                                                  Size maxSamples) const {

        QL_REQUIRE(requiredTolerance != Null<Real>() ||
                   requiredSamples != Null<Size>(),
                   "neither tolerance nor number of samples set");

        //! Initialize the one-factor Monte Carlo
        if (this->controlVariate_) {

            result_type controlVariateValue = this->controlVariateValue();
            QL_REQUIRE(controlVariateValue != Null<result_type>(),
                       "engine does not provide "
                       "control-variation price");

            ext::shared_ptr<path_pricer_type> controlPP =
                this->controlPathPricer();
            QL_REQUIRE(controlPP,
                       "engine does not provide "
                       "control-variation path pricer");

            ext::shared_ptr<path_generator_type> controlPG = 
                this->controlPathGenerator();

            this->mcModel_ =
                ext::shared_ptr<MonteCarloModel<MC,RNG,S> >(
                    new MonteCarloModel<MC,RNG,S>(
                           pathGenerator(), this->pathPricer(), stats_type(),
                           this->antitheticVariate_, controlPP,
                           controlVariateValue, controlPG));
        } else {
            this->mcModel_ =
                ext::shared_ptr<MonteCarloModel<MC,RNG,S> >(
                    new MonteCarloModel<MC,RNG,S>(
                           pathGenerator(), this->pathPricer(), S(),
                           this->antitheticVariate_));
        }

        if (requiredTolerance != Null<Real>()) {
            if (maxSamples != Null<Size>())
                this->value(requiredTolerance, maxSamples);
            else
                this->value(requiredTolerance);
        } else {
            this->valueWithSamples(requiredSamples);
        }

    }

    template <template <class> class MC, class RNG, class S>
    inline typename McSimulation<MC,RNG,S>::result_type
        McSimulation<MC,RNG,S>::errorEstimate() const {
        return mcModel_->sampleAccumulator().errorEstimate();
    }

    template <template <class> class MC, class RNG, class S>
    inline const typename McSimulation<MC,RNG,S>::stats_type&
    McSimulation<MC,RNG,S>::sampleAccumulator() const {
        return mcModel_->sampleAccumulator();
    }

}


#endif
]]></document_content>
  </document>
  <document index="107">
    <source>quanto/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/pricingengines/quanto/quantoengine.hpp>

]]></document_content>
  </document>
  <document index="108">
    <source>quanto/quantoengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file quantoengine.hpp
    \brief Quanto option engine
*/

#ifndef quantlib_quanto_engine_hpp
#define quantlib_quanto_engine_hpp

#include <ql/instruments/payoffs.hpp>
#include <ql/instruments/quantovanillaoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/termstructures/yield/quantotermstructure.hpp>
#include <utility>

namespace QuantLib {

    //! Quanto engine
    /*! \warning for the time being, this engine will only work with
                 simple Black-Scholes processes (i.e., no Merton.)

        \ingroup quantoengines

        \test
        - the correctness of the returned value is tested by
          reproducing results available in literature.
        - the correctness of the returned greeks is tested by
          reproducing numerical derivatives.
    */
    template <class Instr, class Engine>
    class QuantoEngine :
        public GenericEngine<typename Instr::arguments,
                             QuantoOptionResults<typename Instr::results> > {
      public:
        QuantoEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>,
                     Handle<YieldTermStructure> foreignRiskFreeRate,
                     Handle<BlackVolTermStructure> exchangeRateVolatility,
                     Handle<Quote> correlation);
        void calculate() const override;

      protected:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Handle<YieldTermStructure> foreignRiskFreeRate_;
        Handle<BlackVolTermStructure> exchangeRateVolatility_;
        Handle<Quote> correlation_;
    };


    // template definitions

    template <class Instr, class Engine>
    QuantoEngine<Instr, Engine>::QuantoEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Handle<YieldTermStructure> foreignRiskFreeRate,
        Handle<BlackVolTermStructure> exchangeRateVolatility,
        Handle<Quote> correlation)
    : process_(std::move(process)), foreignRiskFreeRate_(std::move(foreignRiskFreeRate)),
      exchangeRateVolatility_(std::move(exchangeRateVolatility)),
      correlation_(std::move(correlation)) {
        this->registerWith(process_);
        this->registerWith(foreignRiskFreeRate_);
        this->registerWith(exchangeRateVolatility_);
        this->registerWith(correlation_);
    }

    template <class Instr, class Engine>
    void QuantoEngine<Instr,Engine>::calculate() const {

        // ATM exchangeRate level needed here
        Real exchangeRateATMlevel = 1.0;

        // determine strike from payoff
        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(
                this->arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");
        Real strike = payoff->strike();

        Handle<Quote> spot = process_->stateVariable();
        QL_REQUIRE(spot->value() > 0.0, "negative or null underlying");
        Handle<YieldTermStructure> riskFreeRate = process_->riskFreeRate();
        // dividendTS needs modification
        Handle<YieldTermStructure> dividendYield(
            ext::shared_ptr<YieldTermStructure>(
                new QuantoTermStructure(process_->dividendYield(),
                                        process_->riskFreeRate(),
                                        foreignRiskFreeRate_,
                                        process_->blackVolatility(),
                                        strike,
                                        exchangeRateVolatility_,
                                        exchangeRateATMlevel,
                                        correlation_->value())));
        Handle<BlackVolTermStructure> blackVol = process_->blackVolatility();

        ext::shared_ptr<GeneralizedBlackScholesProcess> quantoProcess(
                  new GeneralizedBlackScholesProcess(spot, dividendYield,
                                                     riskFreeRate, blackVol));

        ext::shared_ptr<Engine> originalEngine(new Engine(quantoProcess));
        originalEngine->reset();
        auto* originalArguments =
            dynamic_cast<typename Instr::arguments*>(originalEngine->getArguments());
        QL_REQUIRE(originalArguments, "wrong engine type");

        *originalArguments = this->arguments_;

        originalArguments->validate();
        originalEngine->calculate();

        const auto* originalResults =
            dynamic_cast<const typename Instr::results*>(originalEngine->getResults());
        QL_REQUIRE(originalResults, "wrong engine type");

        this->results_.value = originalResults->value;
        this->results_.delta = originalResults->delta;
        this->results_.gamma = originalResults->gamma;
        this->results_.theta = originalResults->theta;
        if (originalResults->rho != Null<Real>() &&
            originalResults->dividendRho != Null<Real>()) {
            this->results_.rho = originalResults->rho +
                originalResults->dividendRho;
            this->results_.dividendRho = originalResults->dividendRho;
        } else {
            this->results_.rho = this->results_.dividendRho = Null<Real>();
        }
        Volatility exchangeRateFlatVol =
            exchangeRateVolatility_->blackVol(
                                        this->arguments_.exercise->lastDate(),
                                        exchangeRateATMlevel);
        if (originalResults->vega != Null<Real>()
            && originalResults->dividendRho != Null<Real>()) {
            this->results_.vega = originalResults->vega +
                correlation_->value() * exchangeRateFlatVol *
                originalResults->dividendRho;
        } else {
            this->results_.vega = Null<Real>();
        }

        if (originalResults->dividendRho != Null<Real>()) {
            Volatility volatility = process_->blackVolatility()->blackVol(
                                        this->arguments_.exercise->lastDate(),
                                        process_->stateVariable()->value());
            this->results_.qvega = correlation_->value() *
                process_->blackVolatility()->blackVol(
                                        this->arguments_.exercise->lastDate(),
                                        process_->stateVariable()->value()) *
                originalResults->dividendRho;
            this->results_.qrho = - originalResults->dividendRho;
            this->results_.qlambda = exchangeRateFlatVol *
                volatility * originalResults->dividendRho;
        } else {
            this->results_.qvega = this->results_.qrho =
                this->results_.qlambda = Null<Real>();
        }
    }

}


#endif
]]></document_content>
  </document>
  <document index="109">
    <source>swap/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/pricingengines/swap/cvaswapengine.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/pricingengines/swap/discretizedswap.hpp>
#include <ql/pricingengines/swap/treeswapengine.hpp>

]]></document_content>
  </document>
  <document index="110">
    <source>swap/cvaswapengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_cva_swap_engine_hpp
#define quantlib_cva_swap_engine_hpp

#include <ql/handle.hpp>
#include <ql/instruments/vanillaswap.hpp>
#include <ql/termstructures/defaulttermstructure.hpp>

namespace QuantLib {

    class YieldTermStructure;
    class Quote;

  /*! Bilateral (CVA and DVA) default adjusted vanilla swap pricing
    engine. Collateral is not considered. No wrong way risk is 
    considered (rates and counterparty default are uncorrelated).
    Based on:
    Sorensen,  E.H.  and  Bollier,  T.F.,  Pricing  swap  default 
    risk. Financial Analysts Journal, 1994, 50, 23–33
    Also see sect. II-5 in: Risk Neutral Pricing of Counterparty Risk
    D. Brigo, M. Masetti, 2004
    or in sections 3 and 4 of "A Formula for Interest Rate Swaps 
      Valuation under Counterparty Risk in presence of Netting Agreements"
    D. Brigo and M. Masetti; May 4, 2005

    to do: Compute fair rate through iteration instead of the 
    current approximation .
    to do: write Issuer based constructors (event type)
    to do: Check consistency between option engine discount and the one given
   */
  class CounterpartyAdjSwapEngine : public VanillaSwap::engine {
    public:
      //! \name Constructors
      //@{
      //! 
      /*! Creates the engine from an arbitrary swaption engine.
        If the investor default model is not given a default 
        free one is assumed.
        @param discountCurve Used in pricing.
        @param swaptionEngine Determines the volatility and thus the 
        exposure model.
        @param ctptyDTS Counterparty default curve.
        @param ctptyRecoveryRate Counterparty recovey rate.
        @param invstDTS Investor (swap holder) default curve.
        @param invstRecoveryRate Investor recovery rate.
       */
      CounterpartyAdjSwapEngine(
          const Handle<YieldTermStructure>& discountCurve,
          const Handle<PricingEngine>& swaptionEngine,
          const Handle<DefaultProbabilityTermStructure>& ctptyDTS,
          Real ctptyRecoveryRate,
          const Handle<DefaultProbabilityTermStructure>& invstDTS =
              Handle<DefaultProbabilityTermStructure>(),
          Real invstRecoveryRate = 0.999);
      /*! Creates an engine with a black volatility model for the 
        exposure.
        If the investor default model is not given a default 
        free one is assumed.
        @param discountCurve Used in pricing.
        @param blackVol Black volatility used in the exposure model.
        @param ctptyDTS Counterparty default curve.
        @param ctptyRecoveryRate Counterparty recovey rate.
        @param invstDTS Investor (swap holder) default curve.
        @param invstRecoveryRate Investor recovery rate.
       */
      CounterpartyAdjSwapEngine(const Handle<YieldTermStructure>& discountCurve,
                                Volatility blackVol,
                                const Handle<DefaultProbabilityTermStructure>& ctptyDTS,
                                Real ctptyRecoveryRate,
                                const Handle<DefaultProbabilityTermStructure>& invstDTS =
                                    Handle<DefaultProbabilityTermStructure>(),
                                Real invstRecoveryRate = 0.999);
      /*! Creates an engine with a black volatility model for the 
        exposure. The volatility is given as a quote.
        If the investor default model is not given a default 
        free one is assumed.
        @param discountCurve Used in pricing.
        @param blackVol Black volatility used in the exposure model.
        @param ctptyDTS Counterparty default curve.
        @param ctptyRecoveryRate Counterparty recovey rate.
        @param invstDTS Investor (swap holder) default curve.
        @param invstRecoveryRate Investor recovery rate.
      */
      CounterpartyAdjSwapEngine(
          const Handle<YieldTermStructure>& discountCurve,
          const Handle<Quote>& blackVol,
          const Handle<DefaultProbabilityTermStructure>& ctptyDTS,
          Real ctptyRecoveryRate,
          const Handle<DefaultProbabilityTermStructure>& invstDTS =
              Handle<DefaultProbabilityTermStructure>(),
          Real invstRecoveryRate = 0.999);
      //@}
      void calculate() const override;

    private:
      Handle<PricingEngine> baseSwapEngine_;
      Handle<PricingEngine> swaptionletEngine_;
      Handle<YieldTermStructure> discountCurve_;
      Handle<DefaultProbabilityTermStructure> defaultTS_;	  
      Real ctptyRecoveryRate_;
      Handle<DefaultProbabilityTermStructure> invstDTS_;	  
      Real invstRecoveryRate_;
  };

}

#endif
]]></document_content>
  </document>
  <document index="111">
    <source>swap/discountingswapengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 StatPro Italia srl
 Copyright (C) 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file discountingswapengine.hpp
    \brief discounting swap engine
*/

#ifndef quantlib_discounting_swap_engine_hpp
#define quantlib_discounting_swap_engine_hpp

#include <ql/instruments/swap.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/handle.hpp>
#include <ql/optional.hpp>

namespace QuantLib {

    //! Discounting engine for swaps
    /*! This engine discounts future swap cashflows to the reference
        date of the discount curve.
    */
    class DiscountingSwapEngine : public Swap::engine {
      public:
        DiscountingSwapEngine(
            Handle<YieldTermStructure> discountCurve = Handle<YieldTermStructure>(),
            const ext::optional<bool>& includeSettlementDateFlows = ext::nullopt,
            Date settlementDate = Date(),
            Date npvDate = Date());
        void calculate() const override;
        Handle<YieldTermStructure> discountCurve() const {
            return discountCurve_;
        }
      private:
        Handle<YieldTermStructure> discountCurve_;
        ext::optional<bool> includeSettlementDateFlows_;
        Date settlementDate_, npvDate_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="112">
    <source>swap/discretizedswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2007 StatPro Italia srl
 Copyright (C) 2022 Ralf Konrad Eckel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file discretizedswap.hpp
    \brief Discretized swap class
*/

#ifndef quantlib_discretized_swap_hpp
#define quantlib_discretized_swap_hpp

#include <ql/discretizedasset.hpp>
#include <ql/instruments/vanillaswap.hpp>

namespace QuantLib {

    class DiscretizedSwap : public DiscretizedAsset {
      public:
        DiscretizedSwap(const VanillaSwap::arguments& args,
                        const Date& referenceDate,
                        const DayCounter& dayCounter);

        DiscretizedSwap(const VanillaSwap::arguments& args,
                        const Date& referenceDate,
                        const DayCounter& dayCounter,
                        std::vector<CouponAdjustment> fixedCouponAdjustments,
                        std::vector<CouponAdjustment> floatingCouponAdjustments);
        void reset(Size size) override;
        std::vector<Time> mandatoryTimes() const override;

      protected:
        void preAdjustValuesImpl() override;
        void postAdjustValuesImpl() override;

      private:
        VanillaSwap::arguments arguments_;
        std::vector<Time> fixedResetTimes_;
        std::vector<Time> fixedPayTimes_;
        std::vector<CouponAdjustment> fixedCouponAdjustments_;
        std::vector<bool> fixedResetTimeIsInPast_;
        std::vector<Time> floatingResetTimes_;
        std::vector<Time> floatingPayTimes_;
        std::vector<CouponAdjustment> floatingCouponAdjustments_;
        std::vector<bool> floatingResetTimeIsInPast_;

        void addFixedCoupon(Size i);
        void addFloatingCoupon(Size i);
    };

}


#endif
]]></document_content>
  </document>
  <document index="113">
    <source>swap/treeswapengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2005, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file treeswapengine.hpp
    \brief Numerical lattice engine for swaps
*/

#ifndef quantlib_tree_swap_engine_hpp
#define quantlib_tree_swap_engine_hpp

#include <ql/instruments/vanillaswap.hpp>
#include <ql/pricingengines/latticeshortratemodelengine.hpp>

namespace QuantLib {

    //! Numerical lattice engine for simple swaps
    /*! \test calculations are checked against known good results
    */
    class TreeVanillaSwapEngine
    : public LatticeShortRateModelEngine<VanillaSwap::arguments,
                                         VanillaSwap::results> {
      public:
        /*! \name Constructors
            \note the term structure is only needed when the short-rate
                  model cannot provide one itself.
        */
        //@{
        TreeVanillaSwapEngine(
            const ext::shared_ptr<ShortRateModel>&,
            Size timeSteps,
            Handle<YieldTermStructure> termStructure = Handle<YieldTermStructure>());
        TreeVanillaSwapEngine(
            const ext::shared_ptr<ShortRateModel>&,
            const TimeGrid& timeGrid,
            Handle<YieldTermStructure> termStructure = Handle<YieldTermStructure>());
        //@}
        void calculate() const override;

      private:
        Handle<YieldTermStructure> termStructure_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="114">
    <source>swaption/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/pricingengines/swaption/basketgeneratingengine.hpp>
#include <ql/pricingengines/swaption/blackswaptionengine.hpp>
#include <ql/pricingengines/swaption/discretizedswaption.hpp>
#include <ql/pricingengines/swaption/gaussian1dfloatfloatswaptionengine.hpp>
#include <ql/pricingengines/swaption/gaussian1djamshidianswaptionengine.hpp>
#include <ql/pricingengines/swaption/gaussian1dnonstandardswaptionengine.hpp>
#include <ql/pricingengines/swaption/gaussian1dswaptionengine.hpp>
#include <ql/pricingengines/swaption/g2swaptionengine.hpp>
#include <ql/pricingengines/swaption/jamshidianswaptionengine.hpp>
#include <ql/pricingengines/swaption/fdg2swaptionengine.hpp>
#include <ql/pricingengines/swaption/fdhullwhiteswaptionengine.hpp>
#include <ql/pricingengines/swaption/treeswaptionengine.hpp>

]]></document_content>
  </document>
  <document index="115">
    <source>swaption/basketgeneratingengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file basketgeneratingengine.hpp
    \brief base class for pricing engines capable of
           generating a calibration basket
*/

#ifndef quantlib_basketgeneratingengine_hpp
#define quantlib_basketgeneratingengine_hpp

#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/instruments/vanillaswap.hpp>
#include <ql/math/optimization/costfunction.hpp>
#include <ql/models/shortrate/onefactormodels/gaussian1dmodel.hpp>
#include <ql/qldefines.hpp>
#include <ql/termstructures/volatility/swaption/swaptionvolstructure.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    /* \warning the generated calibrating swaptions have a strike floored at
       0.1bp (minus lognormal shift, if applicable), this is not true for atm
       swaptions where the strike is generated in the swaption helper.

       \warning the standardSwapBase index should have associated forward and
       discount curves. These curves are used for setup of the swaption helper.
       This means that the market price of the calibration instrument is calculated
       using these curves. Therefore the model price must be calculated using the
       same curves, otherwise the calibration gets incosistent, i.e. the pricing
       engine used for model calibration has to be capable of using the same curves
       as associated to the index. Also the volatility structure passed to construct
       the calibration helper should use curves that are consistent with the model
       calibration curve setup. Finally the discountCurve given in the constructor
       should be the same curve as the discounting curve of the swapIndex used to
       determine the calibration basket. */

    class BasketGeneratingEngine {

      public:

        typedef enum CalibrationBasketType {
            Naive,
            MaturityStrikeByDeltaGamma
        } CalibrationBasketType;

        virtual ~BasketGeneratingEngine() = default;

        std::vector<ext::shared_ptr<BlackCalibrationHelper>>
        calibrationBasket(const ext::shared_ptr<Exercise>& exercise,
                          const ext::shared_ptr<SwapIndex>& standardSwapBase,
                          const ext::shared_ptr<SwaptionVolatilityStructure>& swaptionVolatility,
                          CalibrationBasketType basketType = MaturityStrikeByDeltaGamma) const;

      protected:
        BasketGeneratingEngine(const ext::shared_ptr<Gaussian1dModel>& model,
                               Handle<Quote> oas,
                               Handle<YieldTermStructure> discountCurve)
        : onefactormodel_(model), oas_(std::move(oas)), discountCurve_(std::move(discountCurve)) {}

        BasketGeneratingEngine(Handle<Gaussian1dModel> model,
                               Handle<Quote> oas,
                               Handle<YieldTermStructure> discountCurve)
        : onefactormodel_(std::move(model)), oas_(std::move(oas)),
          discountCurve_(std::move(discountCurve)) {}

        virtual Real underlyingNpv(const Date& expiry, Real y) const = 0;

        virtual Swap::Type underlyingType() const = 0;

        virtual const Date underlyingLastDate() const = 0;

        virtual const Array initialGuess(const Date &expiry) const = 0; // return (nominal,
                                                                        // maturity, rate)

      private:

        const Handle<Gaussian1dModel> onefactormodel_;
        const Handle<Quote> oas_;
        const Handle<YieldTermStructure> discountCurve_;

        class MatchHelper : public CostFunction {
          public:
            MatchHelper(const Swap::Type type,
                        const Real npv,
                        const Real delta,
                        const Real gamma,
                        ext::shared_ptr<Gaussian1dModel> model,
                        ext::shared_ptr<SwapIndex> indexBase,
                        const Date& expiry,
                        const Real maxMaturity,
                        const Real h)
            : type_(type), mdl_(std::move(model)), indexBase_(std::move(indexBase)),
              expiry_(expiry), maxMaturity_(maxMaturity), npv_(npv), delta_(delta), gamma_(gamma),
              h_(h) {}

            Real NPV(const ext::shared_ptr<VanillaSwap>& swap,
                     Real fixedRate,
                     Real nominal,
                     Real y,
                     int type) const {
                Real npv = 0.0;
                for (const auto& i : swap->fixedLeg()) {
                    ext::shared_ptr<FixedRateCoupon> c =
                        ext::dynamic_pointer_cast<FixedRateCoupon>(i);
                    npv -=
                        fixedRate * c->accrualPeriod() * nominal *
                        mdl_->zerobond(c->date(), expiry_, y,
                                       indexBase_->discountingTermStructure());
                }
                for (const auto& i : swap->floatingLeg()) {
                    ext::shared_ptr<IborCoupon> c = ext::dynamic_pointer_cast<IborCoupon>(i);
                    npv +=
                        mdl_->forwardRate(c->fixingDate(), expiry_, y,
                                          c->iborIndex()) *
                        c->accrualPeriod() * nominal *
                        mdl_->zerobond(c->date(), expiry_, y,
                                       indexBase_->discountingTermStructure());
                }
                return (Real)type * npv;
            }

            Real value(const Array& v) const override {
                Array vals = values(v);
                Real res = 0.0;
                for (Real val : vals) {
                    res += val * val;
                }
                return std::sqrt(res / vals.size());
            }

            Array values(const Array& v) const override {
                // transformations
                int type = type_; // start with same type as non standard
                                  // underlying (1 means payer, -1 receiver)
                Real nominal = std::fabs(v[0]);
                if (v[0] < 0.0)
                    type *= -1;
                Real maturity = std::min(std::fabs(v[1]), maxMaturity_);

                Real fixedRate = v[2]; // allow for negative rates explicitly
                // (though it might not be reasonable for calibration depending
                // on the model to calibrate and the market instrument quotation)
                Size years = (Size)std::floor(maturity);
                maturity -= (Real)years;
                maturity *= 12.0;
                Size months = (Size)std::floor(maturity);
                Real alpha = 1.0 - (maturity - (Real)months);
                if (years == 0 && months == 0) {
                    months = 1;  // ensure a maturity of at least one month ...
                    alpha = 1.0; // ... but in this case only look at the lower
                                 // maturity swap
                }
                // maturity -= (Real)months; maturity *= 365.25;
                // Size days = (Size)std::floor(maturity);
                // Real alpha = 1.0-(maturity-(Real)days);
                // generate swap
                Period lowerPeriod =
                    years * Years + months * Months;           //+days*Days;
                Period upperPeriod = lowerPeriod + 1 * Months; // 1*Days;
                ext::shared_ptr<SwapIndex> tmpIndexLower, tmpIndexUpper;
                tmpIndexLower = indexBase_->clone(lowerPeriod);
                tmpIndexUpper = indexBase_->clone(upperPeriod);
                ext::shared_ptr<VanillaSwap> swapLower =
                    tmpIndexLower->underlyingSwap(expiry_);
                ext::shared_ptr<VanillaSwap> swapUpper =
                    tmpIndexUpper->underlyingSwap(expiry_);
                // compute npv, delta, gamma
                Real npvm =
                    alpha * NPV(swapLower, fixedRate, nominal, -h_, type) +
                    (1.0 - alpha) *
                        NPV(swapUpper, fixedRate, nominal, -h_, type);
                Real npv =
                    alpha * NPV(swapLower, fixedRate, nominal, 0.0, type) +
                    (1.0 - alpha) *
                        NPV(swapUpper, fixedRate, nominal, 0.0, type);
                Real npvu =
                    alpha * NPV(swapLower, fixedRate, nominal, h_, type) +
                    (1.0 - alpha) *
                        NPV(swapUpper, fixedRate, nominal, h_, type);
                Real delta = (npvu - npvm) / (2.0 * h_);
                Real gamma = (npvu - 2.0 * npv + npvm) / (h_ * h_);

                // debug output global standard underlying npv
                // Real xtmp = -5.0;
                // std::cout << "globalStandardNpv;";
                // while (xtmp <= 5.0 + QL_EPSILON) {
                //     std::cout << alpha *NPV(swapLower, fixedRate, nominal, xtmp,
                //                             type) +
                //                      (1.0 - alpha) * NPV(swapUpper, fixedRate,
                //                                          nominal, xtmp, type)
                //               << ";";
                //     xtmp += 0.1;
                // }
                // std::cout << std::endl;
                // end debug output

                // return target function values
                Array res(3);
                res[0] = (npv - npv_) / delta_;
                res[1] = (delta - delta_) / delta_;
                res[2] = (gamma - gamma_) / gamma_;
                return res;
            }

            const Swap::Type type_;
            const ext::shared_ptr<Gaussian1dModel> mdl_;
            const ext::shared_ptr<SwapIndex> indexBase_;
            const Date expiry_;
            const Real maxMaturity_;
            const Real npv_, delta_, gamma_, h_;
        };
    };
}

#endif
]]></document_content>
  </document>
  <document index="116">
    <source>swaption/blackswaptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2006 StatPro Italia srl
 Copyright (C) 2015, 2016, 2017 Peter Caspers
 Copyright (C) 2017 Paul Giltinan
 Copyright (C) 2017 Werner Kuerzinger
 Copyright (C) 2020 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file blackswaptionengine.hpp
    \brief Black-formula swaption engine
*/

#ifndef quantlib_pricers_black_swaption_hpp
#define quantlib_pricers_black_swaption_hpp

#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/exercise.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/instruments/swaption.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/termstructures/volatility/swaption/swaptionconstantvol.hpp>
#include <ql/termstructures/volatility/swaption/swaptionvolstructure.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <utility>

namespace QuantLib {

    class Quote;

    namespace detail {

    /*! Generic Black-style-formula swaption engine
        This is the base class for the Black and Bachelier swaption engines */
    template<class Spec>
    class BlackStyleSwaptionEngine : public Swaption::engine {
      public:
        enum CashAnnuityModel { SwapRate, DiscountCurve };
        BlackStyleSwaptionEngine(Handle<YieldTermStructure> discountCurve,
                                 Volatility vol,
                                 const DayCounter& dc = Actual365Fixed(),
                                 Real displacement = 0.0,
                                 CashAnnuityModel model = DiscountCurve);
        BlackStyleSwaptionEngine(Handle<YieldTermStructure> discountCurve,
                                 const Handle<Quote>& vol,
                                 const DayCounter& dc = Actual365Fixed(),
                                 Real displacement = 0.0,
                                 CashAnnuityModel model = DiscountCurve);
        BlackStyleSwaptionEngine(Handle<YieldTermStructure> discountCurve,
                                 Handle<SwaptionVolatilityStructure> vol,
                                 CashAnnuityModel model = DiscountCurve);
        void calculate() const override;
        Handle<YieldTermStructure> termStructure() { return discountCurve_; }
        Handle<SwaptionVolatilityStructure> volatility() { return vol_; }

      private:
        Handle<YieldTermStructure> discountCurve_;
        Handle<SwaptionVolatilityStructure> vol_;
        CashAnnuityModel model_;
    };

    // shifted lognormal type engine
    struct Black76Spec {
        static constexpr VolatilityType type = ShiftedLognormal;
        Real value(const Option::Type type, const Real strike,
                   const Real atmForward, const Real stdDev, const Real annuity,
                   const Real displacement) {
            return blackFormula(type, strike, atmForward, stdDev, annuity,
                                displacement);
        }
        Real vega(const Real strike, const Real atmForward, const Real stdDev,
                  const Real exerciseTime, const Real annuity,
                  const Real displacement) {
            return std::sqrt(exerciseTime) *
                   blackFormulaStdDevDerivative(strike, atmForward, stdDev,
                                                annuity, displacement);
        }
        Real delta(const Option::Type type, const Real strike,
                   const Real atmForward, const Real stdDev, const Real annuity,
                   const Real displacement) {
            return blackFormulaForwardDerivative(type, strike, atmForward, stdDev,
                                                 annuity, displacement);
        }
    };

    // normal type engine
    struct BachelierSpec {
        static constexpr VolatilityType type = Normal;
        Real value(const Option::Type type, const Real strike,
                   const Real atmForward, const Real stdDev, const Real annuity,
                   const Real) {
            return bachelierBlackFormula(type, strike, atmForward, stdDev,
                                         annuity);
        }
        Real vega(const Real strike, const Real atmForward, const Real stdDev,
                  const Real exerciseTime, const Real annuity, const Real) {
            return std::sqrt(exerciseTime) *
                   bachelierBlackFormulaStdDevDerivative(
                       strike, atmForward, stdDev, annuity);
        }
        Real delta(const Option::Type type, const Real strike,
                   const Real atmForward, const Real stdDev, const Real annuity,
                   const Real) {
            return bachelierBlackFormulaForwardDerivative(
                type, strike, atmForward, stdDev, annuity);
        }
    };

    } // namespace detail

    //! Shifted Lognormal Black-formula swaption engine
    /*! \ingroup swaptionengines

        \warning The engine assumes that the exercise date lies before the
                 start date of the passed swap.
    */

    class BlackSwaptionEngine
        : public detail::BlackStyleSwaptionEngine<detail::Black76Spec> {
      public:
        BlackSwaptionEngine(const Handle<YieldTermStructure>& discountCurve,
                            Volatility vol,
                            const DayCounter& dc = Actual365Fixed(),
                            Real displacement = 0.0,
                            CashAnnuityModel model = DiscountCurve);
        BlackSwaptionEngine(const Handle<YieldTermStructure>& discountCurve,
                            const Handle<Quote>& vol,
                            const DayCounter& dc = Actual365Fixed(),
                            Real displacement = 0.0,
                            CashAnnuityModel model = DiscountCurve);
        BlackSwaptionEngine(const Handle<YieldTermStructure>& discountCurve,
                            const Handle<SwaptionVolatilityStructure>& vol,
                            CashAnnuityModel model = DiscountCurve);
    };

    //! Normal Bachelier-formula swaption engine
    /*! \ingroup swaptionengines

        \warning The engine assumes that the exercise date lies before the
                 start date of the passed swap.
    */

    class BachelierSwaptionEngine
        : public detail::BlackStyleSwaptionEngine<detail::BachelierSpec> {
      public:
        BachelierSwaptionEngine(const Handle<YieldTermStructure>& discountCurve,
                                Volatility vol,
                                const DayCounter& dc = Actual365Fixed(),
                                CashAnnuityModel model = DiscountCurve);
        BachelierSwaptionEngine(const Handle<YieldTermStructure>& discountCurve,
                                const Handle<Quote>& vol,
                                const DayCounter& dc = Actual365Fixed(),
                                CashAnnuityModel model = DiscountCurve);
        BachelierSwaptionEngine(const Handle<YieldTermStructure>& discountCurve,
                                const Handle<SwaptionVolatilityStructure>& vol,
                                CashAnnuityModel model = DiscountCurve);
    };

    // implementation

    namespace detail {

        template <class Spec>
        BlackStyleSwaptionEngine<Spec>::BlackStyleSwaptionEngine(
            Handle<YieldTermStructure> discountCurve,
            Volatility vol,
            const DayCounter& dc,
            Real displacement,
            CashAnnuityModel model)
        : discountCurve_(std::move(discountCurve)),
          vol_(ext::shared_ptr<SwaptionVolatilityStructure>(new ConstantSwaptionVolatility(
              0, NullCalendar(), Following, vol, dc, Spec().type, displacement))),
          model_(model) {
            registerWith(discountCurve_);
        }

        template <class Spec>
        BlackStyleSwaptionEngine<Spec>::BlackStyleSwaptionEngine(
            Handle<YieldTermStructure> discountCurve,
            const Handle<Quote>& vol,
            const DayCounter& dc,
            Real displacement,
            CashAnnuityModel model)
        : discountCurve_(std::move(discountCurve)),
          vol_(ext::shared_ptr<SwaptionVolatilityStructure>(new ConstantSwaptionVolatility(
              0, NullCalendar(), Following, vol, dc, Spec().type, displacement))),
          model_(model) {
            registerWith(discountCurve_);
            registerWith(vol_);
        }

        template <class Spec>
        BlackStyleSwaptionEngine<Spec>::BlackStyleSwaptionEngine(
            Handle<YieldTermStructure> discountCurve,
            Handle<SwaptionVolatilityStructure> volatility,
            CashAnnuityModel model)
        : discountCurve_(std::move(discountCurve)), vol_(std::move(volatility)), model_(model) {
            registerWith(discountCurve_);
            registerWith(vol_);
        }

    template<class Spec>
    void BlackStyleSwaptionEngine<Spec>::calculate() const {
        static const Spread basisPoint = 1.0e-4;

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not a European option");

        Date exerciseDate = arguments_.exercise->date(0);

        // The part of the swap preceding exerciseDate should be truncated to avoid taking into
        // account unwanted cashflows. For the moment we add a check avoiding this situation.
        // Furthermore, we take a copy of the underlying swap. This avoids notifying the swaption
        // when we set a pricing engine on the swap below.
        auto swap = arguments_.swap;

        const Leg& fixedLeg = swap->fixedLeg();
        ext::shared_ptr<FixedRateCoupon> firstCoupon =
            ext::dynamic_pointer_cast<FixedRateCoupon>(fixedLeg[0]);
        QL_REQUIRE(firstCoupon->accrualStartDate() >= exerciseDate,
                   "swap start (" << firstCoupon->accrualStartDate() << ") before exercise date ("
                                  << exerciseDate << ") not supported in Black swaption engine");

        Rate strike = swap->fixedRate();

        // using the discounting curve
        // swap.iborIndex() might be using a different forwarding curve
        auto engine = ext::make_shared<DiscountingSwapEngine>(discountCurve_, false);
        ObservableSettings::instance().disableUpdates();
        swap->setPricingEngine(engine);
        ObservableSettings::instance().enableUpdates();
        Date valuation_date = results_.valuationDate  = swap->valuationDate();
        Rate atmForward = swap->fairRate();

        // Volatilities are quoted for zero-spreaded swaps.
        // Therefore, any spread on the floating leg must be removed
        // with a corresponding correction on the fixed leg.
        Real spread = swap->spread();
        if (spread!=0.0) {
            Spread correction =
                spread * std::fabs(swap->floatingLegBPS() / swap->fixedLegBPS());
            strike -= correction;
            atmForward -= correction;
            results_.additionalResults["spreadCorrection"] = correction;
        } else {
            results_.additionalResults["spreadCorrection"] = Real(0.0);
        }
        results_.additionalResults["strike"] = strike;
        results_.additionalResults["atmForward"] = atmForward;

        Real annuity;
        if (arguments_.settlementType == Settlement::Physical ||
            (arguments_.settlementType == Settlement::Cash &&
             arguments_.settlementMethod ==
                 Settlement::CollateralizedCashPrice)) {
            annuity = std::fabs(swap->fixedLegBPS()) / basisPoint;
        } else if (arguments_.settlementType == Settlement::Cash &&
                   arguments_.settlementMethod == Settlement::ParYieldCurve) {
            DayCounter dayCount = firstCoupon->dayCounter();
            // we assume that the cash settlement date is equal
            // to the swap start date
            Date discountDate = model_ == DiscountCurve
                                    ? firstCoupon->accrualStartDate()
                                    : valuation_date;
            Frequency freq = Annual;
            const Schedule& fixedSchedule = swap->fixedSchedule();
            if (fixedSchedule.hasTenor()) {
                freq = fixedSchedule.tenor().frequency();
            }
            Real fixedLegCashBPS =
                CashFlows::bps(fixedLeg,
                        InterestRate(atmForward, dayCount, Compounded, freq),
                        false, discountDate);
            annuity = std::fabs(fixedLegCashBPS / basisPoint) *
                      discountCurve_->discount(discountDate);
        } else {
            QL_FAIL("invalid (settlementType, settlementMethod) pair");
        }
        results_.additionalResults["annuity"] = annuity;

        const Schedule& floatingSchedule = swap->floatingSchedule();
        Time swapLength =  vol_->swapLength(floatingSchedule.dates().front(),
                                            floatingSchedule.dates().back());

        // swapLength is rounded to whole months. To ensure we can read a variance
        // and a shift from vol_ we floor swapLength at 1/12 here therefore.
        swapLength = std::max(swapLength, 1.0 / 12.0);
        results_.additionalResults["swapLength"] = swapLength;

        Real variance = vol_->blackVariance(exerciseDate, swapLength, strike);

        Real displacement =
            vol_->volatilityType() == ShiftedLognormal ?
            vol_->shift(exerciseDate, swapLength) : 0.0;

        Real stdDev = std::sqrt(variance);
        results_.additionalResults["stdDev"] = stdDev;
        Option::Type w = (swap->type() == Swap::Payer) ? Option::Call : Option::Put;
        results_.value = Spec().value(w, strike, atmForward, stdDev, annuity, displacement);

        Time exerciseTime = vol_->timeFromReference(exerciseDate);
        results_.additionalResults["vega"] = Spec().vega(
            strike, atmForward, stdDev, exerciseTime, annuity, displacement);
        results_.additionalResults["delta"] = Spec().delta(
            w, strike, atmForward, stdDev, annuity, displacement);
        results_.additionalResults["timeToExpiry"] = exerciseTime;
        results_.additionalResults["impliedVolatility"] = Real(stdDev / std::sqrt(exerciseTime));
        results_.additionalResults["forwardPrice"] = Real(results_.value / discountCurve_->discount(exerciseDate));
    }

    }  // namespace detail

}

#endif
]]></document_content>
  </document>
  <document index="117">
    <source>swaption/discretizedswaption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2007 StatPro Italia srl
 Copyright (C) 2021, 2022 Ralf Konrad Eckel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file discretizedswaption.hpp
    \brief Discretized swaption class
*/

#ifndef quantlib_discretized_swaption_hpp
#define quantlib_discretized_swaption_hpp

#include <ql/discretizedasset.hpp>
#include <ql/instruments/swaption.hpp>

namespace QuantLib {

    class DiscretizedSwaption : public DiscretizedOption {
      public:
        DiscretizedSwaption(const Swaption::arguments&,
                            const Date& referenceDate,
                            const DayCounter& dayCounter);
        void reset(Size size) override;

      private:
        Swaption::arguments arguments_;
        Time lastPayment_;

        static void prepareSwaptionWithSnappedDates(
            const Swaption::arguments& args,
            const Date& referenceDate,
            const DayCounter& dayCounter,
            PricingEngine::arguments& snappedArgs,
            std::vector<CouponAdjustment>& fixedCouponAdjustments,
            std::vector<CouponAdjustment>& floatingCouponAdjustments);
    };

}


#endif
]]></document_content>
  </document>
  <document index="118">
    <source>swaption/fdg2swaptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdg2swaptionengine.hpp
    \brief finite differences swaption engine
*/

#ifndef quantlib_fd_g2_swaption_engine_hpp
#define quantlib_fd_g2_swaption_engine_hpp

#include <ql/instruments/swaption.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/models/shortrate/twofactormodels/g2.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    class FdG2SwaptionEngine
        : public GenericModelEngine<G2,Swaption::arguments,Swaption::results> {
      public:
        explicit FdG2SwaptionEngine(
            const ext::shared_ptr<G2>& model,
            Size tGrid = 100, Size xGrid = 50, Size yGrid = 50,
            Size dampingSteps = 0, Real invEps = 1e-5,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

        void calculate() const override;

      private:
        const Size tGrid_, xGrid_, yGrid_, dampingSteps_;
        const Real invEps_;
        const FdmSchemeDesc schemeDesc_;
    };
}
#endif
]]></document_content>
  </document>
  <document index="119">
    <source>swaption/fdhullwhiteswaptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdhullwhiteswaptionengine.hpp
    \brief finite differences swaption engine
*/

#ifndef quantlib_fd_hull_white_swaption_engine_hpp
#define quantlib_fd_hull_white_swaption_engine_hpp

#include <ql/instruments/swaption.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/models/shortrate/onefactormodels/hullwhite.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    class FdHullWhiteSwaptionEngine
        : public GenericModelEngine<HullWhite, 
                                    Swaption::arguments, Swaption::results> {
      public:
        explicit FdHullWhiteSwaptionEngine(
            const ext::shared_ptr<HullWhite>& model,
            Size tGrid = 100, Size xGrid = 100,
            Size dampingSteps = 0, Real invEps = 1e-5,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas());

        void calculate() const override;

      private:
        const Size tGrid_, xGrid_, dampingSteps_;
        const Real invEps_;
        const FdmSchemeDesc schemeDesc_;
    };
}

#endif

]]></document_content>
  </document>
  <document index="120">
    <source>swaption/g2swaptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Mike Parker

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file g2swaptionengine.hpp
    \brief Swaption pricing engine for two-factor additive Gaussian Model G2++
*/

#ifndef quantlib_pricers_G2_swaption_hpp
#define quantlib_pricers_G2_swaption_hpp

#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/models/shortrate/twofactormodels/g2.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>

namespace QuantLib {

    //! %Swaption priced by means of the Black formula
    /*! \ingroup swaptionengines

        \warning The engine assumes that the exercise date equals the
                 start date of the passed swap.
    */
    class G2SwaptionEngine : public GenericModelEngine<G2, Swaption::arguments,
                                                           Swaption::results> {
      public:
        // range is the number of standard deviations to use in the
        // exponential term of the integral for the european swaption.
        // intervals is the number of intervals to use in the integration.
        G2SwaptionEngine(const ext::shared_ptr<G2>& model,
                         Real range,
                         Size intervals)
        : GenericModelEngine<G2, Swaption::arguments, Swaption::results>(model),
          range_(range), intervals_(intervals) {}
        void calculate() const override {
            QL_REQUIRE(arguments_.settlementType == Settlement::Physical,
                       "cash-settled swaptions not priced with G2 engine");
            QL_REQUIRE(!model_.empty(), "no model specified");

            // adjust the fixed rate of the swap for the spread on the
            // floating leg (which is not taken into account by the
            // model)
            auto swap = arguments_.swap;
            swap->setPricingEngine(ext::make_shared<DiscountingSwapEngine>(model_->termStructure(), false));
            Spread correction = swap->spread() *
                std::fabs(swap->floatingLegBPS() / swap->fixedLegBPS());
            Rate fixedRate = swap->fixedRate() - correction;

            results_.value =  model_->swaption(arguments_, fixedRate,
                                               range_, intervals_);
        }

      private:
        Real range_;
        Size intervals_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="121">
    <source>swaption/gaussian1dfloatfloatswaptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib liense.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gaussian1dfloatfloatswaptionengine.hpp
    \brief float float swaption engine for one factor interest rate models
*/

#ifndef quantlib_pricers_gaussian1d_floatfloatswaption_hpp
#define quantlib_pricers_gaussian1d_floatfloatswaption_hpp

#include <ql/instruments/floatfloatswaption.hpp>
#include <ql/models/shortrate/onefactormodels/gaussian1dmodel.hpp>
#include <ql/rebatedexercise.hpp>

#include <ql/pricingengines/genericmodelengine.hpp>

namespace QuantLib {

    //! One factor model float float swaption engine
    /*! \ingroup swaptionengines

         All float coupons with fixing date greater or
         equal the respective option expiry are considered
         part of the exercise into right. Note that this
         is different from the usual accrual start date
         greater or equal exercise date if the fixing lag
         is strictly greater than the exercise lag (which
         should be a rare case). For the redepmtion flows
         the criterion is that the associated start date
         of the redemption flow (i.e. the start date of
         the regular coupon period with same payment date
         as the redemption flow) is greater or equal the
         exercise date.

         The addtional result underlyingValue is the npv
         of the underlying (as seen from "today") including
         all fixings greater (or greater equal depending
         on includeTodaysExercise) today.
   */

    class Gaussian1dFloatFloatSwaptionEngine
        : public BasketGeneratingEngine,
          public GenericModelEngine<Gaussian1dModel,
                                    FloatFloatSwaption::arguments,
                                    FloatFloatSwaption::results> {
      public:
        enum Probabilities {
            None,
            Naive,
            Digital
        };

        Gaussian1dFloatFloatSwaptionEngine(
            const ext::shared_ptr<Gaussian1dModel> &model,
            const int integrationPoints = 64, const Real stddevs = 7.0,
            const bool extrapolatePayoff = true,
            const bool flatPayoffExtrapolation = false,
            const Handle<Quote> &oas =
                Handle<Quote>(), // continuously compounded w.r.t. yts daycounter
            const Handle<YieldTermStructure> &discountCurve =
                Handle<YieldTermStructure>(),
            const bool includeTodaysExercise = false,
            const Probabilities probabilities = None)
            : BasketGeneratingEngine(model, oas, discountCurve),
              GenericModelEngine<Gaussian1dModel, FloatFloatSwaption::arguments,
                                 FloatFloatSwaption::results>(model),
              integrationPoints_(integrationPoints), stddevs_(stddevs),
              extrapolatePayoff_(extrapolatePayoff),
              flatPayoffExtrapolation_(flatPayoffExtrapolation),
              oas_(oas), discountCurve_(discountCurve),
              includeTodaysExercise_(includeTodaysExercise),
              probabilities_(probabilities) {

            if (!discountCurve_.empty())
                registerWith(discountCurve_);

            if (!oas_.empty())
                registerWith(oas_);
        }

        Gaussian1dFloatFloatSwaptionEngine(
            const Handle<Gaussian1dModel> &model,
            const int integrationPoints = 64, const Real stddevs = 7.0,
            const bool extrapolatePayoff = true,
            const bool flatPayoffExtrapolation = false,
            const Handle<Quote> &oas =
                Handle<Quote>(), // continuously compounded w.r.t. yts daycounter
            const Handle<YieldTermStructure> &discountCurve =
                Handle<YieldTermStructure>(),
            const bool includeTodaysExercise = false,
            const Probabilities probabilities = None)
            : BasketGeneratingEngine(model, oas, discountCurve),
              GenericModelEngine<Gaussian1dModel, FloatFloatSwaption::arguments,
                                 FloatFloatSwaption::results>(model),
              integrationPoints_(integrationPoints), stddevs_(stddevs),
              extrapolatePayoff_(extrapolatePayoff),
              flatPayoffExtrapolation_(flatPayoffExtrapolation),
              oas_(oas), discountCurve_(discountCurve),
              includeTodaysExercise_(includeTodaysExercise),
              probabilities_(probabilities) {

            if (!discountCurve_.empty())
                registerWith(discountCurve_);

            if (!oas_.empty())
                registerWith(oas_);
        }

        void calculate() const override;

        Handle<YieldTermStructure> discountingCurve() const {
            return discountCurve_.empty() ? model_->termStructure()
                                          : discountCurve_;
        }

      protected:
        Real underlyingNpv(const Date& expiry, Real y) const override;
        Swap::Type underlyingType() const override;
        const Date underlyingLastDate() const override;
        const Array initialGuess(const Date& expiry) const override;

      private:
        const int integrationPoints_;
        const Real stddevs_;
        const bool extrapolatePayoff_, flatPayoffExtrapolation_;
        const Handle<Quote> oas_;
        const Handle<YieldTermStructure> discountCurve_;
        const bool includeTodaysExercise_;
        const Probabilities probabilities_;

        std::pair<Real, Real> npvs(const Date& expiry,
                                   Real y,
                                   bool includeExerciseOnxpiry,
                                   bool considerProbabilities = false) const;

        mutable ext::shared_ptr<RebatedExercise> rebatedExercise_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="122">
    <source>swaption/gaussian1djamshidianswaptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gaussian1djamshidianswaptionengine.hpp
    \brief Swaption engine using Jamshidian's decomposition
*/

#ifndef quantlib_pricers_gaussian1d_jamshidian_swaption_hpp
#define quantlib_pricers_gaussian1d_jamshidian_swaption_hpp

#include <ql/instruments/swaption.hpp>
#include <ql/models/shortrate/onefactormodels/gsr.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>

namespace QuantLib {

    //! Jamshidian swaption engine
    /*! \ingroup swaptionengines
    */
    class Gaussian1dJamshidianSwaptionEngine
        : public GenericModelEngine<Gaussian1dModel, Swaption::arguments,
                                    Swaption::results> {
      public:
        /*! \note the term structure is only needed when the short-rate
                  model cannot provide one itself.
        */
        Gaussian1dJamshidianSwaptionEngine(
            const ext::shared_ptr<Gaussian1dModel> &model)
            : GenericModelEngine<Gaussian1dModel, Swaption::arguments,
                                 Swaption::results>(model) {}
        void calculate() const override;

      private:
        class rStarFinder;
    };
}

#endif

]]></document_content>
  </document>
  <document index="123">
    <source>swaption/gaussian1dnonstandardswaptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gaussian1dnonstandardswaptionengine.hpp
    \brief
*/

#ifndef quantlib_pricers_gaussian1d_nonstandardswaption_hpp
#define quantlib_pricers_gaussian1d_nonstandardswaption_hpp

#include <ql/instruments/nonstandardswaption.hpp>
#include <ql/models/shortrate/onefactormodels/gsr.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/termstructures/volatility/swaption/swaptionvolstructure.hpp>

namespace QuantLib {

    //! One factor model non standard swaption engine
    /*! \ingroup swaptionengines

       All fixed coupons with start date greater or equal to the
       respective option expiry are considered to be part of the
       exercise into right.

       All float coupons with start date greater or equal to the
       respective option expiry are consideres to be part of the
       exercise into right.

       For redemption flows an associated start date is considered
       in the criterion, which is the start date of the regular
       xcoupon period with same payment date as the redemption flow.

       \warning Cash settled swaptions are not supported

    */

    class Gaussian1dNonstandardSwaptionEngine
        : public BasketGeneratingEngine,
          public GenericModelEngine<Gaussian1dModel,
                                    NonstandardSwaption::arguments,
                                    NonstandardSwaption::results> {
      public:
        enum Probabilities {
            None,
            Naive,
            Digital
        };

        Gaussian1dNonstandardSwaptionEngine(
            const ext::shared_ptr<Gaussian1dModel> &model,
            const int integrationPoints = 64, const Real stddevs = 7.0,
            const bool extrapolatePayoff = true,
            const bool flatPayoffExtrapolation = false,
            const Handle<Quote> &oas = Handle<Quote>(), // continuously
                                                        // compounded w.r.t. yts
                                                        // daycounter
            const Handle<YieldTermStructure> &discountCurve =
                Handle<YieldTermStructure>(),
            const Probabilities probabilities = None)
            : BasketGeneratingEngine(model, oas, discountCurve),
              GenericModelEngine<Gaussian1dModel,
                                 NonstandardSwaption::arguments,
                                 NonstandardSwaption::results>(model),
              integrationPoints_(integrationPoints), stddevs_(stddevs),
              extrapolatePayoff_(extrapolatePayoff),
              flatPayoffExtrapolation_(flatPayoffExtrapolation),
              discountCurve_(discountCurve), oas_(oas),
              probabilities_(probabilities) {

            if (!oas_.empty())
                registerWith(oas_);

            if (!discountCurve_.empty())
                registerWith(discountCurve_);
        }

        Gaussian1dNonstandardSwaptionEngine(
            const Handle<Gaussian1dModel> &model,
            const int integrationPoints = 64, const Real stddevs = 7.0,
            const bool extrapolatePayoff = true,
            const bool flatPayoffExtrapolation = false,
            const Handle<Quote> &oas = Handle<Quote>(), // continuously
                                                        // compounded w.r.t. yts
                                                        // daycounter
            const Handle<YieldTermStructure> &discountCurve =
                Handle<YieldTermStructure>(),
            const Probabilities probabilities = None)
            : BasketGeneratingEngine(model, oas, discountCurve),
              GenericModelEngine<Gaussian1dModel,
                                 NonstandardSwaption::arguments,
                                 NonstandardSwaption::results>(model),
              integrationPoints_(integrationPoints), stddevs_(stddevs),
              extrapolatePayoff_(extrapolatePayoff),
              flatPayoffExtrapolation_(flatPayoffExtrapolation),
              discountCurve_(discountCurve), oas_(oas),
              probabilities_(probabilities) {

            if (!oas_.empty())
                registerWith(oas_);

            if (!discountCurve_.empty())
                registerWith(discountCurve_);
        }

        void calculate() const override;

      protected:
        Real underlyingNpv(const Date& expiry, Real y) const override;
        Swap::Type underlyingType() const override;
        const Date underlyingLastDate() const override;
        const Array initialGuess(const Date& expiry) const override;

      private:
        const int integrationPoints_;
        const Real stddevs_;
        const bool extrapolatePayoff_, flatPayoffExtrapolation_;
        const Handle<YieldTermStructure> discountCurve_;
        const Handle<Quote> oas_;
        const Probabilities probabilities_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="124">
    <source>swaption/gaussian1dswaptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gaussian1dswaptionengine.hpp
    \brief
*/

#ifndef quantlib_pricers_gaussian1d_swaption_hpp
#define quantlib_pricers_gaussian1d_swaption_hpp

#include <ql/instruments/swaption.hpp>
#include <ql/models/shortrate/onefactormodels/gaussian1dmodel.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>
#include <utility>

namespace QuantLib {

    //! One factor model swaption engine
    /*! \ingroup swaptionengines

        All fixed coupons with start date greater or equal to the respective
        option expiry are considered to be
        part of the exercise into right.

        \warning Cash settled swaptions are not supported
    */

    class Gaussian1dSwaptionEngine
        : public GenericModelEngine<Gaussian1dModel, Swaption::arguments,
                                    Swaption::results> {
      public:
        enum Probabilities {
            None,
            Naive,
            Digital
        };

        Gaussian1dSwaptionEngine(
            const ext::shared_ptr<Gaussian1dModel>& model,
            const int integrationPoints = 64,
            const Real stddevs = 7.0,
            const bool extrapolatePayoff = true,
            const bool flatPayoffExtrapolation = false,
            Handle<YieldTermStructure> discountCurve = Handle<YieldTermStructure>(),
            const Probabilities probabilities = None)
        : GenericModelEngine<Gaussian1dModel, Swaption::arguments, Swaption::results>(model),
          integrationPoints_(integrationPoints), stddevs_(stddevs),
          extrapolatePayoff_(extrapolatePayoff), flatPayoffExtrapolation_(flatPayoffExtrapolation),
          discountCurve_(std::move(discountCurve)), probabilities_(probabilities) {

            if (!discountCurve_.empty())
                registerWith(discountCurve_);
        }

        Gaussian1dSwaptionEngine(
            const Handle<Gaussian1dModel>& model,
            const int integrationPoints = 64,
            const Real stddevs = 7.0,
            const bool extrapolatePayoff = true,
            const bool flatPayoffExtrapolation = false,
            Handle<YieldTermStructure> discountCurve = Handle<YieldTermStructure>(),
            const Probabilities probabilities = None)
        : GenericModelEngine<Gaussian1dModel, Swaption::arguments, Swaption::results>(model),
          integrationPoints_(integrationPoints), stddevs_(stddevs),
          extrapolatePayoff_(extrapolatePayoff), flatPayoffExtrapolation_(flatPayoffExtrapolation),
          discountCurve_(std::move(discountCurve)), probabilities_(probabilities) {

            if (!discountCurve_.empty())
                registerWith(discountCurve_);
        }

        void calculate() const override;

      private:
        const int integrationPoints_;
        const Real stddevs_;
        const bool extrapolatePayoff_, flatPayoffExtrapolation_;
        const Handle<YieldTermStructure> discountCurve_;
        const Probabilities probabilities_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="125">
    <source>swaption/jamshidianswaptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file jamshidianswaptionengine.hpp
    \brief Swaption engine using Jamshidian's decomposition
    Concerning the start delay cf. http://ssrn.com/abstract=2246054
*/

#ifndef quantlib_pricers_jamshidian_swaption_hpp
#define quantlib_pricers_jamshidian_swaption_hpp

#include <ql/instruments/swaption.hpp>
#include <ql/models/shortrate/onefactormodel.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>
#include <utility>

namespace QuantLib {

    //! Jamshidian swaption engine
    /*! \ingroup swaptionengines
        \warning The engine might assume that the exercise date equals the
                 start date of the passed swap unless the model provides
                 an implementation of the discountBondOption method with
                 start delay 
    */

    class JamshidianSwaptionEngine
        : public GenericModelEngine<OneFactorAffineModel,
                                    Swaption::arguments,
                                    Swaption::results > {
      public:
        /*! \note the term structure is only needed when the short-rate
                  model cannot provide one itself.
        */
        JamshidianSwaptionEngine(
            const ext::shared_ptr<OneFactorAffineModel>& model,
            Handle<YieldTermStructure> termStructure = Handle<YieldTermStructure>())
        : GenericModelEngine<OneFactorAffineModel, Swaption::arguments, Swaption::results>(model),
          termStructure_(std::move(termStructure)) {
            registerWith(termStructure_);
        }
        void calculate() const override;

      private:
        Handle<YieldTermStructure> termStructure_;
        class rStarFinder;
    };

}


#endif

]]></document_content>
  </document>
  <document index="126">
    <source>swaption/treeswaptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2005, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file treeswaptionengine.hpp
    \brief Numerical lattice engine for swaptions
*/

#ifndef quantlib_tree_swaption_engine_hpp
#define quantlib_tree_swaption_engine_hpp

#include <ql/instruments/swaption.hpp>
#include <ql/pricingengines/latticeshortratemodelengine.hpp>

namespace QuantLib {

    //! Numerical lattice engine for swaptions
    /*! \ingroup swaptionengines

        \warning This engine is not guaranteed to work if the
                 underlying swap has a start date in the past, i.e.,
                 before today's date. When using this engine, prune
                 the initial part of the swap so that it starts at
                 \f$ t \geq 0 \f$.

        \test calculations are checked against cached results
    */
    class TreeSwaptionEngine
    : public LatticeShortRateModelEngine<Swaption::arguments,
                                         Swaption::results> {
      public:
        /*! \name Constructors
            \note the term structure is only needed when the short-rate
                  model cannot provide one itself.
        */
        //@{
        TreeSwaptionEngine(const ext::shared_ptr<ShortRateModel>&,
                           Size timeSteps,
                           Handle<YieldTermStructure> termStructure = Handle<YieldTermStructure>());
        TreeSwaptionEngine(const ext::shared_ptr<ShortRateModel>&,
                           const TimeGrid& timeGrid,
                           Handle<YieldTermStructure> termStructure = Handle<YieldTermStructure>());
        TreeSwaptionEngine(const Handle<ShortRateModel>&,
                           Size timeSteps,
                           Handle<YieldTermStructure> termStructure = Handle<YieldTermStructure>());
        //@}
        void calculate() const override;

      private:
        Handle<YieldTermStructure> termStructure_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="127">
    <source>vanilla/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/pricingengines/vanilla/analyticbsmhullwhiteengine.hpp>
#include <ql/pricingengines/vanilla/analyticdigitalamericanengine.hpp>
#include <ql/pricingengines/vanilla/analyticdividendeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanvasicekengine.hpp>
#include <ql/pricingengines/vanilla/analyticcevengine.hpp>
#include <ql/pricingengines/vanilla/analyticgjrgarchengine.hpp>
#include <ql/pricingengines/vanilla/analytich1hwengine.hpp>
#include <ql/pricingengines/vanilla/analytichestonengine.hpp>
#include <ql/pricingengines/vanilla/analytichestonhullwhiteengine.hpp>
#include <ql/pricingengines/vanilla/analyticpdfhestonengine.hpp>
#include <ql/pricingengines/vanilla/analyticptdhestonengine.hpp>
#include <ql/pricingengines/vanilla/baroneadesiwhaleyengine.hpp>
#include <ql/pricingengines/vanilla/batesengine.hpp>
#include <ql/pricingengines/vanilla/binomialengine.hpp>
#include <ql/pricingengines/vanilla/bjerksundstenslandengine.hpp>
#include <ql/pricingengines/vanilla/cashdividendeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/coshestonengine.hpp>
#include <ql/pricingengines/vanilla/discretizedvanillaoption.hpp>
#include <ql/pricingengines/vanilla/exponentialfittinghestonengine.hpp>
#include <ql/pricingengines/vanilla/hestonexpansionengine.hpp>
#include <ql/pricingengines/vanilla/integralengine.hpp>
#include <ql/pricingengines/vanilla/jumpdiffusionengine.hpp>
#include <ql/pricingengines/vanilla/juquadraticengine.hpp>
#include <ql/pricingengines/vanilla/fdbatesvanillaengine.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesvanillaengine.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesshoutengine.hpp>
#include <ql/pricingengines/vanilla/fdcevvanillaengine.hpp>
#include <ql/pricingengines/vanilla/fdhestonhullwhitevanillaengine.hpp>
#include <ql/pricingengines/vanilla/fdhestonvanillaengine.hpp>
#include <ql/pricingengines/vanilla/fdcirvanillaengine.hpp>
#include <ql/pricingengines/vanilla/fdsabrvanillaengine.hpp>
#include <ql/pricingengines/vanilla/fdsimplebsswingengine.hpp>
#include <ql/pricingengines/vanilla/mcamericanengine.hpp>
#include <ql/pricingengines/vanilla/mcdigitalengine.hpp>
#include <ql/pricingengines/vanilla/mceuropeanengine.hpp>
#include <ql/pricingengines/vanilla/mceuropeanhestonengine.hpp>
#include <ql/pricingengines/vanilla/mceuropeangjrgarchengine.hpp>
#include <ql/pricingengines/vanilla/mchestonhullwhiteengine.hpp>
#include <ql/pricingengines/vanilla/mcvanillaengine.hpp>
#include <ql/pricingengines/vanilla/qdfpamericanengine.hpp>
#include <ql/pricingengines/vanilla/qdplusamericanengine.hpp>

]]></document_content>
  </document>
  <document index="128">
    <source>vanilla/analyticbsmhullwhiteengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticbsmhullwhiteengine.hpp
    \brief analytic Black-Scholes engines including stochastic interest rates
*/

#ifndef quantlib_analytic_bsm_hull_white_engine_hpp
#define quantlib_analytic_bsm_hull_white_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/models/shortrate/onefactormodels/hullwhite.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! analytic european option pricer including stochastic interest rates
    /*! References:

        Brigo, Mercurio, Interest Rate Models

        \ingroup vanillaengines

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature
    */

    class AnalyticBSMHullWhiteEngine
        : public GenericModelEngine<HullWhite,
                                    VanillaOption::arguments,
                                    VanillaOption::results> {
      public:
        AnalyticBSMHullWhiteEngine(Real equityShortRateCorrelation,
                                   ext::shared_ptr<GeneralizedBlackScholesProcess>,
                                   const ext::shared_ptr<HullWhite>&);
        void calculate() const override;

      private:
        Real rho_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="129">
    <source>vanilla/analyticcevengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticcevengine.hpp
    \brief  Pricing engine for European vanilla options using a
    constant elasticity of variance (CEV) model
*/

#ifndef quantlib_analytic_cev_engine_hpp
#define quantlib_analytic_cev_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>

namespace QuantLib {

    //! constant elasticity of variance process (absorbing boundary at f=0)
    /*! \f[
         df_t = \alpha f_t^\beta \mathrm{d}W_t
        \f]
    */

    /*! References:

        D.R. Brecher, A.E. Lindsay, Results on the CEV Process, Past and Present
        https://www.fincad.com/sites/default/files/wysiwyg/Resources-Wiki/cev-process-working-paper.pdf
    */

    class CEVCalculator {
      public:
        CEVCalculator(Real f0, Real alpha, Real beta);

        Real value(Option::Type optionType, Real strike, Time t) const;

        Real f0()    const { return f0_; }
        Real alpha() const { return alpha_; }
        Real beta()  const { return beta_; }

      private:
        Real X(Real f) const;

        const Real f0_, alpha_, beta_, delta_, x0_;
    };


    class AnalyticCEVEngine : public VanillaOption::engine {
      public:
        AnalyticCEVEngine(Real f0, Real alpha, Real beta, Handle<YieldTermStructure> discountCurve);

        void calculate() const override;

      private:
        const ext::shared_ptr<CEVCalculator> calculator_;
        const Handle<YieldTermStructure> discountCurve_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="130">
    <source>vanilla/analyticdigitalamericanengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2003, 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticdigitalamericanengine.hpp
    \brief analytic digital American option engine
*/

#ifndef quantlib_analytic_digital_american_engine_hpp
#define quantlib_analytic_digital_american_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic pricing engine for American vanilla options with digital payoff
    /*! \ingroup vanillaengines

        \todo add more greeks (as of now only delta and rho available)

        \test
        - the correctness of the returned value in case of
          cash-or-nothing at-hit digital payoff is tested by
          reproducing results available in literature.
        - the correctness of the returned value in case of
          asset-or-nothing at-hit digital payoff is tested by
          reproducing results available in literature.
        - the correctness of the returned value in case of
          cash-or-nothing at-expiry digital payoff is tested by
          reproducing results available in literature.
        - the correctness of the returned value in case of
          asset-or-nothing at-expiry digital payoff is tested by
          reproducing results available in literature.
        - the correctness of the returned greeks in case of
          cash-or-nothing at-hit digital payoff is tested by
          reproducing numerical derivatives.
    */
    class AnalyticDigitalAmericanEngine : public VanillaOption::engine {
      public:
        AnalyticDigitalAmericanEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);
        void calculate() const override;
        virtual bool knock_in() const {
           return true;
        }
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

    //! Analytic pricing engine for American Knock-out options with digital payoff
    /*! \ingroup vanillaengines

        \todo add more greeks (as of now only delta and rho available)

        \test
        - the correctness of the returned value in case of
          cash-or-nothing at-hit digital payoff is tested by
          reproducing results available in literature.
        - the correctness of the returned value in case of
          asset-or-nothing at-hit digital payoff is tested by
          reproducing results available in literature.
        - the correctness of the returned value in case of
          cash-or-nothing at-expiry digital payoff is tested by
          reproducing results available in literature.
        - the correctness of the returned value in case of
          asset-or-nothing at-expiry digital payoff is tested by
          reproducing results available in literature.
        - the correctness of the returned greeks in case of
          cash-or-nothing at-hit digital payoff is tested by
          reproducing numerical derivatives.
    */
    class AnalyticDigitalAmericanKOEngine : 
                              public AnalyticDigitalAmericanEngine {
      public:
        AnalyticDigitalAmericanKOEngine(
                    const ext::shared_ptr<GeneralizedBlackScholesProcess> 
                                 &engine):
        AnalyticDigitalAmericanEngine(engine) {}
        bool knock_in() const override { return false; }
    };

}


#endif
]]></document_content>
  </document>
  <document index="131">
    <source>vanilla/analyticdividendeuropeanengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticdividendeuropeanengine.hpp
    \brief Analytic discrete-dividend European engine
*/

#ifndef quantlib_analytic_dividend_european_engine_hpp
#define quantlib_analytic_dividend_european_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic pricing engine for European options with discrete dividends
    /*! \ingroup vanillaengines

        \test the correctness of the returned greeks is tested by
              reproducing numerical derivatives.
    */
    class AnalyticDividendEuropeanEngine : public VanillaOption::engine {
      public:
        AnalyticDividendEuropeanEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                                       DividendSchedule dividends);

        void calculate() const override;
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        DividendSchedule dividends_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="132">
    <source>vanilla/analyticeuropeanengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticeuropeanengine.hpp
    \brief Analytic European engine
*/

#ifndef quantlib_analytic_european_engine_hpp
#define quantlib_analytic_european_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Pricing engine for European vanilla options using analytical formulae
    /*! \ingroup vanillaengines

        \test
        - the correctness of the returned value is tested by
          reproducing results available in literature.
        - the correctness of the returned greeks is tested by
          reproducing results available in literature.
        - the correctness of the returned greeks is tested by
          reproducing numerical derivatives.
        - the correctness of the returned implied volatility is tested
          by using it for reproducing the target value.
        - the implied-volatility calculation is tested by checking
          that it does not modify the option.
        - the correctness of the returned value in case of
          cash-or-nothing digital payoff is tested by reproducing
          results available in literature.
        - the correctness of the returned value in case of
          asset-or-nothing digital payoff is tested by reproducing
          results available in literature.
        - the correctness of the returned value in case of gap digital
          payoff is tested by reproducing results available in
          literature.
        - the correctness of the returned greeks in case of
          cash-or-nothing digital payoff is tested by reproducing
          numerical derivatives.
    */
    class AnalyticEuropeanEngine : public VanillaOption::engine {
      public:
        /*! This constructor triggers the usual calculation, in which
            the risk-free rate in the given process is used for both
            forecasting and discounting.
        */
        explicit AnalyticEuropeanEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);

        /*! This constructor allows to use a different term structure
            for discounting the payoff. As usual, the risk-free rate
            from the given process is used for forecasting the forward
            price.
        */
        AnalyticEuropeanEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                               Handle<YieldTermStructure> discountCurve);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Handle<YieldTermStructure> discountCurve_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="133">
    <source>vanilla/analyticeuropeanvasicekengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Lew Wei Hao

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_analytic_black_vasicek_engine_hpp
#define quantlib_analytic_black_vasicek_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/models/shortrate/onefactormodels/vasicek.hpp>
#include <ql/math/integrals/integral.hpp>

namespace QuantLib {

    /**
     *
     * Pricing of Vanilla European options under stochastic Vasicek interest rate model
     * Analytical solution is based on following research paper:
     *
     * http://hsrm-mathematik.de/WS201516/master/option-pricing/Black-Scholes-Vasicek-Model.pdf
     */

    class AnalyticBlackVasicekEngine : public VanillaOption::engine {
      public:
        AnalyticBlackVasicekEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>,
                                   ext::shared_ptr<Vasicek>,
                                   Real correlation);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> blackProcess_;
        ext::shared_ptr<Vasicek> vasicekProcess_;
        ext::shared_ptr<Integrator> simpsonIntegral_;
        Real correlation_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="134">
    <source>vanilla/analyticgjrgarchengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Yee Man Chan

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticgjrgarchengine.hpp
    \brief analytic GJR-GARCH-model engine
*/

#ifndef quantlib_analytic_gjrgarch_engine_hpp
#define quantlib_analytic_gjrgarch_engine_hpp

#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/models/equity/gjrgarchmodel.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/math/integrals/gaussianquadratures.hpp>
#include <complex>

namespace QuantLib {

    //! GJR-GARCH(1,1) engine
    /*! References:

    Jin-Chuan Duan, Genevieve Gauthier, Jean-Guy Simonato, 
    Caroline Sasseville, 2006. Approximating the GJR-GARCH
    and EGARCH option pricing models analytically
    Journal of Computational Finance, Volume 9, Number 3,
    Spring 2006

        \ingroup vanillaengines

        \test the correctness of the returned value is tested by
              reproducing results available in the Duan et al's
              2006 paper.
    */

    class AnalyticGJRGARCHEngine
        : public GenericModelEngine<GJRGARCHModel,
                                    VanillaOption::arguments,
                                    VanillaOption::results> {
      public:
        AnalyticGJRGARCHEngine(const ext::shared_ptr<GJRGARCHModel>& model);
        void calculate() const override;
        // call back for extended stochastic volatility
        // plus jump diffusion engines like bates model
      private:
// store parameters
    mutable bool init_;
    mutable Real h1_;
    mutable Real b0_;
    mutable Real b1_;
    mutable Real b2_;
    mutable Real b3_;
    mutable Real la_;
    mutable Real r_;
    mutable Size T_;
// intermediate constants determined by b1,b2,b3,la
    mutable Real m1_;
    mutable Real m2_;
    mutable Real m3_;
    mutable Real v1_;
    mutable Real v2_;
    mutable Real v3_;
    mutable Real z1_;
    mutable Real z2_;
    mutable Real x1_;
// statistical data for the GJR-GARCH process determined by
// h1,b0,b1,b2,b3,r,T
    mutable Real ex_; // mean
    mutable Real sigma_; // variance
    mutable Real k3_; // skewness
    mutable Real k4_; // kurtosis
    };

}

#endif
]]></document_content>
  </document>
  <document index="135">
    <source>vanilla/analytich1hwengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analytich1hwengine.hpp
    \brief analytic Heston-Hull-White engine based on the H1-HW approximation
*/

#ifndef quantlib_analytic_h1_hw_engine_hpp
#define quantlib_analytic_h1_hw_engine_hpp

#include <ql/models/equity/hestonmodel.hpp>
#include <ql/models/shortrate/onefactormodels/hullwhite.hpp>
#include <ql/pricingengines/vanilla/analytichestonhullwhiteengine.hpp>

namespace QuantLib {

    //! Analytic Heston-Hull-White engine based on the H1-HW approximation
    /*! This class is pricing a european option under the following process

        \f[
        \begin{array}{rcl}
        dS(t, S)  &=& (r-d) S dt +\sqrt{v} S dW_1 \\
        dv(t, S)  &=& \kappa (\theta - v) dt + \sigma \sqrt{v} dW_2 \\
        dr(t)     &=& (\theta(t) - a r) dt + \eta dW_3 \\
        dW_1 dW_2 &=& \rho_{S,v} dt, \rho_{S,r} >= 0 \\
        dW_1 dW_3 &=& \rho_{S.r} dt \\
        dW_2 dW_3 &=& 0 dt \\
        \end{array}
        \f]
    */

    /*! References:

        Lech A. Grzelak, Cornelis W. Oosterlee,
        On The Heston Model with Stochastic,
        http://papers.ssrn.com/sol3/papers.cfm?abstract_id=1382902

        Lech A. Grzelak,
        Equity and Foreign Exchange Hybrid Models for
        Pricing Long-Maturity Financial Derivatives,
        http://repository.tudelft.nl/assets/uuid:a8e1a007-bd89-481a-aee3-0e22f15ade6b/PhDThesis_main.pdf

        \ingroup vanillaengines

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature, testing
              against QuantLib's analytic Heston,
              the Black-Scholes-Merton Hull-White engine and
              the finite difference Heston-Hull-White engine
    */

    class AnalyticH1HWEngine : public AnalyticHestonHullWhiteEngine {
      public:
        AnalyticH1HWEngine(const ext::shared_ptr<HestonModel>& model,
                           const ext::shared_ptr<HullWhite>& hullWhiteModel,
                           Real rhoSr, Size integrationOrder = 144);

        AnalyticH1HWEngine(const ext::shared_ptr<HestonModel>& model,
                           const ext::shared_ptr<HullWhite>& hullWhiteModel,
                           Real rhoSr, Real relTolerance, Size maxEvaluations);

      protected:
        std::complex<Real> addOnTerm(Real phi, Time t, Size j) const override;

      private:
        class Fj_Helper;

        const Real rhoSr_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="136">
    <source>vanilla/analytichestonengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2005, 2008 Klaus Spanderen
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analytichestonengine.hpp
    \brief analytic Heston-model engine
*/

#ifndef quantlib_analytic_heston_engine_hpp
#define quantlib_analytic_heston_engine_hpp

#include <ql/utilities/null.hpp>
#include <ql/math/integrals/integral.hpp>
#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <functional>
#include <complex>

namespace QuantLib {

    //! analytic Heston-model engine based on Fourier transform

    /*! Integration detail:
        Two algebraically equivalent formulations of the complex
        logarithm of the Heston model exist. Gatherals [2005]
        (also Duffie, Pan and Singleton [2000], and Schoutens,
        Simons and Tistaert[2004]) version does not cause
        discoutinuities whereas the original version (e.g. Heston [1993])
        needs some sort of "branch correction" to work properly.
        Gatheral's version does also work with adaptive integration
        routines and should be preferred over the original Heston version.
    */

    /*! References:

        Heston, Steven L., 1993. A Closed-Form Solution for Options
        with Stochastic Volatility with Applications to Bond and
        Currency Options.  The review of Financial Studies, Volume 6,
        Issue 2, 327-343.

        A. Sepp, Pricing European-Style Options under Jump Diffusion
        Processes with Stochastic Volatility: Applications of Fourier
        Transform (<http://math.ut.ee/~spartak/papers/stochjumpvols.pdf>)

        R. Lord and C. Kahl, Why the rotation count algorithm works,
        http://papers.ssrn.com/sol3/papers.cfm?abstract_id=921335

        H. Albrecher, P. Mayer, W.Schoutens and J. Tistaert,
        The Little Heston Trap, http://www.schoutens.be/HestonTrap.pdf

        J. Gatheral, The Volatility Surface: A Practitioner's Guide,
        Wiley Finance

        F. Le Floc'h, Fourier Integration and Stochastic Volatility
        Calibration,
        https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2362968

        L. Andersen, and V. Piterbarg, 2010,
        Interest Rate Modeling, Volume I: Foundations and Vanilla Models,
        Atlantic Financial Press London.

        L. Andersen and M. Lake, 2018
        Robust High-Precision Option Pricing by Fourier Transforms:
        Contour Deformations and Double-Exponential Quadrature,
        https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3231626

        \ingroup vanillaengines

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature
              and comparison with Black pricing.
    */
    class AnalyticHestonEngine
        : public GenericModelEngine<HestonModel,
                                    VanillaOption::arguments,
                                    VanillaOption::results> {
      public:
        class Integration;
        class OptimalAlpha;
        class AP_Helper;

        enum ComplexLogFormula {
            // Gatheral form of characteristic function w/o control variate
            Gatheral,
            // old branch correction form of the characteristic function w/o control variate
            BranchCorrection,
            // Gatheral form with Andersen-Piterbarg control variate
            AndersenPiterbarg,
            // same as AndersenPiterbarg, but a slightly better control variate
            AndersenPiterbargOptCV,
            // Gatheral form with asymptotic expansion of the characteristic function as control variate
            // https://hpcquantlib.wordpress.com/2020/08/30/a-novel-control-variate-for-the-heston-model
            AsymptoticChF,
            // angled contour shift integral with control variate
            AngledContour,
            // angled contour shift integral w/o control variate
            AngledContourNoCV,
            // auto selection of best control variate algorithm from above
            OptimalCV
        };

        // Simple to use constructor: Using adaptive
        // Gauss-Lobatto integration and Gatheral's version of complex log.
        // Be aware: using a too large number for maxEvaluations might result
        // in a stack overflow as the Lobatto integration is a recursive
        // algorithm.
        AnalyticHestonEngine(const ext::shared_ptr<HestonModel>& model,
                             Real relTolerance, Size maxEvaluations);

        // Constructor using Laguerre integration
        // and Gatheral's version of complex log.
        AnalyticHestonEngine(const ext::shared_ptr<HestonModel>& model,
                             Size integrationOrder = 144);

        // Constructor giving full control
        // over the Fourier integration algorithm
        AnalyticHestonEngine(const ext::shared_ptr<HestonModel>& model,
                             ComplexLogFormula cpxLog, const Integration& itg,
                             Real andersenPiterbargEpsilon = 1e-25,
                             Real alpha = -0.5);

        void calculate() const override;

        // normalized characteristic function
        std::complex<Real> chF(const std::complex<Real>& z, Time t) const;
        std::complex<Real> lnChF(const std::complex<Real>& z, Time t) const;

        Size numberOfEvaluations() const;

        [[deprecated("Use AnalyticHestonEngine::priceVanillaPayoff instead.")]]
        static void doCalculation(Real riskFreeDiscount,
                                  Real dividendDiscount,
                                  Real spotPrice,
                                  Real strikePrice,
                                  Real term,
                                  Real kappa,
                                  Real theta,
                                  Real sigma,
                                  Real v0,
                                  Real rho,
                                  const TypePayoff& type,
                                  const Integration& integration,
                                  ComplexLogFormula cpxLog,
                                  const AnalyticHestonEngine* enginePtr,
                                  Real& value,
                                  Size& evaluations);

        Real priceVanillaPayoff(
           const ext::shared_ptr<PlainVanillaPayoff>& payoff,
           const Date& maturity) const;

        Real priceVanillaPayoff(
           const ext::shared_ptr<PlainVanillaPayoff>& payoff, Time maturity) const;

        static ComplexLogFormula optimalControlVariate(
             Time t, Real v0, Real kappa, Real theta, Real sigma, Real rho);

      protected:
        // call back for extended stochastic volatility
        // plus jump diffusion engines like bates model
        virtual std::complex<Real> addOnTerm(Real phi,
                                             Time t,
                                             Size j) const;

      private:
        class Fj_Helper;

        Real priceVanillaPayoff(
           const ext::shared_ptr<PlainVanillaPayoff>& payoff,
           Time maturity, Real fwd) const;


        mutable Size evaluations_;
        const ComplexLogFormula cpxLog_;
        const ext::shared_ptr<Integration> integration_;
        const Real andersenPiterbargEpsilon_, alpha_;
    };


    class AnalyticHestonEngine::Integration {
      public:
        // non adaptive integration algorithms based on Gaussian quadrature
        static Integration gaussLaguerre    (Size integrationOrder = 128);
        static Integration gaussLegendre    (Size integrationOrder = 128);
        static Integration gaussChebyshev   (Size integrationOrder = 128);
        static Integration gaussChebyshev2nd(Size integrationOrder = 128);

        // Gatheral's version has to be used for an adaptive integration
        // algorithm .Be aware: using a too large number for maxEvaluations might
        // result in a stack overflow as the these integrations are based on
        // recursive algorithms.
        static Integration gaussLobatto(Real relTolerance, Real absTolerance,
                                        Size maxEvaluations = 1000,
                                        bool useConvergenceEstimate = false);

        // usually these routines have a poor convergence behavior.
        static Integration gaussKronrod(Real absTolerance,
                                        Size maxEvaluations = 1000);
        static Integration simpson(Real absTolerance,
                                   Size maxEvaluations = 1000);
        static Integration trapezoid(Real absTolerance,
                                     Size maxEvaluations = 1000);
        static Integration discreteSimpson(Size evaluation = 1000);
        static Integration discreteTrapezoid(Size evaluation = 1000);
        static Integration expSinh(Real relTolerance = 1e-8);

        static Real andersenPiterbargIntegrationLimit(
            Real c_inf, Real epsilon, Real v0, Real t);

        Real calculate(Real c_inf,
                       const std::function<Real(Real)>& f,
                       const std::function<Real()>& maxBound = {},
                       Real scaling = 1.0) const;

        Real calculate(Real c_inf,
                       const std::function<Real(Real)>& f,
                       Real maxBound) const;

        Size numberOfEvaluations() const;
        bool isAdaptiveIntegration() const;

      private:
        enum Algorithm
            { GaussLobatto, GaussKronrod, Simpson, Trapezoid,
              DiscreteTrapezoid, DiscreteSimpson,
              GaussLaguerre, GaussLegendre,
              GaussChebyshev, GaussChebyshev2nd,
              ExpSinh};

        Integration(Algorithm intAlgo, ext::shared_ptr<GaussianQuadrature> quadrature);

        Integration(Algorithm intAlgo, ext::shared_ptr<Integrator> integrator);

        const Algorithm intAlgo_;
        const ext::shared_ptr<Integrator> integrator_;
        const ext::shared_ptr<GaussianQuadrature> gaussianQuadrature_;
    };

    class AnalyticHestonEngine::AP_Helper {
      public:
        AP_Helper(Time term, Real fwd, Real strike,
                  ComplexLogFormula cpxLog,
                  const AnalyticHestonEngine* enginePtr,
                  Real alpha = -0.5);

        Real operator()(Real u) const;
        Real controlVariateValue() const;

      private:
        const Time term_;
        const Real fwd_, strike_, freq_;
        const ComplexLogFormula cpxLog_;
        const AnalyticHestonEngine* const enginePtr_;
        const Real alpha_, s_alpha_;
        Real vAvg_, tanPhi_;
        std::complex<Real> phi_, psi_;
    };


    class AnalyticHestonEngine::OptimalAlpha {
      public:
        OptimalAlpha(
            Time t,
            const AnalyticHestonEngine* enginePtr);

        Real operator()(Real strike) const;
        std::pair<Real, Real> alphaGreaterZero(Real strike) const;
        std::pair<Real, Real> alphaSmallerMinusOne(Real strike) const;

        Size numberOfEvaluations() const;
        Real M(Real k) const;
        Real k(Real x, Integer sgn) const;
        Real alphaMin(Real strike) const;
        Real alphaMax(Real strike) const;

      private:
        std::pair<Real, Real> findMinima(Real lower, Real upper, Real strike) const;

        const Real t_, fwd_, kappa_, theta_, sigma_, rho_;

        const Real eps_;

        const AnalyticHestonEngine* const enginePtr_;
        Real km_, kp_;
        mutable Size evaluations_ = 0;
    };


    inline std::complex<Real> AnalyticHestonEngine::addOnTerm(
        Real, Time, Size) const {
        return std::complex<Real>(0,0);
    }
}

#endif
]]></document_content>
  </document>
  <document index="137">
    <source>vanilla/analytichestonhullwhiteengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Klaus Spanderen
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analytichestonhullwhiteengine.hpp
    \brief analytic heston engine incl. stochastic interest rates
*/

#ifndef quantlib_analytic_heston_hull_white_engine_hpp
#define quantlib_analytic_heston_hull_white_engine_hpp

#include <ql/models/equity/hestonmodel.hpp>
#include <ql/models/shortrate/onefactormodels/hullwhite.hpp>
#include <ql/pricingengines/vanilla/analytichestonengine.hpp>

namespace QuantLib {

    //! Analytic Heston engine incl. stochastic interest rates
    /*! This class is pricing a european option under the following process

        \f[
        \begin{array}{rcl}
        dS(t, S)  &=& (r-d) S dt +\sqrt{v} S dW_1 \\
        dv(t, S)  &=& \kappa (\theta - v) dt + \sigma \sqrt{v} dW_2 \\
        dr(t)     &=& (\theta(t) - a r) dt + \eta dW_3 \\
        dW_1 dW_2 &=& \rho dt \\
        dW_1 dW_3 &=& 0 \\
        dW_2 dW_3 &=& 0 \\
        \end{array}
        \f]

        References:

        Karel in't Hout, Joris Bierkens, Antoine von der Ploeg,
        Joe in't Panhuis, A Semi closed-from analytic pricing formula for
        call options in a hybrid Heston-Hull-White Model.

        A. Sepp, Pricing European-Style Options under Jump Diffusion
        Processes with Stochastic Volatility: Applications of Fourier
        Transform (<http://math.ut.ee/~spartak/papers/stochjumpvols.pdf>)

        \ingroup vanillaengines

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature, testing
              against QuantLib's analytic Heston and
              Black-Scholes-Merton Hull-White engine
    */
    class AnalyticHestonHullWhiteEngine : public AnalyticHestonEngine {
      public:
        // see AnalticHestonEninge for usage of different constructors
        AnalyticHestonHullWhiteEngine(const ext::shared_ptr<HestonModel>& hestonModel,
                                      ext::shared_ptr<HullWhite> hullWhiteModel,
                                      Size integrationOrder = 144);

        AnalyticHestonHullWhiteEngine(const ext::shared_ptr<HestonModel>& model,
                                      ext::shared_ptr<HullWhite> hullWhiteModel,
                                      Real relTolerance,
                                      Size maxEvaluations);


        void update() override;
        void calculate() const override;

      protected:
        std::complex<Real> addOnTerm(Real phi, Time t, Size j) const override;

        const ext::shared_ptr<HullWhite> hullWhiteModel_;

      private:
        void setParameters();
        mutable Real m_;
        mutable Real a_, sigma_;
    };

    inline
    std::complex<Real> AnalyticHestonHullWhiteEngine::addOnTerm(Real u,
                                                                Time,
                                                                Size j) const {
        return std::complex<Real>(-m_*u*u, u*(m_-2*m_*(j-1)));
    }

}

#endif
]]></document_content>
  </document>
  <document index="138">
    <source>vanilla/analyticpdfhestonengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticpdfhestonengine.hpp
    \brief Analytic engine for arbitrary European payoffs under the Heston model
*/

#ifndef quantlib_analytic_pdf_heston_engine_hpp
#define quantlib_analytic_pdf_heston_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>

namespace QuantLib {

    //! Analytic engine for arbitrary European payoffs under the Heston model

    /*! References:

        The formulas are taken from A. Dragulescu, V. Yakovenko, 2002.
        Probability distribution of returns in the Heston model
        with stochastic volatility.
        http://arxiv.org/pdf/cond-mat/0203046.pdf

        \test the correctness of the returned value is tested by
              reproducing digital prices using call spreads and the
              AnalyticHestonEngine.

    */
    class AnalyticPDFHestonEngine
       : public GenericModelEngine<HestonModel,
                                   VanillaOption::arguments,
                                   VanillaOption::results> {
      public:
        explicit AnalyticPDFHestonEngine(ext::shared_ptr<HestonModel> model,
                                         Real gaussLobattoEps = 1e-6,
                                         Size gaussLobattoIntegrationOrder = 10000UL);
        void calculate() const override;


        // probability in x_t = ln(s_t)
        Real Pv(Real x_t, Time t) const;

        // cumulative distribution function Pr(x < X)
        Real cdf(Real X, Time t) const;

      private:
        Real weightedPayoff(Real x_t, Time t) const;

        const Size maxIntegrationIterations_;
        const Real integrationEps_;

        const ext::shared_ptr<HestonModel> model_;
    };
}


#endif
]]></document_content>
  </document>
  <document index="139">
    <source>vanilla/analyticptdhestonengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2017 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticptdhestonengine.hpp
    \brief analytic piecewise time dependent Heston-model engine
*/

#ifndef quantlib_analytic_piecewise_time_dependent_heston_engine_hpp
#define quantlib_analytic_piecewise_time_dependent_heston_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/pricingengines/vanilla/analytichestonengine.hpp>
#include <ql/models/equity/piecewisetimedependenthestonmodel.hpp>


namespace QuantLib {

    //! analytic piecewise constant time dependent Heston-model engine

    /*! References:

        Heston, Steven L., 1993. A Closed-Form Solution for Options
        with Stochastic Volatility with Applications to Bond and
        Currency Options.  The review of Financial Studies, Volume 6,
        Issue 2, 327-343.

        J. Gatheral, The Volatility Surface: A Practitioner's Guide,
        Wiley Finance

        A. Elices, Models with time-dependent parameters using 
        transform methods: application to Heston’s model,
        http://arxiv.org/pdf/0708.2020

        \ingroup vanillaengines
    */
    class AnalyticPTDHestonEngine
        : public GenericModelEngine<PiecewiseTimeDependentHestonModel,
                                    VanillaOption::arguments,
                                    VanillaOption::results> {
      public:
        enum ComplexLogFormula { Gatheral, AndersenPiterbarg };
        typedef AnalyticHestonEngine::Integration Integration;

        // Simple to use constructor: Using adaptive
        // Gauss-Lobatto integration and Gatheral's version of complex log.
        // Be aware: using a too large number for maxEvaluations might result
        // in a stack overflow as the Lobatto integration is a recursive
        // algorithm.
        AnalyticPTDHestonEngine(
            const ext::shared_ptr<PiecewiseTimeDependentHestonModel>& model,
            Real relTolerance, Size maxEvaluations);

        // Constructor using Laguerre integration
        // and Gatheral's version of complex log.
        explicit AnalyticPTDHestonEngine(
            const ext::shared_ptr<PiecewiseTimeDependentHestonModel>& model,
            Size integrationOrder = 144);

        // Constructor giving full control over Fourier integration algorithm
        AnalyticPTDHestonEngine(
            const ext::shared_ptr<PiecewiseTimeDependentHestonModel>& model,
            ComplexLogFormula cpxLog,
            const Integration& itg,
            Real andersenPiterbargEpsilon = 1e-8);


        void calculate() const override;
        Size numberOfEvaluations() const;

        // normalized characteristic function
        std::complex<Real> chF(const std::complex<Real>& z, Time t) const;
        std::complex<Real> lnChF(const std::complex<Real>& z, Time t) const;

      private:
        class Fj_Helper;
        class AP_Helper;
        
        mutable Size evaluations_;
        const ComplexLogFormula cpxLog_;
        const ext::shared_ptr<Integration> integration_;
        const Real andersenPiterbargEpsilon_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="140">
    <source>vanilla/baroneadesiwhaleyengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file baroneadesiwhaleyengine.hpp
    \brief Barone-Adesi and Whaley approximation engine
*/

#ifndef quantlib_barone_adesi_whaley_engine_hpp
#define quantlib_barone_adesi_whaley_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Barone-Adesi and Whaley pricing engine for American options (1987)
    /*! \ingroup vanillaengines

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class BaroneAdesiWhaleyApproximationEngine
        : public VanillaOption::engine {
      public:
        BaroneAdesiWhaleyApproximationEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);
        static Real criticalPrice(
            const ext::shared_ptr<StrikedTypePayoff>& payoff,
            DiscountFactor riskFreeDiscount,
            DiscountFactor dividendDiscount,
            Real variance,
            Real tolerance = 1e-6);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="141">
    <source>vanilla/batesengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Klaus Spanderen
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file batesengine.hpp
    \brief analytic Bates model engine
*/

#ifndef quantlib_bates_engine_hpp
#define quantlib_bates_engine_hpp

#include <ql/qldefines.hpp>
#include <ql/models/equity/batesmodel.hpp>
#include <ql/pricingengines/vanilla/analytichestonengine.hpp>

namespace QuantLib {

    //! Bates model engines based on Fourier transform
    /*! this classes price european options under the following processes

        1. Jump-Diffusion with Stochastic Volatility

        \f[
        \begin{array}{rcl}
        dS(t, S)  &=& (r-d-\lambda m) S dt +\sqrt{v} S dW_1 + (e^J - 1) S dN \\
        dv(t, S)  &=& \kappa (\theta - v) dt + \sigma \sqrt{v} dW_2 \\
        dW_1 dW_2 &=& \rho dt
        \end{array}
        \f]

        N is a Poisson process with the intensity \f$ \lambda
        \f$. When a jump occurs the magnitude J has the probability
        density function \f$ \omega(J) \f$.

        1.1 Log-Normal Jump Diffusion: BatesEngine

        Logarithm of the jump size J is normally distributed
        \f[
        \omega(J) = \frac{1}{\sqrt{2\pi \delta^2}}
                    \exp\left[-\frac{(J-\nu)^2}{2\delta^2}\right]
        \f]

        1.2  Double-Exponential Jump Diffusion: BatesDoubleExpEngine

        The jump size has an asymmetric double exponential distribution
        \f[
        \begin{array}{rcl}
        \omega(J)&=&  p\frac{1}{\eta_u}e^{-\frac{1}{\eta_u}J} 1_{J>0}
                    + q\frac{1}{\eta_d}e^{\frac{1}{\eta_d}J} 1_{J<0} \\
        p + q &=& 1
        \end{array}
        \f]

        2. Stochastic Volatility with Jump Diffusion
           and Deterministic Jump Intensity

        \f[
        \begin{array}{rcl}
        dS(t, S)  &=& (r-d-\lambda m) S dt +\sqrt{v} S dW_1 + (e^J - 1) S dN \\
        dv(t, S)  &=& \kappa (\theta - v) dt + \sigma \sqrt{v} dW_2 \\
        d\lambda(t) &=& \kappa_\lambda(\theta_\lambda-\lambda) dt \\
        dW_1 dW_2 &=& \rho dt
        \end{array}
        \f]

        2.1 Log-Normal Jump Diffusion with Deterministic Jump Intensity
              BatesDetJumpEngine

        2.2 Double-Exponential Jump Diffusion with Deterministic Jump Intensity
              BatesDoubleExpDetJumpEngine


        References:

        D. Bates, Jumps and stochastic volatility: exchange rate processes
        implicit in Deutsche mark options,
        Review of Financial Sudies 9, 69-107.

        A. Sepp, Pricing European-Style Options under Jump Diffusion
        Processes with Stochastic Volatility: Applications of Fourier
        Transform (<http://math.ut.ee/~spartak/papers/stochjumpvols.pdf>)

        \ingroup vanillaengines

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature, testing
              against QuantLib's jump diffusion engine
              and comparison with Black pricing.
    */
    class BatesEngine : public AnalyticHestonEngine {
      public:
        explicit BatesEngine(const ext::shared_ptr<BatesModel>& model,
                             Size integrationOrder = 144);
        BatesEngine(const ext::shared_ptr<BatesModel>& model,
                    Real relTolerance, Size maxEvaluations);

      protected:
        std::complex<Real> addOnTerm(Real phi, Time t, Size j) const override;
    };


    class BatesDetJumpEngine : public BatesEngine {
      public:
        explicit BatesDetJumpEngine(const ext::shared_ptr<BatesDetJumpModel>& model,
                                    Size integrationOrder = 144);
        BatesDetJumpEngine(const ext::shared_ptr<BatesDetJumpModel>& model,
                           Real relTolerance, Size maxEvaluations);

      protected:
        std::complex<Real> addOnTerm(Real phi, Time t, Size j) const override;
    };


    class BatesDoubleExpEngine : public AnalyticHestonEngine {
      public:
        explicit BatesDoubleExpEngine(
            const ext::shared_ptr<BatesDoubleExpModel>& model,
            Size integrationOrder = 144);
        BatesDoubleExpEngine(
            const ext::shared_ptr<BatesDoubleExpModel>& model,
            Real relTolerance, Size maxEvaluations);

      protected:
        std::complex<Real> addOnTerm(Real phi, Time t, Size j) const override;
    };


    class BatesDoubleExpDetJumpEngine : public BatesDoubleExpEngine {
      public:
        explicit BatesDoubleExpDetJumpEngine(
            const ext::shared_ptr<BatesDoubleExpDetJumpModel>& model,
            Size integrationOrder = 144);
        BatesDoubleExpDetJumpEngine(
            const ext::shared_ptr<BatesDoubleExpDetJumpModel>& model,
            Real relTolerance, Size maxEvaluations);

      protected:
        std::complex<Real> addOnTerm(Real phi, Time t, Size j) const override;
    };

}

#endif
]]></document_content>
  </document>
  <document index="142">
    <source>vanilla/binomialengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2007 StatPro Italia srl
 Copyright (C) 2007 Affine Group Limited

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file binomialengine.hpp
    \brief Binomial option engine
*/

#ifndef quantlib_binomial_engine_hpp
#define quantlib_binomial_engine_hpp

#include <ql/methods/lattices/binomialtree.hpp>
#include <ql/methods/lattices/bsmlattice.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/pricingengines/vanilla/discretizedvanillaoption.hpp>
#include <ql/pricingengines/greeks.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>

namespace QuantLib {

    //! Pricing engine for vanilla options using binomial trees
    /*! \ingroup vanillaengines

        \test the correctness of the returned values is tested by
              checking it against analytic results.

        \todo Greeks are not overly accurate. They could be improved
              by building a tree so that it has three points at the
              current time. The value would be fetched from the middle
              one, while the two side points would be used for
              estimating partial derivatives.
    */
    template <class T>
    class BinomialVanillaEngine : public VanillaOption::engine {
      public:
        BinomialVanillaEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                              Size timeSteps)
        : process_(std::move(process)), timeSteps_(timeSteps) {
            QL_REQUIRE(timeSteps >= 2,
                       "at least 2 time steps required, "
                       << timeSteps << " provided");
            registerWith(process_);
        }
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Size timeSteps_;
    };


    // template definitions

    template <class T>
    void BinomialVanillaEngine<T>::calculate() const {

        DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
        DayCounter divdc = process_->dividendYield()->dayCounter();
        DayCounter voldc = process_->blackVolatility()->dayCounter();
        Calendar volcal = process_->blackVolatility()->calendar();

        Real s0 = process_->stateVariable()->value();
        QL_REQUIRE(s0 > 0.0, "negative or null underlying given");
        Volatility v = process_->blackVolatility()->blackVol(
            arguments_.exercise->lastDate(), s0);
        Date maturityDate = arguments_.exercise->lastDate();
        Rate r = process_->riskFreeRate()->zeroRate(maturityDate,
            rfdc, Continuous, NoFrequency);
        Rate q = process_->dividendYield()->zeroRate(maturityDate,
            divdc, Continuous, NoFrequency);
        Date referenceDate = process_->riskFreeRate()->referenceDate();

        // binomial trees with constant coefficient
        Handle<YieldTermStructure> flatRiskFree(
            ext::shared_ptr<YieldTermStructure>(
                new FlatForward(referenceDate, r, rfdc)));
        Handle<YieldTermStructure> flatDividends(
            ext::shared_ptr<YieldTermStructure>(
                new FlatForward(referenceDate, q, divdc)));
        Handle<BlackVolTermStructure> flatVol(
            ext::shared_ptr<BlackVolTermStructure>(
                new BlackConstantVol(referenceDate, volcal, v, voldc)));

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        Time maturity = rfdc.yearFraction(referenceDate, maturityDate);

        ext::shared_ptr<StochasticProcess1D> bs(
                         new GeneralizedBlackScholesProcess(
                                      process_->stateVariable(),
                                      flatDividends, flatRiskFree, flatVol));

        TimeGrid grid(maturity, timeSteps_);

        ext::shared_ptr<T> tree(new T(bs, maturity, timeSteps_,
                                        payoff->strike()));

        ext::shared_ptr<BlackScholesLattice<T> > lattice(
            new BlackScholesLattice<T>(tree, r, maturity, timeSteps_));

        DiscretizedVanillaOption option(arguments_, *process_, grid);

        option.initialize(lattice, maturity);

        // Partial derivatives calculated from various points in the
        // binomial tree 
        // (see J.C.Hull, "Options, Futures and other derivatives", 6th edition, pp 397/398)

        // Rollback to third-last step, and get underlying prices (s2) &
        // option values (p2) at this point
        option.rollback(grid[2]);
        Array va2(option.values());
        QL_ENSURE(va2.size() == 3, "Expect 3 nodes in grid at second step");
        Real p2u = va2[2]; // up
        Real p2m = va2[1]; // mid
        Real p2d = va2[0]; // down (low)
        Real s2u = lattice->underlying(2, 2); // up price
        Real s2m = lattice->underlying(2, 1); // middle price
        Real s2d = lattice->underlying(2, 0); // down (low) price

        // calculate gamma by taking the first derivate of the two deltas
        Real delta2u = (p2u - p2m)/(s2u-s2m);
        Real delta2d = (p2m-p2d)/(s2m-s2d);
        Real gamma = (delta2u - delta2d) / ((s2u-s2d)/2);

        // Rollback to second-last step, and get option values (p1) at
        // this point
        option.rollback(grid[1]);
        Array va(option.values());
        QL_ENSURE(va.size() == 2, "Expect 2 nodes in grid at first step");
        Real p1u = va[1];
        Real p1d = va[0];
        Real s1u = lattice->underlying(1, 1); // up (high) price
        Real s1d = lattice->underlying(1, 0); // down (low) price

        Real delta = (p1u - p1d) / (s1u - s1d);

        // Finally, rollback to t=0
        option.rollback(0.0);
        Real p0 = option.presentValue();

        // Store results
        results_.value = p0;
        results_.delta = delta;
        results_.gamma = gamma;
        results_.theta = blackScholesTheta(process_,
                                           results_.value,
                                           results_.delta,
                                           results_.gamma);
    }

}


#endif
]]></document_content>
  </document>
  <document index="143">
    <source>vanilla/bjerksundstenslandengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bjerksundstenslandengine.hpp
    \brief Bjerksund and Stensland approximation engine
*/

#ifndef quantlib_bjerkland_stensland_engine_hpp
#define quantlib_bjerkland_stensland_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Bjerksund and Stensland pricing engine for American options (1993)
    /*! \ingroup vanillaengines

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class BjerksundStenslandApproximationEngine
        : public VanillaOption::engine {
      public:
        BjerksundStenslandApproximationEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);
        void calculate() const override;

      private:
        OneAssetOption::results americanCallApproximation(
            Real S, Real X, Real rfD, Real dD, Real variance) const;
        OneAssetOption::results europeanCallResults(
            Real S, Real X, Real rfD, Real dD, Real variance) const;
        OneAssetOption::results immediateExercise(Real S, Real X) const;


        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="144">
    <source>vanilla/cashdividendeuropeanengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2025 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cashdividendeuropeanengine.hpp
    \brief European engine for spot and escrowed cash dividends
*/

#ifndef quantlib_cash_dividend_european_engine_hpp
#define quantlib_cash_dividend_european_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>


namespace QuantLib {

    //! (Semi)-Analytic pricing engine for European options with cash dividends

    /*! References:

        Jherek Healy, 2021. The Pricing of Vanilla Options with Cash Dividends as
        a Classic Vanilla Basket Option Problem,
        https://arxiv.org/pdf/2106.12971

         \ingroup vanillaengines

        \test the correctness of the returned greeks is tested by
              reproducing numerical derivatives.
    */

    class CashDividendEuropeanEngine : public VanillaOption::engine {
      public:
        enum CashDividendModel { Spot, Escrowed };

        CashDividendEuropeanEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process,
            DividendSchedule dividends,
            CashDividendModel cashDividendModel = Spot);

        void calculate() const override;

      private:
        const ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        const DividendSchedule dividends_;
        const CashDividendModel cashDividendModel_;
    };


}

#endif
]]></document_content>
  </document>
  <document index="145">
    <source>vanilla/coshestonengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2017 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file coshestonengine.hpp
    \brief Heston engine based on Fourier-Cosine series expansions
*/

#ifndef quantlib_cos_heston_engine_hpp
#define quantlib_cos_heston_engine_hpp

#include <ql/models/equity/hestonmodel.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>

#include <complex>

namespace QuantLib {

    //! COS-method Heston engine based on efficient Fourier series expansions

    /*! References:

        F. Fang, C.W. Oosterlee: A Novel Pricing Method for European Ooptions
        based on Fourier-Cosine Series Expansions,
        http://ta.twi.tudelft.nl/mf/users/oosterle/oosterlee/COS.pdf

        Fabien Le Floc'h: Fourier Integration and Stochastic Volatility
        Calibration,
        https://papers.ssrn.com/sol3/papers2.cfm?abstract_id=2362968

        \ingroup vanillaengines

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature
              and comparison with Black pricing.
    */
    class COSHestonEngine
        : public GenericModelEngine<HestonModel,
                                    VanillaOption::arguments,
                                    VanillaOption::results> {
      public:
        explicit COSHestonEngine(const ext::shared_ptr<HestonModel>& model,
                                 Real L = 16, Size N=200);

        void update() override;
        void calculate() const override;

        // normalized characteristic function
        std::complex<Real> chF(Real u, Real t) const;

        Real c1(Time t) const;
        Real c2(Time t) const;
        Real c3(Time t) const;
        Real c4(Time t) const;

        Real mu(Time t) const;
        Real var(Time t) const;
        Real skew(Time t) const;
        Real kurtosis(Time t) const;

      private:
        Real muT(Time t) const;

        const Real L_;
        const Size N_;
        Real kappa_, theta_, sigma_, rho_, v0_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="146">
    <source>vanilla/discretizedvanillaoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file discretizedvanillaoption.hpp
    \brief discretized vanilla option
*/

#ifndef quantlib_discretized_vanilla_option_h
#define quantlib_discretized_vanilla_option_h

#include <ql/discretizedasset.hpp>
#include <ql/methods/lattices/bsmlattice.hpp>
#include <ql/instruments/vanillaoption.hpp>

namespace QuantLib {

    class DiscretizedVanillaOption : public DiscretizedAsset {
      public:
        DiscretizedVanillaOption(const VanillaOption::arguments&,
                                 const StochasticProcess& process,
                                 const TimeGrid& grid = TimeGrid());

        void reset(Size size) override;

        std::vector<Time> mandatoryTimes() const override { return stoppingTimes_; }

      protected:
        void postAdjustValuesImpl() override;

      private:
        void applySpecificCondition();
        VanillaOption::arguments arguments_;
        std::vector<Time> stoppingTimes_;
    };

}





#endif
]]></document_content>
  </document>
  <document index="147">
    <source>vanilla/exponentialfittinghestonengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file exponentialfittinghestonengine.hpp
    \brief analytic Heston-model engine based on exponential fitting
*/

#ifndef quantlib_exponential_fitting_heston_engine_hpp
#define quantlib_exponential_fitting_heston_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/pricingengines/vanilla/analytichestonengine.hpp>

#include <vector>

namespace QuantLib {
    class AnalyticHestonEngine;

    //! analytic Heston-model engine based on
    //  exponentially fitted Gauss-Laguerre quadrature

    /*! References:
        D. Conte, L. Ixaru, B. Paternoster, G. Santomauro, 2014
        Exponentially-fitted Gauss–Laguerre quadrature rule for
        integrals over an unbounded interval

        For adaptation details see
        https://hpcquantlib.wordpress.com/2020/05/17/optimized-heston-model-integration-exponentially-fitted-gauss-laguerre-quadrature-rule/
    */


    class ExponentialFittingHestonEngine
        : public GenericModelEngine<HestonModel,
                                    VanillaOption::arguments,
                                    VanillaOption::results> {
      public:
        typedef AnalyticHestonEngine::ComplexLogFormula ControlVariate;

        explicit ExponentialFittingHestonEngine(
            const ext::shared_ptr<HestonModel>& model,
            ControlVariate cv = ControlVariate::OptimalCV,
            Real scaling = Null<Real>(),
            Real alpha = -0.5);

        void calculate() const override;

      private:
        const ControlVariate cv_;
        const Real scaling_, alpha_;
        const ext::shared_ptr<AnalyticHestonEngine> analyticEngine_;

        static std::vector<Real> moneyness_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="148">
    <source>vanilla/fdbatesvanillaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdbatesvanillaengine.hpp
    \brief Partial integro finite-differences Bates vanilla option engine
*/

#ifndef quantlib_fd_bates_vanilla_engine_hpp
#define quantlib_fd_bates_vanilla_engine_hpp

#include <ql/models/equity/batesmodel.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    //! Partial integro finite-differences Bates vanilla option engine
    /*! \ingroup vanillaengines */
    class FdBatesVanillaEngine
        : public GenericModelEngine<BatesModel,
                                    VanillaOption::arguments,
                                    VanillaOption::results> {
      public:
        explicit
        FdBatesVanillaEngine(
            const ext::shared_ptr<BatesModel>& model,
            Size tGrid = 100, Size xGrid = 100, 
            Size vGrid = 50, Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

        FdBatesVanillaEngine(
            const ext::shared_ptr<BatesModel>& model,
            DividendSchedule dividends,
            Size tGrid = 100, Size xGrid = 100, 
            Size vGrid = 50, Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

        void calculate() const override;

      private:
        DividendSchedule dividends_;
        const Size tGrid_, xGrid_, vGrid_, dampingSteps_;
        const FdmSchemeDesc schemeDesc_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="149">
    <source>vanilla/fdblackscholesshoutengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdblackscholesshoutengine.hpp
    \brief Finite-Differences Black Scholes shout option engine
*/

#ifndef quantlib_fd_black_scholes_shout_engine_hpp
#define quantlib_fd_black_scholes_shout_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    class GeneralizedBlackScholesProcess;

    class FdBlackScholesShoutEngine : public VanillaOption::engine {
      public:
        // Constructor
        explicit FdBlackScholesShoutEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess>,
            Size tGrid = 100,
            Size xGrid = 100,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas());

        FdBlackScholesShoutEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess>,
            DividendSchedule dividends,
            Size tGrid = 100,
            Size xGrid = 100,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas());

        void calculate() const override;

      private:
        const ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        DividendSchedule dividends_;
        const Size tGrid_, xGrid_, dampingSteps_;
        const FdmSchemeDesc schemeDesc_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="150">
    <source>vanilla/fdblackscholesvanillaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdblackscholesvanillaengine.hpp
    \brief Finite-differences Black Scholes vanilla option engine
*/

#ifndef quantlib_fd_black_scholes_vanilla_engine_hpp
#define quantlib_fd_black_scholes_vanilla_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/pricingengines/vanilla/cashdividendeuropeanengine.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    class FdmQuantoHelper;
    class GeneralizedBlackScholesProcess;

    //! Finite-differences Black Scholes vanilla option engine
    /*! \ingroup vanillaengines

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature
              and comparison with Black pricing.
    */
    class FdBlackScholesVanillaEngine : public VanillaOption::engine {
      public:
        enum CashDividendModel {
            Spot = CashDividendEuropeanEngine::Spot,
            Escrowed = CashDividendEuropeanEngine::Escrowed
        };

        explicit FdBlackScholesVanillaEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess>,
            Size tGrid = 100,
            Size xGrid = 100,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas(),
            bool localVol = false,
            Real illegalLocalVolOverwrite = -Null<Real>(),
            CashDividendModel cashDividendModel = Spot);

        FdBlackScholesVanillaEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess>,
            DividendSchedule dividends,
            Size tGrid = 100,
            Size xGrid = 100,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas(),
            bool localVol = false,
            Real illegalLocalVolOverwrite = -Null<Real>(),
            CashDividendModel cashDividendModel = Spot);

        FdBlackScholesVanillaEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess>,
            ext::shared_ptr<FdmQuantoHelper> quantoHelper,
            Size tGrid = 100,
            Size xGrid = 100,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas(),
            bool localVol = false,
            Real illegalLocalVolOverwrite = -Null<Real>(),
            CashDividendModel cashDividendModel = Spot);

        FdBlackScholesVanillaEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess>,
            DividendSchedule dividends,
            ext::shared_ptr<FdmQuantoHelper> quantoHelper,
            Size tGrid = 100,
            Size xGrid = 100,
            Size dampingSteps = 0,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas(),
            bool localVol = false,
            Real illegalLocalVolOverwrite = -Null<Real>(),
            CashDividendModel cashDividendModel = Spot);

        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        DividendSchedule dividends_;
        Size tGrid_, xGrid_, dampingSteps_;
        FdmSchemeDesc schemeDesc_;
        bool localVol_;
        Real illegalLocalVolOverwrite_;
        ext::shared_ptr<FdmQuantoHelper> quantoHelper_;
        CashDividendModel cashDividendModel_;
    };


    class MakeFdBlackScholesVanillaEngine {
      public:
        explicit MakeFdBlackScholesVanillaEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);

        MakeFdBlackScholesVanillaEngine& withQuantoHelper(
            const ext::shared_ptr<FdmQuantoHelper>& quantoHelper);

        MakeFdBlackScholesVanillaEngine& withTGrid(Size tGrid);
        MakeFdBlackScholesVanillaEngine& withXGrid(Size xGrid);
        MakeFdBlackScholesVanillaEngine& withDampingSteps(
            Size dampingSteps);

        MakeFdBlackScholesVanillaEngine& withFdmSchemeDesc(
            const FdmSchemeDesc& schemeDesc);

        MakeFdBlackScholesVanillaEngine& withLocalVol(bool localVol);
        MakeFdBlackScholesVanillaEngine& withIllegalLocalVolOverwrite(
            Real illegalLocalVolOverwrite);

        MakeFdBlackScholesVanillaEngine& withCashDividends(
            const std::vector<Date>& dividendDates,
            const std::vector<Real>& dividendAmounts);

        MakeFdBlackScholesVanillaEngine& withCashDividendModel(
            FdBlackScholesVanillaEngine::CashDividendModel cashDividendModel);

        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        DividendSchedule dividends_;
        Size tGrid_ = 100, xGrid_ = 100, dampingSteps_ = 0;
        ext::shared_ptr<FdmSchemeDesc> schemeDesc_;
        bool localVol_ = false;
        Real illegalLocalVolOverwrite_;
        ext::shared_ptr<FdmQuantoHelper> quantoHelper_;
        FdBlackScholesVanillaEngine::CashDividendModel cashDividendModel_ = FdBlackScholesVanillaEngine::Spot;
    };

}

#endif
]]></document_content>
  </document>
  <document index="151">
    <source>vanilla/fdcevvanillaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdcevvanillaengine.hpp
    \brief Finite-Differences pricing engine for the CEV model
*/

#ifndef quantlib_fd_cev_vanilla_engine_hpp
#define quantlib_fd_cev_vanilla_engine_hpp

#include <ql/handle.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {
    class YieldTermStructure;

    class FdCEVVanillaEngine : public VanillaOption::engine {
      public:
        FdCEVVanillaEngine(Real f0,
                           Real alpha,
                           Real beta,
                           Handle<YieldTermStructure> discountCurve,
                           Size tGrid = 50,
                           Size xGrid = 400,
                           Size dampingSteps = 0,
                           Real scalingFactor = 1.0,
                           Real eps = 1e-4,
                           const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas());

        void calculate() const override;

      private:
        const Real f0_, alpha_, beta_;
        const Handle<YieldTermStructure> discountCurve_;
        const Size tGrid_, xGrid_, dampingSteps_;
        const Real scalingFactor_, eps_;
        const FdmSchemeDesc schemeDesc_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="152">
    <source>vanilla/fdcirvanillaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Lew Wei Hao

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdcirvanillaengine.hpp
    \brief Finite-differences CIR vanilla option engine
*/

#ifndef quantlib_fd_cir_vanilla_engine_hpp
#define quantlib_fd_cir_vanilla_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/processes/coxingersollrossprocess.hpp>
#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>

namespace QuantLib {

    class FdmQuantoHelper;

    //! Finite-differences CIR vanilla option engine
    /*! \ingroup vanillaengines

        \test the engine has been tested to converge among different schemes.
    */
    class FdCIRVanillaEngine : public VanillaOption::engine {
      public:
        FdCIRVanillaEngine(ext::shared_ptr<CoxIngersollRossProcess> cirProcess,
                           ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess,
                           Size tGrid,
                           Size xGrid,
                           Size vGrid,
                           Size dampingSteps,
                           Real rho,
                           const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::ModifiedHundsdorfer(),
                           ext::shared_ptr<FdmQuantoHelper> quantoHelper = {});

        FdCIRVanillaEngine(ext::shared_ptr<CoxIngersollRossProcess> cirProcess,
                           ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess,
                           DividendSchedule dividends,
                           Size tGrid,
                           Size xGrid,
                           Size vGrid,
                           Size dampingSteps,
                           Real rho,
                           const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::ModifiedHundsdorfer(),
                           ext::shared_ptr<FdmQuantoHelper> quantoHelper = {});

        void calculate() const override;

        FdmSolverDesc getSolverDesc(Real equityScaleFactor) const;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess_;
        ext::shared_ptr<CoxIngersollRossProcess> cirProcess_;
        ext::shared_ptr<FdmQuantoHelper> quantoHelper_;
        DividendSchedule dividends_;
        const Size tGrid_, xGrid_, rGrid_, dampingSteps_;
        const Real rho_;
        const FdmSchemeDesc schemeDesc_;
    };

    class MakeFdCIRVanillaEngine {
      public:
        explicit MakeFdCIRVanillaEngine(ext::shared_ptr<CoxIngersollRossProcess> cirProcess,
                                        ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess,
                                        Real rho);

        MakeFdCIRVanillaEngine& withQuantoHelper(
            const ext::shared_ptr<FdmQuantoHelper>& quantoHelper);

        MakeFdCIRVanillaEngine& withTGrid(Size tGrid);
        MakeFdCIRVanillaEngine& withXGrid(Size xGrid);
        MakeFdCIRVanillaEngine& withRGrid(Size rGrid);
        MakeFdCIRVanillaEngine& withDampingSteps(
            Size dampingSteps);

        MakeFdCIRVanillaEngine& withFdmSchemeDesc(
            const FdmSchemeDesc& schemeDesc);

        MakeFdCIRVanillaEngine& withCashDividends(
            const std::vector<Date>& dividendDates,
            const std::vector<Real>& dividendAmounts);

        operator ext::shared_ptr<PricingEngine>() const;

      private:
        ext::shared_ptr<CoxIngersollRossProcess> cirProcess_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess_;
        DividendSchedule dividends_;
        const Real rho_;
        Size tGrid_ = 10, xGrid_ = 100, rGrid_ = 100, dampingSteps_ = 0;
        ext::shared_ptr<FdmSchemeDesc> schemeDesc_;
        ext::shared_ptr<FdmQuantoHelper> quantoHelper_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="153">
    <source>vanilla/fdhestonhullwhitevanillaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdhestonhullwhitevanillaengine.hpp
    \brief Finite-differences Heston Hull-White vanilla option engine
*/

#ifndef quantlib_fd_heston_hull_white_vanilla_engine_hpp
#define quantlib_fd_heston_hull_white_vanilla_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/processes/hullwhiteprocess.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmhestonhullwhitesolver.hpp>

namespace QuantLib {

    //! Finite-differences Heston Hull-White vanilla option engine
    /*! \ingroup vanillaengines

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature
              and comparison with Black/Heston pricing.
    */
    class FdHestonHullWhiteVanillaEngine
        : public GenericModelEngine<HestonModel,
                                    VanillaOption::arguments,
                                    VanillaOption::results> {
      public:
        FdHestonHullWhiteVanillaEngine(
            const ext::shared_ptr<HestonModel>& model,
            ext::shared_ptr<HullWhiteProcess> hwProcess,
            Real corrEquityShortRate,
            Size tGrid = 50,
            Size xGrid = 100,
            Size vGrid = 40,
            Size rGrid = 20,
            Size dampingSteps = 0,
            bool controlVariate = true,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

        FdHestonHullWhiteVanillaEngine(
            const ext::shared_ptr<HestonModel>& model,
            ext::shared_ptr<HullWhiteProcess> hwProcess,
            DividendSchedule dividends,
            Real corrEquityShortRate,
            Size tGrid = 50,
            Size xGrid = 100,
            Size vGrid = 40,
            Size rGrid = 20,
            Size dampingSteps = 0,
            bool controlVariate = true,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

        void calculate() const override;

        // multiple strikes caching engine
        void update() override;
        void enableMultipleStrikesCaching(const std::vector<Real>& strikes);
        
      private:
        const ext::shared_ptr<HullWhiteProcess> hwProcess_;
        DividendSchedule dividends_;
        const Real corrEquityShortRate_;
        const Size tGrid_, xGrid_, vGrid_, rGrid_;
        const Size dampingSteps_;
        const FdmSchemeDesc schemeDesc_;
        const bool controlVariate_;
        
        std::vector<Real> strikes_;
        mutable std::vector<std::pair<VanillaOption::arguments,
                                      VanillaOption::results> >
                                                            cachedArgs2results_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="154">
    <source>vanilla/fdhestonvanillaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008, 2009, 2014 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdhestonvanillaengine.hpp
    \brief Finite-differences Heston vanilla option engine
*/

#ifndef quantlib_fd_heston_vanilla_engine_hpp
#define quantlib_fd_heston_vanilla_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>

namespace QuantLib {

    class FdmQuantoHelper;

    //! Finite-differences Heston vanilla option engine
    /*! \ingroup vanillaengines

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature
              and comparison with Black pricing.
    */
    class FdHestonVanillaEngine
        : public GenericModelEngine<HestonModel,
                                    VanillaOption::arguments,
                                    VanillaOption::results> {
      public:
        explicit
        FdHestonVanillaEngine(const ext::shared_ptr<HestonModel>& model,
                              Size tGrid = 100,
                              Size xGrid = 100,
                              Size vGrid = 50,
                              Size dampingSteps = 0,
                              const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer(),
                              ext::shared_ptr<LocalVolTermStructure> leverageFct = {},
                              Real mixingFactor = 1.0);

        FdHestonVanillaEngine(const ext::shared_ptr<HestonModel>& model,
                              DividendSchedule dividends,
                              Size tGrid = 100,
                              Size xGrid = 100,
                              Size vGrid = 50,
                              Size dampingSteps = 0,
                              const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer(),
                              ext::shared_ptr<LocalVolTermStructure> leverageFct = {},
                              Real mixingFactor = 1.0);

        FdHestonVanillaEngine(const ext::shared_ptr<HestonModel>& model,
                              ext::shared_ptr<FdmQuantoHelper> quantoHelper,
                              Size tGrid = 100,
                              Size xGrid = 100,
                              Size vGrid = 50,
                              Size dampingSteps = 0,
                              const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer(),
                              ext::shared_ptr<LocalVolTermStructure> leverageFct = {},
                              Real mixingFactor = 1.0);

        FdHestonVanillaEngine(const ext::shared_ptr<HestonModel>& model,
                              DividendSchedule dividends,
                              ext::shared_ptr<FdmQuantoHelper> quantoHelper,
                              Size tGrid = 100,
                              Size xGrid = 100,
                              Size vGrid = 50,
                              Size dampingSteps = 0,
                              const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer(),
                              ext::shared_ptr<LocalVolTermStructure> leverageFct = {},
                              Real mixingFactor = 1.0);

        void calculate() const override;

        // multiple strikes caching engine
        void update() override;
        void enableMultipleStrikesCaching(const std::vector<Real>& strikes);

        // helper method for Heston like engines
        FdmSolverDesc getSolverDesc(Real equityScaleFactor) const;

      private:
        DividendSchedule dividends_;
        const Size tGrid_, xGrid_, vGrid_, dampingSteps_;
        const FdmSchemeDesc schemeDesc_;
        const ext::shared_ptr<LocalVolTermStructure> leverageFct_;
        const ext::shared_ptr<FdmQuantoHelper> quantoHelper_;
        const Real mixingFactor_;

        std::vector<Real> strikes_;
        mutable std::vector<std::pair<VanillaOption::arguments,
                                      VanillaOption::results> >
                                                            cachedArgs2results_;
    };

    class MakeFdHestonVanillaEngine {
      public:
        explicit MakeFdHestonVanillaEngine(ext::shared_ptr<HestonModel> hestonModel);

        MakeFdHestonVanillaEngine& withQuantoHelper(
            const ext::shared_ptr<FdmQuantoHelper>& quantoHelper);

        MakeFdHestonVanillaEngine& withTGrid(Size tGrid);
        MakeFdHestonVanillaEngine& withXGrid(Size xGrid);
        MakeFdHestonVanillaEngine& withVGrid(Size vGrid);
        MakeFdHestonVanillaEngine& withDampingSteps(
            Size dampingSteps);

        MakeFdHestonVanillaEngine& withFdmSchemeDesc(
            const FdmSchemeDesc& schemeDesc);

        MakeFdHestonVanillaEngine& withLeverageFunction(
            ext::shared_ptr<LocalVolTermStructure>& leverageFct);

        MakeFdHestonVanillaEngine& withCashDividends(
            const std::vector<Date>& dividendDates,
            const std::vector<Real>& dividendAmounts);

        operator ext::shared_ptr<PricingEngine>() const;

      private:
        ext::shared_ptr<HestonModel> hestonModel_;
        DividendSchedule dividends_;
        Size tGrid_ = 100, xGrid_ = 100, vGrid_ = 50, dampingSteps_ = 0;
        ext::shared_ptr<FdmSchemeDesc> schemeDesc_;
        ext::shared_ptr<LocalVolTermStructure> leverageFct_;
        ext::shared_ptr<FdmQuantoHelper> quantoHelper_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="155">
    <source>vanilla/fdsabrvanillaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2019 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdsabrvanillaengine.hpp
    \brief Finite-Differences pricing engine for the SABR model
*/

#ifndef quantlib_fd_sabr_vanilla_engine_hpp
#define quantlib_fd_sabr_vanilla_engine_hpp

#include <ql/handle.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {
    class YieldTermStructure;

    class FdSabrVanillaEngine : public VanillaOption::engine {
      public:
        FdSabrVanillaEngine(Real f0,
                            Real alpha,
                            Real beta,
                            Real nu,
                            Real rho,
                            Handle<YieldTermStructure> rTS,
                            Size tGrid = 50,
                            Size fGrid = 400,
                            Size xGrid = 50,
                            Size dampingSteps = 0,
                            Real scalingFactor = 1.0,
                            Real eps = 1e-4,
                            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

        void calculate() const override;

      private:
        const Real f0_, alpha_, beta_, nu_, rho_;
        const Handle<YieldTermStructure> rTS_;
        const Size tGrid_, fGrid_, xGrid_, dampingSteps_;
        const Real scalingFactor_, eps_;
        const FdmSchemeDesc schemeDesc_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="156">
    <source>vanilla/fdsimplebsswingengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdsimplebsswingengine.hpp
    \brief Finite Differences Black-Scholes engine for simple swing options
*/

#ifndef quantlib_fd_simple_bs_swing_engine_hpp
#define quantlib_fd_simple_bs_swing_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/instruments/vanillaswingoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    //! Finite-Differences Black Scholes engine for simple swing options

    class GeneralizedBlackScholesProcess;

    class FdSimpleBSSwingEngine
        : public GenericEngine<VanillaSwingOption::arguments,
                               VanillaSwingOption::results> {
      public:
        explicit FdSimpleBSSwingEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> p,
                                       Size tGrid = 50,
                                       Size xGrid = 100,
                                       const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas());

        void calculate() const override;

      private:
        const ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        const Size tGrid_, xGrid_;
        const FdmSchemeDesc schemeDesc_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="157">
    <source>vanilla/hestonexpansionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Fabien Le Floc'h

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hestonexpansionengine.hpp
    \brief analytic Heston expansion engine
*/

#ifndef quantlib_heston_expansion_engine_hpp
#define quantlib_heston_expansion_engine_hpp

#include <ql/pricingengines/genericmodelengine.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/instruments/vanillaoption.hpp>

namespace QuantLib {

    //! Heston-model engine for European options based on analytic expansions
    /*! References:

        M Forde, A Jacquier, R Lee, The small-time smile and term
        structure of implied volatility under the Heston model
        SIAM Journal on Financial Mathematics, 2012 - SIAM

        M Lorig, S Pagliarani, A Pascucci, Explicit implied vols for
        multifactor local-stochastic vol models
        arXiv preprint arXiv:1306.5447v3, 2014 - arxiv.org

        \ingroup vanillaengines
    */
    class HestonExpansionEngine
        : public GenericModelEngine<HestonModel,
                                    VanillaOption::arguments,
                                    VanillaOption::results> {
      public:
        enum HestonExpansionFormula { LPP2, LPP3, Forde };

        HestonExpansionEngine(const ext::shared_ptr<HestonModel>& model,
                              HestonExpansionFormula formula);

        void calculate() const override;

      private:
        const HestonExpansionFormula formula_;
    };

    /*! Interface to represent some Heston expansion formula.
        During calibration, it would typically be initialized once per
        implied volatility surface slice, then calls for each surface
        strike to impliedVolatility(strike, forward) would be
        performed.
    */
    class HestonExpansion {
      public:
        virtual ~HestonExpansion() = default;
        virtual Real impliedVolatility(Real strike, Real forward) const = 0;
    };

    /*! Lorig Pagliarani Pascucci expansion of order-2 for the Heston model.
        During calibration, it can be initialized once per expiry, and
        called many times with different strikes.  The formula is also
        available in the Mathematica notebook from the authors at
        http://explicitsolutions.wordpress.com/
    */
    class LPP2HestonExpansion : public HestonExpansion {
      public:
        LPP2HestonExpansion(Real kappa, Real theta, Real sigma, Real v0, Real rho, Real term);
        Real impliedVolatility(Real strike, Real forward) const override;

      private:
        Real coeffs[3];
        Real ekt, e2kt, e3kt, e4kt;
        Real z0(Real t, Real kappa, Real theta,
                Real delta, Real y, Real rho) const;
        Real z1(Real t, Real kappa, Real theta,
                Real delta, Real y, Real rho) const;
        Real z2(Real t, Real kappa, Real theta,
                Real delta, Real y, Real rho) const;
    };

    /*! Lorig Pagliarani Pascucci expansion of order-3 for the Heston model.
        During calibration, it can be initialized once per expiry, and
        called many times with different strikes.  The formula is also
        available in the Mathematica notebook from the authors at
        http://explicitsolutions.wordpress.com/
    */
    class LPP3HestonExpansion : public HestonExpansion{
      public:
        LPP3HestonExpansion(Real kappa, Real theta, Real sigma, Real v0, Real rho, Real term);
        Real impliedVolatility(Real strike, Real forward) const override;

      private:
        Real coeffs[4];
        Real ekt, e2kt, e3kt, e4kt;
        Real z0(Real t, Real kappa, Real theta,
                Real delta, Real y, Real rho) const;
        Real z1(Real t, Real kappa, Real theta,
                Real delta, Real y, Real rho) const;
        Real z2(Real t, Real kappa, Real theta,
                Real delta, Real y, Real rho) const;
        Real z3(Real t, Real kappa, Real theta,
                Real delta, Real y, Real rho) const;
    };

    /*! Small-time expansion from
        "The small-time smile and term structure of implied volatility
        under the Heston model" M Forde, A Jacquier, R Lee - SIAM
        Journal on Financial Mathematics, 2012 - SIAM
    */
    class FordeHestonExpansion : public HestonExpansion {
      public:
        FordeHestonExpansion(Real kappa, Real theta, Real sigma, Real v0, Real rho, Real term);
        Real impliedVolatility(Real strike, Real forward) const override;

      private:
        Real coeffs[5];
    };

}


#endif
]]></document_content>
  </document>
  <document index="158">
    <source>vanilla/integralengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file integralengine.hpp
    \brief Integral option engine
*/

#ifndef quantlib_integral_engine_hpp
#define quantlib_integral_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Pricing engine for European vanilla options using integral approach
    /*! \todo define tolerance for calculate()

        \ingroup vanillaengines
    */
    class IntegralEngine : public VanillaOption::engine {
      public:
        IntegralEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="159">
    <source>vanilla/jumpdiffusionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file jumpdiffusionengine.hpp
    \brief Jump diffusion (Merton 1976) engine
*/

#ifndef quantlib_jumpdiffusionengine_h
#define quantlib_jumpdiffusionengine_h

#include <ql/instruments/vanillaoption.hpp>
#include <ql/processes/merton76process.hpp>

namespace QuantLib {

    //! Jump-diffusion engine for vanilla options
    /*! \ingroup vanillaengines

        \test
        - the correctness of the returned value is tested by
          reproducing results available in literature.
        - the correctness of the returned greeks is tested by
          reproducing numerical derivatives.
    */
    class JumpDiffusionEngine : public VanillaOption::engine {
      public:
        JumpDiffusionEngine(ext::shared_ptr<Merton76Process>,
                            Real relativeAccuracy_ = 1e-4,
                            Size maxIterations = 100);
        void calculate() const override;

      private:
        ext::shared_ptr<Merton76Process> process_;
        Real relativeAccuracy_;
        Size maxIterations_;
    };

}





#endif
]]></document_content>
  </document>
  <document index="160">
    <source>vanilla/juquadraticengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Neil Firth
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file juquadraticengine.hpp
    \brief Ju quadratic (1999) approximation engine
*/

#ifndef quantlib_ju_quadratic_engine_hpp
#define quantlib_ju_quadratic_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Pricing engine for American options with Ju quadratic approximation
    /*! Reference:
        An Approximate Formula for Pricing American Options,
        Journal of Derivatives Winter 1999,
        Ju, N.

        \warning Barone-Adesi-Whaley critical commodity price
                 calculation is used, it has not been modified to see
                 whether the method of Ju is faster. Ju does not say
                 how he solves the equation for the critical stock
                 price, e.g. Newton method. He just gives the
                 solution.  The method of BAW gives answers to the
                 same accuracy as in Ju (1999).

        \ingroup vanillaengines

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class JuQuadraticApproximationEngine
        : public VanillaOption::engine {
      public:
        JuQuadraticApproximationEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="161">
    <source>vanilla/mcamericanengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Klaus Spanderen
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2016 Peter Caspers
 Copyright (C) 2022 Jonghee Lee

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mcamericanengine.hpp
    \brief American Monte Carlo engine
*/

#ifndef quantlib_mc_american_engine_hpp
#define quantlib_mc_american_engine_hpp

#include <ql/qldefines.hpp>
#include <ql/payoff.hpp>
#include <ql/exercise.hpp>
#include <ql/optional.hpp>
#include <ql/methods/montecarlo/lsmbasissystem.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/pricingengines/mclongstaffschwartzengine.hpp>
#include <ql/pricingengines/vanilla/mceuropeanengine.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>

namespace QuantLib {

    //! American Monte Carlo engine
    /*! References:

        \ingroup vanillaengines

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature
    */
    template <class RNG = PseudoRandom, class S = Statistics,
              class RNG_Calibration = RNG>
    class MCAmericanEngine
        : public MCLongstaffSchwartzEngine<VanillaOption::engine,
                                           SingleVariate,RNG,S,RNG_Calibration> {
      public:
        MCAmericanEngine(const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
                         Size timeSteps,
                         Size timeStepsPerYear,
                         bool antitheticVariate,
                         bool controlVariate,
                         Size requiredSamples,
                         Real requiredTolerance,
                         Size maxSamples,
                         BigNatural seed,
                         Size polynomialOrder,
                         LsmBasisSystem::PolynomialType polynomialType,
                         Size nCalibrationSamples = Null<Size>(),
                         const ext::optional<bool>& antitheticVariateCalibration = ext::nullopt,
                         BigNatural seedCalibration = Null<Size>());

        void calculate() const override;

      protected:
        ext::shared_ptr<LongstaffSchwartzPathPricer<Path> > lsmPathPricer() const override;

        Real controlVariateValue() const override;
        ext::shared_ptr<PricingEngine> controlPricingEngine() const override;
        ext::shared_ptr<PathPricer<Path> > controlPathPricer() const override;

      private:
        const Size polynomialOrder_;
        const LsmBasisSystem::PolynomialType polynomialType_;
    };

    class AmericanPathPricer : public EarlyExercisePathPricer<Path>  {
      public:
        AmericanPathPricer(ext::shared_ptr<Payoff> payoff,
                           Size polynomialOrder,
                           LsmBasisSystem::PolynomialType polynomialType);

        Real state(const Path& path, Size t) const override;
        Real operator()(const Path& path, Size t) const override;

        std::vector<std::function<Real(Real)> > basisSystem() const override;

      protected:
        Real payoff(Real state) const;

        Real scalingValue_ = 1.0;
        const ext::shared_ptr<Payoff> payoff_;
        std::vector<std::function<Real(Real)> > v_;
    };


    //! Monte Carlo American engine factory
    template <class RNG = PseudoRandom, class S = Statistics,
              class RNG_Calibration = RNG>
    class MakeMCAmericanEngine {
      public:
        MakeMCAmericanEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);
        // named parameters
        MakeMCAmericanEngine& withSteps(Size steps);
        MakeMCAmericanEngine& withStepsPerYear(Size steps);
        MakeMCAmericanEngine& withSamples(Size samples);
        MakeMCAmericanEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCAmericanEngine& withMaxSamples(Size samples);
        MakeMCAmericanEngine& withSeed(BigNatural seed);
        MakeMCAmericanEngine& withAntitheticVariate(bool b = true);
        MakeMCAmericanEngine& withControlVariate(bool b = true);
        MakeMCAmericanEngine& withPolynomialOrder(Size polynomialOrder);
        MakeMCAmericanEngine& withBasisSystem(LsmBasisSystem::PolynomialType);
        MakeMCAmericanEngine& withCalibrationSamples(Size calibrationSamples);
        MakeMCAmericanEngine& withAntitheticVariateCalibration(bool b = true);
        MakeMCAmericanEngine& withSeedCalibration(BigNatural seed);

        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        bool antithetic_ = false, controlVariate_ = false;
        Size steps_, stepsPerYear_;
        Size samples_, maxSamples_, calibrationSamples_ = 2048;
        Real tolerance_;
        BigNatural seed_ = 0;
        Size polynomialOrder_ = 2;
        LsmBasisSystem::PolynomialType polynomialType_ = LsmBasisSystem::Monomial;
        ext::optional<bool> antitheticCalibration_;
        BigNatural seedCalibration_;
    };

    template <class RNG, class S, class RNG_Calibration>
    inline MCAmericanEngine<RNG, S, RNG_Calibration>::MCAmericanEngine(
        const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
        Size timeSteps,
        Size timeStepsPerYear,
        bool antitheticVariate,
        bool controlVariate,
        Size requiredSamples,
        Real requiredTolerance,
        Size maxSamples,
        BigNatural seed,
        Size polynomialOrder,
        LsmBasisSystem::PolynomialType polynomialType,
        Size nCalibrationSamples,
        const ext::optional<bool>& antitheticVariateCalibration,
        BigNatural seedCalibration)
    : MCLongstaffSchwartzEngine<VanillaOption::engine, SingleVariate, RNG, S, RNG_Calibration>(
          process,
          timeSteps,
          timeStepsPerYear,
          false,
          antitheticVariate,
          controlVariate,
          requiredSamples,
          requiredTolerance,
          maxSamples,
          seed,
          nCalibrationSamples,
          false,
          antitheticVariateCalibration,
          seedCalibration),
      polynomialOrder_(polynomialOrder), polynomialType_(polynomialType) {}

    template <class RNG, class S, class RNG_Calibration>
    inline void MCAmericanEngine<RNG, S, RNG_Calibration>::calculate() const {
        MCLongstaffSchwartzEngine<VanillaOption::engine, SingleVariate, RNG, S,
                                  RNG_Calibration>::calculate();
        if (this->controlVariate_) {
            // control variate might lead to small negative
            // option values for deep OTM options
            this->results_.value = std::max(0.0, this->results_.value);
        }
    }

    template <class RNG, class S, class RNG_Calibration>
    inline ext::shared_ptr<LongstaffSchwartzPathPricer<Path> >
    MCAmericanEngine<RNG, S, RNG_Calibration>::lsmPathPricer() const {
        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                                                              this->process_);
        QL_REQUIRE(process, "generalized Black-Scholes process required");

        ext::shared_ptr<EarlyExercise> exercise =
            ext::dynamic_pointer_cast<EarlyExercise>(
                this->arguments_.exercise);
        QL_REQUIRE(exercise, "wrong exercise given");
        QL_REQUIRE(!exercise->payoffAtExpiry(),
                   "payoff at expiry not handled");

        ext::shared_ptr<AmericanPathPricer> earlyExercisePathPricer(
            new AmericanPathPricer(this->arguments_.payoff,
                                   polynomialOrder_, polynomialType_));

        return ext::make_shared<LongstaffSchwartzPathPricer<Path> > (
             
                                      this->timeGrid(),
                                      earlyExercisePathPricer,
                                      *(process->riskFreeRate()));
    }

    template <class RNG, class S, class RNG_Calibration>
    inline ext::shared_ptr<PathPricer<Path> >
    MCAmericanEngine<RNG, S, RNG_Calibration>::controlPathPricer() const {
        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(
                this->arguments_.payoff);
        QL_REQUIRE(payoff, "StrikedTypePayoff needed for control variate");

        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                                                              this->process_);
        QL_REQUIRE(process, "generalized Black-Scholes process required");

        return ext::shared_ptr<PathPricer<Path> >(
            new EuropeanPathPricer(
                payoff->optionType(),
                payoff->strike(),
                process->riskFreeRate()->discount(this->timeGrid().back()))
            );
    }

    template <class RNG, class S, class RNG_Calibration>
    inline ext::shared_ptr<PricingEngine>
    MCAmericanEngine<RNG, S, RNG_Calibration>::controlPricingEngine() const {
        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                                                              this->process_);
        QL_REQUIRE(process, "generalized Black-Scholes process required");

        return ext::shared_ptr<PricingEngine>(
                                         new AnalyticEuropeanEngine(process));
    }

    template <class RNG, class S, class RNG_Calibration>
    inline Real
    MCAmericanEngine<RNG, S, RNG_Calibration>::controlVariateValue() const {
        ext::shared_ptr<PricingEngine> controlPE =
            this->controlPricingEngine();

        QL_REQUIRE(controlPE,
                   "engine does not provide "
                   "control variation pricing engine");

        auto* controlArguments = dynamic_cast<VanillaOption::arguments*>(controlPE->getArguments());
        *controlArguments = this->arguments_;
        controlArguments->exercise = ext::shared_ptr<Exercise>(
             new EuropeanExercise(this->arguments_.exercise->lastDate()));

        controlPE->calculate();

        const auto* controlResults =
            dynamic_cast<const VanillaOption::results*>(controlPE->getResults());

        return controlResults->value;
    }

    template <class RNG, class S, class RNG_Calibration>
    inline MakeMCAmericanEngine<RNG, S, RNG_Calibration>::MakeMCAmericanEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)), steps_(Null<Size>()), stepsPerYear_(Null<Size>()),
      samples_(Null<Size>()), maxSamples_(Null<Size>()), tolerance_(Null<Real>()),
      antitheticCalibration_(ext::nullopt), seedCalibration_(Null<Size>()) {}

    template <class RNG, class S, class RNG_Calibration>
    inline MakeMCAmericanEngine<RNG, S, RNG_Calibration> &
    MakeMCAmericanEngine<RNG, S, RNG_Calibration>::withPolynomialOrder(Size polynomialOrder) {
        polynomialOrder_ = polynomialOrder;
        return *this;
    }

    template <class RNG, class S, class RNG_Calibration>
    inline MakeMCAmericanEngine<RNG, S, RNG_Calibration> &
    MakeMCAmericanEngine<RNG, S, RNG_Calibration>::withBasisSystem(LsmBasisSystem::PolynomialType polynomialType) {
        polynomialType_ = polynomialType;
        return *this;
    }

    template <class RNG, class S, class RNG_Calibration>
    inline MakeMCAmericanEngine<RNG, S, RNG_Calibration> &
    MakeMCAmericanEngine<RNG, S, RNG_Calibration>::withSteps(Size steps) {
        steps_ = steps;
        return *this;
    }

    template <class RNG, class S, class RNG_Calibration>
    inline MakeMCAmericanEngine<RNG, S, RNG_Calibration> &
    MakeMCAmericanEngine<RNG, S, RNG_Calibration>::withStepsPerYear(
        Size steps) {
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG, class S, class RNG_Calibration>
    inline MakeMCAmericanEngine<RNG, S, RNG_Calibration> &
    MakeMCAmericanEngine<RNG, S, RNG_Calibration>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S, class RNG_Calibration>
    inline MakeMCAmericanEngine<RNG, S, RNG_Calibration> &
    MakeMCAmericanEngine<RNG, S, RNG_Calibration>::withAbsoluteTolerance(
        Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S, class RNG_Calibration>
    inline MakeMCAmericanEngine<RNG, S, RNG_Calibration> &
    MakeMCAmericanEngine<RNG, S, RNG_Calibration>::withMaxSamples(
        Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S, class RNG_Calibration>
    inline MakeMCAmericanEngine<RNG, S, RNG_Calibration> &
    MakeMCAmericanEngine<RNG, S, RNG_Calibration>::withCalibrationSamples(
        Size samples) {
        calibrationSamples_ = samples;
        return *this;
    }

    template <class RNG, class S, class RNG_Calibration>
    inline MakeMCAmericanEngine<RNG, S, RNG_Calibration> &
    MakeMCAmericanEngine<RNG, S, RNG_Calibration>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S, class RNG_Calibration>
    inline MakeMCAmericanEngine<RNG, S, RNG_Calibration> &
    MakeMCAmericanEngine<RNG, S, RNG_Calibration>::withAntitheticVariate(
        bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S, class RNG_Calibration>
    inline MakeMCAmericanEngine<RNG, S, RNG_Calibration> &
    MakeMCAmericanEngine<RNG, S, RNG_Calibration>::withControlVariate(bool b) {
        controlVariate_ = b;
        return *this;
    }

    template <class RNG, class S, class RNG_Calibration>
    inline MakeMCAmericanEngine<RNG, S, RNG_Calibration> &MakeMCAmericanEngine<
        RNG, S, RNG_Calibration>::withAntitheticVariateCalibration(bool b) {
        antitheticCalibration_ = b;
        return *this;
    }

    template <class RNG, class S, class RNG_Calibration>
    inline MakeMCAmericanEngine<RNG, S, RNG_Calibration> &
    MakeMCAmericanEngine<RNG, S, RNG_Calibration>::withSeedCalibration(
        BigNatural seed) {
        seedCalibration_ = seed;
        return *this;
    }

    template <class RNG, class S, class RNG_Calibration>
    inline MakeMCAmericanEngine<RNG, S, RNG_Calibration>::
    operator ext::shared_ptr<PricingEngine>() const {
        QL_REQUIRE(steps_ != Null<Size>() || stepsPerYear_ != Null<Size>(),
                   "number of steps not given");
        QL_REQUIRE(steps_ == Null<Size>() || stepsPerYear_ == Null<Size>(),
                   "number of steps overspecified");
        return ext::shared_ptr<PricingEngine>(new
           MCAmericanEngine<RNG, S, RNG_Calibration>(process_,
                                     steps_,
                                     stepsPerYear_,
                                     antithetic_,
                                     controlVariate_,
                                     samples_, tolerance_,
                                     maxSamples_,
                                     seed_,
                                     polynomialOrder_,
                                     polynomialType_,
                                     calibrationSamples_,
                                     antitheticCalibration_,
                                     seedCalibration_));
    }

}

#endif
]]></document_content>
  </document>
  <document index="162">
    <source>vanilla/mcdigitalengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Ferdinando Ametrano
 Copyright (C) 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2003 Neil Firth
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mcdigitalengine.hpp
    \brief digital option Monte Carlo engine
*/

#ifndef quantlib_digital_mc_engine_hpp
#define quantlib_digital_mc_engine_hpp

#include <ql/exercise.hpp>
#include <ql/methods/montecarlo/mctraits.hpp>
#include <ql/pricingengines/vanilla/mcvanillaengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/termstructures/volatility/equityfx/blackvoltermstructure.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    //! Pricing engine for digital options using Monte Carlo simulation
    /*! Uses the Brownian Bridge correction for the barrier found in
        <i>
        Going to Extremes: Correcting Simulation Bias in Exotic
        Option Valuation - D.R. Beaglehole, P.H. Dybvig and G. Zhou
        Financial Analysts Journal; Jan/Feb 1997; 53, 1. pg. 62-68
        </i>
        and
        <i>
        Simulating path-dependent options: A new approach -
        M. El Babsiri and G. Noel
        Journal of Derivatives; Winter 1998; 6, 2; pg. 65-83
        </i>

        \ingroup vanillaengines

        \test the correctness of the returned value in case of
              cash-or-nothing at-hit digital payoff is tested by
              reproducing known good results.
    */
    template<class RNG = PseudoRandom, class S = Statistics>
    class MCDigitalEngine : public MCVanillaEngine<SingleVariate,RNG,S> {
      public:
        typedef
        typename MCVanillaEngine<SingleVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef
        typename MCVanillaEngine<SingleVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename MCVanillaEngine<SingleVariate,RNG,S>::stats_type
            stats_type;
        // constructor
        MCDigitalEngine(
                    const ext::shared_ptr<GeneralizedBlackScholesProcess>&,
                    Size timeSteps,
                    Size timeStepsPerYear,
                    bool brownianBridge,
                    bool antitheticVariate,
                    Size requiredSamples,
                    Real requiredTolerance,
                    Size maxSamples,
                    BigNatural seed);
      protected:
        // McSimulation implementation
        ext::shared_ptr<path_pricer_type> pathPricer() const override;
    };

    //! Monte Carlo digital engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCDigitalEngine {
      public:
        MakeMCDigitalEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);
        // named parameters
        MakeMCDigitalEngine& withSteps(Size steps);
        MakeMCDigitalEngine& withStepsPerYear(Size steps);
        MakeMCDigitalEngine& withBrownianBridge(bool b = true);
        MakeMCDigitalEngine& withSamples(Size samples);
        MakeMCDigitalEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCDigitalEngine& withMaxSamples(Size samples);
        MakeMCDigitalEngine& withSeed(BigNatural seed);
        MakeMCDigitalEngine& withAntitheticVariate(bool b = true);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        bool antithetic_ = false;
        Size steps_, stepsPerYear_, samples_, maxSamples_;
        Real tolerance_;
        bool brownianBridge_ = false;
        BigNatural seed_ = 0;
    };

    class DigitalPathPricer : public PathPricer<Path> {
      public:
        DigitalPathPricer(ext::shared_ptr<CashOrNothingPayoff> payoff,
                          ext::shared_ptr<AmericanExercise> exercise,
                          Handle<YieldTermStructure> discountTS,
                          ext::shared_ptr<StochasticProcess1D> diffProcess,
                          PseudoRandom::ursg_type sequenceGen);
        Real operator()(const Path& path) const override;

      private:
        ext::shared_ptr<CashOrNothingPayoff> payoff_;
        ext::shared_ptr<AmericanExercise> exercise_;
        ext::shared_ptr<StochasticProcess1D> diffProcess_;
        PseudoRandom::ursg_type sequenceGen_;
        Handle<YieldTermStructure> discountTS_;
    };



    // template definitions

    template<class RNG, class S>
    MCDigitalEngine<RNG,S>::MCDigitalEngine(
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             Size timeSteps,
             Size timeStepsPerYear,
             bool brownianBridge,
             bool antitheticVariate,
             Size requiredSamples,
             Real requiredTolerance,
             Size maxSamples,
             BigNatural seed)
    : MCVanillaEngine<SingleVariate,RNG,S>(process,
                                           timeSteps,
                                           timeStepsPerYear,
                                           brownianBridge,
                                           antitheticVariate,
                                           false,
                                           requiredSamples,
                                           requiredTolerance,
                                           maxSamples,
                                           seed) {}

    template <class RNG, class S>
    inline
    ext::shared_ptr<typename MCDigitalEngine<RNG,S>::path_pricer_type>
    MCDigitalEngine<RNG,S>::pathPricer() const {

        ext::shared_ptr<CashOrNothingPayoff> payoff =
            ext::dynamic_pointer_cast<CashOrNothingPayoff>(
                this->arguments_.payoff);
        QL_REQUIRE(payoff, "wrong payoff given");

        ext::shared_ptr<AmericanExercise> exercise =
            ext::dynamic_pointer_cast<AmericanExercise>(
                this->arguments_.exercise);
        QL_REQUIRE(exercise, "wrong exercise given");

        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                                                              this->process_);
        QL_REQUIRE(process, "Black-Scholes process required");

        TimeGrid grid = this->timeGrid();
        PseudoRandom::ursg_type sequenceGen(grid.size()-1,
                                            PseudoRandom::urng_type(76));

        return ext::shared_ptr<
                        typename MCDigitalEngine<RNG,S>::path_pricer_type>(
          new DigitalPathPricer(payoff,
                                exercise,
                                process->riskFreeRate(),
                                process,
                                sequenceGen));
    }


    template <class RNG, class S>
    inline MakeMCDigitalEngine<RNG, S>::MakeMCDigitalEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)), steps_(Null<Size>()), stepsPerYear_(Null<Size>()),
      samples_(Null<Size>()), maxSamples_(Null<Size>()), tolerance_(Null<Real>()) {}

    template <class RNG, class S>
    inline MakeMCDigitalEngine<RNG,S>&
    MakeMCDigitalEngine<RNG,S>::withSteps(Size steps) {
        steps_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDigitalEngine<RNG,S>&
    MakeMCDigitalEngine<RNG,S>::withStepsPerYear(Size steps) {
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDigitalEngine<RNG,S>&
    MakeMCDigitalEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDigitalEngine<RNG,S>&
    MakeMCDigitalEngine<RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDigitalEngine<RNG,S>&
    MakeMCDigitalEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDigitalEngine<RNG,S>&
    MakeMCDigitalEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDigitalEngine<RNG,S>&
    MakeMCDigitalEngine<RNG,S>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDigitalEngine<RNG,S>&
    MakeMCDigitalEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCDigitalEngine<RNG,S>::operator ext::shared_ptr<PricingEngine>()
                                                                      const {
        QL_REQUIRE(steps_ != Null<Size>() || stepsPerYear_ != Null<Size>(),
                   "number of steps not given");
        QL_REQUIRE(steps_ == Null<Size>() || stepsPerYear_ == Null<Size>(),
                   "number of steps overspecified");
        return ext::shared_ptr<PricingEngine>(new
            MCDigitalEngine<RNG,S>(process_,
                                   steps_,
                                   stepsPerYear_,
                                   brownianBridge_,
                                   antithetic_,
                                   samples_, tolerance_,
                                   maxSamples_,
                                   seed_));
    }

}


#endif
]]></document_content>
  </document>
  <document index="163">
    <source>vanilla/mceuropeanengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2007, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mceuropeanengine.hpp
    \brief Monte Carlo European option engine
*/

#ifndef quantlib_montecarlo_european_engine_hpp
#define quantlib_montecarlo_european_engine_hpp

#include <ql/pricingengines/vanilla/mcvanillaengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/termstructures/volatility/equityfx/blackvariancecurve.hpp>

namespace QuantLib {

    //! European option pricing engine using Monte Carlo simulation
    /*! \ingroup vanillaengines

        \test the correctness of the returned value is tested by
              checking it against analytic results.
    */
    template <class RNG = PseudoRandom, class S = Statistics>
    class MCEuropeanEngine : public MCVanillaEngine<SingleVariate,RNG,S> {
      public:
        typedef
        typename MCVanillaEngine<SingleVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef
        typename MCVanillaEngine<SingleVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename MCVanillaEngine<SingleVariate,RNG,S>::stats_type
            stats_type;
        // constructor
        MCEuropeanEngine(
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             Size timeSteps,
             Size timeStepsPerYear,
             bool brownianBridge,
             bool antitheticVariate,
             Size requiredSamples,
             Real requiredTolerance,
             Size maxSamples,
             BigNatural seed);
      protected:
        ext::shared_ptr<path_pricer_type> pathPricer() const override;
    };

    //! Monte Carlo European engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCEuropeanEngine {
      public:
        MakeMCEuropeanEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);
        // named parameters
        MakeMCEuropeanEngine& withSteps(Size steps);
        MakeMCEuropeanEngine& withStepsPerYear(Size steps);
        MakeMCEuropeanEngine& withBrownianBridge(bool b = true);
        MakeMCEuropeanEngine& withSamples(Size samples);
        MakeMCEuropeanEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCEuropeanEngine& withMaxSamples(Size samples);
        MakeMCEuropeanEngine& withSeed(BigNatural seed);
        MakeMCEuropeanEngine& withAntitheticVariate(bool b = true);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        bool antithetic_ = false;
        Size steps_, stepsPerYear_, samples_, maxSamples_;
        Real tolerance_;
        bool brownianBridge_ = false;
        BigNatural seed_ = 0;
    };

    class EuropeanPathPricer : public PathPricer<Path> {
      public:
        EuropeanPathPricer(Option::Type type,
                           Real strike,
                           DiscountFactor discount);
        Real operator()(const Path& path) const override;

      private:
        PlainVanillaPayoff payoff_;
        DiscountFactor discount_;
    };


    // inline definitions

    template <class RNG, class S>
    inline
    MCEuropeanEngine<RNG,S>::MCEuropeanEngine(
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             Size timeSteps,
             Size timeStepsPerYear,
             bool brownianBridge,
             bool antitheticVariate,
             Size requiredSamples,
             Real requiredTolerance,
             Size maxSamples,
             BigNatural seed)
    : MCVanillaEngine<SingleVariate,RNG,S>(process,
                                           timeSteps,
                                           timeStepsPerYear,
                                           brownianBridge,
                                           antitheticVariate,
                                           false,
                                           requiredSamples,
                                           requiredTolerance,
                                           maxSamples,
                                           seed) {}


    template <class RNG, class S>
    inline
    ext::shared_ptr<typename MCEuropeanEngine<RNG,S>::path_pricer_type>
    MCEuropeanEngine<RNG,S>::pathPricer() const {

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                this->arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                this->process_);
        QL_REQUIRE(process, "Black-Scholes process required");

        return ext::shared_ptr<
                       typename MCEuropeanEngine<RNG,S>::path_pricer_type>(
          new EuropeanPathPricer(
              payoff->optionType(),
              payoff->strike(),
              process->riskFreeRate()->discount(this->timeGrid().back())));
    }


    template <class RNG, class S>
    inline MakeMCEuropeanEngine<RNG, S>::MakeMCEuropeanEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)), steps_(Null<Size>()), stepsPerYear_(Null<Size>()),
      samples_(Null<Size>()), maxSamples_(Null<Size>()), tolerance_(Null<Real>()) {}

    template <class RNG, class S>
    inline MakeMCEuropeanEngine<RNG,S>&
    MakeMCEuropeanEngine<RNG,S>::withSteps(Size steps) {
        steps_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanEngine<RNG,S>&
    MakeMCEuropeanEngine<RNG,S>::withStepsPerYear(Size steps) {
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanEngine<RNG,S>&
    MakeMCEuropeanEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanEngine<RNG,S>&
    MakeMCEuropeanEngine<RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanEngine<RNG,S>&
    MakeMCEuropeanEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanEngine<RNG,S>&
    MakeMCEuropeanEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanEngine<RNG,S>&
    MakeMCEuropeanEngine<RNG,S>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanEngine<RNG,S>&
    MakeMCEuropeanEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCEuropeanEngine<RNG,S>::operator ext::shared_ptr<PricingEngine>()
                                                                      const {
        QL_REQUIRE(steps_ != Null<Size>() || stepsPerYear_ != Null<Size>(),
                   "number of steps not given");
        QL_REQUIRE(steps_ == Null<Size>() || stepsPerYear_ == Null<Size>(),
                   "number of steps overspecified");
        return ext::shared_ptr<PricingEngine>(new
            MCEuropeanEngine<RNG,S>(process_,
                                    steps_,
                                    stepsPerYear_,
                                    brownianBridge_,
                                    antithetic_,
                                    samples_, tolerance_,
                                    maxSamples_,
                                    seed_));
    }



    inline EuropeanPathPricer::EuropeanPathPricer(Option::Type type,
                                                  Real strike,
                                                  DiscountFactor discount)
    : payoff_(type, strike), discount_(discount) {
        QL_REQUIRE(strike>=0.0,
                   "strike less than zero not allowed");
    }

    inline Real EuropeanPathPricer::operator()(const Path& path) const {
        QL_REQUIRE(!path.empty(), "the path cannot be empty");
        return payoff_(path.back()) * discount_;
    }

}


#endif
]]></document_content>
  </document>
  <document index="164">
    <source>vanilla/mceuropeangjrgarchengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Yee Man Chan

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mceuropeangjrgarchengine.hpp
    \brief Monte Carlo GJR-GARCH-model engine for European options
*/

#ifndef quantlib_mc_european_gjrgarch_engine_hpp
#define quantlib_mc_european_gjrgarch_engine_hpp

#include <ql/pricingengines/vanilla/mcvanillaengine.hpp>
#include <ql/processes/gjrgarchprocess.hpp>
#include <utility>

namespace QuantLib {

    //! Monte Carlo GJR-GARCH-model engine for European options
    /*! \ingroup vanillaengines

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature
    */
    template <class RNG = PseudoRandom, class S = Statistics>
    class MCEuropeanGJRGARCHEngine
        : public MCVanillaEngine<MultiVariate,RNG,S> {
      public:
        typedef typename MCVanillaEngine<MultiVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        MCEuropeanGJRGARCHEngine(const ext::shared_ptr<GJRGARCHProcess>&,
                               Size timeSteps,
                               Size timeStepsPerYear,
                               bool antitheticVariate,
                               Size requiredSamples,
                               Real requiredTolerance,
                               Size maxSamples,
                               BigNatural seed);
      protected:
        ext::shared_ptr<path_pricer_type> pathPricer() const override;
    };

    //! Monte Carlo GJR-GARCH European engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCEuropeanGJRGARCHEngine {
      public:
        MakeMCEuropeanGJRGARCHEngine(ext::shared_ptr<GJRGARCHProcess>);
        // named parameters
        MakeMCEuropeanGJRGARCHEngine& withSteps(Size steps);
        MakeMCEuropeanGJRGARCHEngine& withStepsPerYear(Size steps);
        MakeMCEuropeanGJRGARCHEngine& withSamples(Size samples);
        MakeMCEuropeanGJRGARCHEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCEuropeanGJRGARCHEngine& withMaxSamples(Size samples);
        MakeMCEuropeanGJRGARCHEngine& withSeed(BigNatural seed);
        MakeMCEuropeanGJRGARCHEngine& withAntitheticVariate(bool b = true);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<GJRGARCHProcess> process_;
        bool antithetic_ = false;
        Size steps_, stepsPerYear_, samples_, maxSamples_;
        Real tolerance_;
        BigNatural seed_ = 0;
    };


    class EuropeanGJRGARCHPathPricer : public PathPricer<MultiPath> {
      public:
        EuropeanGJRGARCHPathPricer(Option::Type type,
                                 Real strike,
                                 DiscountFactor discount);
        Real operator()(const MultiPath& Multipath) const override;

      private:
        PlainVanillaPayoff payoff_;
        DiscountFactor discount_;
    };


    // template definitions

    template <class RNG, class S>
    MCEuropeanGJRGARCHEngine<RNG, S>::MCEuropeanGJRGARCHEngine(
                const ext::shared_ptr<GJRGARCHProcess>& process,
                Size timeSteps, Size timeStepsPerYear, bool antitheticVariate,
                Size requiredSamples, Real requiredTolerance,
                Size maxSamples, BigNatural seed)
    : MCVanillaEngine<MultiVariate,RNG,S>(process, timeSteps, timeStepsPerYear,
                                          false, antitheticVariate, false,
                                          requiredSamples, requiredTolerance,
                                          maxSamples, seed) {}


    template <class RNG, class S>
    ext::shared_ptr<
        typename MCEuropeanGJRGARCHEngine<RNG,S>::path_pricer_type>
    MCEuropeanGJRGARCHEngine<RNG,S>::pathPricer() const {

        ext::shared_ptr<PlainVanillaPayoff> payoff(
                  ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                                                    this->arguments_.payoff));
        QL_REQUIRE(payoff, "non-plain payoff given");

        ext::shared_ptr<GJRGARCHProcess> process =
            ext::dynamic_pointer_cast<GJRGARCHProcess>(this->process_);
        QL_REQUIRE(process, "GJRGARCH process required");

        return ext::shared_ptr<
            typename MCEuropeanGJRGARCHEngine<RNG,S>::path_pricer_type>(
                   new EuropeanGJRGARCHPathPricer(
                                        payoff->optionType(),
                                        payoff->strike(),
                                        process->riskFreeRate()->discount(
                                                   this->timeGrid().back())));
    }


    template <class RNG, class S>
    inline MakeMCEuropeanGJRGARCHEngine<RNG, S>::MakeMCEuropeanGJRGARCHEngine(
        ext::shared_ptr<GJRGARCHProcess> process)
    : process_(std::move(process)), steps_(Null<Size>()), stepsPerYear_(Null<Size>()),
      samples_(Null<Size>()), maxSamples_(Null<Size>()), tolerance_(Null<Real>()) {}

    template <class RNG, class S>
    inline MakeMCEuropeanGJRGARCHEngine<RNG,S>&
    MakeMCEuropeanGJRGARCHEngine<RNG,S>::withSteps(Size steps) {
        QL_REQUIRE(stepsPerYear_ == Null<Size>(),
                   "number of steps per year already set");
        steps_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanGJRGARCHEngine<RNG,S>&
    MakeMCEuropeanGJRGARCHEngine<RNG,S>::withStepsPerYear(Size steps) {
        QL_REQUIRE(steps_ == Null<Size>(),
                   "number of steps already set");
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanGJRGARCHEngine<RNG,S>&
    MakeMCEuropeanGJRGARCHEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanGJRGARCHEngine<RNG,S>&
    MakeMCEuropeanGJRGARCHEngine<RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanGJRGARCHEngine<RNG,S>&
    MakeMCEuropeanGJRGARCHEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanGJRGARCHEngine<RNG,S>&
    MakeMCEuropeanGJRGARCHEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEuropeanGJRGARCHEngine<RNG,S>&
    MakeMCEuropeanGJRGARCHEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCEuropeanGJRGARCHEngine<RNG,S>::
    operator ext::shared_ptr<PricingEngine>() const {
        QL_REQUIRE(steps_ != Null<Size>() || stepsPerYear_ != Null<Size>(),
                   "number of steps not given");
        return ext::shared_ptr<PricingEngine>(
                 new MCEuropeanGJRGARCHEngine<RNG,S>(process_,
                                                   steps_,
                                                   stepsPerYear_,
                                                   antithetic_,
                                                   samples_, tolerance_,
                                                   maxSamples_,
                                                   seed_));
    }



    inline EuropeanGJRGARCHPathPricer::EuropeanGJRGARCHPathPricer(
                                                 Option::Type type,
                                                 Real strike,
                                                 DiscountFactor discount)
    : payoff_(type, strike), discount_(discount) {
        QL_REQUIRE(strike>=0.0,
                   "strike less than zero not allowed");
    }

    inline Real EuropeanGJRGARCHPathPricer::operator()(
                                           const MultiPath& multiPath) const {
        const Path& path = multiPath[0];
        const Size n = multiPath.pathSize();
        QL_REQUIRE(n>0, "the path cannot be empty");

        return payoff_(path.back()) * discount_;
    }

}


#endif
]]></document_content>
  </document>
  <document index="165">
    <source>vanilla/mceuropeanhestonengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Klaus Spanderen
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mceuropeanhestonengine.hpp
    \brief Monte Carlo Heston-model engine for European options
*/

#ifndef quantlib_mc_european_heston_engine_hpp
#define quantlib_mc_european_heston_engine_hpp

#include <ql/pricingengines/vanilla/mcvanillaengine.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <utility>

namespace QuantLib {

    //! Monte Carlo Heston-model engine for European options
    /*! \ingroup vanillaengines

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature
    */
    template <class RNG = PseudoRandom,
              class S = Statistics, class P = HestonProcess>
    class MCEuropeanHestonEngine
        : public MCVanillaEngine<MultiVariate,RNG,S> {
      public:
        typedef typename MCVanillaEngine<MultiVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        MCEuropeanHestonEngine(const ext::shared_ptr<P>&,
                               Size timeSteps,
                               Size timeStepsPerYear,
                               bool antitheticVariate,
                               Size requiredSamples,
                               Real requiredTolerance,
                               Size maxSamples,
                               BigNatural seed);
      protected:
        ext::shared_ptr<path_pricer_type> pathPricer() const override;
    };

    //! Monte Carlo Heston European engine factory
    template <class RNG = PseudoRandom,
              class S = Statistics, class P = HestonProcess>
    class MakeMCEuropeanHestonEngine {
      public:
        explicit MakeMCEuropeanHestonEngine(ext::shared_ptr<P>);
        // named parameters
        MakeMCEuropeanHestonEngine& withSteps(Size steps);
        MakeMCEuropeanHestonEngine& withStepsPerYear(Size steps);
        MakeMCEuropeanHestonEngine& withSamples(Size samples);
        MakeMCEuropeanHestonEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCEuropeanHestonEngine& withMaxSamples(Size samples);
        MakeMCEuropeanHestonEngine& withSeed(BigNatural seed);
        MakeMCEuropeanHestonEngine& withAntitheticVariate(bool b = true);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<P> process_;
        bool antithetic_ = false;
        Size steps_, stepsPerYear_, samples_, maxSamples_;
        Real tolerance_;
        BigNatural seed_ = 0;
    };


    class EuropeanHestonPathPricer : public PathPricer<MultiPath> {
      public:
        EuropeanHestonPathPricer(Option::Type type,
                                 Real strike,
                                 DiscountFactor discount);
        Real operator()(const MultiPath& Multipath) const override;

      private:
        PlainVanillaPayoff payoff_;
        DiscountFactor discount_;
    };


    // template definitions

    template <class RNG, class S, class P>
    MCEuropeanHestonEngine<RNG, S, P>::MCEuropeanHestonEngine(
                const ext::shared_ptr<P>& process,
                Size timeSteps, Size timeStepsPerYear, bool antitheticVariate,
                Size requiredSamples, Real requiredTolerance,
                Size maxSamples, BigNatural seed)
    : MCVanillaEngine<MultiVariate,RNG,S>(process, timeSteps, timeStepsPerYear,
                                          false, antitheticVariate, false,
                                          requiredSamples, requiredTolerance,
                                          maxSamples, seed) {}


    template <class RNG, class S, class P>
    ext::shared_ptr<
        typename MCEuropeanHestonEngine<RNG,S,P>::path_pricer_type>
    MCEuropeanHestonEngine<RNG,S,P>::pathPricer() const {

        ext::shared_ptr<PlainVanillaPayoff> payoff(
                  ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                                                    this->arguments_.payoff));
        QL_REQUIRE(payoff, "non-plain payoff given");

        ext::shared_ptr<P> process =
            ext::dynamic_pointer_cast<P>(this->process_);
        QL_REQUIRE(process, "Heston like process required");

        return ext::shared_ptr<
            typename MCEuropeanHestonEngine<RNG,S,P>::path_pricer_type>(
                   new EuropeanHestonPathPricer(
                                        payoff->optionType(),
                                        payoff->strike(),
                                        process->riskFreeRate()->discount(
                                                   this->timeGrid().back())));
    }


    template <class RNG, class S, class P>
    inline MakeMCEuropeanHestonEngine<RNG, S, P>::MakeMCEuropeanHestonEngine(
        ext::shared_ptr<P> process)
    : process_(std::move(process)), steps_(Null<Size>()), stepsPerYear_(Null<Size>()),
      samples_(Null<Size>()), maxSamples_(Null<Size>()), tolerance_(Null<Real>()) {}

    template <class RNG, class S,class P>
    inline MakeMCEuropeanHestonEngine<RNG,S,P>&
    MakeMCEuropeanHestonEngine<RNG,S,P>::withSteps(Size steps) {
        QL_REQUIRE(stepsPerYear_ == Null<Size>(),
                   "number of steps per year already set");
        steps_ = steps;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCEuropeanHestonEngine<RNG,S,P>&
    MakeMCEuropeanHestonEngine<RNG,S,P>::withStepsPerYear(Size steps) {
        QL_REQUIRE(steps_ == Null<Size>(),
                   "number of steps already set");
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG, class S,class P>
    inline MakeMCEuropeanHestonEngine<RNG,S,P>&
    MakeMCEuropeanHestonEngine<RNG,S,P>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCEuropeanHestonEngine<RNG,S,P>&
    MakeMCEuropeanHestonEngine<RNG,S,P>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCEuropeanHestonEngine<RNG,S,P>&
    MakeMCEuropeanHestonEngine<RNG,S,P>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCEuropeanHestonEngine<RNG,S,P>&
    MakeMCEuropeanHestonEngine<RNG,S,P>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S, class P>
    inline MakeMCEuropeanHestonEngine<RNG,S,P>&
    MakeMCEuropeanHestonEngine<RNG,S,P>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S, class P>
    inline
    MakeMCEuropeanHestonEngine<RNG,S,P>::
    operator ext::shared_ptr<PricingEngine>() const {
        QL_REQUIRE(steps_ != Null<Size>() || stepsPerYear_ != Null<Size>(),
                   "number of steps not given");
        return ext::shared_ptr<PricingEngine>(
               new MCEuropeanHestonEngine<RNG,S,P>(process_,
                                                   steps_,
                                                   stepsPerYear_,
                                                   antithetic_,
                                                   samples_, tolerance_,
                                                   maxSamples_,
                                                   seed_));
    }



    inline EuropeanHestonPathPricer::EuropeanHestonPathPricer(
                                                 Option::Type type,
                                                 Real strike,
                                                 DiscountFactor discount)
    : payoff_(type, strike), discount_(discount) {
        QL_REQUIRE(strike>=0.0,
                   "strike less than zero not allowed");
    }

    inline Real EuropeanHestonPathPricer::operator()(
                                           const MultiPath& multiPath) const {
        const Path& path = multiPath[0];
        const Size n = multiPath.pathSize();
        QL_REQUIRE(n>0, "the path cannot be empty");

        return payoff_(path.back()) * discount_;
    }

}


#endif
]]></document_content>
  </document>
  <document index="166">
    <source>vanilla/mchestonhullwhiteengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mchestonhullwhiteengine.hpp
    \brief Monte Carlo vanilla option engine for stochastic interest rates
*/

#ifndef quantlib_mc_heston_hull_white_engine_hpp
#define quantlib_mc_heston_hull_white_engine_hpp

#include <ql/pricingengines/vanilla/analytichestonhullwhiteengine.hpp>
#include <ql/pricingengines/vanilla/mcvanillaengine.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <ql/processes/hullwhiteprocess.hpp>
#include <ql/processes/hybridhestonhullwhiteprocess.hpp>
#include <utility>

namespace QuantLib {

    template <class RNG = PseudoRandom, class S = Statistics>
    class MCHestonHullWhiteEngine
        : public MCVanillaEngine<MultiVariate, RNG, S> {
      public:
        typedef MCVanillaEngine<MultiVariate, RNG,S> base_type;
        typedef typename base_type::path_generator_type path_generator_type;
        typedef typename base_type::path_pricer_type path_pricer_type;
        typedef typename base_type::stats_type stats_type;
        typedef typename base_type::result_type result_type;

        MCHestonHullWhiteEngine(
               const ext::shared_ptr<HybridHestonHullWhiteProcess>& process,
               Size timeSteps,
               Size timeStepsPerYear,
               bool antitheticVariate,
               bool controlVariate,
               Size requiredSamples,
               Real requiredTolerance,
               Size maxSamples,
               BigNatural seed);

        void calculate() const override;

      protected:
        // just to avoid upcasting
        ext::shared_ptr<HybridHestonHullWhiteProcess> process_;

        ext::shared_ptr<path_pricer_type> pathPricer() const override;

        ext::shared_ptr<path_pricer_type> controlPathPricer() const override;
        ext::shared_ptr<PricingEngine> controlPricingEngine() const override;
        ext::shared_ptr<path_generator_type> controlPathGenerator() const override;
    };

    //! Monte Carlo Heston/Hull-White engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCHestonHullWhiteEngine {
      public:
        explicit MakeMCHestonHullWhiteEngine(ext::shared_ptr<HybridHestonHullWhiteProcess>);
        // named parameters
        MakeMCHestonHullWhiteEngine& withSteps(Size steps);
        MakeMCHestonHullWhiteEngine& withStepsPerYear(Size steps);
        MakeMCHestonHullWhiteEngine& withAntitheticVariate(bool b = true);
        MakeMCHestonHullWhiteEngine& withControlVariate(bool b = true);
        MakeMCHestonHullWhiteEngine& withSamples(Size samples);
        MakeMCHestonHullWhiteEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCHestonHullWhiteEngine& withMaxSamples(Size samples);
        MakeMCHestonHullWhiteEngine& withSeed(BigNatural seed);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<HybridHestonHullWhiteProcess> process_;
        Size steps_, stepsPerYear_, samples_, maxSamples_;
        bool antithetic_ = false, controlVariate_ = false;
        Real tolerance_;
        BigNatural seed_ = 0;
    };


    class HestonHullWhitePathPricer : public PathPricer<MultiPath> {
      public:
        HestonHullWhitePathPricer(Time exerciseTime,
                                  ext::shared_ptr<Payoff> payoff,
                                  ext::shared_ptr<HybridHestonHullWhiteProcess> process);

        Real operator()(const MultiPath& path) const override;

      private:
        Time exerciseTime_;
        ext::shared_ptr<Payoff> payoff_;
        ext::shared_ptr<HybridHestonHullWhiteProcess> process_;
    };


    template<class RNG,class S>
    inline MCHestonHullWhiteEngine<RNG,S>::MCHestonHullWhiteEngine(
              const ext::shared_ptr<HybridHestonHullWhiteProcess> & process,
              Size timeSteps,
              Size timeStepsPerYear,
              bool antitheticVariate,
              bool controlVariate,
              Size requiredSamples,
              Real requiredTolerance,
              Size maxSamples,
              BigNatural seed)
    : base_type(process, timeSteps, timeStepsPerYear,
                false, antitheticVariate,
                controlVariate, requiredSamples,
                requiredTolerance, maxSamples, seed),
      process_(process) {}

    template<class RNG,class S>
    inline void MCHestonHullWhiteEngine<RNG,S>::calculate() const {
        MCVanillaEngine<MultiVariate, RNG, S>::calculate();
        
        if (this->controlVariate_) {
            // control variate might lead to small negative
            // option values for deep OTM options
            this->results_.value = std::max(0.0, this->results_.value);
        }
    }
                  
    template <class RNG,class S> inline
    ext::shared_ptr<typename MCHestonHullWhiteEngine<RNG,S>::path_pricer_type>
    MCHestonHullWhiteEngine<RNG,S>::pathPricer() const {

        ext::shared_ptr<Exercise> exercise = this->arguments_.exercise;

        QL_REQUIRE(exercise->type() == Exercise::European,
                       "only european exercise is supported");

        const Time exerciseTime = process_->time(exercise->lastDate());

        return ext::shared_ptr<path_pricer_type>(
             new HestonHullWhitePathPricer(exerciseTime,
                                           this->arguments_.payoff,
                                           process_));
    }

    template <class RNG, class S> inline
    ext::shared_ptr<
        typename MCHestonHullWhiteEngine<RNG,S>::path_pricer_type>
    MCHestonHullWhiteEngine<RNG,S>::controlPathPricer() const {

        ext::shared_ptr<HestonProcess> hestonProcess =
            process_->hestonProcess();

        QL_REQUIRE(hestonProcess, "first constituent of the joint stochastic "
                                  "process need to be of type HestonProcess");

        ext::shared_ptr<Exercise> exercise = this->arguments_.exercise;

        QL_REQUIRE(exercise->type() == Exercise::European,
                       "only european exercise is supported");

        const Time exerciseTime = process_->time(exercise->lastDate());

        return ext::shared_ptr<path_pricer_type>(
             new HestonHullWhitePathPricer(
                  exerciseTime,
                  this->arguments_.payoff,
                  process_) );
    }

    template <class RNG, class S> inline
    ext::shared_ptr<PricingEngine>
    MCHestonHullWhiteEngine<RNG,S>::controlPricingEngine() const {

        ext::shared_ptr<HestonProcess> hestonProcess =
            process_->hestonProcess();

        ext::shared_ptr<HullWhiteForwardProcess> hullWhiteProcess =
            process_->hullWhiteProcess();

        ext::shared_ptr<HestonModel> hestonModel(
                                              new HestonModel(hestonProcess));
        ext::shared_ptr<HullWhite> hwModel(
                              new HullWhite(hestonProcess->riskFreeRate(),
                                            hullWhiteProcess->a(),
                                            hullWhiteProcess->sigma()));

        return ext::shared_ptr<PricingEngine>(
                new AnalyticHestonHullWhiteEngine(hestonModel, hwModel, 144));
    }

    template <class RNG, class S> inline
    ext::shared_ptr<
        typename MCHestonHullWhiteEngine<RNG,S>::path_generator_type>
    MCHestonHullWhiteEngine<RNG,S>::controlPathGenerator() const {

        Size dimensions = process_->factors();
        TimeGrid grid = this->timeGrid();
        typename RNG::rsg_type generator =
            RNG::make_sequence_generator(dimensions*(grid.size()-1),
                                         this->seed_);

        ext::shared_ptr<HybridHestonHullWhiteProcess> cvProcess(
            new HybridHestonHullWhiteProcess(process_->hestonProcess(),
                                             process_->hullWhiteProcess(),
                                             0.0,
                                             process_->discretization()));

        return ext::shared_ptr<path_generator_type>(
                  new path_generator_type(cvProcess, grid, generator, false));
    }


    template <class RNG, class S>
    inline MakeMCHestonHullWhiteEngine<RNG, S>::MakeMCHestonHullWhiteEngine(
        ext::shared_ptr<HybridHestonHullWhiteProcess> process)
    : process_(std::move(process)), steps_(Null<Size>()), stepsPerYear_(Null<Size>()),
      samples_(Null<Size>()), maxSamples_(Null<Size>()), tolerance_(Null<Real>()) {}

    template <class RNG, class S>
    inline MakeMCHestonHullWhiteEngine<RNG,S>&
    MakeMCHestonHullWhiteEngine<RNG,S>::withSteps(Size steps) {
        steps_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHestonHullWhiteEngine<RNG,S>&
    MakeMCHestonHullWhiteEngine<RNG,S>::withStepsPerYear(Size steps) {
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHestonHullWhiteEngine<RNG,S>&
    MakeMCHestonHullWhiteEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHestonHullWhiteEngine<RNG,S>&
    MakeMCHestonHullWhiteEngine<RNG,S>::withControlVariate(bool b) {
        controlVariate_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHestonHullWhiteEngine<RNG,S>&
    MakeMCHestonHullWhiteEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHestonHullWhiteEngine<RNG,S>&
    MakeMCHestonHullWhiteEngine<RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHestonHullWhiteEngine<RNG,S>&
    MakeMCHestonHullWhiteEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHestonHullWhiteEngine<RNG,S>&
    MakeMCHestonHullWhiteEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCHestonHullWhiteEngine<RNG,S>::operator
    ext::shared_ptr<PricingEngine>() const {
        QL_REQUIRE(steps_ != Null<Size>() || stepsPerYear_ != Null<Size>(),
                   "number of steps not given");
        QL_REQUIRE(steps_ == Null<Size>() || stepsPerYear_ == Null<Size>(),
                   "number of steps overspecified");
        return ext::shared_ptr<PricingEngine>(new
            MCHestonHullWhiteEngine<RNG,S>(process_,
                                           steps_,
                                           stepsPerYear_,
                                           antithetic_,
                                           controlVariate_,
                                           samples_,
                                           tolerance_,
                                           maxSamples_,
                                           seed_));
    }

}

#endif
]]></document_content>
  </document>
  <document index="167">
    <source>vanilla/mcvanillaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2003, 2004, 2005, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mcvanillaengine.hpp
    \brief Monte Carlo vanilla option engine
*/

#ifndef quantlib_mcvanilla_engine_hpp
#define quantlib_mcvanilla_engine_hpp

#include <ql/pricingengines/mcsimulation.hpp>
#include <ql/instruments/vanillaoption.hpp>

namespace QuantLib {

    //! Pricing engine for vanilla options using Monte Carlo simulation
    /*! \ingroup vanillaengines */
    template <template <class> class MC, class RNG,
              class S = Statistics, class Inst = VanillaOption>
    class MCVanillaEngine : public Inst::engine,
                            public McSimulation<MC,RNG,S> {
      public:
        void calculate() const override {
            McSimulation<MC,RNG,S>::calculate(requiredTolerance_,
                                              requiredSamples_,
                                              maxSamples_);
            this->results_.value = this->mcModel_->sampleAccumulator().mean();
            if constexpr (RNG::allowsErrorEstimate)
                this->results_.errorEstimate =
                    this->mcModel_->sampleAccumulator().errorEstimate();
        }

      protected:
        typedef typename McSimulation<MC,RNG,S>::path_generator_type
            path_generator_type;
        typedef typename McSimulation<MC,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename McSimulation<MC,RNG,S>::stats_type
            stats_type;
        typedef typename McSimulation<MC,RNG,S>::result_type
            result_type;
        // constructor
        MCVanillaEngine(ext::shared_ptr<StochasticProcess>,
                        Size timeSteps,
                        Size timeStepsPerYear,
                        bool brownianBridge,
                        bool antitheticVariate,
                        bool controlVariate,
                        Size requiredSamples,
                        Real requiredTolerance,
                        Size maxSamples,
                        BigNatural seed);
        // McSimulation implementation
        TimeGrid timeGrid() const override;
        ext::shared_ptr<path_generator_type> pathGenerator() const override {

            Size dimensions = process_->factors();
            TimeGrid grid = this->timeGrid();
            typename RNG::rsg_type generator =
                RNG::make_sequence_generator(dimensions*(grid.size()-1),seed_);
            return ext::shared_ptr<path_generator_type>(
                   new path_generator_type(process_, grid,
                                           generator, brownianBridge_));
        }
        result_type controlVariateValue() const override;
        // data members
        ext::shared_ptr<StochasticProcess> process_;
        Size timeSteps_, timeStepsPerYear_;
        Size requiredSamples_, maxSamples_;
        Real requiredTolerance_;
        bool brownianBridge_;
        BigNatural seed_;
    };


    // template definitions

    template <template <class> class MC, class RNG, class S, class Inst>
    inline MCVanillaEngine<MC, RNG, S, Inst>::MCVanillaEngine(
        ext::shared_ptr<StochasticProcess> process,
        Size timeSteps,
        Size timeStepsPerYear,
        bool brownianBridge,
        bool antitheticVariate,
        bool controlVariate,
        Size requiredSamples,
        Real requiredTolerance,
        Size maxSamples,
        BigNatural seed)
    : McSimulation<MC, RNG, S>(antitheticVariate, controlVariate), process_(std::move(process)),
      timeSteps_(timeSteps), timeStepsPerYear_(timeStepsPerYear), requiredSamples_(requiredSamples),
      maxSamples_(maxSamples), requiredTolerance_(requiredTolerance),
      brownianBridge_(brownianBridge), seed_(seed) {
        QL_REQUIRE(timeSteps != Null<Size>() ||
                   timeStepsPerYear != Null<Size>(),
                   "no time steps provided");
        QL_REQUIRE(timeSteps == Null<Size>() ||
                   timeStepsPerYear == Null<Size>(),
                   "both time steps and time steps per year were provided");
        QL_REQUIRE(timeSteps != 0,
                   "timeSteps must be positive, " << timeSteps <<
                   " not allowed");
        QL_REQUIRE(timeStepsPerYear != 0,
                   "timeStepsPerYear must be positive, " << timeStepsPerYear <<
                   " not allowed");
        this->registerWith(process_);
    }

    template <template <class> class MC, class RNG, class S, class Inst>
    inline typename MCVanillaEngine<MC,RNG,S,Inst>::result_type
    MCVanillaEngine<MC,RNG,S,Inst>::controlVariateValue() const {

        ext::shared_ptr<PricingEngine> controlPE =
            this->controlPricingEngine();
        QL_REQUIRE(controlPE,
                   "engine does not provide "
                   "control variation pricing engine");

        auto* controlArguments = dynamic_cast<typename Inst::arguments*>(controlPE->getArguments());

        QL_REQUIRE(controlArguments, "engine is using inconsistent arguments");

        *controlArguments = this->arguments_;
        controlPE->calculate();

        const auto* controlResults =
            dynamic_cast<const typename Inst::results*>(controlPE->getResults());
        QL_REQUIRE(controlResults,
                   "engine returns an inconsistent result type");

        return result_type(controlResults->value);
    }


    template <template <class> class MC, class RNG, class S, class Inst>
    inline TimeGrid MCVanillaEngine<MC,RNG,S,Inst>::timeGrid() const {
        Date lastExerciseDate = this->arguments_.exercise->lastDate();
        Time t = process_->time(lastExerciseDate);
        if (this->timeSteps_ != Null<Size>()) {
            return TimeGrid(t, this->timeSteps_);
        } else if (this->timeStepsPerYear_ != Null<Size>()) {
            Size steps = static_cast<Size>(this->timeStepsPerYear_*t);
            return TimeGrid(t, std::max<Size>(steps, 1));
        } else {
            QL_FAIL("time steps not specified");
        }
    }

}


#endif
]]></document_content>
  </document>
  <document index="168">
    <source>vanilla/qdfpamericanengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2022 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file qdfpamericanengine.hpp
*/

#ifndef quantlib_qd_fp_american_engine_hpp
#define quantlib_qd_fp_american_engine_hpp

#include <ql/pricingengines/vanilla/qdplusamericanengine.hpp>

namespace QuantLib {

    class Integrator;

    //! Iteration scheme for fixed-point QD American engine
    class QdFpIterationScheme {
      public:
        virtual Size getNumberOfChebyshevInterpolationNodes() const = 0;
        virtual Size getNumberOfNaiveFixedPointSteps() const = 0;
        virtual Size getNumberOfJacobiNewtonFixedPointSteps() const = 0;

        virtual ext::shared_ptr<Integrator> getFixedPointIntegrator() const = 0;
        virtual ext::shared_ptr<Integrator> getExerciseBoundaryToPriceIntegrator() const = 0;

        virtual ~QdFpIterationScheme() = default;
    };

    //! Gauss-Legendre (l,m,n)-p Scheme
    /*! \param l  order of Gauss-Legendre integration within every fixed point iteration step
        \param m  fixed point iteration steps, first step is a partial Jacobi-Newton,
                  the rest are naive Richardson fixed point iterations
        \param n  number of Chebyshev nodes to interpolate the exercise boundary
        \param p  order of Gauss-Legendre integration in final conversion of the
                  exercise boundary into option prices
    */
    class QdFpLegendreScheme: public QdFpIterationScheme {
      public:
        QdFpLegendreScheme(Size l, Size m, Size n, Size p);

        Size getNumberOfChebyshevInterpolationNodes() const override;
        Size getNumberOfNaiveFixedPointSteps() const override;
        Size getNumberOfJacobiNewtonFixedPointSteps() const override;

        ext::shared_ptr<Integrator> getFixedPointIntegrator() const override;
        ext::shared_ptr<Integrator> getExerciseBoundaryToPriceIntegrator() const override;

      private:
        const Size m_, n_;
        const ext::shared_ptr<Integrator> fpIntegrator_;
        const ext::shared_ptr<Integrator> exerciseBoundaryIntegrator_;
    };

    //! Legendre-Tanh-Sinh (l,m,n)-eps Scheme
    /*! \param l    order of Gauss-Legendre integration within every fixed point iteration step
        \param m    fixed point iteration steps, first step is a partial Jacobi-Newton,
                    the rest are naive Richardson fixed point iterations
        \param n    number of Chebyshev nodes to interpolate the exercise boundary
        \param eps  final conversion of the exercise boundary into option prices
                    is carried out by a tanh-sinh integration with accuracy eps
    */
    class QdFpLegendreTanhSinhScheme: public QdFpLegendreScheme {
      public:
        QdFpLegendreTanhSinhScheme(Size l, Size m, Size n, Real eps);

        ext::shared_ptr<Integrator> getExerciseBoundaryToPriceIntegrator() const override;

      private:
        const Real eps_;
    };

    //! tanh-sinh (m,n)-eps Scheme
    /*! \param m    fixed point iteration steps, first step is a partial Jacobi-Newton,
                    the rest are naive Richardson fixed point iterations
        \param n    number of Chebyshev nodes to interpolate the exercise boundary
        \param eps  tanh-sinh integration precision
    */
    class QdFpTanhSinhIterationScheme: public QdFpIterationScheme {
      public:
        QdFpTanhSinhIterationScheme(Size m, Size n, Real eps);

        Size getNumberOfChebyshevInterpolationNodes() const override;
        Size getNumberOfNaiveFixedPointSteps() const override;
        Size getNumberOfJacobiNewtonFixedPointSteps() const override;

        ext::shared_ptr<Integrator> getFixedPointIntegrator() const override;
        ext::shared_ptr<Integrator> getExerciseBoundaryToPriceIntegrator() const override;
      private:
        const Size m_, n_;
        const ext::shared_ptr<Integrator> integrator_;
    };


    //! High performance/precision American engine based on fixed point iteration for the exercise boundary
    /*! References:
        Leif Andersen, Mark Lake and Dimitri Offengenden (2015)
        "High Performance American Option Pricing",
        https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2547027

        Leif Andersen, Mark Lake (2021)
        "Fast American Option Pricing: The Double-Boundary Case"

        https://onlinelibrary.wiley.com/doi/abs/10.1002/wilm.10969
    */
    class QdFpAmericanEngine : public detail::QdPutCallParityEngine {
      public:
        enum FixedPointEquation { FP_A, FP_B, Auto };

        explicit QdFpAmericanEngine(
          ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess,
          ext::shared_ptr<QdFpIterationScheme> iterationScheme = accurateScheme(),
          FixedPointEquation fpEquation = Auto);

        static ext::shared_ptr<QdFpIterationScheme> fastScheme();
        static ext::shared_ptr<QdFpIterationScheme> accurateScheme();
        static ext::shared_ptr<QdFpIterationScheme> highPrecisionScheme();

      protected:
        Real calculatePut(
            Real S, Real K, Rate r, Rate q, Volatility vol, Time T) const override;

      private:
        const ext::shared_ptr<QdFpIterationScheme> iterationScheme_;
        const FixedPointEquation fpEquation_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="169">
    <source>vanilla/qdplusamericanengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2022 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file qdplusamericanengine.hpp
*/

#ifndef quantlib_qd_plus_american_engine_hpp
#define quantlib_qd_plus_american_engine_hpp

#include <ql/utilities/null.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>


namespace QuantLib {

    class Interpolation;
    class ChebyshevInterpolation;
    class QdPlusBoundaryEvaluator;

    namespace detail {

        class QdPutCallParityEngine: public VanillaOption::engine {
          public:
            explicit QdPutCallParityEngine(
                ext::shared_ptr<GeneralizedBlackScholesProcess> process);

            void calculate() const override;

          protected:
            virtual Real calculatePut(
                Real S, Real K, Rate r, Rate q, Volatility vol, Time T) const = 0;

            const ext::shared_ptr<GeneralizedBlackScholesProcess> process_;

          private:
            Real calculatePutWithEdgeCases(
               Real S, Real K, Rate r, Rate q, Volatility vol, Time T) const;
        };

        class QdPlusAddOnValue {
          public:
            QdPlusAddOnValue(Time T,
                             Real S,
                             Real K,
                             Rate r,
                             Rate q,
                             Volatility vol,
                             Real xmax,
                             ext::shared_ptr<Interpolation> q_z);

            Real operator()(Real z) const;
          private:
            const Time T_;
            const Real S_, K_, xmax_;
            const Rate r_, q_;
            const Volatility vol_;
            const ext::shared_ptr<Interpolation> q_z_;
            const CumulativeNormalDistribution Phi_;
        };
    }


    //! American engine based on the QD+ approximation to the exercise boundary.
    /*! The main purpose of this engine is to provide a good initial guess to the exercise
        boundary for the superior fixed point American engine QdFpAmericanEngine

        References:
        Li, M. (2009), “Analytical Approximations for the Critical Stock Prices
                        of American Options: A Performance Comparison,”
                        Working paper, Georgia Institute of Technology.

        https://mpra.ub.uni-muenchen.de/15018/1/MPRA_paper_15018.pdf
    */
    class QdPlusAmericanEngine: public detail::QdPutCallParityEngine {
      public:
        enum SolverType {Brent, Newton, Ridder, Halley, SuperHalley};

        explicit QdPlusAmericanEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess>,
            Size interpolationPoints = 8,
            SolverType solverType = Halley,
            Real eps = 1e-6,
            Size maxIter = Null<Size>());

        std::pair<Size, Real> putExerciseBoundaryAtTau(
            Real S, Real K, Rate r, Rate q,
            Volatility vol, Time T, Time tau) const;

        ext::shared_ptr<ChebyshevInterpolation> getPutExerciseBoundary(
            Real S, Real K, Rate r, Rate q, Volatility vol, Time T) const;

        static Real xMax(Real K, Rate r, Rate q);

      protected:
        Real calculatePut(
            Real S, Real K, Rate r, Rate q, Volatility vol, Time T) const override;

      private:
        template <class Solver>
        Real buildInSolver(
            const QdPlusBoundaryEvaluator& eval,
            Solver solver, Real S, Real strike, Size maxIter,
            Real guess = Null<Real>()) const;

        const Size interpolationPoints_;
        const SolverType solverType_;
        const Real eps_;
        const Size maxIter_;
    };
}

#endif
]]></document_content>
  </document>
</documents>