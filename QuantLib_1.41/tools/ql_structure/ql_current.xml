<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>any.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2023 Jonathan Sweemer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file any.hpp
    \brief Maps any to either the boost or std implementation
*/

#ifndef quantlib_any_hpp
#define quantlib_any_hpp

#include <ql/qldefines.hpp>

#if defined(QL_USE_STD_ANY)
#include <any>
#else
// Deprecated in version 1.39
#pragma message("Warning: using boost::any is deprecated.  Enable std::any instead.")
#include <boost/any.hpp>
#endif

namespace QuantLib::ext {

        #if defined(QL_USE_STD_ANY)
        using std::any;                   // NOLINT(misc-unused-using-decls)
        using std::any_cast;              // NOLINT(misc-unused-using-decls)
        #else
        using boost::any;                 // NOLINT(misc-unused-using-decls)
        using boost::any_cast;            // NOLINT(misc-unused-using-decls)
        #endif

    }

#endif
]]></document_content>
  </document>
  <document index="2">
    <source>auto_link.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2008 Ferdinando Ametrano
 Copyright (C) 2012 Édouard Tallent

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_autolink_hpp
#define quantlib_autolink_hpp

#include <ql/version.hpp>
#include <boost/config.hpp>

#ifdef _M_X64
#  define QL_LIB_PLATFORM "-x64"
#else
#  define QL_LIB_PLATFORM
#endif

/*** libraries to be linked ***/

// select thread opt:
#ifdef _MT
#  define QL_LIB_THREAD_OPT "-mt"
#else
#  define QL_LIB_THREAD_OPT
#endif

// select linkage opt:
#ifdef _DLL
#  if defined(_DEBUG)
#    define QL_LIB_RT_OPT "-gd"
#  else
#    define QL_LIB_RT_OPT
#  endif
#else
#  if defined(_DEBUG)
#    define QL_LIB_RT_OPT "-sgd"
#  else
#    define QL_LIB_RT_OPT "-s"
#  endif
#endif

#define QL_LIB_NAME "QuantLib" QL_LIB_PLATFORM QL_LIB_THREAD_OPT QL_LIB_RT_OPT ".lib"

#pragma comment(lib, QL_LIB_NAME)
#ifdef BOOST_LIB_DIAGNOSTIC
#  pragma message("Will (need to) link to lib file: " QL_LIB_NAME)
#endif

#endif
]]></document_content>
  </document>
  <document index="3">
    <source>cashflow.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Ferdinando Ametrano
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflow.hpp>
#include <ql/settings.hpp>
#include <ql/patterns/visitor.hpp>

namespace QuantLib {

    bool CashFlow::hasOccurred(const Date& refDate,
                               ext::optional<bool> includeRefDate) const {

        // easy and quick handling of most cases
        if (refDate != Date()) {
            Date cf = date();
            if (refDate < cf)
                return false;
            if (cf < refDate)
                return true;
        }

        if (refDate == Date() ||
            refDate == Settings::instance().evaluationDate()) {
            // today's date; we override the bool with the one
            // specified in the settings (if any)
            ext::optional<bool> includeToday =
                Settings::instance().includeTodaysCashFlows();
            if (includeToday.has_value())
                includeRefDate = includeToday;
        }
        return Event::hasOccurred(refDate, includeRefDate);
    }

    bool CashFlow::tradingExCoupon(const Date& refDate) const {

        Date ecd = exCouponDate();
        if (ecd == Date())
            return false;

        Date ref =
            refDate != Date() ? refDate : Settings::instance().evaluationDate();

        return ecd <= ref;
    }

    void CashFlow::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<CashFlow>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Event::accept(v);
    }

}
]]></document_content>
  </document>
  <document index="4">
    <source>cashflow.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cashflow.hpp
    \brief Base class for cash flows
*/

#ifndef quantlib_cash_flow_hpp
#define quantlib_cash_flow_hpp

#include <ql/event.hpp>
#include <ql/math/comparison.hpp>
#include <ql/optional.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <vector>

namespace QuantLib {

    //! Base class for cash flows
    /*! This class is purely virtual and acts as a base class for the
        actual cash flow implementations.
    */
    class CashFlow : public Event, public LazyObject {
      public:
        ~CashFlow() override = default;
        //! \name Event interface
        //@{
        //! \note This is inherited from the event class
        Date date() const override = 0;
        //! returns true if an event has already occurred before a date
        /*! overloads Event::hasOccurred in order to take
            Settings::includeTodaysCashflows in account
        */
        bool hasOccurred(const Date& refDate = Date(),
                         ext::optional<bool> includeRefDate = ext::nullopt) const override;
        //@}
        //! \name LazyObject interface
        //@{
        void performCalculations() const override {}
        //@}
        //! \name CashFlow interface
        //@{
        //! returns the amount of the cash flow
        /*! \note The amount is not discounted, i.e., it is the actual
                  amount paid at the cash flow date.
        */
        virtual Real amount() const = 0;
        //! returns the date that the cash flow trades exCoupon
        virtual Date exCouponDate() const { return {}; };
        //! returns true if the cashflow is trading ex-coupon on the refDate
        bool tradingExCoupon(const Date& refDate = Date()) const;

        //@}
        //! \name Visitability
        //@{
        void accept(AcyclicVisitor&) override;
        //@}
    };

    //! Sequence of cash-flows
    typedef std::vector<ext::shared_ptr<CashFlow> > Leg;

    template <>
    struct earlier_than<CashFlow> {
        bool operator()(const CashFlow& c1,
                        const CashFlow& c2) const {
            return c1.date() < c2.date();
        }
    };

}

#endif
]]></document_content>
  </document>
  <document index="5">
    <source>compounding.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2005, 2006, 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file compounding.hpp
    \brief Compounding enumeration
*/

#ifndef quantlib_compounding_hpp
#define quantlib_compounding_hpp

#include <ql/errors.hpp>

namespace QuantLib {

    //! Interest rate coumpounding rule
    enum Compounding { Simple = 0,          //!< \f$ 1+rt \f$
                       Compounded = 1,      //!< \f$ (1+r)^t \f$
                       Continuous = 2,      //!< \f$ e^{rt} \f$
                       SimpleThenCompounded, //!< Simple up to the first period then Compounded
                       CompoundedThenSimple //!< Compounded up to the first period then Simple
    };

    inline std::ostream& operator<<(std::ostream& out, const Compounding& compounding) {
        switch (compounding) {
            case Compounding::Simple:
                return out << "Simple";
            case Compounding::Compounded:
                return out << "Compounded";
            case Compounding::Continuous:
                return out << "Continuous";
            case Compounding::SimpleThenCompounded:
                return out << "SimpleThenCompounded";
            case Compounding::CompoundedThenSimple:
                return out << "CompoundedThenSimple";
            default:
                QL_FAIL("unknown compounding type");
        }
    }
}

#endif
]]></document_content>
  </document>
  <document index="6">
    <source>config.ansi.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_config_ansi_h
#define quantlib_config_ansi_h

#include <ql/userconfig.hpp>


#endif
]]></document_content>
  </document>
  <document index="7">
    <source>config.mingw.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_config_mingw_hpp
#define quantlib_config_mingw_hpp

#include <ql/userconfig.hpp>


#endif
]]></document_content>
  </document>
  <document index="8">
    <source>config.msvc.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2010 StatPro Italia srl
 Copyright (C) 2004, 2008 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_config_msvc_hpp
#define quantlib_config_msvc_hpp

#include <ql/userconfig.hpp>

// first things first
#if (_MSC_VER < 1910)
#  error "versions of Visual C++ prior to VC++ 2017 are no longer supported"
#endif

/*******************************************
   System configuration section:
   do not modify the following definitions.
 *******************************************/

// force undefining min and max macros
#ifndef NOMINMAX
#  define NOMINMAX
#endif
#ifdef min
#  undef min
#endif
#ifdef max
#  undef max
#endif

// conditionally work around compiler glitches
#define QL_PATCH_MSVC

// Compilation on the x64 platform throws a lot of warnings assigning
// QuantLib::Size == size_t (64 bit) to QuantLib::Integer == int (32
// bit under x64 Windows). We disable this warning until a better
// solution is suggested.
#ifdef _M_X64
#pragma warning(disable : 4267)
#endif


/* suppress C++ code analysis warning C26812 in VS 2019:
 * Prefer 'enum class' over 'enum' (Enum.3). */
#pragma warning(disable : 26812)


#ifndef _CPPRTTI
#   error Enable Run-Time Type Info (Property Pages | C/C++ | Language)
#endif

#endif
]]></document_content>
  </document>
  <document index="9">
    <source>config.sun.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_config_sun_hpp
#define quantlib_config_sun_hpp

#include <ql/userconfig.hpp>

/*******************************************
   System configuration section:
   do not modify the following definitions.
 *******************************************/

#ifndef QL_PATCH_SOLARIS
#define QL_PATCH_SOLARIS
#endif

// to be compatible with gcc and VC++, make math functions
// available in the global namespace as well.
#include <cmath>
using std::sqrt; using std::abs; using std::fabs;
using std::exp; using std::log; using std::pow;
using std::sin; using std::cos; using std::asin; using std::acos;
using std::sinh; using std::cosh;
using std::floor; using std::fmod; using std::modf;


#endif
]]></document_content>
  </document>
  <document index="10">
    <source>currency.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/currency.hpp>
#include <utility>

namespace QuantLib {

    std::ostream& operator<<(std::ostream& out, const Currency& c) {
        if (!c.empty())
            return out << c.code();
        else
            return out << "null currency";
    }

    Currency::Data::Data(std::string name,
                         std::string code,
                         Integer numericCode,
                         std::string symbol,
                         std::string fractionSymbol,
                         Integer fractionsPerUnit,
                         const Rounding& rounding,
                         Currency triangulationCurrency,
                         std::set<std::string> minorUnitCodes)
    : name(std::move(name)), code(std::move(code)), numeric(numericCode), symbol(std::move(symbol)),
      fractionSymbol(std::move(fractionSymbol)), fractionsPerUnit(fractionsPerUnit),
      rounding(rounding), triangulated(std::move(triangulationCurrency)),
      minorUnitCodes(std::move(minorUnitCodes)) {}

    Currency::Currency(const std::string& name,
                       const std::string& code,
                       Integer numericCode,
                       const std::string& symbol,
                       const std::string& fractionSymbol,
                       Integer fractionsPerUnit,
                       const Rounding& rounding,
                       const Currency& triangulationCurrency,
                       const std::set<std::string>& minorUnitCodes)
    : data_(ext::make_shared<Currency::Data>(name,
                                             code,
                                             numericCode,
                                             symbol,
                                             fractionSymbol,
                                             fractionsPerUnit,
                                             rounding,
                                             triangulationCurrency,
                                             minorUnitCodes)) {}

}
]]></document_content>
  </document>
  <document index="11">
    <source>currency.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Decillion Pty(Ltd)
 Copyright (C) 2004, 2005, 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file currency.hpp
    \brief Currency specification
*/

#ifndef quantlib_currency_hpp
#define quantlib_currency_hpp

#include <ql/math/rounding.hpp>
#include <ql/errors.hpp>
#include <iosfwd>
#include <set>

namespace QuantLib {

    //! %Currency specification
    class Currency {
      public:
        //! \name Constructors
        //@{
        //! default constructor
        /*! Instances built via this constructor have undefined
            behavior. Such instances can only act as placeholders
            and must be reassigned to a valid currency before being
            used.
        */
        Currency() = default;
        Currency(const std::string& name,
                 const std::string& code,
                 Integer numericCode,
                 const std::string& symbol,
                 const std::string& fractionSymbol,
                 Integer fractionsPerUnit,
                 const Rounding& rounding,
                 const Currency& triangulationCurrency = Currency(),
                 const std::set<std::string>& minorUnitCodes = {});
        //@}
        //! \name Inspectors
        //@{
        //! currency name, e.g, "U.S. Dollar"
        const std::string& name() const;
        //! ISO 4217 three-letter code, e.g, "USD"
        const std::string& code() const;
        //! ISO 4217 numeric code, e.g, "840"
        Integer numericCode() const;
        //! symbol, e.g, "$"
        const std::string& symbol() const;
        //! fraction symbol, e.g, "¢"
        const std::string& fractionSymbol() const;
        //! number of fractionary parts in a unit, e.g, 100
        Integer fractionsPerUnit() const;
        //! rounding convention
        const Rounding& rounding() const;
        //@}
        //! \name Other information
        //@{
        //! is this a usable instance?
        bool empty() const;
        //! currency used for triangulated exchange when required
        const Currency& triangulationCurrency() const;
        //! minor unit codes, e.g. GBp, GBX for GBP
        const std::set<std::string>& minorUnitCodes() const;
        //@}
      protected:
        struct Data;
        ext::shared_ptr<Data> data_;
     private:
        void checkNonEmpty() const;
    };

    struct Currency::Data {
        std::string name, code;
        Integer numeric;
        std::string symbol, fractionSymbol;
        Integer fractionsPerUnit;
        Rounding rounding;
        Currency triangulated;
        std::set<std::string> minorUnitCodes;

        Data(std::string name,
             std::string code,
             Integer numericCode,
             std::string symbol,
             std::string fractionSymbol,
             Integer fractionsPerUnit,
             const Rounding& rounding,
             Currency triangulationCurrency = Currency(),
             std::set<std::string> minorUnitCodes = {});
    };


    /*! \relates Currency */
    bool operator==(const Currency&,
                    const Currency&);

    /*! \relates Currency */
    bool operator!=(const Currency&,
                    const Currency&);

    /*! \relates Currency */
    std::ostream& operator<<(std::ostream&,
                             const Currency&);


    // inline definitions

    inline void Currency::checkNonEmpty() const {
        QL_REQUIRE(data_, "no currency data provided");
    }

    inline const std::string& Currency::name() const {
        checkNonEmpty();
        return data_->name;
    }

    inline const std::string& Currency::code() const {
        checkNonEmpty();
        return data_->code;
    }

    inline Integer Currency::numericCode() const {
        checkNonEmpty();
        return data_->numeric;
    }

    inline const std::string& Currency::symbol() const {
        checkNonEmpty();
        return data_->symbol;
    }

    inline const std::string& Currency::fractionSymbol() const {
        checkNonEmpty();
        return data_->fractionSymbol;
    }

    inline Integer Currency::fractionsPerUnit() const {
        checkNonEmpty();
        return data_->fractionsPerUnit;
    }

    inline const Rounding& Currency::rounding() const {
        checkNonEmpty();
        return data_->rounding;
    }

    inline bool Currency::empty() const {
        return !data_;
    }

    inline const Currency& Currency::triangulationCurrency() const {
        checkNonEmpty();
        return data_->triangulated;
    }

    inline const std::set<std::string>& Currency::minorUnitCodes() const {
        checkNonEmpty();
        return data_->minorUnitCodes;
    }

    inline bool operator==(const Currency& c1, const Currency& c2) {
        return (c1.empty() && c2.empty()) ||
               (!c1.empty() && !c2.empty() && c1.name() == c2.name());
    }

    inline bool operator!=(const Currency& c1, const Currency& c2) {
        return !(c1 == c2);
    }

}


#endif
]]></document_content>
  </document>
  <document index="12">
    <source>default.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file default.hpp
    \brief Classes for default-event handling.
*/

#ifndef quantlib_default_hpp
#define quantlib_default_hpp

#include <ql/qldefines.hpp>

namespace QuantLib {

    //! information on a default-protection contract
    struct Protection {
        enum Side { Buyer, Seller };
    };

}

#endif
]]></document_content>
  </document>
  <document index="13">
    <source>discretizedasset.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/discretizedasset.hpp>

namespace QuantLib {

    void DiscretizedOption::postAdjustValuesImpl() {
        /* In the real world, with time flowing forward, first
           any payment is settled and only after options can be
           exercised. Here, with time flowing backward, options
           must be exercised before performing the adjustment.
        */
        underlying_->partialRollback(time());
        underlying_->preAdjustValues();
        Size i;
        switch (exerciseType_) {
          case Exercise::American:
            if (time_ >= exerciseTimes_[0] && time_ <= exerciseTimes_[1])
                applyExerciseCondition();
            break;
          case Exercise::Bermudan:
          case Exercise::European:
            for (i=0; i<exerciseTimes_.size(); i++) {
                Time t = exerciseTimes_[i];
                if (t >= 0.0 && isOnTime(t))
                    applyExerciseCondition();
            }
            break;
          default:
            QL_FAIL("invalid exercise type");
        }
        underlying_->postAdjustValues();
    }

}

]]></document_content>
  </document>
  <document index="14">
    <source>discretizedasset.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file discretizedasset.hpp
    \brief Discretized asset classes
*/

#ifndef quantlib_discretized_asset_hpp
#define quantlib_discretized_asset_hpp

#include <ql/exercise.hpp>
#include <ql/math/comparison.hpp>
#include <ql/numericalmethod.hpp>
#include <utility>

namespace QuantLib {

    //! Discretized asset class used by numerical methods
    class DiscretizedAsset {
      public:
        DiscretizedAsset()
        : latestPreAdjustment_(QL_MAX_REAL),
          latestPostAdjustment_(QL_MAX_REAL) {}
        virtual ~DiscretizedAsset() = default;

        //! \name inspectors
        //@{
        Time time() const { return time_; }
        Time& time() { return time_; }

        const Array& values() const { return values_; }
        Array& values() { return values_; }

        const ext::shared_ptr<Lattice>& method() const {
            return method_;
        }
        //@}

        /*! \name High-level interface

            Users of discretized assets should use these methods in
            order to initialize, evolve and take the present value of
            the assets.  They call the corresponding methods in the
            Lattice interface, to which we refer for
            documentation.

            @{
        */
        void initialize(const ext::shared_ptr<Lattice>&,
                        Time t);
        void rollback(Time to);
        void partialRollback(Time to);
        Real presentValue();
        //@}

        /*! \name Low-level interface

            These methods (that developers should override when
            deriving from DiscretizedAsset) are to be used by
            numerical methods and not directly by users, with the
            exception of adjustValues(), preAdjustValues() and
            postAdjustValues() that can be used together with
            partialRollback().

            @{
        */

        /*! This method should initialize the asset values to an Array
            of the given size and with values depending on the
            particular asset.
        */
        virtual void reset(Size size) = 0;

        /*! This method will be invoked after rollback and before any
            other asset (i.e., an option on this one) has any chance to
            look at the values. For instance, payments happening at times
            already spanned by the rollback will be added here.

            This method is not virtual; derived classes must override
            the protected preAdjustValuesImpl() method instead.
        */
        void preAdjustValues();

        /*! This method will be invoked after rollback and after any
            other asset had their chance to look at the values. For
            instance, payments happening at the present time (and therefore
            not included in an option to be exercised at this time) will be
            added here.

            This method is not virtual; derived classes must override
            the protected postAdjustValuesImpl() method instead.
        */
        void postAdjustValues();

        /*! This method performs both pre- and post-adjustment */
        void adjustValues() {
            preAdjustValues();
            postAdjustValues();
        }

        /*! This method returns the times at which the numerical
            method should stop while rolling back the asset. Typical
            examples include payment times, exercise times and such.

            \note The returned values are not guaranteed to be sorted.
        */
        virtual std::vector<Time> mandatoryTimes() const = 0;
        //@}
      protected:
        /*! Indicates if a coupon should be adjusted in preAdjustValues() or postAdjustValues(). */
        enum class CouponAdjustment { pre, post };

        /*! This method checks whether the asset was rolled at the
            given time. */
        bool isOnTime(Time t) const;
        /*! This method performs the actual pre-adjustment */
        virtual void preAdjustValuesImpl() {}
        /*! This method performs the actual post-adjustment */
        virtual void postAdjustValuesImpl() {}

        Time time_;
        Time latestPreAdjustment_, latestPostAdjustment_;
        Array values_;
      private:
        ext::shared_ptr<Lattice> method_;
    };


    //! Useful discretized discount bond asset
    class DiscretizedDiscountBond : public DiscretizedAsset {
      public:
        DiscretizedDiscountBond() = default;
        void reset(Size size) override { values_ = Array(size, 1.0); }
        std::vector<Time> mandatoryTimes() const override { return std::vector<Time>(); }
    };


    //! Discretized option on a given asset
    /*! \warning it is advised that derived classes take care of
                 creating and initializing themselves an instance of
                 the underlying.
    */
    class DiscretizedOption : public DiscretizedAsset {
      public:
        DiscretizedOption(ext::shared_ptr<DiscretizedAsset> underlying,
                          Exercise::Type exerciseType,
                          std::vector<Time> exerciseTimes)
        : underlying_(std::move(underlying)), exerciseType_(exerciseType),
          exerciseTimes_(std::move(exerciseTimes)) {}
        void reset(Size size) override;
        std::vector<Time> mandatoryTimes() const override;

      protected:
        void postAdjustValuesImpl() override;
        void applyExerciseCondition();
        ext::shared_ptr<DiscretizedAsset> underlying_;
        Exercise::Type exerciseType_;
        std::vector<Time> exerciseTimes_;
    };



    // inline definitions

    inline void DiscretizedAsset::initialize(
                             const ext::shared_ptr<Lattice>& method,
                             Time t) {
        method_ = method;
        method_->initialize(*this, t);
    }

    inline void DiscretizedAsset::rollback(Time to) {
        method_->rollback(*this, to);
    }

    inline void DiscretizedAsset::partialRollback(Time to) {
        method_->partialRollback(*this, to);
    }

    inline Real DiscretizedAsset::presentValue() {
        return method_->presentValue(*this);
    }

    inline void DiscretizedAsset::preAdjustValues() {
        if (!close_enough(time(),latestPreAdjustment_)) {
            preAdjustValuesImpl();
            latestPreAdjustment_ = time();
        }
    }

    inline void DiscretizedAsset::postAdjustValues() {
        if (!close_enough(time(),latestPostAdjustment_)) {
            postAdjustValuesImpl();
            latestPostAdjustment_ = time();
        }
    }

    inline bool DiscretizedAsset::isOnTime(Time t) const {
        const TimeGrid& grid = method()->timeGrid();
        return close_enough(grid[grid.index(t)],time());
    }


    inline void DiscretizedOption::reset(Size size) {
        QL_REQUIRE(method() == underlying_->method(),
                   "option and underlying were initialized on "
                   "different methods");
        values_ = Array(size, 0.0);
        adjustValues();
    }

    inline std::vector<Time> DiscretizedOption::mandatoryTimes() const {
        std::vector<Time> times = underlying_->mandatoryTimes();
        // discard negative times...
        auto i = std::find_if(exerciseTimes_.begin(), exerciseTimes_.end(),
                              [](Time t){ return t >= 0.0; });
        // and add the positive ones
        times.insert(times.end(), i, exerciseTimes_.end());
        return times;
    }

    inline void DiscretizedOption::applyExerciseCondition() {
        for (Size i=0; i<values_.size(); i++)
            values_[i] = std::max(underlying_->values()[i], values_[i]);
    }


}


#endif
]]></document_content>
  </document>
  <document index="15">
    <source>errors.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/errors.hpp>
#include <stdexcept>

namespace {

    #if defined(_MSC_VER)
    // allow Visual Studio integration
    std::string format_error(
                       #ifdef QL_ERROR_LINES
                       const std::string& file, long line,
                       #else
                       const std::string&, long,
                       #endif
                       #ifdef QL_ERROR_FUNCTIONS
                       const std::string& function,
                       #else
                       const std::string&,
                       #endif
                       const std::string& message) {
        std::ostringstream msg;
        #ifdef QL_ERROR_FUNCTIONS
        if (function != "(unknown)")
            msg << function << ": ";
        #endif
        #ifdef QL_ERROR_LINES
        msg << "\n  " << file << "(" << line << "): \n";
        #endif
        msg << message;
        return msg.str();
    }
    #else
    // use gcc format (e.g. for integration with Emacs)
    std::string format_error(const std::string& file, long line,
                             const std::string& function,
                             const std::string& message) {
        std::ostringstream msg;
        #ifdef QL_ERROR_LINES
        msg << "\n" << file << ":" << line << ": ";
        #endif
        #ifdef QL_ERROR_FUNCTIONS
        if (function != "(unknown)")
            msg << "In function `" << function << "': \n";
        #endif
        msg << message;
        return msg.str();
    }
    #endif

}

namespace boost {

    // must be defined by the user
    void assertion_failed(char const * expr, char const * function,
                          char const * file, long line) {
        throw std::runtime_error(format_error(file, line, function,
                                              "Boost assertion failed: " +
                                              std::string(expr)));
    }

    void assertion_failed_msg(char const * expr, char const * msg,
                              char const * function, char const * file,
                              long line) {
        throw std::runtime_error(format_error(file, line, function,
                                              "Boost assertion failed: " +
                                              std::string(expr) + ": " +
                                              std::string(msg)));
    }

}

namespace QuantLib {

    Error::Error(const std::string& file, long line,
                 const std::string& function,
                 const std::string& message) {
        message_ = ext::make_shared<std::string>(
            format_error(file, line, function, message));
    }

    const char* Error::what() const noexcept { return message_->c_str(); }
}

]]></document_content>
  </document>
  <document index="16">
    <source>errors.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file errors.hpp
    \brief Classes and functions for error handling.
*/

#ifndef quantlib_errors_hpp
#define quantlib_errors_hpp

#include <ql/qldefines.hpp>
#include <ql/shared_ptr.hpp>
#include <boost/assert.hpp>
#include <boost/current_function.hpp>
#include <exception>
#include <sstream>
#include <string>

namespace QuantLib {

    //! Base error class
    class Error : public std::exception {
      public:
        /*! The explicit use of this constructor is not advised.
            Use the QL_FAIL macro instead.
        */
        Error(const std::string& file,
              long line,
              const std::string& functionName,
              const std::string& message = "");
        //! returns the error message.
        const char* what() const noexcept override;

      private:
        ext::shared_ptr<std::string> message_;
    };

}

#define QL_MULTILINE_FAILURE_BEGIN do {

/* Disable warning C4127 (conditional expression is constant) when
   wrapping macros with the do { ... } while(false) construct on MSVC
*/
#if defined(BOOST_MSVC)
    #define QL_MULTILINE_FAILURE_END \
        __pragma(warning(push)) \
        __pragma(warning(disable:4127)) \
        } while(false) \
        __pragma(warning(pop))
#else
    #define QL_MULTILINE_FAILURE_END } while(false)
#endif


#define QL_MULTILINE_ASSERTION_BEGIN do {

/* Disable warning C4127 (conditional expression is constant) when
   wrapping macros with the do { ... } while(false) construct on MSVC
*/
#if defined(BOOST_MSVC)
    #define QL_MULTILINE_ASSERTION_END \
        __pragma(warning(push)) \
        __pragma(warning(disable:4127)) \
        } while(false) \
        __pragma(warning(pop))
#else
    #define QL_MULTILINE_ASSERTION_END } while(false)
#endif


/*! \def QL_FAIL
    \brief throw an error (possibly with file and line information)
*/
#define QL_FAIL(message) \
QL_MULTILINE_FAILURE_BEGIN \
    std::ostringstream _ql_msg_stream; \
    _ql_msg_stream << message; \
    throw QuantLib::Error(__FILE__,__LINE__, \
                          BOOST_CURRENT_FUNCTION,_ql_msg_stream.str()); \
QL_MULTILINE_FAILURE_END


/*! \def QL_ASSERT
    \brief throw an error if the given condition is not verified
*/
#define QL_ASSERT(condition,message) \
QL_MULTILINE_ASSERTION_BEGIN \
if (!(condition)) { \
    std::ostringstream _ql_msg_stream; \
    _ql_msg_stream << message; \
    throw QuantLib::Error(__FILE__,__LINE__, \
                          BOOST_CURRENT_FUNCTION,_ql_msg_stream.str()); \
} \
QL_MULTILINE_ASSERTION_END

/*! \def QL_REQUIRE
    \brief throw an error if the given pre-condition is not verified
*/
#define QL_REQUIRE(condition,message) \
QL_MULTILINE_ASSERTION_BEGIN \
if (!(condition)) { \
    std::ostringstream _ql_msg_stream; \
    _ql_msg_stream << message; \
    throw QuantLib::Error(__FILE__,__LINE__, \
                          BOOST_CURRENT_FUNCTION,_ql_msg_stream.str()); \
} \
QL_MULTILINE_ASSERTION_END

/*! \def QL_ENSURE
    \brief throw an error if the given post-condition is not verified
*/
#define QL_ENSURE(condition,message) \
QL_MULTILINE_ASSERTION_BEGIN \
if (!(condition)) { \
    std::ostringstream _ql_msg_stream; \
    _ql_msg_stream << message; \
    throw QuantLib::Error(__FILE__,__LINE__, \
                          BOOST_CURRENT_FUNCTION,_ql_msg_stream.str()); \
} \
QL_MULTILINE_ASSERTION_END


#endif

]]></document_content>
  </document>
  <document index="17">
    <source>event.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Ferdinando Ametrano
 Copyright (C) 2005 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/event.hpp>
#include <ql/patterns/visitor.hpp>
#include <ql/optional.hpp>
#include <ql/settings.hpp>

namespace QuantLib {

    bool Event::hasOccurred(const Date& d, // refDate
                            ext::optional<bool> includeRefDate) const {
        Date refDate =
            d != Date() ? d : Settings::instance().evaluationDate();
        bool includeRefDateEvent = includeRefDate ? // NOLINT(readability-implicit-bool-conversion)
                                       *includeRefDate :
                                       Settings::instance().includeReferenceDateEvents();
        if (includeRefDateEvent)
            return date() < refDate;
        else
            return date() <= refDate;
    }

    void Event::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<Event>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            QL_FAIL("not an event visitor");
    }

}
]]></document_content>
  </document>
  <document index="18">
    <source>event.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Ferdinando Ametrano
 Copyright (C) 2005 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file event.hpp
    \brief Base class for events associated with a given date
*/

#ifndef quantlib_event_hpp
#define quantlib_event_hpp

#include <ql/time/date.hpp>
#include <ql/patterns/observable.hpp>
#include <ql/optional.hpp>

namespace QuantLib {

    class AcyclicVisitor;

    //! Base class for event
    /*! This class acts as a base class for the actual
        event implementations.
    */
    class Event : public virtual Observable {
      public:
        ~Event() override = default;
        //! \name Event interface
        //@{
        //! returns the date at which the event occurs
        virtual Date date() const = 0;

        //! returns true if an event has already occurred before a date
        /*! If includeRefDate is true, then an event has not occurred if its
            date is the same as the refDate, i.e. this method returns false if
            the event date is the same as the refDate.
        */
        virtual bool hasOccurred(
                    const Date& refDate = Date(),
                    ext::optional<bool> includeRefDate = ext::nullopt) const;
        //@}

        //! \name Visitability
        //@{
        virtual void accept(AcyclicVisitor&);
        //@}
    };


    namespace detail {

        // used to create an Event instance.
        // to be replaced with specific events as soon as we find out which.
        class simple_event : public Event {
          public:
            explicit simple_event(const Date& date) : date_(date) {}
            Date date() const override { return date_; }

          private:
            Date date_;
        };

    }

}


#endif
]]></document_content>
  </document>
  <document index="19">
    <source>exchangerate.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2008 StatPro Italia srl
 Copyright (C) 2004 Decillion Pty(Ltd)

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exchangerate.hpp>

namespace QuantLib {

    Money ExchangeRate::exchange(const Money& amount) const {
        switch (type_) {
          case Direct:
            if (amount.currency() == source_)
                return Money(amount.value()*rate_, target_);
            else if (amount.currency() == target_)
                return Money(amount.value()/rate_, source_);
            else
                QL_FAIL("exchange rate not applicable");
          case Derived:
            if (amount.currency() == rateChain_.first->source() ||
                amount.currency() == rateChain_.first->target())
                return rateChain_.second->exchange(
                                         rateChain_.first->exchange(amount));
            else if (amount.currency() == rateChain_.second->source() ||
                       amount.currency() == rateChain_.second->target())
                return rateChain_.first->exchange(
                                         rateChain_.second->exchange(amount));
            else
                QL_FAIL("exchange rate not applicable");
          default:
            QL_FAIL("unknown exchange-rate type");
        }
    }

    ExchangeRate ExchangeRate::chain(const ExchangeRate& r1,
                                     const ExchangeRate& r2) {
        ExchangeRate result;
        result.type_ = Derived;
        result.rateChain_ = std::make_pair(
                       ext::make_shared<ExchangeRate>(r1),
                       ext::make_shared<ExchangeRate>(r2));
        if (r1.source_ == r2.source_) {
            result.source_ = r1.target_;
            result.target_ = r2.target_;
            result.rate_ = r2.rate_/r1.rate_;
        } else if (r1.source_ == r2.target_) {
            result.source_ = r1.target_;
            result.target_ = r2.source_;
            result.rate_ = 1.0/(r1.rate_*r2.rate_);
        } else if (r1.target_ == r2.source_) {
            result.source_ = r1.source_;
            result.target_ = r2.target_;
            result.rate_ = r1.rate_*r2.rate_;
        } else if (r1.target_ == r2.target_) {
            result.source_ = r1.source_;
            result.target_ = r2.source_;
            result.rate_ = r1.rate_/r2.rate_;
        } else {
            QL_FAIL("exchange rates not chainable");
        }
        return result;
    }

}
]]></document_content>
  </document>
  <document index="20">
    <source>exchangerate.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 StatPro Italia srl
 Copyright (C) 2004 Decillion Pty(Ltd)

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file exchangerate.hpp
    \brief exchange rate between two currencies
*/

#ifndef quantlib_exchange_rate_hpp
#define quantlib_exchange_rate_hpp

#include <ql/money.hpp>
#include <ql/utilities/null.hpp>
#include <utility>

namespace QuantLib {

    //! exchange rate between two currencies
    /*! \test application of direct and derived exchange rate is
              tested against calculations.
    */
    class ExchangeRate {
      public:
        enum Type { Direct,  /*!< given directly by the user */
                    Derived  /*!< derived from exchange rates between
                                  other currencies */
        };
        //! \name Constructors
        //@{
        ExchangeRate();
        /*! the rate \f$ r \f$ is given with the convention that a
            unit of the source is worth \f$ r \f$ units of the target.
        */
        ExchangeRate(Currency source, Currency target, Decimal rate);
        //@}

        //! \name Inspectors
        //@{
        //! the source currency.
        const Currency& source() const;
        //! the target currency.
        const Currency& target() const;
        //! the type
        Type type() const;
        //! the exchange rate (when available)
        Decimal rate() const;
        //@}

        //! \name Utility methods
        //@{
        //! apply the exchange rate to a cash amount
        Money exchange(const Money& amount) const;
        //! chain two exchange rates
        static ExchangeRate chain(const ExchangeRate& r1,
                                  const ExchangeRate& r2);
        //@}
      private:
        Currency source_, target_;
        Decimal rate_;
        Type type_;
        std::pair<ext::shared_ptr<ExchangeRate>,
                  ext::shared_ptr<ExchangeRate> > rateChain_;
    };


    // inline definitions

    inline ExchangeRate::ExchangeRate() : rate_(Null<Decimal>()), type_(Direct) {}

    inline ExchangeRate::ExchangeRate(Currency source, Currency target, Decimal rate)
    : source_(std::move(source)), target_(std::move(target)), rate_(rate), type_(Direct) {}

    inline const Currency& ExchangeRate::source() const {
        return source_;
    }

    inline const Currency& ExchangeRate::target() const {
        return target_;
    }

    inline ExchangeRate::Type ExchangeRate::type() const {
        return type_;
    }

    inline Decimal ExchangeRate::rate() const {
        return rate_;
    }

}


#endif
]]></document_content>
  </document>
  <document index="21">
    <source>exercise.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2003 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/errors.hpp>
#include <algorithm>

namespace QuantLib {

    Date Exercise::lastDate() const {
        QL_REQUIRE(!dates_.empty(), "no exercise date given");
        return dates_.back();
    }

    AmericanExercise::AmericanExercise(const Date& earliest,
                                       const Date& latest,
                                       bool payoffAtExpiry)
    : EarlyExercise(American, payoffAtExpiry) {
        QL_REQUIRE(earliest<=latest,
                   "earliest > latest exercise date");
        dates_ = std::vector<Date>(2);
        dates_[0] = earliest;
        dates_[1] = latest;
    }

    AmericanExercise::AmericanExercise(const Date& latest,
                                       bool payoffAtExpiry)
    : EarlyExercise(American, payoffAtExpiry) {
        dates_ = std::vector<Date>(2);
        dates_[0] = Date::minDate();
        dates_[1] = latest;
    }

    BermudanExercise::BermudanExercise(const std::vector<Date>& dates,
                                       bool payoffAtExpiry)
    : EarlyExercise(Bermudan, payoffAtExpiry) {
        QL_REQUIRE(!dates.empty(), "no exercise date given");
        dates_ = dates;
        std::sort(dates_.begin(), dates_.end());
    }

    EuropeanExercise::EuropeanExercise(const Date& date)
    : Exercise(European) {
        dates_ = std::vector<Date>(1,date);
    }

}
]]></document_content>
  </document>
  <document index="22">
    <source>exercise.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file exercise.hpp
    \brief Option exercise classes and payoff function
*/

#ifndef quantlib_exercise_type_h
#define quantlib_exercise_type_h

#include <ql/time/date.hpp>
#include <vector>

namespace QuantLib {

    //! Base exercise class
    class Exercise {
      public:
        enum Type {
            American, Bermudan, European
        };
        // constructor
        explicit Exercise(Type type) : type_(type) {}
        virtual ~Exercise() = default;
        // inspectors
        Type type() const { return type_; }
        Date date(Size index) const { return dates_[index]; }
        Date dateAt(Size index) const { return dates_.at(index); }
        //! Returns all exercise dates
        const std::vector<Date>& dates() const { return dates_; }
        Date lastDate() const;
      protected:
        std::vector<Date> dates_;
        Type type_;
    };

    //! Early-exercise base class
    /*! The payoff can be at exercise (the default) or at expiry */
    class EarlyExercise : public Exercise {
      public:
        EarlyExercise(Type type,
                      bool payoffAtExpiry = false)
        : Exercise(type), payoffAtExpiry_(payoffAtExpiry) {}
        bool payoffAtExpiry() const { return payoffAtExpiry_; }
      private:
        bool payoffAtExpiry_;
    };

    //! American exercise
    /*! An American option can be exercised at any time between two
        predefined dates; the first date might be omitted, in which
        case the option can be exercised at any time before the expiry.

        \todo check that everywhere the American condition is applied
              from earliestDate and not earlier
    */
    class AmericanExercise : public EarlyExercise {
      public:
        AmericanExercise(const Date& earliestDate,
                         const Date& latestDate,
                         bool payoffAtExpiry = false);
        AmericanExercise(const Date& latestDate,
                         bool payoffAtExpiry = false);
    };

    //! Bermudan exercise
    /*! A Bermudan option can only be exercised at a set of fixed dates.
    */
    class BermudanExercise : public EarlyExercise {
      public:
        BermudanExercise(const std::vector<Date>& dates,
                         bool payoffAtExpiry = false);
    };

    //! European exercise
    /*! A European option can only be exercised at one (expiry) date.
    */
    class EuropeanExercise : public Exercise {
      public:
        EuropeanExercise(const Date& date);
    };

}


#endif
]]></document_content>
  </document>
  <document index="23">
    <source>functional.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_functional_hpp
#define quantlib_functional_hpp

// Deprecated in version 1.41
#pragma message("Warning: this file is empty and will disappear in a future release; use #include <functional> instead.")

#include <functional>

#endif

]]></document_content>
  </document>
  <document index="24">
    <source>grid.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_grid_hpp
#define quantlib_grid_hpp

#include <ql/math/array.hpp>

/* Deprecated in version 1.42 */

#pragma message("Warning: this file is empty and will disappear in a future release; do not include it.")

#endif
]]></document_content>
  </document>
  <document index="25">
    <source>handle.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file handle.hpp
    \brief Globally accessible relinkable pointer
*/

#ifndef quantlib_handle_hpp
#define quantlib_handle_hpp

#include <ql/patterns/observable.hpp>

namespace QuantLib {

    //! Shared handle to an observable
    /*! All copies of an instance of this class refer to the same
        observable by means of a relinkable smart pointer. When such
        pointer is relinked to another observable, the change will be
        propagated to all the copies.

        \pre Class T must inherit from Observable
    */
    template <class T>
    class Handle {
      protected:
        class Link : public Observable, public Observer {
          public:
            Link(const ext::shared_ptr<T>& h,
                 bool registerAsObserver);
            Link(ext::shared_ptr<T>&& h,
                 bool registerAsObserver);
            void linkTo(ext::shared_ptr<T>,
                        bool registerAsObserver);
            bool empty() const { return !h_; }
            const ext::shared_ptr<T>& currentLink() const { return h_; }
            void update() override { notifyObservers(); }

          private:
            ext::shared_ptr<T> h_;
            bool isObserver_ = false;
        };
        ext::shared_ptr<Link> link_;
      public:
        /*! \name Constructors

            \warning <tt>registerAsObserver</tt> is left as a backdoor
                     in case the programmer cannot guarantee that the
                     object pointed to will remain alive for the whole
                     lifetime of the handle---namely, it should be set
                     to <tt>false</tt> when the passed shared pointer
                     does not own the pointee (this should only happen
                     in a controlled environment, so that the
                     programmer is aware of it). Failure to do so can
                     very likely result in a program crash.  If the
                     programmer does want the handle to register as
                     observer of such a shared pointer, it is his
                     responsibility to ensure that the handle gets
                     destroyed before the pointed object does.
        */
        //@{
        Handle()
        : Handle(ext::shared_ptr<T>()) {}
        explicit Handle(const ext::shared_ptr<T>& p,
                        bool registerAsObserver = true)
        : link_(new Link(p, registerAsObserver)) {}
        explicit Handle(ext::shared_ptr<T>&& p,
                        bool registerAsObserver = true)
        : link_(new Link(std::move(p), registerAsObserver)) {}
        //@}
        //! dereferencing
        const ext::shared_ptr<T>& currentLink() const;
        const ext::shared_ptr<T>& operator->() const;
        const ext::shared_ptr<T>& operator*() const;
        //! checks if the contained shared pointer points to anything
        bool empty() const;
        //! allows registration as observable
        operator ext::shared_ptr<Observable>() const;
        //! equality test
        template <class U>
        bool operator==(const Handle<U>& other) const { return link_==other.link_; }
        //! disequality test
        template <class U>
        bool operator!=(const Handle<U>& other) const { return link_!=other.link_; }
        //! strict weak ordering
        template <class U>
        bool operator<(const Handle<U>& other) const { return link_ < other.link_; }
    };

    //! Relinkable handle to an observable
    /*! An instance of this class can be relinked so that it points to
        another observable. The change will be propagated to all
        handles that were created as copies of such instance.

        \pre Class T must inherit from Observable

        \warning see the Handle documentation for issues
                 relatives to <tt>registerAsObserver</tt>.
    */
    template <class T>
    class RelinkableHandle : public Handle<T> {
      public:
        RelinkableHandle()
        : RelinkableHandle(ext::shared_ptr<T>()) {}
        explicit RelinkableHandle(
                       const ext::shared_ptr<T>& p,
                       bool registerAsObserver = true);
        explicit RelinkableHandle(
                       ext::shared_ptr<T>&& p,
                       bool registerAsObserver = true);
        void linkTo(const ext::shared_ptr<T>& h,
                    bool registerAsObserver = true);
        void linkTo(ext::shared_ptr<T>&& h,
                    bool registerAsObserver = true);
        void reset();
    };


    // inline definitions

    template <class T>
    inline Handle<T>::Link::Link(const ext::shared_ptr<T>& h, bool registerAsObserver) {
        linkTo(h, registerAsObserver);
    }

    template <class T>
    inline Handle<T>::Link::Link(ext::shared_ptr<T>&& h, bool registerAsObserver) {
        linkTo(std::move(h), registerAsObserver);
    }

    template <class T>
    inline void Handle<T>::Link::linkTo(ext::shared_ptr<T> h,
                                        bool registerAsObserver) {
        if ((h != h_) || (isObserver_ != registerAsObserver)) {
            if (h_ && isObserver_)
                unregisterWith(h_);
            h_ = std::move(h);
            isObserver_ = registerAsObserver;
            if (h_ && isObserver_)
                registerWith(h_);
            notifyObservers();
        }
    }


    template <class T>
    inline const ext::shared_ptr<T>& Handle<T>::currentLink() const {
        QL_REQUIRE(!empty(), "empty Handle cannot be dereferenced");
        return link_->currentLink();
    }

    template <class T>
    inline const ext::shared_ptr<T>& Handle<T>::operator->() const {
        QL_REQUIRE(!empty(), "empty Handle cannot be dereferenced");
        return link_->currentLink();
    }

    template <class T>
    inline const ext::shared_ptr<T>& Handle<T>::operator*() const {
        QL_REQUIRE(!empty(), "empty Handle cannot be dereferenced");
        return link_->currentLink();
    }

    template <class T>
    inline bool Handle<T>::empty() const {
        return link_->empty();
    }

    template <class T>
    inline Handle<T>::operator ext::shared_ptr<Observable>() const {
        return link_;
    }


    template <class T>
    inline RelinkableHandle<T>::RelinkableHandle(const ext::shared_ptr<T>& p,
                                                 bool registerAsObserver)
    : Handle<T>(p,registerAsObserver) {}

    template <class T>
    inline RelinkableHandle<T>::RelinkableHandle(ext::shared_ptr<T>&& p,
                                                 bool registerAsObserver)
    : Handle<T>(std::move(p), registerAsObserver) {}

    template <class T>
    inline void RelinkableHandle<T>::linkTo(const ext::shared_ptr<T>& h,
                                            bool registerAsObserver) {
        this->link_->linkTo(h, registerAsObserver);
    }

    template <class T>
    inline void RelinkableHandle<T>::linkTo(ext::shared_ptr<T>&& h,
                                            bool registerAsObserver) {
        this->link_->linkTo(std::move(h), registerAsObserver);
    }

    template <class T>
    inline void RelinkableHandle<T>::reset() {
        this->link_->linkTo(nullptr, true);
    }

}

#endif
]]></document_content>
  </document>
  <document index="26">
    <source>index.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/index.hpp>

namespace QuantLib {

    void Index::addFixing(const Date& fixingDate,
                          Real fixing,
                          bool forceOverwrite) {
        checkNativeFixingsAllowed();
        addFixings(&fixingDate, (&fixingDate) + 1, &fixing, forceOverwrite);
    }

    void Index::addFixings(const TimeSeries<Real>& t,
                           bool forceOverwrite) {
        checkNativeFixingsAllowed();
        // is there a way of iterating over dates and values
        // without having to make a copy?
        std::vector<Date> dates = t.dates();
        std::vector<Real> values = t.values();
        addFixings(dates.begin(), dates.end(),
                   values.begin(),
                   forceOverwrite);
    }

    void Index::clearFixings() {
        checkNativeFixingsAllowed();
        QL_DEPRECATED_DISABLE_WARNING
        IndexManager::instance().clearHistory(name());
        QL_DEPRECATED_ENABLE_WARNING
    }

    void Index::checkNativeFixingsAllowed() {
        QL_REQUIRE(allowsNativeFixings(),
                   "native fixings not allowed for " << name()
                   << "; refer to underlying indices instead");
    }

}

]]></document_content>
  </document>
  <document index="27">
    <source>index.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl
 Copyright (C) 2007, 2008 Ferdinando Ametrano
 Copyright (C) 2007 Chiara Fornarola

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file index.hpp
    \brief virtual base class for indexes
*/

#ifndef quantlib_index_hpp
#define quantlib_index_hpp

#include <ql/indexes/indexmanager.hpp>
#include <ql/math/comparison.hpp>
#include <ql/patterns/observable.hpp>
#include <ql/time/calendar.hpp>

namespace QuantLib {

    //! purely virtual base class for indexes
    /*! \warning this class performs no check that the
                 provided/requested fixings are for dates in the past,
                 i.e. for dates less than or equal to the evaluation
                 date. It is up to the client code to take care of
                 possible inconsistencies due to "seeing in the
                 future"
    */
    class Index : public Observable, public Observer {
      public:
        ~Index() override = default;
        //! Returns the name of the index.
        /*! \warning This method is used for output and comparison
                     between indexes. It is <b>not</b> meant to be
                     used for writing switch-on-type code.
        */
        virtual std::string name() const = 0;
        //! returns the calendar defining valid fixing dates
        virtual Calendar fixingCalendar() const = 0;
        //! returns TRUE if the fixing date is a valid one
        virtual bool isValidFixingDate(const Date& fixingDate) const = 0;
        //! returns whether a historical fixing was stored for the given date
        bool hasHistoricalFixing(const Date& fixingDate) const;
        //! returns the fixing at the given date
        /*! the date passed as arguments must be the actual calendar
            date of the fixing; no settlement days must be used.
        */
        virtual Real fixing(const Date& fixingDate, bool forecastTodaysFixing = false) const = 0;
        //! returns a past fixing at the given date
        /*! the date passed as arguments must be the actual calendar
            date of the fixing; no settlement days must be used.
        */
        virtual Real pastFixing(const Date& fixingDate) const;
        //! returns the fixing TimeSeries
        const TimeSeries<Real>& timeSeries() const {
            QL_DEPRECATED_DISABLE_WARNING
            return IndexManager::instance().getHistory(name());
            QL_DEPRECATED_ENABLE_WARNING
        }
        //! check if index allows for native fixings.
        /*! If this returns false, calls to addFixing and similar
            methods will raise an exception.
        */
        virtual bool allowsNativeFixings() { return true; }
        //! stores the historical fixing at the given date
        /*! the date passed as arguments must be the actual calendar
            date of the fixing; no settlement days must be used.
        */
        //! \name Observer interface
        //@{
        void update() override;
        //@}
        virtual void addFixing(const Date& fixingDate, Real fixing, bool forceOverwrite = false);
        //! stores historical fixings from a TimeSeries
        /*! the dates in the TimeSeries must be the actual calendar
            dates of the fixings; no settlement days must be used.
        */
        void addFixings(const TimeSeries<Real>& t, bool forceOverwrite = false);
        //! stores historical fixings at the given dates
        /*! the dates passed as arguments must be the actual calendar
            dates of the fixings; no settlement days must be used.
        */
        template <class DateIterator, class ValueIterator>
        void addFixings(DateIterator dBegin,
                        DateIterator dEnd,
                        ValueIterator vBegin,
                        bool forceOverwrite = false) {
            checkNativeFixingsAllowed();
            IndexManager::instance().addFixings(
                name(), dBegin, dEnd, vBegin, forceOverwrite,
                [this](const Date& d) { return isValidFixingDate(d); });
        }
        //! clears all stored historical fixings
        void clearFixings();

      protected:
        ext::shared_ptr<Observable> notifier() const {
            QL_DEPRECATED_DISABLE_WARNING
            return IndexManager::instance().notifier(name());
            QL_DEPRECATED_ENABLE_WARNING
        }

      private:
        //! check if index allows for native fixings
        void checkNativeFixingsAllowed();

    };

    inline bool Index::hasHistoricalFixing(const Date& fixingDate) const {
        QL_DEPRECATED_DISABLE_WARNING
        return IndexManager::instance().hasHistoricalFixing(name(), fixingDate);
        QL_DEPRECATED_ENABLE_WARNING
    }

    inline Real Index::pastFixing(const Date& fixingDate) const {
        QL_REQUIRE(isValidFixingDate(fixingDate), fixingDate << " is not a valid fixing date");
        return timeSeries()[fixingDate];
    }

    inline void Index::update() {
        notifyObservers();
    }

}

#endif
]]></document_content>
  </document>
  <document index="28">
    <source>instrument.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instrument.hpp>
#include <ql/settings.hpp>

namespace QuantLib {

    Instrument::Instrument()
    : NPV_(Null<Real>()), errorEstimate_(Null<Real>()) {
        // this makes sense in general (if the evaluation date
        // changes, you probably want to recalculate) and can also
        // help avoid some edge cases when lazy objects only forward
        // their first notification.
        registerWith(Settings::instance().evaluationDate());
    }

    void Instrument::setPricingEngine(const ext::shared_ptr<PricingEngine>& e) {
        if (engine_ != nullptr)
            unregisterWith(engine_);
        engine_ = e;
        if (engine_ != nullptr)
            registerWith(engine_);
        // trigger (lazy) recalculation and notify observers
        update();
    }

    void Instrument::setupArguments(PricingEngine::arguments*) const {
        QL_FAIL("Instrument::setupArguments() not implemented");
    }

}
]]></document_content>
  </document>
  <document index="29">
    <source>instrument.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file instrument.hpp
    \brief Abstract instrument class
*/

#ifndef quantlib_instrument_hpp
#define quantlib_instrument_hpp

#include <ql/patterns/lazyobject.hpp>
#include <ql/pricingengine.hpp>
#include <ql/utilities/null.hpp>
#include <ql/time/date.hpp>
#include <ql/any.hpp>
#include <map>
#include <string>

namespace QuantLib {

    //! Abstract instrument class
    /*! This class is purely abstract and defines the interface of concrete
        instruments which will be derived from this one.

        \test observability of class instances is checked.
    */
    class Instrument : public LazyObject {
      public:
        class results;
        Instrument();
        //! \name Inspectors
        //@{

        //! returns the net present value of the instrument.
        Real NPV() const;
        //! returns the error estimate on the NPV when available.
        Real errorEstimate() const;
        //! returns the date the net present value refers to.
        const Date& valuationDate() const;

        const ext::shared_ptr<PricingEngine>& pricingEngine() const;
        //! returns any additional result returned by the pricing engine.
        template <typename T> T result(const std::string& tag) const;
        //! returns all additional result returned by the pricing engine.
        const std::map<std::string, ext::any>& additionalResults() const;

        //! returns whether the instrument might have value greater than zero.
        virtual bool isExpired() const = 0;
        //@}
        //! \name Modifiers
        //@{
        //! set the pricing engine to be used.
        /*! \warning calling this method will have no effects in
                     case the <b>performCalculation</b> method
                     was overridden in a derived class.
        */
        void setPricingEngine(const ext::shared_ptr<PricingEngine>&);
        //@}
        /*! When a derived argument structure is defined for an
            instrument, this method should be overridden to fill
            it. This is mandatory in case a pricing engine is used.
        */
        virtual void setupArguments(PricingEngine::arguments*) const;
        /*! When a derived result structure is defined for an
            instrument, this method should be overridden to read from
            it. This is mandatory in case a pricing engine is used.
        */
        virtual void fetchResults(const PricingEngine::results*) const;
      protected:
        //! \name Calculations
        //@{
        void calculate() const override;
        /*! This method must leave the instrument in a consistent
            state when the expiration condition is met.
        */
        virtual void setupExpired() const;
        /*! In case a pricing engine is <b>not</b> used, this
            method must be overridden to perform the actual
            calculations and set any needed results. In case
            a pricing engine is used, the default implementation
            can be used.
        */
        void performCalculations() const override;
        //@}
        /*! \name Results
            The value of this attribute and any other that derived
            classes might declare must be set during calculation.
        */
        //@{
        mutable Real NPV_, errorEstimate_;
        mutable Date valuationDate_;
        mutable std::map<std::string, ext::any> additionalResults_;
        //@}
        ext::shared_ptr<PricingEngine> engine_;
    };

    class Instrument::results : public virtual PricingEngine::results {
      public:
        void reset() override {
            value = errorEstimate = Null<Real>();
            valuationDate = Date();
            additionalResults.clear();
        }
        Real value;
        Real errorEstimate;
        Date valuationDate;
        std::map<std::string, ext::any> additionalResults;
    };


    // inline definitions

    inline void Instrument::calculate() const {
        if (!calculated_) {
            if (isExpired()) {
                setupExpired();
                calculated_ = true;
            } else {
                LazyObject::calculate();
            }
        }
    }

    inline void Instrument::setupExpired() const {
        NPV_ = errorEstimate_ = 0.0;
        valuationDate_ = Date();
        additionalResults_.clear();
    }

    inline void Instrument::performCalculations() const {
        QL_REQUIRE(engine_, "null pricing engine");
        engine_->reset();
        setupArguments(engine_->getArguments());
        engine_->getArguments()->validate();
        engine_->calculate();
        fetchResults(engine_->getResults());
    }

    inline void Instrument::fetchResults(
                                      const PricingEngine::results* r) const {
        const auto* results = dynamic_cast<const Instrument::results*>(r);
        QL_ENSURE(results != nullptr, "no results returned from pricing engine");

        NPV_ = results->value;
        errorEstimate_ = results->errorEstimate;
        valuationDate_ = results->valuationDate;

        additionalResults_ = results->additionalResults;
    }

    inline Real Instrument::NPV() const {
        calculate();
        QL_REQUIRE(NPV_ != Null<Real>(), "NPV not provided");
        return NPV_;
    }

    inline Real Instrument::errorEstimate() const {
        calculate();
        QL_REQUIRE(errorEstimate_ != Null<Real>(),
                   "error estimate not provided");
        return errorEstimate_;
    }

    inline const Date& Instrument::valuationDate() const {
        calculate();
        QL_REQUIRE(valuationDate_ != Date(),
                   "valuation date not provided");
        return valuationDate_;
    }

    inline const ext::shared_ptr<PricingEngine>& Instrument::pricingEngine() const {
        return engine_;
    }

    template <class T>
    inline T Instrument::result(const std::string& tag) const {
        calculate();
        auto value =
            additionalResults_.find(tag);
        QL_REQUIRE(value != additionalResults_.end(),
                   tag << " not provided");
        return ext::any_cast<T>(value->second);
    }

    inline const std::map<std::string, ext::any>&
    Instrument::additionalResults() const {
        calculate();
        return additionalResults_;
    }

}

#endif
]]></document_content>
  </document>
  <document index="30">
    <source>interestrate.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/interestrate.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <iomanip>
#include <sstream>
#include <utility>

namespace QuantLib {

    // constructors

    InterestRate::InterestRate()
    : r_(Null<Real>()) {}

    InterestRate::InterestRate(Rate r, DayCounter dc, Compounding comp, Frequency freq)
    : r_(r), dc_(std::move(dc)), comp_(comp), freqMakesSense_(false) {

        if (comp_==Compounded || comp_==SimpleThenCompounded || comp_==CompoundedThenSimple) {
            freqMakesSense_ = true;
            QL_REQUIRE(freq!=Once && freq!=NoFrequency,
                       "frequency not allowed for this interest rate");
            freq_ = Real(freq);
        }
    }

    Real InterestRate::compoundFactor(Time t) const {

        QL_REQUIRE(t>=0.0, "negative time (" << t << ") not allowed");
        QL_REQUIRE(r_ != Null<Rate>(), "null interest rate");
        switch (comp_) {
          case Simple:
            return 1.0 + r_*t;
          case Compounded:
            return std::pow(1.0+r_/freq_, freq_*t);
          case Continuous:
            return std::exp(r_*t);
          case SimpleThenCompounded:
            if (t<=1.0/Real(freq_))
                return 1.0 + r_*t;
            else
                return std::pow(1.0+r_/freq_, freq_*t);
          case CompoundedThenSimple:
            if (t>1.0/Real(freq_))
                return 1.0 + r_*t;
            else
                return std::pow(1.0+r_/freq_, freq_*t);
          default:
            QL_FAIL("unknown compounding convention");
        }
    }

    InterestRate InterestRate::impliedRate(Real compound,
                                           const DayCounter& resultDC,
                                           Compounding comp,
                                           Frequency freq,
                                           Time t) {

        QL_REQUIRE(compound>0.0, "positive compound factor required");

        Rate r;
        if (compound==1.0) {
            QL_REQUIRE(t>=0.0, "non negative time (" << t << ") required");
            r = 0.0;
        } else {
            QL_REQUIRE(t>0.0, "positive time (" << t << ") required");
            switch (comp) {
              case Simple:
                r = (compound - 1.0)/t;
                break;
              case Compounded:
                r = (std::pow(compound, 1.0/(Real(freq)*t))-1.0)*Real(freq);
                break;
              case Continuous:
                r = std::log(compound)/t;
                break;
              case SimpleThenCompounded:
                if (t<=1.0/Real(freq))
                    r = (compound - 1.0)/t;
                else
                    r = (std::pow(compound, 1.0/(Real(freq)*t))-1.0)*Real(freq);
                break;
              case CompoundedThenSimple:
                if (t>1.0/Real(freq))
                    r = (compound - 1.0)/t;
                else
                    r = (std::pow(compound, 1.0/(Real(freq)*t))-1.0)*Real(freq);
                break;
              default:
                QL_FAIL("unknown compounding convention ("
                        << Integer(comp) << ")");
            }
        }
        return InterestRate(r, resultDC, comp, freq);
    }


    std::ostream& operator<<(std::ostream& out, const InterestRate& ir) {
        if (ir.rate() == Null<Rate>())
            return out << "null interest rate";

        out << io::rate(ir.rate()) << " " << ir.dayCounter().name() << " ";
        switch (ir.compounding()) {
          case Simple:
            out << "simple compounding";
            break;
          case Compounded:
            switch (ir.frequency()) {
              case NoFrequency:
              case Once:
                QL_FAIL(ir.frequency() << " frequency not allowed "
                        "for this interest rate");
              default:
                out << ir.frequency() <<" compounding";
            }
            break;
          case Continuous:
            out << "continuous compounding";
            break;
          case SimpleThenCompounded:
            switch (ir.frequency()) {
              case NoFrequency:
              case Once:
                QL_FAIL(ir.frequency() << " frequency not allowed "
                        "for this interest rate");
              default:
                out << "simple compounding up to "
                    << Integer(12/ir.frequency()) << " months, then "
                    << ir.frequency() << " compounding";
            }
            break;
          case CompoundedThenSimple:
            switch (ir.frequency()) {
              case NoFrequency:
              case Once:
                QL_FAIL(ir.frequency() << " frequency not allowed "
                        "for this interest rate");
              default:
                out << "compounding up to "
                    << Integer(12/ir.frequency()) << " months, then "
                    << ir.frequency() << " simple compounding";
            }
            break;
          default:
            QL_FAIL("unknown compounding convention ("
                    << Integer(ir.compounding()) << ")");
        }
        return out;
    }

}
]]></document_content>
  </document>
  <document index="31">
    <source>interestrate.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file interestrate.hpp
    \brief Instrument rate class
*/

#ifndef quantlib_interest_rate_hpp
#define quantlib_interest_rate_hpp

#include <ql/compounding.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>

namespace QuantLib {

    //! Concrete interest rate class
    /*! This class encapsulate the interest rate compounding algebra.
        It manages day-counting conventions, compounding conventions,
        conversion between different conventions, discount/compound factor
        calculations, and implied/equivalent rate calculations.

        \test Converted rates are checked against known good results
    */
    class InterestRate {
      public:
        //! \name constructors
        //@{
        //! Default constructor returning a null interest rate.
        InterestRate();
        //! Standard constructor
        InterestRate(Rate r, DayCounter dc, Compounding comp, Frequency freq);
        //@}
        //! \name conversions
        //@{
        operator Rate() const { return r_; }
        //@}
        //! \name inspectors
        //@{
        Rate rate() const { return r_; }
        const DayCounter& dayCounter() const { return dc_; }
        Compounding compounding() const { return comp_; }
        Frequency frequency() const {
            return freqMakesSense_ ? Frequency(Integer(freq_)) : NoFrequency;
        }
        //@}

        //! \name discount/compound factor calculations
        //@{
        //! discount factor implied by the rate compounded at time t.
        /*! \warning Time must be measured using InterestRate's own
                     day counter.
        */
        DiscountFactor discountFactor(Time t) const {
            return 1.0/compoundFactor(t);
        }

        //! discount factor implied by the rate compounded between two dates
        DiscountFactor discountFactor(const Date& d1,
                                      const Date& d2,
                                      const Date& refStart = Date(),
                                      const Date& refEnd = Date()) const {
            QL_REQUIRE(d2>=d1,
                       "d1 (" << d1 << ") "
                       "later than d2 (" << d2 << ")");
            Time t = dc_.yearFraction(d1, d2, refStart, refEnd);
            return discountFactor(t);
        }

        //! compound factor implied by the rate compounded at time t.
        /*! returns the compound (a.k.a capitalization) factor
            implied by the rate compounded at time t.

            \warning Time must be measured using InterestRate's own
                     day counter.
        */
        Real compoundFactor(Time t) const;

        //! compound factor implied by the rate compounded between two dates
        /*! returns the compound (a.k.a capitalization) factor
            implied by the rate compounded between two dates.
        */
        Real compoundFactor(const Date& d1,
                            const Date& d2,
                            const Date& refStart = Date(),
                            const Date& refEnd = Date()) const {
            QL_REQUIRE(d2>=d1,
                       "d1 (" << d1 << ") "
                       "later than d2 (" << d2 << ")");
            Time t = dc_.yearFraction(d1, d2, refStart, refEnd);
            return compoundFactor(t);
        }
        //@}

        //! \name implied rate calculations
        //@{

        //! implied interest rate for a given compound factor at a given time.
        /*! The resulting InterestRate has the day-counter provided as input.

            \warning Time must be measured using the day-counter provided
                     as input.
        */
        static InterestRate impliedRate(Real compound,
                                        const DayCounter& resultDC,
                                        Compounding comp,
                                        Frequency freq,
                                        Time t);

        //! implied rate for a given compound factor between two dates.
        /*! The resulting rate is calculated taking the required
            day-counting rule into account.
        */
        static InterestRate impliedRate(Real compound,
                                        const DayCounter& resultDC,
                                        Compounding comp,
                                        Frequency freq,
                                        const Date& d1,
                                        const Date& d2,
                                        const Date& refStart = Date(),
                                        const Date& refEnd = Date()) {
            QL_REQUIRE(d2>=d1,
                       "d1 (" << d1 << ") "
                       "later than d2 (" << d2 << ")");
            Time t = resultDC.yearFraction(d1, d2, refStart, refEnd);
            return impliedRate(compound, resultDC, comp, freq, t);
        }
        //@}

        //! \name equivalent rate calculations
        //@{

        //! equivalent interest rate for a compounding period t.
        /*! The resulting InterestRate shares the same implicit
            day-counting rule of the original InterestRate instance.

            \warning Time must be measured using the InterestRate's
                     own day counter.
        */
        InterestRate equivalentRate(Compounding comp,
                                    Frequency freq,
                                    Time t) const {
            return impliedRate(compoundFactor(t), dc_, comp, freq, t);
        }

        //! equivalent rate for a compounding period between two dates
        /*! The resulting rate is calculated taking the required
            day-counting rule into account.
        */
        InterestRate equivalentRate(const DayCounter& resultDC,
                                    Compounding comp,
                                    Frequency freq,
                                    Date d1,
                                    Date d2,
                                    const Date& refStart = Date(),
                                    const Date& refEnd = Date()) const {
            QL_REQUIRE(d2>=d1,
                       "d1 (" << d1 << ") "
                       "later than d2 (" << d2 << ")");
            Time t1 = dc_.yearFraction(d1, d2, refStart, refEnd);
            Time t2 = resultDC.yearFraction(d1, d2, refStart, refEnd);
            return impliedRate(compoundFactor(t1), resultDC, comp, freq, t2);
        }
        //@}
      private:
        Rate r_;
        DayCounter dc_;
        Compounding comp_;
        bool freqMakesSense_;
        Real freq_;
    };

    /*! \relates InterestRate */
    std::ostream& operator<<(std::ostream&,
                             const InterestRate&);

}

#endif
]]></document_content>
  </document>
  <document index="32">
    <source>mathconstants.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_math_constants_hpp
#define quantlib_math_constants_hpp

#include <cmath>

#ifndef M_E
    #define M_E         2.71828182845904523536
#endif

#ifndef M_LOG2E
    #define M_LOG2E     1.44269504088896340736
#endif

#ifndef M_LOG10E
    #define M_LOG10E    0.434294481903251827651
#endif

#ifndef M_IVLN10
    #define M_IVLN10    0.434294481903251827651
#endif

#ifndef M_LN2
    #define M_LN2       0.693147180559945309417
#endif

#ifndef M_LOG2_E
    #define M_LOG2_E    0.693147180559945309417
#endif

#ifndef M_LN10
    #define M_LN10      2.30258509299404568402
#endif

#ifndef M_PI
#    define M_PI 3.141592653589793238462643383280
#endif

#ifndef M_TWOPI
    #define M_TWOPI     (M_PI * 2.0)
#endif

#ifndef M_PI_2
    #define M_PI_2      1.57079632679489661923
#endif

#ifndef M_PI_4
    #define M_PI_4      0.785398163397448309616
#endif

#ifndef M_3PI_4
    #define M_3PI_4     2.3561944901923448370E0
#endif

#ifndef M_SQRTPI
    #define M_SQRTPI    1.77245385090551602792981
#endif

#ifndef M_1_PI
    #define M_1_PI      0.318309886183790671538
#endif

#ifndef M_2_PI
    #define M_2_PI      0.636619772367581343076
#endif

#ifndef M_1_SQRTPI
    #define M_1_SQRTPI  0.564189583547756286948
#endif

#ifndef M_2_SQRTPI
    #define M_2_SQRTPI  1.12837916709551257390
#endif

#ifndef M_SQRT2
    #define M_SQRT2     1.41421356237309504880
#endif

#ifndef M_SQRT_2
    #define M_SQRT_2    0.7071067811865475244008443621048490392848359376887
#endif

#ifndef M_SQRT1_2
    #define M_SQRT1_2   0.7071067811865475244008443621048490392848359376887
#endif

#ifndef M_LN2LO
    #define M_LN2LO     1.9082149292705877000E-10
#endif

#ifndef M_LN2HI
    #define M_LN2HI     6.9314718036912381649E-1
#endif

#ifndef M_SQRT3
    #define M_SQRT3     1.73205080756887719000
#endif

#ifndef M_INVLN2
    #define M_INVLN2    1.4426950408889633870E0
#endif

/* This should ensure that no macro are redefined if we happen to
   include <math.h> again, whether or not we're using our macros
   or theirs. We can't know in advance, since it depends on the
   order of inclusion of headers in client code. */
#ifdef _MSC_VER
    #undef _USE_MATH_DEFINES
#endif

#endif

]]></document_content>
  </document>
  <document index="33">
    <source>money.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Decillion Pty(Ltd)
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/money.hpp>
#include <ql/currencies/exchangeratemanager.hpp>
#include <ql/math/comparison.hpp>

namespace QuantLib {

    namespace {

        void convertTo(Money& m, const Currency& target) {
            if (m.currency() != target) {
                ExchangeRate rate =
                    ExchangeRateManager::instance().lookup(m.currency(),
                                                           target);
                m = rate.exchange(m).rounded();
            }
        }

        void convertToBase(Money& m) {
            const auto & base_currency =
                Money::Settings::instance().baseCurrency();
            QL_REQUIRE(!base_currency.empty(), "no base currency set");
            convertTo(m, base_currency);
        }

        template< typename ReturnValue, typename Function >
        ReturnValue apply(const Money& m1, const Money& m2, const Function f) {
            const auto & conversion_type =
                Money::Settings::instance().conversionType();
            if (m1.currency() == m2.currency()) {
                return f(m1.value(), m2.value());
            } else if (conversion_type == Money::BaseCurrencyConversion) {
                Money tmp1 = m1;
                convertToBase(tmp1);
                Money tmp2 = m2;
                convertToBase(tmp2);
                return f(tmp1.value(), tmp2.value());
            } else if (conversion_type == Money::AutomatedConversion) {
                Money tmp = m2;
                convertTo(tmp, m1.currency());
                return f(m1.value(), tmp.value());
            } else {
                QL_FAIL("currency mismatch and no conversion specified");
            }
        }
    }

    Money& Money::operator+=(const Money& m) {
        const auto & conversion_type = Settings::instance().conversionType();
        if (currency_ == m.currency_) {
            value_ += m.value_;
        } else if (conversion_type == Money::BaseCurrencyConversion) {
            convertToBase(*this);
            Money tmp = m;
            convertToBase(tmp);
            *this += tmp;
        } else if (conversion_type == Money::AutomatedConversion) {
            Money tmp = m;
            convertTo(tmp, currency_);
            *this += tmp;
        } else {
            QL_FAIL("currency mismatch and no conversion specified");
        }
        return *this;
    }

    Money& Money::operator-=(const Money& m) {
        return *this += (-m);
    }

    Decimal operator/(const Money& m1, const Money& m2) {
        return apply<Decimal>(
                    m1, m2,
                    [](const Real x, const Real y) { return x / y; });
    }

    bool operator==(const Money& m1, const Money& m2) {
        return apply<bool>(
                    m1, m2,
                    [](const Real x, const Real y) { return x == y; });
    }

    bool operator<(const Money& m1, const Money& m2) {
        return apply<bool>(
                    m1, m2,
                    [](const Real x, const Real y) { return x < y; });
    }

    bool operator<=(const Money& m1, const Money& m2) {
        return apply<bool>(
                    m1, m2,
                    [](const Real x, const Real y) { return x <= y; });
    }

    bool close(const Money& m1, const Money& m2, Size n) {
        return apply<bool>(
                    m1, m2,
                    [n](const Real x, const Real y) { return close(x, y, n); });
    }

    bool close_enough(const Money& m1, const Money& m2, Size n) {
        return apply<bool>(
                    m1, m2,
                    [n](const Real x, const Real y) { return close_enough(x, y, n); });
    }

    std::ostream& operator<<(std::ostream& out, const Money& m) {
        return out << m.rounded().value() << " " << m.currency().code();
    }

    const Money::ConversionType & Money::Settings::conversionType() const
    {
        return conversionType_;
    }

    Money::ConversionType & Money::Settings::conversionType()
    {
        return conversionType_;
    }

    const Currency & Money::Settings::baseCurrency() const
    {
        return baseCurrency_;
    }

    Currency & Money::Settings::baseCurrency()
    {
        return baseCurrency_;
    }

    Money::BaseCurrencyProxy& Money::BaseCurrencyProxy::operator=(const Currency& c) {
        Money::Settings::instance().baseCurrency() = c;
        return *this;
    }

    Money::BaseCurrencyProxy::operator Currency() const {
        return Money::Settings::instance().baseCurrency();
    }

    Money::ConversionTypeProxy& Money::ConversionTypeProxy::operator=(ConversionType t) {
        Money::Settings::instance().conversionType() = t;
        return *this;
    }

    Money::ConversionTypeProxy::operator Money::ConversionType() const {
        return Money::Settings::instance().conversionType();
    }

}
]]></document_content>
  </document>
  <document index="34">
    <source>money.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Decillion Pty(Ltd)
 Copyright (C) 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file money.hpp
    \brief cash amount in a given currency
*/

#ifndef quantlib_money_hpp
#define quantlib_money_hpp

#include <ql/currency.hpp>
#include <ql/patterns/singleton.hpp>
#include <utility>

namespace QuantLib {

    //! amount of cash
    /*! \test money arithmetic is tested with and without currency
              conversions.
    */
    class Money {
      public:
        //! \name Constructors
        //@{
        Money() = default;
        Money(Currency currency, Decimal value);
        Money(Decimal value, Currency currency);
        //@}
        //! \name Inspectors
        //@{
        const Currency& currency() const;
        Decimal value() const;
        Money rounded() const;
        //@}
        /*! \name Money arithmetics

            See below for non-member functions and for settings which
            determine the behavior of the operators.
        */
        //@{
        Money operator+() const;
        Money operator-() const;
        Money& operator+=(const Money&);
        Money& operator-=(const Money&);
        Money& operator*=(Decimal);
        Money& operator/=(Decimal);
        //@}
        /*! \name Conversion settings

            These parameters are used for combining money amounts
            in different currencies
        */
        //@{
        enum ConversionType {
            NoConversion,           /*!< do not perform conversions */
            BaseCurrencyConversion, /*!< convert both operands to
                                         the base currency before
                                         converting */
            AutomatedConversion     /*!< return the result in the
                                         currency of the first
                                         operand */
        };
        // Money::Settings forward declaration
        class Settings;
        //@}
      private:
        Decimal value_ = 0.0;
        Currency currency_;

        // temporary support for old syntax
        struct BaseCurrencyProxy {
          public:
            BaseCurrencyProxy& operator=(const Currency&);
            operator Currency() const;
        };

        struct ConversionTypeProxy {
          public:
            ConversionTypeProxy& operator=(Money::ConversionType);
            operator Money::ConversionType() const;
        };
    };

    //! Per-session settings for the Money class
    class Money::Settings : public Singleton<Money::Settings> {
        friend class Singleton<Money::Settings>;
      private:
        Settings() = default;

      public:
        const Money::ConversionType & conversionType() const;
        Money::ConversionType & conversionType();

        const Currency & baseCurrency() const;
        Currency & baseCurrency();

      private:
        Money::ConversionType conversionType_ = Money::NoConversion;
        Currency baseCurrency_;
    };

    // More arithmetics and comparisons

    /*! \relates Money */
    Money operator+(const Money&, const Money&);
    /*! \relates Money */
    Money operator-(const Money&, const Money&);
    /*! \relates Money */
    Money operator*(const Money&, Decimal);
    /*! \relates Money */
    Money operator*(Decimal, const Money&);
    /*! \relates Money */
    Money operator/(const Money&, Decimal);
    /*! \relates Money */
    Decimal operator/(const Money&, const Money&);

    /*! \relates Money */
    bool operator==(const Money&, const Money&);
    /*! \relates Money */
    bool operator!=(const Money&, const Money&);
    /*! \relates Money */
    bool operator<(const Money&, const Money&);
    /*! \relates Money */
    bool operator<=(const Money&, const Money&);
    /*! \relates Money */
    bool operator>(const Money&, const Money&);
    /*! \relates Money */
    bool operator>=(const Money&, const Money&);

    /*! \relates Money */
    bool close(const Money&, const Money&, Size n = 42);
    /*! \relates Money */
    bool close_enough(const Money&, const Money&, Size n = 42);

    // syntactic sugar

    /*! \relates Money */
    Money operator*(Decimal, const Currency&);
    /*! \relates Money */
    Money operator*(const Currency&, Decimal);

    // formatting

    /*! \relates Money */
    std::ostream& operator<<(std::ostream&, const Money&);


    // inline definitions

    inline Money::Money(Currency currency, Decimal value)
    : value_(value), currency_(std::move(currency)) {}

    inline Money::Money(Decimal value, Currency currency)
    : value_(value), currency_(std::move(currency)) {}

    inline const Currency& Money::currency() const {
        return currency_;
    }

    inline Decimal Money::value() const {
        return value_;
    }

    inline Money Money::rounded() const {
        return Money(currency_.rounding()(value_), currency_);
    }

    inline Money Money::operator+() const {
        return *this;
    }

    inline Money Money::operator-() const {
        return Money(-value_, currency_);
    }

    inline Money& Money::operator*=(Decimal x) {
        value_ *= x;
        return *this;
    }

    inline Money& Money::operator/=(Decimal x) {
        value_ /= x;
        return *this;
    }


    inline Money operator+(const Money& m1, const Money& m2) {
        Money tmp = m1;
        tmp += m2;
        return tmp;
    }

    inline Money operator-(const Money& m1, const Money& m2) {
        Money tmp = m1;
        tmp -= m2;
        return tmp;
    }

    inline Money operator*(const Money& m, Decimal x) {
        Money tmp = m;
        tmp *= x;
        return tmp;
    }

    inline Money operator*(Decimal x, const Money& m) {
        return m*x;
    }

    inline Money operator/(const Money& m, Decimal x) {
        Money tmp = m;
        tmp /= x;
        return tmp;
    }

    inline bool operator!=(const Money& m1, const Money& m2) {
        return !(m1 == m2);
    }

    inline bool operator>(const Money& m1, const Money& m2) {
        return m2 < m1;
    }

    inline bool operator>=(const Money& m1, const Money& m2) {
        return m2 <= m1;
    }

    inline Money operator*(Decimal value, const Currency& c) {
        return Money(value,c);
    }

    inline Money operator*(const Currency& c, Decimal value) {
        return Money(value,c);
    }

}


#endif
]]></document_content>
  </document>
  <document index="35">
    <source>numericalmethod.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file numericalmethod.hpp
    \brief Numerical method class
*/

#ifndef quantlib_lattice_hpp
#define quantlib_lattice_hpp

#include <ql/math/array.hpp>
#include <ql/timegrid.hpp>
#include <utility>

namespace QuantLib {

    class DiscretizedAsset;

    //! %Lattice (tree, finite-differences) base class
    class Lattice {
      public:
        explicit Lattice(TimeGrid timeGrid) : t_(std::move(timeGrid)) {}
        virtual ~Lattice() = default;

        //!\name Inspectors
        //{
        const TimeGrid& timeGrid() const { return t_; }
        //@}

        /*! \name Numerical method interface

            These methods are to be used by discretized assets and
            must be overridden by developers implementing numerical
            methods. Users are advised to use the corresponding
            methods of DiscretizedAsset instead.

            @{
        */

        //! initialize an asset at the given time.
        virtual void initialize(DiscretizedAsset&,
                                Time time) const = 0;

        /*! Roll back an asset until the given time, performing any
            needed adjustment.
        */
        virtual void rollback(DiscretizedAsset&,
                              Time to) const = 0;

        /*! Roll back an asset until the given time, but do not perform
            the final adjustment.

            \warning In version 0.3.7 and earlier, this method was
                     called rollAlmostBack method and performed
                     pre-adjustment. This is no longer true; when
                     migrating your code, you'll have to replace calls
                     such as:
                     \code
                     method->rollAlmostBack(asset,t);
                     \endcode
                     with the two statements:
                     \code
                     method->partialRollback(asset,t);
                     asset->preAdjustValues();
                     \endcode
        */
        virtual void partialRollback(DiscretizedAsset&,
                                     Time to) const = 0;

        //! computes the present value of an asset.
        virtual Real presentValue(DiscretizedAsset&) const = 0;

        //@}

        // this is a smell, but we need it. We'll rethink it later.
        virtual Array grid(Time) const = 0;
      protected:
        TimeGrid t_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="36">
    <source>option.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file option.hpp
    \brief Base option class
*/

#ifndef quantlib_option_hpp
#define quantlib_option_hpp

#include <ql/instrument.hpp>
#include <utility>

namespace QuantLib {

    class Payoff;
    class Exercise;

    //! base option class
    class Option : public Instrument {
      public:
        class arguments;
        enum Type { Put = -1,
                    Call = 1
        };
        Option(ext::shared_ptr<Payoff> payoff, ext::shared_ptr<Exercise> exercise)
        : payoff_(std::move(payoff)), exercise_(std::move(exercise)) {}
        void setupArguments(PricingEngine::arguments*) const override;
        ext::shared_ptr<Payoff> payoff() const { return payoff_; }
        ext::shared_ptr<Exercise> exercise() const { return exercise_; }
      protected:
        // arguments
        ext::shared_ptr<Payoff> payoff_;
        ext::shared_ptr<Exercise> exercise_;
    };

    /*! \relates Option */
    std::ostream& operator<<(std::ostream&, Option::Type);

    //! basic %option %arguments
    class Option::arguments : public virtual PricingEngine::arguments {
      public:
        arguments() = default;
        void validate() const override {
            QL_REQUIRE(payoff, "no payoff given");
            QL_REQUIRE(exercise, "no exercise given");
        }
        ext::shared_ptr<Payoff> payoff;
        ext::shared_ptr<Exercise> exercise;
    };

    //! additional %option results
    class Greeks : public virtual PricingEngine::results {
      public:
        void reset() override { delta = gamma = theta = vega = rho = dividendRho = Null<Real>(); }
        Real delta, gamma;
        Real theta;
        Real vega;
        Real rho, dividendRho;
    };

    //! more additional %option results
    class MoreGreeks : public virtual PricingEngine::results {
      public:
        void reset() override {
            itmCashProbability = deltaForward = elasticity = thetaPerDay =
                strikeSensitivity = Null<Real>();
        }
        Real itmCashProbability, deltaForward, elasticity, thetaPerDay,
             strikeSensitivity;
    };


    // inline definitions

    inline void Option::setupArguments(PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<Option::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->payoff = payoff_;
        arguments->exercise = exercise_;
    }

    inline std::ostream& operator<<(std::ostream& out, Option::Type type) {
        switch (type) {
          case Option::Call:
            return out << "Call";
          case Option::Put:
            return out << "Put";
          default:
            QL_FAIL("unknown option type");
        }
    }

}


#endif
]]></document_content>
  </document>
  <document index="37">
    <source>optional.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2023 Jonathan Sweemer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file optional.hpp
    \brief Maps optional to either the boost or std implementation
*/

#ifndef quantlib_optional_hpp
#define quantlib_optional_hpp

#include <ql/qldefines.hpp>

#if defined(QL_USE_STD_OPTIONAL)
#include <optional>
#else
// Deprecated in version 1.39
#pragma message("Warning: using boost::optional is deprecated.  Enable std::optional instead.")
#include <boost/optional.hpp>
#endif

namespace QuantLib::ext {

        #if defined(QL_USE_STD_OPTIONAL)
        using std::optional;                    // NOLINT(misc-unused-using-decls)
        inline constexpr const std::nullopt_t& nullopt = std::nullopt;
        #else
        using boost::optional;                  // NOLINT(misc-unused-using-decls)
        inline constexpr const boost::none_t& nullopt = boost::none;
        #endif

    }

#endif
]]></document_content>
  </document>
  <document index="38">
    <source>payoff.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2006 Ferdinando Ametrano
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file payoff.hpp
    \brief Option payoff classes
*/

#ifndef quantlib_payoff_hpp
#define quantlib_payoff_hpp

#include <ql/types.hpp>
#include <ql/patterns/visitor.hpp>
#include <ql/errors.hpp>
#include <functional>

namespace QuantLib {

    //! Abstract base class for option payoffs
    class Payoff {
      public:
        virtual ~Payoff() = default;
        //! \name Payoff interface
        //@{
        /*! \warning This method is used for output and comparison between
                payoffs. It is <b>not</b> meant to be used for writing
                switch-on-type code.
        */
        virtual std::string name() const = 0;
        virtual std::string description() const = 0;
        virtual Real operator()(Real price) const = 0;
        //@}
        //! \name Visitability
        //@{
        virtual void accept(AcyclicVisitor&);
        //@}
    };


    // inline definitions

    inline void Payoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<Payoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            QL_FAIL("not a payoff visitor");
    }

}


#endif
]]></document_content>
  </document>
  <document index="39">
    <source>position.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Cristina Duminuco

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/position.hpp>
#include <ql/types.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    std::ostream& operator<<(std::ostream& out, Position::Type p) {
        switch (p) {
          case Position::Long :
            return out << "Long";
          case Position::Short :
            return out << "Short";
          default:
            QL_FAIL("unknown Position Type (" << Integer(p) << ")");
        }
    }

}
]]></document_content>
  </document>
  <document index="40">
    <source>position.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file position.hpp
    \brief Short or long position
*/

#ifndef quantlib_position_hpp
#define quantlib_position_hpp

#include <ql/qldefines.hpp>
#include <iosfwd>

namespace QuantLib {

    struct Position {
        enum Type { Long, Short };
    };

    /*! \relates Position */
    std::ostream& operator<<(std::ostream&,
                             Position::Type);

}


#endif

]]></document_content>
  </document>
  <document index="41">
    <source>prices.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006 Katiuscia Manzoni
 Copyright (C) 2006 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/prices.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    Real midEquivalent(const Real bid,
                       const Real ask,
                       const Real last,
                       const Real close)
    {
        if (bid != Null<Real>() && bid > 0.0) {
            if (ask != Null<Real>() && ask > 0.0) return ((bid+ask)/2.0);
            else                                  return bid;
        } else {
            if (ask != Null<Real>() && ask > 0.0)          return ask;
            else if (last != Null<Real>() && last > 0.0)   return last;
            else {
                QL_REQUIRE(close != Null<Real>() && close > 0.0,
                           "all input prices are invalid");
                return close;
            }
        }
    }

    Real midSafe(const Real bid,
                 const Real ask)
    {
        QL_REQUIRE(bid != Null<Real>() && bid > 0.0,
                   "invalid bid price");
        QL_REQUIRE(ask != Null<Real>() && ask > 0.0,
                   "invalid ask price");
        return (bid+ask)/2.0;
    }


    IntervalPrice::IntervalPrice()
    : open_(Null<Real>()), close_(Null<Real>()),
      high_(Null<Real>()), low_(Null<Real>()) {}

    IntervalPrice::IntervalPrice(Real open, Real close, Real high, Real low)
    : open_(open), close_(close), high_(high), low_(low) {}

    Real IntervalPrice::value(IntervalPrice::Type t) const {
        switch(t) {
          case Open:
            return open_;
          case Close:
            return close_;
          case High:
            return high_;
          case Low:
            return low_;
          default:
            QL_FAIL("Unknown price type");
        }
    }

    void IntervalPrice::setValue(Real value,
                                 IntervalPrice::Type t) {
        switch(t) {
          case Open:
            open_ = value;
            break;
          case Close:
            close_ = value;
            break;
          case High:
            high_ = value;
            break;
          case Low:
            low_ = value;
            break;
          default:
            QL_FAIL("Unknown price type");
        }
    }

    void IntervalPrice::setValues(Real open, Real close, Real high, Real low) {
        open_ = open; close_ = close; high_ = high; low_ = low;
    }


    TimeSeries<IntervalPrice> IntervalPrice::makeSeries(
                                               const std::vector<Date>& d,
                                               const std::vector<Real>& open,
                                               const std::vector<Real>& close,
                                               const std::vector<Real>& high,
                                               const std::vector<Real>& low) {
        Size dsize = d.size();
        QL_REQUIRE((open.size() == dsize && close.size() == dsize &&
                    high.size() == dsize && low.size() == dsize),
                   "size mismatch (" << dsize << ", "
                                     << open.size() << ", "
                                     << close.size() << ", "
                                     << high.size() << ", "
                                     << low.size() << ")");
        TimeSeries<IntervalPrice> retval;
        std::vector<Date>::const_iterator i;
        std::vector<Real>::const_iterator openi, closei, highi, lowi;
        openi = open.begin();
        closei = close.begin();
        highi = high.begin();
        lowi = low.begin();
        for (i = d.begin(); i != d.end(); ++i) {
            retval[*i] = IntervalPrice(*openi, *closei, *highi, *lowi);
            ++openi; ++closei; ++highi; ++lowi;
        }
        return retval;
    }

    std::vector<Real> IntervalPrice::extractValues(
                                           const TimeSeries<IntervalPrice>& ts,
                                           IntervalPrice::Type t)  {
        std::vector<Real> returnval;
        returnval.reserve(ts.size());
        for (const auto& i : ts) {
            returnval.push_back(i.second.value(t));
        }
        return returnval;
    }

    TimeSeries<Real> IntervalPrice::extractComponent(
                                          const TimeSeries<IntervalPrice>& ts,
                                          IntervalPrice::Type t) {
        std::vector<Date> dates = ts.dates();
        std::vector<Real> values = extractValues(ts, t);
        return TimeSeries<Real>(dates.begin(), dates.end(), values.begin());
    }

}

]]></document_content>
  </document>
  <document index="42">
    <source>prices.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006 Katiuscia Manzoni
 Copyright (C) 2006 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file prices.hpp
    \brief price classes
*/

#ifndef quantlib_prices_hpp
#define quantlib_prices_hpp

#include <ql/timeseries.hpp>
#include <ql/utilities/null.hpp>

namespace QuantLib {

    //! Price types
    enum PriceType {
         Bid,          /*!< Bid price. */
         Ask,          /*!< Ask price. */
         Last,         /*!< Last price. */
         Close,        /*!< Close price. */
         Mid,          /*!< Mid price, calculated as the arithmetic
                            average of bid and ask prices. */
         MidEquivalent, /*!< Mid equivalent price, calculated as
                            a) the arithmetic average of bid and ask prices
                            when both are available; b) either the bid or the
                            ask price if any of them is available;
                            c) the last price; or d) the close price. */
         MidSafe       /*!< Safe Mid price, returns the mid price only if
                            both bid and ask are available. */
    };

    /*! return the MidEquivalent price, i.e. the mid if available,
        or a suitable substitute if the proper mid is not available
        \test different combinations are tested
    */
    Real midEquivalent(Real bid, Real ask, Real last, Real close);

    /*! return the MidSafe price, i.e. the mid only if
        both bid and ask prices are available
        \test different combinations are tested
    */
    Real midSafe(Real bid, Real ask);

    //! interval price
    /*! \test Inspectors, Modifiers, and Helper functions are tested.
    */
    class IntervalPrice {
      public:
        enum Type { Open, Close, High, Low };

        IntervalPrice();
        IntervalPrice(Real open, Real close, Real high, Real low);

        //! \name Inspectors
        //@{
        Real open() const { return open_; }
        Real close() const { return close_; }
        Real high() const { return high_; }
        Real low() const { return low_; }
        Real value(IntervalPrice::Type) const;
        //@}

        //! \name Modifiers
        //@{
        void setValue(Real value, IntervalPrice::Type);
        void setValues(Real open, Real close, Real high, Real low);
        //@}

        //! \name Helper functions
        //@{
        static TimeSeries<IntervalPrice> makeSeries(
                                               const std::vector<Date>& d,
                                               const std::vector<Real>& open,
                                               const std::vector<Real>& close,
                                               const std::vector<Real>& high,
                                               const std::vector<Real>& low);
        static std::vector<Real> extractValues(
                                          const TimeSeries<IntervalPrice>&,
                                          IntervalPrice::Type);
        static TimeSeries<Real> extractComponent(
                                          const TimeSeries<IntervalPrice>&,
                                          IntervalPrice::Type);
        //@}
      private:
        Real open_, close_, high_, low_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="43">
    <source>pricingengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file pricingengine.hpp
    \brief Base class for pricing engines
*/

#ifndef quantlib_pricing_engine_hpp
#define quantlib_pricing_engine_hpp

#include <ql/patterns/observable.hpp>

namespace QuantLib {

    //! interface for pricing engines
    class PricingEngine : public Observable {
      public:
        class arguments;
        class results;
        ~PricingEngine() override = default;
        virtual arguments* getArguments() const = 0;
        virtual const results* getResults() const = 0;
        virtual void reset() = 0;
        virtual void calculate() const = 0;
    };

    class PricingEngine::arguments {
      public:
        virtual ~arguments() = default;
        virtual void validate() const = 0;
    };

    class PricingEngine::results {
      public:
        virtual ~results() = default;
        virtual void reset() = 0;
    };


    //! template base class for option pricing engines
    /*! Derived engines only need to implement
        the <tt>calculate()</tt> method.
    */
    template<class ArgumentsType, class ResultsType>
    class GenericEngine : public PricingEngine,
                          public Observer {
      public:
        PricingEngine::arguments* getArguments() const override { return &arguments_; }
        const PricingEngine::results* getResults() const override { return &results_; }
        void reset() override { results_.reset(); }
        void update() override { notifyObservers(); }

      protected:
        mutable ArgumentsType arguments_;
        mutable ResultsType results_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="44">
    <source>qldefines.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007 StatPro Italia srl
 Copyright (C) 2015 CompatibL

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file qldefines.hpp
    \brief Global definitions and compiler switches.
*/

#ifndef quantlib_defines_hpp
#define quantlib_defines_hpp

/* install-hook */

#ifdef _MSC_VER
/* Microsoft-specific, but needs to be defined before
   including <boost/config.hpp> which somehow includes
   <math.h> under VC++10
*/
#define _USE_MATH_DEFINES
#endif

#include <boost/config.hpp>
#include <boost/version.hpp>
#if BOOST_VERSION < 104800
    #error using an old version of Boost, please update.
#endif
#if !defined(BOOST_ENABLE_ASSERT_HANDLER)
    #define BOOST_ENABLE_ASSERT_HANDLER
#endif

/* This allows one to include a given file at this point by
   passing it as a compiler define (e.g., -DQL_INCLUDE_FIRST=foo.hpp).

   The idea is to provide a hook for defining QL_REAL and at the
   same time including any necessary headers for the new type.
*/
#define INCLUDE_FILE(F) INCLUDE_FILE_(F)
#define INCLUDE_FILE_(F) #F
#ifdef QL_INCLUDE_FIRST
#    include INCLUDE_FILE(QL_INCLUDE_FIRST)
#endif
#undef INCLUDE_FILE_
#undef INCLUDE_FILE

/* Eventually these might go into userconfig.hpp.
   For the time being, we hard code them here.
   They can be overridden by passing the #define to the compiler.
*/
#ifndef QL_INTEGER
#    define QL_INTEGER int
#endif

#ifndef QL_BIG_INTEGER
#    define QL_BIG_INTEGER long
#endif

#ifndef QL_REAL
#   define QL_REAL double
#endif


/*! \defgroup macros QuantLib macros

    Global definitions and a few macros which help porting the
    code to different compilers.

    @{
*/

#if (defined(_DEBUG) || defined(DEBUG))
    #define QL_DEBUG
#endif

#if   defined(HAVE_CONFIG_H)    // Dynamically created by configure
   #include <ql/config.hpp>
/* Use BOOST_MSVC instead of _MSC_VER since some other vendors (Metrowerks,
   for example) also #define _MSC_VER
*/
#elif defined(BOOST_MSVC)       // Microsoft Visual C++
   #include <ql/config.msvc.hpp>
#elif defined(__MINGW32__)      // Minimalistic GNU for Windows
   #include <ql/config.mingw.hpp>
#elif defined(__SUNPRO_CC)      // Sun Studio
   #include <ql/config.sun.hpp>
#else                           // We hope that the compiler follows ANSI
   #include <ql/config.ansi.hpp>
#endif


// extra debug checks
#ifdef QL_DEBUG
    #ifndef QL_EXTRA_SAFETY_CHECKS
        #define QL_EXTRA_SAFETY_CHECKS
    #endif
#endif

#ifdef QL_ENABLE_THREAD_SAFE_OBSERVER_PATTERN
    #if BOOST_VERSION < 105800
        #error Boost version 1.58 or higher is required for the thread-safe observer pattern
    #endif
#endif

#ifdef QL_ENABLE_PARALLEL_UNIT_TEST_RUNNER
    #if BOOST_VERSION < 105900
        #error Boost version 1.59 or higher is required for the parallel unit test runner
    #endif
#endif

// ensure that needed math constants are defined
#include <ql/mathconstants.hpp>


// import global functions into std namespace
#if defined(BOOST_NO_STDC_NAMESPACE)
    #include <cmath>
    namespace std {
        using ::sqrt; using ::abs; using ::fabs;
        using ::exp; using ::log; using ::pow;
        using ::sin; using ::cos; using ::asin; using ::acos;
        using ::sinh; using ::cosh;
        using ::floor; using ::fmod; using ::modf;
    }
#endif


/*! \defgroup limitMacros Numeric limits

    Some compilers do not give an implementation of
    <code>\<limits\></code> yet.  For the code to be portable
    these macros should be used instead of the corresponding method of
    <code>std::numeric_limits</code> or the corresponding macro
    defined in <code><limits.h></code>.

    @{
*/
/*! \def QL_MIN_INTEGER
    Defines the value of the largest representable negative integer value
*/
/*! \def QL_MAX_INTEGER
    Defines the value of the largest representable integer value
*/
/*! \def QL_MIN_REAL
    Defines the value of the largest representable negative
    floating-point value
*/
/*! \def QL_MIN_POSITIVE_REAL
    Defines the value of the smallest representable positive double value
*/
/*! \def QL_MAX_REAL
    Defines the value of the largest representable floating-point value
*/
/*! \def QL_EPSILON
    Defines the machine precision for operations over doubles
*/
#include <limits>
// limits used as such
#define QL_MIN_INTEGER         ((std::numeric_limits<QL_INTEGER>::min)())
#define QL_MAX_INTEGER         ((std::numeric_limits<QL_INTEGER>::max)())
#define QL_MIN_REAL           -((std::numeric_limits<QL_REAL>::max)())
#define QL_MAX_REAL            ((std::numeric_limits<QL_REAL>::max)())
#define QL_MIN_POSITIVE_REAL   ((std::numeric_limits<QL_REAL>::min)())
#define QL_EPSILON             ((std::numeric_limits<QL_REAL>::epsilon)())
/*! @} */

/*! @}  */


// For the time being we're keeping a QL_DEPRECATED macro because
// of <https://stackoverflow.com/questions/38378693/>.  We need to
// use it to deprecate constructors until we drop support for VC++2015.
// Other features (methods, typedefs etc.) can use [[deprecated]] and
// possibly add a message.

// emit warning when using deprecated features
// clang-format off
#if defined(BOOST_MSVC)       // Microsoft Visual C++
#    define QL_DEPRECATED __declspec(deprecated)
#    define QL_DEPRECATED_DISABLE_WARNING \
        __pragma(warning(push))           \
        __pragma(warning(disable : 4996))
#    define QL_DEPRECATED_ENABLE_WARNING \
        __pragma(warning(pop))
#elif defined(__clang__)
#    define QL_DEPRECATED __attribute__((deprecated))
#    define QL_DEPRECATED_DISABLE_WARNING                                 \
        _Pragma("clang diagnostic push")                                  \
        _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
#    define QL_DEPRECATED_ENABLE_WARNING \
        _Pragma("clang diagnostic pop")
#elif defined(__GNUC__)
#    define QL_DEPRECATED __attribute__((deprecated))
#    define QL_DEPRECATED_DISABLE_WARNING                               \
        _Pragma("GCC diagnostic push")                                  \
        _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
#    define QL_DEPRECATED_ENABLE_WARNING \
        _Pragma("GCC diagnostic pop")
#else
// we don't know how to enable it, just define the macros away
#    define QL_DEPRECATED
#    define QL_DEPRECATED_DISABLE_WARNING
#    define QL_DEPRECATED_ENABLE_WARNING
#endif
// clang-format on

#endif
]]></document_content>
  </document>
  <document index="45">
    <source>quantlib.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/qldefines.hpp>
#include <ql/version.hpp>
#if !defined(BOOST_ALL_NO_LIB) && defined(BOOST_MSVC)
#  include <ql/auto_link.hpp>
#endif

#include <ql/any.hpp>
#include <ql/cashflow.hpp>
#include <ql/compounding.hpp>
#include <ql/currency.hpp>
#include <ql/default.hpp>
#include <ql/discretizedasset.hpp>
#include <ql/errors.hpp>
#include <ql/exchangerate.hpp>
#include <ql/exercise.hpp>
#include <ql/event.hpp>
#include <ql/handle.hpp>
#include <ql/index.hpp>
#include <ql/instrument.hpp>
#include <ql/interestrate.hpp>
#include <ql/money.hpp>
#include <ql/numericalmethod.hpp>
#include <ql/option.hpp>
#include <ql/optional.hpp>
#include <ql/payoff.hpp>
#include <ql/position.hpp>
#include <ql/prices.hpp>
#include <ql/pricingengine.hpp>
#include <ql/quote.hpp>
#include <ql/rebatedexercise.hpp>
#include <ql/settings.hpp>
#include <ql/shared_ptr.hpp>
#include <ql/stochasticprocess.hpp>
#include <ql/termstructure.hpp>
#include <ql/timegrid.hpp>
#include <ql/timeseries.hpp>
#include <ql/types.hpp>
#include <ql/volatilitymodel.hpp>

#include <ql/cashflows/all.hpp>
#include <ql/currencies/all.hpp>
#include <ql/experimental/all.hpp>
#include <ql/indexes/all.hpp>
#include <ql/instruments/all.hpp>
#include <ql/legacy/all.hpp>
#include <ql/math/all.hpp>
#include <ql/methods/all.hpp>
#include <ql/models/all.hpp>
#include <ql/patterns/all.hpp>
#include <ql/pricingengines/all.hpp>
#include <ql/processes/all.hpp>
#include <ql/quotes/all.hpp>
#include <ql/termstructures/all.hpp>
#include <ql/time/all.hpp>
#include <ql/utilities/all.hpp>
]]></document_content>
  </document>
  <document index="46">
    <source>quote.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2025 Paolo D'Elia

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/quote.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/errors.hpp>
#include <ql/utilities/variants.hpp>

namespace QuantLib {

    Handle<Quote> handleFromVariant(const std::variant<Real, Handle<Quote>>& value) {
        return std::visit(
            detail::variant_visitor{
                [](Real x) -> Handle<Quote> { return makeQuoteHandle(x); },
                [](const Handle<Quote>& x) { return x; }
            },
            value);
    }

}
]]></document_content>
  </document>
  <document index="47">
    <source>quote.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file quote.hpp
    \brief purely virtual base class for market observables
*/

#ifndef quantlib_quote_hpp
#define quantlib_quote_hpp

#include <ql/handle.hpp>
#include <ql/errors.hpp>
#include <ql/utilities/null.hpp>
#include <variant>

namespace QuantLib {

    //! purely virtual base class for market observables
    /*! \test the observability of class instances is tested.
     */
    class Quote : public virtual Observable {
      public:
        ~Quote() override = default;
        //! returns the current value
        virtual Real value() const = 0;
        //! returns true if the Quote holds a valid value
        virtual bool isValid() const = 0;
    };


    Handle<Quote> handleFromVariant(const std::variant<Real, Handle<Quote>>& value);

}

#endif
]]></document_content>
  </document>
  <document index="48">
    <source>rebatedexercise.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/rebatedexercise.hpp>
#include <utility>

namespace QuantLib {

    RebatedExercise::RebatedExercise(const Exercise& exercise,
                                     const Real rebate,
                                     const Natural rebateSettlementDays,
                                     Calendar rebatePaymentCalendar,
                                     const BusinessDayConvention rebatePaymentConvention)
    : Exercise(exercise), rebates_(std::vector<Real>(dates().size(), rebate)),
      rebateSettlementDays_(rebateSettlementDays),
      rebatePaymentCalendar_(std::move(rebatePaymentCalendar)),
      rebatePaymentConvention_(rebatePaymentConvention) {}

    RebatedExercise::RebatedExercise(const Exercise& exercise,
                                     const std::vector<Real>& rebates,
                                     const Natural rebateSettlementDays,
                                     Calendar rebatePaymentCalendar,
                                     const BusinessDayConvention rebatePaymentConvention)
    : Exercise(exercise), rebates_(rebates), rebateSettlementDays_(rebateSettlementDays),
      rebatePaymentCalendar_(std::move(rebatePaymentCalendar)),
      rebatePaymentConvention_(rebatePaymentConvention) {

        QL_REQUIRE(
            type_ == Bermudan,
            "a rebate vector is allowed only for a bermudan style exercise");

        QL_REQUIRE(rebates.size() == dates().size(),
                   "the number of rebates ("
                       << rebates.size()
                       << ") must be equal to the number of exercise dates ("
                       << dates().size());
    }
}
]]></document_content>
  </document>
  <document index="49">
    <source>rebatedexercise.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file rebatedexercise.hpp
    \brief Option exercise with rebate payments
*/

#ifndef quantlib_rebatedexercise_hpp
#define quantlib_rebatedexercise_hpp

#include <ql/exercise.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    //! Rebated exercise
    /*! in case of exercise the holder receives a rebate (if positive) or pays
       it (if negative)
        on the rebate settlement date
    */
    class RebatedExercise : public Exercise {
      public:
        // in case of exercise the holder receives the rebate
        // (if positive) or pays it (if negative) on the rebate
        // settlement date
        RebatedExercise(const Exercise& exercise,
                        Real rebate = 0.0,
                        Natural rebateSettlementDays = 0,
                        Calendar rebatePaymentCalendar = NullCalendar(),
                        BusinessDayConvention rebatePaymentConvention = Following);
        RebatedExercise(const Exercise& exercise,
                        const std::vector<Real>& rebates,
                        Natural rebateSettlementDays = 0,
                        Calendar rebatePaymentCalendar = NullCalendar(),
                        BusinessDayConvention rebatePaymentConvention = Following);
        Real rebate(Size index) const;
        Date rebatePaymentDate(Size index) const;
        const std::vector<Real> &rebates() const { return rebates_; }

      private:
        const std::vector<Real> rebates_;
        const Natural rebateSettlementDays_;
        const Calendar rebatePaymentCalendar_;
        const BusinessDayConvention rebatePaymentConvention_;
    };

    inline Real RebatedExercise::rebate(Size index) const {
        QL_REQUIRE(index < rebates_.size(),
                   "rebate with index " << index << " does not exist (0..."
                   << (rebates_.size()-1) << ")");
        return rebates_[index];
    }

    inline Date RebatedExercise::rebatePaymentDate(Size index) const {
        QL_REQUIRE(type_ == European || type_ == Bermudan,
                   "for american style exercises the rebate payment date "
                       << "has to be calculted in the client code");
        return rebatePaymentCalendar_.advance(dates_[index],
                                              rebateSettlementDays_, Days,
                                              rebatePaymentConvention_);
    }

}

#endif
]]></document_content>
  </document>
  <document index="50">
    <source>settings.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2011 Ferdinando Ametrano
 Copyright (C) 2007 François du Vignaud
 Copyright (C) 2004, 2005, 2007, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/settings.hpp>

namespace QuantLib {

    Settings::DateProxy::DateProxy()
    : ObservableValue<Date>(Date()) {}

    std::ostream& operator<<(std::ostream& out,
                             const Settings::DateProxy& p) {
        return out << Date(p);
    }

    Settings::Settings()

        = default;

    void Settings::anchorEvaluationDate() {
        // set to today's date if not already set.
        if (evaluationDate_.value() == Date())
            evaluationDate_ = Date::todaysDate();
        // If set, no-op since the date is already anchored.
    }

    void Settings::resetEvaluationDate() {
        evaluationDate_ = Date();
    }

    SavedSettings::SavedSettings()
    : evaluationDate_(Settings::instance().evaluationDate()),
      includeReferenceDateEvents_(Settings::instance().includeReferenceDateEvents()),
      includeTodaysCashFlows_(Settings::instance().includeTodaysCashFlows()),
      enforcesTodaysHistoricFixings_(Settings::instance().enforcesTodaysHistoricFixings()) {}

    SavedSettings::~SavedSettings() {
        try {
            if (Settings::instance().evaluationDate() != evaluationDate_)
                Settings::instance().evaluationDate() = evaluationDate_;
            Settings::instance().includeReferenceDateEvents() =
                includeReferenceDateEvents_;
            Settings::instance().includeTodaysCashFlows() =
                includeTodaysCashFlows_;
            Settings::instance().enforcesTodaysHistoricFixings() =
                enforcesTodaysHistoricFixings_;
        } catch (...) {
            // nothing we can do except bailing out.
        }
    }

}
]]></document_content>
  </document>
  <document index="51">
    <source>settings.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2011 Ferdinando Ametrano
 Copyright (C) 2007 François du Vignaud
 Copyright (C) 2004, 2005, 2007, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file settings.hpp
    \brief global repository for run-time library settings
*/

#ifndef quantlib_settings_hpp
#define quantlib_settings_hpp

#include <ql/patterns/singleton.hpp>
#include <ql/time/date.hpp>
#include <ql/utilities/observablevalue.hpp>
#include <ql/optional.hpp>

namespace QuantLib {

    //! global repository for run-time library settings
    class Settings : public Singleton<Settings> {
        friend class Singleton<Settings>;
      private:
        Settings();
        class DateProxy : public ObservableValue<Date> {
          public:
            DateProxy();
            DateProxy& operator=(const Date&);
            operator Date() const;
        };
        friend std::ostream& operator<<(std::ostream&, const DateProxy&);
      public:
        //! the date at which pricing is to be performed.
        /*! Client code can inspect the evaluation date, as in:
            \code
            Date d = Settings::instance().evaluationDate();
            \endcode
            where today's date is returned if the evaluation date is
            set to the null date (its default value;) can set it to a
            new value, as in:
            \code
            Settings::instance().evaluationDate() = d;
            \endcode
            and can register with it, as in:
            \code
            registerWith(Settings::instance().evaluationDate());
            \endcode
            to be notified when it is set to a new value.
            \warning a notification is not sent when the evaluation
                     date changes for natural causes---i.e., a date
                     was not explicitly set (which results in today's
                     date being used for pricing) and the current date
                     changes as the clock strikes midnight.
        */
        DateProxy& evaluationDate();
        const DateProxy& evaluationDate() const;

        /*! Call this to prevent the evaluation date to change at
            midnight (and, incidentally, to gain quite a bit of
            performance.)  If no evaluation date was previously set,
            it is equivalent to setting the evaluation date to
            Date::todaysDate(); if an evaluation date other than
            Date() was already set, it has no effect.
        */
        void anchorEvaluationDate();
        /*! Call this to reset the evaluation date to
            Date::todaysDate() and allow it to change at midnight.  It
            is equivalent to setting the evaluation date to Date().
            This comes at the price of losing some performance, since
            the evaluation date is re-evaluated each time it is read.
        */
        void resetEvaluationDate();

        /*! This flag specifies whether or not Events occurring on the reference
            date should, by default, be taken into account as not happened yet.
            It can be overridden locally when calling the Event::hasOccurred
            method.
        */
        bool& includeReferenceDateEvents();
        bool includeReferenceDateEvents() const;

        /*! If set, this flag specifies whether or not CashFlows
            occurring on today's date should enter the NPV.  When the
            NPV date (i.e., the date at which the cash flows are
            discounted) equals today's date, this flag overrides the
            behavior chosen for includeReferenceDate. It cannot be overridden
            locally when calling the CashFlow::hasOccurred method.
        */
        ext::optional<bool>& includeTodaysCashFlows();
        ext::optional<bool> includeTodaysCashFlows() const;

        bool& enforcesTodaysHistoricFixings();
        bool enforcesTodaysHistoricFixings() const;

      private:
        DateProxy evaluationDate_;
        bool includeReferenceDateEvents_ = false;
        ext::optional<bool> includeTodaysCashFlows_;
        bool enforcesTodaysHistoricFixings_ = false;
    };


    // helper class to temporarily and safely change the settings
    class SavedSettings { // NOLINT(cppcoreguidelines-special-member-functions)
      public:
        SavedSettings();
        ~SavedSettings();
      private:
        Date evaluationDate_;
        bool includeReferenceDateEvents_;
        ext::optional<bool> includeTodaysCashFlows_;
        bool enforcesTodaysHistoricFixings_;
    };


    // inline

    inline Settings::DateProxy::operator Date() const {
        if (value() == Date())
            return Date::todaysDate();
        else
            return value();
    }

    inline Settings::DateProxy& Settings::DateProxy::operator=(const Date& d) {
        if (value() != d) // avoid notifications if the date doesn't actually change
            ObservableValue<Date>::operator=(d);
        return *this;
    }

    inline Settings::DateProxy& Settings::evaluationDate() {
        return evaluationDate_;
    }

    inline const Settings::DateProxy& Settings::evaluationDate() const {
        return evaluationDate_;
    }

    inline bool& Settings::includeReferenceDateEvents() {
        return includeReferenceDateEvents_;
    }

    inline bool Settings::includeReferenceDateEvents() const {
        return includeReferenceDateEvents_;
    }

    inline ext::optional<bool>& Settings::includeTodaysCashFlows() {
        return includeTodaysCashFlows_;
    }

    inline ext::optional<bool> Settings::includeTodaysCashFlows() const {
        return includeTodaysCashFlows_;
    }

    inline bool& Settings::enforcesTodaysHistoricFixings() {
        return enforcesTodaysHistoricFixings_;
    }

    inline bool Settings::enforcesTodaysHistoricFixings() const {
        return enforcesTodaysHistoricFixings_;
    }

}

#endif
]]></document_content>
  </document>
  <document index="52">
    <source>shared_ptr.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file shared_ptr.hpp
    \brief Maps shared_ptr to either the boost or std implementation
*/

#ifndef quantlib_shared_ptr_hpp
#define quantlib_shared_ptr_hpp

#include <ql/qldefines.hpp>

#if defined(QL_USE_STD_SHARED_PTR)
#include <memory>
#else
#include <boost/shared_ptr.hpp>
#include <boost/make_shared.hpp>
#include <boost/enable_shared_from_this.hpp>
#endif

namespace QuantLib::ext {

        #if defined(QL_USE_STD_SHARED_PTR)
        using std::shared_ptr;                   // NOLINT(misc-unused-using-decls)
        using std::weak_ptr;                     // NOLINT(misc-unused-using-decls)
        using std::make_shared;                  // NOLINT(misc-unused-using-decls)
        using std::static_pointer_cast;          // NOLINT(misc-unused-using-decls)
        using std::dynamic_pointer_cast;         // NOLINT(misc-unused-using-decls)
        using std::enable_shared_from_this;      // NOLINT(misc-unused-using-decls)
        #else
        using boost::shared_ptr;                 // NOLINT(misc-unused-using-decls)
        using boost::weak_ptr;                   // NOLINT(misc-unused-using-decls)
        using boost::make_shared;                // NOLINT(misc-unused-using-decls)
        using boost::static_pointer_cast;        // NOLINT(misc-unused-using-decls)
        using boost::dynamic_pointer_cast;       // NOLINT(misc-unused-using-decls)
        using boost::enable_shared_from_this;    // NOLINT(misc-unused-using-decls)
        #endif

    }


#endif

]]></document_content>
  </document>
  <document index="53">
    <source>stochasticprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/stochasticprocess.hpp>
#include <utility>

namespace QuantLib {

    // base class

    StochasticProcess::StochasticProcess(ext::shared_ptr<discretization> disc)
    : discretization_(std::move(disc)) {}

    Size StochasticProcess::factors() const {
        return size();
    }

    Array StochasticProcess::expectation(Time t0,
                                         const Array& x0,
                                         Time dt) const {
        return apply(x0, discretization_->drift(*this, t0, x0, dt));
    }

    Matrix StochasticProcess::stdDeviation(Time t0,
                                           const Array& x0,
                                           Time dt) const {
        return discretization_->diffusion(*this, t0, x0, dt);
    }

    Matrix StochasticProcess::covariance(Time t0,
                                         const Array& x0,
                                         Time dt) const {
        return discretization_->covariance(*this, t0, x0, dt);
    }

    Array StochasticProcess::evolve(Time t0, const Array& x0,
                                    Time dt, const Array& dw) const {
        return apply(expectation(t0,x0,dt), stdDeviation(t0,x0,dt)*dw);
    }

    Array StochasticProcess::apply(const Array& x0,
                                   const Array& dx) const {
        return x0 + dx;
    }

    Time StochasticProcess::time(const Date& ) const {
        QL_FAIL("date/time conversion not supported");
    }

    void StochasticProcess::update() {
        notifyObservers();
    }


    // 1-D specialization

    StochasticProcess1D::StochasticProcess1D(ext::shared_ptr<discretization> disc)
    : discretization_(std::move(disc)) {}

    Real StochasticProcess1D::expectation(Time t0, Real x0, Time dt) const {
        return apply(x0, discretization_->drift(*this, t0, x0, dt));
    }

    Real StochasticProcess1D::stdDeviation(Time t0, Real x0, Time dt) const {
        return discretization_->diffusion(*this, t0, x0, dt);
    }

    Real StochasticProcess1D::variance(Time t0, Real x0, Time dt) const {
        return discretization_->variance(*this, t0, x0, dt);
    }

    Real StochasticProcess1D::evolve(Time t0, Real x0,
                                     Time dt, Real dw) const {
        return apply(expectation(t0,x0,dt), stdDeviation(t0,x0,dt)*dw);
    }

    Real StochasticProcess1D::apply(Real x0, Real dx) const {
        return x0 + dx;
    }

}
]]></document_content>
  </document>
  <document index="54">
    <source>stochasticprocess.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file stochasticprocess.hpp
    \brief stochastic processes
*/

#ifndef quantlib_stochastic_process_hpp
#define quantlib_stochastic_process_hpp

#include <ql/time/date.hpp>
#include <ql/patterns/observable.hpp>
#include <ql/math/matrix.hpp>

namespace QuantLib {

    //! multi-dimensional stochastic process class.
    /*! This class describes a stochastic process governed by
        \f[
        d\mathrm{x}_t = \mu(t, x_t)\mathrm{d}t
                      + \sigma(t, \mathrm{x}_t) \cdot d\mathrm{W}_t.
        \f]
    */
    class StochasticProcess : public Observer, public Observable {
      public:
        //! discretization of a stochastic process over a given time interval
        class discretization {
          public:
            virtual ~discretization() = default;
            virtual Array drift(const StochasticProcess&,
                                Time t0,
                                const Array& x0,
                                Time dt) const = 0;
            virtual Matrix diffusion(const StochasticProcess&,
                                     Time t0,
                                     const Array& x0,
                                     Time dt) const = 0;
            virtual Matrix covariance(const StochasticProcess&,
                                      Time t0,
                                      const Array& x0,
                                      Time dt) const = 0;
        };
        ~StochasticProcess() override = default;
        //! \name Stochastic process interface
        //@{
        //! returns the number of dimensions of the stochastic process
        virtual Size size() const = 0;
        //! returns the number of independent factors of the process
        virtual Size factors() const;
        //! returns the initial values of the state variables
        virtual Array initialValues() const = 0;
        /*! \brief returns the drift part of the equation, i.e.,
                   \f$ \mu(t, \mathrm{x}_t) \f$
        */
        virtual Array drift(Time t,
                            const Array& x) const = 0;
        /*! \brief returns the diffusion part of the equation, i.e.
                   \f$ \sigma(t, \mathrm{x}_t) \f$
        */
        virtual Matrix diffusion(Time t,
                                 const Array& x) const = 0;
        /*! returns the expectation
            \f$ E(\mathrm{x}_{t_0 + \Delta t}
                | \mathrm{x}_{t_0} = \mathrm{x}_0) \f$
            of the process after a time interval \f$ \Delta t \f$
            according to the given discretization. This method can be
            overridden in derived classes which want to hard-code a
            particular discretization.
        */
        virtual Array expectation(Time t0,
                                  const Array& x0,
                                  Time dt) const;
        /*! returns the standard deviation
            \f$ S(\mathrm{x}_{t_0 + \Delta t}
                | \mathrm{x}_{t_0} = \mathrm{x}_0) \f$
            of the process after a time interval \f$ \Delta t \f$
            according to the given discretization. This method can be
            overridden in derived classes which want to hard-code a
            particular discretization.
        */
        virtual Matrix stdDeviation(Time t0,
                                    const Array& x0,
                                    Time dt) const;
        /*! returns the covariance
            \f$ V(\mathrm{x}_{t_0 + \Delta t}
                | \mathrm{x}_{t_0} = \mathrm{x}_0) \f$
            of the process after a time interval \f$ \Delta t \f$
            according to the given discretization. This method can be
            overridden in derived classes which want to hard-code a
            particular discretization.
        */
        virtual Matrix covariance(Time t0,
                                  const Array& x0,
                                  Time dt) const;
        /*! returns the asset value after a time interval \f$ \Delta t
            \f$ according to the given discretization. By default, it
            returns
            \f[
            E(\mathrm{x}_0,t_0,\Delta t) +
            S(\mathrm{x}_0,t_0,\Delta t) \cdot \Delta \mathrm{w}
            \f]
            where \f$ E \f$ is the expectation and \f$ S \f$ the
            standard deviation.
        */
        virtual Array evolve(Time t0,
                             const Array& x0,
                             Time dt,
                             const Array& dw) const;
        /*! applies a change to the asset value. By default, it
            returns \f$ \mathrm{x} + \Delta \mathrm{x} \f$.
        */
        virtual Array apply(const Array& x0,
                            const Array& dx) const;
        //@}

        //! \name utilities
        //@{
        /*! returns the time value corresponding to the given date
            in the reference system of the stochastic process.

            \note As a number of processes might not need this
                  functionality, a default implementation is given
                  which raises an exception.
        */
        virtual Time time(const Date&) const;
        //@}

        //! \name Observer interface
        //@{
        void update() override;
        //@}
      protected:
        StochasticProcess() = default;
        explicit StochasticProcess(ext::shared_ptr<discretization>);
        ext::shared_ptr<discretization> discretization_;
    };


    //! 1-dimensional stochastic process
    /*! This class describes a stochastic process governed by
        \f[
            dx_t = \mu(t, x_t)dt + \sigma(t, x_t)dW_t.
        \f]
    */
    class StochasticProcess1D : public StochasticProcess {
      public:
        //! discretization of a 1-D stochastic process
        class discretization {
          public:
            virtual ~discretization() = default;
            virtual Real drift(const StochasticProcess1D&,
                               Time t0, Real x0, Time dt) const = 0;
            virtual Real diffusion(const StochasticProcess1D&,
                                   Time t0, Real x0, Time dt) const = 0;
            virtual Real variance(const StochasticProcess1D&,
                                  Time t0, Real x0, Time dt) const = 0;
        };
        //! \name 1-D stochastic process interface
        //@{
        //! returns the initial value of the state variable
        virtual Real x0() const = 0;
        //! returns the drift part of the equation, i.e. \f$ \mu(t, x_t) \f$
        virtual Real drift(Time t, Real x) const = 0;
        /*! \brief returns the diffusion part of the equation, i.e.
            \f$ \sigma(t, x_t) \f$
        */
        virtual Real diffusion(Time t, Real x) const = 0;
        /*! returns the expectation
            \f$ E(x_{t_0 + \Delta t} | x_{t_0} = x_0) \f$
            of the process after a time interval \f$ \Delta t \f$
            according to the given discretization. This method can be
            overridden in derived classes which want to hard-code a
            particular discretization.
        */
        virtual Real expectation(Time t0, Real x0, Time dt) const;
        /*! returns the standard deviation
            \f$ S(x_{t_0 + \Delta t} | x_{t_0} = x_0) \f$
            of the process after a time interval \f$ \Delta t \f$
            according to the given discretization. This method can be
            overridden in derived classes which want to hard-code a
            particular discretization.
        */
        virtual Real stdDeviation(Time t0, Real x0, Time dt) const;
        /*! returns the variance
            \f$ V(x_{t_0 + \Delta t} | x_{t_0} = x_0) \f$
            of the process after a time interval \f$ \Delta t \f$
            according to the given discretization. This method can be
            overridden in derived classes which want to hard-code a
            particular discretization.
        */
        virtual Real variance(Time t0, Real x0, Time dt) const;
        /*! returns the asset value after a time interval \f$ \Delta t
            \f$ according to the given discretization. By default, it
            returns
            \f[
            E(x_0,t_0,\Delta t) + S(x_0,t_0,\Delta t) \cdot \Delta w
            \f]
            where \f$ E \f$ is the expectation and \f$ S \f$ the
            standard deviation.
        */
        virtual Real evolve(Time t0, Real x0, Time dt, Real dw) const;
        /*! applies a change to the asset value. By default, it
            returns \f$ x + \Delta x \f$.
        */
        virtual Real apply(Real x0, Real dx) const;
        //@}
      protected:
        StochasticProcess1D() = default;
        explicit StochasticProcess1D(ext::shared_ptr<discretization>);
        ext::shared_ptr<discretization> discretization_;
      private:
        // StochasticProcess interface implementation
        Size size() const override;
        Array initialValues() const override;
        Array drift(Time t, const Array& x) const override;
        Matrix diffusion(Time t, const Array& x) const override;
        Array expectation(Time t0, const Array& x0, Time dt) const override;
        Matrix stdDeviation(Time t0, const Array& x0, Time dt) const override;
        Matrix covariance(Time t0, const Array& x0, Time dt) const override;
        Array evolve(Time t0, const Array& x0, Time dt, const Array& dw) const override;
        Array apply(const Array& x0, const Array& dx) const override;
    };


    // inline definitions

    inline Size StochasticProcess1D::size() const {
        return 1;
    }

    inline Array StochasticProcess1D::initialValues() const {
        Array a(1, x0());
        return a;
    }

    inline Array StochasticProcess1D::drift(Time t, const Array& x) const {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(x.size() == 1, "1-D array required");
        #endif
        Array a(1, drift(t, x[0]));
        return a;
    }

    inline Matrix StochasticProcess1D::diffusion(Time t, const Array& x) const {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(x.size() == 1, "1-D array required");
        #endif
        Matrix m(1, 1, diffusion(t, x[0]));
        return m;
    }

    inline Array StochasticProcess1D::expectation(
                                    Time t0, const Array& x0, Time dt) const {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(x0.size() == 1, "1-D array required");
        #endif
        Array a(1, expectation(t0, x0[0], dt));
        return a;
    }

    inline Matrix StochasticProcess1D::stdDeviation(
                                    Time t0, const Array& x0, Time dt) const {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(x0.size() == 1, "1-D array required");
        #endif
        Matrix m(1, 1, stdDeviation(t0, x0[0], dt));
        return m;
    }

    inline Matrix StochasticProcess1D::covariance(
                                    Time t0, const Array& x0, Time dt) const {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(x0.size() == 1, "1-D array required");
        #endif
        Matrix m(1, 1, variance(t0, x0[0], dt));
        return m;
    }

    inline Array StochasticProcess1D::evolve(Time t0, const Array& x0,
                                             Time dt, const Array& dw) const {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(x0.size() == 1, "1-D array required");
        QL_REQUIRE(dw.size() == 1, "1-D array required");
        #endif
        Array a(1, evolve(t0,x0[0],dt,dw[0]));
        return a;
    }

    inline Array StochasticProcess1D::apply(const Array& x0,
                                            const Array& dx) const {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(x0.size() == 1, "1-D array required");
        QL_REQUIRE(dx.size() == 1, "1-D array required");
        #endif
        Array a(1, apply(x0[0],dx[0]));
        return a;
    }

}


#endif
]]></document_content>
  </document>
  <document index="55">
    <source>termstructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2005, 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/comparison.hpp>
#include <ql/termstructure.hpp>
#include <utility>

namespace QuantLib {

    TermStructure::TermStructure(DayCounter dc)
    : settlementDays_(Null<Natural>()), dayCounter_(std::move(dc)) {}

    TermStructure::TermStructure(const Date& referenceDate, Calendar cal, DayCounter dc)
    : calendar_(std::move(cal)), referenceDate_(referenceDate), settlementDays_(Null<Natural>()),
      dayCounter_(std::move(dc)) {}

    TermStructure::TermStructure(Natural settlementDays, Calendar cal, DayCounter dc)
    : moving_(true), updated_(false), calendar_(std::move(cal)), settlementDays_(settlementDays),
      dayCounter_(std::move(dc)) {
        registerWith(Settings::instance().evaluationDate());
    }

    const Date& TermStructure::referenceDate() const {
        if (!updated_) {
            Date today = Settings::instance().evaluationDate();
            referenceDate_ = calendar().advance(today, settlementDays(), Days);
            updated_ = true;
        }
        return referenceDate_;
    }

    void TermStructure::update() {
        if (moving_)
            updated_ = false;
        notifyObservers();
    }

    void TermStructure::checkRange(const Date& d,
                                   bool extrapolate) const {
        QL_REQUIRE(d >= referenceDate(),
                   "date (" << d << ") before reference date (" <<
                   referenceDate() << ")");
        QL_REQUIRE(extrapolate || allowsExtrapolation() || d <= maxDate(),
                   "date (" << d << ") is past max curve date ("
                            << maxDate() << ")");
    }

    void TermStructure::checkRange(Time t,
                                   bool extrapolate) const {
        QL_REQUIRE(t >= 0.0,
                   "negative time (" << t << ") given");
        QL_REQUIRE(extrapolate || allowsExtrapolation()
                   || t <= maxTime() || close_enough(t, maxTime()),
                   "time (" << t << ") is past max curve time ("
                            << maxTime() << ")");
    }

}
]]></document_content>
  </document>
  <document index="56">
    <source>termstructure.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2005, 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file termstructure.hpp
    \brief base class for term structures
*/

#ifndef quantlib_term_structure_hpp
#define quantlib_term_structure_hpp

#include <ql/time/calendar.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/settings.hpp>
#include <ql/handle.hpp>
#include <ql/math/interpolations/extrapolation.hpp>
#include <ql/utilities/null.hpp>

namespace QuantLib {

    //! Basic term-structure functionality
    class TermStructure : public virtual Observer,
                          public virtual Observable,
                          public Extrapolator {
      public:
        /*! \name Constructors

            There are three ways in which a term structure can keep
            track of its reference date.  The first is that such date
            is fixed; the second is that it is determined by advancing
            the current date of a given number of business days; and
            the third is that it is based on the reference date of
            some other structure.

            In the first case, the constructor taking a date is to be
            used; the default implementation of referenceDate() will
            then return such date. In the second case, the constructor
            taking a number of days and a calendar is to be used;
            referenceDate() will return a date calculated based on the
            current evaluation date, and the term structure and its
            observers will be notified when the evaluation date
            changes. In the last case, the referenceDate() method must
            be overridden in derived classes so that it fetches and
            return the appropriate date.
        */
        //@{
        //! default constructor
        /*! \warning term structures initialized by means of this
                     constructor must manage their own reference date
                     by overriding the referenceDate() method.
        */
        explicit TermStructure(DayCounter dc = DayCounter());
        //! initialize with a fixed reference date
        explicit TermStructure(const Date& referenceDate,
                               Calendar calendar = Calendar(),
                               DayCounter dc = DayCounter());
        //! calculate the reference date based on the global evaluation date
        TermStructure(Natural settlementDays, Calendar, DayCounter dc = DayCounter());
        //@}
        ~TermStructure() override = default;
        //! \name Dates and Time
        //@{
        //! the day counter used for date/time conversion
        virtual DayCounter dayCounter() const;
        //! date/time conversion
        Time timeFromReference(const Date& date) const;
        //! the latest date for which the curve can return values
        virtual Date maxDate() const = 0;
        //! the latest time for which the curve can return values
        virtual Time maxTime() const;
        //! the date at which discount = 1.0 and/or variance = 0.0
        virtual const Date& referenceDate() const;
        //! the calendar used for reference and/or option date calculation
        virtual Calendar calendar() const;
        //! the settlementDays used for reference date calculation
        virtual Natural settlementDays() const;
        //@}
        //! \name Observer interface
        //@{
        void update() override;
        //@}
      protected:
        //! date-range check
        void checkRange(const Date& d,
                        bool extrapolate) const;
        //! time-range check
        void checkRange(Time t,
                        bool extrapolate) const;
        bool moving_ = false;
        mutable bool updated_ = true;
        Calendar calendar_;
      private:
        mutable Date referenceDate_;
        Natural settlementDays_;
        DayCounter dayCounter_;
    };

    // inline definitions

    inline DayCounter TermStructure::dayCounter() const {
        return dayCounter_;
    }

    inline Time TermStructure::maxTime() const {
        return timeFromReference(maxDate());
    }

    inline Calendar TermStructure::calendar() const {
        return calendar_;
    }

    inline Natural TermStructure::settlementDays() const {
        QL_REQUIRE(settlementDays_!=Null<Natural>(),
                   "settlement days not provided for this instance");
        return settlementDays_;
    }

    inline Time TermStructure::timeFromReference(const Date& d) const {
        return dayCounter().yearFraction(referenceDate(), d);
    }

}

#endif
]]></document_content>
  </document>
  <document index="57">
    <source>timegrid.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/timegrid.hpp>
#include <iomanip>

namespace QuantLib {

    TimeGrid::TimeGrid(Time end, Size steps) {
        // We seem to assume that the grid begins at 0.
        // Let's enforce the assumption for the time being
        // (even though I'm not sure that I agree.)
        QL_REQUIRE(end > 0.0,
                   "negative times not allowed");
        Time dt = end/steps;
        times_.reserve(steps+1);
        for (Size i=0; i<=steps; i++)
            times_.push_back(dt*i);

        mandatoryTimes_ = std::vector<Time>(1);
        mandatoryTimes_[0] = end;

        dt_ = std::vector<Time>(steps,dt);
    }

    Size TimeGrid::index(Time t) const {
        Size i = closestIndex(t);
        if (close_enough(t,times_[i])) {
            return i;
        } else {
            if (t < times_.front()) {
                QL_FAIL("using inadequate time grid: all nodes "
                        "are later than the required time t = "
                        << std::setprecision(12) << t
                        << " (earliest node is t1 = "
                        << std::setprecision(12) << times_.front() << ")");
            } else if (t > times_.back()) {
                QL_FAIL("using inadequate time grid: all nodes "
                        "are earlier than the required time t = "
                        << std::setprecision(12) << t
                        << " (latest node is t1 = "
                        << std::setprecision(12) << times_.back() << ")");
            } else {
                Size j, k;
                if (t > times_[i]) {
                    j = i;
                    k = i+1;
                } else {
                    j = i-1;
                    k = i;
                }
                QL_FAIL("using inadequate time grid: the nodes closest "
                        "to the required time t = "
                        << std::setprecision(12) << t
                        << " are t1 = "
                        << std::setprecision(12) << times_[j]
                        << " and t2 = "
                        << std::setprecision(12) << times_[k]);
            }
        }
    }

    Size TimeGrid::closestIndex(Time t) const {
        auto begin = times_.begin(), end = times_.end();
        auto result = std::lower_bound(begin, end, t);
        if (result == begin) {
            return 0;
        } else if (result == end) {
            return size()-1;
        } else {
            Time dt1 = *result - t;
            Time dt2 = t - *(result-1);
            if (dt1 < dt2)
                return result-begin;
            else
                return (result-begin)-1;
        }
    }

}

]]></document_content>
  </document>
  <document index="58">
    <source>timegrid.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file timegrid.hpp
    \brief discrete time grid
*/

#ifndef quantlib_time_grid_hpp
#define quantlib_time_grid_hpp

#include <ql/errors.hpp>
#include <ql/math/comparison.hpp>
#include <vector>
#include <algorithm>
#include <iterator>
#include <numeric>
#include <cmath>

namespace QuantLib {

    //! time grid class
    /*! \todo what was the rationale for limiting the grid to
              positive times? Investigate and see whether we
              can use it for negative ones as well.
    */
    class TimeGrid {
      public:
        //! \name Constructors
        //@{
        TimeGrid() = default;
        //! Regularly spaced time-grid
        TimeGrid(Time end, Size steps);
        //! Time grid with mandatory time points
        /*! Mandatory points are guaranteed to belong to the grid.
            No additional points are added.
        */
        template <class Iterator>
        TimeGrid(Iterator begin, Iterator end)
        : mandatoryTimes_(begin, end) {
            QL_REQUIRE(begin != end, "empty time sequence");
            std::sort(mandatoryTimes_.begin(),mandatoryTimes_.end());
            // We seem to assume that the grid begins at 0.
            // Let's enforce the assumption for the time being
            // (even though I'm not sure that I agree.)
            QL_REQUIRE(mandatoryTimes_.front() >= 0.0,
                       "negative times not allowed");
            auto e = std::unique(mandatoryTimes_.begin(), mandatoryTimes_.end(),
                                 static_cast<bool (*)(Real, Real)>(close_enough));
            mandatoryTimes_.resize(e - mandatoryTimes_.begin());

            if (mandatoryTimes_[0] > 0.0)
                times_.push_back(0.0);

            times_.insert(times_.end(),
                          mandatoryTimes_.begin(), mandatoryTimes_.end());

            dt_.reserve(times_.size()-1);
            std::adjacent_difference(times_.begin()+1,times_.end(),
                                     std::back_inserter(dt_));

        }
        //! Time grid with mandatory time points
        /*! Mandatory points are guaranteed to belong to the grid.
            Additional points are then added with regular spacing
            between pairs of mandatory times in order to reach the
            desired number of steps.
        */
        template <class Iterator>
        TimeGrid(Iterator begin, Iterator end, Size steps)
        : mandatoryTimes_(begin, end) {
            QL_REQUIRE(begin != end, "empty time sequence");
            std::sort(mandatoryTimes_.begin(),mandatoryTimes_.end());
            // We seem to assume that the grid begins at 0.
            // Let's enforce the assumption for the time being
            // (even though I'm not sure that I agree.)
            QL_REQUIRE(mandatoryTimes_.front() >= 0.0,
                       "negative times not allowed");
            auto e = std::unique(mandatoryTimes_.begin(), mandatoryTimes_.end(),
                                 static_cast<bool (*)(Real, Real)>(close_enough));
            mandatoryTimes_.resize(e - mandatoryTimes_.begin());

            Time last = mandatoryTimes_.back();
            Time dtMax;
            // The resulting timegrid have points at times listed in the input
            // list. Between these points, there are inner-points which are
            // regularly spaced.
            if (steps == 0) {
                std::vector<Time> diff;
                std::adjacent_difference(mandatoryTimes_.begin(),
                                         mandatoryTimes_.end(),
                                         std::back_inserter(diff));
                QL_REQUIRE(!diff.empty(), "at least two distinct points required in time grid");

                if (diff.front()==0.0)
                    diff.erase(diff.begin());

                auto i = std::min_element(diff.begin(), diff.end());
                QL_REQUIRE(i != diff.end(), "not enough distinct points in time grid");
                dtMax = *i;
            } else {
                dtMax = last/steps;
            }

            Time periodBegin = 0.0;
            times_.push_back(periodBegin);
            for (auto t=mandatoryTimes_.begin();
                                                   t<mandatoryTimes_.end();
                                                   ++t) {
                Time periodEnd = *t;
                if (periodEnd != 0.0) {
                    // the nearest integer, at least 1
                    Size nSteps = std::max(Size(std::lround((periodEnd - periodBegin)/dtMax)), Size(1));
                    Time dt = (periodEnd - periodBegin)/nSteps;
                    for (Size n=1; n<=nSteps; ++n)
                        times_.push_back(periodBegin + n*dt);
                }
                periodBegin = periodEnd;
            }

            dt_.reserve(times_.size()-1);
            std::adjacent_difference(times_.begin()+1,times_.end(),
                                     std::back_inserter(dt_));
        }
        TimeGrid(std::initializer_list<Time> times)
        : TimeGrid(times.begin(), times.end()) {}
        TimeGrid(std::initializer_list<Time> times, Size steps)
        : TimeGrid(times.begin(), times.end(), steps) {}
        //@}
        //! \name Time grid interface
        //@{
        //! returns the index i such that grid[i] = t
        Size index(Time t) const;
        //! returns the index i such that grid[i] is closest to t
        Size closestIndex(Time t) const;
        //! returns the time on the grid closest to the given t
        Time closestTime(Time t) const {
            return times_[closestIndex(t)];
        }
        const std::vector<Time>& mandatoryTimes() const {
            return mandatoryTimes_;
        }
        Time dt(Size i) const { return dt_[i]; }
        //@}
        //! \name sequence interface
        //@{
        typedef std::vector<Time>::const_iterator const_iterator;
        typedef std::vector<Time>::const_reverse_iterator
                                          const_reverse_iterator;

        Time operator[](Size i) const { return times_[i]; }
        Time at(Size i) const { return times_.at(i); }
        Size size() const { return times_.size(); }
        bool empty() const { return times_.empty(); }
        const_iterator begin() const { return times_.begin(); }
        const_iterator end() const { return times_.end(); }
        const_reverse_iterator rbegin() const { return times_.rbegin(); }
        const_reverse_iterator rend() const { return times_.rend(); }
        Time front() const { return times_.front(); }
        Time back() const { return times_.back(); }
        //@}
      private:
        std::vector<Time> times_;
        std::vector<Time> dt_;
        std::vector<Time> mandatoryTimes_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="59">
    <source>timeseries.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Joseph Wang
 Copyright (C) 2010 Liquidnet Holdings, Inc.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file timeseries.hpp
    \brief Container for historical data
*/

#ifndef quantlib_timeseries_hpp
#define quantlib_timeseries_hpp

#include <ql/time/date.hpp>
#include <ql/utilities/null.hpp>
#include <ql/errors.hpp>
#include <boost/iterator/transform_iterator.hpp>
#include <functional>
#include <iterator>
#include <algorithm>
#include <map>
#include <vector>
#include <type_traits>

namespace QuantLib {

    //! Container for historical data
    /*! This class acts as a generic repository for a set of
        historical data.  Any single datum can be accessed through its
        date, while sets of consecutive data can be accessed through
        iterators.

        \pre The <c>Container</c> type must satisfy the requirements
             set by the C++ standard for associative containers.
    */
    template <class T, class Container = std::map<Date, T> >
    class TimeSeries {
      public:
        typedef Date key_type;
        typedef T value_type;
      private:
        mutable Container values_;
      public:
        /*! Default constructor */
        TimeSeries() = default;
        /*! This constructor initializes the history with a set of
            values passed as two sequences, the first containing dates
            and the second containing corresponding values.
        */
        template <class DateIterator, class ValueIterator>
        TimeSeries(DateIterator dBegin, DateIterator dEnd,
                   ValueIterator vBegin) {
            while (dBegin != dEnd)
                values_[*(dBegin++)] = *(vBegin++);
        }
        /*! This constructor initializes the history with a set of
            values. Such values are assigned to a corresponding number
            of consecutive dates starting from <b><i>firstDate</i></b>
            included.
        */
        template <class ValueIterator>
        TimeSeries(const Date& firstDate,
                   ValueIterator begin, ValueIterator end) {
            Date d = firstDate;
            while (begin != end)
                values_[d++] = *(begin++);
        }
        //! \name Inspectors
        //@{
        //! returns the first date for which a historical datum exists
        Date firstDate() const;
        //! returns the last date for which a historical datum exists
        Date lastDate() const;
        //! returns the number of historical data including null ones
        Size size() const;
        //! returns whether the series contains any data
        bool empty() const;
        //@}
        //! \name Historical data access
        //@{
        //! returns the (possibly null) datum corresponding to the given date
        T operator[](const Date& d) const {
            auto found = values_.find(d);
            if (found == values_.cend())
                return Null<T>();
            return found->second;
        }
        T& operator[](const Date& d) {
            auto found = values_.insert(std::pair<Date, T>(d, Null<T>())).first;
            return found->second;
        }
        //@}

        //! \name Iterators
        //@{
        typedef typename Container::const_iterator const_iterator;
        typedef typename const_iterator::iterator_category iterator_category;

        // Reverse iterators
        // The following class makes compilation fail for the code
        // that calls rbegin or rend with a container that does not
        // support reverse iterators.  All the rest TimeSeries class
        // features should compile and work for this type of
        // containers.
        template <class container, class iterator_category>
        struct reverse {
            typedef std::reverse_iterator<typename container::const_iterator>
                                                       const_reverse_iterator;
            reverse(const container& c) : c_(c) {}
            const_reverse_iterator rbegin() const {
                return const_reverse_iterator(c_.end());
            }
            const_reverse_iterator rend() const {
                return const_reverse_iterator(c_.begin());
            }
            const container& c_;
        };

        // This class defines reverse iterator features via
        // container's native calls.
        template <class container>
        struct reverse<container, std::bidirectional_iterator_tag> {
            typedef typename container::const_reverse_iterator
                                                       const_reverse_iterator;
            reverse(const container& c) : c_(c) {}
            const_reverse_iterator rbegin() const { return c_.rbegin(); }
            const_reverse_iterator rend() const { return c_.rend(); }
            const container& c_;
        };

        // The following typedef enables reverse iterators for
        // bidirectional_iterator_tag category.
        typedef std::conditional_t<
                std::is_same_v<iterator_category, std::bidirectional_iterator_tag> ||
                std::is_base_of_v<std::bidirectional_iterator_tag, iterator_category>,
            std::bidirectional_iterator_tag, std::input_iterator_tag> enable_reverse;

        typedef typename
        reverse<Container, enable_reverse>::const_reverse_iterator
                                                       const_reverse_iterator;

        const_iterator cbegin() const;
        const_iterator cend() const;
        const_iterator begin() const { return cbegin(); }
        const_iterator end() const { return cend(); }
        const_reverse_iterator crbegin() const {
            return reverse<Container, enable_reverse>(values_).rbegin();
        }
        const_reverse_iterator crend() const {
            return reverse<Container, enable_reverse>(values_).rend();
        }
        const_reverse_iterator rbegin() const { return crbegin(); }
        const_reverse_iterator rend() const { return crend(); }
        //@}

      private:
        typedef typename Container::value_type container_value_type;
        typedef std::function<Date(const container_value_type&)>
                                                              projection_time;
        typedef std::function<T(const container_value_type&)>
                                                             projection_value;

      public:
        //! \name Utilities
        //@{
        const_iterator find(const Date&);
        //! returns the dates for which historical data exist
        std::vector<Date> dates() const;
        //! returns the historical data
        std::vector<T> values() const;
        //@}

      private:
        static const Date& get_time (const container_value_type& v) {
            return v.first;
        }
        static const T& get_value (const container_value_type& v) {
            return v.second;
        }
    };


    // inline definitions

    template <class T, class C>
    inline Date TimeSeries<T,C>::firstDate() const {
        QL_REQUIRE(!values_.empty(), "empty timeseries");
        return values_.begin()->first;
    }

    template <class T, class C>
    inline Date TimeSeries<T,C>::lastDate() const {
        QL_REQUIRE(!values_.empty(), "empty timeseries");
        return rbegin()->first;
    }

    template <class T, class C>
    inline Size TimeSeries<T,C>::size() const {
        return values_.size();
    }

    template <class T, class C>
    inline bool TimeSeries<T,C>::empty() const {
        return values_.empty();
    }

    template <class T, class C>
    inline typename TimeSeries<T,C>::const_iterator
    TimeSeries<T,C>::cbegin() const {
        return values_.begin();
    }

    template <class T, class C>
    inline typename TimeSeries<T,C>::const_iterator
    TimeSeries<T,C>::cend() const {
        return values_.end();
    }

    template <class T, class C>
    inline typename TimeSeries<T,C>::const_iterator
    TimeSeries<T,C>::find(const Date& d) {
        auto i = values_.find(d);
        if (i == values_.end()) {
            values_[d] = Null<T>();
            i = values_.find(d);
        }
        return i;
    }

    template <class T, class C>
    std::vector<Date> TimeSeries<T,C>::dates() const {
        std::vector<Date> v;
        v.reserve(size());
        std::transform(cbegin(), cend(), std::back_inserter(v),
                       TimeSeries<T,C>::get_time);
        return v;
    }

    template <class T, class C>
    std::vector<T> TimeSeries<T,C>::values() const {
        std::vector<T> v;
        v.reserve(size());
        std::transform(cbegin(), cend(), std::back_inserter(v),
                       TimeSeries<T,C>::get_value);
        return v;
    }

}

#endif
]]></document_content>
  </document>
  <document index="60">
    <source>tuple.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_tuple_hpp
#define quantlib_tuple_hpp

// Deprecated in version 1.41
#pragma message("Warning: this file is empty and will disappear in a future release; use #include <tuple> instead.")

#include <tuple>

#endif

]]></document_content>
  </document>
  <document index="61">
    <source>types.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file types.hpp
    \brief Custom types
*/

#ifndef quantlib_types_hpp
#define quantlib_types_hpp

#include <ql/qldefines.hpp>
#include <cstddef>

namespace QuantLib {

    //! integer number
    /*! \ingroup types */
    typedef QL_INTEGER Integer;

    //! large integer number
    /*! \ingroup types */
    typedef QL_BIG_INTEGER BigInteger;

    //! positive integer
    /*! \ingroup types */
    typedef unsigned QL_INTEGER Natural;

    //! large positive integer
    typedef unsigned QL_BIG_INTEGER BigNatural;

    //! real number
    /*! \ingroup types */
    typedef QL_REAL Real;

    //! decimal number
    /*! \ingroup types */
    typedef Real Decimal;

    //! size of a container
    /*! \ingroup types */
    typedef std::size_t Size;

    //! continuous quantity with 1-year units
    /*! \ingroup types */
    typedef Real Time;

    //! discount factor between dates
    /*! \ingroup types */
    typedef Real DiscountFactor;

    //! interest rates
    /*! \ingroup types */
    typedef Real Rate;

    //! spreads on interest rates
    /*! \ingroup types */
    typedef Real Spread;

    //! volatility
    /*! \ingroup types */
    typedef Real Volatility;

    //! probability
    /*! \ingroup types */
    typedef Real Probability;

}


#endif
]]></document_content>
  </document>
  <document index="62">
    <source>userconfig.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2011 Ferdinando Ametrano
 Copyright (C) 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#ifndef quantlib_config_hpp
#define quantlib_config_hpp

/***************************************************************
   User configuration section:
   modify the following definitions to suit your preferences.

   Do not modify this file if you are using a Linux/Unix system:
   it will not be read by the compiler. The definitions below
   will be provided by running ./configure instead.
****************************************************************/

/* If defined, function information is added to the error messages
   thrown by the library.
*/
#ifndef QL_ERROR_FUNCTIONS
//#   define QL_ERROR_FUNCTIONS
#endif

/* If defined, file and line information is added to the error
   messages thrown by the library.
*/
#ifndef QL_ERROR_LINES
//#   define QL_ERROR_LINES
#endif

/* If defined, tracing messages might be emitted by the library
   depending on run-time settings. Enabling this option can degrade
   performance.
*/
#ifndef QL_ENABLE_TRACING
//#   define QL_ENABLE_TRACING
#endif

/* If defined, extra run-time checks are added to a few
   functions. This can prevent their inlining and degrade
   performance.
*/
#ifndef QL_EXTRA_SAFETY_CHECKS
//#   define QL_EXTRA_SAFETY_CHECKS
#endif

/* If defined, indexed coupons (see the documentation) are used in
   floating legs.  If undefined, par coupons are used.
*/
#ifndef QL_USE_INDEXED_COUPON
//#   define QL_USE_INDEXED_COUPON
#endif

/* If defined, singletons will return different instances for
   different threads; in particular, this means that the evaluation
   date, the stored index fixings and any other settings will be
   per-thread.
*/
#ifndef QL_ENABLE_SESSIONS
//#   define QL_ENABLE_SESSIONS
#endif

/* If defined, a thread-safe (but less performant) version of the
   observer pattern is used. You should define it if you want to use
   QuantLib via the SWIG layer within the JVM or .NET ecosystem or
   any other environment with an async garbage collector.
*/
#ifndef QL_ENABLE_THREAD_SAFE_OBSERVER_PATTERN
//#    define QL_ENABLE_THREAD_SAFE_OBSERVER_PATTERN
#endif

/* If defined, date objects willsupport an intraday datetime
   resolution down to microseconds.  Strictly monotone daycounters
   (`Actual360`, `Actual365Fixed` and `ActualActual`) will take the
   additional information into account and allow for accurate intraday
   pricing.  If undefined, the smallest resolution of date objects is
   a single day.  Intraday datetime resolution is experimental.
*/
#ifndef QL_HIGH_RESOLUTION_DATE
//#    define QL_HIGH_RESOLUTION_DATE
#endif

/* If defined, lazy objects will raise an exception when they detect a
   notification cycle which would result in an infinite recursion
   loop. If undefined, they will break the recursion without throwing.
   Enabling this option is recommended but might cause existing code
   to throw.
*/
#ifndef QL_THROW_IN_CYCLES
//#    define QL_THROW_IN_CYCLES
#endif

/* If defined, lazy objects will forward the first notification
   received, and discard the others until recalculated; the rationale
   is that observers were already notified, and don't need further
   notifications until they recalculate, at which point this object
   would be recalculated too.  After recalculation, this object would
   again forward the first notification received.  Although not always
   correct, this behavior is a lot faster and thus is the current
   default.
*/
#ifndef QL_FASTER_LAZY_OBJECTS
#    define QL_FASTER_LAZY_OBJECTS
#endif

/* If defined, `std::any` and related classes and functions will be
   used instead of `boost::any`. If undefined, the Boost facilities
   will be used.
*/
#ifndef QL_USE_STD_ANY
#    define QL_USE_STD_ANY
#endif

/* If defined, `std::optional` and related classes and functions will
   be used instead of `boost::optional`. If undefined, the Boost
   facilities will be used.
*/
#ifndef QL_USE_STD_OPTIONAL
#    define QL_USE_STD_OPTIONAL
#endif

/* If defined, `std::shared_ptr` and related classes and functions
   will used instead of `boost::shared_ptr`. If undefined, the Boost
   facilities will be used. Note that `std::shared_ptr` does not check
   access and can cause segmentation faults.
*/
#ifndef QL_USE_STD_SHARED_PTR
//#    define QL_USE_STD_SHARED_PTR
#endif

/* If defined, `Null` will be implemented as a template function.
   This allows the code to work with user-defined `Real` types but was
   reported to cause internal compiler errors with Visual C++ 2022 in
   some cases.  If undefined, `Null` will be implemented as a class
   template, as in previous releases.
*/
#ifndef QL_NULL_AS_FUNCTIONS
//#    define QL_NULL_AS_FUNCTIONS
#endif

/* If defined, a parallel unit test runner will be used to execute the
   C++ test suite. This will reduce the runtime on multi core CPUs.
*/
#ifndef QL_ENABLE_PARALLEL_UNIT_TEST_RUNNER
//#    define QL_ENABLE_PARALLEL_UNIT_TEST_RUNNER
#endif

#endif
]]></document_content>
  </document>
  <document index="63">
    <source>version.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2019 Aprexo Limited

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/version.hpp>
#include <boost/version.hpp>

// Macros for forcing the compiler not to inline code
// For now only used here, but could move this to a common header if necessary
#if defined(BOOST_MSVC)       // Microsoft Visual C++
#define QL_FORCE_NONINLINE __declspec(noinline)
#elif defined(__GNUC__) || defined(__clang__)
#define QL_FORCE_NONINLINE __attribute__((noinline))
#else
// we don't know how to enable it, just define the macro away and emit a warning
#define QL_FORCE_NONINLINE
#warning QL_FORCE_NONINLINE is not implemented on this platform
#endif


namespace QuantLib {

    QL_FORCE_NONINLINE std::size_t compiledBoostVersion()
    {
        return static_cast<std::size_t>(BOOST_VERSION);
    }

}
]]></document_content>
  </document>
  <document index="64">
    <source>version.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 StatPro Italia srl
 Copyright (C) 2019 Aprexo Limited

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file version.hpp
    \brief Version number, and version of boost the library is compiled with
*/

#ifndef quantlib_version_hpp
#define quantlib_version_hpp

#include <ql/qldefines.hpp>
#include <cstddef>

/*! \addtogroup macros */
/*! @{ */

//! version string
#define QL_VERSION "1.42-dev"

//! version hexadecimal number
#define QL_HEX_VERSION 0x01420000

/*! @}  */

namespace QuantLib {

    /*! Returns the version of boost that the QuantLib library was built with
        Use to check that client code is using a consistent version of boost.
        Using QuantLib header files compiled with a different version of boost
        than the library itself may result in undefined behaviour */
    std::size_t compiledBoostVersion();

}

#endif
]]></document_content>
  </document>
  <document index="65">
    <source>volatilitymodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file volatilitymodel.hpp
    \brief Volatility term structures
*/

#ifndef quantlib_volatility_model_hpp
#define quantlib_volatility_model_hpp

#include <ql/types.hpp>
#include <ql/timeseries.hpp>


namespace QuantLib {

    template <class T>
    class LocalVolatilityEstimator {
      public:
        virtual ~LocalVolatilityEstimator() = default;
        virtual TimeSeries<Volatility>
        calculate(const TimeSeries<T> &quoteSeries) = 0;
    };

    class VolatilityCompositor {
      public:
        typedef TimeSeries<Volatility> time_series;
        virtual ~VolatilityCompositor() = default;
        virtual time_series calculate(const time_series& volatilitySeries) = 0;
        virtual void calibrate(const time_series& volatilitySeries) = 0;
    };

}


#endif
]]></document_content>
  </document>
</documents>