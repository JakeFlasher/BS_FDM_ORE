<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>credit/defaultdensitystructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Chris Kenyon
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/termstructures/credit/defaultdensitystructure.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        template <class F>
        struct t_remapper {
            F f;
            Time T;
            t_remapper(F f, Time T) : f(std::move(f)), T(T) {}
            // This remaps [-1,1] to [0,T]. No differential included.
            Real operator()(Real x) const {
                const Real arg = (x+1.0)*T/2.0;
                return f(arg);
            }
        };

        template <class F>
        t_remapper<F> remap_t(const F& f, Time T) {
            return t_remapper<F>(f,T);
        }

    }

    DefaultDensityStructure::DefaultDensityStructure(
                                    const DayCounter& dc,
                                    const std::vector<Handle<Quote> >& jumps,
                                    const std::vector<Date>& jumpDates)
    : DefaultProbabilityTermStructure(dc, jumps, jumpDates) {}

    DefaultDensityStructure::DefaultDensityStructure(
                                    const Date& refDate,
                                    const Calendar& cal,
                                    const DayCounter& dc,
                                    const std::vector<Handle<Quote> >& jumps,
                                    const std::vector<Date>& jumpDates)
    : DefaultProbabilityTermStructure(refDate, cal, dc, jumps, jumpDates) {}

    DefaultDensityStructure::DefaultDensityStructure(
                                    Natural settlDays,
                                    const Calendar& cal,
                                    const DayCounter& dc,
                                    const std::vector<Handle<Quote> >& jumps,
                                    const std::vector<Date>& jumpDates)
    : DefaultProbabilityTermStructure(settlDays, cal, dc, jumps, jumpDates) {}

    Probability DefaultDensityStructure::survivalProbabilityImpl(Time t) const {
        static GaussChebyshevIntegration integral(48);
        // the Gauss-Chebyshev quadratures integrate over [-1,1],
        // hence the remapping (and the Jacobian term t/2)
        Probability P = 1.0 - integral(remap_t([&](Time tau){ return defaultDensityImpl(tau); }, t)) * t / 2.0;
        //QL_ENSURE(P >= 0.0, "negative survival probability");
        return std::max<Real>(P, 0.0);
    }

}
]]></document_content>
  </document>
  <document index="2">
    <source>credit/defaultprobabilityhelpers.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 Jose Aparicio
 Copyright (C) 2008 Chris Kenyon
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2008 StatPro Italia srl
  Copyright (C) 2023 Andrea Pellegatta

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/credit/isdacdsengine.hpp>
#include <ql/pricingengines/credit/midpointcdsengine.hpp>
#include <ql/termstructures/credit/defaultprobabilityhelpers.hpp>
#include <ql/utilities/null_deleter.hpp>
#include <utility>

namespace QuantLib {

    CdsHelper::CdsHelper(const std::variant<Rate, Handle<Quote>>& quote,
                         const Period& tenor,
                         Integer settlementDays,
                         Calendar calendar,
                         Frequency frequency,
                         BusinessDayConvention paymentConvention,
                         DateGeneration::Rule rule,
                         DayCounter dayCounter,
                         Real recoveryRate,
                         const Handle<YieldTermStructure>& discountCurve,
                         bool settlesAccrual,
                         bool paysAtDefaultTime,
                         const Date& startDate,
                         DayCounter lastPeriodDayCounter,
                         const bool rebatesAccrual,
                         const CreditDefaultSwap::PricingModel model)
    : RelativeDateDefaultProbabilityHelper(quote), tenor_(tenor), settlementDays_(settlementDays),
      calendar_(std::move(calendar)), frequency_(frequency), paymentConvention_(paymentConvention),
      rule_(rule), dayCounter_(std::move(dayCounter)), recoveryRate_(recoveryRate),
      discountCurve_(discountCurve), settlesAccrual_(settlesAccrual),
      paysAtDefaultTime_(paysAtDefaultTime), lastPeriodDC_(std::move(lastPeriodDayCounter)),
      rebatesAccrual_(rebatesAccrual), model_(model), startDate_(startDate) {

        CdsHelper::initializeDates();

        registerWith(discountCurve);
    }

    void CdsHelper::setTermStructure(DefaultProbabilityTermStructure* ts) {
        RelativeDateDefaultProbabilityHelper::setTermStructure(ts);

        probability_.linkTo(
            ext::shared_ptr<DefaultProbabilityTermStructure>(ts, null_deleter()),
            false);

        resetEngine();
    }

    void CdsHelper::update() {
        RelativeDateDefaultProbabilityHelper::update();
        resetEngine();
    }

    void CdsHelper::initializeDates() {

        protectionStart_ = evaluationDate_ + settlementDays_;

        Date startDate = startDate_ == Date() ? protectionStart_ : startDate_;
        // Only adjust start date if rule is not CDS or CDS2015. Unsure about OldCDS.
        if (rule_ != DateGeneration::CDS && rule_ != DateGeneration::CDS2015) {
            startDate = calendar_.adjust(startDate, paymentConvention_);
        }

        Date endDate;
        if (rule_ == DateGeneration::CDS2015 || rule_ == DateGeneration::CDS || rule_ == DateGeneration::OldCDS) {
            Date refDate = startDate_ == Date() ? evaluationDate_ : startDate_;
            endDate = cdsMaturity(refDate, tenor_, rule_);
        } else {
            // Keep the old logic here
            Date refDate = startDate_ == Date() ? protectionStart_ : startDate_ + settlementDays_;
            endDate = refDate + tenor_;
        }

        schedule_ =
            MakeSchedule().from(startDate)
                          .to(endDate)
                          .withFrequency(frequency_)
                          .withCalendar(calendar_)
                          .withConvention(paymentConvention_)
                          .withTerminationDateConvention(Unadjusted)
                          .withRule(rule_);
        earliestDate_ = schedule_.dates().front();
        latestDate_   = calendar_.adjust(schedule_.dates().back(),
                                         paymentConvention_);
        if (model_ == CreditDefaultSwap::ISDA)
            ++latestDate_;
    }

    SpreadCdsHelper::SpreadCdsHelper(
                              const std::variant<Rate, Handle<Quote>>& runningSpread,
                              const Period& tenor,
                              Integer settlementDays,
                              const Calendar& calendar,
                              Frequency frequency,
                              BusinessDayConvention paymentConvention,
                              DateGeneration::Rule rule,
                              const DayCounter& dayCounter,
                              Real recoveryRate,
                              const Handle<YieldTermStructure>& discountCurve,
                              bool settlesAccrual,
                              bool paysAtDefaultTime,
                              const Date& startDate,
                              const DayCounter& lastPeriodDayCounter,
                              const bool rebatesAccrual,
                              const CreditDefaultSwap::PricingModel model)
    : CdsHelper(runningSpread, tenor, settlementDays, calendar,
                frequency, paymentConvention, rule, dayCounter,
                recoveryRate, discountCurve, settlesAccrual, paysAtDefaultTime,
                startDate, lastPeriodDayCounter, rebatesAccrual, model) {}

    Real SpreadCdsHelper::impliedQuote() const {
        swap_->recalculate();
        return swap_->fairSpread();
    }

    void SpreadCdsHelper::resetEngine() {
        swap_ = ext::make_shared<CreditDefaultSwap>(
            Protection::Buyer, 100.0, 0.01, schedule_, paymentConvention_,
            dayCounter_, settlesAccrual_, paysAtDefaultTime_, protectionStart_,
            ext::shared_ptr<Claim>(), lastPeriodDC_, rebatesAccrual_, evaluationDate_);

        switch (model_) {
          case CreditDefaultSwap::ISDA:
            swap_->setPricingEngine(ext::make_shared<IsdaCdsEngine>(
                probability_, recoveryRate_, discountCurve_, false,
                IsdaCdsEngine::Taylor, IsdaCdsEngine::HalfDayBias,
                IsdaCdsEngine::Piecewise));
            break;
          case CreditDefaultSwap::Midpoint:
            swap_->setPricingEngine(ext::make_shared<MidPointCdsEngine>(
                probability_, recoveryRate_, discountCurve_));
            break;
          default:
            QL_FAIL("unknown CDS pricing model: " << model_);
        }
    }

    UpfrontCdsHelper::UpfrontCdsHelper(
                              const std::variant<Rate, Handle<Quote>>& upfront,
                              Rate runningSpread,
                              const Period& tenor,
                              Integer settlementDays,
                              const Calendar& calendar,
                              Frequency frequency,
                              BusinessDayConvention paymentConvention,
                              DateGeneration::Rule rule,
                              const DayCounter& dayCounter,
                              Real recoveryRate,
                              const Handle<YieldTermStructure>& discountCurve,
                              Natural upfrontSettlementDays,
                              bool settlesAccrual,
                              bool paysAtDefaultTime,
                              const Date& startDate,
                              const DayCounter& lastPeriodDayCounter,
                              const bool rebatesAccrual,
                              const CreditDefaultSwap::PricingModel model)
    : CdsHelper(upfront, tenor, settlementDays, calendar,
                frequency, paymentConvention, rule, dayCounter,
                recoveryRate, discountCurve, settlesAccrual, paysAtDefaultTime,
                startDate, lastPeriodDayCounter, rebatesAccrual, model),
      upfrontSettlementDays_(upfrontSettlementDays),
      upfrontDate_(upfrontDate()),
      runningSpread_(runningSpread) {}

    Date UpfrontCdsHelper::upfrontDate() {
        return calendar_.advance(evaluationDate_, upfrontSettlementDays_, Days, paymentConvention_);
    }

    void UpfrontCdsHelper::initializeDates() {
        CdsHelper::initializeDates();
        upfrontDate_ = upfrontDate();
    }

    void UpfrontCdsHelper::resetEngine() {
        swap_ = ext::make_shared<CreditDefaultSwap>(
            Protection::Buyer, 100.0, 0.01, runningSpread_, schedule_,
            paymentConvention_, dayCounter_, settlesAccrual_,
            paysAtDefaultTime_, protectionStart_, upfrontDate_,
            ext::shared_ptr<Claim>(), lastPeriodDC_, rebatesAccrual_,
            evaluationDate_);

        switch (model_) {
          case CreditDefaultSwap::ISDA:
            swap_->setPricingEngine(ext::make_shared<IsdaCdsEngine>(
                probability_, recoveryRate_, discountCurve_, false,
                IsdaCdsEngine::Taylor, IsdaCdsEngine::HalfDayBias,
                IsdaCdsEngine::Piecewise));
            break;
          case CreditDefaultSwap::Midpoint:
            swap_->setPricingEngine(ext::make_shared<MidPointCdsEngine>(
                probability_, recoveryRate_, discountCurve_));
            break;
          default:
            QL_FAIL("unknown CDS pricing model: " << model_);
        }
    }

    Real UpfrontCdsHelper::impliedQuote() const {
        SavedSettings backup;
        Settings::instance().includeTodaysCashFlows() = true;
        swap_->recalculate();
        return swap_->fairUpfront();
    }

}
]]></document_content>
  </document>
  <document index="3">
    <source>credit/flathazardrate.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/credit/flathazardrate.hpp>
#include <utility>

namespace QuantLib {

    FlatHazardRate::FlatHazardRate(const Date& referenceDate,
                                   Handle<Quote> hazardRate,
                                   const DayCounter& dayCounter)
    : HazardRateStructure(referenceDate, Calendar(), dayCounter),
      hazardRate_(std::move(hazardRate)) {
        registerWith(hazardRate_);
    }

    FlatHazardRate::FlatHazardRate(const Date& referenceDate,
                                   Rate hazardRate,
                                   const DayCounter& dayCounter)
    : HazardRateStructure(referenceDate, Calendar(), dayCounter),
      hazardRate_(ext::shared_ptr<Quote>(new SimpleQuote(hazardRate))) {}

    FlatHazardRate::FlatHazardRate(Natural settlementDays,
                                   const Calendar& calendar,
                                   Handle<Quote> hazardRate,
                                   const DayCounter& dayCounter)
    : HazardRateStructure(settlementDays, calendar, dayCounter),
      hazardRate_(std::move(hazardRate)) {
        registerWith(hazardRate_);
    }

    FlatHazardRate::FlatHazardRate(Natural settlementDays,
                                   const Calendar& calendar,
                                   Rate hazardRate,
                                   const DayCounter& dayCounter)
    : HazardRateStructure(settlementDays, calendar, dayCounter),
      hazardRate_(ext::shared_ptr<Quote>(new SimpleQuote(hazardRate))) {}

}
]]></document_content>
  </document>
  <document index="4">
    <source>credit/hazardratestructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Jose Aparicio
 Copyright (C) 2008 Chris Kenyon
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2008 StatPro Italia srl
 Copyright (C) 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/termstructures/credit/hazardratestructure.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        template <class F>
        struct remapper {
            F f;
            Time T;
            remapper(F f, Time T) : f(std::move(f)), T(T) {}
            // This remaps [-1,1] to [0,T]. No differential included.
            Real operator()(Real x) const {
                const Real arg = (x+1.0)*T/2.0;
                return f(arg);
            }
        };

        template <class F>
        remapper<F> remap(const F& f, Time T) {
            return remapper<F>(f,T);
        }

    }

    HazardRateStructure::HazardRateStructure(
                                    const DayCounter& dc,
                                    const std::vector<Handle<Quote> >& jumps,
                                    const std::vector<Date>& jumpDates)
    : DefaultProbabilityTermStructure(dc, jumps, jumpDates) {}

    HazardRateStructure::HazardRateStructure(
                                    const Date& refDate,
                                    const Calendar& cal,
                                    const DayCounter& dc,
                                    const std::vector<Handle<Quote> >& jumps,
                                    const std::vector<Date>& jumpDates)
    : DefaultProbabilityTermStructure(refDate, cal, dc, jumps, jumpDates) {}

    HazardRateStructure::HazardRateStructure(
                                    Natural settlDays,
                                    const Calendar& cal,
                                    const DayCounter& dc,
                                    const std::vector<Handle<Quote> >& jumps,
                                    const std::vector<Date>& jumpDates)
    : DefaultProbabilityTermStructure(settlDays, cal, dc, jumps, jumpDates) {}

    Real HazardRateStructure::hazardRateImpl(Time) const {
        QL_FAIL("hazardRateImpl() must be implemented by a class derived from HazardRateStructure");
    }

    Probability HazardRateStructure::survivalProbabilityImpl(Time t) const {
        static GaussChebyshevIntegration integral(48);
        // the Gauss-Chebyshev quadratures integrate over [-1,1],
        // hence the remapping (and the Jacobian term t/2)
        return std::exp(-integral(remap([&](Time tau){ return hazardRateImpl(tau); }, t)) * t/2.0);
    }

}
]]></document_content>
  </document>
  <document index="5">
    <source>credit/survivalprobabilitystructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/credit/survivalprobabilitystructure.hpp>

namespace QuantLib {

    SurvivalProbabilityStructure::SurvivalProbabilityStructure(
                                    const DayCounter& dc,
                                    const std::vector<Handle<Quote> >& jumps,
                                    const std::vector<Date>& jumpDates)
    : DefaultProbabilityTermStructure(dc, jumps, jumpDates) {}

    SurvivalProbabilityStructure::SurvivalProbabilityStructure(
                                    const Date& refDate,
                                    const Calendar& cal,
                                    const DayCounter& dc,
                                    const std::vector<Handle<Quote> >& jumps,
                                    const std::vector<Date>& jumpDates)
    : DefaultProbabilityTermStructure(refDate, cal, dc, jumps, jumpDates) {}

    SurvivalProbabilityStructure::SurvivalProbabilityStructure(
                                    Natural settlDays,
                                    const Calendar& cal,
                                    const DayCounter& dc,
                                    const std::vector<Handle<Quote> >& jumps,
                                    const std::vector<Date>& jumpDates)
    : DefaultProbabilityTermStructure(settlDays, cal, dc, jumps, jumpDates) {}

    Real SurvivalProbabilityStructure::defaultDensityImpl(Time t) const {
        Time dt = 0.0001;
        Time t1 = std::max(t-dt, 0.0);
        Time t2 = t+dt;

        Probability p1 = survivalProbabilityImpl(t1);
        Probability p2 = survivalProbabilityImpl(t2);

        return (p1-p2)/(t2-t1);
    }

}
]]></document_content>
  </document>
  <document index="6">
    <source>defaulttermstructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2008 Chris Kenyon
 Copyright (C) 2008 StatPro Italia srl
 Copyright (C) 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/defaulttermstructure.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <utility>

namespace QuantLib {

    DefaultProbabilityTermStructure::DefaultProbabilityTermStructure(
        const DayCounter& dc, std::vector<Handle<Quote> > jumps, const std::vector<Date>& jumpDates)
    : TermStructure(dc), jumps_(std::move(jumps)), jumpDates_(jumpDates),
      jumpTimes_(jumpDates.size()), nJumps_(jumps_.size()) {
        setJumps();
        for (Size i=0; i<nJumps_; ++i)
            registerWith(jumps_[i]);
    }

    DefaultProbabilityTermStructure::DefaultProbabilityTermStructure(
        const Date& referenceDate,
        const Calendar& cal,
        const DayCounter& dc,
        std::vector<Handle<Quote> > jumps,
        const std::vector<Date>& jumpDates)
    : TermStructure(referenceDate, cal, dc), jumps_(std::move(jumps)), jumpDates_(jumpDates),
      jumpTimes_(jumpDates.size()), nJumps_(jumps_.size()) {
        setJumps();
        for (Size i=0; i<nJumps_; ++i)
            registerWith(jumps_[i]);
    }

    DefaultProbabilityTermStructure::DefaultProbabilityTermStructure(
        Natural settlementDays,
        const Calendar& cal,
        const DayCounter& dc,
        std::vector<Handle<Quote> > jumps,
        const std::vector<Date>& jumpDates)
    : TermStructure(settlementDays, cal, dc), jumps_(std::move(jumps)), jumpDates_(jumpDates),
      jumpTimes_(jumpDates.size()), nJumps_(jumps_.size()) {
        setJumps();
        for (Size i=0; i<nJumps_; ++i)
            registerWith(jumps_[i]);
    }

    void DefaultProbabilityTermStructure::setJumps() {
        if (jumpDates_.empty() && !jumps_.empty()) { // turn of year dates
            jumpDates_.resize(nJumps_);
            jumpTimes_.resize(nJumps_);
            Year y = referenceDate().year();
            for (Size i=0; i<nJumps_; ++i)
                jumpDates_[i] = Date(31, December, y+i);
        } else { // fixed dats
            QL_REQUIRE(jumpDates_.size()==nJumps_,
                       "mismatch between number of jumps (" << nJumps_ <<
                       ") and jump dates (" << jumpDates_.size() << ")");
        }
        for (Size i=0; i<nJumps_; ++i)
            jumpTimes_[i] = timeFromReference(jumpDates_[i]);
        latestReference_ = referenceDate();
    }

    Probability DefaultProbabilityTermStructure::survivalProbability(
                                                     Time t,
                                                     bool extrapolate) const {
        checkRange(t, extrapolate);

        if (!jumps_.empty()) {
            Probability jumpEffect = 1.0;
            for (Size i=0; i<nJumps_ && jumpTimes_[i]<t; ++i) {
                QL_REQUIRE(jumps_[i]->isValid(),
                           "invalid " << io::ordinal(i+1) << " jump quote");
                DiscountFactor thisJump = jumps_[i]->value();
                QL_REQUIRE(thisJump > 0.0 && thisJump <= 1.0,
                           "invalid " << io::ordinal(i+1) << " jump value: " <<
                           thisJump);
                jumpEffect *= thisJump;
            }
            return jumpEffect * survivalProbabilityImpl(t);
        }

        return survivalProbabilityImpl(t);
    }

    Probability DefaultProbabilityTermStructure::defaultProbability(
                                                     const Date& d1,
                                                     const Date& d2,
                                                     bool extrapolate) const {
        QL_REQUIRE(d1 <= d2,
                   "initial date (" << d1 << ") "
                   "later than final date (" << d2 << ")");
        Probability p1 = d1 < referenceDate() ? 0.0 :
                                           defaultProbability(d1,extrapolate),
                    p2 = defaultProbability(d2,extrapolate);
        return p2 - p1;
    }

    Probability DefaultProbabilityTermStructure::defaultProbability(
                                                     Time t1,
                                                     Time t2,
                                                     bool extrapolate) const {
        QL_REQUIRE(t1 <= t2,
                   "initial time (" << t1 << ") "
                   "later than final time (" << t2 << ")");
        Probability p1 = t1 < 0.0 ? 0.0 : defaultProbability(t1,extrapolate),
                    p2 = defaultProbability(t2,extrapolate);
        return p2 - p1;
    }

}
]]></document_content>
  </document>
  <document index="7">
    <source>globalbootstrap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2019 SoftSolutions! S.r.l.
 Copyright (C) 2025 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/optimization/levenbergmarquardt.hpp>
#include <ql/termstructures/globalbootstrap.hpp>

namespace QuantLib {

MultiCurveBootstrap::MultiCurveBootstrap(Real accuracy) {
    optimizer_ = ext::make_shared<LevenbergMarquardt>(accuracy, accuracy, accuracy);
    endCriteria_ = ext::make_shared<EndCriteria>(1000, 10, accuracy, accuracy, accuracy);
}

MultiCurveBootstrap::MultiCurveBootstrap(ext::shared_ptr<OptimizationMethod> optimizer,
                                         ext::shared_ptr<EndCriteria> endCriteria)
: optimizer_(std::move(optimizer)), endCriteria_(std::move(endCriteria)) {
    constexpr auto accuracy = 1E-10;
    if (optimizer_ == nullptr)
        optimizer_ = ext::make_shared<LevenbergMarquardt>(accuracy, accuracy, accuracy);
    if (endCriteria_ == nullptr)
        endCriteria_ = ext::make_shared<EndCriteria>(1000, 10, accuracy, accuracy, accuracy);
}

void MultiCurveBootstrap::add(const MultiCurveBootstrapContributor* c) {
    contributors_.push_back(c);
    c->setParentBootstrapper(shared_from_this());
}

void MultiCurveBootstrap::addObserver(Observer* o) {
    observers_.push_back(o);
}

void MultiCurveBootstrap::runMultiCurveBootstrap() {

    std::vector<Size> guessSizes;
    std::vector<Real> globalGuess;

    for (auto const& c : contributors_) {
        Array guess = c->setupCostFunction();
        globalGuess.insert(globalGuess.end(), guess.begin(), guess.end());
        guessSizes.push_back(guess.size());
    }

    auto fn = [this, &guessSizes](const Array& x) {
        // call the contributors' cost functions' set part

        std::size_t offset = 0;
        for (std::size_t c = 0; c < contributors_.size(); ++c) {
            Array tmp(guessSizes[c]);
            std::copy(std::next(x.begin(), offset), std::next(x.begin(), offset + guessSizes[c]),
                      tmp.begin());
            offset += guessSizes[c];
            contributors_[c]->setCostFunctionArgument(tmp);
        }

        // update observers
        for(auto *o: observers_)
            o->update();

        // collect the contributors' result

        std::vector<Array> results;
        results.reserve(contributors_.size());
        for (auto& contributor : contributors_) {
            results.push_back(contributor->evaluateCostFunction());
        }

        // concatenate the contributors' values and return the concatenation as the result

        std::size_t resultSize =
            std::accumulate(results.begin(), results.end(), (std::size_t)0,
                            [](std::size_t len, const Array& a) { return len + a.size(); });

        Array result(resultSize);

        offset = 0;
        for (auto const& r : results) {
            std::copy(r.begin(), r.end(), std::next(result.begin(), offset));
            offset += r.size();
        }

        return result;
    };

    SimpleCostFunction<decltype(fn)> costFunction(fn);
    NoConstraint noConstraint;
    Problem problem(costFunction, noConstraint, Array(globalGuess.begin(), globalGuess.end()));
    EndCriteria::Type endType = optimizer_->minimize(problem, *endCriteria_);

    QL_REQUIRE(
        EndCriteria::succeeded(endType),
        "global bootstrap failed to minimize to required accuracy (during multi curve bootstrap): "
            << endType);

    // set all contributors to valid

    for (auto const& c : contributors_)
        c->setToValid();
}

} // namespace QuantLib
]]></document_content>
  </document>
  <document index="8">
    <source>globalbootstrapvars.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

#include <ql/termstructures/globalbootstrapvars.hpp>
#include <ql/utilities/null.hpp>
#include <ql/utilities/vectors.hpp>
#include <utility>

namespace QuantLib {

    SimpleQuoteVariables::SimpleQuoteVariables(std::vector<ext::shared_ptr<SimpleQuote>> quotes,
                                               std::vector<Real> initialGuesses,
                                               std::vector<Real> lowerBounds)
    : quotes_(std::move(quotes)), initialGuesses_(std::move(initialGuesses)),
      lowerBounds_(std::move(lowerBounds)) {
        QL_REQUIRE(initialGuesses_.size() <= quotes_.size(), "too many initialGuesses");
        QL_REQUIRE(lowerBounds_.size() <= quotes_.size(), "too many lowerBounds");
    }

    Array SimpleQuoteVariables::initialize(bool validData) {
        Array guesses(quotes_.size());
        for (Size i = 0, size = guesses.size(); i < size; ++i) {
            Real guess;
            if (validData) {
                guess = quotes_[i]->value();
            } else {
                guess = detail::get(initialGuesses_, i, 0.0);
                quotes_[i]->setValue(guess);
            }
            guesses[i] = transformInverse(guess, i);
        }
        return guesses;
    }

    void SimpleQuoteVariables::update(const Array& x) {
        for (Size i = 0, size = x.size(); i < size; ++i) {
            quotes_[i]->setValue(transformDirect(x[i], i));
        }
    }

    Real SimpleQuoteVariables::transformDirect(Real x, Size i) const {
        const Real lb = detail::get(lowerBounds_, i, Null<Real>());
        return lb == Null<Real>() ? x : std::exp(x) + lb;
    }

    Real SimpleQuoteVariables::transformInverse(Real x, Size i) const {
        const Real lb = detail::get(lowerBounds_, i, Null<Real>());
        return lb == Null<Real>() ? x : std::log(x - lb);
    }
}
]]></document_content>
  </document>
  <document index="9">
    <source>inflation/inflationhelpers.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 Chris Kenyon
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/cashflows/inflationcouponpricer.hpp>
#include <ql/indexes/inflationindex.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/shared_ptr.hpp>
#include <ql/termstructures/inflation/inflationhelpers.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/utilities/null_deleter.hpp>
#include <utility>

namespace QuantLib {

    QL_DEPRECATED_DISABLE_WARNING

    ZeroCouponInflationSwapHelper::ZeroCouponInflationSwapHelper(
        const Handle<Quote>& quote,
        const Period& swapObsLag,
        const Date& maturity,
        Calendar calendar,
        BusinessDayConvention paymentConvention,
        DayCounter dayCounter,
        const ext::shared_ptr<ZeroInflationIndex>& zii,
        CPI::InterpolationType observationInterpolation)
    : ZeroCouponInflationSwapHelper(
        quote, swapObsLag, Date(), maturity, std::move(calendar), paymentConvention,
        std::move(dayCounter), zii, observationInterpolation) {}

    ZeroCouponInflationSwapHelper::ZeroCouponInflationSwapHelper(
        const Handle<Quote>& quote,
        const Period& swapObsLag,
        const Date& startDate,
        const Date& endDate,
        Calendar calendar,
        BusinessDayConvention paymentConvention,
        DayCounter dayCounter,
        const ext::shared_ptr<ZeroInflationIndex>& zii,
        CPI::InterpolationType observationInterpolation)
    : ZeroCouponInflationSwapHelper(
        quote, swapObsLag, startDate, endDate, std::move(calendar), paymentConvention,
        std::move(dayCounter), zii, observationInterpolation,
        // any nominal term structure will give the same result;
        // when calculating the fair rate, the equal discount factors
        // for the payments on the two legs will cancel out.
        Handle<YieldTermStructure>(ext::make_shared<FlatForward>(0, NullCalendar(), 0.0, dayCounter))) {}

    ZeroCouponInflationSwapHelper::ZeroCouponInflationSwapHelper(
        const Handle<Quote>& quote,
        const Period& swapObsLag,
        const Date& maturity,
        Calendar calendar,
        BusinessDayConvention paymentConvention,
        DayCounter dayCounter,
        const ext::shared_ptr<ZeroInflationIndex>& zii,
        CPI::InterpolationType observationInterpolation,
        Handle<YieldTermStructure> nominalTermStructure)
    : ZeroCouponInflationSwapHelper(
        quote, swapObsLag, Date(), maturity, std::move(calendar), paymentConvention,
        std::move(dayCounter), zii, observationInterpolation, std::move(nominalTermStructure)) {}

    ZeroCouponInflationSwapHelper::ZeroCouponInflationSwapHelper(
        const Handle<Quote>& quote,
        const Period& swapObsLag,
        const Date& startDate,
        const Date& endDate,
        Calendar calendar,
        BusinessDayConvention paymentConvention,
        DayCounter dayCounter,
        const ext::shared_ptr<ZeroInflationIndex>& zii,
        CPI::InterpolationType observationInterpolation,
        Handle<YieldTermStructure> nominalTermStructure)
    : RelativeDateBootstrapHelper<ZeroInflationTermStructure>(quote, startDate == Date()),
      swapObsLag_(swapObsLag), startDate_(startDate), maturity_(endDate),
      calendar_(std::move(calendar)), paymentConvention_(paymentConvention),
      dayCounter_(std::move(dayCounter)), observationInterpolation_(observationInterpolation),
      nominalTermStructure_(std::move(nominalTermStructure)) {
        zii_ = zii->clone(termStructureHandle_);
        // We want to be notified of changes of fixings, but we don't
        // want notifications from termStructureHandle_ (they would
        // interfere with bootstrapping.)
        zii_->unregisterWith(termStructureHandle_);

        auto fixingPeriod = inflationPeriod(maturity_ - swapObsLag_, zii_->frequency());
        auto interpolationPeriod = inflationPeriod(maturity_, zii_->frequency());

        if (detail::CPI::isInterpolated(observationInterpolation_) && maturity_ > interpolationPeriod.first) {
            // if interpolated, we need to cover the end of the interpolation period
            earliestDate_ = fixingPeriod.first;
            latestDate_ = fixingPeriod.second + 1;
        } else {
            // if not interpolated, the date of the initial fixing is enough
            earliestDate_ = fixingPeriod.first;
            latestDate_ = fixingPeriod.first;
        }

        // check that the observation lag of the swap
        // is compatible with the availability lag of the index AND
        // it's interpolation (assuming the start day is spot)
        if (detail::CPI::isInterpolated(observationInterpolation_)) {
            Period pShift(zii_->frequency());
            QL_REQUIRE(swapObsLag_ - pShift >= zii_->availabilityLag(),
                       "inconsistency between swap observation lag "
                           << swapObsLag_ << ", index period " << pShift << " and index availability "
                           << zii_->availabilityLag() << ": need (obsLag-index period) >= availLag");
        }

        registerWith(zii_);
        registerWith(nominalTermStructure_);
        ZeroCouponInflationSwapHelper::initializeDates();
    }

    QL_DEPRECATED_ENABLE_WARNING


    Real ZeroCouponInflationSwapHelper::impliedQuote() const {
        zciis_->deepUpdate();
        return zciis_->fairRate();
    }

    void ZeroCouponInflationSwapHelper::initializeDates() {
        zciis_ = ext::make_shared<ZeroCouponInflationSwap>(
            Swap::Payer, 1.0, updateDates_ ? evaluationDate_ : startDate_, maturity_, calendar_,
            paymentConvention_, dayCounter_, 0.0, zii_, swapObsLag_,
            observationInterpolation_);
        // The instrument takes a standard discounting swap engine.
        // The inflation-related work is done by the coupons.
        zciis_->setPricingEngine(
            ext::make_shared<DiscountingSwapEngine>(nominalTermStructure_));
    }

    void ZeroCouponInflationSwapHelper::setTermStructure(ZeroInflationTermStructure* z) {
        // do not set the relinkable handle as an observer -
        // force recalculation when needed
        bool observer = false;

        ext::shared_ptr<ZeroInflationTermStructure> temp(z, null_deleter());
        termStructureHandle_.linkTo(std::move(temp), observer);

        RelativeDateBootstrapHelper<ZeroInflationTermStructure>::setTermStructure(z);
    }


    YearOnYearInflationSwapHelper::YearOnYearInflationSwapHelper(
        const Handle<Quote>& quote,
        const Period& swapObsLag,
        const Date& maturity,
        Calendar calendar,
        BusinessDayConvention paymentConvention,
        DayCounter dayCounter,
        const ext::shared_ptr<YoYInflationIndex>& yii,
        CPI::InterpolationType interpolation,
        Handle<YieldTermStructure> nominalTermStructure)
    : YearOnYearInflationSwapHelper(
        quote, swapObsLag, Date(), maturity, std::move(calendar), paymentConvention,
        std::move(dayCounter), yii, interpolation, std::move(nominalTermStructure)) {}

    YearOnYearInflationSwapHelper::YearOnYearInflationSwapHelper(
        const Handle<Quote>& quote,
        const Period& swapObsLag,
        const Date& startDate,
        const Date& endDate,
        Calendar calendar,
        BusinessDayConvention paymentConvention,
        DayCounter dayCounter,
        const ext::shared_ptr<YoYInflationIndex>& yii,
        CPI::InterpolationType interpolation,
        Handle<YieldTermStructure> nominalTermStructure)
    : RelativeDateBootstrapHelper<YoYInflationTermStructure>(quote, startDate == Date()),
      swapObsLag_(swapObsLag), startDate_(startDate), maturity_(endDate),
      calendar_(std::move(calendar)), paymentConvention_(paymentConvention),
      dayCounter_(std::move(dayCounter)), interpolation_(interpolation),
      nominalTermStructure_(std::move(nominalTermStructure)) {
        yii_ = yii->clone(termStructureHandle_);
        // We want to be notified of changes of fixings, but we don't
        // want notifications from termStructureHandle_ (they would
        // interfere with bootstrapping.)
        yii_->unregisterWith(termStructureHandle_);

        auto fixingPeriod = inflationPeriod(maturity_ - swapObsLag_, yii_->frequency());
        auto interpolationPeriod = inflationPeriod(maturity_, yii_->frequency());

        if (detail::CPI::isInterpolated(interpolation_, yii_) && maturity_ > interpolationPeriod.first) {
            // if interpolated, we need to cover the end of the interpolation period
            earliestDate_ = fixingPeriod.first;
            latestDate_ = fixingPeriod.second + 1;
        } else {
            // if not interpolated, the date of the initial fixing is enough
            earliestDate_ = fixingPeriod.first;
            latestDate_ = fixingPeriod.first;
        }

        // check that the observation lag of the swap
        // is compatible with the availability lag of the index AND
        // its interpolation (assuming the start day is spot)
        if (detail::CPI::isInterpolated(interpolation_, yii_)) {
            Period pShift(yii_->frequency());
            QL_REQUIRE(swapObsLag_ - pShift >= yii_->availabilityLag(),
                       "inconsistency between swap observation lag "
                       << swapObsLag_ << ", index period " << pShift << " and index availability "
                       << yii_->availabilityLag() << ": need (obsLag-index period) >= availLag");
        }

        registerWith(yii_);
        registerWith(nominalTermStructure_);
        YearOnYearInflationSwapHelper::initializeDates();
    }

    Real YearOnYearInflationSwapHelper::impliedQuote() const {
        yyiis_->deepUpdate();
        return yyiis_->fairRate();
    }

    void YearOnYearInflationSwapHelper::initializeDates() {
        // always works because tenor is always 1 year so
        // no problem with different days-in-month
        Schedule fixedSchedule = MakeSchedule()
                                     .from(updateDates_ ? evaluationDate_ : startDate_)
                                     .to(maturity_)
                                     .withTenor(1 * Years)
                                     .withConvention(Unadjusted)
                                     .withCalendar(calendar_) // fixed leg gets cal from sched
                                     .backwards();
        const Schedule& yoySchedule = fixedSchedule;

        yyiis_ = ext::make_shared<YearOnYearInflationSwap>(
            Swap::Payer, 1.0, fixedSchedule, 0.0, dayCounter_,
            yoySchedule, yii_, swapObsLag_, interpolation_,
            0.0, dayCounter_, calendar_, paymentConvention_);

        // The instrument takes a standard discounting swap engine.
        // The inflation-related work is done by the coupons.
        yyiis_->setPricingEngine(
            ext::make_shared<DiscountingSwapEngine>(nominalTermStructure_));
    }

    void YearOnYearInflationSwapHelper::setTermStructure(YoYInflationTermStructure* y) {
        // do not set the relinkable handle as an observer -
        // force recalculation when needed
        bool observer = false;

        ext::shared_ptr<YoYInflationTermStructure> temp(y, null_deleter());
        termStructureHandle_.linkTo(std::move(temp), observer);

        RelativeDateBootstrapHelper<YoYInflationTermStructure>::setTermStructure(y);
    }

}
]]></document_content>
  </document>
  <document index="10">
    <source>inflation/seasonality.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Piero Del Boca
 Copyright (C) 2009 Chris Kenyon
 Copyright (C) 2015 Bernd Lewerenz

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include <ql/termstructures/inflation/seasonality.hpp>
#include <ql/termstructures/inflationtermstructure.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    bool Seasonality::isConsistent(const InflationTermStructure&) const {
        return true;
    }


    //Multiplicative Seasonality on price = on CPI/RPI/HICP/etc

    void MultiplicativePriceSeasonality::validate() const
    {
        // NOLINTBEGIN(clang-analyzer-optin.cplusplus.VirtualCall)
        switch (this->frequency()) {
            case Semiannual:        //2
            case EveryFourthMonth:  //3
            case Quarterly:         //4
            case Bimonthly:         //6
            case Monthly:           //12
            case Biweekly:          // etc.
            case Weekly:
            case Daily:
                QL_REQUIRE(!this->seasonalityFactors().empty(), "no seasonality factors given");
                QL_REQUIRE( (this->seasonalityFactors().size() %
                             this->frequency()) == 0,
                           "For frequency " << this->frequency()
                           << " require multiple of " << ((int)this->frequency()) << " factors "
                           << this->seasonalityFactors().size() << " were given.");
            break;
            default:
                QL_FAIL("bad frequency specified: " << this->frequency()
                        << ", only semi-annual through daily permitted.");
            break;
        }
        // NOLINTEND(clang-analyzer-optin.cplusplus.VirtualCall)
    }


    bool MultiplicativePriceSeasonality::isConsistent(const InflationTermStructure& iTS) const
    {
        // If multi-year is the specification consistent with the term structure start date?
        // We do NOT test daily seasonality because this will, in general, never be consistent
        // given weekends, holidays, leap years, etc.
        if(this->frequency() == Daily) return true;
        if(Size(this->frequency()) == seasonalityFactors().size()) return true;

        // how many years do you need to test?
        Size nTest = seasonalityFactors().size() / this->frequency();
        // ... relative to the start of the inflation curve
        std::pair<Date,Date> lim = inflationPeriod(iTS.baseDate(), iTS.frequency());
        Date curveBaseDate = lim.second;
        Real factorBase = this->seasonalityFactor(curveBaseDate);

        Real eps = 0.00001;
        for (Size i = 1; i < nTest; i++) {
            Real factorAt = this->seasonalityFactor(curveBaseDate+Period(i,Years));
            QL_REQUIRE(std::fabs(factorAt-factorBase)<eps,"seasonality is inconsistent with inflation term structure, factors "
                       << factorBase << " and later factor " << factorAt << ", " << i << " years later from inflation curve "
                       <<" with base date at " << curveBaseDate);
        }

        return true;
    }


    MultiplicativePriceSeasonality::MultiplicativePriceSeasonality(const Date& seasonalityBaseDate, const Frequency frequency,
                                                                   const std::vector<Rate>& seasonalityFactors)
    {
        MultiplicativePriceSeasonality::set(seasonalityBaseDate, frequency, seasonalityFactors);
    }

    void MultiplicativePriceSeasonality::set(const Date& seasonalityBaseDate, const Frequency frequency,
                                             const std::vector<Rate>& seasonalityFactors)
    {
        frequency_ = frequency;
        seasonalityFactors_ = std::vector<Rate>(seasonalityFactors.size());
        for(Size i=0; i<seasonalityFactors.size(); i++) {
            seasonalityFactors_[i] = seasonalityFactors[i];
        }
        seasonalityBaseDate_ = seasonalityBaseDate;
        // NOLINTNEXTLINE(clang-analyzer-optin.cplusplus.VirtualCall)
        validate();
    }

    Date MultiplicativePriceSeasonality::seasonalityBaseDate() const {
        return seasonalityBaseDate_;
    }

    Frequency MultiplicativePriceSeasonality::frequency() const {
        return frequency_;
    }

    std::vector<Rate> MultiplicativePriceSeasonality::seasonalityFactors() const {
        return seasonalityFactors_;
    }


    Rate MultiplicativePriceSeasonality::correctZeroRate(const Date &d,
                                                         const Rate r,
                                                         const InflationTermStructure& iTS) const {
        // Mimic the logic in ZeroInflationIndex::forecastFixing for choosing the
        // curveBaseDate and effective fixing date. This means that we should retrieve
        // the input seasonality adjustments when we look at I_{SA}(t) / I_{NSA}(t).
        Date curveBaseDate = iTS.baseDate();
        Date effectiveFixingDate = inflationPeriod(d, iTS.frequency()).first;
        
        return seasonalityCorrection(r, effectiveFixingDate, iTS.dayCounter(), curveBaseDate, true);
    }


    Rate MultiplicativePriceSeasonality::correctYoYRate(const Date &d,
                                                        const Rate r,
                                                        const InflationTermStructure& iTS) const {
        std::pair<Date,Date> lim = inflationPeriod(iTS.baseDate(), iTS.frequency());
        Date curveBaseDate = lim.second;
        return seasonalityCorrection(r, d, iTS.dayCounter(), curveBaseDate, false);
    }


    Real MultiplicativePriceSeasonality::seasonalityFactor(const Date &to) const {

        Date from = seasonalityBaseDate();
        Frequency factorFrequency = frequency();
        Size nFactors = seasonalityFactors().size();
        Period factorPeriod(factorFrequency);
        Size which = 0;
        if (from==to) {
            which = 0;
        } else {
            // days, weeks, months, years are the only time unit possibilities
            Integer diffDays = std::abs(to - from);  // in days
            Integer dir = 1;
            if(from > to)dir = -1;
            Integer diff;
            if (factorPeriod.units() == Days) {
                diff = dir*diffDays;
            } else if (factorPeriod.units() == Weeks) {
                diff = dir * (diffDays / 7);
            } else if (factorPeriod.units() == Months) {
                std::pair<Date,Date> lim = inflationPeriod(to, factorFrequency);
                diff = diffDays / (31*factorPeriod.length());
                Date go = from + dir*diff*factorPeriod;
                while ( !(lim.first <= go && go <= lim.second) ) {
                    go += dir*factorPeriod;
                    diff++;
                }
                diff=dir*diff;
            } else if (factorPeriod.units() == Years) {
                QL_FAIL("seasonality period time unit is not allowed to be : " << factorPeriod.units());
            } else {
                QL_FAIL("Unknown time unit: " << factorPeriod.units());
            }
            // now adjust to the available number of factors, direction dependent

            if (dir==1) {
                which = diff % nFactors;
            } else {
                which = (nFactors - (-diff % nFactors)) % nFactors;
            }
        }

        return seasonalityFactors()[which];
    }


    Rate MultiplicativePriceSeasonality::seasonalityCorrection(Rate rate,
                                                               const Date& atDate,
                                                               const DayCounter& dc,
                                                               const Date& curveBaseDate,
                                                               const bool isZeroRate) const {
        // need _two_ corrections in order to get: seasonality = factor[atDate-seasonalityBase] / factor[reference-seasonalityBase]
        // i.e. for ZERO inflation rates you have the true fixing at the curve base so this factor must be normalized to one
        //      for YoY inflation rates your reference point is the year before

        Real factorAt = this->seasonalityFactor(atDate);

        //Getting seasonality correction for either ZC or YoY
        Rate f;
        if (isZeroRate) {
            Rate factorBase = this->seasonalityFactor(curveBaseDate);
            Real seasonalityAt = factorAt / factorBase;
            std::pair<Date,Date> p = inflationPeriod(atDate,frequency());
            Time timeFromCurveBase = dc.yearFraction(curveBaseDate, p.first);
            f = std::pow(seasonalityAt, 1/timeFromCurveBase);
        }
        else {
            Rate factor1Ybefore = this->seasonalityFactor(atDate - Period(1,Years));
            f = factorAt / factor1Ybefore;
        }

        return (rate + 1)*f - 1;
    }


    Real KerkhofSeasonality::seasonalityFactor(const Date &to) const {

        Integer dir = 1;
        Date from = seasonalityBaseDate();
        Size fromMonth = from.month();
        Size toMonth = to.month();

        Period factorPeriod(frequency());

        if (toMonth < fromMonth)
        {
            Size dummy = fromMonth;
            fromMonth = toMonth;
            toMonth = dummy;
            dir = 0; // We calculate invers Factor in loop
        }

        QL_REQUIRE(seasonalityFactors().size() == 12 &&
                   factorPeriod.units() == Months,
                   "12 monthly seasonal factors needed for Kerkhof Seasonality:"
                   << " got " << seasonalityFactors().size());

        Real seasonalCorrection = 1.0;
        for (Size i = fromMonth ; i<toMonth; i++)
        {
            seasonalCorrection *= seasonalityFactors()[i];

        }

        if (dir == 0) // invers Factor required
        {
            seasonalCorrection = 1/seasonalCorrection;
        }

        return seasonalCorrection;
    }

    Rate KerkhofSeasonality::seasonalityCorrection(Rate rate,
                                                   const Date& atDate,
                                                   const DayCounter& dc,
                                                   const Date& curveBaseDate,
                                                   const bool isZeroRate) const {

        Real indexFactor = this->seasonalityFactor(atDate);

        // Getting seasonality correction
        Rate f;
        if (isZeroRate) {
            std::pair<Date,Date> lim = inflationPeriod(curveBaseDate, Monthly);
            Time timeFromCurveBase = dc.yearFraction(lim.first, atDate);
            f = std::pow(indexFactor, 1/timeFromCurveBase);
        }
        else {
            QL_FAIL("Seasonal Kerkhof model is not defined on YoY rates");
        }

        return (rate + 1)*f - 1;
    }

}
]]></document_content>
  </document>
  <document index="11">
    <source>inflationtermstructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/inflationindex.hpp>
#include <ql/termstructures/inflationtermstructure.hpp>
#include <utility>

namespace QuantLib {

    QL_DEPRECATED_DISABLE_WARNING

    InflationTermStructure::InflationTermStructure(
                                        Date baseDate,
                                        Frequency frequency,
                                        const DayCounter& dayCounter,
                                        ext::shared_ptr<Seasonality> seasonality,
                                        Rate baseRate)
    : TermStructure(dayCounter), seasonality_(std::move(seasonality)),
      frequency_(frequency), baseRate_(baseRate), baseDate_(baseDate) {
        if (seasonality_ != nullptr) {
            QL_REQUIRE(seasonality_->isConsistent(*this),
                       "Seasonality inconsistent with inflation term structure");
        }
    }

    InflationTermStructure::InflationTermStructure(
                                        const Date& referenceDate,
                                        Date baseDate,
                                        Frequency frequency,
                                        const DayCounter& dayCounter,
                                        ext::shared_ptr<Seasonality> seasonality,
                                        Rate baseRate)
    : TermStructure(referenceDate, Calendar(), dayCounter), seasonality_(std::move(seasonality)),
      frequency_(frequency), baseRate_(baseRate), baseDate_(baseDate) {
        if (seasonality_ != nullptr) {
            QL_REQUIRE(seasonality_->isConsistent(*this),
                       "Seasonality inconsistent with inflation term structure");
        }
    }

    InflationTermStructure::InflationTermStructure(
                                        Natural settlementDays,
                                        const Calendar& calendar,
                                        Date baseDate,
                                        Frequency frequency,
                                        const DayCounter& dayCounter,
                                        ext::shared_ptr<Seasonality> seasonality,
                                        Rate baseRate)
    : TermStructure(settlementDays, calendar, dayCounter), seasonality_(std::move(seasonality)),
      frequency_(frequency), baseRate_(baseRate), baseDate_(baseDate) {
        if (seasonality_ != nullptr) {
            QL_REQUIRE(seasonality_->isConsistent(*this),
                       "Seasonality inconsistent with inflation term structure");
        }
    }

    QL_DEPRECATED_ENABLE_WARNING

    Date InflationTermStructure::baseDate() const {
        return baseDate_;
    }

    void InflationTermStructure::setSeasonality(
                          const ext::shared_ptr<Seasonality>& seasonality) {
        // always reset, whether with null or new pointer
        seasonality_ = seasonality;
        if (seasonality_ != nullptr) {
            QL_REQUIRE(seasonality_->isConsistent(*this),
                       "Seasonality inconsistent with inflation term structure");
        }
        update();
    }


    void InflationTermStructure::checkRange(const Date& d,
                                            bool extrapolate) const {
        QL_REQUIRE(d >= baseDate(),
                   "date (" << d << ") is before base date (" << baseDate() << ")");
        QL_REQUIRE(extrapolate || allowsExtrapolation() || d <= maxDate(),
                   "date (" << d << ") is past max curve date ("
                   << maxDate() << ")");
    }

    void InflationTermStructure::checkRange(Time t,
                                            bool extrapolate) const {
        QL_REQUIRE(t >= timeFromReference(baseDate()),
                   "time (" << t << ") is before base date");
        QL_REQUIRE(extrapolate || allowsExtrapolation() || t <= maxTime(),
                   "time (" << t << ") is past max curve time ("
                   << maxTime() << ")");
    }


    ZeroInflationTermStructure::ZeroInflationTermStructure(
                                   Date baseDate,
                                   Frequency frequency,
                                   const DayCounter& dayCounter,
                                   const ext::shared_ptr<Seasonality>& seasonality)
    : InflationTermStructure(baseDate, frequency, dayCounter, seasonality) {}

    ZeroInflationTermStructure::ZeroInflationTermStructure(
                                   const Date& referenceDate,
                                   Date baseDate,
                                   Frequency frequency,
                                   const DayCounter& dayCounter,
                                   const ext::shared_ptr<Seasonality>& seasonality)
    : InflationTermStructure(referenceDate, baseDate, frequency, dayCounter, seasonality) {}

    ZeroInflationTermStructure::ZeroInflationTermStructure(
                                   Natural settlementDays,
                                   const Calendar& calendar,
                                   Date baseDate,
                                   Frequency frequency,
                                   const DayCounter& dayCounter,
                                   const ext::shared_ptr<Seasonality>& seasonality)
    : InflationTermStructure(settlementDays, calendar, baseDate, frequency, dayCounter, seasonality) {}

    Rate ZeroInflationTermStructure::zeroRate(const Date &d, bool extrapolate) const {
        QL_DEPRECATED_DISABLE_WARNING
        return zeroRate(d, Period(0, Days), false, extrapolate);
        QL_DEPRECATED_ENABLE_WARNING
    }

    Rate ZeroInflationTermStructure::zeroRate(const Date &d, const Period& instObsLag,
                                              bool forceLinearInterpolation,
                                              bool extrapolate) const {

        Period useLag = instObsLag;
        if (instObsLag == Period(-1,Days)) {
            useLag = Period(0, Days);
        }

        Rate zeroRate;
        if (forceLinearInterpolation) {
            std::pair<Date,Date> dd = inflationPeriod(d-useLag, frequency());
            dd.second = dd.second + Period(1,Days);
            Real dp = dd.second - dd.first;
            Real dt = d - dd.first;
            // if we are interpolating we only check the exact point
            // this prevents falling off the end at curve maturity
            InflationTermStructure::checkRange(d, extrapolate);
            Time t1 = timeFromReference(dd.first);
            Time t2 = timeFromReference(dd.second);
            Rate z1 = zeroRateImpl(t1);
            Rate z2 = zeroRateImpl(t2);
            zeroRate = z1 + (z2-z1) * (dt/dp);
        } else {
            std::pair<Date,Date> dd = inflationPeriod(d-useLag, frequency());
            InflationTermStructure::checkRange(dd.first, extrapolate);
            Time t = timeFromReference(dd.first);
            zeroRate = zeroRateImpl(t);
        }

        if (hasSeasonality()) {
            zeroRate = seasonality()->correctZeroRate(d-useLag, zeroRate, *this);
        }
        return zeroRate;
    }

    Rate ZeroInflationTermStructure::zeroRate(Time t,
                                              bool extrapolate) const {
        checkRange(t, extrapolate);
        return zeroRateImpl(t);
    }


    YoYInflationTermStructure::YoYInflationTermStructure(
                                    Date baseDate,
                                    Rate baseYoYRate,
                                    Frequency frequency,
                                    const DayCounter& dayCounter,
                                    const ext::shared_ptr<Seasonality> &seasonality)
    : InflationTermStructure(baseDate, frequency, dayCounter, seasonality, baseYoYRate) {}

    YoYInflationTermStructure::YoYInflationTermStructure(
                                    const Date& referenceDate,
                                    Date baseDate,
                                    Rate baseYoYRate,
                                    Frequency frequency,
                                    const DayCounter& dayCounter,
                                    const ext::shared_ptr<Seasonality> &seasonality)
    : InflationTermStructure(referenceDate, baseDate, frequency, dayCounter, seasonality, baseYoYRate) {}

    YoYInflationTermStructure::YoYInflationTermStructure(
                                    Natural settlementDays,
                                    const Calendar& calendar,
                                    Date baseDate,
                                    Rate baseYoYRate,
                                    Frequency frequency,
                                    const DayCounter& dayCounter,
                                    const ext::shared_ptr<Seasonality> &seasonality)
    : InflationTermStructure(settlementDays, calendar, baseDate, frequency, dayCounter, seasonality, baseYoYRate) {}

    Rate YoYInflationTermStructure::yoyRate(const Date &d, bool extrapolate) const {
        QL_DEPRECATED_DISABLE_WARNING
        return yoyRate(d, Period(0, Days), false, extrapolate);
        QL_DEPRECATED_ENABLE_WARNING
    }

    Rate YoYInflationTermStructure::yoyRate(const Date &d, const Period& instObsLag,
                                            bool forceLinearInterpolation,
                                            bool extrapolate) const {

        Period useLag = instObsLag;
        if (instObsLag == Period(-1,Days)) {
            useLag = Period(0, Days);
        }

        Rate yoyRate;
        if (forceLinearInterpolation) {
            std::pair<Date,Date> dd = inflationPeriod(d-useLag, frequency());
            dd.second = dd.second + Period(1,Days);
            Real dp = dd.second - dd.first;
            Real dt = (d-useLag) - dd.first;
            // if we are interpolating we only check the exact point
            // this prevents falling off the end at curve maturity
            InflationTermStructure::checkRange(d, extrapolate);
            Time t1 = timeFromReference(dd.first);
            Time t2 = timeFromReference(dd.second);
            Rate y1 = yoyRateImpl(t1);
            Rate y2 = yoyRateImpl(t2);
            yoyRate = y1 + (y2-y1) * (dt/dp);
        } else {
            std::pair<Date,Date> dd = inflationPeriod(d-useLag, frequency());
            InflationTermStructure::checkRange(dd.first, extrapolate);
            Time t = timeFromReference(dd.first);
            yoyRate = yoyRateImpl(t);
        }

        if (hasSeasonality()) {
            yoyRate = seasonality()->correctYoYRate(d-useLag, yoyRate, *this);
        }
        return yoyRate;
    }

    Rate YoYInflationTermStructure::yoyRate(Time t,
                                            bool extrapolate) const {
        checkRange(t, extrapolate);
        return yoyRateImpl(t);
    }




    std::pair<Date,Date> inflationPeriod(const Date& d,
                                         Frequency frequency) {
        Month month = d.month();
        Year year = d.year();

        Month startMonth, endMonth;
        switch (frequency) {
          case Annual:
          case Semiannual:
          case EveryFourthMonth:
          case Quarterly:
          case Bimonthly: {
                int nMonths = 12 / frequency;
                startMonth = Month(month - (month - 1) % nMonths);
                endMonth = Month(startMonth + nMonths - 1);
            }
            break;
          case Monthly:
            startMonth = endMonth = month;
            break;
          default:
            QL_FAIL("Frequency not handled: " << frequency);
            break;
        };

        return {Date(1, startMonth, year), Date::endOfMonth(Date(1, endMonth, year))};
    }


    Time inflationYearFraction(Frequency f, bool indexIsInterpolated,
                               const DayCounter &dayCounter,
                               const Date &d1, const Date &d2) {

        Time t=0;
        if (indexIsInterpolated) {
            // N.B. we do not use linear interpolation between flat
            // fixing forecasts for forecasts.  This avoids awkwardnesses
            // when bootstrapping the inflation curve.
            t = dayCounter.yearFraction(d1, d2);
        } else {
            // I.e. fixing is constant for the whole inflation period.
            // Use the value for half way along the period.
            // But the inflation time is the time between period starts
            std::pair<Date,Date> limD1 = inflationPeriod(d1, f);
            std::pair<Date,Date> limD2 = inflationPeriod(d2, f);
            t = dayCounter.yearFraction(limD1.first, limD2.first);
        }

        return t;
    }


}
]]></document_content>
  </document>
  <document index="12">
    <source>multicurve.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2025 Eugene Toder
 Copyright (C) 2025 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/multicurve.hpp>

namespace QuantLib {

    MultiCurve::MultiCurve(Real accuracy)
    : multiCurveBootstrap_(ext::make_shared<MultiCurveBootstrap>(accuracy)) {}

    MultiCurve::MultiCurve(const ext::shared_ptr<OptimizationMethod>& optimizer,
                           const ext::shared_ptr<EndCriteria>& endCriteria)
    : multiCurveBootstrap_(ext::make_shared<MultiCurveBootstrap>(optimizer, endCriteria)) {}

    Handle<YieldTermStructure>
    MultiCurve::addBootstrappedCurve(RelinkableHandle<YieldTermStructure>& internalHandle,
                                     ext::shared_ptr<YieldTermStructure>&& curve) {
        QL_REQUIRE(internalHandle.empty(),
                   "internal handle must be empty; was the curve added already?");
        auto mcProv = ext::dynamic_pointer_cast<MultiCurveBootstrapProvider>(curve);
        QL_REQUIRE(mcProv != nullptr, "curve must be a MultiCurveBootstrapProvider");
        const auto *bootstrap = mcProv->multiCurveBootstrapContributor();
        QL_REQUIRE(bootstrap, "curve does not provide a valid multi curve bootstrap contributor");
        multiCurveBootstrap_->add(bootstrap);
        return addCurve(internalHandle, std::move(curve));
    }

    Handle<YieldTermStructure>
    MultiCurve::addNonBootstrappedCurve(RelinkableHandle<YieldTermStructure>& internalHandle,
                                        ext::shared_ptr<YieldTermStructure>&& curve) {
        QL_REQUIRE(internalHandle.empty(),
                   "internal handle must be empty; was the curve added already?");
        QL_REQUIRE(curve != nullptr, "curve must not be null");
        multiCurveBootstrap_->addObserver(curve.get());
        return addCurve(internalHandle, std::move(curve));
    }

    Handle<YieldTermStructure>
    MultiCurve::addCurve(RelinkableHandle<YieldTermStructure>& internalHandle,
                         ext::shared_ptr<YieldTermStructure>&& curve) {
        internalHandle.linkTo(ext::shared_ptr<YieldTermStructure>(curve.get(), null_deleter()),
                              false);
        Handle<YieldTermStructure> externalHandle(ext::shared_ptr<YieldTermStructure>(
#ifdef QL_ENABLE_THREAD_SAFE_OBSERVER_PATTERN
            ext::static_pointer_cast<MultiCurve>(shared_from_this())
#else
            shared_from_this()
#endif
                ,
            curve.get()));
        registerWithObservables(curve);
        curves_.push_back(curve);
        return externalHandle;
    }

    void MultiCurve::update() {
        for (auto const& c : curves_)
            c->update();
    }

}
]]></document_content>
  </document>
  <document index="13">
    <source>volatility/abcd.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006 Cristina Duminuco
 Copyright (C) 2005, 2006 Klaus Spanderen
 Copyright (C) 2007 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/abcd.hpp>
#include <ql/math/comparison.hpp>
#include <algorithm>

namespace QuantLib {

    AbcdFunction::AbcdFunction(Real a, Real b, Real c, Real d)
    : AbcdMathFunction(a, b, c, d) {}

    Real AbcdFunction::volatility(Time tMin, Time tMax, Time T) const {
        if (tMax==tMin)
            return instantaneousVolatility(tMax, T);
        QL_REQUIRE(tMax>tMin, "tMax must be > tMin");
        return std::sqrt(variance(tMin, tMax, T)/(tMax-tMin));
    }

    Real AbcdFunction::variance(Time tMin, Time tMax, Time T) const {
        return covariance(tMin, tMax, T, T);
    }

    Real AbcdFunction::covariance(Time t, Time T, Time S) const {
        return (*this)(T-t) * (*this)(S-t);
    }

    Real AbcdFunction::covariance(Time t1, Time t2, Time T, Time S) const {
        QL_REQUIRE(t1<=t2,
                   "integrations bounds (" << t1 <<
                   "," << t2 << ") are in reverse order");
        Time cutOff = std::min(S,T);
        if (t1>=cutOff) {
            return 0.0;
        } else {
            cutOff = std::min(t2, cutOff);
            return primitive(cutOff, T, S) - primitive(t1, T, S);
        }
    }

    // INSTANTANEOUS
    Real AbcdFunction::instantaneousVolatility(Time u, Time T) const {
        return std::sqrt(instantaneousVariance(u, T));
    }

    Real AbcdFunction::instantaneousVariance(Time u, Time T) const {
        return instantaneousCovariance(u, T, T);
    }
    Real AbcdFunction::instantaneousCovariance(Time u, Time T, Time S) const {
        return (*this)(T-u)*(*this)(S-u);
    }

    // PRIMITIVE
    Real AbcdFunction::primitive(Time t, Time T, Time S) const {
        if (T<t || S<t) return 0.0;

        if (close(c_,0.0)) {
            Real v = a_+d_;
            return t*(v*v+v*b_*S+v*b_*T-v*b_*t+b_*b_*S*T-0.5*b_*b_*t*(S+T)+b_*b_*t*t/3.0);
        }

        Real k1=std::exp(c_*t), k2=std::exp(c_*S), k3=std::exp(c_*T);

        return (b_*b_*(-1 - 2*c_*c_*S*T - c_*(S + T)
                     + k1*k1*(1 + c_*(S + T - 2*t) + 2*c_*c_*(S - t)*(T - t)))
                + 2*c_*c_*(2*d_*a_*(k2 + k3)*(k1 - 1)
                         +a_*a_*(k1*k1 - 1)+2*c_*d_*d_*k2*k3*t)
                + 2*b_*c_*(a_*(-1 - c_*(S + T) + k1*k1*(1 + c_*(S + T - 2*t)))
                         -2*d_*(k3*(1 + c_*S) + k2*(1 + c_*T)
                               - k1*k3*(1 + c_*(S - t))
                               - k1*k2*(1 + c_*(T - t)))
                         )
                ) / (4*c_*c_*c_*k2*k3);
    }

//===========================================================================//
//                               AbcdSquared                                //
//===========================================================================//

    AbcdSquared::AbcdSquared(Real a, Real b, Real c, Real d, Time T, Time S)
    : abcd_(new AbcdFunction(a,b,c,d)),
      T_(T), S_(S) {}

    Real AbcdSquared::operator()(Time t) const {
        return abcd_->covariance(t, T_, S_);
    }
}
]]></document_content>
  </document>
  <document index="14">
    <source>volatility/abcdcalibration.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2015 Ferdinando Ametrano
 Copyright (C) 2006 Cristina Duminuco
 Copyright (C) 2005, 2006 Klaus Spanderen
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2015 Paolo Mazzocchi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/interpolations/abcdinterpolation.hpp>
#include <ql/math/optimization/constraint.hpp>
#include <ql/math/optimization/levenbergmarquardt.hpp>
#include <ql/math/optimization/method.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/termstructures/volatility/abcd.hpp>
#include <ql/termstructures/volatility/abcdcalibration.hpp>
#include <utility>

namespace QuantLib {

    // to constrained <- from unconstrained
    Array AbcdCalibration::AbcdParametersTransformation::direct(const Array& x) const {
        y_[1] = x[1];
        y_[2] = std::exp(x[2]);
        y_[3] = std::exp(x[3]);
        y_[0] = std::exp(x[0]) - y_[3];
        return y_;
    }

    // to unconstrained <- from constrained
    Array AbcdCalibration::AbcdParametersTransformation::inverse(const Array& x) const {
        y_[1] = x[1];
        y_[2] = std::log(x[2]);
        y_[3] = std::log(x[3]);
        y_[0] = std::log(x[0] + x[3]);
        return y_;
    }

    // to constrained <- from unconstrained

    AbcdCalibration::AbcdCalibration(const std::vector<Real>& t,
                                     const std::vector<Real>& blackVols,
                                     Real a,
                                     Real b,
                                     Real c,
                                     Real d,
                                     bool aIsFixed,
                                     bool bIsFixed,
                                     bool cIsFixed,
                                     bool dIsFixed,
                                     bool vegaWeighted,
                                     ext::shared_ptr<EndCriteria> endCriteria,
                                     ext::shared_ptr<OptimizationMethod> optMethod)
    : aIsFixed_(aIsFixed), bIsFixed_(bIsFixed), cIsFixed_(cIsFixed), dIsFixed_(dIsFixed), a_(a),
      b_(b), c_(c), d_(d), abcdEndCriteria_(EndCriteria::None),
      endCriteria_(std::move(endCriteria)), optMethod_(std::move(optMethod)),
      weights_(blackVols.size(), 1.0 / blackVols.size()), vegaWeighted_(vegaWeighted), times_(t),
      blackVols_(blackVols) {

        AbcdMathFunction::validate(a, b, c, d);

        QL_REQUIRE(blackVols.size()==t.size(),
                       "mismatch between number of times (" << t.size() <<
                       ") and blackVols (" << blackVols.size() << ")");

        // if no optimization method or endCriteria is provided, we provide one
        if (!optMethod_) {
            Real epsfcn = 1.0e-8;
            Real xtol = 1.0e-8;
            Real gtol = 1.0e-8;
            bool useCostFunctionsJacobian = false;
            optMethod_ = ext::shared_ptr<OptimizationMethod>(new
                LevenbergMarquardt(epsfcn, xtol, gtol, useCostFunctionsJacobian));
        }
        if (!endCriteria_) {
            Size maxIterations = 10000;
            Size maxStationaryStateIterations = 1000;
            Real rootEpsilon = 1.0e-8;
            Real functionEpsilon = 0.3e-4;     // Why 0.3e-4 ?
            Real gradientNormEpsilon = 0.3e-4; // Why 0.3e-4 ?
            endCriteria_ = ext::make_shared<EndCriteria>(maxIterations, maxStationaryStateIterations,
                            rootEpsilon, functionEpsilon, gradientNormEpsilon);
        }
    }

    void AbcdCalibration::compute() {
        if (vegaWeighted_) {
            Real weightsSum = 0.0;
            for (Size i=0; i<times_.size() ; i++) {
                Real stdDev = std::sqrt(blackVols_[i]* blackVols_[i]* times_[i]);
                // when strike==forward, the blackFormulaStdDevDerivative becomes
                weights_[i] = CumulativeNormalDistribution().derivative(.5*stdDev);
                weightsSum += weights_[i];
            }
            // weight normalization
            for (Size i=0; i<times_.size() ; i++) {
                weights_[i] /= weightsSum;
            }
        }

        // there is nothing to optimize
        if (aIsFixed_ && bIsFixed_ && cIsFixed_ && dIsFixed_) {
            abcdEndCriteria_ = EndCriteria::None;
            //error_ = interpolationError();
            //maxError_ = interpolationMaxError();
            return;
        } else {

            AbcdError costFunction(this);
            transformation_ = ext::shared_ptr<ParametersTransformation>(new
                AbcdParametersTransformation);

            Array guess(4);
            guess[0] = a_;
            guess[1] = b_;
            guess[2] = c_;
            guess[3] = d_;

            std::vector<bool> parameterAreFixed(4);
            parameterAreFixed[0] = aIsFixed_;
            parameterAreFixed[1] = bIsFixed_;
            parameterAreFixed[2] = cIsFixed_;
            parameterAreFixed[3] = dIsFixed_;

            Array inversedTransformatedGuess(transformation_->inverse(guess));

            ProjectedCostFunction projectedAbcdCostFunction(costFunction,
                            inversedTransformatedGuess, parameterAreFixed);

            Array projectedGuess
                (projectedAbcdCostFunction.project(inversedTransformatedGuess));

            NoConstraint constraint;
            Problem problem(projectedAbcdCostFunction, constraint, projectedGuess);
            abcdEndCriteria_ = optMethod_->minimize(problem, *endCriteria_);
            Array projectedResult(problem.currentValue());
            Array transfResult(projectedAbcdCostFunction.include(projectedResult));

            Array result = transformation_->direct(transfResult);
            AbcdMathFunction::validate(a_, b_, c_, d_);
            a_ = result[0];
            b_ = result[1];
            c_ = result[2];
            d_ = result[3];

        }
    }

    Real AbcdCalibration::value(Real x) const {
        return abcdBlackVolatility(x,a_,b_,c_,d_);
    }

    std::vector<Real> AbcdCalibration::k(const std::vector<Real>& t,
                                         const std::vector<Real>& blackVols) const {
        QL_REQUIRE(blackVols.size()==t.size(),
               "mismatch between number of times (" << t.size() <<
               ") and blackVols (" << blackVols.size() << ")");
        std::vector<Real> k(t.size());
        for (Size i=0; i<t.size() ; i++) {
            k[i]=blackVols[i]/value(t[i]);
        }
        return k;
    }

    Real AbcdCalibration::error() const {
        Size n = times_.size();
        Real error, squaredError = 0.0;
        for (Size i=0; i<times_.size() ; i++) {
            error = (value(times_[i]) - blackVols_[i]);
            squaredError += error * error * weights_[i];
        }
        return std::sqrt(n*squaredError/(n-1));
    }

    Real AbcdCalibration::maxError() const {
        Real error, maxError = QL_MIN_REAL;
        for (Size i=0; i<times_.size() ; i++) {
            error = std::fabs(value(times_[i]) - blackVols_[i]);
            maxError = std::max(maxError, error);
        }
        return maxError;
    }

    // calculate weighted differences
    Array AbcdCalibration::errors() const {
        Array results(times_.size());
        for (Size i=0; i<times_.size() ; i++) {
            results[i] = (value(times_[i]) - blackVols_[i])* std::sqrt(weights_[i]);
        }
        return results;
    }

    EndCriteria::Type AbcdCalibration::endCriteria() const{
        return abcdEndCriteria_;
    }

}
]]></document_content>
  </document>
  <document index="15">
    <source>volatility/atmadjustedsmilesection.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/atmadjustedsmilesection.hpp>

namespace QuantLib {

    AtmAdjustedSmileSection::AtmAdjustedSmileSection(const ext::shared_ptr<SmileSection>& source,
                                                     const Real atm,
                                                     const bool recenterSmile)
    : SmileSection(*source), source_(source) {

        f_ = atm;
        if (f_ == Null<Real>())
            f_ = source_->atmLevel();
        if (recenterSmile && f_ != Null<Real>() &&
            source_->atmLevel() != Null<Real>())
            adjustment_ = source_->atmLevel() - f_;
        else
            adjustment_ = 0.0;

    }

    Real AtmAdjustedSmileSection::adjustedStrike(Real strike) const {
        return strike + adjustment_;
    }

    Real AtmAdjustedSmileSection::varianceImpl(Rate strike) const {
        return source_->variance(adjustedStrike(strike));
    }

    Real AtmAdjustedSmileSection::volatilityImpl(Rate strike) const {
        return source_->volatility(adjustedStrike(strike));
    }

}
]]></document_content>
  </document>
  <document index="16">
    <source>volatility/atmsmilesection.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/atmsmilesection.hpp>

namespace QuantLib {

    AtmSmileSection::AtmSmileSection(const ext::shared_ptr<SmileSection>& source, const Real atm)
    : SmileSection(*source), source_(source) {

        f_ = atm;
        if (f_ == Null<Real>())
            f_ = source_->atmLevel();
    }

}
]]></document_content>
  </document>
  <document index="17">
    <source>volatility/capfloor/capfloortermvolatilitystructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/capfloor/capfloortermvolatilitystructure.hpp>

namespace QuantLib {

    CapFloorTermVolatilityStructure::CapFloorTermVolatilityStructure(
                                                    BusinessDayConvention bdc,
                                                    const DayCounter& dc)
    : VolatilityTermStructure(bdc, dc) {}

    CapFloorTermVolatilityStructure::CapFloorTermVolatilityStructure(
                                                    const Date& refDate,
                                                    const Calendar& cal,
                                                    BusinessDayConvention bdc,
                                                    const DayCounter& dc)
    : VolatilityTermStructure(refDate, cal, bdc, dc) {}

    CapFloorTermVolatilityStructure::CapFloorTermVolatilityStructure(
                                                    Natural settlementDays,
                                                    const Calendar& cal,
                                                    BusinessDayConvention bdc,
                                                    const DayCounter& dc)
    : VolatilityTermStructure(settlementDays, cal, bdc, dc) {}

}
]]></document_content>
  </document>
  <document index="18">
    <source>volatility/capfloor/capfloortermvolcurve.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Katiuscia Manzoni
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/capfloor/capfloortermvolcurve.hpp>
#include <ql/math/interpolations/cubicinterpolation.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/utilities/dataformatters.hpp>

namespace QuantLib {

    // floating reference date, floating market data
    CapFloorTermVolCurve::CapFloorTermVolCurve(
                        Natural settlementDays,
                        const Calendar& calendar,
                        BusinessDayConvention bdc,
                        const std::vector<Period>& optionTenors,
                        const std::vector<Handle<Quote> >& vols,
                        const DayCounter& dc)
    : CapFloorTermVolatilityStructure(settlementDays, calendar, bdc, dc),
      nOptionTenors_(optionTenors.size()),
      optionTenors_(optionTenors),
      optionDates_(nOptionTenors_),
      optionTimes_(nOptionTenors_),
      volHandles_(vols),
      vols_(vols.size()) // do not initialize with nOptionTenors_
    {
        checkInputs();
        initializeOptionDatesAndTimes();
        registerWithMarketData();
        interpolate();
    }

    // fixed reference date, floating market data
    CapFloorTermVolCurve::CapFloorTermVolCurve(
                            const Date& settlementDate,
                            const Calendar& calendar,
                            BusinessDayConvention bdc,
                            const std::vector<Period>& optionTenors,
                            const std::vector<Handle<Quote> >& vols,
                            const DayCounter& dayCounter)
    : CapFloorTermVolatilityStructure(settlementDate, calendar, bdc, dayCounter),
      nOptionTenors_(optionTenors.size()),
      optionTenors_(optionTenors),
      optionDates_(nOptionTenors_),
      optionTimes_(nOptionTenors_),
      volHandles_(vols),
      vols_(vols.size()) // do not initialize with nOptionTenors_
    {
        checkInputs();
        initializeOptionDatesAndTimes();
        registerWithMarketData();
        interpolate();
    }

    // fixed reference date, fixed market data
    CapFloorTermVolCurve::CapFloorTermVolCurve(
                                const Date& settlementDate,
                                const Calendar& calendar,
                                BusinessDayConvention bdc,
                                const std::vector<Period>& optionTenors,
                                const std::vector<Volatility>& vols,
                                const DayCounter& dayCounter)
    : CapFloorTermVolatilityStructure(settlementDate, calendar, bdc, dayCounter),
      nOptionTenors_(optionTenors.size()),
      optionTenors_(optionTenors),
      optionDates_(nOptionTenors_),
      optionTimes_(nOptionTenors_),
      volHandles_(vols.size()), // do not initialize with nOptionTenors_
      vols_(vols)
    {
        checkInputs();
        initializeOptionDatesAndTimes();
        // fill dummy handles to allow generic handle-based computations later
        for (Size i=0; i<nOptionTenors_; ++i)
            volHandles_[i] = Handle<Quote>(ext::shared_ptr<Quote>(new
                SimpleQuote(vols_[i])));
        interpolate();
    }

    // floating reference date, fixed market data
    CapFloorTermVolCurve::CapFloorTermVolCurve(
                                Natural settlementDays,
                                const Calendar& calendar,
                                BusinessDayConvention bdc,
                                const std::vector<Period>& optionTenors,
                                const std::vector<Volatility>& vols,
                                const DayCounter& dayCounter)
    : CapFloorTermVolatilityStructure(settlementDays, calendar, bdc, dayCounter),
      nOptionTenors_(optionTenors.size()),
      optionTenors_(optionTenors),
      optionDates_(nOptionTenors_),
      optionTimes_(nOptionTenors_),
      volHandles_(vols.size()), // do not initialize with nOptionTenors_
      vols_(vols)
    {
        checkInputs();
        initializeOptionDatesAndTimes();
        // fill dummy handles to allow generic handle-based computations later
        for (Size i=0; i<nOptionTenors_; ++i)
            volHandles_[i] = Handle<Quote>(ext::shared_ptr<Quote>(new
                SimpleQuote(vols_[i])));
        interpolate();
    }

    void CapFloorTermVolCurve::checkInputs() const
    {
        QL_REQUIRE(!optionTenors_.empty(), "empty option tenor vector");
        QL_REQUIRE(nOptionTenors_==vols_.size(),
                   "mismatch between number of option tenors (" <<
                   nOptionTenors_ << ") and number of volatilities (" <<
                   vols_.size() << ")");
        QL_REQUIRE(optionTenors_[0]>0*Days,
                   "negative first option tenor: " << optionTenors_[0]);
        for (Size i=1; i<nOptionTenors_; ++i)
            QL_REQUIRE(optionTenors_[i]>optionTenors_[i-1],
                       "non increasing option tenor: " << io::ordinal(i) <<
                       " is " << optionTenors_[i-1] << ", " <<
                       io::ordinal(i+1) << " is " << optionTenors_[i]);
    }

    void CapFloorTermVolCurve::registerWithMarketData()
    {
        for (auto& volHandle : volHandles_)
            registerWith(volHandle);
    }

    void CapFloorTermVolCurve::interpolate()
    {
        interpolation_ = CubicInterpolation(
                                    optionTimes_.begin(), optionTimes_.end(),
                                    vols_.begin(),
                                    CubicInterpolation::Spline, false,
                                    CubicInterpolation::SecondDerivative, 0.0,
                                    CubicInterpolation::SecondDerivative, 0.0);
    }

    void CapFloorTermVolCurve::update()
    {
        // recalculate dates if necessary...
        if (moving_) {
            Date d = Settings::instance().evaluationDate();
            if (evaluationDate_ != d) {
                evaluationDate_ = d;
                initializeOptionDatesAndTimes();
            }
        }
        CapFloorTermVolatilityStructure::update();
        LazyObject::update();
    }

    void CapFloorTermVolCurve::initializeOptionDatesAndTimes() const
    {
        for (Size i=0; i<nOptionTenors_; ++i) {
            optionDates_[i] = optionDateFromTenor(optionTenors_[i]);
            optionTimes_[i] = timeFromReference(optionDates_[i]);
        }
    }

    void CapFloorTermVolCurve::performCalculations() const
    {
        // check if date recalculation must be called here

        for (Size i=0; i<vols_.size(); ++i)
            vols_[i] = volHandles_[i]->value();

        interpolation_.update();
    }

}
]]></document_content>
  </document>
  <document index="19">
    <source>volatility/capfloor/capfloortermvolsurface.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Katiuscia Manzoni

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/capfloor/capfloortermvolsurface.hpp>
#include <ql/math/interpolations/bicubicsplineinterpolation.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/quotes/simplequote.hpp>

namespace QuantLib {

    // floating reference date, floating market data
    CapFloorTermVolSurface::CapFloorTermVolSurface(
                        Natural settlementDays,
                        const Calendar& calendar,
                        BusinessDayConvention bdc,
                        const std::vector<Period>& optionTenors,
                        const std::vector<Rate>& strikes,
                        const std::vector<std::vector<Handle<Quote> > >& vols,
                        const DayCounter& dc)
    : CapFloorTermVolatilityStructure(settlementDays, calendar, bdc, dc),
      nOptionTenors_(optionTenors.size()),
      optionTenors_(optionTenors),
      optionDates_(nOptionTenors_),
      optionTimes_(nOptionTenors_),
      nStrikes_(strikes.size()),
      strikes_(strikes),
      volHandles_(vols),
      vols_(vols.size(), vols[0].size())
    {
        checkInputs();
        initializeOptionDatesAndTimes();
        for (Size i=0; i<nOptionTenors_; ++i)
            QL_REQUIRE(volHandles_[i].size()==nStrikes_,
                       io::ordinal(i+1) << " row of vol handles has size " <<
                       volHandles_[i].size() << " instead of " << nStrikes_);
        registerWithMarketData();
        for (Size i=0; i<vols_.rows(); ++i)
            for (Size j=0; j<vols_.columns(); ++j)
                vols_[i][j] = volHandles_[i][j]->value();
        interpolate();
    }

    // fixed reference date, floating market data
    CapFloorTermVolSurface::CapFloorTermVolSurface(
                        const Date& settlementDate,
                        const Calendar& calendar,
                        BusinessDayConvention bdc,
                        const std::vector<Period>& optionTenors,
                        const std::vector<Rate>& strikes,
                        const std::vector<std::vector<Handle<Quote> > >& vols,
                        const DayCounter& dc)
    : CapFloorTermVolatilityStructure(settlementDate, calendar, bdc, dc),
      nOptionTenors_(optionTenors.size()),
      optionTenors_(optionTenors),
      optionDates_(nOptionTenors_),
      optionTimes_(nOptionTenors_),
      nStrikes_(strikes.size()),
      strikes_(strikes),
      volHandles_(vols),
      vols_(vols.size(), vols[0].size())
    {
        checkInputs();
        initializeOptionDatesAndTimes();
        for (Size i=0; i<nOptionTenors_; ++i)
            QL_REQUIRE(volHandles_[i].size()==nStrikes_,
                       io::ordinal(i+1) << " row of vol handles has size " <<
                       volHandles_[i].size() << " instead of " << nStrikes_);
        registerWithMarketData();
        for (Size i=0; i<vols_.rows(); ++i)
            for (Size j=0; j<vols_.columns(); ++j)
                vols_[i][j] = volHandles_[i][j]->value();
        interpolate();
    }

    // fixed reference date, fixed market data
    CapFloorTermVolSurface::CapFloorTermVolSurface(
                        const Date& settlementDate,
                        const Calendar& calendar,
                        BusinessDayConvention bdc,
                        const std::vector<Period>& optionTenors,
                        const std::vector<Rate>& strikes,
                        const Matrix& vols,
                        const DayCounter& dc)
    : CapFloorTermVolatilityStructure(settlementDate, calendar, bdc, dc),
      nOptionTenors_(optionTenors.size()),
      optionTenors_(optionTenors),
      optionDates_(nOptionTenors_),
      optionTimes_(nOptionTenors_),
      nStrikes_(strikes.size()),
      strikes_(strikes),
      volHandles_(vols.rows()),
      vols_(vols)
    {
        checkInputs();
        initializeOptionDatesAndTimes();
        // fill dummy handles to allow generic handle-based computations later
        for (Size i=0; i<nOptionTenors_; ++i) {
            volHandles_[i].resize(nStrikes_);
            for (Size j=0; j<nStrikes_; ++j)
                volHandles_[i][j] = Handle<Quote>(ext::shared_ptr<Quote>(new
                    SimpleQuote(vols_[i][j])));
        }
        interpolate();
    }

    // floating reference date, fixed market data
    CapFloorTermVolSurface::CapFloorTermVolSurface(
                        Natural settlementDays,
                        const Calendar& calendar,
                        BusinessDayConvention bdc,
                        const std::vector<Period>& optionTenors,
                        const std::vector<Rate>& strikes,
                        const Matrix& vols,
                        const DayCounter& dc)
    : CapFloorTermVolatilityStructure(settlementDays, calendar, bdc, dc),
      nOptionTenors_(optionTenors.size()),
      optionTenors_(optionTenors),
      optionDates_(nOptionTenors_),
      optionTimes_(nOptionTenors_),
      nStrikes_(strikes.size()),
      strikes_(strikes),
      volHandles_(vols.rows()),
      vols_(vols)
    {
        checkInputs();
        initializeOptionDatesAndTimes();
        // fill dummy handles to allow generic handle-based computations later
        for (Size i=0; i<nOptionTenors_; ++i) {
            volHandles_[i].resize(nStrikes_);
            for (Size j=0; j<nStrikes_; ++j)
                volHandles_[i][j] = Handle<Quote>(ext::shared_ptr<Quote>(new
                    SimpleQuote(vols_[i][j])));
        }
        interpolate();
    }

    void CapFloorTermVolSurface::checkInputs() const {

        QL_REQUIRE(!optionTenors_.empty(), "empty option tenor vector");
        QL_REQUIRE(nOptionTenors_==vols_.rows(),
                   "mismatch between number of option tenors (" <<
                   nOptionTenors_ << ") and number of volatility rows (" <<
                   vols_.rows() << ")");
        QL_REQUIRE(optionTenors_[0]>0*Days,
                   "negative first option tenor: " << optionTenors_[0]);
        for (Size i=1; i<nOptionTenors_; ++i)
            QL_REQUIRE(optionTenors_[i]>optionTenors_[i-1],
                       "non increasing option tenor: " << io::ordinal(i) <<
                       " is " << optionTenors_[i-1] << ", " <<
                       io::ordinal(i+1) << " is " << optionTenors_[i]);

        QL_REQUIRE(nStrikes_==vols_.columns(),
                   "mismatch between strikes(" << strikes_.size() <<
                   ") and vol columns (" << vols_.columns() << ")");
        for (Size j=1; j<nStrikes_; ++j)
            QL_REQUIRE(strikes_[j-1]<strikes_[j],
                       "non increasing strikes: " << io::ordinal(j) <<
                       " is " << io::rate(strikes_[j-1]) << ", " <<
                       io::ordinal(j+1) << " is " << io::rate(strikes_[j]));
    }

    void CapFloorTermVolSurface::registerWithMarketData()
    {
        for (Size i=0; i<nOptionTenors_; ++i)
            for (Size j=0; j<nStrikes_; ++j)
                registerWith(volHandles_[i][j]);
    }

    void CapFloorTermVolSurface::interpolate()
    {
        interpolation_ = BicubicSpline(strikes_.begin(),
                                       strikes_.end(),
                                       optionTimes_.begin(),
                                       optionTimes_.end(),
                                       vols_);
    }

    void CapFloorTermVolSurface::update()
    {
        // recalculate dates if necessary...
        if (moving_) {
            Date d = Settings::instance().evaluationDate();
            if (evaluationDate_ != d) {
                evaluationDate_ = d;
                initializeOptionDatesAndTimes();
            }
        }
        CapFloorTermVolatilityStructure::update();
        LazyObject::update();
    }

    void CapFloorTermVolSurface::initializeOptionDatesAndTimes() const
    {
        for (Size i=0; i<nOptionTenors_; ++i) {
            optionDates_[i] = optionDateFromTenor(optionTenors_[i]);
            optionTimes_[i] = timeFromReference(optionDates_[i]);
        }
    }

    void CapFloorTermVolSurface::performCalculations() const
    {
        // check if date recalculation must be called here

        for (Size i=0; i<nOptionTenors_; ++i)
            for (Size j=0; j<nStrikes_; ++j)
                vols_[i][j] = volHandles_[i][j]->value();

        interpolation_.update();
    }

}
]]></document_content>
  </document>
  <document index="20">
    <source>volatility/capfloor/constantcapfloortermvol.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/capfloor/constantcapfloortermvol.hpp>
#include <utility>

namespace QuantLib {

    // floating reference date, floating market data
    ConstantCapFloorTermVolatility::ConstantCapFloorTermVolatility(Natural settlementDays,
                                                                   const Calendar& cal,
                                                                   BusinessDayConvention bdc,
                                                                   Handle<Quote> vol,
                                                                   const DayCounter& dc)
    : CapFloorTermVolatilityStructure(settlementDays, cal, bdc, dc), volatility_(std::move(vol)) {
        registerWith(volatility_);
    }

    // fixed reference date, floating market data
    ConstantCapFloorTermVolatility::ConstantCapFloorTermVolatility(const Date& referenceDate,
                                                                   const Calendar& cal,
                                                                   BusinessDayConvention bdc,
                                                                   Handle<Quote> vol,
                                                                   const DayCounter& dc)
    : CapFloorTermVolatilityStructure(referenceDate, cal, bdc, dc), volatility_(std::move(vol)) {
        registerWith(volatility_);
    }

    // floating reference date, fixed market data
    ConstantCapFloorTermVolatility::ConstantCapFloorTermVolatility(
                                                    Natural settlementDays,
                                                    const Calendar& cal,
                                                    BusinessDayConvention bdc,
                                                    Volatility vol,
                                                    const DayCounter& dc)
    : CapFloorTermVolatilityStructure(settlementDays, cal, bdc, dc),
      volatility_(ext::shared_ptr<Quote>(new SimpleQuote(vol))) {}

    // fixed reference date, fixed market data
    ConstantCapFloorTermVolatility::ConstantCapFloorTermVolatility(
                                                    const Date& referenceDate,
                                                    const Calendar& cal,
                                                    BusinessDayConvention bdc,
                                                    Volatility vol,
                                                    const DayCounter& dc)
    : CapFloorTermVolatilityStructure(referenceDate, cal, bdc, dc),
      volatility_(ext::shared_ptr<Quote>(new SimpleQuote(vol))) {}

    Volatility ConstantCapFloorTermVolatility::volatilityImpl(Time,
                                                              Rate) const {
        return volatility_->value();
    }

}
]]></document_content>
  </document>
  <document index="21">
    <source>volatility/equityfx/andreasenhugelocalvoladapter.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2017, 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/equityfx/andreasenhugelocalvoladapter.hpp>
#include <ql/termstructures/volatility/equityfx/andreasenhugevolatilityinterpl.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {


    AndreasenHugeLocalVolAdapter::AndreasenHugeLocalVolAdapter(
        ext::shared_ptr<AndreasenHugeVolatilityInterpl> localVol)
    : localVol_(std::move(localVol)) {}

    Date AndreasenHugeLocalVolAdapter::maxDate() const {
        return localVol_->maxDate();
    }

    Real AndreasenHugeLocalVolAdapter::minStrike() const {
        return 0.0;
    }

    Real AndreasenHugeLocalVolAdapter::maxStrike() const {
        return QL_MAX_REAL;
    }

    Volatility
    AndreasenHugeLocalVolAdapter::localVolImpl(Time t, Real strike) const {
        return localVol_->localVol(t,
            std::min(localVol_->maxStrike(),
                std::max(localVol_->minStrike(), strike)));
    }

    Calendar AndreasenHugeLocalVolAdapter::calendar() const {
        return localVol_->riskFreeRate()->calendar();
    }
    DayCounter AndreasenHugeLocalVolAdapter::dayCounter() const {
        return localVol_->riskFreeRate()->dayCounter();
    }
    const Date& AndreasenHugeLocalVolAdapter::referenceDate() const {
        return localVol_->riskFreeRate()->referenceDate();
    }
    Natural AndreasenHugeLocalVolAdapter::settlementDays() const {
        return localVol_->riskFreeRate()->settlementDays();
    }
}
]]></document_content>
  </document>
  <document index="22">
    <source>volatility/equityfx/andreasenhugevolatilityadapter.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2017 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/functional.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/termstructures/volatility/equityfx/andreasenhugevolatilityadapter.hpp>
#include <ql/termstructures/volatility/equityfx/andreasenhugevolatilityinterpl.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    AndreasenHugeVolatilityAdapter::AndreasenHugeVolatilityAdapter(
        ext::shared_ptr<AndreasenHugeVolatilityInterpl> volInterpl, Real eps)
    : eps_(eps), volInterpl_(std::move(volInterpl)) {}

    Real AndreasenHugeVolatilityAdapter::blackVarianceImpl(Time t, Real strike)
    const {
        const Real fwd = volInterpl_->fwd(t);
        const Option::Type optionType =
            (fwd > strike)? Option::Put : Option::Call;

        const Real npv = volInterpl_->optionPrice(t, strike, optionType);

        return squared(blackFormulaImpliedStdDevLiRS(
            optionType, strike, fwd, npv,
            volInterpl_->riskFreeRate()->discount(t),
            0.0, Null<Real>(), 1.0, eps_, 1000));
    }


    Date AndreasenHugeVolatilityAdapter::maxDate() const {
        return volInterpl_->maxDate();
    }
    Real AndreasenHugeVolatilityAdapter::minStrike() const {
        return volInterpl_->minStrike();
    }
    Real AndreasenHugeVolatilityAdapter::maxStrike() const {
        return volInterpl_->maxStrike();
    }
    Calendar AndreasenHugeVolatilityAdapter::calendar() const {
        return volInterpl_->riskFreeRate()->calendar();
    }
    DayCounter AndreasenHugeVolatilityAdapter::dayCounter() const {
        return volInterpl_->riskFreeRate()->dayCounter();
    }
    const Date& AndreasenHugeVolatilityAdapter::referenceDate() const {
        return volInterpl_->riskFreeRate()->referenceDate();
    }
    Natural AndreasenHugeVolatilityAdapter::settlementDays() const {
        return volInterpl_->riskFreeRate()->settlementDays();
    }
}
]]></document_content>
  </document>
  <document index="23">
    <source>volatility/equityfx/andreasenhugevolatilityinterpl.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2017, 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/math/array.hpp>
#include <ql/math/comparison.hpp>
#include <ql/math/interpolations/backwardflatinterpolation.hpp>
#include <ql/math/interpolations/cubicinterpolation.hpp>
#include <ql/methods/finitedifferences/meshers/concentrating1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>
#include <ql/methods/finitedifferences/tridiagonaloperator.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/termstructures/volatility/equityfx/andreasenhugevolatilityinterpl.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/timegrid.hpp>
#include <ql/utilities/null.hpp>
#include <cmath>
#include <limits>
#include <utility>

namespace QuantLib {

    namespace {

        struct close_enough_to {
            Real y;
            Size n;
            explicit close_enough_to(Real y, Size n=42) : y(y), n(n) {}
            bool operator()(Real x) const { return close_enough(x, y, n); }
        };

    }

    class AndreasenHugeCostFunction : public CostFunction {
      public:
        AndreasenHugeCostFunction(
            Array marketNPVs,
            Array marketVegas,
            Array lnMarketStrikes,
            Array previousNPVs,
            const ext::shared_ptr<FdmMesherComposite>& mesher,
            Time dT,
            AndreasenHugeVolatilityInterpl::InterpolationType interpolationType)
        : marketNPVs_(std::move(marketNPVs)), marketVegas_(std::move(marketVegas)),
          lnMarketStrikes_(std::move(lnMarketStrikes)), previousNPVs_(std::move(previousNPVs)),
          mesher_(mesher), nGridPoints_(mesher->layout()->size()), dT_(dT),
          interpolationType_((lnMarketStrikes_.size() > 1) ?
                                 interpolationType :
                                 AndreasenHugeVolatilityInterpl::PiecewiseConstant),
          dxMap_(FirstDerivativeOp(0, mesher_)), dxxMap_(SecondDerivativeOp(0, mesher_)),
          d2CdK2_(dxMap_.mult(Array(mesher->layout()->size(), -1.0)).add(dxxMap_)),
          mapT_(0, mesher_) {}

        Array d2CdK2(const Array& c) const {
            return d2CdK2_.apply(c);
        }

        Array solveFor(Time dT, const Array& sig, const Array& b) const {

            Array x(lnMarketStrikes_.size());
            Interpolation sigInterpl;

            switch (interpolationType_) {
              case AndreasenHugeVolatilityInterpl::CubicSpline:
                sigInterpl = CubicNaturalSpline(
                    lnMarketStrikes_.begin(), lnMarketStrikes_.end(),
                    sig.begin());
                break;
              case AndreasenHugeVolatilityInterpl::Linear:
                sigInterpl = LinearInterpolation(
                    lnMarketStrikes_.begin(), lnMarketStrikes_.end(),
                    sig.begin());
                break;
              case AndreasenHugeVolatilityInterpl::PiecewiseConstant:
                for (Size i=0; i < x.size()-1; ++i)
                    x[i] = 0.5*(lnMarketStrikes_[i] + lnMarketStrikes_[i+1]);
                x.back() = lnMarketStrikes_.back();

                sigInterpl = BackwardFlatInterpolation(
                    x.begin(), x.end(), sig.begin());
                break;
              default:
                QL_FAIL("unknown interpolation type");
            }

            Array z(mesher_->layout()->size());
            for (const auto& iter : *mesher_->layout()) {
                const Size i = iter.index();
                const Real lnStrike = mesher_->location(iter, 0);

                const Real vol = sigInterpl(
                    std::min(std::max(lnStrike, lnMarketStrikes_.front()),
                            lnMarketStrikes_.back()), true);

                z[i] = 0.5*vol*vol;
            }

            mapT_.axpyb(z, dxMap_, dxxMap_.mult(-z), Array());
            return mapT_.mult(Array(z.size(), dT)).solve_splitting(b, 1.0);

        }

        Array apply(const Array& c) const {
            return -mapT_.apply(c);
        }

        Array values(const Array& sig) const override {
            Array newNPVs = solveFor(dT_, sig, previousNPVs_);

            const std::vector<Real>& gridPoints =
                mesher_->getFdm1dMeshers().front()->locations();

            const MonotonicCubicNaturalSpline interpl(
                gridPoints.begin(), gridPoints.end(), newNPVs.begin());

            Array retVal(lnMarketStrikes_.size());
            for (Size i=0; i < retVal.size(); ++i) {
                const Real strike = lnMarketStrikes_[i];
                retVal[i] = interpl(strike) - marketNPVs_[i];
            }
            return retVal;
        }

        Array vegaCalibrationError(const Array& sig) const {
            return values(sig)/marketVegas_;
        }

        Array initialValues() const {
            return Array(lnMarketStrikes_.size(), 0.25);
        }


      private:
        const Array marketNPVs_, marketVegas_;
        const Array lnMarketStrikes_, previousNPVs_;
        const ext::shared_ptr<FdmMesherComposite> mesher_;
        const Size nGridPoints_;
        const Time dT_;
        const AndreasenHugeVolatilityInterpl::InterpolationType
            interpolationType_;

        const FirstDerivativeOp  dxMap_;
        const TripleBandLinearOp dxxMap_;
        const TripleBandLinearOp d2CdK2_;
        mutable TripleBandLinearOp mapT_;
    };

    class CombinedCostFunction : public CostFunction {
      public:
        CombinedCostFunction(ext::shared_ptr<AndreasenHugeCostFunction> putCostFct,
                             ext::shared_ptr<AndreasenHugeCostFunction> callCostFct)
        : putCostFct_(std::move(putCostFct)), callCostFct_(std::move(callCostFct)) {}

        Array values(const Array& sig) const override {
            if ((putCostFct_ != nullptr) && (callCostFct_ != nullptr)) {
                const Array pv = putCostFct_->values(sig);
                const Array cv = callCostFct_->values(sig);

                Array retVal(pv.size() + cv.size());
                std::copy(pv.begin(), pv.end(), retVal.begin());
                std::copy(cv.begin(), cv.end(), retVal.begin() + cv.size());

                return retVal;
            } else if (putCostFct_ != nullptr)
                return putCostFct_->values(sig);
            else if (callCostFct_ != nullptr)
                return callCostFct_->values(sig);
            else
                QL_FAIL("internal error: cost function not set");
        }

        Array initialValues() const {
            if ((putCostFct_ != nullptr) && (callCostFct_ != nullptr))
                return 0.5*(  putCostFct_->initialValues()
                            + callCostFct_->initialValues());
            else if (putCostFct_ != nullptr)
                return putCostFct_->initialValues();
            else if (callCostFct_ != nullptr)
                return callCostFct_->initialValues();
            else
                QL_FAIL("internal error: cost function not set");
        }

      private:
        const ext::shared_ptr<AndreasenHugeCostFunction> putCostFct_;
        const ext::shared_ptr<AndreasenHugeCostFunction> callCostFct_;
    };


    AndreasenHugeVolatilityInterpl::AndreasenHugeVolatilityInterpl(
        const CalibrationSet& calibrationSet,
        Handle<Quote> spot,
        Handle<YieldTermStructure> rTS,
        Handle<YieldTermStructure> qTS,
        InterpolationType interplationType,
        CalibrationType calibrationType,
        Size nGridPoints,
        Real _minStrike,
        Real _maxStrike,
        ext::shared_ptr<OptimizationMethod> optimizationMethod,
        const EndCriteria& endCriteria)
    : spot_(std::move(spot)), rTS_(std::move(rTS)), qTS_(std::move(qTS)),
      interpolationType_(interplationType), calibrationType_(calibrationType),
      nGridPoints_(nGridPoints), minStrike_(_minStrike), maxStrike_(_maxStrike),
      optimizationMethod_(std::move(optimizationMethod)), endCriteria_(endCriteria) {
        QL_REQUIRE(nGridPoints > 2 && !calibrationSet.empty(), "undefined grid or calibration set");

        std::set<Real> strikes;
        std::set<Date> expiries;

        calibrationSet_.reserve(calibrationSet.size());
        for (const auto& i : calibrationSet) {

            const ext::shared_ptr<Exercise> exercise = i.first->exercise();

            QL_REQUIRE(exercise->type() == Exercise::European,
                    "European option required");

            const Date expiry = exercise->lastDate();
            expiries.insert(expiry);

            const ext::shared_ptr<PlainVanillaPayoff> payoff =
                ext::dynamic_pointer_cast<PlainVanillaPayoff>(i.first->payoff());

            QL_REQUIRE(payoff, "plain vanilla payoff required");

            const Real strike = payoff->strike();
            strikes.insert(strike);

            calibrationSet_.emplace_back(ext::make_shared<VanillaOption>(payoff, exercise), i.second);

            registerWith(i.second);
        }

        strikes_.assign(strikes.begin(), strikes.end());
        expiries_.assign(expiries.begin(), expiries.end());

        dT_.resize(expiries_.size());
        expiryTimes_.resize(expiries_.size());

        calibrationMatrix_ = std::vector< std::vector<Size> >(
            expiries.size(), std::vector<Size>(strikes.size(), Null<Size>()));

        for (Size i=0; i < calibrationSet.size(); ++i) {
            const Date expiry =
                calibrationSet[i].first->exercise()->lastDate();

            const Size l = std::distance(expiries.begin(), expiries.lower_bound(expiry));

            const Real strike =
                ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                    calibrationSet[i].first->payoff())->strike();

            const Size k = std::distance(strikes_.begin(),
                std::find_if(strikes_.begin(), strikes_.end(),
                             close_enough_to(strike)));

            calibrationMatrix_[l][k] = i;
        }

        registerWith(spot_);
        registerWith(rTS_);
        registerWith(qTS_);
    }

    ext::shared_ptr<AndreasenHugeCostFunction>
        AndreasenHugeVolatilityInterpl::buildCostFunction(
        Size iExpiry, Option::Type optionType,
        const Array& previousNPVs) const {

        if (calibrationType_ != CallPut
            && (   (calibrationType_ == Call && optionType ==Option::Put)
                || (calibrationType_ == Put  && optionType ==Option::Call)))
            return ext::shared_ptr<AndreasenHugeCostFunction>();

        const Time expiryTime = expiryTimes_[iExpiry];

        const DiscountFactor discount = rTS_->discount(expiryTime);
        const Real fwd = spot_->value()*qTS_->discount(expiryTime)/discount;

        Size null = Null<Size>();
        const Size nOptions = std::count_if(
            calibrationMatrix_[iExpiry].begin(),
            calibrationMatrix_[iExpiry].end(),
            [=](Size n){ return n != null; });

        Array lnMarketStrikes(nOptions),
            marketNPVs(nOptions), marketVegas(nOptions);

        // calculate undiscounted market prices
        for (Size j=0, k=0; j < strikes_.size(); ++j) {
            const Size idx = calibrationMatrix_[iExpiry][j];

            if (idx != null) {

                const Volatility vol = calibrationSet_[idx].second->value();
                const Real stdDev = vol*std::sqrt(expiryTime);

                const BlackCalculator calculator(
                    optionType, strikes_[j], fwd, stdDev, discount);

                const Real npv = calculator.value();
                const Real vega = calculator.vega(expiryTime);

                marketNPVs[k] = npv/(discount*fwd);
                marketVegas[k] = vega/(discount*fwd);
                lnMarketStrikes[k++] = std::log(strikes_[j]/fwd);
            }
        }

        return ext::make_shared<AndreasenHugeCostFunction>(
            marketNPVs,
            marketVegas,
            lnMarketStrikes,
            previousNPVs,
            mesher_,
            dT_[iExpiry],
            interpolationType_);
    }


    void AndreasenHugeVolatilityInterpl::performCalculations() const {
        QL_REQUIRE(maxStrike() > minStrike(),
            "max strike must be greater than min strike");

        const DayCounter dc = rTS_->dayCounter();
        for (Size i=0; i < expiryTimes_.size(); ++i) {
            expiryTimes_[i] =
                dc.yearFraction(rTS_->referenceDate(), expiries_[i]);
            dT_[i] = expiryTimes_[i] - ( (i==0)? 0.0 : expiryTimes_[i-1]);
        }

        mesher_ =
            ext::make_shared<FdmMesherComposite>(
                ext::make_shared<Concentrating1dMesher>(
                    std::log(minStrike()/spot_->value()),
                    std::log(maxStrike()/spot_->value()),
                    nGridPoints_,
                    std::pair<Real, Real>(0.0, 0.025)));

        gridPoints_ = mesher_->locations(0);
        gridInFwd_ = Exp(gridPoints_)*spot_->value();

        localVolCache_.clear();
        calibrationResults_.clear();

        avgError_ = 0.0;
        minError_ = std::numeric_limits<Real>::max();
        maxError_ = 0.0;

        calibrationResults_.reserve(expiries_.size());

        Array npvPuts(nGridPoints_);
        Array npvCalls(nGridPoints_);

        for (Size i=0; i < nGridPoints_; ++i) {
            const Real strike = std::exp(gridPoints_[i]);
            npvPuts[i] = PlainVanillaPayoff(Option::Put, strike)(1.0);
            npvCalls[i]= PlainVanillaPayoff(Option::Call, strike)(1.0);
        }

        for (Size i=0; i < expiries_.size(); ++i) {
            const ext::shared_ptr<AndreasenHugeCostFunction> putCostFct =
                buildCostFunction(i, Option::Put, npvPuts);
            const ext::shared_ptr<AndreasenHugeCostFunction> callCostFct =
                buildCostFunction(i, Option::Call, npvCalls);

            CombinedCostFunction costFunction(putCostFct, callCostFct);

            PositiveConstraint positiveConstraint;
            Problem problem(costFunction,
                positiveConstraint, costFunction.initialValues());

            optimizationMethod_->minimize(problem, endCriteria_);

            const Array& sig = problem.currentValue();

            const SingleStepCalibrationResult calibrationResult = {
                npvPuts, npvCalls, sig,
                (calibrationType_ == Call)? callCostFct : putCostFct
            };

            calibrationResults_.push_back(calibrationResult);

            Array vegaDiffs(sig.size());
            switch (calibrationType_) {
              case CallPut: {
                const Array vegaPutDiffs =
                    putCostFct->vegaCalibrationError(sig);
                const Array vegaCallDiffs =
                    callCostFct->vegaCalibrationError(sig);

                const Real fwd = spot_->value()*
                    qTS_->discount(expiryTimes_[i])/rTS_->discount(expiryTimes_[i]);

                for (Size j=0; j < vegaDiffs.size(); ++j)
                    vegaDiffs[j] = std::fabs(
                        (fwd > gridInFwd_[j])? vegaPutDiffs[j] : vegaCallDiffs[j]);
              }
              break;
              case Put:
                vegaDiffs = Abs(putCostFct->vegaCalibrationError(sig));
              break;
              case Call:
                vegaDiffs = Abs(callCostFct->vegaCalibrationError(sig));
              break;
              default:
                QL_FAIL("unknown calibration type");
            }

            avgError_ +=
                std::accumulate(vegaDiffs.begin(), vegaDiffs.end(), Real(0.0));
            minError_ = std::min(minError_,
                *std::min_element(vegaDiffs.begin(), vegaDiffs.end()));
            maxError_ = std::max(maxError_,
                *std::max_element(vegaDiffs.begin(), vegaDiffs.end()));

            if (putCostFct != nullptr)
                npvPuts = putCostFct->solveFor(dT_[i], sig, npvPuts);
            if (callCostFct != nullptr)
                npvCalls= callCostFct->solveFor(dT_[i], sig, npvCalls);
        }

        avgError_ /= calibrationSet_.size();
    }

    Date AndreasenHugeVolatilityInterpl::maxDate() const {
        return expiries_.back();
    }

    Real AndreasenHugeVolatilityInterpl::minStrike() const {
        return (minStrike_ == Null<Real>())
            ? 1/8.0*strikes_.front() : minStrike_;
    }

    Real AndreasenHugeVolatilityInterpl::maxStrike() const {
        return (maxStrike_ == Null<Real>())
            ? 8.0*strikes_.back() : maxStrike_;
    }

    Real AndreasenHugeVolatilityInterpl::fwd(Time t) const {
        return spot_->value()*qTS_->discount(t)/rTS_->discount(t);
    }

    const Handle<YieldTermStructure>&
    AndreasenHugeVolatilityInterpl::riskFreeRate() const {
        return rTS_;
    }

    std::tuple<Real, Real, Real>
    AndreasenHugeVolatilityInterpl::calibrationError() const {
        calculate();

        return std::make_tuple(minError_, maxError_, avgError_);
    }

    Size AndreasenHugeVolatilityInterpl::getExerciseTimeIdx(Time t) const {
        return std::min<Size>(expiryTimes_.size()-1,
            std::distance(expiryTimes_.begin(),
                std::upper_bound(
                    expiryTimes_.begin(), expiryTimes_.end(), t)));
    }

    Real AndreasenHugeVolatilityInterpl::getCacheValue(
        Real strike, const TimeValueCacheType::const_iterator& f) const {

        const Real fwd = std::get<0>(f->second);
        const Real k = std::log(strike / fwd);

        const Real s = std::max(gridPoints_[1],
            std::min(*(gridPoints_.end()-2), k));

        return (*(std::get<2>(f->second)))(s);
    }

    Array AndreasenHugeVolatilityInterpl::getPriceSlice(
        Time t, Option::Type optionType) const {

        const Size iu = getExerciseTimeIdx(t);

        return calibrationResults_[iu].costFunction->solveFor(
            (iu == 0) ? t : t-expiryTimes_[iu-1],
            calibrationResults_[iu].sigmas,
            (optionType == Option::Call)? calibrationResults_[iu].callNPVs
                                        : calibrationResults_[iu].putNPVs);
    }

    Real AndreasenHugeVolatilityInterpl::optionPrice(
        Time t, Real strike, Option::Type optionType) const {

        auto f = priceCache_.find(t);

        const DiscountFactor df = rTS_->discount(t);

        if (f != priceCache_.end()) {
            const Real fwd = std::get<0>(f->second);

            Real price = getCacheValue(strike, f);

            if (optionType == Option::Put
                && (calibrationType_ == Call || calibrationType_ == CallPut))
                price = price + strike/fwd - 1.0;
            else if (optionType == Option::Call && calibrationType_ == Put)
                price = 1.0 - strike/fwd + price;

            return price*df*fwd;
        }

        calculate();


        ext::shared_ptr<Array> prices(
            ext::make_shared<Array>(gridPoints_));

        switch (calibrationType_) {
          case Put:
            (*prices) = getPriceSlice(t, Option::Put);
          break;
          case Call:
          case CallPut:
            (*prices) = getPriceSlice(t, Option::Call);
          break;
          default:
            QL_FAIL("unknown calibration type");
        }

        Real fwd = spot_->value()*qTS_->discount(t)/df;

        priceCache_[t] = std::make_tuple(
                fwd, prices,
                ext::make_shared<CubicNaturalSpline>(
                    gridPoints_.begin()+1, gridPoints_.end()-1,
                    prices->begin()+1));

        return this->optionPrice(t, strike, optionType);
    }

    Array AndreasenHugeVolatilityInterpl::getLocalVolSlice(
        Time t, Option::Type optionType) const {

        const Size iu = getExerciseTimeIdx(t);

        const Array& previousNPVs =
            (optionType == Option::Call)? calibrationResults_[iu].callNPVs
                                        : calibrationResults_[iu].putNPVs;

        const ext::shared_ptr<AndreasenHugeCostFunction> costFunction
            = calibrationResults_[iu].costFunction;

        const Time dt = (iu == 0) ? t : t-expiryTimes_[iu-1];
        const Array& sig = calibrationResults_[iu].sigmas;

        const Array cAtJ = costFunction->solveFor(dt, sig, previousNPVs);

        const Array dCdT =
            costFunction->solveFor(dt, sig,
                    costFunction->apply(
                        costFunction->solveFor(dt, sig, previousNPVs)));

        const Array d2CdK2 = costFunction->d2CdK2(cAtJ);

        Array localVol = Sqrt(2*dCdT/d2CdK2);

        for (Size i=1; i < localVol.size()-1; ++i)
            if (!std::isfinite(localVol[i]) || localVol[i] < 0.0)
                localVol[i] = 0.25;

        return localVol;
    }

    Volatility AndreasenHugeVolatilityInterpl::localVol(Time t, Real strike)
    const {
        auto f = localVolCache_.find(t);

        if (f != localVolCache_.end())
            return getCacheValue(strike, f);

        calculate();

        ext::shared_ptr<Array> localVol(
            ext::make_shared<Array>(gridPoints_.size()));

        switch (calibrationType_) {
          case CallPut: {
            const Array putLocalVol = getLocalVolSlice(t, Option::Put);
            const Array callLocalVol = getLocalVolSlice(t, Option::Call);

            for (Size i=0, n=localVol->size(); i < n; ++i)
                (*localVol)[i] =
                    (gridPoints_[i] > 0.0)? callLocalVol[i] : putLocalVol[i];
          }
          break;
          case Put:
            (*localVol) = getLocalVolSlice(t, Option::Put);
          break;
          case Call:
            (*localVol) = getLocalVolSlice(t, Option::Call);
          break;
          default:
            QL_FAIL("unknown calibration type");
        }

        Real fwd = spot_->value()*qTS_->discount(t)/rTS_->discount(t);

        localVolCache_[t] = std::make_tuple(
                fwd, localVol,
                ext::make_shared<LinearInterpolation>(
                    gridPoints_.begin()+1, gridPoints_.end()-1,
                    localVol->begin()+1));

        return this->localVol(t, strike);
    }
}
]]></document_content>
  </document>
  <document index="24">
    <source>volatility/equityfx/blackvariancecurve.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2003 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/termstructures/volatility/equityfx/blackvariancecurve.hpp>
#include <utility>

namespace QuantLib {

    BlackVarianceCurve::BlackVarianceCurve(const Date& referenceDate,
                                           const std::vector<Date>& dates,
                                           const std::vector<Volatility>& blackVolCurve,
                                           DayCounter dayCounter,
                                           bool forceMonotoneVariance)
    : BlackVarianceTermStructure(referenceDate), dayCounter_(std::move(dayCounter)),
      maxDate_(dates.back()) {

        QL_REQUIRE(dates.size()==blackVolCurve.size(),
                   "mismatch between date vector and black vol vector");

        // cannot have dates[0]==referenceDate, since the
        // value of the vol at dates[0] would be lost
        // (variance at referenceDate must be zero)
        QL_REQUIRE(dates[0]>referenceDate,
                   "cannot have dates[0] <= referenceDate");

        variances_ = std::vector<Real>(dates.size()+1);
        times_ = std::vector<Time>(dates.size()+1);
        variances_[0] = 0.0;
        times_[0] = 0.0;
        Size j;
        for (j=1; j<=blackVolCurve.size(); j++) {
            times_[j] = timeFromReference(dates[j-1]);
            QL_REQUIRE(times_[j]>times_[j-1],
                       "dates must be sorted unique!");
            variances_[j] = times_[j] *
                blackVolCurve[j-1]*blackVolCurve[j-1];
            QL_REQUIRE(variances_[j]>=variances_[j-1]
                       || !forceMonotoneVariance,
                       "variance must be non-decreasing");
        }

        // default: linear interpolation
        setInterpolation<Linear>();
    }

    Real BlackVarianceCurve::blackVarianceImpl(Time t, Real) const {
        if (t<=times_.back()) {
            return varianceCurve_(t, true);
        } else {
            // extrapolate with flat vol
            return varianceCurve_(times_.back(), true)*t/times_.back();
        }
    }

}

]]></document_content>
  </document>
  <document index="25">
    <source>volatility/equityfx/blackvariancesurface.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2003, 2004 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/interpolations/bilinearinterpolation.hpp>
#include <ql/termstructures/volatility/equityfx/blackvariancesurface.hpp>
#include <utility>

namespace QuantLib {

    BlackVarianceSurface::BlackVarianceSurface(const Date& referenceDate,
                                               const Calendar& cal,
                                               const std::vector<Date>& dates,
                                               std::vector<Real> strikes,
                                               const Matrix& blackVolMatrix,
                                               DayCounter dayCounter,
                                               BlackVarianceSurface::Extrapolation lowerEx,
                                               BlackVarianceSurface::Extrapolation upperEx)
    : BlackVarianceTermStructure(referenceDate, cal), dayCounter_(std::move(dayCounter)),
      maxDate_(dates.back()), strikes_(std::move(strikes)), lowerExtrapolation_(lowerEx),
      upperExtrapolation_(upperEx) {

        QL_REQUIRE(dates.size()==blackVolMatrix.columns(),
                   "mismatch between date vector and vol matrix colums");
        QL_REQUIRE(strikes_.size()==blackVolMatrix.rows(),
                   "mismatch between money-strike vector and vol matrix rows");

        QL_REQUIRE(dates[0]>=referenceDate,
                   "cannot have dates[0] < referenceDate");

        Size j, i;
        times_ = std::vector<Time>(dates.size()+1);
        times_[0] = 0.0;
        variances_ = Matrix(strikes_.size(), dates.size()+1);
        for (i=0; i<blackVolMatrix.rows(); i++) {
            variances_[i][0] = 0.0;
        }
        for (j=1; j<=blackVolMatrix.columns(); j++) {
            times_[j] = timeFromReference(dates[j-1]);
            QL_REQUIRE(times_[j]>times_[j-1],
                       "dates must be sorted unique!");
            for (i=0; i<blackVolMatrix.rows(); i++) {
                variances_[i][j] = times_[j] *
                    blackVolMatrix[i][j-1]*blackVolMatrix[i][j-1];
            }
        }
        // default: bilinear interpolation
        setInterpolation<Bilinear>();
    }

    Real BlackVarianceSurface::blackVarianceImpl(Time t, Real strike) const {

        if (t==0.0) return 0.0;

        // enforce constant extrapolation when required
        if (strike < strikes_.front()
            && lowerExtrapolation_ == ConstantExtrapolation)
            strike = strikes_.front();
        if (strike > strikes_.back()
            && upperExtrapolation_ == ConstantExtrapolation)
            strike = strikes_.back();

        if (t<=times_.back())
            return varianceSurface_(t, strike, true);
        else // t>times_.back() || extrapolate
            return varianceSurface_(times_.back(), strike, true) *
                t/times_.back();
    }

}

]]></document_content>
  </document>
  <document index="26">
    <source>volatility/equityfx/blackvoltermstructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/equityfx/blackvoltermstructure.hpp>

namespace QuantLib {

    BlackVolTermStructure::BlackVolTermStructure(BusinessDayConvention bdc,
                                                 const DayCounter& dc)
    : VolatilityTermStructure(bdc, dc) {}

    BlackVolTermStructure::BlackVolTermStructure(const Date& refDate,
                                                 const Calendar& cal,
                                                 BusinessDayConvention bdc,
                                                 const DayCounter& dc)
    : VolatilityTermStructure(refDate, cal, bdc, dc) {}

    BlackVolTermStructure::BlackVolTermStructure(Natural settlDays,
                                                 const Calendar& cal,
                                                 BusinessDayConvention bdc,
                                                 const DayCounter& dc)
    : VolatilityTermStructure(settlDays, cal, bdc, dc) {}

    Volatility BlackVolTermStructure::blackForwardVol(const Date& date1,
                                                      const Date& date2,
                                                      Real strike,
                                                      bool extrapolate) const {
        // (redundant) date-based checks
        QL_REQUIRE(date1 <= date2,
                   date1 << " later than " << date2);
        checkRange(date2, extrapolate);

        // using the time implementation
        Time time1 = timeFromReference(date1);
        Time time2 = timeFromReference(date2);
        return blackForwardVol(time1, time2, strike, extrapolate);
    }

    Volatility BlackVolTermStructure::blackForwardVol(Time time1,
                                                      Time time2,
                                                      Real strike,
                                                      bool extrapolate) const {
        QL_REQUIRE(time1 <= time2,
                   time1 << " later than " << time2);
        checkRange(time2, extrapolate);
        checkStrike(strike, extrapolate);
        if (time2==time1) {
            if (time1==0.0) {
                Time epsilon = 1.0e-5;
                Real var = blackVarianceImpl(epsilon, strike);
                return std::sqrt(var/epsilon);
            } else {
                Time epsilon = std::min<Time>(1.0e-5, time1);
                Real var1 = blackVarianceImpl(time1-epsilon, strike);
                Real var2 = blackVarianceImpl(time1+epsilon, strike);
                QL_ENSURE(var2>=var1,
                          "variances must be non-decreasing");
                return std::sqrt((var2-var1)/(2*epsilon));
            }
        } else {
            Real var1 = blackVarianceImpl(time1, strike);
            Real var2 = blackVarianceImpl(time2, strike);
            QL_ENSURE(var2 >= var1,
                      "variances must be non-decreasing");
            return std::sqrt((var2-var1)/(time2-time1));
        }
    }

    Real BlackVolTermStructure::blackForwardVariance(const Date& date1,
                                                     const Date& date2,
                                                     Real strike,
                                                     bool extrapolate)
                                                                      const {
        // (redundant) date-based checks
        QL_REQUIRE(date1 <= date2,
                   date1 << " later than " << date2);
        checkRange(date2, extrapolate);

        // using the time implementation
        Time time1 = timeFromReference(date1);
        Time time2 = timeFromReference(date2);
        return blackForwardVariance(time1, time2, strike, extrapolate);
    }

    Real BlackVolTermStructure::blackForwardVariance(Time time1,
                                                     Time time2,
                                                     Real strike,
                                                     bool extrapolate) const {
        QL_REQUIRE(time1 <= time2,
                   time1 << " later than " << time2);
        checkRange(time2, extrapolate);
        checkStrike(strike, extrapolate);
        Real v1 = blackVarianceImpl(time1, strike);
        Real v2 = blackVarianceImpl(time2, strike);
        QL_ENSURE(v2 >= v1,
                  "variances must be non-decreasing");
        return v2-v1;
    }

    BlackVolatilityTermStructure::BlackVolatilityTermStructure(
                                                    BusinessDayConvention bdc,
                                                    const DayCounter& dc)
    : BlackVolTermStructure(bdc, dc) {}

    BlackVolatilityTermStructure::BlackVolatilityTermStructure(
                                                    const Date& refDate,
                                                    const Calendar& cal,
                                                    BusinessDayConvention bdc,
                                                    const DayCounter& dc)
    : BlackVolTermStructure(refDate, cal, bdc, dc) {}

    BlackVolatilityTermStructure::BlackVolatilityTermStructure(
                                                    Natural settlementDays,
                                                    const Calendar& cal,
                                                    BusinessDayConvention bdc,
                                                    const DayCounter& dc)
    : BlackVolTermStructure(settlementDays, cal, bdc, dc) {}

    BlackVarianceTermStructure::BlackVarianceTermStructure(
                                                    BusinessDayConvention bdc,
                                                    const DayCounter& dc)
    : BlackVolTermStructure(bdc, dc) {}

    BlackVarianceTermStructure::BlackVarianceTermStructure(
                                                    const Date& refDate,
                                                    const Calendar& cal,
                                                    BusinessDayConvention bdc,
                                                    const DayCounter& dc)
    : BlackVolTermStructure(refDate, cal, bdc, dc) {}

    BlackVarianceTermStructure::BlackVarianceTermStructure(
                                                    Natural settlementDays,
                                                    const Calendar& cal,
                                                    BusinessDayConvention bdc,
                                                    const DayCounter& dc)
    : BlackVolTermStructure(settlementDays, cal, bdc, dc) {}

}
]]></document_content>
  </document>
  <document index="27">
    <source>volatility/equityfx/fixedlocalvolsurface.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes Gttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/termstructures/volatility/equityfx/fixedlocalvolsurface.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/daycounters/yearfractiontodate.hpp>
#include <utility>


namespace QuantLib {

    FixedLocalVolSurface::FixedLocalVolSurface(const Date& referenceDate,
                                               const std::vector<Date>& dates,
                                               const std::vector<Real>& strikes,
                                               ext::shared_ptr<Matrix> localVolMatrix,
                                               const DayCounter& dayCounter,
                                               Extrapolation lowerExtrapolation,
                                               Extrapolation upperExtrapolation)
    : LocalVolTermStructure(referenceDate, NullCalendar(), Following, dayCounter),
      maxDate_(dates.back()), localVolMatrix_(std::move(localVolMatrix)),
      strikes_(dates.size(), ext::make_shared<std::vector<Real> >(strikes)),
      localVolInterpol_(dates.size()), lowerExtrapolation_(lowerExtrapolation),
      upperExtrapolation_(upperExtrapolation) {

        QL_REQUIRE(dates[0]>=referenceDate,
                   "cannot have dates[0] < referenceDate");

        times_ = std::vector<Time>(dates.size());
        for (Size j=0; j<times_.size(); j++)
            times_[j] = timeFromReference(dates[j]);

        checkSurface();
        setInterpolation<Linear>();
    }

    FixedLocalVolSurface::FixedLocalVolSurface(const Date& referenceDate,
                                               const std::vector<Time>& times,
                                               const std::vector<Real>& strikes,
                                               ext::shared_ptr<Matrix> localVolMatrix,
                                               const DayCounter& dayCounter,
                                               Extrapolation lowerExtrapolation,
                                               Extrapolation upperExtrapolation)
    : LocalVolTermStructure(referenceDate, NullCalendar(), Following, dayCounter),
      maxDate_(yearFractionToDate(dayCounter, referenceDate, times.back())), times_(times),
      localVolMatrix_(std::move(localVolMatrix)),
      strikes_(times.size(), ext::make_shared<std::vector<Real> >(strikes)),
      localVolInterpol_(times.size()), lowerExtrapolation_(lowerExtrapolation),
      upperExtrapolation_(upperExtrapolation) {

        QL_REQUIRE(times_[0]>=0, "cannot have times[0] < 0");

        checkSurface();
        setInterpolation<Linear>();
    }

    FixedLocalVolSurface::FixedLocalVolSurface(
        const Date& referenceDate,
        const std::vector<Time>& times,
        const std::vector<ext::shared_ptr<std::vector<Real> > >& strikes,
        ext::shared_ptr<Matrix> localVolMatrix,
        const DayCounter& dayCounter,
        Extrapolation lowerExtrapolation,
        Extrapolation upperExtrapolation)
    : LocalVolTermStructure(referenceDate, NullCalendar(), Following, dayCounter),
      maxDate_(yearFractionToDate(dayCounter, referenceDate, times.back())), times_(times),
      localVolMatrix_(std::move(localVolMatrix)), strikes_(strikes),
      localVolInterpol_(times.size()), lowerExtrapolation_(lowerExtrapolation),
      upperExtrapolation_(upperExtrapolation) {

        QL_REQUIRE(times_[0]>=0, "cannot have times[0] < 0");
        QL_REQUIRE(times.size() == strikes.size(),
             "need strikes for every time step");
        checkSurface();
        setInterpolation<Linear>();
    }


    void FixedLocalVolSurface::checkSurface() {
        QL_REQUIRE(times_.size()==localVolMatrix_->columns(),
                   "mismatch between date vector and vol matrix colums");
        for (const auto& strike : strikes_) {
            QL_REQUIRE(strike->size() == localVolMatrix_->rows(),
                       "mismatch between money-strike vector and "
                       "vol matrix rows");
        }

        for (Size j=1; j<times_.size(); j++) {
            QL_REQUIRE(times_[j]>times_[j-1],
                       "dates must be sorted unique!");
        }

        for (const auto& strike : strikes_)
            for (Size j = 1; j < strike->size(); j++) {
                QL_REQUIRE((*strike)[j] >= (*strike)[j - 1], "strikes must be sorted");
            }
    }

    Date FixedLocalVolSurface::maxDate() const {
        return maxDate_;
    }
    Time FixedLocalVolSurface::maxTime() const {
        return times_.back();
    }
    Real FixedLocalVolSurface::minStrike() const {
        return strikes_.back()->front();
    }
    Real FixedLocalVolSurface::maxStrike() const {
        return strikes_.back()->back();
    }

    Volatility FixedLocalVolSurface::localVolImpl(Time t, Real strike) const {
        t = std::min(times_.back(), std::max(t, times_.front()));

        const Size idx = std::distance(times_.begin(),
            std::lower_bound(times_.begin(), times_.end(), t));

        if (close_enough(t, times_[idx])) {
            if (strikes_[idx]->front() < strikes_[idx]->back())
                return localVolInterpol_[idx](strike, true);
            else
                return (*localVolMatrix_)[localVolMatrix_->rows()/2][idx];
        }
        else {
            Real earlierStrike = strike, laterStrike = strike;
            if (lowerExtrapolation_ == ConstantExtrapolation) {
                if (strike < strikes_[idx-1]->front())
                    earlierStrike = strikes_[idx-1]->front();
                if (strike < strikes_[idx]->front())
                    laterStrike = strikes_[idx]->front();
            }

            if (upperExtrapolation_ == ConstantExtrapolation) {
                if (strike > strikes_[idx-1]->back())
                    earlierStrike = strikes_[idx-1]->back();
                if (strike > strikes_[idx]->back())
                    laterStrike = strikes_[idx]->back();
            }

            const Real earlyVol =
                (strikes_[idx-1]->front() < strikes_[idx-1]->back())
                ? localVolInterpol_[idx-1](earlierStrike, true)
                : (*localVolMatrix_)[localVolMatrix_->rows()/2][idx-1];
            const Real laterVol = localVolInterpol_[idx](laterStrike, true);

            return earlyVol
                    + (laterVol-earlyVol)/(times_[idx]-times_[idx-1])
                      *(t-times_[idx-1]);
        }
    }

}
]]></document_content>
  </document>
  <document index="28">
    <source>volatility/equityfx/gridmodellocalvolsurface.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file parameterizedlocalvolsurface.cpp
*/

#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/termstructures/volatility/equityfx/fixedlocalvolsurface.hpp>
#include <ql/termstructures/volatility/equityfx/gridmodellocalvolsurface.hpp>
#include <functional>
#include <algorithm>

namespace QuantLib {
    GridModelLocalVolSurface::GridModelLocalVolSurface(
        const Date& referenceDate,
        const std::vector<Date>& dates,
        const std::vector<ext::shared_ptr<std::vector<Real> > >& strikes,
        const DayCounter& dayCounter,
        Extrapolation lowerExtrapolation,
        Extrapolation upperExtrapolation)
    : LocalVolTermStructure(
            referenceDate, NullCalendar(), Following, dayCounter),
      CalibratedModel(dates.size()*strikes.front()->size()),
      referenceDate_(referenceDate),
      times_(dates.size()),
      strikes_(strikes),
      dayCounter_(dayCounter),
      lowerExtrapolation_(lowerExtrapolation),
      upperExtrapolation_(upperExtrapolation) {

        for (Size i=1; i < strikes_.size(); ++i) {
            QL_REQUIRE(strikes_[i]->size() == strikes_.front()->size(),
                       "strike vectors must have the same dimension");
        }

        std::fill(arguments_.begin(), arguments_.end(),
            ConstantParameter(1.0, PositiveConstraint()));

        for (Size i=0; i < dates.size(); ++i) {
            times_[i] = dayCounter.yearFraction(referenceDate_, dates[i]);
        }

        GridModelLocalVolSurface::generateArguments();
    }

    void GridModelLocalVolSurface::update() {
        LocalVolTermStructure::update();
        CalibratedModel::update();
    }

    Date GridModelLocalVolSurface::maxDate() const {
        return localVol_->maxDate();
    }
    Time GridModelLocalVolSurface::maxTime() const {
        return localVol_->maxTime();
    }
    Real GridModelLocalVolSurface::minStrike() const {
        return localVol_->minStrike();
    }
    Real GridModelLocalVolSurface::maxStrike() const {
        return localVol_->maxStrike();
    }

    Volatility GridModelLocalVolSurface::localVolImpl(Time t, Real strike)
    const {
        return localVol_->localVol(t, strike, true);
    }

    void GridModelLocalVolSurface::generateArguments() {
        const ext::shared_ptr<Matrix> localVolMatrix(
            new Matrix(strikes_.front()->size(), times_.size()));

        std::transform(arguments_.begin(), arguments_.end(),
                       localVolMatrix->begin(),
                       [](const Parameter& p) { return p(0.0); });

        localVol_ = ext::make_shared<FixedLocalVolSurface>(
                referenceDate_,
                times_,
                strikes_,
                localVolMatrix,
                dayCounter_,
                lowerExtrapolation_,
                upperExtrapolation_);
    }
}
]]></document_content>
  </document>
  <document index="29">
    <source>volatility/equityfx/hestonblackvolsurface.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes Gttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hestonblackvolsurface.hpp
    \brief Black volatility surface back by Heston model
*/

#include <ql/math/functional.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/termstructures/volatility/equityfx/hestonblackvolsurface.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <limits>
#include <utility>

namespace QuantLib {

    namespace {
        Real blackValue(Option::Type optionType, Real strike,
                        Real forward, Real maturity,
                        Volatility vol, Real discount, Real npv) {

            return blackFormula(optionType, strike, forward,
                                std::max(0.0, vol)*std::sqrt(maturity),
                                discount)-npv;
        }
    }

    HestonBlackVolSurface::HestonBlackVolSurface(
        const Handle<HestonModel>& hestonModel,
        const AnalyticHestonEngine::ComplexLogFormula cpxLogFormula,
        AnalyticHestonEngine::Integration integration)
    : BlackVolTermStructure(hestonModel->process()->riskFreeRate()->referenceDate(),
                            NullCalendar(),
                            Following,
                            hestonModel->process()->riskFreeRate()->dayCounter()),
      hestonModel_(hestonModel), cpxLogFormula_(cpxLogFormula),
      integration_(std::move(integration)) {
        registerWith(hestonModel_);
    }

    DayCounter HestonBlackVolSurface::dayCounter() const {
        return hestonModel_->process()->riskFreeRate()->dayCounter();
    }
    Date HestonBlackVolSurface::maxDate() const {
        return Date::maxDate();
    }
    Real HestonBlackVolSurface::minStrike() const {
        return 0.0;
    }
    Real HestonBlackVolSurface::maxStrike() const {
        return std::numeric_limits<Real>::max();
    }

    Real HestonBlackVolSurface::blackVarianceImpl(Time t, Real strike) const {
        return squared(blackVolImpl(t, strike))*t;
    }

    Volatility HestonBlackVolSurface::blackVolImpl(Time t, Real strike) const {
        AnalyticHestonEngine hestonEngine(
                    hestonModel_.currentLink(), cpxLogFormula_, integration_);

        const ext::shared_ptr<HestonProcess>& process = hestonModel_->process();

        const DiscountFactor df = process->riskFreeRate()->discount(t, true);

        const Real fwd = process->s0()->value()
            * process->dividendYield()->discount(t, true) / df;

        const ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::make_shared<PlainVanillaPayoff>(
                            fwd > strike ? Option::Put : Option::Call, strike);

        const Real npv = hestonEngine.priceVanillaPayoff(payoff, t);

        const Real theta = hestonModel_->theta();
        if (npv <= 0.0) return std::sqrt(theta);

        Brent solver;
        solver.setMaxEvaluations(10000);
        const Volatility guess = std::sqrt(theta);
        constexpr double accuracy = std::numeric_limits<double>::epsilon();

        return solver.solve(
            [&](Volatility _v) {
                return blackValue(
                    payoff->optionType(), strike, fwd, t, _v, df, npv);
            },
            accuracy, guess, 0.01
        );
    }
}
]]></document_content>
  </document>
  <document index="30">
    <source>volatility/equityfx/localvolsurface.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/equityfx/blackvoltermstructure.hpp>
#include <ql/termstructures/volatility/equityfx/localvolsurface.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {


    const Date& LocalVolSurface::referenceDate() const {
        return blackTS_->referenceDate();
    }

    DayCounter LocalVolSurface::dayCounter() const {
        return blackTS_->dayCounter();
    }

    Date LocalVolSurface::maxDate() const {
        return blackTS_->maxDate();
    }

    Real LocalVolSurface::minStrike() const {
        return blackTS_->minStrike();
    }

    Real LocalVolSurface::maxStrike() const {
        return blackTS_->maxStrike();
    }

    LocalVolSurface::LocalVolSurface(const Handle<BlackVolTermStructure>& blackTS,
                                     Handle<YieldTermStructure> riskFreeTS,
                                     Handle<YieldTermStructure> dividendTS,
                                     Handle<Quote> underlying)
    : LocalVolTermStructure(blackTS->businessDayConvention(), blackTS->dayCounter()),
      blackTS_(blackTS), riskFreeTS_(std::move(riskFreeTS)), dividendTS_(std::move(dividendTS)),
      underlying_(std::move(underlying)) {
        registerWith(blackTS_);
        registerWith(riskFreeTS_);
        registerWith(dividendTS_);
        registerWith(underlying_);
    }

    LocalVolSurface::LocalVolSurface(const Handle<BlackVolTermStructure>& blackTS,
                                     Handle<YieldTermStructure> riskFreeTS,
                                     Handle<YieldTermStructure> dividendTS,
                                     Real underlying)
    : LocalVolTermStructure(blackTS->businessDayConvention(), blackTS->dayCounter()),
      blackTS_(blackTS), riskFreeTS_(std::move(riskFreeTS)), dividendTS_(std::move(dividendTS)),
      underlying_(ext::shared_ptr<Quote>(new SimpleQuote(underlying))) {
        registerWith(blackTS_);
        registerWith(riskFreeTS_);
        registerWith(dividendTS_);
    }

    void LocalVolSurface::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<LocalVolSurface>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            LocalVolTermStructure::accept(v);
    }

    Volatility LocalVolSurface::localVolImpl(Time t, Real underlyingLevel)
                                                                     const {

        DiscountFactor dr = riskFreeTS_->discount(t, true);
        DiscountFactor dq = dividendTS_->discount(t, true);
        Real forwardValue = underlying_->value()*dq/dr;
        
        // strike derivatives
        Real strike, y, dy, strikep, strikem;
        Real w, wp, wm, dwdy, d2wdy2;
        strike = underlyingLevel;
        y = std::log(strike/forwardValue);
        dy = ((std::fabs(y) > 0.001) ? Real(y*0.0001) : 0.000001);
        strikep=strike*std::exp(dy);
        strikem=strike/std::exp(dy);
        w  = blackTS_->blackVariance(t, strike,  true);
        wp = blackTS_->blackVariance(t, strikep, true);
        wm = blackTS_->blackVariance(t, strikem, true);
        dwdy = (wp-wm)/(2.0*dy);
        d2wdy2 = (wp-2.0*w+wm)/(dy*dy);

        // time derivative
        Real dt, wpt, wmt, dwdt;
        if (t==0.0) {
            dt = 0.0001;
            DiscountFactor drpt = riskFreeTS_->discount(t+dt, true);
            DiscountFactor dqpt = dividendTS_->discount(t+dt, true);           
            Real strikept = strike*dr*dqpt/(drpt*dq);
        
            wpt = blackTS_->blackVariance(t+dt, strikept, true);
            QL_ENSURE(wpt>=w,
                      "decreasing variance at strike " << strike
                      << " between time " << t << " and time " << t+dt);
            dwdt = (wpt-w)/dt;
        } else {
            dt = std::min<Time>(0.0001, t/2.0);
            DiscountFactor drpt = riskFreeTS_->discount(t+dt, true);
            DiscountFactor drmt = riskFreeTS_->discount(t-dt, true);
            DiscountFactor dqpt = dividendTS_->discount(t+dt, true);
            DiscountFactor dqmt = dividendTS_->discount(t-dt, true);
            
            Real strikept = strike*dr*dqpt/(drpt*dq);
            Real strikemt = strike*dr*dqmt/(drmt*dq);
            
            wpt = blackTS_->blackVariance(t+dt, strikept, true);
            wmt = blackTS_->blackVariance(t-dt, strikemt, true);

            QL_ENSURE(wpt>=w,
                      "decreasing variance at strike " << strike
                      << " between time " << t << " and time " << t+dt);
            QL_ENSURE(w>=wmt,
                      "decreasing variance at strike " << strike
                      << " between time " << t-dt << " and time " << t);
         
            dwdt = (wpt-wmt)/(2.0*dt);
        }

        if (dwdy==0.0 && d2wdy2==0.0) { // avoid /w where w might be 0.0
            return std::sqrt(dwdt);
        } else {
            Real den1 = 1.0 - y/w*dwdy;
            Real den2 = 0.25*(-0.25 - 1.0/w + y*y/w/w)*dwdy*dwdy;
            Real den3 = 0.5*d2wdy2;
            Real den = den1+den2+den3;
            Real result = dwdt / den;

            QL_ENSURE(result>=0.0,
                      "negative local vol^2 at strike " << strike
                      << " and time " << t
                      << "; the black vol surface is not smooth enough");

            return std::sqrt(result);
        }
    }

}

]]></document_content>
  </document>
  <document index="31">
    <source>volatility/equityfx/localvoltermstructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>

namespace QuantLib {

    LocalVolTermStructure::LocalVolTermStructure(BusinessDayConvention bdc,
                                                 const DayCounter& dc)
    : VolatilityTermStructure(bdc, dc) {}

    LocalVolTermStructure::LocalVolTermStructure(const Date& referenceDate,
                                                 const Calendar& cal,
                                                 BusinessDayConvention bdc,
                                                 const DayCounter& dc)
    : VolatilityTermStructure(referenceDate, cal, bdc, dc) {}

    LocalVolTermStructure::LocalVolTermStructure(Natural settlementDays,
                                                 const Calendar& cal,
                                                 BusinessDayConvention bdc,
                                                 const DayCounter& dc)
    : VolatilityTermStructure(settlementDays, cal, bdc, dc) {}

    Volatility LocalVolTermStructure::localVol(const Date& d,
                                               Real underlyingLevel,
                                               bool extrapolate) const {
        checkRange(d, extrapolate);
        checkStrike(underlyingLevel, extrapolate);
        Time t = timeFromReference(d);
        return localVolImpl(t, underlyingLevel);
    }

    Volatility LocalVolTermStructure::localVol(Time t,
                                               Real underlyingLevel,
                                               bool extrapolate) const {
        checkRange(t, extrapolate);
        checkStrike(underlyingLevel, extrapolate);
        return localVolImpl(t, underlyingLevel);
    }

    void LocalVolTermStructure::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<LocalVolTermStructure>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            QL_FAIL("not a local-volatility term structure visitor");
    }

}
]]></document_content>
  </document>
  <document index="32">
    <source>volatility/flatsmilesection.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Franois du Vignaud
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/flatsmilesection.hpp>

namespace QuantLib {

    FlatSmileSection::FlatSmileSection(const Date& d,
                                       Volatility vol,
                                       const DayCounter& dc,
                                       const Date& referenceDate,
                                       Real atmLevel,
                                       VolatilityType type,
                                       Real shift)
    : SmileSection(d, dc, referenceDate, type, shift),
      vol_(vol), atmLevel_(atmLevel) {}

    FlatSmileSection::FlatSmileSection(Time exerciseTime,
                                       Volatility vol,
                                       const DayCounter& dc,
                                       Real atmLevel,
                                       VolatilityType type,
                                       Real shift)
    : SmileSection(exerciseTime, dc, type, shift),
      vol_(vol), atmLevel_(atmLevel) {}

}
]]></document_content>
  </document>
  <document index="33">
    <source>volatility/gaussian1dsmilesection.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/makecapfloor.hpp>
#include <ql/instruments/makeswaption.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/termstructures/volatility/gaussian1dsmilesection.hpp>
#include <utility>

using std::sqrt;

namespace QuantLib {

    Gaussian1dSmileSection::Gaussian1dSmileSection(
        const Date& fixingDate,
        ext::shared_ptr<SwapIndex> swapIndex,
        const ext::shared_ptr<Gaussian1dModel>& model,
        const DayCounter& dc,
        const ext::shared_ptr<Gaussian1dSwaptionEngine>& swaptionEngine)
    : SmileSection(fixingDate, dc, model->termStructure()->referenceDate()),
      fixingDate_(fixingDate), swapIndex_(std::move(swapIndex)), model_(model),
      engine_(swaptionEngine) {

        atm_ = model_->swapRate(fixingDate_, swapIndex_->tenor(), Date(), 0.0, swapIndex_);
        annuity_ =
            model_->swapAnnuity(fixingDate_, swapIndex_->tenor(), Date(), 0.0, swapIndex_);

        if (engine_ == nullptr) {
            engine_ = ext::make_shared<Gaussian1dSwaptionEngine>(
                model_, 64, 7.0, true, false, swapIndex_->discountingTermStructure());
        }
    }

    Gaussian1dSmileSection::Gaussian1dSmileSection(
        const Date& fixingDate,
        ext::shared_ptr<IborIndex> iborIndex,
        const ext::shared_ptr<Gaussian1dModel>& model,
        const DayCounter& dc,
        const ext::shared_ptr<Gaussian1dCapFloorEngine>& capEngine)
    : SmileSection(fixingDate, dc, model->termStructure()->referenceDate()),
      fixingDate_(fixingDate), iborIndex_(std::move(iborIndex)), model_(model), engine_(capEngine) {

        atm_ = model_->forwardRate(fixingDate_, Date(), 0.0, iborIndex_);
        CapFloor c =
            MakeCapFloor(CapFloor::Cap, iborIndex_->tenor(), iborIndex_, Null<Real>(), 0 * Days)
                .withEffectiveDate(fixingDate_, false);
        annuity_ = iborIndex_->dayCounter().yearFraction(c.startDate(), c.maturityDate()) *
                   model_->zerobond(c.maturityDate());

        if (engine_ == nullptr) {
            engine_ = ext::make_shared<Gaussian1dCapFloorEngine>(
                model_, 64, 7.0, true,
                false); // use model curve as discounting curve
        }
    }

Real Gaussian1dSmileSection::atmLevel() const { return atm_; }

Real Gaussian1dSmileSection::optionPrice(Rate strike, Option::Type type,
                                         Real discount) const {

    if (swapIndex_ != nullptr) {
        Swaption s = MakeSwaption(swapIndex_, fixingDate_, strike)
                         .withUnderlyingType(type == Option::Call
                                                 ? Swap::Payer
                                                 : Swap::Receiver)
                         .withPricingEngine(engine_);
        Real tmp = s.NPV();
        return tmp / annuity_ * discount;
    } else {
        CapFloor c =
            MakeCapFloor(type == Option::Call ? CapFloor::Cap : CapFloor::Floor,
                         iborIndex_->tenor(), iborIndex_, strike, 0 * Days)
                .withEffectiveDate(fixingDate_, false)
                .withPricingEngine(engine_);
        Real tmp = c.NPV();
        return tmp / annuity_ * discount;
    }
}

Real Gaussian1dSmileSection::volatilityImpl(Rate strike) const {
    Real vol = 0.0;
    try {
        Option::Type type = strike >= atm_ ? Option::Call : Option::Put;
        Real o = optionPrice(strike, type);
        vol = blackFormulaImpliedStdDev(type, strike, atm_, o) /
              sqrt(exerciseTime());
    } catch (...) {
    }
    return vol;
}
}
]]></document_content>
  </document>
  <document index="34">
    <source>volatility/inflation/constantcpivolatility.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009, 2011 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/termstructures/volatility/inflation/constantcpivolatility.hpp>
#include <ql/quotes/simplequote.hpp>

namespace QuantLib {

    ConstantCPIVolatility:: ConstantCPIVolatility(const Handle<Quote>& vol,
                                                  Natural settlementDays,
                                                  const Calendar& cal,
                                                  BusinessDayConvention bdc,
                                                  const DayCounter& dc,
                                                  const Period& observationLag,
                                                  Frequency frequency,
                                                  bool indexIsInterpolated)
    : CPIVolatilitySurface(settlementDays, cal, bdc, dc,
                           observationLag, frequency, indexIsInterpolated),
      volatility_(vol) {}

    ConstantCPIVolatility:: ConstantCPIVolatility(Volatility vol,
                                                  Natural settlementDays,
                                                  const Calendar& cal,
                                                  BusinessDayConvention bdc,
                                                  const DayCounter& dc,
                                                  const Period& observationLag,
                                                  Frequency frequency,
                                                  bool indexIsInterpolated)
    : CPIVolatilitySurface(settlementDays, cal, bdc, dc,
                           observationLag, frequency, indexIsInterpolated),
      volatility_(ext::make_shared<SimpleQuote>(vol)) {}


    Volatility ConstantCPIVolatility::volatilityImpl(Time, Rate) const {
        return volatility_->value();
    }

}

]]></document_content>
  </document>
  <document index="35">
    <source>volatility/inflation/cpivolatilitystructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009, 2011 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/termstructures/volatility/inflation/cpivolatilitystructure.hpp>
#include <ql/termstructures/inflationtermstructure.hpp>

namespace QuantLib {

    CPIVolatilitySurface::CPIVolatilitySurface(Natural settlementDays,
                                               const Calendar& cal,
                                               BusinessDayConvention bdc,
                                               const DayCounter& dc,
                                               const Period& observationLag,
                                               Frequency frequency,
                                               bool indexIsInterpolated)
    : VolatilityTermStructure(settlementDays, cal, bdc, dc),
      baseLevel_(Null<Volatility>()), observationLag_(observationLag),
      frequency_(frequency), indexIsInterpolated_(indexIsInterpolated)
    {}


    Date CPIVolatilitySurface::baseDate() const {
        // Depends on interpolation, or not, of observed index
        // and observation lag with which it was built.
        // We want this to work even if the index does not
        // have a term structure.
        if (indexIsInterpolated()) {
            return referenceDate() - observationLag();
        } else {
            return inflationPeriod(referenceDate() - observationLag(),
                                   frequency()).first;
        }
    }


    void CPIVolatilitySurface::checkRange(const Date& d, Rate strike,
                                          bool extrapolate) const {
        QL_REQUIRE(d >= baseDate(),
                   "date (" << d << ") is before base date");
        QL_REQUIRE(extrapolate || allowsExtrapolation() || d <= maxDate(),
                   "date (" << d << ") is past max curve date ("
                   << maxDate() << ")");
        QL_REQUIRE(extrapolate || allowsExtrapolation() ||
                   (strike >= minStrike() && strike <= maxStrike()),
                   "strike (" << strike << ") is outside the curve domain ["
                   << minStrike() << "," << maxStrike()<< "]] at date = " << d);
    }


    void CPIVolatilitySurface::checkRange(Time t, Rate strike,
                                          bool extrapolate) const {
        QL_REQUIRE(t >= timeFromReference(baseDate()),
                   "time (" << t << ") is before base date");
        QL_REQUIRE(extrapolate || allowsExtrapolation() || t <= maxTime(),
                   "time (" << t << ") is past max curve time ("
                   << maxTime() << ")");
        QL_REQUIRE(extrapolate || allowsExtrapolation() ||
                   (strike >= minStrike() && strike <= maxStrike()),
                   "strike (" << strike << ") is outside the curve domain ["
                   << minStrike() << "," << maxStrike()<< "] at time = " << t);
    }


    Volatility CPIVolatilitySurface::volatility(const Date& maturityDate,
                                                Rate strike,
                                                const Period& obsLag,
                                                bool extrapolate) const {

        Period useLag = obsLag;
        if (obsLag==Period(-1,Days)) {
            useLag = observationLag();
        }

        if (indexIsInterpolated()) {
            checkRange(maturityDate-useLag, strike, extrapolate);
            Time t = timeFromReference(maturityDate-useLag);
            return volatilityImpl(t,strike);
        } else {
            std::pair<Date,Date> dd =
                inflationPeriod(maturityDate-useLag, frequency());
            checkRange(dd.first, strike, extrapolate);
            Time t = timeFromReference(dd.first);
            return volatilityImpl(t,strike);
        }
    }


    Volatility CPIVolatilitySurface::volatility(const Period& optionTenor,
                                                Rate strike,
                                                const Period& obsLag,
                                                bool extrapolate) const {
        Date maturityDate = optionDateFromTenor(optionTenor);
        return volatility(maturityDate, strike, obsLag, extrapolate);
    }

    Volatility CPIVolatilitySurface::volatility(Time time, Rate strike) const {
        return volatilityImpl(time, strike);
    }

    //! needed for total variance calculations
    Time CPIVolatilitySurface::timeFromBase(const Date& maturityDate,
                                            const Period& obsLag) const {
        Period useLag = obsLag;
        if (obsLag==Period(-1,Days)) {
            useLag = observationLag();
        }

        Date useDate;
        if (indexIsInterpolated()) {
            useDate = maturityDate - useLag;
        } else {
            useDate = inflationPeriod(maturityDate - useLag,
                                      frequency()).first;
        }

        // This assumes that the inflation term structure starts
        // as late as possible given the inflation index definition,
        // which is the usual case.
        return dayCounter().yearFraction(baseDate(), useDate);
    }


    Volatility CPIVolatilitySurface::totalVariance(const Date& maturityDate,
                                                   Rate strike,
                                                   const Period& obsLag,
                                                   bool extrapolate) const {
        Volatility vol = volatility(maturityDate, strike, obsLag, extrapolate);
        Time t = timeFromBase(maturityDate, obsLag);
        return vol*vol*t;
    }


    Volatility CPIVolatilitySurface::totalVariance(const Period& tenor,
                                                   Rate strike,
                                                   const Period& obsLag,
                                                   bool extrap) const {
        Date maturityDate = optionDateFromTenor(tenor);
        return totalVariance(maturityDate, strike, obsLag, extrap);
    }

}

]]></document_content>
  </document>
  <document index="36">
    <source>volatility/inflation/yoyinflationoptionletvolatilitystructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

/*! \file yoyoptionletvolatilitystructures.cpp
 \brief yoy inflation volatility structures
 */

#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/inflationtermstructure.hpp>
#include <ql/termstructures/volatility/inflation/yoyinflationoptionletvolatilitystructure.hpp>
#include <utility>

namespace QuantLib {

    YoYOptionletVolatilitySurface::
    YoYOptionletVolatilitySurface(Natural settlementDays,
                                  const Calendar &cal,
                                  BusinessDayConvention bdc,
                                  const DayCounter& dc,
                                  const Period& observationLag,
                                  Frequency frequency,
                                  bool indexIsInterpolated,
                                  VolatilityType volType,
                                  Real displacement)
    : VolatilityTermStructure(settlementDays, cal, bdc, dc),
      baseLevel_(Null<Volatility>()), observationLag_(observationLag),
      frequency_(frequency), indexIsInterpolated_(indexIsInterpolated),
      volType_(volType), displacement_(displacement) {
        QL_REQUIRE(close_enough(displacement, 0.0) || close_enough(displacement, 1.0),
                   "YoYOptionletVolatilitySurface: displacement (" << displacement
                                                                   << ") must be 0 or 1");
    }


    Date
    YoYOptionletVolatilitySurface::baseDate() const {

        // Depends on interpolation, or not, of observed index
        // and observation lag with which it was built.
        // We want this to work even if the index does not
        // have a yoy term structure.
        if (indexIsInterpolated()) {
            return referenceDate() - observationLag();
        } else {
            return inflationPeriod(referenceDate() - observationLag(),
                                   frequency()).first;
        }
    }


    void YoYOptionletVolatilitySurface::checkRange(const Date& d, Rate strike,
                                            bool extrapolate) const {
        QL_REQUIRE(d >= baseDate(),
                   "date (" << d << ") is before base date");
        QL_REQUIRE(extrapolate || allowsExtrapolation() || d <= maxDate(),
                   "date (" << d << ") is past max curve date ("
                   << maxDate() << ")");
        QL_REQUIRE(extrapolate || allowsExtrapolation() ||
                   (strike >= minStrike() && strike <= maxStrike()),
                   "strike (" << strike << ") is outside the curve domain ["
                   << minStrike() << "," << maxStrike()<< "]] at date = " << d);
    }


    void YoYOptionletVolatilitySurface::checkRange(Time t, Rate strike,
                                            bool extrapolate) const {
        QL_REQUIRE(t >= timeFromReference(baseDate()),
                   "time (" << t << ") is before base date");
        QL_REQUIRE(extrapolate || allowsExtrapolation() || t <= maxTime(),
                   "time (" << t << ") is past max curve time ("
                   << maxTime() << ")");
        QL_REQUIRE(extrapolate || allowsExtrapolation() ||
                   (strike >= minStrike() && strike <= maxStrike()),
                   "strike (" << strike << ") is outside the curve domain ["
                   << minStrike() << "," << maxStrike()<< "] at time = " << t);
    }


    Volatility
    YoYOptionletVolatilitySurface::volatility(const Date& maturityDate,
                                              Rate strike,
                                              const Period &obsLag,
                                              bool extrapolate) const {

        Period useLag = obsLag;
        if (obsLag==Period(-1,Days)) {
            useLag = observationLag();
        }

        if (indexIsInterpolated()) {
            YoYOptionletVolatilitySurface::checkRange(maturityDate-useLag, strike, extrapolate);
            Time t = timeFromReference(maturityDate-useLag);
            return volatilityImpl(t,strike);
        } else {
            std::pair<Date,Date> dd = inflationPeriod(maturityDate-useLag, frequency());
            YoYOptionletVolatilitySurface::checkRange(dd.first, strike, extrapolate);
            Time t = timeFromReference(dd.first);
            return volatilityImpl(t,strike);
        }
    }


    Volatility
    YoYOptionletVolatilitySurface::volatility(const Period& optionTenor,
                                              Rate strike,
                                              const Period &obsLag,
                                              bool extrapolate) const {
        Date maturityDate = optionDateFromTenor(optionTenor);
        return volatility(maturityDate, strike, obsLag, extrapolate);
    }

    Volatility YoYOptionletVolatilitySurface::volatility(Time time, Rate strike) const {
        return volatilityImpl(time, strike);
    }

    //! needed for total variance calculations
    Time
    YoYOptionletVolatilitySurface::timeFromBase(const Date &maturityDate,
                                                const Period& obsLag) const {

        Period useLag = obsLag;
        if (obsLag==Period(-1,Days)) {
            useLag = observationLag();
        }

        Date useDate;
        if (indexIsInterpolated()) {
            useDate = maturityDate - useLag;
        } else {
            useDate = inflationPeriod(maturityDate - useLag,
                                      frequency()).first;
        }

        // This assumes that the inflation term structure starts
        // as late as possible given the inflation index definition,
        // which is the usual case.
        return dayCounter().yearFraction(baseDate(), useDate);
    }


    Volatility
    YoYOptionletVolatilitySurface::totalVariance(const Date& maturityDate,
                                                 Rate strike,
                                                 const Period &obsLag,
                                                 bool extrapolate) const {

        Volatility vol = volatility(maturityDate, strike, obsLag, extrapolate);
        Time t = timeFromBase(maturityDate, obsLag);
        return vol*vol*t;
    }


    Volatility
    YoYOptionletVolatilitySurface::totalVariance(const Period& tenor,
                                                 Rate strike,
                                                 const Period &obsLag,
                                                 bool extrap) const {
        Date maturityDate = optionDateFromTenor(tenor);
        return totalVariance(maturityDate, strike, obsLag, extrap);
    }



    //========================================================================
    // constant yoy vol surface
    //========================================================================

    ConstantYoYOptionletVolatility::
    ConstantYoYOptionletVolatility(const Volatility v,
                                   Natural settlementDays,
                                   const Calendar& cal,
                                   BusinessDayConvention bdc,
                                   const DayCounter& dc,
                                   const Period &observationLag,
                                   Frequency frequency,
                                   bool indexIsInterpolated,
                                   Rate minStrike,
                                   Rate maxStrike,
                                   VolatilityType volType,
                                   Real displacement)
    : YoYOptionletVolatilitySurface(settlementDays, cal, bdc, dc,
                                    observationLag, frequency, indexIsInterpolated,
                                    volType, displacement),
      volatility_(ext::make_shared<SimpleQuote>(v)), minStrike_(minStrike), maxStrike_(maxStrike) {}

    ConstantYoYOptionletVolatility::ConstantYoYOptionletVolatility(Handle<Quote> v,
                                                                   Natural settlementDays,
                                                                   const Calendar& cal,
                                                                   BusinessDayConvention bdc,
                                                                   const DayCounter& dc,
                                                                   const Period& observationLag,
                                                                   Frequency frequency,
                                                                   bool indexIsInterpolated,
                                                                   Rate minStrike,
                                                                   Rate maxStrike,
                                                                   VolatilityType volType,
                                                                   Real displacement)
    : YoYOptionletVolatilitySurface(settlementDays,
                                    cal,
                                    bdc,
                                    dc,
                                    observationLag,
                                    frequency,
                                    indexIsInterpolated,
                                    volType,
                                    displacement),
      volatility_(std::move(v)), minStrike_(minStrike), maxStrike_(maxStrike) {}

    Volatility ConstantYoYOptionletVolatility::volatilityImpl(Time, Rate) const {
        return volatility_->value();
    }

} // namespace QuantLib
]]></document_content>
  </document>
  <document index="37">
    <source>volatility/kahalesmilesection.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/kahalesmilesection.hpp>

using std::sqrt;

namespace QuantLib {

    KahaleSmileSection::KahaleSmileSection(const ext::shared_ptr<SmileSection>& source,
                                           const Real atm,
                                           const bool interpolate,
                                           const bool exponentialExtrapolation,
                                           const bool deleteArbitragePoints,
                                           const std::vector<Real>& moneynessGrid,
                                           const Real gap,
                                           const int forcedLeftIndex,
                                           const int forcedRightIndex)
    : SmileSection(*source), source_(source), moneynessGrid_(moneynessGrid), gap_(gap),
      interpolate_(interpolate), exponentialExtrapolation_(exponentialExtrapolation),
      forcedLeftIndex_(forcedLeftIndex), forcedRightIndex_(forcedRightIndex) {

        // only shifted lognormal smile sections are supported

        QL_REQUIRE(source->volatilityType() == ShiftedLognormal,
                   "KahaleSmileSection only supports shifted lognormal source sections");

        ssutils_ = ext::make_shared<SmileSectionUtils>(
            *source, moneynessGrid, atm, deleteArbitragePoints);

        moneynessGrid_ = ssutils_->moneyGrid();
        k_ = ssutils_->strikeGrid();
        c_ = ssutils_->callPrices();
        f_ = ssutils_->atmLevel();

        // for shifted smile sections we shift the forward and the strikes
        // and do as if we were in a lognormal setting

        for (Real& i : k_) {
            i += source_->shift();
        }

        f_ += source_->shift();

        compute();
    }

    void KahaleSmileSection::compute() {

        std::pair<Size, Size> afIdx = ssutils_->arbitragefreeIndices();
        leftIndex_ = afIdx.first;
        rightIndex_ = afIdx.second;

        cFunctions_ = std::vector<ext::shared_ptr<cFunction> >(
            rightIndex_ - leftIndex_ + 2);

        // extrapolation in the leftmost interval

        Brent brent;
        bool success;
        Real secl = 0.0;

        do {
            success = true;
            try {
                Real k1 = k_[leftIndex_];
                Real c1 = c_[leftIndex_];
                Real c0 = c_[0];
                secl = (c_[leftIndex_] - c_[0]) / (k_[leftIndex_] - k_[0]);
                Real sec = (c_[leftIndex_ + 1] - c_[leftIndex_]) /
                           (k_[leftIndex_ + 1] - k_[leftIndex_]);
                Real c1p;
                if (interpolate_)
                    c1p = (secl + sec) / 2;
                else {
                    c1p = -source_->digitalOptionPrice(k1 - source_->shift() + gap_ / 2.0, Option::Call, 1.0, gap_);
                    QL_REQUIRE(secl < c1p && c1p <= 0.0, "dummy");
                    // can not extrapolate so throw exception which is caught
                    // below
                }
                sHelper1 sh1(k1, c0, c1, c1p);
                Real s = brent.solve(sh1, QL_KAHALE_ACC, 0.20, 0.00,
                                     QL_KAHALE_SMAX); // numerical parameters
                                                      // hardcoded here
                sh1(s);
                ext::shared_ptr<cFunction> cFct1(
                    new cFunction(sh1.f_, s, 0.0, sh1.b_));
                cFunctions_[0] = cFct1;
                // sanity check - in rare cases we can get digitials
                // which are not monotonic or greater than 1.0
                // due to numerical effects. Move to the next index in
                // these cases.
                Real dig = digitalOptionPrice((k1 - source_->shift()) / 2.0, Option::Call, 1.0, gap_);
                QL_REQUIRE(dig >= -c1p && dig <= 1.0, "dummy");
                if(static_cast<int>(leftIndex_) < forcedLeftIndex_) {
                    leftIndex_++;
                    success = false;
                }
            }
            catch (...) {
                leftIndex_++;
                success = false;
            }
        } while (!success && leftIndex_ < rightIndex_);

        QL_REQUIRE(
            leftIndex_ < rightIndex_,
            "can not extrapolate to left, right index of af region reached ("
                << rightIndex_ << ")");

        // interpolation

        Real cp0 = 0.0, cp1 = 0.0;

        if (interpolate_) {

            for (Size i = leftIndex_; i < rightIndex_; i++) {
                Real k0 = k_[i];
                Real k1 = k_[i + 1];
                Real c0 = c_[i];
                Real c1 = c_[i + 1];
                Real sec = (c_[i + 1] - c_[i]) / (k_[i + 1] - k_[i]);
                if (i == leftIndex_)
                    cp0 = leftIndex_ > 0 ? (secl + sec) / 2.0 : sec;
                Real secr;
                if (i == rightIndex_ - 1)
                    secr = 0.0;
                else
                    secr = (c_[i + 2] - c_[i + 1]) / (k_[i + 2] - k_[i + 1]);
                cp1 = (sec + secr) / 2.0;
                aHelper ah(k0, k1, c0, c1, cp0, cp1);
                Real a;
                bool valid = false;
                try {
                    a = brent.solve(
                        ah, QL_KAHALE_ACC, 0.5 * (cp1 + (1.0 + cp0)),
                        cp1 + QL_KAHALE_EPS, 1.0 + cp0 - QL_KAHALE_EPS);
                    // numerical parameters hardcoded here
                    valid = true;
                }
                catch (...) {
                    // delete the right point of the interval where we try to
                    // interpolate
                    moneynessGrid_.erase(moneynessGrid_.begin() + (i + 1));
                    k_.erase(k_.begin() + (i + 1));
                    c_.erase(c_.begin() + (i + 1));
                    cFunctions_.erase(cFunctions_.begin() + (i + 1));
                    rightIndex_--;
                    i--;
                }
                if (valid) {
                    ah(a);
                    ext::shared_ptr<cFunction> cFct(
                        new cFunction(ah.f_, ah.s_, a, ah.b_));
                    cFunctions_[leftIndex_ > 0 ? i - leftIndex_ + 1 : 0] = cFct;
                    cp0 = cp1;
                }
            }
        }

        // extrapolation of right wing

        do {
            success = true;
            try {
                Real k0 = k_[rightIndex_];
                Real c0 = c_[rightIndex_];
                Real cp0;
                if (interpolate_)
                    cp0 = 0.5 * (c_[rightIndex_] - c_[rightIndex_ - 1]) /
                          (k_[rightIndex_] - k_[rightIndex_ - 1]);
                else {
                    cp0 = -source_->digitalOptionPrice(
                        k0 - shift() - gap_ / 2.0, Option::Call, 1.0, gap_);
                }
                ext::shared_ptr<cFunction> cFct;
                if (exponentialExtrapolation_) {
                    QL_REQUIRE(-cp0 / c0 > 0.0, "dummy"); // this is caught
                                                          // below
                    cFct = ext::make_shared<cFunction>(
                        -cp0 / c0, std::log(c0) - cp0 / c0 * k0);
                } else {
                    sHelper sh(k0, c0, cp0);
                    Real s;
                    s = brent.solve(sh, QL_KAHALE_ACC, 0.20, 0.0,
                                    QL_KAHALE_SMAX); // numerical parameters
                                                     // hardcoded here
                    sh(s);
                    cFct = ext::make_shared<cFunction>(
                        sh.f_, s, 0.0, 0.0);
                }
                cFunctions_[rightIndex_ - leftIndex_ + 1] = cFct;
            }
            catch (...) {
                rightIndex_--;
                success = false;
            }
            if(static_cast<int>(rightIndex_) > forcedRightIndex_) {
                rightIndex_--;
                success = false;
            }
        } while (!success && rightIndex_ > leftIndex_);

        QL_REQUIRE(
            leftIndex_ < rightIndex_,
            "can not extrapolate to right, left index of af region reached ("
                << leftIndex_ << ")");
    }

    Real KahaleSmileSection::optionPrice(Rate strike, Option::Type type,
                                         Real discount) const {
        // option prices are directly available, so implement this function
        // rather than use smileSection
        // standard implementation
        Real shifted_strike = std::max(strike + shift(), QL_KAHALE_EPS);
        int i = index(shifted_strike);
        if (interpolate_ ||
            (i == 0 || i == (int)(rightIndex_ - leftIndex_ + 1)))
            return discount *
                   (type == Option::Call
                        ? (*cFunctions_[i])(shifted_strike)
                        : (*cFunctions_[i])(shifted_strike) + shifted_strike - f_);
        else
            return source_->optionPrice(strike, type, discount);
    }

    Real KahaleSmileSection::volatilityImpl(Rate strike) const {
        Real shifted_strike = std::max(strike + shift(), QL_KAHALE_EPS);
        int i = index(shifted_strike);
        if (!interpolate_ &&
            !(i == 0 || i == (int)(rightIndex_ - leftIndex_ + 1)))
            return source_->volatility(strike);
        Real c = (*cFunctions_[i])(shifted_strike);
        Real vol = 0.0;
        try {
            Option::Type type = shifted_strike >= f_ ? Option::Call : Option::Put;
            vol = blackFormulaImpliedStdDev(
                      type, shifted_strike, f_,
                      type == Option::Put ? strike - f_ + c : c) /
                  sqrt(exerciseTime());
        }
        catch (...) {
        }
        return vol;
    }

    Size KahaleSmileSection::index(Rate strike) const {
        int i =
            static_cast<int>(std::upper_bound(k_.begin(), k_.end(), strike) -
                             k_.begin()) -
            static_cast<int>(leftIndex_);
        return std::max(
            std::min(i, static_cast<int>(rightIndex_ - leftIndex_ + 1)), 0);
    }
}
]]></document_content>
  </document>
  <document index="38">
    <source>volatility/optionlet/constantoptionletvol.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Ferdinando Ametrano
 Copyright (C) 2004, 2005, 2007 StatPro Italia srl
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/flatsmilesection.hpp>
#include <ql/termstructures/volatility/optionlet/constantoptionletvol.hpp>
#include <utility>

namespace QuantLib {

    // floating reference date, floating market data
    ConstantOptionletVolatility::ConstantOptionletVolatility(Natural settlementDays,
                                                             const Calendar& cal,
                                                             BusinessDayConvention bdc,
                                                             Handle<Quote> vol,
                                                             const DayCounter& dc,
                                                             VolatilityType type,
                                                             Real displacement)
    : OptionletVolatilityStructure(settlementDays, cal, bdc, dc), volatility_(std::move(vol)),
      type_(type), displacement_(displacement) {
        registerWith(volatility_);
    }

    // fixed reference date, floating market data
    ConstantOptionletVolatility::ConstantOptionletVolatility(const Date& referenceDate,
                                                             const Calendar& cal,
                                                             BusinessDayConvention bdc,
                                                             Handle<Quote> vol,
                                                             const DayCounter& dc,
                                                             VolatilityType type,
                                                             Real displacement)
    : OptionletVolatilityStructure(referenceDate, cal, bdc, dc), volatility_(std::move(vol)),
      type_(type), displacement_(displacement) {
        registerWith(volatility_);
    }

    // floating reference date, fixed market data
    ConstantOptionletVolatility::ConstantOptionletVolatility(
        Natural settlementDays, const Calendar &cal, BusinessDayConvention bdc,
        Volatility vol, const DayCounter &dc, VolatilityType type,
        Real displacement)
        : OptionletVolatilityStructure(settlementDays, cal, bdc, dc),
          volatility_(ext::shared_ptr< Quote >(new SimpleQuote(vol))),
          type_(type), displacement_(displacement) {}

    // fixed reference date, fixed market data
    ConstantOptionletVolatility::ConstantOptionletVolatility(
        const Date &referenceDate, const Calendar &cal,
        BusinessDayConvention bdc, Volatility vol, const DayCounter &dc,
        VolatilityType type, Real displacement)
        : OptionletVolatilityStructure(referenceDate, cal, bdc, dc),
          volatility_(ext::shared_ptr< Quote >(new SimpleQuote(vol))),
          type_(type), displacement_(displacement) {}

    ext::shared_ptr<SmileSection>
    ConstantOptionletVolatility::smileSectionImpl(const Date& d) const {
        Volatility atmVol = volatility_->value();
        return ext::shared_ptr<SmileSection>(new
            FlatSmileSection(d, atmVol, dayCounter(), referenceDate()));
    }

    ext::shared_ptr<SmileSection>
    ConstantOptionletVolatility::smileSectionImpl(Time optionTime) const {
        Volatility atmVol = volatility_->value();
        return ext::shared_ptr<SmileSection>(new
            FlatSmileSection(optionTime, atmVol, dayCounter()));
    }

    Volatility ConstantOptionletVolatility::volatilityImpl(Time,
                                                    Rate) const {
        return volatility_->value();
    }

}
]]></document_content>
  </document>
  <document index="39">
    <source>volatility/optionlet/optionletstripper.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/iborindex.hpp>
#include <ql/termstructures/volatility/optionlet/optionletstripper.hpp>
#include <utility>

using std::vector;

namespace QuantLib {

    OptionletStripper::OptionletStripper(
        const ext::shared_ptr<CapFloorTermVolSurface>& termVolSurface,
        ext::shared_ptr<IborIndex> iborIndex,
        Handle<YieldTermStructure> discount,
        const VolatilityType type,
        const Real displacement,
        ext::optional<Period> optionletFrequency
    )
    : termVolSurface_(termVolSurface), iborIndex_(std::move(iborIndex)),
      discount_(std::move(discount)), nStrikes_(termVolSurface->strikes().size()),
      volatilityType_(type), displacement_(displacement), 
      optionletFrequency_(optionletFrequency) {

        if (volatilityType_ == Normal) {
            QL_REQUIRE(displacement_ == 0.0,
                       "non-null displacement is not allowed with Normal model");
        }

        if (ext::dynamic_pointer_cast<OvernightIndex>(iborIndex_)) {
            QL_REQUIRE(optionletFrequency_, 
                       "an optionlet frequency is required when using an overnight index");
        }

        registerWith(termVolSurface);
        registerWith(iborIndex_);
        registerWith(discount_);
        registerWith(Settings::instance().evaluationDate());

        Period indexTenor = optionletFrequency_ ? *optionletFrequency_ : iborIndex_->tenor();
        Period maxCapFloorTenor = termVolSurface->optionTenors().back();

        // optionlet tenors and capFloor lengths
        optionletTenors_.push_back(indexTenor);
        capFloorLengths_.push_back(optionletTenors_.back()+indexTenor);
        QL_REQUIRE(maxCapFloorTenor>=capFloorLengths_.back(),
                   "too short (" << maxCapFloorTenor <<
                   ") capfloor term vol termVolSurface");
        Period nextCapFloorLength = capFloorLengths_.back()+indexTenor;
        while (nextCapFloorLength<=maxCapFloorTenor) {
            optionletTenors_.push_back(capFloorLengths_.back());
            capFloorLengths_.push_back(nextCapFloorLength);
            nextCapFloorLength += indexTenor;
        }
        nOptionletTenors_ = optionletTenors_.size();
        
        optionletVolatilities_ =
            vector<vector<Volatility> >(nOptionletTenors_, 
                                        vector<Volatility>(nStrikes_));
        optionletStrikes_ = vector<vector<Rate> >(nOptionletTenors_,
                                                  termVolSurface->strikes());
        optionletDates_ = vector<Date>(nOptionletTenors_);
        optionletTimes_ = vector<Time>(nOptionletTenors_);
        atmOptionletRate_ = vector<Rate>(nOptionletTenors_);
        optionletPaymentDates_ = vector<Date>(nOptionletTenors_);
        optionletAccrualPeriods_ = vector<Time>(nOptionletTenors_);
    }

    const vector<Rate>& OptionletStripper::optionletStrikes(Size i) const {
        calculate();
        QL_REQUIRE(i<optionletStrikes_.size(),
                   "index (" << i <<
                   ") must be less than optionletStrikes size (" <<
                   optionletStrikes_.size() << ")");
        return optionletStrikes_[i];
    }   

    const vector<Volatility>&
    OptionletStripper::optionletVolatilities(Size i) const {
        calculate();
        QL_REQUIRE(i<optionletVolatilities_.size(),
                   "index (" << i <<
                   ") must be less than optionletVolatilities size (" <<
                   optionletVolatilities_.size() << ")");
        return optionletVolatilities_[i];
    }   

    const vector<Period>& OptionletStripper::optionletFixingTenors() const {
        return optionletTenors_;
    }

    const vector<Date>& OptionletStripper::optionletFixingDates() const {
        calculate();
        return optionletDates_;
    }
      
    const vector<Time>& OptionletStripper::optionletFixingTimes() const {
        calculate();
        return optionletTimes_;
    }
     
    Size OptionletStripper::optionletMaturities() const {
        return optionletTenors_.size();
    }

    const vector<Date>& OptionletStripper::optionletPaymentDates() const {
        calculate();
        return optionletPaymentDates_;
    }  

    const vector<Time>& OptionletStripper::optionletAccrualPeriods() const {
        calculate();
        return optionletAccrualPeriods_;
    }

    const vector<Rate>& OptionletStripper::atmOptionletRates() const {
        calculate();
        return atmOptionletRate_;
    }
    

    DayCounter OptionletStripper::dayCounter() const {
        return termVolSurface_->dayCounter();
    }

    Calendar OptionletStripper::calendar() const {
        return termVolSurface_->calendar();
    }

    Natural OptionletStripper::settlementDays() const {
        return termVolSurface_->settlementDays();
    }

    BusinessDayConvention OptionletStripper::businessDayConvention() const {
        return termVolSurface_->businessDayConvention();
    }

    ext::shared_ptr<CapFloorTermVolSurface>
    OptionletStripper::termVolSurface() const {
        return termVolSurface_;
    }

    ext::shared_ptr<IborIndex> OptionletStripper::iborIndex() const {
        return iborIndex_;
    }

    Real OptionletStripper::displacement() const {
        return displacement_;
    }

    VolatilityType OptionletStripper::volatilityType() const {
        return volatilityType_;
    }

    ext::optional<Period> OptionletStripper::optionletFrequency() const {
        return optionletFrequency_;
    }

}
]]></document_content>
  </document>
  <document index="40">
    <source>volatility/optionlet/optionletstripper1.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2008 Ferdinando Ametrano
 Copyright (C) 2007 Franois du Vignaud
 Copyright (C) 2007 Katiuscia Manzoni
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2015 Michael von den Driesch
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/optionlet/optionletstripper1.hpp>
#include <ql/instruments/makecapfloor.hpp>
#include <ql/pricingengines/capfloor/blackcapfloorengine.hpp>
#include <ql/pricingengine.hpp>
#include <ql/pricingengines/capfloor/bacheliercapfloorengine.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/utilities/dataformatters.hpp>

namespace QuantLib {

    OptionletStripper1::OptionletStripper1(
        const ext::shared_ptr<CapFloorTermVolSurface>& termVolSurface,
        const ext::shared_ptr<IborIndex>& index,
        Rate switchStrike,
        Real accuracy,
        Natural maxIter,
        const Handle<YieldTermStructure>& discount,
        const VolatilityType type,
        const Real displacement,
        bool dontThrow,
        ext::optional<Period> optionletFrequency)
    : OptionletStripper(termVolSurface, index, discount, type, displacement, optionletFrequency),
      floatingSwitchStrike_(switchStrike == Null<Rate>()), switchStrike_(switchStrike),
      accuracy_(accuracy), maxIter_(maxIter), dontThrow_(dontThrow) {

        capFloorPrices_ = Matrix(nOptionletTenors_, nStrikes_);
        optionletPrices_ = Matrix(nOptionletTenors_, nStrikes_);
        capletVols_ = Matrix(nOptionletTenors_, nStrikes_);
        capFloorVols_ = Matrix(nOptionletTenors_, nStrikes_);

        Real firstGuess = 0.14; // guess is only used for shifted lognormal vols
        optionletStDevs_ = Matrix(nOptionletTenors_, nStrikes_, firstGuess);
    }

    void OptionletStripper1::performCalculations() const {

        // update dates
        const Date& referenceDate = termVolSurface_->referenceDate();
        const DayCounter& dc = termVolSurface_->dayCounter();
        ext::shared_ptr<BlackCapFloorEngine> dummy(new
                    BlackCapFloorEngine(// discounting does not matter here
                                        iborIndex_->forwardingTermStructure(),
                                        0.20, dc));
        for (Size i=0; i<nOptionletTenors_; ++i) {
            CapFloor temp = MakeCapFloor(CapFloor::Cap,
                                         capFloorLengths_[i],
                                         iborIndex_,
                                         0.04, // dummy strike
                                         0*Days)
                .withPricingEngine(dummy);
            ext::shared_ptr<FloatingRateCoupon> lFRC =
                                                temp.lastFloatingRateCoupon();
            optionletDates_[i] = lFRC->fixingDate();
            optionletPaymentDates_[i] = lFRC->date();
            optionletAccrualPeriods_[i] = lFRC->accrualPeriod();
            optionletTimes_[i] = dc.yearFraction(referenceDate,
                                                 optionletDates_[i]);
            atmOptionletRate_[i] = lFRC->indexFixing();
        }

        if (floatingSwitchStrike_) {
            Rate averageAtmOptionletRate = 0.0;
            for (Size i=0; i<nOptionletTenors_; ++i) {
                averageAtmOptionletRate += atmOptionletRate_[i];
            }
            switchStrike_ = averageAtmOptionletRate / nOptionletTenors_;
        }

        const Handle<YieldTermStructure>& discountCurve =
            discount_.empty() ?
                iborIndex_->forwardingTermStructure() :
                discount_;

        const std::vector<Rate>& strikes = termVolSurface_->strikes();

        ext::shared_ptr<PricingEngine> capFloorEngine;
        ext::shared_ptr<SimpleQuote> volQuote(new SimpleQuote);

        if (volatilityType_ == ShiftedLognormal) {
            capFloorEngine = ext::make_shared<BlackCapFloorEngine>(
                        
                            discountCurve, Handle<Quote>(volQuote),
                            dc, displacement_);
        } else if (volatilityType_ == Normal) {
            capFloorEngine = ext::make_shared<BachelierCapFloorEngine>(
                        
                            discountCurve, Handle<Quote>(volQuote),
                            dc);
        } else {
            QL_FAIL("unknown volatility type: " << volatilityType_);
        }

        for (Size j=0; j<nStrikes_; ++j) {
            // using out-of-the-money options
            CapFloor::Type capFloorType =
                strikes[j] < switchStrike_ ? CapFloor::Floor : CapFloor::Cap;
            Option::Type optionletType =
                strikes[j] < switchStrike_ ? Option::Put : Option::Call;

            Real previousCapFloorPrice = 0.0;
            for (Size i=0; i<nOptionletTenors_; ++i) {

                capFloorVols_[i][j] = termVolSurface_->volatility(
                    capFloorLengths_[i], strikes[j], true);
                volQuote->setValue(capFloorVols_[i][j]);
                ext::shared_ptr<CapFloor> capFloor =
                    MakeCapFloor(capFloorType, capFloorLengths_[i],
                                 iborIndex_, strikes[j], -0 * Days)
                        .withPricingEngine(capFloorEngine);
                capFloorPrices_[i][j] = capFloor->NPV();
                optionletPrices_[i][j] = capFloorPrices_[i][j] -
                                                        previousCapFloorPrice;
                previousCapFloorPrice = capFloorPrices_[i][j];
                DiscountFactor d =
                    discountCurve->discount(optionletPaymentDates_[i]);
                DiscountFactor optionletAnnuity=optionletAccrualPeriods_[i]*d;
                try {
                  if (volatilityType_ == ShiftedLognormal) {
                    optionletStDevs_[i][j] = blackFormulaImpliedStdDev(
                        optionletType, strikes[j], atmOptionletRate_[i],
                        optionletPrices_[i][j], optionletAnnuity, displacement_,
                        optionletStDevs_[i][j], accuracy_, maxIter_);
                  } else if (volatilityType_ == Normal) {
                    optionletStDevs_[i][j] =
                        std::sqrt(optionletTimes_[i]) *
                        bachelierBlackFormulaImpliedVol(
                            optionletType, strikes[j], atmOptionletRate_[i],
                            optionletTimes_[i], optionletPrices_[i][j],
                            optionletAnnuity);
                  } else {
                    QL_FAIL("Unknown volatility type: " << volatilityType_);
                  }
                }
                catch (std::exception &e) {
                    if(dontThrow_)
                        optionletStDevs_[i][j]=0.0;
                    else
                        QL_FAIL("could not bootstrap optionlet:"
                            "\n type:    " << optionletType <<
                            "\n strike:  " << io::rate(strikes[j]) <<
                            "\n atm:     " << io::rate(atmOptionletRate_[i]) <<
                            "\n price:   " << optionletPrices_[i][j] <<
                            "\n annuity: " << optionletAnnuity <<
                            "\n expiry:  " << optionletDates_[i] <<
                            "\n error:   " << e.what());
                }
                optionletVolatilities_[i][j] = optionletStDevs_[i][j] /
                                                std::sqrt(optionletTimes_[i]);
            }
        }

    }

    const Matrix &OptionletStripper1::capletVols() const {
        calculate();
        return capletVols_;
    }

    const Matrix& OptionletStripper1::capFloorPrices() const {
        calculate();
        return capFloorPrices_;
    }

    const Matrix& OptionletStripper1::capFloorVolatilities() const {
        calculate();
        return capFloorVols_;
    }

    const Matrix& OptionletStripper1::optionletPrices() const {
        calculate();
        return optionletPrices_;
    }

    Rate OptionletStripper1::switchStrike() const {
        if (floatingSwitchStrike_)
            calculate();
        return switchStrike_;
    }

}
]]></document_content>
  </document>
  <document index="41">
    <source>volatility/optionlet/optionletstripper2.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2010 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/iborindex.hpp>
#include <ql/instruments/makecapfloor.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/pricingengines/capfloor/blackcapfloorengine.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/capfloor/capfloortermvolcurve.hpp>
#include <ql/termstructures/volatility/optionlet/optionletstripper1.hpp>
#include <ql/termstructures/volatility/optionlet/optionletstripper2.hpp>
#include <ql/termstructures/volatility/optionlet/spreadedoptionletvol.hpp>
#include <ql/termstructures/volatility/optionlet/strippedoptionletadapter.hpp>
#include <utility>


namespace QuantLib {

    OptionletStripper2::OptionletStripper2(
        const ext::shared_ptr<OptionletStripper1>& optionletStripper1,
        const Handle<CapFloorTermVolCurve>& atmCapFloorTermVolCurve)
    : OptionletStripper(optionletStripper1->termVolSurface(),
                        optionletStripper1->iborIndex(),
                        Handle<YieldTermStructure>(),
                        optionletStripper1->volatilityType(),
                        optionletStripper1->displacement(),
                        optionletStripper1->optionletFrequency()),
      stripper1_(optionletStripper1), atmCapFloorTermVolCurve_(atmCapFloorTermVolCurve),
      dc_(stripper1_->termVolSurface()->dayCounter()),
      nOptionExpiries_(atmCapFloorTermVolCurve->optionTenors().size()),
      atmCapFloorStrikes_(nOptionExpiries_), atmCapFloorPrices_(nOptionExpiries_),
      spreadsVolImplied_(nOptionExpiries_), caps_(nOptionExpiries_) {
        registerWith(stripper1_);
        registerWith(atmCapFloorTermVolCurve_);

        QL_REQUIRE(dc_ == atmCapFloorTermVolCurve->dayCounter(),
                   "different day counters provided");
    }

    void OptionletStripper2::performCalculations() const {

        //// optionletStripper data
        optionletDates_ = stripper1_->optionletFixingDates();
        optionletPaymentDates_ = stripper1_->optionletPaymentDates();
        optionletAccrualPeriods_ = stripper1_->optionletAccrualPeriods();
        optionletTimes_ = stripper1_->optionletFixingTimes();
        atmOptionletRate_ = stripper1_->atmOptionletRates();
        for (Size i=0; i<optionletTimes_.size(); ++i) {
            optionletStrikes_[i] = stripper1_->optionletStrikes(i);
            optionletVolatilities_[i] = stripper1_->optionletVolatilities(i);
        }

        // atmCapFloorTermVolCurve data
        const std::vector<Period>& optionExpiriesTenors =
                                    atmCapFloorTermVolCurve_->optionTenors();
        const std::vector<Time>& optionExpiriesTimes =
                                    atmCapFloorTermVolCurve_->optionTimes();

        for (Size j=0; j<nOptionExpiries_; ++j) {
            Volatility atmOptionVol = atmCapFloorTermVolCurve_->volatility(
                optionExpiriesTimes[j], 33.3333); // dummy strike
            ext::shared_ptr<BlackCapFloorEngine> engine(new
                    BlackCapFloorEngine(iborIndex_->forwardingTermStructure(),
                                        atmOptionVol, dc_));
            caps_[j] = MakeCapFloor(CapFloor::Cap,
                                    optionExpiriesTenors[j],
                                    iborIndex_,
                                    Null<Rate>(),
                                    0*Days).withPricingEngine(engine);
            atmCapFloorStrikes_[j] =
                caps_[j]->atmRate(**iborIndex_->forwardingTermStructure());
            atmCapFloorPrices_[j] = caps_[j]->NPV();
        }

        spreadsVolImplied_ = spreadsVolImplied();

        StrippedOptionletAdapter adapter(stripper1_);
        adapter.enableExtrapolation();

        Volatility unadjustedVol, adjustedVol;
        for (Size j=0; j<nOptionExpiries_; ++j) {
            for (Size i=0; i<optionletVolatilities_.size(); ++i) {
                if (i<=caps_[j]->floatingLeg().size()) {
                    unadjustedVol = adapter.volatility(optionletTimes_[i],
                                                       atmCapFloorStrikes_[j]);
                    adjustedVol = unadjustedVol + spreadsVolImplied_[j];

                    // insert adjusted volatility
                    auto previous =
                        std::lower_bound(optionletStrikes_[i].begin(),
                                         optionletStrikes_[i].end(),
                                         atmCapFloorStrikes_[j]);
                    Size insertIndex = previous - optionletStrikes_[i].begin();

                    optionletStrikes_[i].insert(
                                optionletStrikes_[i].begin() + insertIndex,
                                atmCapFloorStrikes_[j]);
                    optionletVolatilities_[i].insert(
                                optionletVolatilities_[i].begin() + insertIndex,
                                adjustedVol);
                }
            }
        }
    }

    std::vector<Volatility> OptionletStripper2::spreadsVolImplied() const {

        Brent solver;
        std::vector<Volatility> result(nOptionExpiries_);
        Volatility guess = 0.0001, minSpread = -0.1, maxSpread = 0.1;
        for (Size j=0; j<nOptionExpiries_; ++j) {
            ObjectiveFunction f(stripper1_, caps_[j], atmCapFloorPrices_[j]);
            solver.setMaxEvaluations(maxEvaluations_);
            Volatility root = solver.solve(f, accuracy_, guess,
                                           minSpread, maxSpread);
            result[j] = root;
        }
        return result;
    }

    std::vector<Volatility> OptionletStripper2::spreadsVol() const {
        calculate();
        return spreadsVolImplied_;
    }

    std::vector<Rate> OptionletStripper2::atmCapFloorStrikes() const{
        calculate();
        return atmCapFloorStrikes_;
    }

    std::vector<Real> OptionletStripper2::atmCapFloorPrices() const {
        calculate();
        return atmCapFloorPrices_;
    }

//==========================================================================//
//                 OptionletStripper2::ObjectiveFunction                    //
//==========================================================================//

    OptionletStripper2::ObjectiveFunction::ObjectiveFunction(
        const ext::shared_ptr<OptionletStripper1>& optionletStripper1,
        ext::shared_ptr<CapFloor> cap,
        Real targetValue)
    : cap_(std::move(cap)), targetValue_(targetValue) {
        ext::shared_ptr<OptionletVolatilityStructure> adapter(new
            StrippedOptionletAdapter(optionletStripper1));
        adapter->enableExtrapolation();

        // set an implausible value, so that calculation is forced
        // at first operator()(Volatility x) call
        spreadQuote_ = ext::make_shared<SimpleQuote>(-1.0);

        ext::shared_ptr<OptionletVolatilityStructure> spreadedAdapter(new
            SpreadedOptionletVolatility(Handle<OptionletVolatilityStructure>(
                adapter), Handle<Quote>(spreadQuote_)));

        ext::shared_ptr<BlackCapFloorEngine> engine(new
            BlackCapFloorEngine(
                optionletStripper1->iborIndex()->forwardingTermStructure(),
                Handle<OptionletVolatilityStructure>(spreadedAdapter)));

        cap_->setPricingEngine(engine);
    }

    Real OptionletStripper2::ObjectiveFunction::operator()(Volatility s) const
    {
        if (s!=spreadQuote_->value())
            spreadQuote_->setValue(s);
        return cap_->NPV()-targetValue_;
    }
}
]]></document_content>
  </document>
  <document index="42">
    <source>volatility/optionlet/optionletvolatilitystructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/optionlet/optionletvolatilitystructure.hpp>

namespace QuantLib {

    OptionletVolatilityStructure::OptionletVolatilityStructure(
                                                    BusinessDayConvention bdc,
                                                    const DayCounter& dc)
    : VolatilityTermStructure(bdc, dc) {}

    OptionletVolatilityStructure::OptionletVolatilityStructure(
                                                    const Date& referenceDate,
                                                    const Calendar& cal,
                                                    BusinessDayConvention bdc,
                                                    const DayCounter& dc)
    : VolatilityTermStructure(referenceDate, cal, bdc, dc) {}

    OptionletVolatilityStructure::OptionletVolatilityStructure(
                                                    Natural settlementDays,
                                                    const Calendar& cal,
                                                    BusinessDayConvention bdc,
                                                    const DayCounter& dc)
    : VolatilityTermStructure(settlementDays, cal, bdc, dc) {}

}
]]></document_content>
  </document>
  <document index="43">
    <source>volatility/optionlet/spreadedoptionletvol.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Ferdinando Ametrano
 Copyright (C) 2007 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/quote.hpp>
#include <ql/termstructures/volatility/optionlet/spreadedoptionletvol.hpp>
#include <ql/termstructures/volatility/spreadedsmilesection.hpp>
#include <utility>

namespace QuantLib {

    SpreadedOptionletVolatility::SpreadedOptionletVolatility(
        const Handle<OptionletVolatilityStructure>& baseVol, Handle<Quote> spread)
    : baseVol_(baseVol), spread_(std::move(spread)) {
        enableExtrapolation(baseVol->allowsExtrapolation());
        registerWith(baseVol_);
        registerWith(spread_);
    }

    ext::shared_ptr<SmileSection>
    SpreadedOptionletVolatility::smileSectionImpl(const Date& d) const {
        ext::shared_ptr<SmileSection> baseSmile =
            baseVol_->smileSection(d, true);
        return ext::shared_ptr<SmileSection>(new
            SpreadedSmileSection(baseSmile, spread_));
    }

    ext::shared_ptr<SmileSection>
    SpreadedOptionletVolatility::smileSectionImpl(Time optionTime) const {
        ext::shared_ptr<SmileSection> baseSmile =
            baseVol_->smileSection(optionTime, true);
        return ext::shared_ptr<SmileSection>(new
            SpreadedSmileSection(baseSmile, spread_));
    }

    Volatility SpreadedOptionletVolatility::volatilityImpl(Time t,
                                                           Rate s) const {
        return baseVol_->volatility(t, s, true) + spread_->value();
    }

}
]]></document_content>
  </document>
  <document index="44">
    <source>volatility/optionlet/strippedoptionlet.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Ferdinando Ametrano
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/makecapfloor.hpp>
#include <ql/pricingengines/capfloor/blackcapfloorengine.hpp>
#include <ql/termstructures/volatility/optionlet/strippedoptionlet.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <utility>

using std::vector;

namespace QuantLib {

    StrippedOptionlet::StrippedOptionlet(Natural settlementDays,
                                         const Calendar& calendar,
                                         BusinessDayConvention bdc,
                                         ext::shared_ptr<IborIndex> iborIndex,
                                         const vector<Date>& optionletDates,
                                         const vector<Rate>& strikes,
                                         vector<vector<Handle<Quote>>> v,
                                         DayCounter dc,
                                         VolatilityType type,
                                         Real displacement)
    : StrippedOptionlet(settlementDays,
                        calendar,
                        bdc,
                        std::move(iborIndex),
                        optionletDates,
                        vector<vector<Rate>>(optionletDates.size(), strikes),
                        std::move(v),
                        std::move(dc),
                        type,
                        displacement) {}

    StrippedOptionlet::StrippedOptionlet(Natural settlementDays,
                                         const Calendar& calendar,
                                         BusinessDayConvention bdc,
                                         ext::shared_ptr<IborIndex> iborIndex,
                                         const vector<Date>& optionletDates,
                                         const vector<vector<Rate>>& strikes,
                                         vector<vector<Handle<Quote>>> v,
                                         DayCounter dc,
                                         VolatilityType type,
                                         Real displacement)
    : calendar_(calendar), settlementDays_(settlementDays), businessDayConvention_(bdc),
      dc_(std::move(dc)), iborIndex_(std::move(iborIndex)), type_(type),
      displacement_(displacement), nOptionletDates_(optionletDates.size()),
      optionletDates_(optionletDates), optionletTimes_(nOptionletDates_),
      optionletAtmRates_(nOptionletDates_), optionletStrikes_(strikes),
      optionletVolQuotes_(std::move(v)) {
        checkInputs();

        for (Size i = 0; i < nOptionletDates_; ++i)
            optionletVolatilities_.emplace_back(strikes[i].size());

        registerWith(Settings::instance().evaluationDate());
        registerWithMarketData();

        Date refDate = calendar.advance(Settings::instance().evaluationDate(),
                                        settlementDays, Days);

        for (Size i=0; i<nOptionletDates_; ++i)
            optionletTimes_[i] = dc_.yearFraction(refDate, optionletDates_[i]);
    }

    void StrippedOptionlet::checkInputs() const {

        QL_REQUIRE(!optionletDates_.empty(), "empty optionlet tenor vector");
        QL_REQUIRE(nOptionletDates_==optionletVolQuotes_.size(),
                   "mismatch between number of option tenors (" <<
                   nOptionletDates_ << ") and number of volatility rows (" <<
                   optionletVolQuotes_.size() << ")");
        QL_REQUIRE(optionletDates_[0]>Settings::instance().evaluationDate(),
                   "first option date (" << optionletDates_[0] << ") is in the past");
        for (Size i=1; i<nOptionletDates_; ++i)
            QL_REQUIRE(optionletDates_[i]>optionletDates_[i-1],
                       "non increasing option dates: " << io::ordinal(i) <<
                       " is " << optionletDates_[i-1] << ", " <<
                       io::ordinal(i+1) << " is " << optionletDates_[i]);
        QL_REQUIRE(nOptionletDates_ == optionletStrikes_.size(),
                   "mismatch between number of option tenors (" << nOptionletDates_
                                                                << ") and number of strikes ("
                                                                << optionletStrikes_.size() << ")");
        for (Size i = 0; i < nOptionletDates_; ++i) {
            QL_REQUIRE(optionletStrikes_[i].size() == optionletVolQuotes_[i].size(),
                       "mismatch between number of option tenors ("
                           << nOptionletDates_ << ") and number of vol columns at date " << i
                           << " (" << optionletVolQuotes_[i].size());
            for (Size j = 1; j < optionletStrikes_[i].size(); ++j)
                QL_REQUIRE(optionletStrikes_[i][j - 1] < optionletStrikes_[i][j],
                           "non increasing strikes at date "
                               << i << ": " << io::ordinal(j) << " is "
                               << io::rate(optionletStrikes_[0][j - 1]) << ", "
                               << io::ordinal(j + 1) << " is "
                               << io::rate(optionletStrikes_[0][j]));
        }
    }

    void StrippedOptionlet::registerWithMarketData() {
        for (Size i = 0; i < nOptionletDates_; ++i)
            for (auto& j : optionletVolQuotes_[i])
                registerWith(j);
    }

    void StrippedOptionlet::performCalculations() const {
        for (Size i = 0; i < nOptionletDates_; ++i)
            for (Size j = 0; j < optionletVolQuotes_[i].size(); ++j)
                optionletVolatilities_[i][j] = optionletVolQuotes_[i][j]->value();
    }

    const vector<Rate>& StrippedOptionlet::optionletStrikes(Size i) const{
        QL_REQUIRE(i<optionletStrikes_.size(),
                   "index (" << i <<
                   ") must be less than optionletStrikes size (" <<
                   optionletStrikes_.size() << ")");
        return optionletStrikes_[i];
    }

    const vector<Volatility>&
    StrippedOptionlet::optionletVolatilities(Size i) const{
        calculate();
        QL_REQUIRE(i<optionletVolatilities_.size(),
                   "index (" << i <<
                   ") must be less than optionletVolatilities size (" <<
                   optionletVolatilities_.size() << ")");
        return optionletVolatilities_[i];
    }

    const vector<Date>& StrippedOptionlet::optionletFixingDates() const {
        calculate();
        return optionletDates_;
    }

    const vector<Time>& StrippedOptionlet::optionletFixingTimes() const {
        calculate();
        return optionletTimes_;
    }

    Size StrippedOptionlet::optionletMaturities() const {
        return nOptionletDates_;
    }

    const vector<Time>& StrippedOptionlet::atmOptionletRates() const {
        calculate();
        for (Size i=0; i<nOptionletDates_; ++i)
            optionletAtmRates_[i] = iborIndex_->fixing(optionletDates_[i], true);
        return optionletAtmRates_;
    }

    DayCounter StrippedOptionlet::dayCounter() const {
        return dc_;
    }

    Calendar StrippedOptionlet::calendar() const {
        return calendar_;
    }

    Natural StrippedOptionlet::settlementDays() const {
        return settlementDays_;
    }

    BusinessDayConvention StrippedOptionlet::businessDayConvention() const {
        return businessDayConvention_;
    }

    VolatilityType StrippedOptionlet::volatilityType() const {
        return type_;
    }

    Real StrippedOptionlet::displacement() const {
        return displacement_;
    }

}
]]></document_content>
  </document>
  <document index="45">
    <source>volatility/optionlet/strippedoptionletadapter.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2007 Katiuscia Manzoni
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/optionlet/strippedoptionletadapter.hpp>
#include <ql/termstructures/volatility/optionlet/optionletstripper.hpp>
#include <ql/termstructures/volatility/capfloor/capfloortermvolsurface.hpp>
#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/math/interpolations/sabrinterpolation.hpp>
#include <ql/termstructures/volatility/interpolatedsmilesection.hpp>
#include <ql/math/interpolations/cubicinterpolation.hpp>

namespace QuantLib {

    StrippedOptionletAdapter::StrippedOptionletAdapter(
                const ext::shared_ptr<StrippedOptionletBase>& s)
    : OptionletVolatilityStructure(s->settlementDays(),
                                   s->calendar(),
                                   s->businessDayConvention(),
                                   s->dayCounter()),
      optionletStripper_(s),
      nInterpolations_(s->optionletMaturities()),
      strikeInterpolations_(nInterpolations_) {
        registerWith(optionletStripper_);
    }

    ext::shared_ptr<SmileSection>
    StrippedOptionletAdapter::smileSectionImpl(Time t) const {
        std::vector< Rate > optionletStrikes =
            optionletStripper_->optionletStrikes(
                0); // strikes are the same for all times ?!
        std::vector< Real > stddevs;
        stddevs.reserve(optionletStrikes.size());
        for (Real optionletStrike : optionletStrikes) {
            stddevs.push_back(volatilityImpl(t, optionletStrike) * std::sqrt(t));
        }
        // Extrapolation may be a problem with splines, but since minStrike()
        // and maxStrike() are set, we assume that no one will use stddevs for
        // strikes outside these strikes
        CubicInterpolation::BoundaryCondition bc =
            optionletStrikes.size() >= 4 ? CubicInterpolation::Lagrange
                                         : CubicInterpolation::SecondDerivative;
        return ext::make_shared< InterpolatedSmileSection< Cubic > >(
            t, optionletStrikes, stddevs, Null< Real >(),
            Cubic(CubicInterpolation::Spline, false, bc, 0.0, bc, 0.0),
            Actual365Fixed(), volatilityType(), displacement());
    }

    Volatility StrippedOptionletAdapter::volatilityImpl(Time length,
                                                        Rate strike) const {
        calculate();

        std::vector<Volatility> vol(nInterpolations_);
        for (Size i=0; i<nInterpolations_; ++i)
            vol[i] = (*strikeInterpolations_[i])(strike, true);

        const std::vector<Time>& optionletTimes =
                                    optionletStripper_->optionletFixingTimes();
        ext::shared_ptr<LinearInterpolation> timeInterpolator(new
            LinearInterpolation(optionletTimes.begin(), optionletTimes.end(),
                                vol.begin()));
        return (*timeInterpolator)(length, true);
    }

    void StrippedOptionletAdapter::performCalculations() const {

        //const std::vector<Rate>& atmForward = optionletStripper_->atmOptionletRate();
        //const std::vector<Time>& optionletTimes = optionletStripper_->optionletTimes();

        for (Size i=0; i<nInterpolations_; ++i) {
            const std::vector<Rate>& optionletStrikes =
                optionletStripper_->optionletStrikes(i);
            const std::vector<Volatility>& optionletVolatilities =
                optionletStripper_->optionletVolatilities(i);
            //strikeInterpolations_[i] = ext::shared_ptr<SABRInterpolation>(new
            //            SABRInterpolation(optionletStrikes.begin(), optionletStrikes.end(),
            //                              optionletVolatilities.begin(),
            //                              optionletTimes[i], atmForward[i],
            //                              0.02,0.5,0.2,0.,
            //                              false, true, false, false
            //                              //alphaGuess_, betaGuess_,
            //                              //nuGuess_, rhoGuess_,
            //                              //isParameterFixed_[0],
            //                              //isParameterFixed_[1],
            //                              //isParameterFixed_[2],
            //                              //isParameterFixed_[3]
            //                              ////,
            //                              //vegaWeightedSmileFit_,
            //                              //endCriteria_,
            //                              //optMethod_
            //                              ));
            strikeInterpolations_[i] = ext::make_shared<LinearInterpolation>(optionletStrikes.begin(),
                                    optionletStrikes.end(),
                                    optionletVolatilities.begin());

            //QL_ENSURE(strikeInterpolations_[i]->endCriteria()!=EndCriteria::MaxIterations,
            //          "section calibration failed: "
            //          "option time " << optionletTimes[i] <<
            //          ": " <<
            //              ", alpha " <<  strikeInterpolations_[i]->alpha()<<
            //              ", beta "  <<  strikeInterpolations_[i]->beta() <<
            //              ", nu "    <<  strikeInterpolations_[i]->nu()   <<
            //              ", rho "   <<  strikeInterpolations_[i]->rho()  <<
            //              ", error " <<  strikeInterpolations_[i]->interpolationError()
            //              );

        }
    }

    Rate StrippedOptionletAdapter::minStrike() const {
        return optionletStripper_->optionletStrikes(0).front(); //FIX
    }

    Rate StrippedOptionletAdapter::maxStrike() const {
        return optionletStripper_->optionletStrikes(0).back(); //FIX
    }

    Date StrippedOptionletAdapter::maxDate() const {
        return optionletStripper_->optionletFixingDates().back();
    }

    VolatilityType StrippedOptionletAdapter::volatilityType() const {
        return optionletStripper_->volatilityType();
    }

    Real StrippedOptionletAdapter::displacement() const {
        return optionletStripper_->displacement();
    }
}
]]></document_content>
  </document>
  <document index="46">
    <source>volatility/sabr.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Mario Pucci
 Copyright (C) 2006 StatPro Italia srl
 Copyright (C) 2015 Peter Caspers
 Copyright (C) 2019 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/sabr.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/math/comparison.hpp>
#include <ql/math/functional.hpp>
#include <ql/errors.hpp>
#include <ql/termstructures/volatility/volatilitytype.hpp>
#if BOOST_VERSION >= 107800
#include <boost/math/special_functions/sign.hpp>
#include <boost/math/tools/cubic_roots.hpp>
#endif

namespace QuantLib {

    Real unsafeSabrLogNormalVolatility(
                              Rate strike,
                              Rate forward,
                              Time expiryTime,
                              Real alpha,
                              Real beta,
                              Real nu,
                              Real rho) {
        const Real oneMinusBeta = 1.0-beta;
        const Real A = std::pow(forward*strike, oneMinusBeta);
        const Real sqrtA= std::sqrt(A);
        Real logM;
        if (!close(forward, strike))
            logM = std::log(forward/strike);
        else {
            const Real epsilon = (forward-strike)/strike;
            logM = epsilon - .5 * epsilon * epsilon ;
        }
        const Real z = (nu/alpha)*sqrtA*logM;
        const Real B = 1.0-2.0*rho*z+z*z;
        const Real C = oneMinusBeta*oneMinusBeta*logM*logM;
        const Real tmp = (std::sqrt(B)+z-rho)/(1.0-rho);
        const Real xx = std::log(tmp);
        const Real D = sqrtA*(1.0+C/24.0+C*C/1920.0);
        const Real d = 1.0 + expiryTime *
            (oneMinusBeta*oneMinusBeta*alpha*alpha/(24.0*A)
                                + 0.25*rho*beta*nu*alpha/sqrtA
                                    +(2.0-3.0*rho*rho)*(nu*nu/24.0));

        Real multiplier;
        // computations become precise enough if the square of z worth
        // slightly more than the precision machine (hence the m)
        static const Real m = 10;
        if (std::fabs(z*z)>QL_EPSILON * m)
            multiplier = z/xx;
        else {
            multiplier = 1.0 - 0.5*rho*z - (3.0*rho*rho-2.0)*z*z/12.0;
        }
        return (alpha/D)*multiplier*d;
    }

    Real unsafeShiftedSabrVolatility(Rate strike,
                              Rate forward,
                              Time expiryTime,
                              Real alpha,
                              Real beta,
                              Real nu,
                              Real rho,
                              Real shift,
                              VolatilityType volatilityType) {
        if (volatilityType == VolatilityType::Normal) {
            return unsafeSabrNormalVolatility(strike + shift, forward + shift, expiryTime, alpha, beta, nu, rho);
        } else {
            return unsafeSabrLogNormalVolatility(strike + shift, forward + shift, expiryTime, alpha, beta, nu, rho);
        }
    }

    Real unsafeSabrNormalVolatility(
        Rate strike, Rate forward, Time expiryTime, Real alpha, Real beta, Real nu, Real rho) {
        const Real oneMinusBeta = 1.0 - beta;
        const Real minusBeta = -1.0 * beta;
        const Real A = std::pow(forward * strike, oneMinusBeta);
        const Real sqrtA = std::sqrt(A);
        Real logM;
        if (!close(forward, strike))
            logM = std::log(forward / strike);
        else {
            const Real epsilon = (forward - strike) / strike;
            logM = epsilon - .5 * epsilon * epsilon;
        }
        const Real z = (nu / alpha) * sqrtA * logM;
        const Real B = 1.0 - 2.0 * rho * z + z * z;
        const Real C = oneMinusBeta * oneMinusBeta * logM * logM;
        const Real D = logM * logM;
        const Real tmp = (std::sqrt(B) + z - rho) / (1.0 - rho);
        const Real xx = std::log(tmp);
        const Real E_1 = (1.0 + D / 24.0 + D * D / 1920.0);
        const Real E_2 = (1.0 + C / 24.0 + C * C / 1920.0);
        const Real E = E_1 / E_2;
        const Real d = 1.0 + expiryTime * (minusBeta * (2 - beta) * alpha * alpha / (24.0 * A) +
                                0.25 * rho * beta * nu * alpha / sqrtA +
                                (2.0 - 3.0 * rho * rho) * (nu * nu / 24.0));

        Real multiplier;
        // computations become precise enough if the square of z worth
        // slightly more than the precision machine (hence the m)
        static const Real m = 10;
        if (std::fabs(z * z) > QL_EPSILON * m)
            multiplier = z / xx;
        else {
            multiplier = 1.0 - 0.5 * rho * z - (3.0 * rho * rho - 2.0) * z * z / 12.0;
        }
        const Real F = alpha * std::pow(forward * strike, beta / 2.0);

       return F * E * multiplier * d;
    }

     Real unsafeSabrVolatility(Rate strike,
                              Rate forward,
                              Time expiryTime,
                              Real alpha,
                              Real beta,
                              Real nu,
                              Real rho,
                              VolatilityType volatilityType) {
        if (volatilityType == VolatilityType::Normal) {
            return unsafeSabrNormalVolatility(strike, forward, expiryTime, alpha, beta, nu, rho);
        } else {
            return unsafeSabrLogNormalVolatility(strike, forward, expiryTime, alpha, beta, nu, rho);
        }
     }

    void validateSabrParameters(Real alpha,
                                Real beta,
                                Real nu,
                                Real rho) {
        QL_REQUIRE(alpha>0.0, "alpha must be positive: "
                              << alpha << " not allowed");
        QL_REQUIRE(beta>=0.0 && beta<=1.0, "beta must be in (0.0, 1.0): "
                                         << beta << " not allowed");
        QL_REQUIRE(nu>=0.0, "nu must be non negative: "
                            << nu << " not allowed");
        QL_REQUIRE(rho*rho<1.0, "rho square must be less than one: "
                                << rho << " not allowed");
    }

    Real sabrVolatility(Rate strike,
                        Rate forward,
                        Time expiryTime,
                        Real alpha,
                        Real beta,
                        Real nu,
                        Real rho,
                        VolatilityType volatilityType) {
        QL_REQUIRE(strike>0.0, "strike must be positive: "
                               << io::rate(strike) << " not allowed");
        QL_REQUIRE(forward>0.0, "at the money forward rate must be "
                   "positive: " << io::rate(forward) << " not allowed");
        QL_REQUIRE(expiryTime>=0.0, "expiry time must be non-negative: "
                                   << expiryTime << " not allowed");
        validateSabrParameters(alpha, beta, nu, rho);
        return unsafeSabrVolatility(strike, forward, expiryTime, alpha, beta, nu, rho,
                                             volatilityType);
    }

    Real shiftedSabrVolatility(Rate strike,
                               Rate forward,
                               Time expiryTime,
                               Real alpha,
                               Real beta,
                               Real nu,
                               Real rho,
                               Real shift,
                               VolatilityType volatilityType) {
        QL_REQUIRE(strike + shift > 0.0, "strike+shift must be positive: "
                   << io::rate(strike) << "+" << io::rate(shift) << " not allowed");
        QL_REQUIRE(forward + shift > 0.0, "at the money forward rate + shift must be "
                   "positive: " << io::rate(forward) << " " << io::rate(shift) << " not allowed");
        QL_REQUIRE(expiryTime>=0.0, "expiry time must be non-negative: "
                                   << expiryTime << " not allowed");
        validateSabrParameters(alpha, beta, nu, rho);
        return unsafeShiftedSabrVolatility(strike, forward, expiryTime,
                                             alpha, beta, nu, rho,shift, volatilityType);
    }

    namespace {
        struct SabrFlochKennedyVolatility {
            Real F, alpha, beta, nu, rho, t;

            Real y(Real k) const {
                return -1.0/(1.0-beta)*(std::pow(F,1-beta)-std::pow(k,1-beta));
            }

            Real Dint(Real k) const {
                return 1/nu*std::log( ( std::sqrt(1+2*rho*nu/alpha*y(k)
                    + squared(nu/alpha*y(k)) )
                    - rho - nu/alpha*y(k) ) / (1-rho) );
            }

            Real D(Real k) const {
                return std::sqrt(alpha*alpha+2*alpha*rho*nu*y(k)
                    + squared(nu*y(k)))*std::pow(k,beta);
            }

            Real omega0(Real k) const {
                return std::log(F/k)/Dint(k);
            }

            Real operator()(Real k) const {
                const Real m = F/k;
                if (m > 1.0025 || m < 0.9975) {
                    return omega0(k)*(1+0.25*rho*nu*alpha*
                       (std::pow(k,beta)-std::pow(F,beta))/(k-F)*t)
                       -omega0(k)/squared(Dint(k))*(std::log(
                           omega0(k)) + 0.5*std::log((F*k/(D(F)*D(k))) ))*t;
                }
                else {
                    return taylorExpansion(k);
                }
            }

            Real taylorExpansion(Real k) const {
                const Real F2 = F*F;
                const Real alpha2 = alpha*alpha;
                const Real rho2 = rho*rho;
                return
                    (alpha*std::pow(F,-3 + beta)*(alpha2*squared(-1 + beta)*std::pow(F,2*beta)*t + 6*alpha*beta*nu*std::pow(F,1 + beta)*rho*t +
                        F2*(24 + nu*nu*(2 - 3*rho2)*t)))/24.0 +
                     (3*alpha2*alpha*std::pow(-1 + beta,3)*std::pow(F,3*beta)*t +
                        3*alpha2*(-1 + beta)*(-1 + 5*beta)*nu*std::pow(F,1 + 2*beta)*rho*t + nu*F2*F*rho*(24 + nu*nu*(-4 + 3*rho2)*t) +
                        alpha*std::pow(F,2 + beta)*(24*(-1 + beta) + nu*nu*(2*(-1 + beta) + 3*(1 + beta)*rho2)*t))/(48.*F2*F2) * (k-F) +
                    (std::pow(F,-5 - beta)*(alpha2*alpha2*std::pow(-1 + beta,3)*(-209 + 119*beta)*std::pow(F,4*beta)*t + 30*alpha2*alpha*(-1 + beta)*(9 + beta*(-37 + 18*beta))*nu*std::pow(F,1 + 3*beta)*rho*t -
                        30*alpha*nu*std::pow(F,3 + beta)*rho*(24 + nu*nu*(-4*(1 + beta) + 3*(1 + 2*beta)*rho2)*t) +
                        10*alpha2*std::pow(F,2 + 2*beta)*(24*(-4 + beta)*(-1 + beta) + nu*nu*(2*(-1 + beta)*(-7 + 4*beta) + 3*(-4 + beta*(-7 + 5*beta))*rho2)*t) +
                        nu*nu*F2*F2*(480 - 720*rho2 + nu*nu*(-64 + 75*rho2*(4 - 3*rho2))*t)))/(2880*alpha) * (k-F)*(k-F);
            }
        };
    }

    Real sabrFlochKennedyVolatility(Rate strike,
                                Rate forward,
                                Time expiryTime,
                                Real alpha,
                                Real beta,
                                Real nu,
                                Real rho) {
        const SabrFlochKennedyVolatility v =
            {forward, alpha, beta, nu, rho, expiryTime};

        return v(strike);
    }


    #if BOOST_VERSION >= 107800

    namespace {

        Real smallest_positive_root(Real c1, Real c2, Real c3, Real c4) {
            auto [r1, r2, r3] = boost::math::tools::cubic_roots(c1, c2, c3, c4);
            if (std::isnan(r3)) {
                // single root (or two equal ones), check that it's positive
                QL_REQUIRE(r1 > 0.0, "no positive root");
                return r1;
            } else {
                // three roots in non-decreasing order, return the first positive one
                QL_REQUIRE(r3 > 0.0, "no positive root");
                return r1 > 0.0 ? r1 : (r2 > 0.0 ? r2 : r3);
            }
        }

    }

    std::array<Real, 4> sabrGuess(Real k_m, Volatility vol_m,
                                  Real k_0, Volatility vol_0,
                                  Real k_p, Volatility vol_p,
                                  Rate forward,
                                  Time expiryTime,
                                  Real beta,
                                  Real shift,
                                  VolatilityType volatilityType) {

        // same variable names as in the equations for ease of reference:
        Real f = forward, b = shift, T = expiryTime;

        // change to log-moneyness

        Real z_m = std::log((k_m + b) / (f + b));
        Real z_0 = std::log((k_0 + b) / (f + b));
        Real z_p = std::log((k_p + b) / (f + b));

        // calculate atm, skew, curvature

        Real w_m = 1 / ((z_m - z_0) * (z_m - z_p));  // eq. (42) in the paper
        Real w_0 = 1 / ((z_0 - z_m) * (z_0 - z_p));  // eq. (43)
        Real w_p = 1 / ((z_p - z_m) * (z_p - z_0));  // eq. (44)

        Real sigma_0 = z_0 * z_p * w_m * vol_m + z_m * z_p * w_0 * vol_0 + z_m * z_0 * w_p * vol_p;         // (39)
        Real sigma_1 = - (z_0 + z_p) * w_m * vol_m - (z_m + z_p) * w_0 * vol_0 - (z_m + z_0) * w_p * vol_p; // (40)
        Real sigma_2 = 2 * w_m * vol_m + 2 * w_0 * vol_0 + 2 * w_p * vol_p;                                 // (41)

        switch (volatilityType) {
          case ShiftedLognormal: {

              // equations (32)

              Real alpha = sigma_0 * std::pow(f + b, 1.0-beta); // NOLINT(clang-analyzer-deadcode.DeadStores)
              Real nu2 =
                  3 * sigma_0 * sigma_2
                  - 0.5 * squared(1-beta) * sigma_0 * sigma_0
                  + 1.5 * squared(2*sigma_1 + (1-beta)*sigma_0);
              Real nu, rho;
              if (nu2 > 0.0) {
                  nu = std::sqrt(nu2);
                  rho = (1/nu) * (2*sigma_1 + (1-beta)*sigma_0);
              } else {
                  rho = boost::math::sign(2*sigma_1 + (1-beta)*sigma_0);
                  nu = (1/rho) * (2*sigma_1 + (1-beta)*sigma_0);
              }

              // coefficients of the polynomial in equation (33)

              Real c1 = squared(1 - beta) * T / (24 * std::pow(f + b, 2 - 2 * beta));
              Real c2 = rho * beta * nu * T / (4 * std::pow(f + b, 1 - beta));
              Real c3 = 1 + ((2 - 3 * rho*rho) / 24) * nu*nu * T;
              Real c4 = - sigma_0 * std::pow(f + b, 1-beta);

              try {
                  alpha = smallest_positive_root(c1, c2, c3, c4);
              } catch (Error&) {}

              return { alpha, beta, nu, rho };
          }
          case Normal: {

              // equations (37)

              Real alpha = sigma_0 * std::pow(f + b, -beta); // NOLINT(clang-analyzer-deadcode.DeadStores)
              Real nu2 = squared(1 / (f + b)) * (
                  3 * sigma_0 * sigma_2
                  - 0.5 * (beta*beta + beta) * (sigma_0*sigma_0)
                  - 3 * sigma_0 * (sigma_1 - 0.5 * beta * sigma_0)
                  + 1.5 * squared(2 * sigma_1 - beta * sigma_0)
              );
              Real nu, rho;
              if (nu2 > 0.0) {
                  nu = std::sqrt(nu2);
                  rho = (1 / (nu * (f + b))) * (2 * sigma_1 - beta * sigma_0);
              } else {
                  rho = boost::math::sign((1 / (f + b)) * (2 * sigma_1 - beta * sigma_0));
                  nu = (1 / (rho * (f + b))) * (2 * sigma_1 - beta * sigma_0);
              }

              // coefficients of the polynomial in equation (38)

              Real c1 = (beta * beta - 2 * beta) * T / (24 * std::pow(f + b, 2 - 2 * beta));
              Real c2 = rho * beta * nu * T / (4 * std::pow(f + b, 1 - beta));
              Real c3 = 1 + ((2 - 3 * rho*rho) / 24) * nu*nu * T;
              Real c4 = - sigma_0 * std::pow(f + b, -beta);

              try {
                  alpha = smallest_positive_root(c1, c2, c3, c4);
              } catch (Error&) {}

              return { alpha, beta, nu, rho };
          }
          default:
            QL_FAIL("unknown volatility type: " << Integer(volatilityType));
        }
    }

    #else

    std::array<Real, 4> sabrGuess(Real, Volatility,
                                  Real, Volatility,
                                  Real, Volatility,
                                  Rate,
                                  Time,
                                  Real,
                                  Real,
                                  VolatilityType) {
        QL_FAIL("Boost 1.78 or later is required for the implementation of this functionality");
    }

    #endif

}
]]></document_content>
  </document>
  <document index="47">
    <source>volatility/sabrinterpolatedsmilesection.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Cristina Duminuco
 Copyright (C) 2006 Franois du Vignaud
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/quotes/simplequote.hpp>
#include <ql/settings.hpp>
#include <ql/termstructures/volatility/sabrinterpolatedsmilesection.hpp>
#include <utility>

namespace QuantLib {

    SabrInterpolatedSmileSection::SabrInterpolatedSmileSection(
        const Date& optionDate,
        Handle<Quote> forward,
        const std::vector<Rate>& strikes,
        bool hasFloatingStrikes,
        Handle<Quote> atmVolatility,
        const std::vector<Handle<Quote> >& volHandles,
        Real alpha,
        Real beta,
        Real nu,
        Real rho,
        bool isAlphaFixed,
        bool isBetaFixed,
        bool isNuFixed,
        bool isRhoFixed,
        bool vegaWeighted,
        ext::shared_ptr<EndCriteria> endCriteria,
        ext::shared_ptr<OptimizationMethod> method,
        const DayCounter& dc,
        const Real shift)
    : SmileSection(optionDate, dc, Date(), ShiftedLognormal, shift), forward_(std::move(forward)),
      atmVolatility_(std::move(atmVolatility)), volHandles_(volHandles), strikes_(strikes),
      actualStrikes_(strikes), hasFloatingStrikes_(hasFloatingStrikes), vols_(volHandles.size()),
      alpha_(alpha), beta_(beta), nu_(nu), rho_(rho), isAlphaFixed_(isAlphaFixed),
      isBetaFixed_(isBetaFixed), isNuFixed_(isNuFixed), isRhoFixed_(isRhoFixed),
      vegaWeighted_(vegaWeighted), endCriteria_(std::move(endCriteria)), method_(std::move(method)),
      evaluationDate_(Settings::instance().evaluationDate()) {

        LazyObject::registerWith(forward_);
        LazyObject::registerWith(atmVolatility_);
        for (auto& volHandle : volHandles_)
            LazyObject::registerWith(volHandle);
    }

    SabrInterpolatedSmileSection::SabrInterpolatedSmileSection(
        const Date& optionDate,
        const Rate& forward,
        const std::vector<Rate>& strikes,
        bool hasFloatingStrikes,
        const Volatility& atmVolatility,
        const std::vector<Volatility>& volHandles,
        Real alpha,
        Real beta,
        Real nu,
        Real rho,
        bool isAlphaFixed,
        bool isBetaFixed,
        bool isNuFixed,
        bool isRhoFixed,
        bool vegaWeighted,
        ext::shared_ptr<EndCriteria> endCriteria,
        ext::shared_ptr<OptimizationMethod> method,
        const DayCounter& dc,
        const Real shift)
    : SmileSection(optionDate, dc, Date(), ShiftedLognormal, shift),
      forward_(Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(forward)))),
      atmVolatility_(Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(atmVolatility)))),
      volHandles_(volHandles.size()), strikes_(strikes), actualStrikes_(strikes),
      hasFloatingStrikes_(hasFloatingStrikes), vols_(volHandles.size()), alpha_(alpha), beta_(beta),
      nu_(nu), rho_(rho), isAlphaFixed_(isAlphaFixed), isBetaFixed_(isBetaFixed),
      isNuFixed_(isNuFixed), isRhoFixed_(isRhoFixed), vegaWeighted_(vegaWeighted),
      endCriteria_(std::move(endCriteria)), method_(std::move(method)),
      evaluationDate_(Settings::instance().evaluationDate()) {

        for (Size i = 0; i < volHandles_.size(); ++i)
            volHandles_[i] = Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(volHandles[i])));
    }

    void SabrInterpolatedSmileSection::createInterpolation() const {
         ext::shared_ptr<SABRInterpolation> tmp(new SABRInterpolation(
                     actualStrikes_.begin(), actualStrikes_.end(), vols_.begin(),
                     exerciseTime(), forwardValue_,
                     alpha_, beta_, nu_, rho_,
                     isAlphaFixed_, isBetaFixed_, isNuFixed_, isRhoFixed_, vegaWeighted_,
                     endCriteria_, method_, 0.0020, false, 50, shift()));
         swap(tmp, sabrInterpolation_);
    }

    void SabrInterpolatedSmileSection::performCalculations() const {
        forwardValue_ = forward_->value();
        vols_.clear();
        actualStrikes_.clear();
        // we populate the volatilities, skipping the invalid ones
        for (Size i=0; i<volHandles_.size(); ++i) {
            if (volHandles_[i]->isValid()) {
                if (hasFloatingStrikes_) {
                    actualStrikes_.push_back(forwardValue_ + strikes_[i]);
                    vols_.push_back(atmVolatility_->value() + volHandles_[i]->value());
                } else {
                    actualStrikes_.push_back(strikes_[i]);
                    vols_.push_back(volHandles_[i]->value());
                }
            }
        }
        // we are recreating the sabrinterpolation object unconditionnaly to
        // avoid iterator invalidation
        createInterpolation();
        sabrInterpolation_->update();
    }

    Real SabrInterpolatedSmileSection::varianceImpl(Real strike) const {
        calculate();
        Real v = (*sabrInterpolation_)(strike, true);
        return v*v*exerciseTime();
    }

}

]]></document_content>
  </document>
  <document index="48">
    <source>volatility/sabrsmilesection.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mario Pucci
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/sabrsmilesection.hpp>
#include <ql/termstructures/volatility/sabr.hpp>
#include <ql/utilities/dataformatters.hpp>

namespace QuantLib {

    SabrSmileSection::SabrSmileSection(Time timeToExpiry,
                                       Rate forward,
                                       const std::vector<Real>& sabrParams,
                                       const Real shift,
                                       VolatilityType volatilityType)
        : SmileSection(timeToExpiry,DayCounter(),
                       volatilityType,shift),
          forward_(forward), shift_(shift) {
        initialise(sabrParams);
    }

    SabrSmileSection::SabrSmileSection(const Date& d,
                                       Rate forward,
                                       const std::vector<Real>& sabrParams,
                                       const Date& referenceDate,
                                       const DayCounter& dc,
                                       const Real shift,
                                       VolatilityType volatilityType)
    : SmileSection(d, dc, referenceDate, volatilityType, shift),
      forward_(forward), shift_(shift) {
        initialise(sabrParams);
    }

    void SabrSmileSection::initialise(const std::vector<Real>& sabrParams) {

        alpha_ = sabrParams[0];
        beta_ = sabrParams[1];
        nu_ = sabrParams[2];
        rho_ = sabrParams[3];

        QL_REQUIRE(forward_ + shift_ > 0.0,
                   "at the money forward rate + shift must be "
                   "positive: "
                       << io::rate(forward_) << " with shift "
                       << io::rate(shift_) << " not allowed");
        validateSabrParameters(alpha_, beta_, nu_, rho_);
    }

     Real SabrSmileSection::varianceImpl(Rate strike) const {
        strike = std::max(0.00001 - shift(),strike);
        Volatility vol = unsafeShiftedSabrVolatility(
            strike, forward_, exerciseTime(), alpha_, beta_, nu_, rho_, shift_, volatilityType());
        return vol * vol * exerciseTime();
     }

     Real SabrSmileSection::volatilityImpl(Rate strike) const {
        strike = std::max(0.00001 - shift(),strike);
        return unsafeShiftedSabrVolatility(strike, forward_, exerciseTime(),
                                           alpha_, beta_, nu_, rho_, shift_, volatilityType());
     }
}
]]></document_content>
  </document>
  <document index="49">
    <source>volatility/smilesection.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mario Pucci
 Copyright (C) 2013, 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/comparison.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/settings.hpp>
#include <ql/termstructures/volatility/smilesection.hpp>
#include <utility>

using std::sqrt;

namespace QuantLib {

    void SmileSection::update() {
        if (isFloating_) {
            referenceDate_ = Settings::instance().evaluationDate();
            initializeExerciseTime();
        }
    }

    void SmileSection::initializeExerciseTime() const {
        QL_REQUIRE(exerciseDate_>=referenceDate_,
                   "expiry date (" << exerciseDate_ <<
                   ") must be greater than reference date (" <<
                   referenceDate_ << ")");
        exerciseTime_ = dc_.yearFraction(referenceDate_, exerciseDate_);
    }

    SmileSection::SmileSection(const Date& d,
                               DayCounter dc,
                               const Date& referenceDate,
                               const VolatilityType type,
                               const Rate shift)
    : exerciseDate_(d), dc_(std::move(dc)), volatilityType_(type), shift_(shift) {
        isFloating_ = referenceDate==Date();
        if (isFloating_) {
            registerWith(Settings::instance().evaluationDate());
            referenceDate_ = Settings::instance().evaluationDate();
        } else
            referenceDate_ = referenceDate;
        SmileSection::initializeExerciseTime();
    }

    SmileSection::SmileSection(Time exerciseTime,
                               DayCounter dc,
                               const VolatilityType type,
                               const Rate shift)
    : isFloating_(false), dc_(std::move(dc)), exerciseTime_(exerciseTime), volatilityType_(type),
      shift_(shift) {
        QL_REQUIRE(exerciseTime_>=0.0,
                   "expiry time must be positive: " <<
                   exerciseTime_ << " not allowed");
    }

    Real SmileSection::optionPrice(Rate strike,
                                   Option::Type type,
                                   Real discount) const {
        Real atm = atmLevel();
        QL_REQUIRE(atm != Null<Real>(),
                   "smile section must provide atm level to compute option price");
        // if lognormal or shifted lognormal,
        // for strike at -shift, return option price even if outside
        // minstrike, maxstrike interval
        if (volatilityType() == ShiftedLognormal)
            return blackFormula(type,strike,atm, std::fabs(strike+shift()) < QL_EPSILON ?
                            0.2 : Real(sqrt(variance(strike))),discount,shift());
        else
            return bachelierBlackFormula(type,strike,atm,sqrt(variance(strike)),discount);
    }

    Real SmileSection::digitalOptionPrice(Rate strike,
                                          Option::Type type,
                                          Real discount,
                                          Real gap) const {
        Real m = volatilityType() == ShiftedLognormal ? Real(-shift()) : -QL_MAX_REAL;
        Real kl = std::max(strike-gap/2.0,m);
        Real kr = kl+gap;
        return (type==Option::Call ? 1.0 : -1.0) *
            (optionPrice(kl,type,discount)-optionPrice(kr,type,discount)) / gap;
    }

    Real SmileSection::density(Rate strike, Real discount, Real gap) const {
        Real m = volatilityType() == ShiftedLognormal ? Real(-shift()) : -QL_MAX_REAL;
        Real kl = std::max(strike-gap/2.0,m);
        Real kr = kl+gap;
        return (digitalOptionPrice(kl,Option::Call,discount,gap) -
                digitalOptionPrice(kr,Option::Call,discount,gap)) / gap;
    }

    Real SmileSection::vega(Rate strike, Real discount) const {
        Real atm = atmLevel();
        QL_REQUIRE(atm != Null<Real>(),
                   "smile section must provide atm level to compute option vega");
        if (volatilityType() == ShiftedLognormal)
            return blackFormulaVolDerivative(strike,atmLevel(),
                                             sqrt(variance(strike)),
                                             exerciseTime(),discount,shift())*0.01;
        else
            QL_FAIL("vega for normal smilesection not yet implemented");
    }

    Real SmileSection::volatility(Rate strike, VolatilityType volatilityType,
                                  Real shift) const {
        if(volatilityType == volatilityType_ && close(shift,this->shift()))
            return volatility(strike);
        Real atm = atmLevel();
        QL_REQUIRE(atm != Null<Real>(),
                   "smile section must provide atm level to compute converted volatilties");
        Option::Type type = strike >= atm ? Option::Call : Option::Put;
        Real premium = optionPrice(strike,type);
        Real premiumAtm = optionPrice(atm,type);
        if (volatilityType == ShiftedLognormal) {
            try {
                return blackFormulaImpliedStdDev(type, strike, atm, premium,
                                                 1.0, shift) /
                       std::sqrt(exerciseTime());
            } catch(...) {
                return blackFormulaImpliedStdDevChambers(
                    type, strike, atm, premium, premiumAtm, 1.0, shift) /
                       std::sqrt(exerciseTime());
            }
        } else {
                return bachelierBlackFormulaImpliedVol(type, strike, atm,
                                                       exerciseTime(), premium);
            }
    }
}
]]></document_content>
  </document>
  <document index="50">
    <source>volatility/smilesectionutils.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2015, 2018 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/smilesectionutils.hpp>
#include <ql/math/comparison.hpp>
#include <algorithm>

namespace QuantLib {

    SmileSectionUtils::SmileSectionUtils(const SmileSection &section,
                                         const std::vector<Real> &moneynessGrid,
                                         const Real atm,
                                         const bool deleteArbitragePoints) {

        if (!moneynessGrid.empty()) {
            QL_REQUIRE(
                section.volatilityType() == Normal || moneynessGrid[0] >= 0.0,
                "moneyness grid should only contain non negative values ("
                    << moneynessGrid[0] << ")");
            for (Size i = 0; i < moneynessGrid.size() - 1; i++) {
                QL_REQUIRE(moneynessGrid[i] < moneynessGrid[i + 1],
                           "moneyness grid should contain strictly increasing "
                           "values ("
                               << moneynessGrid[i] << ","
                               << moneynessGrid[i + 1] << " at indices " << i
                               << ", " << i + 1 << ")");
            }
        }

        if (atm == Null<Real>()) {
            f_ = section.atmLevel();
            QL_REQUIRE(f_ != Null<Real>(),
                       "atm level must be provided by source section or given "
                       "in the constructor");
        } else {
            f_ = atm;
        }

        std::vector<Real> tmp;

        static const Real defaultMoney[] = { 0.0,  0.01, 0.05, 0.10, 0.25, 0.40,
                                             0.50, 0.60, 0.70, 0.80, 0.90, 1.0,
                                             1.25, 1.5,  1.75, 2.0,  5.0,  7.5,
                                             10.0, 15.0, 20.0 };
        static const Real defaultMoneyNormal[] = {
            -0.20,  -0.15,  -0.10,  -0.075,  -0.05,   -0.04,   -0.03,
            -0.02,  -0.015, -0.01,  -0.0075, -0.0050, -0.0025, 0.0,
            0.0025, 0.0050, 0.0075, 0.01,    0.015,   0.02,    0.03,
            0.04,   0.05,   0.075,  0.10,    0.15,    0.20
        };

        if (moneynessGrid.empty()) {
            tmp = section.volatilityType() == Normal
                      ? std::vector<Real>(defaultMoneyNormal,
                                          defaultMoneyNormal + 27)
                      : std::vector<Real>(defaultMoney, defaultMoney + 21);
        }
        else
            tmp = std::vector<Real>(moneynessGrid);

        Real shift = section.shift();

        if (section.volatilityType() == ShiftedLognormal && tmp[0] > QL_EPSILON) {
            m_.push_back(0.0);
            k_.push_back(-shift);
        }

        bool minStrikeAdded = false, maxStrikeAdded = false;
        for (Real& i : tmp) {
            Real k = section.volatilityType() == Normal ? Real(f_ + i) : Real(i * (f_ + shift) - shift);
            if ((section.volatilityType() == ShiftedLognormal && i <= QL_EPSILON) ||
                (k >= section.minStrike() && k <= section.maxStrike())) {
                if (!minStrikeAdded || !close(k, section.minStrike())) {
                    m_.push_back(i);
                    k_.push_back(k);
                }
                if (close(k, section.maxStrike()))
                    maxStrikeAdded = true;
            } else { // if the section provides a limited strike range
                     // we put the respective endpoint in our grid
                     // in order to not loose too much information
                if (k < section.minStrike() && !minStrikeAdded) {
                    m_.push_back(section.volatilityType() == Normal
                                     ? Real(section.minStrike() - f_)
                                     : Real((section.minStrike() + shift) / f_));
                    k_.push_back(section.minStrike());
                    minStrikeAdded = true;
                }
                if (k > section.maxStrike() && !maxStrikeAdded) {
                    m_.push_back(section.volatilityType() == Normal
                                     ? Real(section.maxStrike() - f_)
                                     : Real((section.maxStrike() + shift) / f_));
                    k_.push_back(section.maxStrike());
                    maxStrikeAdded = true;
                }
            }
        }

        // only known for shifted lognormal vols, otherwise we include
        // the lower strike in the loop below
        if(section.volatilityType() == ShiftedLognormal)
            c_.push_back(f_ + shift);

        for (Size i = (section.volatilityType() == Normal ? 0 : 1);
             i < k_.size(); i++) {
            c_.push_back(section.optionPrice(k_[i], Option::Call, 1.0));
        }

        Size centralIndex =
            std::upper_bound(m_.begin(), m_.end(),
                             (section.volatilityType() == Normal ? 0.0 : 1.0) -
                                 QL_EPSILON) -
            m_.begin();
        QL_REQUIRE(centralIndex < k_.size() - 1 && centralIndex > 1,
                   "Atm point in moneyness grid ("
                       << centralIndex << ") too close to boundary.");

        // shift central index to the right if necessary
        // (sometimes even the atm point lies in an arbitrageable area)

        while (!af(centralIndex, centralIndex, centralIndex + 1) &&
               centralIndex < k_.size() - 1)
            centralIndex++;

        QL_REQUIRE(centralIndex < k_.size(),
                   "central index is at right boundary");

        leftIndex_ = centralIndex;
        rightIndex_ = centralIndex;

        bool done = false;
        while (!done) {

            bool isAf = true;
            done = true;

            while (isAf && rightIndex_ < k_.size() - 1) {
                rightIndex_++;
                isAf = af(leftIndex_, rightIndex_, rightIndex_) &&
                       af(leftIndex_, rightIndex_ - 1, rightIndex_);
            }
            if (!isAf)
                rightIndex_--;

            isAf = true;
            while (isAf && leftIndex_ > 1) {
                leftIndex_--;
                isAf = af(leftIndex_, leftIndex_, rightIndex_) &&
                       af(leftIndex_, leftIndex_ + 1, rightIndex_);
            }
            if (!isAf)
                leftIndex_++;

            if (rightIndex_ < leftIndex_)
                rightIndex_ = leftIndex_;

            if (deleteArbitragePoints && leftIndex_ > 1) {
                m_.erase(m_.begin() + leftIndex_ - 1);
                k_.erase(k_.begin() + leftIndex_ - 1);
                c_.erase(c_.begin() + leftIndex_ - 1);
                leftIndex_--;
                rightIndex_--;
                done = false;
            }
            if (deleteArbitragePoints && rightIndex_ < k_.size() - 1) {
                m_.erase(m_.begin() + rightIndex_ + 1);
                k_.erase(k_.begin() + rightIndex_ + 1);
                c_.erase(c_.begin() + rightIndex_ + 1);
                rightIndex_--;
                done = false;
            }
        }

        QL_REQUIRE(rightIndex_ > leftIndex_,
                   "arbitrage free region must at least contain two "
                   "points (only index is "
                       << leftIndex_ << ")");

    }

    std::pair<Real, Real> SmileSectionUtils::arbitragefreeRegion() const {
        return {k_[leftIndex_], k_[rightIndex_]};
    }

    std::pair<Size, Size> SmileSectionUtils::arbitragefreeIndices() const {
        return {leftIndex_, rightIndex_};
    }

    bool SmileSectionUtils::af(const Size i0, const Size i,
                               const Size i1) const {
        if (i == 0)
            return true;
        Size im = i - 1 >= i0 ? i - 1 : 0;
        Real q1 = (c_[i] - c_[im]) / (k_[i] - k_[im]);
        if (q1 < -1.0 || q1 > 0.0)
            return false;
        if (i >= i1)
            return true;
        Real q2 = (c_[i + 1] - c_[i]) / (k_[i + 1] - k_[i]);
        return q1 <= q2 && q2 <= 0.0;
    }
}
]]></document_content>
  </document>
  <document index="51">
    <source>volatility/spreadedsmilesection.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mario Pucci

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/quote.hpp>
#include <ql/termstructures/volatility/spreadedsmilesection.hpp>
#include <utility>

namespace QuantLib {

    SpreadedSmileSection::SpreadedSmileSection(ext::shared_ptr<SmileSection> underlyingSection,
                                               Handle<Quote> spread)
    : underlyingSection_(std::move(underlyingSection)), spread_(std::move(spread)) {
        registerWith(underlyingSection_);
        registerWith(spread_);
    }

    Volatility SpreadedSmileSection::volatilityImpl(Rate k) const {
        return underlyingSection_->volatility(k) + spread_->value();
    }

}
]]></document_content>
  </document>
  <document index="52">
    <source>volatility/swaption/cmsmarket.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2006, 2007 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflows.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/instruments/makecms.hpp>
#include <ql/instruments/swap.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/swaption/cmsmarket.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

using std::vector;

namespace QuantLib {

    CmsMarket::CmsMarket(vector<Period> swapLengths,
                         vector<ext::shared_ptr<SwapIndex> > swapIndexes,
                         ext::shared_ptr<IborIndex> iborIndex,
                         const vector<vector<Handle<Quote> > >& bidAskSpreads,
                         const vector<ext::shared_ptr<CmsCouponPricer> >& pricers,
                         Handle<YieldTermStructure> discountingTS)
    : swapLengths_(std::move(swapLengths)), swapIndexes_(std::move(swapIndexes)),
      iborIndex_(std::move(iborIndex)), bidAskSpreads_(bidAskSpreads), pricers_(pricers),
      discTS_(std::move(discountingTS)),

      nExercise_(swapLengths_.size()), nSwapIndexes_(swapIndexes_.size()),
      swapTenors_(nSwapIndexes_),

      spotFloatLegNPV_(nExercise_, nSwapIndexes_), spotFloatLegBPS_(nExercise_, nSwapIndexes_),

      mktBidSpreads_(nExercise_, nSwapIndexes_), mktAskSpreads_(nExercise_, nSwapIndexes_),

      mktSpreads_(nExercise_, nSwapIndexes_), mdlSpreads_(nExercise_, nSwapIndexes_),
      errSpreads_(nExercise_, nSwapIndexes_),

      mktSpotCmsLegNPV_(nExercise_, nSwapIndexes_), mdlSpotCmsLegNPV_(nExercise_, nSwapIndexes_),
      errSpotCmsLegNPV_(nExercise_, nSwapIndexes_),

      mktFwdCmsLegNPV_(nExercise_, nSwapIndexes_), mdlFwdCmsLegNPV_(nExercise_, nSwapIndexes_),
      errFwdCmsLegNPV_(nExercise_, nSwapIndexes_),

      spotSwaps_(nExercise_, vector<ext::shared_ptr<Swap> >(nSwapIndexes_)),
      fwdSwaps_(nExercise_, vector<ext::shared_ptr<Swap> >(nSwapIndexes_)) {
        QL_REQUIRE(2 * nSwapIndexes_ == bidAskSpreads[0].size(),
                   "2*nSwapIndexes_ (" << 2 * nSwapIndexes_
                                       << ") != bidAskSpreads columns() ("
                                       << bidAskSpreads[0].size() << ")");
        QL_REQUIRE(nExercise_ == bidAskSpreads.size(),
                   "nExercise_ (" << nExercise_ << ") != bidAskSpreads rows() ("
                                  << bidAskSpreads.size() << ")");
        QL_REQUIRE(nSwapIndexes_ == pricers.size(),
                   "nSwapIndexes_ (" << nSwapIndexes_ << ") != pricers ("
                                     << pricers_.size() << ")");

        for (Size j=0; j<nSwapIndexes_; ++j) {
            swapTenors_[j] = swapIndexes_[j]->tenor();
            // pricers
            registerWith(pricers_[j]);
            for (Size i=0; i<nExercise_; ++i) {
                // market Spread
                registerWith(bidAskSpreads_[i][j*2]);
                registerWith(bidAskSpreads_[i][j*2+1]);
            }
        }

        Period start(0, Years);
        for (Size i=0; i<nExercise_; ++i) {
            if (i>0) start = swapLengths_[i-1];
            for (Size j=0; j<nSwapIndexes_; ++j) {
                // never evaluate the spot swap, only its ibor floating leg
                spotSwaps_[i][j] = MakeCms(swapLengths_[i],
                                           swapIndexes_[j],
                                           iborIndex_, 0.0,
                                           Period())
                                   .operator ext::shared_ptr<Swap>();
                fwdSwaps_[i][j]  = MakeCms(swapLengths_[i]-start,
                                           swapIndexes_[j],
                                           iborIndex_, 0.0,
                                           start)
                                   .withCmsCouponPricer(pricers_[j])
                                   .withDiscountingTermStructure(discTS_)
                                   .operator ext::shared_ptr<Swap>();
            }
        }
        // probably useless
        CmsMarket::performCalculations();
    }

    void CmsMarket::performCalculations() const {
        for (Size j=0; j<nSwapIndexes_; ++j) {
          Real mktPrevPart = 0.0, mdlPrevPart = 0.0;
          for (Size i=0; i<nExercise_; ++i) {

            // **** market

            mktBidSpreads_[i][j] = bidAskSpreads_[i][j*2]->value();
            mktAskSpreads_[i][j] = bidAskSpreads_[i][j*2+1]->value();
            mktSpreads_[i][j] = (mktBidSpreads_[i][j]+mktAskSpreads_[i][j])/2;

            const Leg& spotFloatLeg = spotSwaps_[i][j]->leg(1);
            spotFloatLegNPV_[i][j] = CashFlows::npv(spotFloatLeg,
                                                    **discTS_,
                                                    false, discTS_->referenceDate());
            spotFloatLegBPS_[i][j] = CashFlows::bps(spotFloatLeg,
                                                    **discTS_,
                                                    false, discTS_->referenceDate());

            // imply the spot CMS leg NPV from the spot ibor floating leg NPV
            mktSpotCmsLegNPV_[i][j] = -(spotFloatLegNPV_[i][j] +
                                spotFloatLegBPS_[i][j]*mktSpreads_[i][j]/1e-4);
            // fwd CMS legs can be computed as differences between spot legs
            mktFwdCmsLegNPV_[i][j] = mktSpotCmsLegNPV_[i][j] - mktPrevPart;
            mktPrevPart = mktSpotCmsLegNPV_[i][j];

            // **** model

            // calculate the forward swap (the time consuming part)
            mdlFwdCmsLegNPV_[i][j] = fwdSwaps_[i][j]->legNPV(0);
            errFwdCmsLegNPV_[i][j] = mdlFwdCmsLegNPV_[i][j] -
                                                mktFwdCmsLegNPV_[i][j];

            // spot CMS legs can be computed as incremental sum of forward legs
            mdlSpotCmsLegNPV_[i][j] = mdlPrevPart + mdlFwdCmsLegNPV_[i][j];
            mdlPrevPart = mdlSpotCmsLegNPV_[i][j];
            errSpotCmsLegNPV_[i][j] = mdlSpotCmsLegNPV_[i][j] -
                                                mktSpotCmsLegNPV_[i][j];

            // equilibriums spread over ibor leg
            Real npv = spotFloatLegNPV_[i][j] + mdlSpotCmsLegNPV_[i][j];
            mdlSpreads_[i][j] = - npv/spotFloatLegBPS_[i][j]*1e-4;
            errSpreads_[i][j] = mdlSpreads_[i][j] - mktSpreads_[i][j];
          }
        }
    }

    void CmsMarket::reprice(const Handle<SwaptionVolatilityStructure> &v,
                            Real meanReversion) {
        Handle<Quote> meanReversionQuote(
            ext::make_shared<SimpleQuote>(meanReversion));
        for (Size j = 0; j < nSwapIndexes_; ++j) {
            // ??
            // set new volatility structure and new mean reversion
            pricers_[j]->setSwaptionVolatility(v);
            if (meanReversion != Null<Real>()) {
                ext::shared_ptr<MeanRevertingPricer> p =
                    ext::dynamic_pointer_cast<MeanRevertingPricer>(
                        pricers_[j]);
                QL_REQUIRE(p != nullptr, "mean reverting pricer required at index " << j);
                p->setMeanReversion(meanReversionQuote);
            }
        }
        performCalculations();
    }

    Real CmsMarket::weightedFwdNpvError(const Matrix& w) {
        performCalculations();
        return weightedMean(errFwdCmsLegNPV_, w);
    }

    Real CmsMarket::weightedSpotNpvError(const Matrix& w) {
        performCalculations();
        return weightedMean(errSpotCmsLegNPV_, w);
    }

    Real CmsMarket::weightedSpreadError(const Matrix& w) {
        performCalculations();
        return weightedMean(errSpreads_, w);
    }

    // array of errors to be used by Levenberg-Marquardt optimization

    Array CmsMarket::weightedFwdNpvErrors(const Matrix& w) {
        performCalculations();
        return weightedMeans(errFwdCmsLegNPV_, w);
    }

    Array CmsMarket::weightedSpotNpvErrors(const Matrix& w) {
        performCalculations();
        return weightedMeans(errSpotCmsLegNPV_, w);
    }

    Array CmsMarket::weightedSpreadErrors(const Matrix& w) {
        performCalculations();
        return weightedMeans(errSpreads_, w);
    }

    Real CmsMarket::weightedMean(const Matrix& var, const Matrix& w) const {
        Real mean = 0.0;
        for (Size i=0; i<nExercise_; ++i) {
            for (Size j=0; j<nSwapIndexes_; ++j) {
                mean += w[i][j]*var[i][j]*var[i][j];
            }
        }
        mean = std::sqrt(mean/(nExercise_*nSwapIndexes_));
        return mean;
    }

    Array CmsMarket::weightedMeans(const Matrix& var, const Matrix& w) const {
        Array weightedVars(nExercise_*nSwapIndexes_);
        for (Size i=0; i<nExercise_; ++i) {
            for (Size j=0; j<nSwapIndexes_; ++j) {
                weightedVars[i*nSwapIndexes_+j] = std::sqrt(w[i][j])*var[i][j];
            }
        }
        return weightedVars;
    }

    Matrix CmsMarket::browse() const {
        calculate();
        //Matrix result(nExercise_*nSwapIndexes_, 15);
        Matrix result(nExercise_*nSwapIndexes_, 14);
            for (Size j=0; j<nSwapIndexes_; ++j) {
                for (Size i=0; i<nExercise_; ++i) {
                result[j*nExercise_+i][0] = swapTenors_[j].length();
                result[j*nExercise_+i][1] = swapLengths_[i].length();

                // Spreads
                result[j*nExercise_+i][2] = mktBidSpreads_[i][j]*10000;
                result[j*nExercise_+i][3] = mktAskSpreads_[i][j]*10000;
                result[j*nExercise_+i][4] = mktSpreads_[i][j]*10000;
                result[j*nExercise_+i][5] = mdlSpreads_[i][j]*10000;
                result[j*nExercise_+i][6] = errSpreads_[i][j]*10000;
                if (mdlSpreads_[i][j]>mktAskSpreads_[i][j])
                    result[j*nExercise_+i][7] = (mdlSpreads_[i][j] -
                                                mktAskSpreads_[i][j])*10000;
                else if (mdlSpreads_[i][j]<mktBidSpreads_[i][j])
                    result[j*nExercise_+i][7] = (mktBidSpreads_[i][j] -
                                                mdlSpreads_[i][j])*10000;
                else
                    result[j*nExercise_+i][7] = 0.0;

                // spot CMS Leg NPVs
                result[j*nExercise_+i][ 8] = mktSpotCmsLegNPV_[i][j];
                result[j*nExercise_+i][ 9] = mdlSpotCmsLegNPV_[i][j];
                result[j*nExercise_+i][10] = errSpotCmsLegNPV_[i][j];

                // forward CMS Leg NPVs
                result[j*nExercise_+i][11] = mktFwdCmsLegNPV_[i][j];
                result[j*nExercise_+i][12] = mdlFwdCmsLegNPV_[i][j];
                result[j*nExercise_+i][13] = errFwdCmsLegNPV_[i][j];
            }
        }
        return result;
    }
}
]]></document_content>
  </document>
  <document index="53">
    <source>volatility/swaption/cmsmarketcalibration.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2006, 2007 Giorgio Facchinetti
 Cpoyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/swaption/cmsmarketcalibration.hpp>
#include <ql/termstructures/volatility/swaption/cmsmarket.hpp>
#include <ql/termstructures/volatility/swaption/sabrswaptionvolatilitycube.hpp>
#include <ql/math/optimization/problem.hpp>
#include <ql/math/optimization/constraint.hpp>

namespace {
    using namespace QuantLib;

    class ObjectiveFunction : public CostFunction {
      public:
        explicit ObjectiveFunction(CmsMarketCalibration *smileAndCms)
            : smileAndCms_(smileAndCms), volCube_(smileAndCms->volCube_),
              cmsMarket_(smileAndCms->cmsMarket_),
              weights_(smileAndCms->weights_),
              calibrationType_(smileAndCms->calibrationType_) {};

        Real value(const Array& x) const override;
        Array values(const Array& x) const override;

      protected:
        Real switchErrorFunctionOnCalibrationType() const;
        Array switchErrorsFunctionOnCalibrationType() const;

        CmsMarketCalibration *smileAndCms_;
        Handle<SwaptionVolatilityStructure> volCube_;
        ext::shared_ptr<CmsMarket> cmsMarket_;
        Matrix weights_;
        CmsMarketCalibration::CalibrationType calibrationType_;

      private:
        virtual void updateVolatilityCubeAndCmsMarket(const Array &x) const;
    };

    class ObjectiveFunction2 : public ObjectiveFunction {
      public:
        ObjectiveFunction2(CmsMarketCalibration *smileAndCms,
                           Real fixedMeanReversion)
            : ObjectiveFunction(smileAndCms),
              fixedMeanReversion_(fixedMeanReversion) {};

      private:
        void updateVolatilityCubeAndCmsMarket(const Array& x) const override;
        Real fixedMeanReversion_;
    };

    class ObjectiveFunction3 : public ObjectiveFunction {
      public:
        explicit ObjectiveFunction3(CmsMarketCalibration *smileAndCms)
            : ObjectiveFunction(smileAndCms) {};

      private:
        void updateVolatilityCubeAndCmsMarket(const Array& x) const override;
    };

    class ObjectiveFunction4 : public ObjectiveFunction {
      public:
        ObjectiveFunction4(CmsMarketCalibration *smileAndCms,
                           Real fixedMeanReversion)
            : ObjectiveFunction(smileAndCms),
              fixedMeanReversion_(fixedMeanReversion) {};

      private:
        void updateVolatilityCubeAndCmsMarket(const Array& x) const override;
        Real fixedMeanReversion_;
    };

    class ObjectiveFunction5 : public ObjectiveFunction {
      public:
        ObjectiveFunction5(CmsMarketCalibration *smileAndCms,
                           Real fixedMeanReversion)
            : ObjectiveFunction(smileAndCms),
              fixedMeanReversion_(fixedMeanReversion) {};

      private:
        void updateVolatilityCubeAndCmsMarket(const Array& x) const override;
        Real fixedMeanReversion_;
    };

    class ObjectiveFunction6 : public ObjectiveFunction {
      public:
        explicit ObjectiveFunction6(CmsMarketCalibration *smileAndCms)
            : ObjectiveFunction(smileAndCms) {};

      private:
        void updateVolatilityCubeAndCmsMarket(const Array& x) const override;
    };

    //===========================================================================//
    //        ObjectiveFunction (constant beta, free mean reversion)             //
    //===========================================================================//

    Real ObjectiveFunction::value(const Array &x) const {
        updateVolatilityCubeAndCmsMarket(x);
        return switchErrorFunctionOnCalibrationType();
    }

    Array ObjectiveFunction::values(const Array &x) const {
        updateVolatilityCubeAndCmsMarket(x);
        return switchErrorsFunctionOnCalibrationType();
    }

    void
    ObjectiveFunction::updateVolatilityCubeAndCmsMarket(const Array &x) const {
        const std::vector<Period> &swapTenors = cmsMarket_->swapTenors();
        Size nSwapTenors = swapTenors.size();
        QL_REQUIRE(nSwapTenors + 1 == x.size(),
                   "bad calibration guess nSwapTenors+1 != x.size()");
        const ext::shared_ptr<SabrSwaptionVolatilityCube> volCubeBySabr =
            ext::dynamic_pointer_cast<SabrSwaptionVolatilityCube>(*volCube_);
        for (Size i = 0; i < nSwapTenors; ++i)
            volCubeBySabr->recalibration(CmsMarketCalibration::betaTransformDirect(x[i]),
                                         swapTenors[i]);
        Real meanReversion =
            CmsMarketCalibration::reversionTransformDirect(x[nSwapTenors]);
        cmsMarket_->reprice(volCube_, meanReversion);
    }

    Real ObjectiveFunction::switchErrorFunctionOnCalibrationType() const {
        switch (calibrationType_) {
        case CmsMarketCalibration::OnSpread:
            return cmsMarket_->weightedSpreadError(weights_);
        case CmsMarketCalibration::OnPrice:
            return cmsMarket_->weightedSpotNpvError(weights_);
        case CmsMarketCalibration::OnForwardCmsPrice:
            return cmsMarket_->weightedFwdNpvError(weights_);
        default:
            QL_FAIL("unknown/illegal calibration type");
        }
    }

    Array ObjectiveFunction::switchErrorsFunctionOnCalibrationType() const {
        switch (calibrationType_) {
        case CmsMarketCalibration::OnSpread:
            return cmsMarket_->weightedSpreadErrors(weights_);
        case CmsMarketCalibration::OnPrice:
            return cmsMarket_->weightedSpotNpvErrors(weights_);
        case CmsMarketCalibration::OnForwardCmsPrice:
            return cmsMarket_->weightedFwdNpvErrors(weights_);
        default:
            QL_FAIL("unknown/illegal calibration type");
        }
    }

    //===========================================================================//
    //        ObjectiveFunction2 (constant beta, fixed mean reversion)           //
    //===========================================================================//

    void
    ObjectiveFunction2::updateVolatilityCubeAndCmsMarket(const Array &x) const {
        const std::vector<Period> &swapTenors = cmsMarket_->swapTenors();
        Size nSwapTenors = swapTenors.size();
        QL_REQUIRE(nSwapTenors == x.size(),
                   "bad calibration guess nSwapTenors != x.size()");
        const ext::shared_ptr<SabrSwaptionVolatilityCube> volCubeBySabr =
            ext::dynamic_pointer_cast<SabrSwaptionVolatilityCube>(*volCube_);
        for (Size i = 0; i < nSwapTenors; ++i)
            volCubeBySabr->recalibration(QuantLib::CmsMarketCalibration::betaTransformDirect(x[i]),
                                         swapTenors[i]);
        cmsMarket_->reprice(volCube_, fixedMeanReversion_ == Null<Real>() ?
                                          Null<Real>() :
                                          QuantLib::CmsMarketCalibration::reversionTransformDirect(
                                              fixedMeanReversion_));
    }

    //===========================================================================//
    //        ObjectiveFunction3 (beta termstructure, free mean reversion)       //
    //===========================================================================//

    void
    ObjectiveFunction3::updateVolatilityCubeAndCmsMarket(const Array &x) const {
        const std::vector<Period> &swapTenors = cmsMarket_->swapTenors();
        const std::vector<Period> &swapLengths = cmsMarket_->swapLengths();
        Size nSwapTenors = swapTenors.size();
        Size nSwapLengths = swapLengths.size();
        QL_REQUIRE(
            (nSwapLengths * nSwapTenors) + 1 == x.size(),
            "bad calibration guess (nSwapLengths*nSwapTenors)+1 != x.size()");
        const ext::shared_ptr<SabrSwaptionVolatilityCube> volCubeBySabr =
            ext::dynamic_pointer_cast<SabrSwaptionVolatilityCube>(*volCube_);
        for (Size i = 0; i < nSwapTenors; ++i) {
            std::vector<Real> beta(x.begin() + (i * nSwapLengths),
                                   x.begin() + ((i + 1) * nSwapLengths));
            for (Real& j : beta)
                j = CmsMarketCalibration::betaTransformDirect(j);
            volCubeBySabr->recalibration(swapLengths, beta, swapTenors[i]);
        }
        Real meanReversion =
            CmsMarketCalibration::reversionTransformDirect(x[nSwapLengths + nSwapTenors]);
        cmsMarket_->reprice(volCube_, meanReversion);
    }

    //===========================================================================//
    //        ObjectiveFunction4 (beta termstructure, fixed mean reversion)      //
    //===========================================================================//

    void
    ObjectiveFunction4::updateVolatilityCubeAndCmsMarket(const Array &x) const {
        const std::vector<Period> &swapTenors = cmsMarket_->swapTenors();
        const std::vector<Period> &swapLengths = cmsMarket_->swapLengths();
        Size nSwapTenors = swapTenors.size();
        Size nSwapLengths = swapLengths.size();
        QL_REQUIRE(
            (nSwapLengths * nSwapTenors) == x.size(),
            "bad calibration guess (nSwapLengths*nSwapTenors) != x.size()");
        const ext::shared_ptr<SabrSwaptionVolatilityCube> volCubeBySabr =
            ext::dynamic_pointer_cast<SabrSwaptionVolatilityCube>(*volCube_);
        for (Size i = 0; i < nSwapTenors; ++i) {
            std::vector<Real> beta(x.begin() + (i * nSwapLengths),
                                   x.begin() + ((i + 1) * nSwapLengths));
            for (Real& j : beta)
                j = CmsMarketCalibration::betaTransformDirect(j);
            volCubeBySabr->recalibration(swapLengths, beta, swapTenors[i]);
        }
        cmsMarket_->reprice(volCube_, fixedMeanReversion_ == Null<Real>() ?
                                          Null<Real>() :
                                          CmsMarketCalibration::reversionTransformDirect(
                                              fixedMeanReversion_));
    }

    //=============================================================================//
    // ObjectiveFunction5 (beta parameteric termstructure, fixed mean reversion)   //
    //=============================================================================//

    void
    ObjectiveFunction5::updateVolatilityCubeAndCmsMarket(const Array &x) const {
        const std::vector<Period> &swapTenors = cmsMarket_->swapTenors();
        const std::vector<Period> &swapLengths = cmsMarket_->swapLengths();
        Size nSwapTenors = swapTenors.size();
        Size nSwapLengths = swapLengths.size();
        QL_REQUIRE((3 * nSwapTenors) == x.size(),
                   "bad calibration guess (3*nSwapTenors) != x.size()");
        const ext::shared_ptr<SabrSwaptionVolatilityCube> volCubeBySabr =
            ext::dynamic_pointer_cast<SabrSwaptionVolatilityCube>(*volCube_);
        for (Size i = 0; i < nSwapTenors; ++i) {
            Real betaInf = CmsMarketCalibration::betaTransformDirect(x[0 + 3 * i]);
            Real beta0 = CmsMarketCalibration::betaTransformDirect(x[1 + 3 * i]);
            Real decay = x[2 + 3 * i] * x[2 + 3 * i];
            std::vector<Real> beta(nSwapLengths);
            for (Size j = 0; j < beta.size(); ++j) {
                Real t = smileAndCms_->volCube_->timeFromReference(
                    smileAndCms_->volCube_->optionDateFromTenor(swapLengths[j]));
                beta[j] = betaInf + (beta0 - betaInf) * std::exp(-decay * t);
            }
            volCubeBySabr->recalibration(swapLengths, beta, swapTenors[i]);
        }
        cmsMarket_->reprice(volCube_, fixedMeanReversion_ == Null<Real>() ?
                                          Null<Real>() :
                                          CmsMarketCalibration::reversionTransformDirect(
                                              fixedMeanReversion_));
    }

    //===========================================================================//
    // ObjectiveFunction6 (beta parameteric termstructure, free mean reversion)  //
    //===========================================================================//

    void
    ObjectiveFunction6::updateVolatilityCubeAndCmsMarket(const Array &x) const {
        const std::vector<Period> &swapTenors = cmsMarket_->swapTenors();
        const std::vector<Period> &swapLengths = cmsMarket_->swapLengths();
        Size nSwapTenors = swapTenors.size();
        Size nSwapLengths = swapLengths.size();
        QL_REQUIRE((3 * nSwapTenors) == x.size(),
                   "bad calibration guess (3*nSwapTenors) != x.size()");
        const ext::shared_ptr<SabrSwaptionVolatilityCube> volCubeBySabr =
            ext::dynamic_pointer_cast<SabrSwaptionVolatilityCube>(*volCube_);
        for (Size i = 0; i < nSwapTenors; ++i) {
            Real betaInf = CmsMarketCalibration::betaTransformDirect(x[0 + 3 * i]);
            Real beta0 = CmsMarketCalibration::betaTransformDirect(x[1 + 3 * i]);
            Real decay = x[2 + 3 * i] * x[2 + 3 * i];
            std::vector<Real> beta(nSwapLengths);
            for (Size j = 0; j < beta.size(); ++j) {
                Real t = smileAndCms_->volCube_->timeFromReference(
                    smileAndCms_->volCube_->optionDateFromTenor(swapLengths[j]));
                beta[j] = betaInf + (beta0 - betaInf) * std::exp(-decay * t);
            }
            volCubeBySabr->recalibration(swapLengths, beta, swapTenors[i]);
        }
        Real meanReversion =
            CmsMarketCalibration::reversionTransformDirect(x[3 * nSwapTenors]);
        cmsMarket_->reprice(volCube_, meanReversion);
    }
}

namespace QuantLib {

    //===========================================================================//
    //                       CmsMarketCalibration                                //
    //===========================================================================//

    CmsMarketCalibration::CmsMarketCalibration(
        Handle<SwaptionVolatilityStructure> &volCube,
        ext::shared_ptr<CmsMarket> &cmsMarket, const Matrix &weights,
        CalibrationType calibrationType)
        : volCube_(volCube), cmsMarket_(cmsMarket), weights_(weights),
          calibrationType_(calibrationType) {

        QL_REQUIRE(weights.rows() == cmsMarket_->swapLengths().size(),
                   "weights number of rows ("
                       << weights.rows()
                       << ") must be equal to number of swap lengths ("
                       << cmsMarket_->swapLengths().size() << ")");
        QL_REQUIRE(weights.columns() == cmsMarket_->swapTenors().size(),
                   "weights number of columns ("
                       << weights.columns()
                       << ") must be equal to number of swap indexes ("
                       << cmsMarket_->swapTenors().size());
    }

    Array CmsMarketCalibration::compute(
        const ext::shared_ptr<EndCriteria> &endCriteria,
        const ext::shared_ptr<OptimizationMethod> &method, const Array &guess,
        bool isMeanReversionFixed) {
        Size nSwapTenors = cmsMarket_->swapTenors().size();
        QL_REQUIRE(isMeanReversionFixed || guess.size() == nSwapTenors + 1,
                   "if mean reversion is not fixed, a guess must be provided");
        QL_REQUIRE(nSwapTenors == guess.size() ||
                       nSwapTenors == guess.size() - 1,
                   "guess size (" << guess.size()
                                  << ") must be equal to swap tenors size ("
                                  << nSwapTenors
                                  << ") or greater by one if mean reversion is "
                                     "given as last element");
        bool isMeanReversionGiven = (nSwapTenors == guess.size() - 1);
        Size nBeta = guess.size() - (isMeanReversionGiven ? 1 : 0);
        Array result;
        if (isMeanReversionFixed) {
            NoConstraint constraint;
            Real fixedMeanReversion =
                isMeanReversionGiven ? guess[nBeta] : Null<Real>();
            Array betasGuess(nBeta);
            for (Size i = 0; i < nBeta; ++i)
                betasGuess[i] = guess[i];
            ObjectiveFunction2 costFunction(
                this, fixedMeanReversion == Null<Real>()
                          ? Null<Real>()
                          : reversionTransformInverse(fixedMeanReversion));
            Problem problem(costFunction, constraint, betasGuess);
            endCriteria_ = method->minimize(problem, *endCriteria);
            Array tmp = problem.currentValue();
            error_ = costFunction.value(tmp);
            result = Array(nBeta + (isMeanReversionGiven ? 1 : 0));
            for (Size i = 0; i < nBeta; ++i)
                result[i] = betaTransformDirect(tmp[i]);
            if (isMeanReversionGiven)
                result[nBeta] = fixedMeanReversion;
        } else {
            NoConstraint constraint;
            ObjectiveFunction costFunction(this);
            Array betaReversionGuess(nBeta + 1);
            for (Size i = 0; i < nBeta; ++i)
                betaReversionGuess[i] = betaTransformInverse(guess[i]);
            betaReversionGuess[nBeta] = reversionTransformInverse(guess[nBeta]);
            Problem problem(costFunction, constraint, betaReversionGuess);
            endCriteria_ = method->minimize(problem, *endCriteria);
            result = problem.currentValue();
            error_ = costFunction.value(result);
            for (Size i = 0; i < nBeta; ++i)
                result[i] = betaTransformDirect(result[i]);
            result[nBeta] = reversionTransformDirect(result[nBeta]);
        }
        const ext::shared_ptr<SabrSwaptionVolatilityCube> volCubeBySabr =
            ext::dynamic_pointer_cast<SabrSwaptionVolatilityCube>(*volCube_);
        volCubeBySabr->updateAfterRecalibration();
        sparseSabrParameters_ = volCubeBySabr->sparseSabrParameters();
        denseSabrParameters_ = volCubeBySabr->denseSabrParameters();
        browseCmsMarket_ = cmsMarket_->browse();

        return result;
    }

    Matrix CmsMarketCalibration::compute(
        const ext::shared_ptr<EndCriteria> &endCriteria,
        const ext::shared_ptr<OptimizationMethod> &method,
        const Matrix &guess, bool isMeanReversionFixed,
        const Real meanReversionGuess) {
        Size nSwapTenors = cmsMarket_->swapTenors().size();
        Size nSwapLengths = cmsMarket_->swapLengths().size();
        QL_REQUIRE(isMeanReversionFixed || meanReversionGuess != Null<Real>(),
                   "if mean reversion is not fixed, a guess must be provided");
        QL_REQUIRE(nSwapTenors == guess.columns(),
                   "number of swap tenors ("
                       << nSwapTenors
                       << ") must be equal to number of guess columns ("
                       << guess.columns() << ")");
        QL_REQUIRE(nSwapLengths == guess.rows(),
                   "number of swap lengths ("
                       << nSwapLengths
                       << ") must be equal to number of guess rows ("
                       << guess.rows() << ")");
        Matrix result;
        Size nBeta = nSwapTenors * nSwapLengths;
        if (isMeanReversionFixed) {
            NoConstraint constraint;
            Array betasGuess(nBeta);
            for (Size i = 0; i < nSwapTenors; ++i) {
                for (Size j = 0; j < nSwapLengths; ++j) {
                    betasGuess[i * nSwapLengths + j] =
                        betaTransformInverse(guess[j][i]);
                }
            }
            ObjectiveFunction4 costFunction(
                this, meanReversionGuess == Null<Real>()
                          ? meanReversionGuess
                          : reversionTransformInverse(meanReversionGuess));
            Problem problem(costFunction, constraint, betasGuess);
            endCriteria_ = method->minimize(problem, *endCriteria);
            Array tmp = problem.currentValue();
            error_ = costFunction.value(tmp);
            result = Matrix(nSwapLengths,
                            nSwapTenors +
                                (meanReversionGuess != Null<Real>() ? 1 : 0));
            for (Size i = 0; i < nSwapTenors; ++i) {
                for (Size j = 0; j < nSwapLengths; ++j) {
                    result[j][i] =
                        betaTransformDirect(tmp[i * nSwapLengths + j]);
                }
            }
            if (meanReversionGuess != Null<Real>()) {
                for (Size j = 0; j < nSwapLengths; ++j) {
                    result[j][nSwapTenors] = meanReversionGuess;
                }
            }
        } else {
            NoConstraint constraint;
            Array betasReversionGuess(nBeta + 1);
            for (Size i = 0; i < nSwapTenors; ++i) {
                for (Size j = 0; j < nSwapLengths; ++j) {
                    betasReversionGuess[i * nSwapLengths + j] =
                        betaTransformInverse(guess[j][i]);
                }
            }
            betasReversionGuess[nBeta] =
                reversionTransformInverse(meanReversionGuess);
            ObjectiveFunction3 costFunction(this);
            Problem problem(costFunction, constraint, betasReversionGuess);
            endCriteria_ = method->minimize(problem, *endCriteria);
            Array tmp = problem.currentValue();
            error_ = costFunction.value(tmp);
            result = Matrix(nSwapLengths, nSwapTenors + 1);
            for (Size i = 0; i < nSwapTenors; ++i) {
                for (Size j = 0; j < nSwapLengths; ++j) {
                    result[j][i] =
                        betaTransformDirect(tmp[i * nSwapLengths + j]);
                }
            }
            for (Size j = 0; j < nSwapLengths; ++j) {
                result[j][nSwapTenors] = reversionTransformDirect(tmp[nBeta]);
            }
        }
        const ext::shared_ptr<SabrSwaptionVolatilityCube> volCubeBySabr =
            ext::dynamic_pointer_cast<SabrSwaptionVolatilityCube>(*volCube_);
        volCubeBySabr->updateAfterRecalibration();
        sparseSabrParameters_ = volCubeBySabr->sparseSabrParameters();
        denseSabrParameters_ = volCubeBySabr->denseSabrParameters();
        browseCmsMarket_ = cmsMarket_->browse();

        return result;
    }

    Matrix CmsMarketCalibration::computeParametric(
        const ext::shared_ptr<EndCriteria> &endCriteria,
        const ext::shared_ptr<OptimizationMethod> &method,
        const Matrix &guess, bool isMeanReversionFixed,
        const Real meanReversionGuess) {

        Size nSwapTenors = cmsMarket_->swapTenors().size();
        Size nSwapLengths = cmsMarket_->swapLengths().size();
        QL_REQUIRE(isMeanReversionFixed || meanReversionGuess != Null<Real>(),
                   "if mean reversion is not fixed, a guess must be provided");
        QL_REQUIRE(nSwapTenors == guess.columns(),
                   "number of swap tenors ("
                       << nSwapTenors
                       << ") must be equal to number of guess columns ("
                       << guess.columns() << ")");
        QL_REQUIRE(3 == guess.rows(),
                   "number of parameters ("
                       << 3 << ") must be equal to number of guess rows ("
                       << guess.rows() << ")");

        Matrix result;
        Size nParams = nSwapTenors * 3;
        if (isMeanReversionFixed) {
            NoConstraint constraint;
            Array betasGuess(nParams);
            for (Size i = 0; i < nSwapTenors; ++i) {
                for (Size j = 0; j < nParams; ++j) {
                    betasGuess[i * 3 + j] =
                        (j == 0 || j == 1) ? betaTransformInverse(guess[j][i])
                                           : std::sqrt(guess[j][i]);
                }
            }
            ObjectiveFunction5 costFunction(
                this, meanReversionGuess == Null<Real>()
                          ? meanReversionGuess
                          : reversionTransformInverse(meanReversionGuess));
            Problem problem(costFunction, constraint, betasGuess);
            endCriteria_ = method->minimize(problem, *endCriteria);
            Array tmp = problem.currentValue();
            error_ = costFunction.value(tmp);
            result = Matrix(
                3, nSwapTenors + (meanReversionGuess != Null<Real>() ? 1 : 0));
            for (Size i = 0; i < nSwapTenors; ++i) {
                for (Size j = 0; j < 3; ++j) {
                    result[j][i] = (j == 0 || j == 1)
                                       ? betaTransformDirect(tmp[i * 3 + j])
                                       : tmp[i * 3 + j] * tmp[i * 3 + j];
                }
            }
            if (meanReversionGuess != Null<Real>()) {
                for (Size j = 0; j < nSwapLengths; ++j) {
                    result[j][nSwapTenors] = meanReversionGuess;
                }
            }
        } else {
            NoConstraint constraint;
            Array betasReversionGuess(nParams + 1);
            for (Size i = 0; i < nSwapTenors; ++i) {
                for (Size j = 0; j < nParams; ++j) {
                    betasReversionGuess[i * nSwapLengths + j] =
                        (j == 0 || j == 1) ? betaTransformInverse(guess[j][i])
                                           : std::sqrt(guess[j][i]);
                }
            }
            betasReversionGuess[nParams] =
                reversionTransformInverse(meanReversionGuess);
            ObjectiveFunction6 costFunction(this);
            Problem problem(costFunction, constraint, betasReversionGuess);
            endCriteria_ = method->minimize(problem, *endCriteria);
            Array tmp = problem.currentValue();
            error_ = costFunction.value(tmp);
            result = Matrix(3, nSwapTenors + 1);
            for (Size i = 0; i < nSwapTenors; ++i) {
                for (Size j = 0; j < 3; ++j) {
                    result[j][i] =
                        (j == 0 || j == 1)
                            ? betaTransformDirect(tmp[i * nSwapLengths + j])
                            : tmp[i * 3 + j] * tmp[i * 3 + j];
                }
            }
            for (Size j = 0; j < nSwapLengths; ++j) {
                result[j][nSwapTenors] = reversionTransformDirect(tmp[nParams]);
            }
        }

        const ext::shared_ptr<SabrSwaptionVolatilityCube> volCubeBySabr =
            ext::dynamic_pointer_cast<SabrSwaptionVolatilityCube>(*volCube_);
        volCubeBySabr->updateAfterRecalibration();
        sparseSabrParameters_ = volCubeBySabr->sparseSabrParameters();
        denseSabrParameters_ = volCubeBySabr->denseSabrParameters();
        browseCmsMarket_ = cmsMarket_->browse();

        return result;
    }
}
]]></document_content>
  </document>
  <document index="54">
    <source>volatility/swaption/gaussian1dswaptionvolatility.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/solvers1d/newtonsafe.hpp>
#include <ql/termstructures/volatility/gaussian1dsmilesection.hpp>
#include <ql/termstructures/volatility/swaption/gaussian1dswaptionvolatility.hpp>
#include <utility>

namespace QuantLib {

    Gaussian1dSwaptionVolatility::Gaussian1dSwaptionVolatility(
        const Calendar& cal,
        BusinessDayConvention bdc,
        ext::shared_ptr<SwapIndex> indexBase,
        const ext::shared_ptr<Gaussian1dModel>& model,
        const DayCounter& dc,
        ext::shared_ptr<Gaussian1dSwaptionEngine> swaptionEngine)
    : SwaptionVolatilityStructure(model->termStructure()->referenceDate(), cal, bdc, dc),
      indexBase_(std::move(indexBase)), model_(model), engine_(std::move(swaptionEngine)),
      maxSwapTenor_(100 * Years) {}

    ext::shared_ptr<SmileSection>
    Gaussian1dSwaptionVolatility::smileSectionImpl(const Date& d, const Period& tenor) const {
        ext::shared_ptr<SmileSection> tmp = ext::make_shared<Gaussian1dSmileSection>(
            d, indexBase_->clone(tenor), model_, this->dayCounter(), engine_);
        return tmp;
}

ext::shared_ptr<SmileSection>
Gaussian1dSwaptionVolatility::smileSectionImpl(Time optionTime,
                                               Time swapLength) const {
    DateHelper hlp(*this, optionTime);
    NewtonSafe newton;
    Date d(static_cast<Date::serial_type>(newton.solve(
        hlp, 0.1,
        365.25 * optionTime + static_cast<Real>(referenceDate().serialNumber()),
        1.0)));
    Period tenor(
        static_cast<Integer>(Rounding(0)(swapLength * 12.0)),
        Months);
    d = indexBase_->fixingCalendar().adjust(d);
    return smileSectionImpl(d, tenor);
}

Volatility Gaussian1dSwaptionVolatility::volatilityImpl(const Date &d,
                                                        const Period &tenor,
                                                        Rate strike) const {
    return smileSectionImpl(d, tenor)->volatility(strike);
}

Volatility Gaussian1dSwaptionVolatility::volatilityImpl(Time optionTime,
                                                        Time swapLength,
                                                        Rate strike) const {
    return smileSectionImpl(optionTime, swapLength)->volatility(strike);
}
}
]]></document_content>
  </document>
  <document index="55">
    <source>volatility/swaption/interpolatedswaptionvolatilitycube.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Katiuscia Manzoni
 Copyright (C) 2015 Peter Caspers
 Copyright (C) 2023 Ignacio Anguita

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/swaption/interpolatedswaptionvolatilitycube.hpp>
#include <ql/termstructures/volatility/interpolatedsmilesection.hpp>
#include <ql/math/interpolations/bilinearinterpolation.hpp>
#include <ql/math/rounding.hpp>
#include <ql/indexes/swapindex.hpp>

namespace QuantLib {

    InterpolatedSwaptionVolatilityCube::InterpolatedSwaptionVolatilityCube(
        const Handle<SwaptionVolatilityStructure>& atmVolStructure,
        const std::vector<Period>& optionTenors,
        const std::vector<Period>& swapTenors,
        const std::vector<Spread>& strikeSpreads,
        const std::vector<std::vector<Handle<Quote> > >& volSpreads,
        const ext::shared_ptr<SwapIndex>& swapIndexBase,
        const ext::shared_ptr<SwapIndex>& shortSwapIndexBase,
        bool vegaWeightedSmileFit)
    : SwaptionVolatilityCube(atmVolStructure, optionTenors, swapTenors,
                             strikeSpreads, volSpreads, swapIndexBase,
                             shortSwapIndexBase,
                             vegaWeightedSmileFit),
      volSpreadsInterpolator_(nStrikes_),
      volSpreadsMatrix_(nStrikes_, Matrix(optionTenors.size(), swapTenors.size(), 0.0)) {
    }

    void InterpolatedSwaptionVolatilityCube::performCalculations() const{

        SwaptionVolatilityCube::performCalculations();
        //! set volSpreadsMatrix_ by volSpreads_ quotes
        for (Size i=0; i<nStrikes_; i++) 
            for (Size j=0; j<nOptionTenors_; j++)
                for (Size k=0; k<nSwapTenors_; k++) {
                    volSpreadsMatrix_[i][j][k] =
                        volSpreads_[j*nSwapTenors_+k][i]->value();
                }
        //! create volSpreadsInterpolator_ 
        for (Size i=0; i<nStrikes_; i++) {
            volSpreadsInterpolator_[i] = BilinearInterpolation(
                swapLengths_.begin(), swapLengths_.end(),
                optionTimes_.begin(), optionTimes_.end(),
                volSpreadsMatrix_[i]);
            volSpreadsInterpolator_[i].enableExtrapolation();
        }
    }

    ext::shared_ptr<SmileSection>
    InterpolatedSwaptionVolatilityCube::smileSectionImpl(Time optionTime,
                                       Time swapLength) const {

        calculate();
        Date optionDate = optionDateFromTime(optionTime);
        Rounding rounder(0);
        Period swapTenor(static_cast<Integer>(rounder(swapLength*12.0)), Months);
        // ensure that option date is valid fixing date
        optionDate =
            swapTenor > shortSwapIndexBase_->tenor()
                ? swapIndexBase_->fixingCalendar().adjust(optionDate, Following)
                : shortSwapIndexBase_->fixingCalendar().adjust(optionDate,
                                                               Following);
        return smileSectionImpl(optionDate, swapTenor);
    }

    ext::shared_ptr<SmileSection>
    InterpolatedSwaptionVolatilityCube::smileSectionImpl(const Date& optionDate,
                                       const Period& swapTenor) const {
        calculate();
        Rate atmForward = atmStrike(optionDate, swapTenor);
        Volatility atmVol = atmVol_->volatility(optionDate,
                                                swapTenor,
                                                atmForward);
        Time optionTime = timeFromReference(optionDate);
        Real exerciseTimeSqrt = std::sqrt(optionTime);
        std::vector<Real> strikes, stdDevs;
        strikes.reserve(nStrikes_);
        stdDevs.reserve(nStrikes_);
        Time length = swapLength(swapTenor);
        for (Size i=0; i<nStrikes_; ++i) {
            strikes.push_back(atmForward + strikeSpreads_[i]);
            stdDevs.push_back(exerciseTimeSqrt*(
                atmVol + volSpreadsInterpolator_[i](length, optionTime)));
        }
        Real shift = atmVol_->shift(optionTime,length);
        return ext::shared_ptr<SmileSection>(new
            InterpolatedSmileSection<Linear>(optionTime,
                                             strikes,
                                             stdDevs,
                                             atmForward,
                                             Linear(),
                                             Actual365Fixed(),
                                             volatilityType(),
                                             shift));
    }
}
]]></document_content>
  </document>
  <document index="56">
    <source>volatility/swaption/spreadedswaptionvol.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Ferdinando Ametrano
 Copyright (C) 2007 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/quote.hpp>
#include <ql/termstructures/volatility/spreadedsmilesection.hpp>
#include <ql/termstructures/volatility/swaption/spreadedswaptionvol.hpp>
#include <utility>

namespace QuantLib {

    SpreadedSwaptionVolatility::SpreadedSwaptionVolatility(
        const Handle<SwaptionVolatilityStructure>& baseVol, Handle<Quote> spread)
    : SwaptionVolatilityStructure(baseVol->businessDayConvention(), baseVol->dayCounter()),
      baseVol_(baseVol), spread_(std::move(spread)) {
        enableExtrapolation(baseVol->allowsExtrapolation());
        registerWith(baseVol_);
        registerWith(spread_);
    }

    ext::shared_ptr<SmileSection>
    SpreadedSwaptionVolatility::smileSectionImpl(const Date& d,
                                                 const Period& swapT) const {
        ext::shared_ptr<SmileSection> baseSmile =
            baseVol_->smileSection(d, swapT, true);
        return ext::shared_ptr<SmileSection>(new
            SpreadedSmileSection(baseSmile, spread_));
    }

    ext::shared_ptr<SmileSection>
    SpreadedSwaptionVolatility::smileSectionImpl(Time optionTime,
                                                 Time swapLength) const {
        ext::shared_ptr<SmileSection> baseSmile =
            baseVol_->smileSection(optionTime, swapLength, true);
        return ext::shared_ptr<SmileSection>(new
            SpreadedSmileSection(baseSmile, spread_));
    }

    Volatility SpreadedSwaptionVolatility::volatilityImpl(const Date& d,
                                                          const Period& p,
                                                          Rate strike) const {
        return baseVol_->volatility(d, p, strike, true) + spread_->value();
    }

    Volatility SpreadedSwaptionVolatility::volatilityImpl(Time t,
                                                          Time l,
                                                          Rate strike) const {
        return baseVol_->volatility(t, l, strike, true) + spread_->value();
    }

}
]]></document_content>
  </document>
  <document index="57">
    <source>volatility/swaption/swaptionconstantvol.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Ferdinando Ametrano
 Copyright (C) 2006, 2007 StatPro Italia srl
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/flatsmilesection.hpp>
#include <ql/termstructures/volatility/swaption/swaptionconstantvol.hpp>
#include <utility>

namespace QuantLib {

    // floating reference date, floating market data
    ConstantSwaptionVolatility::ConstantSwaptionVolatility(Natural settlementDays,
                                                           const Calendar& cal,
                                                           BusinessDayConvention bdc,
                                                           Handle<Quote> vol,
                                                           const DayCounter& dc,
                                                           const VolatilityType type,
                                                           const Real shift)
    : SwaptionVolatilityStructure(settlementDays, cal, bdc, dc), volatility_(std::move(vol)),
      maxSwapTenor_(100 * Years), volatilityType_(type), shift_(shift) {
        registerWith(volatility_);
    }

    // fixed reference date, floating market data
    ConstantSwaptionVolatility::ConstantSwaptionVolatility(const Date& referenceDate,
                                                           const Calendar& cal,
                                                           BusinessDayConvention bdc,
                                                           Handle<Quote> vol,
                                                           const DayCounter& dc,
                                                           const VolatilityType type,
                                                           const Real shift)
    : SwaptionVolatilityStructure(referenceDate, cal, bdc, dc), volatility_(std::move(vol)),
      maxSwapTenor_(100 * Years), volatilityType_(type), shift_(shift) {
        registerWith(volatility_);
    }

    // floating reference date, fixed market data
    ConstantSwaptionVolatility::ConstantSwaptionVolatility(
                                                    Natural settlementDays,
                                                    const Calendar& cal,
                                                    BusinessDayConvention bdc,
                                                    Volatility vol,
                                                    const DayCounter& dc,
                                                    const VolatilityType type,
                                                    const Real shift)
    : SwaptionVolatilityStructure(settlementDays, cal, bdc, dc),
      volatility_(ext::shared_ptr<Quote>(new SimpleQuote(vol))),
      maxSwapTenor_(100*Years), volatilityType_(type), shift_(shift) {}

    // fixed reference date, fixed market data
    ConstantSwaptionVolatility::ConstantSwaptionVolatility(
                                                    const Date& referenceDate,
                                                    const Calendar& cal,
                                                    BusinessDayConvention bdc,
                                                    Volatility vol,
                                                    const DayCounter& dc,
                                                    const VolatilityType type,
                                                    const Real shift)
    : SwaptionVolatilityStructure(referenceDate, cal, bdc, dc),
      volatility_(ext::shared_ptr<Quote>(new SimpleQuote(vol))),
      maxSwapTenor_(100*Years), volatilityType_(type), shift_(shift) {}

    ext::shared_ptr<SmileSection>
    ConstantSwaptionVolatility::smileSectionImpl(const Date& d,
                                                 const Period&) const {
        Volatility atmVol = volatility_->value();
        return ext::shared_ptr<SmileSection>(
            new FlatSmileSection(d, atmVol, dayCounter(), referenceDate(),
                                 Null<Rate>(), volatilityType_, shift_));
    }

    ext::shared_ptr<SmileSection>
    ConstantSwaptionVolatility::smileSectionImpl(Time optionTime,
                                                 Time) const {
        Volatility atmVol = volatility_->value();
        return ext::shared_ptr<SmileSection>(
            new FlatSmileSection(optionTime, atmVol, dayCounter(), Null<Rate>(),
                                 volatilityType_, shift_));
    }

    Volatility ConstantSwaptionVolatility::volatilityImpl(const Date&,
                                                          const Period&,
                                                          Rate) const {
        return volatility_->value();
    }

    Volatility ConstantSwaptionVolatility::volatilityImpl(Time,
                                                          Time,
                                                          Rate) const {
        return volatility_->value();
    }

}
]]></document_content>
  </document>
  <document index="58">
    <source>volatility/swaption/swaptionvolcube.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Katiuscia Manzoni

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/swapindex.hpp>
#include <ql/termstructures/volatility/swaption/swaptionvolcube.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <utility>

namespace QuantLib {

    SwaptionVolatilityCube::SwaptionVolatilityCube(
        const Handle<SwaptionVolatilityStructure>& atmVol,
        const std::vector<Period>& optionTenors,
        const std::vector<Period>& swapTenors,
        const std::vector<Spread>& strikeSpreads,
        std::vector<std::vector<Handle<Quote> > > volSpreads,
        ext::shared_ptr<SwapIndex> swapIndexBase,
        ext::shared_ptr<SwapIndex> shortSwapIndexBase,
        bool vegaWeightedSmileFit)
    : SwaptionVolatilityDiscrete(optionTenors,
                                 swapTenors,
                                 0,
                                 atmVol->calendar(),
                                 atmVol->businessDayConvention(),
                                 atmVol->dayCounter()),
      atmVol_(atmVol), nStrikes_(strikeSpreads.size()), strikeSpreads_(strikeSpreads),
      localStrikes_(nStrikes_), localSmile_(nStrikes_), volSpreads_(std::move(volSpreads)),
      swapIndexBase_(std::move(swapIndexBase)), shortSwapIndexBase_(std::move(shortSwapIndexBase)),
      vegaWeightedSmileFit_(vegaWeightedSmileFit) {
        QL_REQUIRE(!atmVol_.empty(), "atm vol handle not linked to anything");
        for (Size i=1; i<nStrikes_; ++i)
            QL_REQUIRE(strikeSpreads_[i-1]<strikeSpreads_[i],
                       "non increasing strike spreads: " <<
                       io::ordinal(i) << " is " << strikeSpreads_[i-1] << ", " <<
                       io::ordinal(i+1) << " is " << strikeSpreads_[i]);

        QL_REQUIRE(!volSpreads_.empty(), "empty vol spreads matrix");

        QL_REQUIRE(nOptionTenors_*nSwapTenors_==volSpreads_.size(),
            "mismatch between number of option tenors * swap tenors (" <<
            nOptionTenors_*nSwapTenors_ << ") and number of rows (" <<
            volSpreads_.size() << ")");

        for (Size i=0; i<volSpreads_.size(); i++)
            QL_REQUIRE(nStrikes_==volSpreads_[i].size(),
                       "mismatch between number of strikes (" << nStrikes_ <<
                       ") and number of columns (" << volSpreads_[i].size() <<
                       ") in the " << io::ordinal(i+1) << " row");

        registerWith(atmVol_);
        atmVol_->enableExtrapolation();

        registerWith(swapIndexBase_);
        registerWith(shortSwapIndexBase_);

        QL_REQUIRE(shortSwapIndexBase_->tenor()<=swapIndexBase_->tenor(),
                   "short index tenor (" << shortSwapIndexBase_->tenor() <<
                   ") is not less or equal than index tenor (" <<
                   swapIndexBase_->tenor() << ")");

        registerWithVolatilitySpread();
    }

    void SwaptionVolatilityCube::registerWithVolatilitySpread()
    {
        for (Size i=0; i<nStrikes_; i++)
            for (Size j=0; j<nOptionTenors_; j++)
                for (Size k=0; k<nSwapTenors_; k++)
                    registerWith(volSpreads_[j*nSwapTenors_+k][i]);
    }

    Rate SwaptionVolatilityCube::atmStrike(const Date& optionD,
                                           const Period& swapTenor) const {

        // FIXME use a familyName-based index factory
        if (swapTenor > shortSwapIndexBase_->tenor()) {
            if (swapIndexBase_->exogenousDiscount()) {
                return SwapIndex(swapIndexBase_->familyName(),
                                 swapTenor,
                                 swapIndexBase_->fixingDays(),
                                 swapIndexBase_->currency(),
                                 swapIndexBase_->fixingCalendar(),
                                 swapIndexBase_->fixedLegTenor(),
                                 swapIndexBase_->fixedLegConvention(),
                                 swapIndexBase_->dayCounter(),
                                 swapIndexBase_->iborIndex(),
                                 swapIndexBase_->discountingTermStructure())
                    .fixing(optionD);
            } else {
                return SwapIndex(swapIndexBase_->familyName(),
                                 swapTenor,
                                 swapIndexBase_->fixingDays(),
                                 swapIndexBase_->currency(),
                                 swapIndexBase_->fixingCalendar(),
                                 swapIndexBase_->fixedLegTenor(),
                                 swapIndexBase_->fixedLegConvention(),
                                 swapIndexBase_->dayCounter(),
                                 swapIndexBase_->iborIndex())
                    .fixing(optionD);
            }
        } else {
            if (shortSwapIndexBase_->exogenousDiscount()) {
                return SwapIndex(shortSwapIndexBase_->familyName(),
                                 swapTenor,
                                 shortSwapIndexBase_->fixingDays(),
                                 shortSwapIndexBase_->currency(),
                                 shortSwapIndexBase_->fixingCalendar(),
                                 shortSwapIndexBase_->fixedLegTenor(),
                                 shortSwapIndexBase_->fixedLegConvention(),
                                 shortSwapIndexBase_->dayCounter(),
                                 shortSwapIndexBase_->iborIndex(),
                                 shortSwapIndexBase_->discountingTermStructure())
                    .fixing(optionD);
            } else {
                return SwapIndex(shortSwapIndexBase_->familyName(),
                                 swapTenor,
                                 shortSwapIndexBase_->fixingDays(),
                                 shortSwapIndexBase_->currency(),
                                 shortSwapIndexBase_->fixingCalendar(),
                                 shortSwapIndexBase_->fixedLegTenor(),
                                 shortSwapIndexBase_->fixedLegConvention(),
                                 shortSwapIndexBase_->dayCounter(),
                                 shortSwapIndexBase_->iborIndex())
                    .fixing(optionD);
            }
        }
    }

}
]]></document_content>
  </document>
  <document index="59">
    <source>volatility/swaption/swaptionvoldiscrete.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Franois du Vignaud

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/swaption/swaptionvoldiscrete.hpp>
#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/utilities/dataformatters.hpp>

namespace QuantLib {

    SwaptionVolatilityDiscrete::SwaptionVolatilityDiscrete(
                                    const std::vector<Period>& optionTenors,
                                    const std::vector<Period>& swapTenors,
                                    Natural settlementDays,
                                    const Calendar& cal,
                                    BusinessDayConvention bdc,
                                    const DayCounter& dc)
    : SwaptionVolatilityStructure(settlementDays, cal, bdc, dc),
      nOptionTenors_(optionTenors.size()),
      optionTenors_(optionTenors),
      optionDates_(nOptionTenors_),
      optionTimes_(nOptionTenors_),
      optionDatesAsReal_(nOptionTenors_),
      optionInterpolatorTimes_(nOptionTenors_  + 1),
      optionInterpolatorDatesAsReal_(nOptionTenors_ + 1),
      nSwapTenors_(swapTenors.size()),
      swapTenors_(swapTenors),
      swapLengths_(nSwapTenors_) {

        checkOptionTenors();
        initializeOptionDatesAndTimes();

        checkSwapTenors();
        initializeSwapLengths();

        optionInterpolator_= LinearInterpolation(optionInterpolatorTimes_.begin(),
                                                 optionInterpolatorTimes_.end(),
                                                 optionInterpolatorDatesAsReal_.begin());
        optionInterpolator_.update();
        optionInterpolator_.enableExtrapolation();
        cachedReferenceDate_ = referenceDate();
    }

    SwaptionVolatilityDiscrete::SwaptionVolatilityDiscrete(
                                    const std::vector<Period>& optionTenors,
                                    const std::vector<Period>& swapTenors,
                                    const Date& referenceDate,
                                    const Calendar& cal,
                                    BusinessDayConvention bdc,
                                    const DayCounter& dc)
    : SwaptionVolatilityStructure(referenceDate, cal, bdc, dc),
      nOptionTenors_(optionTenors.size()),
      optionTenors_(optionTenors),
      optionDates_(nOptionTenors_),
      optionTimes_(nOptionTenors_),
      optionDatesAsReal_(nOptionTenors_),
      optionInterpolatorTimes_(nOptionTenors_  + 1),
      optionInterpolatorDatesAsReal_(nOptionTenors_ + 1),
      nSwapTenors_(swapTenors.size()),
      swapTenors_(swapTenors),
      swapLengths_(nSwapTenors_) {

        checkOptionTenors();
        initializeOptionDatesAndTimes();

        checkSwapTenors();
        initializeSwapLengths();

        optionInterpolator_= LinearInterpolation(optionInterpolatorTimes_.begin(),
                                                 optionInterpolatorTimes_.end(),
                                                 optionInterpolatorDatesAsReal_.begin());
        optionInterpolator_.update();
        optionInterpolator_.enableExtrapolation();
    }

    SwaptionVolatilityDiscrete::SwaptionVolatilityDiscrete(
                                        const std::vector<Date>& optionDates,
                                        const std::vector<Period>& swapTenors,
                                        const Date& referenceDate,
                                        const Calendar& cal,
                                        BusinessDayConvention bdc,
                                        const DayCounter& dc)
    : SwaptionVolatilityStructure(referenceDate, cal, bdc, dc),
      nOptionTenors_(optionDates.size()),
      optionTenors_(nOptionTenors_),
      optionDates_(optionDates),
      optionTimes_(nOptionTenors_),
      optionDatesAsReal_(nOptionTenors_),
      optionInterpolatorTimes_(nOptionTenors_  + 1),
      optionInterpolatorDatesAsReal_(nOptionTenors_ + 1),
      nSwapTenors_(swapTenors.size()),
      swapTenors_(swapTenors),
      swapLengths_(nSwapTenors_) {

        checkOptionDates(referenceDate);
        initializeOptionTimes();

        checkSwapTenors();
        initializeSwapLengths();

        optionInterpolator_= LinearInterpolation(optionInterpolatorTimes_.begin(),
                                                 optionInterpolatorTimes_.end(),
                                                 optionInterpolatorDatesAsReal_.begin());
        optionInterpolator_.update();
        optionInterpolator_.enableExtrapolation();
    }

    void SwaptionVolatilityDiscrete::checkOptionDates(const Date& reference) const {
        QL_REQUIRE(optionDates_[0] > reference,
                   "first option date (" << optionDates_[0] <<
                   ") must be greater than reference date (" << reference << ")");
        for (Size i=1; i<nOptionTenors_; ++i) {
            QL_REQUIRE(optionDates_[i]>optionDates_[i-1],
                       "non increasing option dates: " << io::ordinal(i) <<
                       " is " << optionDates_[i-1] << ", " << io::ordinal(i+1) <<
                       " is " << optionDates_[i]);
        }
    }

    void SwaptionVolatilityDiscrete::checkOptionTenors() const {
        QL_REQUIRE(optionTenors_[0]>0*Days,
                   "first option tenor is negative (" <<
                   optionTenors_[0] << ")");
        for (Size i=1; i<nOptionTenors_; ++i)
            QL_REQUIRE(optionTenors_[i]>optionTenors_[i-1],
                       "non increasing option tenor: " << io::ordinal(i) <<
                       " is " << optionTenors_[i-1] << ", " << io::ordinal(i+1) <<
                       " is " << optionTenors_[i]);
    }

    void SwaptionVolatilityDiscrete::checkSwapTenors() const {
        QL_REQUIRE(swapTenors_[0]>0*Days,
                   "first swap tenor is negative (" <<
                   swapTenors_[0] << ")");
        for (Size i=1; i<nSwapTenors_; ++i)
            QL_REQUIRE(swapTenors_[i]>swapTenors_[i-1],
                       "non increasing swap tenor: " << io::ordinal(i) <<
                       " is " << swapTenors_[i-1] << ", " << io::ordinal(i+1) <<
                       " is " << swapTenors_[i]);
    }

    void SwaptionVolatilityDiscrete::initializeOptionDatesAndTimes() const {
        optionInterpolatorDatesAsReal_[0] = static_cast<Real>(referenceDate().serialNumber());
        for (Size i=0; i<nOptionTenors_; ++i) {
            optionDates_[i] = optionDateFromTenor(optionTenors_[i]);
            optionDatesAsReal_[i] = optionInterpolatorDatesAsReal_[i + 1] =
                static_cast<Real>(optionDates_[i].serialNumber());
        }
        initializeOptionTimes();
    }

    void SwaptionVolatilityDiscrete::initializeOptionTimes() const {
        optionInterpolatorTimes_[0] = 0.0;
        for (Size i = 0; i < nOptionTenors_; ++i) {
            optionTimes_[i] = optionInterpolatorTimes_[i + 1] = timeFromReference(optionDates_[i]);
        }
    }

    void SwaptionVolatilityDiscrete::initializeSwapLengths() const {
        for (Size i=0; i<nSwapTenors_; ++i) 
            swapLengths_[i] = swapLength(swapTenors_[i]);
    }

    void SwaptionVolatilityDiscrete::performCalculations() const {
        // recalculate dates if necessary...
        if (moving_) {
            if (cachedReferenceDate_ != referenceDate()) {
                cachedReferenceDate_ = referenceDate();
                initializeOptionDatesAndTimes();
                initializeSwapLengths();
                optionInterpolator_.update();
            }
        }
    }

    void SwaptionVolatilityDiscrete::update() {
        TermStructure::update();
        LazyObject::update();
    }

}
]]></document_content>
  </document>
  <document index="60">
    <source>volatility/swaption/swaptionvolmatrix.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2008 Ferdinando Ametrano
 Copyright (C) 2006 Franois du Vignaud
 Copyright (C) 2006 Katiuscia Manzoni
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/swaption/swaptionvolmatrix.hpp>
#include <ql/termstructures/volatility/flatsmilesection.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/math/interpolations/bilinearinterpolation.hpp>
#include <ql/math/interpolations/flatextrapolation2d.hpp>


namespace QuantLib {

    // floating reference date, floating market data
    SwaptionVolatilityMatrix::SwaptionVolatilityMatrix(
                    const Calendar& cal,
                    BusinessDayConvention bdc,
                    const std::vector<Period>& optionT,
                    const std::vector<Period>& swapT,
                    const std::vector<std::vector<Handle<Quote> > >& vols,
                    const DayCounter& dc,
                    const bool flatExtrapolation,
                    const VolatilityType type,
                    const std::vector<std::vector<Real> >& shifts)
    : SwaptionVolatilityDiscrete(optionT, swapT, 0, cal, bdc, dc),
      volHandles_(vols), shiftValues_(shifts),
      volatilities_(vols.size(), vols.front().size()),
      shifts_(vols.size(), vols.front().size(), 0.0), volatilityType_(type) {
        checkInputs(volatilities_.rows(), volatilities_.columns(), shifts.size(),
                    shifts.empty() ? 0 : shifts.front().size());
        registerWithMarketData();
        if (flatExtrapolation) {
            interpolation_ =
                FlatExtrapolator2D(ext::make_shared<BilinearInterpolation>(
                    swapLengths_.begin(), swapLengths_.end(),
                    optionTimes_.begin(), optionTimes_.end(), volatilities_));
            interpolationShifts_ =
                FlatExtrapolator2D(ext::make_shared<BilinearInterpolation>(
                    swapLengths_.begin(), swapLengths_.end(),
                    optionTimes_.begin(), optionTimes_.end(), shifts_));
        } else {
            interpolation_ = BilinearInterpolation(
                swapLengths_.begin(), swapLengths_.end(), optionTimes_.begin(),
                optionTimes_.end(), volatilities_);
            interpolationShifts_ = BilinearInterpolation(
                swapLengths_.begin(), swapLengths_.end(), optionTimes_.begin(),
                optionTimes_.end(), shifts_);
        }
   }

    // fixed reference date, floating market data
    SwaptionVolatilityMatrix::SwaptionVolatilityMatrix(
                    const Date& refDate,
                    const Calendar& cal,
                    BusinessDayConvention bdc,
                    const std::vector<Period>& optionT,
                    const std::vector<Period>& swapT,
                    const std::vector<std::vector<Handle<Quote> > >& vols,
                    const DayCounter& dc,
                    const bool flatExtrapolation,
                    const VolatilityType type,
                    const std::vector<std::vector<Real> >& shifts)
    : SwaptionVolatilityDiscrete(optionT, swapT, refDate, cal, bdc, dc),
      volHandles_(vols), shiftValues_(shifts),
      volatilities_(vols.size(), vols.front().size()),
      shifts_(vols.size(), vols.front().size(), 0.0), volatilityType_(type) {
        checkInputs(volatilities_.rows(), volatilities_.columns(), shifts.size(),
                    shifts.empty() ? 0 : shifts.front().size());
        registerWithMarketData();
        if (flatExtrapolation) {
            interpolation_ =
                FlatExtrapolator2D(ext::make_shared<BilinearInterpolation>(
                    swapLengths_.begin(), swapLengths_.end(),
                    optionTimes_.begin(), optionTimes_.end(), volatilities_));
            interpolationShifts_ =
                FlatExtrapolator2D(ext::make_shared<BilinearInterpolation>(
                    swapLengths_.begin(), swapLengths_.end(),
                    optionTimes_.begin(), optionTimes_.end(), shifts_));
        } else {
            interpolation_ = BilinearInterpolation(
                swapLengths_.begin(), swapLengths_.end(), optionTimes_.begin(),
                optionTimes_.end(), volatilities_);
            interpolationShifts_ = BilinearInterpolation(
                swapLengths_.begin(), swapLengths_.end(), optionTimes_.begin(),
                optionTimes_.end(), shifts_);
        }
    }

    // floating reference date, fixed market data
    SwaptionVolatilityMatrix::SwaptionVolatilityMatrix(
                        const Calendar& cal,
                        BusinessDayConvention bdc,
                        const std::vector<Period>& optionT,
                        const std::vector<Period>& swapT,
                        const Matrix& vols,
                        const DayCounter& dc,
                        const bool flatExtrapolation,
                        const VolatilityType type,
                        const Matrix& shifts)
    : SwaptionVolatilityDiscrete(optionT, swapT, 0, cal, bdc, dc),
      volHandles_(vols.rows()), shiftValues_(vols.rows()),
      volatilities_(vols.rows(), vols.columns()),
      shifts_(vols.rows(), vols.columns(), 0.0), volatilityType_(type) {

        checkInputs(vols.rows(), vols.columns(), shifts.rows(), shifts.columns());

        // fill dummy handles to allow generic handle-based
        // computations later on
        for (Size i=0; i<vols.rows(); ++i) {
            volHandles_[i].resize(vols.columns());
            shiftValues_[i].resize(vols.columns());
            for (Size j=0; j<vols.columns(); ++j) {
                volHandles_[i][j] = Handle<Quote>(ext::shared_ptr<Quote>(new
                    SimpleQuote(vols[i][j])));
                shiftValues_[i][j] = shifts.rows() > 0 ? shifts[i][j] : 0.0;
            }
        }
        if (flatExtrapolation) {
            interpolation_ =
                FlatExtrapolator2D(ext::make_shared<BilinearInterpolation>(
                    swapLengths_.begin(), swapLengths_.end(),
                    optionTimes_.begin(), optionTimes_.end(), volatilities_));
            interpolationShifts_ =
                FlatExtrapolator2D(ext::make_shared<BilinearInterpolation>(
                    swapLengths_.begin(), swapLengths_.end(),
                    optionTimes_.begin(), optionTimes_.end(), shifts_));
        } else {
            interpolation_ = BilinearInterpolation(
                swapLengths_.begin(), swapLengths_.end(), optionTimes_.begin(),
                optionTimes_.end(), volatilities_);
            interpolationShifts_ = BilinearInterpolation(
                swapLengths_.begin(), swapLengths_.end(), optionTimes_.begin(),
                optionTimes_.end(), shifts_);
        }
    }

    // fixed reference date, fixed market data
    SwaptionVolatilityMatrix::SwaptionVolatilityMatrix(
                        const Date& refDate,
                        const Calendar& cal,
                        BusinessDayConvention bdc,
                        const std::vector<Period>& optionT,
                        const std::vector<Period>& swapT,
                        const Matrix& vols,
                        const DayCounter& dc,
                        const bool flatExtrapolation,
                        const VolatilityType type,
                        const Matrix& shifts)
    : SwaptionVolatilityDiscrete(optionT, swapT, refDate, cal, bdc, dc),
      volHandles_(vols.rows()), shiftValues_(vols.rows()),
      volatilities_(vols.rows(), vols.columns()),
      shifts_(shifts.rows(), shifts.columns(), 0.0), volatilityType_(type) {

        checkInputs(vols.rows(), vols.columns(), shifts.rows(), shifts.columns());

        // fill dummy handles to allow generic handle-based
        // computations later on
        for (Size i=0; i<vols.rows(); ++i) {
            volHandles_[i].resize(vols.columns());
            shiftValues_[i].resize(vols.columns());
            for (Size j=0; j<vols.columns(); ++j) {
                volHandles_[i][j] = Handle<Quote>(ext::shared_ptr<Quote>(new
                    SimpleQuote(vols[i][j])));
                shiftValues_[i][j] = shifts.rows() > 0 ? shifts[i][j] : 0.0;
            }
        }
        if (flatExtrapolation) {
            interpolation_ =
                FlatExtrapolator2D(ext::make_shared<BilinearInterpolation>(
                    swapLengths_.begin(), swapLengths_.end(),
                    optionTimes_.begin(), optionTimes_.end(), volatilities_));
            interpolationShifts_ =
                FlatExtrapolator2D(ext::make_shared<BilinearInterpolation>(
                    swapLengths_.begin(), swapLengths_.end(),
                    optionTimes_.begin(), optionTimes_.end(), shifts_));
        } else {
            interpolation_ = BilinearInterpolation(
                swapLengths_.begin(), swapLengths_.end(), optionTimes_.begin(),
                optionTimes_.end(), volatilities_);
            interpolationShifts_ = BilinearInterpolation(
                swapLengths_.begin(), swapLengths_.end(), optionTimes_.begin(),
                optionTimes_.end(), shifts_);
        }
    }

    // fixed reference date and fixed market data, option dates
    SwaptionVolatilityMatrix::SwaptionVolatilityMatrix(
                    const Date& today,
                    const Calendar& calendar,
                    BusinessDayConvention bdc,
                    const std::vector<Date>& optionDates,
                    const std::vector<Period>& swapT,
                    const Matrix& vols,
                    const DayCounter& dc,
                    const bool flatExtrapolation,
                    const VolatilityType type,
                    const Matrix& shifts)
    : SwaptionVolatilityDiscrete(optionDates, swapT, today, calendar, bdc, dc),
      volHandles_(vols.rows()), shiftValues_(vols.rows()),
      volatilities_(vols.rows(), vols.columns()),
      shifts_(shifts.rows(),shifts.columns(),0.0), volatilityType_(type) {

        checkInputs(vols.rows(), vols.columns(), shifts.rows(), shifts.columns());

        // fill dummy handles to allow generic handle-based
        // computations later on
        for (Size i=0; i<vols.rows(); ++i) {
            volHandles_[i].resize(vols.columns());
            shiftValues_[i].resize(vols.columns());
            for (Size j=0; j<vols.columns(); ++j) {
                volHandles_[i][j] = Handle<Quote>(ext::shared_ptr<Quote>(new
                    SimpleQuote(vols[i][j])));
                shiftValues_[i][j] = shifts.rows() > 0 ? shifts[i][j] : 0.0;
            }
        }
        if (flatExtrapolation) {
            interpolation_ =
                FlatExtrapolator2D(ext::make_shared<BilinearInterpolation>(
                    swapLengths_.begin(), swapLengths_.end(),
                    optionTimes_.begin(), optionTimes_.end(), volatilities_));
            interpolationShifts_ =
                FlatExtrapolator2D(ext::make_shared<BilinearInterpolation>(
                    swapLengths_.begin(), swapLengths_.end(),
                    optionTimes_.begin(), optionTimes_.end(), shifts_));
        } else {
            interpolation_ = BilinearInterpolation(
                swapLengths_.begin(), swapLengths_.end(), optionTimes_.begin(),
                optionTimes_.end(), volatilities_);
            interpolationShifts_ = BilinearInterpolation(
                swapLengths_.begin(), swapLengths_.end(), optionTimes_.begin(),
                optionTimes_.end(), shifts_);
        }
    }


    void SwaptionVolatilityMatrix::checkInputs(Size volRows,
                                               Size volsColumns,
                                               Size shiftRows,
                                               Size shiftsColumns) const {
        QL_REQUIRE(nOptionTenors_==volRows,
                   "mismatch between number of option dates (" <<
                   nOptionTenors_ << ") and number of rows (" << volRows <<
                   ") in the vol matrix");
        QL_REQUIRE(nSwapTenors_==volsColumns,
                   "mismatch between number of swap tenors (" <<
                   nSwapTenors_ << ") and number of columns (" << volsColumns <<
                   ") in the vol matrix");

        if(shiftRows==0 && shiftsColumns==0) {
            shifts_ = Matrix(volRows, volsColumns, 0.0);
            shiftRows = volRows;
            shiftsColumns = volsColumns;
        }

        QL_REQUIRE(nOptionTenors_==shiftRows,
                   "mismatch between number of option dates (" <<
                   nOptionTenors_ << ") and number of rows (" << shiftRows <<
                   ") in the shift matrix");
        QL_REQUIRE(nSwapTenors_==shiftsColumns,
                   "mismatch between number of swap tenors (" <<
                   nSwapTenors_ << ") and number of columns (" << shiftsColumns <<
                   ") in the shift matrix");

    }

    void SwaptionVolatilityMatrix::registerWithMarketData()
    {
        for (Size i=0; i<volHandles_.size(); ++i)
            for (Size j=0; j<volHandles_.front().size(); ++j)
                registerWith(volHandles_[i][j]);
    }

    void SwaptionVolatilityMatrix::performCalculations() const {

        SwaptionVolatilityDiscrete::performCalculations();

        // we might use iterators here...
        for (Size i=0; i<volatilities_.rows(); ++i) {
            for (Size j=0; j<volatilities_.columns(); ++j) {
                volatilities_[i][j] = volHandles_[i][j]->value();
                if (!shiftValues_.empty())
                    shifts_[i][j] = shiftValues_[i][j];
            }
        }
    }

    //ext::shared_ptr<SmileSection>
    //SwaptionVolatilityMatrix::smileSectionImpl(const Date& d,
    //                                           const Period& swapTenor) const {
    //    Time optionTime = timeFromReference(d);
    //    Time swapLength = convertSwapTenor(swapTenor);
    //    // dummy strike
    //    Volatility atmVol = volatilityImpl(optionTime, swapLength, 0.05);
    //    return ext::shared_ptr<SmileSection>(new
    //        FlatSmileSection(d, atmVol, dayCounter(), referenceDate()));
    //}

    ext::shared_ptr<SmileSection>
    SwaptionVolatilityMatrix::smileSectionImpl(Time optionTime,
                                               Time swapLength) const {
        // dummy strike
        Volatility atmVol = volatilityImpl(optionTime, swapLength, 0.05);
        return ext::shared_ptr<SmileSection>(new FlatSmileSection(
            optionTime, atmVol, dayCounter(), Null<Real>(), volatilityType(),
            shift(optionTime, swapLength, true)));
    }

}
]]></document_content>
  </document>
  <document index="61">
    <source>volatility/swaption/swaptionvolstructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/volatility/swaption/swaptionvolstructure.hpp>
#include <ql/math/rounding.hpp>

namespace QuantLib {

    SwaptionVolatilityStructure::SwaptionVolatilityStructure(
                                                    BusinessDayConvention bdc,
                                                    const DayCounter& dc)
    : VolatilityTermStructure(bdc, dc) {}

    SwaptionVolatilityStructure::SwaptionVolatilityStructure(
                                                const Date& referenceDate,
                                                const Calendar& calendar,
                                                BusinessDayConvention bdc,
                                                const DayCounter& dc)
    : VolatilityTermStructure(referenceDate, calendar, bdc, dc) {}

    SwaptionVolatilityStructure::SwaptionVolatilityStructure(
                                                Natural settlementDays,
                                                const Calendar& calendar,
                                                BusinessDayConvention bdc,
                                                const DayCounter& dc)
    : VolatilityTermStructure(settlementDays, calendar, bdc, dc) {}


    Time SwaptionVolatilityStructure::swapLength(const Period& p) const {
        QL_REQUIRE(p.length()>0,
                   "non-positive swap tenor (" << p << ") given");
        switch (p.units()) {
          case Months:
            return p.length()/12.0;
          case Years:
            return static_cast<Time>(p.length());
          default:
            QL_FAIL("invalid Time Unit (" << p.units() << ") for swap length");
        }
    }

    Time SwaptionVolatilityStructure::swapLength(const Date& start,
                                                 const Date& end) const {
        QL_REQUIRE(end>start, "swap end date (" << end <<
                   ") must be greater than start (" << start << ")");
        Time result = (end-start)/365.25*12.0; // month unit
        result = ClosestRounding(0)(result);
        result /= 12.0; // year unit
        return result;
    }

    void SwaptionVolatilityStructure::checkSwapTenor(const Period& swapTenor,
                                                     bool extrapolate) const {
        QL_REQUIRE(swapTenor.length() > 0,
                   "non-positive swap tenor (" << swapTenor << ") given");
        QL_REQUIRE(extrapolate || allowsExtrapolation() ||
                   swapTenor <= maxSwapTenor(),
                   "swap tenor (" << swapTenor << ") is past max tenor ("
                   << maxSwapTenor() << ")");
    }

    void SwaptionVolatilityStructure::checkSwapTenor(Time swapLength,
                                                     bool extrapolate) const {
        QL_REQUIRE(swapLength > 0.0,
                   "non-positive swap length (" << swapLength << ") given");
        QL_REQUIRE(extrapolate || allowsExtrapolation() ||
                   swapLength <= maxSwapLength(),
                   "swap tenor (" << swapLength << ") is past max tenor ("
                   << maxSwapLength() << ")");
    }

}
]]></document_content>
  </document>
  <document index="62">
    <source>voltermstructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/voltermstructure.hpp>

namespace QuantLib {

    VolatilityTermStructure::VolatilityTermStructure(BusinessDayConvention bdc,
                                                     const DayCounter& dc)
    : TermStructure(dc), bdc_(bdc) {}

    VolatilityTermStructure::VolatilityTermStructure(const Date& referenceDate,
                                                     const Calendar& cal,
                                                     BusinessDayConvention bdc,
                                                     const DayCounter& dc)
    : TermStructure(referenceDate, cal, dc), bdc_(bdc) {}

    VolatilityTermStructure::VolatilityTermStructure(Natural settlementDays,
                                                     const Calendar& cal,
                                                     BusinessDayConvention bdc,
                                                     const DayCounter& dc)
    : TermStructure(settlementDays, cal, dc), bdc_(bdc) {}

    void VolatilityTermStructure::checkStrike(Rate k,
                                              bool extrapolate) const {
        QL_REQUIRE(extrapolate || allowsExtrapolation() ||
                   (k >= minStrike() && k <= maxStrike()),
                   "strike (" << k << ") is outside the curve domain ["
                   << minStrike() << "," << maxStrike()<< "]");
    }

}
]]></document_content>
  </document>
  <document index="63">
    <source>yield/bondhelpers.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 Ferdinando Ametrano
 Copyright (C) 2005 Toyin Akin
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/yield/bondhelpers.hpp>
#include <ql/pricingengines/bond/discountingbondengine.hpp>
#include <ql/time/schedule.hpp>
#include <ql/settings.hpp>
#include <ql/utilities/null_deleter.hpp>

namespace QuantLib {

    BondHelper::BondHelper(const Handle<Quote>& price,
                           const ext::shared_ptr<Bond>& bond,
                           const Bond::Price::Type priceType)
    : RateHelper(price), bond_(ext::make_shared<Bond>(*bond)), priceType_(priceType) {

        // the bond's last cashflow date, which can be later than
        // bond's maturity date because of adjustment
        latestDate_ = bond_->cashflows().back()->date();
        earliestDate_ = bond_->nextCashFlowDate();

        bond_->setPricingEngine(
             ext::make_shared<DiscountingBondEngine>(termStructureHandle_));
    }

    void BondHelper::setTermStructure(YieldTermStructure* t) {
        // do not set the relinkable handle as an observer -
        // force recalculation when needed
        termStructureHandle_.linkTo(
            ext::shared_ptr<YieldTermStructure>(t, null_deleter()), false);

        BootstrapHelper<YieldTermStructure>::setTermStructure(t);
    }

    Real BondHelper::impliedQuote() const {
        QL_REQUIRE(termStructure_ != nullptr, "term structure not set");
        // we didn't register as observers - force calculation
        bond_->recalculate();

        switch (priceType_) {
            case Bond::Price::Clean:
                return bond_->cleanPrice();
                break;

            case Bond::Price::Dirty:
                return bond_->dirtyPrice();
                break;

            default:
                QL_FAIL("This price type isn't implemented.");
        }
    }

    void BondHelper::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<BondHelper>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            BootstrapHelper<YieldTermStructure>::accept(v);
    }


    FixedRateBondHelper::FixedRateBondHelper(
                                    const Handle<Quote>& price,
                                    Natural settlementDays,
                                    Real faceAmount,
                                    Schedule schedule,
                                    const std::vector<Rate>& coupons,
                                    const DayCounter& dayCounter,
                                    BusinessDayConvention paymentConvention,
                                    Real redemption,
                                    const Date& issueDate,
                                    const Calendar& paymentCalendar,
                                    const Period& exCouponPeriod,
                                    const Calendar& exCouponCalendar,
                                    const BusinessDayConvention exCouponConvention,
                                    bool exCouponEndOfMonth,
                                    const Bond::Price::Type priceType)
    : BondHelper(price,
                 ext::make_shared<FixedRateBond>(settlementDays, faceAmount, std::move(schedule),
                                                 coupons, dayCounter, paymentConvention,
                                                 redemption, issueDate, paymentCalendar,
                                                 exCouponPeriod, exCouponCalendar,
                                                 exCouponConvention, exCouponEndOfMonth),
                 priceType) {}

    void FixedRateBondHelper::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<FixedRateBondHelper>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            BondHelper::accept(v);
    }


    QL_DEPRECATED_DISABLE_WARNING

    CPIBondHelper::CPIBondHelper(
                            const Handle<Quote>& price,
                            Natural settlementDays,
                            Real faceAmount,
                            Real baseCPI,
                            const Period& observationLag,
                            const ext::shared_ptr<ZeroInflationIndex>& cpiIndex,
                            CPI::InterpolationType observationInterpolation,
                            Schedule schedule,
                            const std::vector<Rate>& fixedRate,
                            const DayCounter& accrualDayCounter,
                            BusinessDayConvention paymentConvention,
                            const Date& issueDate,
                            const Calendar& paymentCalendar,
                            const Period& exCouponPeriod,
                            const Calendar& exCouponCalendar,
                            const BusinessDayConvention exCouponConvention,
                            bool exCouponEndOfMonth,
                            const Bond::Price::Type priceType)
    : CPIBondHelper(price, settlementDays, faceAmount, false, baseCPI, observationLag,
                    cpiIndex, observationInterpolation, std::move(schedule), fixedRate,
                    accrualDayCounter, paymentConvention, issueDate, paymentCalendar,
                    exCouponPeriod, exCouponCalendar, exCouponConvention, exCouponEndOfMonth,
                    priceType) {}

    CPIBondHelper::CPIBondHelper(
                            const Handle<Quote>& price,
                            Natural settlementDays,
                            Real faceAmount,
                            const bool growthOnly,
                            Real baseCPI,
                            const Period& observationLag,
                            const ext::shared_ptr<ZeroInflationIndex>& cpiIndex,
                            CPI::InterpolationType observationInterpolation,
                            Schedule schedule,
                            const std::vector<Rate>& fixedRate,
                            const DayCounter& accrualDayCounter,
                            BusinessDayConvention paymentConvention,
                            const Date& issueDate,
                            const Calendar& paymentCalendar,
                            const Period& exCouponPeriod,
                            const Calendar& exCouponCalendar,
                            const BusinessDayConvention exCouponConvention,
                            bool exCouponEndOfMonth,
                            const Bond::Price::Type priceType)
    : BondHelper(price,
                 // make_shared and deprecation interfere; restore later
                 ext::shared_ptr<Bond>(new CPIBond(settlementDays, faceAmount, growthOnly, baseCPI,
                                           observationLag, cpiIndex, observationInterpolation,
                                           std::move(schedule), fixedRate, accrualDayCounter, paymentConvention,
                                           issueDate, paymentCalendar, exCouponPeriod, exCouponCalendar,
                                           exCouponConvention, exCouponEndOfMonth)),
                 priceType) {}

    QL_DEPRECATED_ENABLE_WARNING

    void CPIBondHelper::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<CPIBondHelper>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            BondHelper::accept(v);
    }

}
]]></document_content>
  </document>
  <document index="64">
    <source>yield/fittedbonddiscountcurve.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Ferdinando Ametrano
 Copyright (C) 2007 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflows.hpp>
#include <ql/math/optimization/constraint.hpp>
#include <ql/math/optimization/costfunction.hpp>
#include <ql/math/optimization/simplex.hpp>
#include <ql/pricingengines/bond/bondfunctions.hpp>
#include <ql/termstructures/yield/fittedbonddiscountcurve.hpp>
#include <ql/time/daycounters/simpledaycounter.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <utility>

using std::vector;

namespace QuantLib {

    class FittedBondDiscountCurve::FittingMethod::FittingCost
        : public CostFunction {
        friend class FittedBondDiscountCurve::FittingMethod;
      public:
        explicit FittingCost(
                       FittedBondDiscountCurve::FittingMethod* fittingMethod);
        Real value(const Array& x) const override;
        Array values(const Array& x) const override;

      private:
        FittedBondDiscountCurve::FittingMethod* fittingMethod_;
    };


    FittedBondDiscountCurve::FittedBondDiscountCurve(
        Natural settlementDays,
        const Calendar& calendar,
        vector<ext::shared_ptr<BondHelper> > bondHelpers,
        const DayCounter& dayCounter,
        const FittingMethod& fittingMethod,
        Real accuracy,
        Size maxEvaluations,
        Array guess,
        Real simplexLambda,
        Size maxStationaryStateIterations)
    : YieldTermStructure(settlementDays, calendar, dayCounter), accuracy_(accuracy),
      maxEvaluations_(maxEvaluations), simplexLambda_(simplexLambda),
      maxStationaryStateIterations_(maxStationaryStateIterations), guessSolution_(std::move(guess)),
      bondHelpers_(std::move(bondHelpers)), fittingMethod_(fittingMethod) {
        fittingMethod_->curve_ = this;
        setup();
    }


    FittedBondDiscountCurve::FittedBondDiscountCurve(
        const Date& referenceDate,
        vector<ext::shared_ptr<BondHelper> > bondHelpers,
        const DayCounter& dayCounter,
        const FittingMethod& fittingMethod,
        Real accuracy,
        Size maxEvaluations,
        Array guess,
        Real simplexLambda,
        Size maxStationaryStateIterations)
    : YieldTermStructure(referenceDate, Calendar(), dayCounter), accuracy_(accuracy),
      maxEvaluations_(maxEvaluations), simplexLambda_(simplexLambda),
      maxStationaryStateIterations_(maxStationaryStateIterations), guessSolution_(std::move(guess)),
      bondHelpers_(std::move(bondHelpers)), fittingMethod_(fittingMethod) {

        fittingMethod_->curve_ = this;
        setup();
    }

    FittedBondDiscountCurve::FittedBondDiscountCurve(
                            Natural settlementDays,
                            const Calendar& calendar,
                            const FittingMethod& fittingMethod,
                            Array parameters,
                            Date maxDate,
                            const DayCounter& dayCounter)
    : YieldTermStructure(settlementDays, calendar, dayCounter), accuracy_(1e-10),
      maxEvaluations_(0), guessSolution_(std::move(parameters)),
      maxDate_(maxDate), fittingMethod_(fittingMethod) {

        fittingMethod_->curve_ = this;
        setup();
    }

    FittedBondDiscountCurve::FittedBondDiscountCurve(
                                const Date& referenceDate,
                                const FittingMethod& fittingMethod,
                                Array parameters,
                                Date maxDate,
                                const DayCounter& dayCounter)
    : YieldTermStructure(referenceDate, Calendar(), dayCounter), accuracy_(1e-10),
      maxEvaluations_(0), guessSolution_(std::move(parameters)),
      maxDate_(maxDate), fittingMethod_(fittingMethod) {

        fittingMethod_->curve_ = this;
        setup();
    }


    void FittedBondDiscountCurve::resetGuess(const Array& guess) {
        QL_REQUIRE(guess.empty() || guess.size() == fittingMethod_->size(), "guess is of wrong size");
        guessSolution_ = guess;
        update();
    }


    void FittedBondDiscountCurve::performCalculations() const {

        if (maxEvaluations_!= 0) {
            // we need to fit, so we require helpers
            QL_REQUIRE(!bondHelpers_.empty(), "no bond helpers given");
        }

        if (maxEvaluations_ == 0) {
            // no fit, but we need either an explicit max date or
            // helpers from which to deduce it
            QL_REQUIRE(maxDate_ != Date() || !bondHelpers_.empty(),
                       "no bond helpers or max date given");
        }

        if (!bondHelpers_.empty()) {
            maxDate_ = Date::minDate();
            Date refDate = referenceDate();

            // double check bond quotes still valid and/or instruments not expired
            for (Size i=0; i<bondHelpers_.size(); ++i) {
                ext::shared_ptr<Bond> bond = bondHelpers_[i]->bond();
                QL_REQUIRE(bondHelpers_[i]->quote()->isValid(),
                           io::ordinal(i+1) << " bond (maturity: " <<
                           bond->maturityDate() << ") has an invalid price quote");
                Date bondSettlement = bond->settlementDate();
                QL_REQUIRE(bondSettlement>=refDate,
                           io::ordinal(i+1) << " bond settlemente date (" <<
                           bondSettlement << ") before curve reference date (" <<
                           refDate << ")");
                QL_REQUIRE(BondFunctions::isTradable(*bond, bondSettlement),
                           io::ordinal(i+1) << " bond non tradable at " <<
                           bondSettlement << " settlement date (maturity"
                           " being " << bond->maturityDate() << ")");
                maxDate_ = std::max(maxDate_, bondHelpers_[i]->pillarDate());
                bondHelpers_[i]->setTermStructure(
                                                  const_cast<FittedBondDiscountCurve*>(this));
            }
        }

        fittingMethod_->init();
        fittingMethod_->calculate();
    }


    FittedBondDiscountCurve::FittingMethod::FittingMethod(
        bool constrainAtZero,
        const Array& weights,
        ext::shared_ptr<OptimizationMethod> optimizationMethod,
        Array l2,
        const Real minCutoffTime,
        const Real maxCutoffTime,
        Constraint constraint)
    : constrainAtZero_(constrainAtZero), weights_(weights), l2_(std::move(l2)),
      calculateWeights_(weights.empty()), optimizationMethod_(std::move(optimizationMethod)),
      constraint_(std::move(constraint)),
      minCutoffTime_(minCutoffTime), maxCutoffTime_(maxCutoffTime) {
        if (constraint_.empty())
            constraint_ = NoConstraint();
    }

    void FittedBondDiscountCurve::FittingMethod::init() {

        if (curve_->maxEvaluations_ == 0)
            return; // we can skip the rest

        // yield conventions
        DayCounter yieldDC = curve_->dayCounter();
        Compounding yieldComp = Compounded;
        Frequency yieldFreq = Annual;

        Size n = curve_->bondHelpers_.size();
        costFunction_ = ext::make_shared<FittingCost>(this);

        for (auto& bondHelper : curve_->bondHelpers_) {
            bondHelper->setTermStructure(curve_);
        }

        if (calculateWeights_) {
            if (weights_.empty())
                weights_ = Array(n);

            Real squaredSum = 0.0;
            for (Size i=0; i<curve_->bondHelpers_.size(); ++i) {
                ext::shared_ptr<Bond> bond = curve_->bondHelpers_[i]->bond();

                Real amount = curve_->bondHelpers_[i]->quote()->value();
                Bond::Price price(amount, curve_->bondHelpers_[i]->priceType());

                Date bondSettlement = bond->settlementDate();
                Rate ytm = BondFunctions::yield(*bond, price,
                                                yieldDC, yieldComp, yieldFreq,
                                                bondSettlement);

                Time dur = BondFunctions::duration(*bond, ytm,
                                                   yieldDC, yieldComp, yieldFreq,
                                                   Duration::Modified,
                                                   bondSettlement);
                weights_[i] = 1.0/dur;
                squaredSum += weights_[i]*weights_[i];
            }
            weights_ /= std::sqrt(squaredSum);
        }

        QL_REQUIRE(weights_.size() == n,
                   "Given weights do not cover all boostrapping helpers");

        if (!l2_.empty()) {
            QL_REQUIRE(l2_.size() == size(),
                       "Given penalty factors do not cover all parameters");

            QL_REQUIRE(!curve_->guessSolution_.empty(), "L2 penalty requires a guess");
        }
    }

    void FittedBondDiscountCurve::FittingMethod::calculate() {

        if (curve_->maxEvaluations_ == 0)
        {
            // Don't calculate, simply use the given parameters to
            // provide a fitted curve.  This turns the instance into
            // an evaluator of the parametric curve, for example
            // allowing to use the parameters for a credit spread
            // curve calculated with bonds in one currency to be
            // coupled to a discount curve in another currency.

            QL_REQUIRE(curve_->guessSolution_.size() == size(),
                       "wrong number of parameters");

            solution_ = curve_->guessSolution_;

            numberOfIterations_ = 0;
            costValue_ = Null<Real>();
            errorCode_ = EndCriteria::None;

            return;
        }

        FittingCost& costFunction = *costFunction_;

        // start with the guess solution, if it exists
        Array x(size(), 0.0);
        if (!curve_->guessSolution_.empty()) {
            QL_REQUIRE(curve_->guessSolution_.size() == size(), "wrong size for guess");
            x = curve_->guessSolution_;
        }

        // workaround for backwards compatibility
        ext::shared_ptr<OptimizationMethod> optimization = optimizationMethod_;
        if (!optimization) {
            optimization = ext::make_shared<Simplex>(curve_->simplexLambda_);
        }
        Problem problem(costFunction, constraint_, x);

        Real rootEpsilon = curve_->accuracy_;
        Real functionEpsilon =  curve_->accuracy_;
        Real gradientNormEpsilon = curve_->accuracy_;

        EndCriteria endCriteria(curve_->maxEvaluations_,
                                curve_->maxStationaryStateIterations_,
                                rootEpsilon,
                                functionEpsilon,
                                gradientNormEpsilon);

        errorCode_ = optimization->minimize(problem,endCriteria);
        solution_ = problem.currentValue();

        numberOfIterations_ = problem.functionEvaluation();
        costValue_ = problem.functionValue();

        // save the results as the guess solution, in case of recalculation
        curve_->guessSolution_ = solution_;
    }


    FittedBondDiscountCurve::FittingMethod::FittingCost::FittingCost(
                        FittedBondDiscountCurve::FittingMethod* fittingMethod)
    : fittingMethod_(fittingMethod) {}


    Real FittedBondDiscountCurve::FittingMethod::FittingCost::value(
                                                       const Array& x) const {
        Real squaredError = 0.0;
        Array vals = values(x);
        for (Real val : vals) {
            squaredError += val;
        }
        return squaredError;
    }

    Array FittedBondDiscountCurve::FittingMethod::FittingCost::values(const Array &x) const {
        Size n = fittingMethod_->curve_->bondHelpers_.size();
        Size N = fittingMethod_->l2_.size();

        // set solution so that fittingMethod_->curve_ represents the current trial
        // the final solution will be set in FittingMethod::calculate() later on
        fittingMethod_->solution_ = x;

        Array values(n + N);
        for (Size i=0; i<n; ++i) {
            ext::shared_ptr<BondHelper> helper = fittingMethod_->curve_->bondHelpers_[i];
            Real weightedError = fittingMethod_->weights_[i] * helper->quoteError();
            values[i] = weightedError * weightedError;
        }

        if (N != 0) {
            for (Size i = 0; i < N; ++i) {
                Real error = x[i] - fittingMethod_->curve_->guessSolution_[i];
                values[i + n] = fittingMethod_->l2_[i] * error * error;
            }
        }
        return values;
    }

}
]]></document_content>
  </document>
  <document index="65">
    <source>yield/flatforward.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <utility>

namespace QuantLib {

    FlatForward::FlatForward(const Date& referenceDate,
                             Handle<Quote> forward,
                             const DayCounter& dayCounter,
                             Compounding compounding,
                             Frequency frequency)
    : YieldTermStructure(referenceDate, Calendar(), dayCounter), forward_(std::move(forward)),
      compounding_(compounding), frequency_(frequency) {
        registerWith(forward_);
    }

    FlatForward::FlatForward(const Date& referenceDate,
                             Rate forward,
                             const DayCounter& dayCounter,
                             Compounding compounding,
                             Frequency frequency)
    : YieldTermStructure(referenceDate, Calendar(), dayCounter),
      forward_(ext::shared_ptr<Quote>(new SimpleQuote(forward))),
      compounding_(compounding), frequency_(frequency) {}

    FlatForward::FlatForward(Natural settlementDays,
                             const Calendar& calendar,
                             Handle<Quote> forward,
                             const DayCounter& dayCounter,
                             Compounding compounding,
                             Frequency frequency)
    : YieldTermStructure(settlementDays, calendar, dayCounter), forward_(std::move(forward)),
      compounding_(compounding), frequency_(frequency) {
        registerWith(forward_);
    }

    FlatForward::FlatForward(Natural settlementDays,
                             const Calendar& calendar,
                             Rate forward,
                             const DayCounter& dayCounter,
                             Compounding compounding,
                             Frequency frequency)
    : YieldTermStructure(settlementDays, calendar, dayCounter),
      forward_(ext::shared_ptr<Quote>(new SimpleQuote(forward))),
      compounding_(compounding), frequency_(frequency) {}

}
]]></document_content>
  </document>
  <document index="66">
    <source>yield/forwardstructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004 StatPro Italia srl
 Copyright (C) 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/yield/forwardstructure.hpp>

namespace QuantLib {

    ForwardRateStructure::ForwardRateStructure(const DayCounter& dc)
    : YieldTermStructure(dc) {}

    ForwardRateStructure::ForwardRateStructure(
                                    const Date& refDate,
                                    const Calendar& cal,
                                    const DayCounter& dc,
                                    const std::vector<Handle<Quote> >& jumps,
                                    const std::vector<Date>& jumpDates)
    : YieldTermStructure(refDate, cal, dc, jumps, jumpDates) {}

    ForwardRateStructure::ForwardRateStructure(
                                    Natural settlDays,
                                    const Calendar& cal,
                                    const DayCounter& dc,
                                    const std::vector<Handle<Quote> >& jumps,
                                    const std::vector<Date>& jumpDates)
    : YieldTermStructure(settlDays, cal, dc, jumps, jumpDates) {}

    Rate ForwardRateStructure::zeroYieldImpl(Time t) const {
        if (t == 0.0)
            return forwardImpl(0.0);
        // implement smarter integration if plan to use the following code
        Rate sum = 0.5*forwardImpl(0.0);
        Size N = 1000;
        Time dt = t/N;
        for (Time i=dt; i<t; i+=dt)
            sum += forwardImpl(i);
        sum += 0.5*forwardImpl(t);
        return Rate(sum*dt/t);
    }

}
]]></document_content>
  </document>
  <document index="67">
    <source>yield/nonlinearfittingmethods.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Allen Kuo
 Copyright (C) 2010 Alessandro Roveda
 Copyright (C) 2015 Andres Hernandez

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/bernsteinpolynomial.hpp>
#include <ql/termstructures/yield/nonlinearfittingmethods.hpp>
#include <utility>

namespace QuantLib {

    ExponentialSplinesFitting::ExponentialSplinesFitting(
        bool constrainAtZero,
        const Array& weights,
        const ext::shared_ptr<OptimizationMethod>& optimizationMethod,
        const Array& l2,
        const Real minCutoffTime,
        const Real maxCutoffTime,
        const Size numCoeffs,
        const Real fixedKappa,
        Constraint constraint)
    : FittedBondDiscountCurve::FittingMethod(constrainAtZero, weights, optimizationMethod, l2,
                                             minCutoffTime, maxCutoffTime, std::move(constraint)),
      numCoeffs_(numCoeffs), fixedKappa_(fixedKappa) {
        QL_REQUIRE(ExponentialSplinesFitting::size() > 0, "At least 1 unconstrained coefficient required");
    }

    ExponentialSplinesFitting::ExponentialSplinesFitting(
        bool constrainAtZero,
        const Array& weights,
        const Array& l2, const Real minCutoffTime, const Real maxCutoffTime,
        const Size numCoeffs, const Real fixedKappa,
        Constraint constraint)
    : ExponentialSplinesFitting(constrainAtZero, weights, {}, l2,
                                minCutoffTime, maxCutoffTime,
                                numCoeffs, fixedKappa, std::move(constraint)) {}

    ExponentialSplinesFitting::ExponentialSplinesFitting(
        bool constrainAtZero,
        const Size numCoeffs,
        const Real fixedKappa,
        const Array& weights,
        Constraint constraint)
    : ExponentialSplinesFitting(constrainAtZero, weights, {}, Array(),
                                0.0, QL_MAX_REAL,
                                numCoeffs, fixedKappa, std::move(constraint)) {}

    std::unique_ptr<FittedBondDiscountCurve::FittingMethod>
    ExponentialSplinesFitting::clone() const {
        return std::make_unique<ExponentialSplinesFitting>(*this); 
    }

    Size ExponentialSplinesFitting::size() const {
        Size N = constrainAtZero_ ? numCoeffs_ : numCoeffs_ + 1;
        
        return (fixedKappa_ != Null<Real>()) ? N-1 : N; //One fewer optimization parameters if kappa is fixed
    }

    DiscountFactor ExponentialSplinesFitting::discountFunction(const Array& x,
                                                               Time t) const {
        DiscountFactor d = 0.0;
        Size N = size();
        //Use the interal fixedKappa_ member if non-zero, otherwise take kappa from the passed x[] array
        Real kappa = (fixedKappa_ != Null<Real>()) ? fixedKappa_: x[N-1];
        Real coeff = 0;

        if (!constrainAtZero_) {
            for (Size i = 0; i < N - 1; ++i) {
                d += x[i] * std::exp(-kappa * (i + 1) * t);
            }
        } else {
            //  notation:
            //  d(t) = coeff* exp(-kappa*1*t) + x[0]* exp(-kappa*2*t) +
            //  x[1]* exp(-kappa*3*t) + ..+ x[7]* exp(-kappa*9*t)
            for (Size i = 0; i < N - 1; i++) {
                d += x[i] * std::exp(-kappa * (i + 2) * t);
                coeff += x[i];
            }
            coeff = 1.0 - coeff;
            d += coeff * std::exp(-kappa * t);
        }

        return d;
    }


    NelsonSiegelFitting::NelsonSiegelFitting(
        const Array& weights,
        const ext::shared_ptr<OptimizationMethod>& optimizationMethod,
        const Array& l2,
        const Real minCutoffTime,
        const Real maxCutoffTime,
        Constraint constraint)
    : FittedBondDiscountCurve::FittingMethod(true, weights, optimizationMethod, l2,
                                             minCutoffTime, maxCutoffTime, std::move(constraint)) {}

    NelsonSiegelFitting::NelsonSiegelFitting(
        const Array& weights,
        const Array& l2,
        const Real minCutoffTime,
        const Real maxCutoffTime,
        Constraint constraint)
    : NelsonSiegelFitting(weights, {}, l2,
                          minCutoffTime, maxCutoffTime, std::move(constraint)) {}

    std::unique_ptr<FittedBondDiscountCurve::FittingMethod>
    NelsonSiegelFitting::clone() const {
        return std::make_unique<NelsonSiegelFitting>(*this);
    }

    Size NelsonSiegelFitting::size() const {
        return 4;
    }

    DiscountFactor NelsonSiegelFitting::discountFunction(const Array& x,
                                                         Time t) const {
        Real kappa = x[size()-1];
        Real zeroRate = x[0] + (x[1] + x[2])*
                        (1.0 - std::exp(-kappa*t))/
                        ((kappa+QL_EPSILON)*(t+QL_EPSILON)) -
                        (x[2])*std::exp(-kappa*t);
        DiscountFactor d = std::exp(-zeroRate * t) ;
        return d;
    }


    SvenssonFitting::SvenssonFitting(const Array& weights,
                                     const ext::shared_ptr<OptimizationMethod>& optimizationMethod,
                                     const Array& l2,
                                     const Real minCutoffTime,
                                     const Real maxCutoffTime,
                                     Constraint constraint)
    : FittedBondDiscountCurve::FittingMethod(true, weights, optimizationMethod, l2,
                                             minCutoffTime, maxCutoffTime, std::move(constraint)) {}

    SvenssonFitting::SvenssonFitting(const Array& weights,
                                     const Array& l2,
                                     const Real minCutoffTime,
                                     const Real maxCutoffTime,
                                     Constraint constraint)
    : SvenssonFitting(weights, {}, l2,
                      minCutoffTime, maxCutoffTime, std::move(constraint)) {}

    std::unique_ptr<FittedBondDiscountCurve::FittingMethod>
    SvenssonFitting::clone() const {
        return std::make_unique<SvenssonFitting>(*this);
    }

    Size SvenssonFitting::size() const {
        return 6;
    }

    DiscountFactor SvenssonFitting::discountFunction(const Array& x,
                                                     Time t) const {
        Real kappa = x[size()-2];
        Real kappa_1 = x[size()-1];

        Real zeroRate = x[0] + (x[1] + x[2])*
                        (1.0 - std::exp(-kappa*t))/
                        ((kappa+QL_EPSILON)*(t+QL_EPSILON)) -
                        (x[2])*std::exp(-kappa*t) +
                        x[3]* (((1.0 - std::exp(-kappa_1*t))/((kappa_1+QL_EPSILON)*(t+QL_EPSILON)))- std::exp(-kappa_1*t));
        DiscountFactor d = std::exp(-zeroRate * t) ;
        return d;
    }


    CubicBSplinesFitting::CubicBSplinesFitting(
        const std::vector<Time>& knots,
        bool constrainAtZero,
        const Array& weights,
        const ext::shared_ptr<OptimizationMethod>& optimizationMethod,
        const Array& l2,
        const Real minCutoffTime,
        const Real maxCutoffTime,
        Constraint constraint)
    : FittedBondDiscountCurve::FittingMethod(constrainAtZero, weights, optimizationMethod, l2,
                                             minCutoffTime, maxCutoffTime, std::move(constraint)),
      splines_(3, knots.size() - 5, knots) {

        QL_REQUIRE(knots.size() >= 8,
                   "At least 8 knots are required" );
        Size basisFunctions = knots.size() - 4;

        if (constrainAtZero) {
            size_ = basisFunctions-1;

            // Note: A small but nonzero N_th basis function at t=0 may
            // lead to an ill conditioned problem
            N_ = 1;

            QL_REQUIRE(std::abs(splines_(N_, 0.0)) > QL_EPSILON,
                       "N_th cubic B-spline must be nonzero at t=0");
        } else {
            size_ = basisFunctions;
            N_ = 0;
        }
    }

    CubicBSplinesFitting::CubicBSplinesFitting(
        const std::vector<Time>& knots,
        bool constrainAtZero,
        const Array& weights,
        const Array& l2,
        const Real minCutoffTime,
        const Real maxCutoffTime,
        Constraint constraint)
    : CubicBSplinesFitting(knots, constrainAtZero, weights, {}, l2,
                           minCutoffTime, maxCutoffTime, std::move(constraint)) {}

    Real CubicBSplinesFitting::basisFunction(Integer i, Time t) const {
        return splines_(i,t);
    }

    std::unique_ptr<FittedBondDiscountCurve::FittingMethod>
    CubicBSplinesFitting::clone() const {
        return std::make_unique<CubicBSplinesFitting>(*this);
    }

    Size CubicBSplinesFitting::size() const {
        return size_;
    }

    DiscountFactor CubicBSplinesFitting::discountFunction(const Array& x,
                                                          Time t) const {
        DiscountFactor d = 0.0;

        if (!constrainAtZero_) {
            for (Size i=0; i<size_; ++i) {
                d += x[i] * splines_(i,t);
            }
        } else {
            const Real T = 0.0;
            Real sum = 0.0;
            for (Size i=0; i<size_; ++i) {
                if (i < N_) {
                    d += x[i] * splines_(i,t);
                    sum += x[i] * splines_(i,T);
                } else {
                    d += x[i] * splines_(i+1,t);
                    sum += x[i] * splines_(i+1,T);
                }
            }
            Real coeff = 1.0 - sum;
            coeff /= splines_(N_,T);
            d += coeff * splines_(N_,t);
        }

        return d;
    }

    NaturalCubicFitting::NaturalCubicFitting(
        const std::vector<Time>& knotTimes,
        const Array& weights,
        const ext::shared_ptr<OptimizationMethod>& optimizationMethod,
        const Array& l2,
        Real minCutoffTime,
        Real maxCutoffTime,
        Constraint constraint)
    : FittedBondDiscountCurve::FittingMethod(true, weights, optimizationMethod, l2,
                                             minCutoffTime, maxCutoffTime, std::move(constraint)),
      knotTimes_(knotTimes) {
        knotTimes_.push_back(0.0);
        std::sort(knotTimes_.begin(), knotTimes_.end());

        auto last = std::unique(knotTimes_.begin(), knotTimes_.end(),
                                [](Time a, Time b){ return std::fabs(a - b) <= 1e-14; });
        knotTimes_.erase(last, knotTimes_.end());

        QL_REQUIRE(knotTimes_.size() >= 2,
                   "NaturalCubicFitting: at least two knot times required");

        const Size n = knotTimes_.size();
        size_ = n - 1;

        for (Size i = 0; i + 1 < n; ++i) {
            Real h = knotTimes_[i+1] - knotTimes_[i];
            QL_REQUIRE(h > 1e-14,
                       "NaturalCubicFitting: knot times must be strictly increasing (non-zero spacing)");
            QL_REQUIRE(std::isfinite(h),
                       "NaturalCubicFitting: non-finite knot spacing");
        }
    }

    NaturalCubicFitting::NaturalCubicFitting(
        const std::vector<Time>& knotTimes,
        const Array& weights,
        const Array& l2,
        Real minCutoffTime,
        Real maxCutoffTime,
        Constraint constraint)
    : NaturalCubicFitting(knotTimes, weights, {}, l2,
                          minCutoffTime, maxCutoffTime, std::move(constraint)) {}

    std::unique_ptr<FittedBondDiscountCurve::FittingMethod>
    NaturalCubicFitting::clone() const {
        return std::make_unique<NaturalCubicFitting>(*this);
    }

    Size NaturalCubicFitting::size() const {
        return size_;
    }

    DiscountFactor NaturalCubicFitting::discountFunction(const Array& x, Time t) const {
        const Size n = knotTimes_.size();
        const Size expected = size();
        QL_REQUIRE(x.size() == expected,
                   "NaturalCubicFitting::discountFunction(): parameter size mismatch: expected "
                   << expected << " got " << x.size());

        Array y(n);
        y[0] = 1.0;
        for (Size i = 1; i < n; ++i)
            y[i] = x[i - 1];

        for (Size i = 0; i < n; ++i)
            QL_REQUIRE(std::isfinite(y[i]), "NaturalCubicFitting::discountFunction(): non-finite nodal value");

        CubicNaturalSpline spline(knotTimes_.begin(), knotTimes_.end(), y.begin());
        spline.update();
        return spline(std::clamp(t, knotTimes_.front(), knotTimes_.back()));
    }


    SimplePolynomialFitting::SimplePolynomialFitting(
        Natural degree,
        bool constrainAtZero,
        const Array& weights,
        const ext::shared_ptr<OptimizationMethod>& optimizationMethod,
        const Array& l2,
        const Real minCutoffTime,
        const Real maxCutoffTime,
        Constraint constraint)
    : FittedBondDiscountCurve::FittingMethod(constrainAtZero, weights, optimizationMethod, l2,
                                             minCutoffTime, maxCutoffTime, std::move(constraint)),
      size_(constrainAtZero ? degree : degree + 1) {}

    SimplePolynomialFitting::SimplePolynomialFitting(
        Natural degree,
        bool constrainAtZero,
        const Array& weights,
        const Array& l2,
        const Real minCutoffTime,
        const Real maxCutoffTime,
        Constraint constraint)
    : SimplePolynomialFitting(degree, constrainAtZero, weights, {}, l2,
                              minCutoffTime, maxCutoffTime, std::move(constraint)) {}

    std::unique_ptr<FittedBondDiscountCurve::FittingMethod>
    SimplePolynomialFitting::clone() const {
        return std::make_unique<SimplePolynomialFitting>(*this);
    }

    Size SimplePolynomialFitting::size() const {
        return size_;
    }

    DiscountFactor SimplePolynomialFitting::discountFunction(const Array& x,
                                                             Time t) const {
        DiscountFactor d = 0.0;

        if (!constrainAtZero_) {
            for (Size i=0; i<size_; ++i)
                d += x[i] * BernsteinPolynomial::get(i,i,t);
        } else {
            d = 1.0;
            for (Size i=0; i<size_; ++i)
                d += x[i] * BernsteinPolynomial::get(i+1,i+1,t);
        }
        return d;
    }

    SpreadFittingMethod::SpreadFittingMethod(const ext::shared_ptr<FittingMethod>& method,
                                             Handle<YieldTermStructure> discountCurve,
                                             const Real minCutoffTime,
                                             const Real maxCutoffTime)
    : FittedBondDiscountCurve::FittingMethod(
          method != nullptr ? method->constrainAtZero() : true,
          method != nullptr ? method->weights() : Array(),
          method != nullptr ? method->optimizationMethod() : ext::shared_ptr<OptimizationMethod>(),
          method != nullptr ? method->l2() : Array(),
          minCutoffTime,
          maxCutoffTime),
      method_(method), discountingCurve_(std::move(discountCurve)) {
        QL_REQUIRE(method, "Fitting method is empty");
        QL_REQUIRE(!discountingCurve_.empty(), "Discounting curve cannot be empty");
    }

    std::unique_ptr<FittedBondDiscountCurve::FittingMethod>
    SpreadFittingMethod::clone() const {
        return std::make_unique<SpreadFittingMethod>(*this);
    }

    Size SpreadFittingMethod::size() const {
        return method_->size();
    }

    DiscountFactor SpreadFittingMethod::discountFunction(const Array& x, Time t) const{
        return method_->discount(x, t)*discountingCurve_->discount(t, true)/rebase_;
    }

    void SpreadFittingMethod::init(){
        //In case discount curve has a different reference date,
        //discount to this curve's reference date
        if (curve_->referenceDate() != discountingCurve_->referenceDate()){
            rebase_ = discountingCurve_->discount(curve_->referenceDate());
        }
        else{
            rebase_ = 1.0;
        }
        //Call regular init
        FittedBondDiscountCurve::FittingMethod::init();
    }
}

]]></document_content>
  </document>
  <document index="68">
    <source>yield/oisratehelper.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009, 2012 Roland Lichters
 Copyright (C) 2009, 2012 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/makeois.hpp>
#include <ql/instruments/simplifynotificationgraph.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/overnightindexedcoupon.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/termstructures/yield/oisratehelper.hpp>
#include <ql/utilities/null_deleter.hpp>
#include <utility>

namespace QuantLib {

    OISRateHelper::OISRateHelper(
        Natural settlementDays,
        const Period& tenor, // swap maturity
        const std::variant<Rate, Handle<Quote>>& fixedRate,
        const ext::shared_ptr<OvernightIndex>& overnightIndex,
        Handle<YieldTermStructure> discount,
        bool telescopicValueDates,
        Integer paymentLag,
        BusinessDayConvention paymentConvention,
        Frequency paymentFrequency,
        Calendar paymentCalendar,
        const Period& forwardStart,
        const std::variant<Spread, Handle<Quote>>& overnightSpread,
        Pillar::Choice pillar,
        Date customPillarDate,
        RateAveraging::Type averagingMethod,
        ext::optional<bool> endOfMonth,
        ext::optional<Frequency> fixedPaymentFrequency,
        Calendar fixedCalendar,
        Natural lookbackDays,
        Natural lockoutDays,
        bool applyObservationShift,
        ext::shared_ptr<FloatingRateCouponPricer> pricer,
        DateGeneration::Rule rule,
        Calendar overnightCalendar,
        BusinessDayConvention convention)
    : RelativeDateRateHelper(fixedRate), settlementDays_(settlementDays), tenor_(tenor),
      discountHandle_(std::move(discount)), telescopicValueDates_(telescopicValueDates),
      paymentLag_(paymentLag), paymentConvention_(paymentConvention),
      paymentFrequency_(paymentFrequency), paymentCalendar_(std::move(paymentCalendar)),
      forwardStart_(forwardStart), overnightSpread_(handleFromVariant(overnightSpread)), pillarChoice_(pillar),
      averagingMethod_(averagingMethod), endOfMonth_(endOfMonth),
      fixedPaymentFrequency_(fixedPaymentFrequency), fixedCalendar_(std::move(fixedCalendar)),
      overnightCalendar_(std::move(overnightCalendar)), convention_(convention),
      lookbackDays_(lookbackDays), lockoutDays_(lockoutDays),
      applyObservationShift_(applyObservationShift), pricer_(std::move(pricer)), rule_(rule) {
        initialize(overnightIndex, customPillarDate);
    }

    OISRateHelper::OISRateHelper(
        const Date& startDate,
        const Date& endDate,
        const std::variant<Rate, Handle<Quote>>& fixedRate,
        const ext::shared_ptr<OvernightIndex>& overnightIndex,
        Handle<YieldTermStructure> discount,
        bool telescopicValueDates,
        Integer paymentLag,
        BusinessDayConvention paymentConvention,
        Frequency paymentFrequency,
        Calendar paymentCalendar,
        const std::variant<Spread, Handle<Quote>>& overnightSpread,
        Pillar::Choice pillar,
        Date customPillarDate,
        RateAveraging::Type averagingMethod,
        ext::optional<bool> endOfMonth,
        ext::optional<Frequency> fixedPaymentFrequency,
        Calendar fixedCalendar,
        Natural lookbackDays,
        Natural lockoutDays,
        bool applyObservationShift,
        ext::shared_ptr<FloatingRateCouponPricer> pricer,
        DateGeneration::Rule rule,
        Calendar overnightCalendar,
        BusinessDayConvention convention)
    : RelativeDateRateHelper(fixedRate, false), startDate_(startDate), endDate_(endDate),
      discountHandle_(std::move(discount)), telescopicValueDates_(telescopicValueDates),
      paymentLag_(paymentLag), paymentConvention_(paymentConvention),
      paymentFrequency_(paymentFrequency), paymentCalendar_(std::move(paymentCalendar)),
      overnightSpread_(handleFromVariant(overnightSpread)), pillarChoice_(pillar),
      averagingMethod_(averagingMethod), endOfMonth_(endOfMonth),
      fixedPaymentFrequency_(fixedPaymentFrequency), fixedCalendar_(std::move(fixedCalendar)),
      overnightCalendar_(std::move(overnightCalendar)), convention_(convention),
      lookbackDays_(lookbackDays), lockoutDays_(lockoutDays),
      applyObservationShift_(applyObservationShift), pricer_(std::move(pricer)), rule_(rule) {
        initialize(overnightIndex, customPillarDate);
    }

    void OISRateHelper::initialize(const ext::shared_ptr<OvernightIndex>& overnightIndex,
                                   Date customPillarDate) {
        overnightIndex_ =
            ext::dynamic_pointer_cast<OvernightIndex>(overnightIndex->clone(termStructureHandle_));
        // We want to be notified of changes of fixings, but we don't
        // want notifications from termStructureHandle_ (they would
        // interfere with bootstrapping.)
        overnightIndex_->unregisterWith(termStructureHandle_);

        registerWith(overnightIndex_);
        registerWith(discountHandle_);
        registerWith(overnightSpread_);

        pillarDate_ = customPillarDate;
        OISRateHelper::initializeDates();
    }

    void OISRateHelper::initializeDates() {

        // 1. do not pass the spread here, as it might be a Quote
        //    i.e. it can dynamically change
        // 2. input discount curve Handle might be empty now but it could
        //    be assigned a curve later; use a RelinkableHandle here
        auto tmp = MakeOIS(tenor_, overnightIndex_, 0.0, forwardStart_)
            .withDiscountingTermStructure(discountRelinkableHandle_)
            .withSettlementDays(settlementDays_)  // resets effectiveDate
            .withEffectiveDate(startDate_)
            .withTerminationDate(endDate_)
            .withTelescopicValueDates(telescopicValueDates_)
            .withPaymentLag(paymentLag_)
            .withPaymentAdjustment(paymentConvention_)
            .withPaymentFrequency(paymentFrequency_)
            .withPaymentCalendar(paymentCalendar_)
            .withAveragingMethod(averagingMethod_)
            .withLookbackDays(lookbackDays_)
            .withLockoutDays(lockoutDays_)
            .withRule(rule_)
            .withConvention(convention_)
            .withTerminationDateConvention(convention_)
            .withObservationShift(applyObservationShift_);
        if (endOfMonth_) {
            tmp.withEndOfMonth(*endOfMonth_);
        }
        if (fixedPaymentFrequency_) {
            tmp.withFixedLegPaymentFrequency(*fixedPaymentFrequency_);
        }
        if (!fixedCalendar_.empty()) {
            tmp.withFixedLegCalendar(fixedCalendar_);
        }
        if (!overnightCalendar_.empty()) {
            tmp.withOvernightLegCalendar(overnightCalendar_);
        }
        swap_ = tmp;

        if (pricer_)
            setCouponPricer(swap_->overnightLeg(), pricer_);

        simplifyNotificationGraph(*swap_, true);

        earliestDate_ = swap_->startDate();
        maturityDate_ = swap_->maturityDate();

        Date lastPaymentDate = std::max(swap_->overnightLeg().back()->date(),
                                        swap_->fixedLeg().back()->date());
        Date lastFixingDate =
            ext::dynamic_pointer_cast<OvernightIndexedCoupon>(swap_->overnightLeg().back())->fixingDate();
        Date fixingEndDate =
            overnightIndex_->maturityDate(overnightIndex_->valueDate(lastFixingDate));
        latestRelevantDate_ = latestDate_ = std::max({maturityDate_, lastPaymentDate, fixingEndDate});

        switch (pillarChoice_) {
          case Pillar::MaturityDate:
            pillarDate_ = maturityDate_;
            break;
          case Pillar::LastRelevantDate:
            pillarDate_ = latestRelevantDate_;
            break;
          case Pillar::CustomDate:
            // pillarDate_ already assigned at construction time
            QL_REQUIRE(pillarDate_ >= earliestDate_,
                       "pillar date (" << pillarDate_ << ") must be later "
                       "than or equal to the instrument's earliest date (" <<
                       earliestDate_ << ")");
            QL_REQUIRE(pillarDate_ <= latestRelevantDate_,
                       "pillar date (" << pillarDate_ << ") must be before "
                       "or equal to the instrument's latest relevant date (" <<
                       latestRelevantDate_ << ")");
            break;
          default:
            QL_FAIL("unknown Pillar::Choice(" << Integer(pillarChoice_) << ")");
        }
    }

    void OISRateHelper::setTermStructure(YieldTermStructure* t) {
        // do not set the relinkable handle as an observer -
        // force recalculation when needed
        bool observer = false;

        ext::shared_ptr<YieldTermStructure> temp(t, null_deleter());
        termStructureHandle_.linkTo(temp, observer);

        if (discountHandle_.empty())
            discountRelinkableHandle_.linkTo(temp, observer);
        else
            discountRelinkableHandle_.linkTo(*discountHandle_, observer);

        RelativeDateRateHelper::setTermStructure(t);
    }

    Real OISRateHelper::impliedQuote() const {
        QL_REQUIRE(termStructure_ != nullptr, "term structure not set");
        // we didn't register as observers - force calculation
        swap_->deepUpdate();
        // weak implementation... to be improved
        static const Spread basisPoint = 1.0e-4;
        Real floatingLegNPV = swap_->overnightLegNPV();
        Spread spread = overnightSpread_.empty() ? 0.0 : overnightSpread_->value();
        Real spreadNPV = swap_->overnightLegBPS()/basisPoint*spread;
        Real totNPV = - (floatingLegNPV+spreadNPV);
        Real result = totNPV/(swap_->fixedLegBPS()/basisPoint);
        return result;
    }

    void OISRateHelper::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<OISRateHelper>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            RateHelper::accept(v);
    }

}
]]></document_content>
  </document>
  <document index="69">
    <source>yield/overnightindexfutureratehelper.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Roy Zywina
 Copyright (C) 2019, 2020 Eisuke Tani

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/yield/overnightindexfutureratehelper.hpp>
#include <ql/indexes/ibor/sofr.hpp>
#include <ql/utilities/null_deleter.hpp>

namespace QuantLib {

    namespace {

        Date getSofrStart(Month month, Year year, Frequency freq) {
            return freq == Monthly ? Date(1, month, year) :
                   Date::nthWeekday(3, Wednesday, month, year);
        }

        Date getSofrEnd(Month month, Year year, Frequency freq) {
            if (freq == Monthly) {
                return Date::endOfMonth(Date(1, month, year)) + 1;
            } else {
                Date d = getSofrStart(month, year, freq) + Period(freq);
                return Date::nthWeekday(3, Wednesday, d.month(), d.year());
            }

        }

    }

    OvernightIndexFutureRateHelper::OvernightIndexFutureRateHelper(
        const Handle<Quote>& price,
        // first day of reference period
        const Date& valueDate,
        // delivery date
        const Date& maturityDate,
        const ext::shared_ptr<OvernightIndex>& overnightIndex,
        const Handle<Quote>& convexityAdjustment,
        RateAveraging::Type averagingMethod)
    : RateHelper(price) {
        ext::shared_ptr<OvernightIndex> index =
            ext::dynamic_pointer_cast<OvernightIndex>(overnightIndex->clone(termStructureHandle_));
        future_ = ext::make_shared<OvernightIndexFuture>(
            index, valueDate, maturityDate, convexityAdjustment, averagingMethod);
        registerWithObservables(future_);
        earliestDate_ = valueDate;
        latestDate_ = maturityDate;
    }

    Real OvernightIndexFutureRateHelper::impliedQuote() const {
        future_->recalculate();
        return future_->NPV();
    }

    void OvernightIndexFutureRateHelper::setTermStructure(YieldTermStructure* t) {
        // do not set the relinkable handle as an observer -
        // force recalculation when needed
        bool observer = false;

        ext::shared_ptr<YieldTermStructure> temp(t, null_deleter());
        termStructureHandle_.linkTo(temp, observer);

        RateHelper::setTermStructure(t);
    }

    void OvernightIndexFutureRateHelper::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<OvernightIndexFutureRateHelper>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            RateHelper::accept(v);
    }

    Real OvernightIndexFutureRateHelper::convexityAdjustment() const {
        return future_->convexityAdjustment();
    }


    SofrFutureRateHelper::SofrFutureRateHelper(
        const Handle<Quote>& price,
        Month referenceMonth,
        Year referenceYear,
        Frequency referenceFreq,
        const Handle<Quote>& convexityAdjustment)
    : OvernightIndexFutureRateHelper(price,
            getSofrStart(referenceMonth, referenceYear, referenceFreq),
            getSofrEnd(referenceMonth, referenceYear, referenceFreq),
            ext::make_shared<Sofr>(),
            convexityAdjustment,
            referenceFreq == Quarterly ? RateAveraging::Compound : RateAveraging::Simple) {
        QL_REQUIRE(referenceFreq == Quarterly || referenceFreq == Monthly,
            "only monthly and quarterly SOFR futures accepted");
    }

    SofrFutureRateHelper::SofrFutureRateHelper(
        Real price,
        Month referenceMonth,
        Year referenceYear,
        Frequency referenceFreq,
        Real convexityAdjustment)
    : OvernightIndexFutureRateHelper(
            Handle<Quote>(ext::make_shared<SimpleQuote>(price)),
            getSofrStart(referenceMonth, referenceYear, referenceFreq),
            getSofrEnd(referenceMonth, referenceYear, referenceFreq),
            ext::make_shared<Sofr>(),
            Handle<Quote>(ext::make_shared<SimpleQuote>(convexityAdjustment)),
            referenceFreq == Quarterly ? RateAveraging::Compound : RateAveraging::Simple) {
        QL_REQUIRE(referenceFreq == Quarterly || referenceFreq == Monthly,
            "only monthly and quarterly SOFR futures accepted");
    }
}
]]></document_content>
  </document>
  <document index="70">
    <source>yield/ratehelpers.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008 StatPro Italia srl
 Copyright (C) 2007, 2008, 2009, 2015 Ferdinando Ametrano
 Copyright (C) 2007, 2009 Roland Lichters
 Copyright (C) 2015 Maddalena Zanzi
 Copyright (C) 2015 Paolo Mazzocchi
 Copyright (C) 2018 Matthias Lungwitz

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/iborcoupon.hpp>
#include <ql/currency.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/instruments/makevanillaswap.hpp>
#include <ql/instruments/simplifynotificationgraph.hpp>
#include <ql/optional.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/quote.hpp>
#include <ql/termstructures/yield/ratehelpers.hpp>
#include <ql/time/asx.hpp>
#include <ql/time/calendars/jointcalendar.hpp>
#include <ql/time/imm.hpp>
#include <ql/utilities/null_deleter.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        void CheckDate(const Date& date, const Futures::Type type) {
            switch (type) {
              case Futures::IMM:
                QL_REQUIRE(IMM::isIMMdate(date, false), date << " is not a valid IMM date");
                break;
              case Futures::ASX:
                QL_REQUIRE(ASX::isASXdate(date, false), date << " is not a valid ASX date");
                break;
              case Futures::Custom:
                break;
              default:
                QL_FAIL("unknown futures type (" << type << ')');
            }
        }

        Time DetermineYearFraction(const Date& earliestDate,
                                   const Date& maturityDate,
                                   const DayCounter& dayCounter) {
            return dayCounter.yearFraction(earliestDate, maturityDate,
                                           earliestDate, maturityDate);
        }

    } // namespace

    FuturesRateHelper::FuturesRateHelper(const std::variant<Real, Handle<Quote>>& price,
                                         const Date& iborStartDate,
                                         Natural lengthInMonths,
                                         const Calendar& calendar,
                                         BusinessDayConvention convention,
                                         bool endOfMonth,
                                         const DayCounter& dayCounter,
                                         const std::variant<Real, Handle<Quote>>& convAdj,
                                         Futures::Type type)
    : RateHelper(price), convAdj_(handleFromVariant(convAdj)) {
        CheckDate(iborStartDate, type);

        earliestDate_ = iborStartDate;
        maturityDate_ =
            calendar.advance(iborStartDate, lengthInMonths * Months, convention, endOfMonth);
        yearFraction_ = DetermineYearFraction(earliestDate_, maturityDate_, dayCounter);
        pillarDate_ = latestDate_ = latestRelevantDate_ = maturityDate_;

        registerWith(convAdj_);
    }

    FuturesRateHelper::FuturesRateHelper(const std::variant<Real, Handle<Quote>>& price,
                                         const Date& iborStartDate,
                                         const Date& iborEndDate,
                                         const DayCounter& dayCounter,
                                         const std::variant<Real, Handle<Quote>>& convAdj,
                                         Futures::Type type)
    : RateHelper(price), convAdj_(handleFromVariant(convAdj)) {
        CheckDate(iborStartDate, type);

        const auto determineMaturityDate =
            [&iborStartDate, &iborEndDate](const auto nextDateCalculator) -> Date {
                Date maturityDate;
                if (iborEndDate == Date()) {
                    // advance 3 months
                    maturityDate = nextDateCalculator(iborStartDate);
                    maturityDate = nextDateCalculator(maturityDate);
                    maturityDate = nextDateCalculator(maturityDate);
                } else {
                    QL_REQUIRE(iborEndDate > iborStartDate,
                               "end date (" << iborEndDate << ") must be greater than start date ("
                                            << iborStartDate << ')');
                    maturityDate = iborEndDate;
                }
                return maturityDate;
            };

        switch (type) {
          case Futures::IMM:
            maturityDate_ = determineMaturityDate(
                [](const Date date) -> Date { return IMM::nextDate(date, false); });
            break;
          case Futures::ASX:
            maturityDate_ = determineMaturityDate(
                [](const Date date) -> Date { return ASX::nextDate(date, false); });
            break;
          case Futures::Custom:
            maturityDate_ = iborEndDate;
            break;
          default:
            QL_FAIL("unsupported futures type (" << type << ')');
        }
        earliestDate_ = iborStartDate;
        yearFraction_ = DetermineYearFraction(earliestDate_, maturityDate_, dayCounter);
        pillarDate_ = latestDate_ = latestRelevantDate_ = maturityDate_;

        registerWith(convAdj_);
    }

    FuturesRateHelper::FuturesRateHelper(const std::variant<Real, Handle<Quote>>& price,
                                         const Date& iborStartDate,
                                         const ext::shared_ptr<IborIndex>& index,
                                         const std::variant<Real, Handle<Quote>>& convAdj,
                                         Futures::Type type)
    : RateHelper(price), convAdj_(handleFromVariant(convAdj)) {
        CheckDate(iborStartDate, type);

        earliestDate_ = iborStartDate;
        const Calendar& cal = index->fixingCalendar();
        maturityDate_ =
            cal.advance(iborStartDate, index->tenor(), index->businessDayConvention());
        yearFraction_ = DetermineYearFraction(earliestDate_, maturityDate_, index->dayCounter());
        pillarDate_ = latestDate_ = latestRelevantDate_ = maturityDate_;

        registerWith(convAdj_);
    }

    Real FuturesRateHelper::impliedQuote() const {
        QL_REQUIRE(termStructure_ != nullptr, "term structure not set");
        Rate forwardRate = (termStructure_->discount(earliestDate_) /
            termStructure_->discount(maturityDate_) - 1.0) / yearFraction_;
        // Convexity, as FRA/futures adjustment, has been used in the
        // past to take into account futures margining vs FRA.
        // Therefore, there's no requirement for it to be non-negative.
        Rate futureRate = forwardRate + convexityAdjustment();
        return 100.0 * (1.0 - futureRate);
    }

    Real FuturesRateHelper::convexityAdjustment() const {
        return convAdj_.empty() ? 0.0 : convAdj_->value();
    }

    void FuturesRateHelper::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<FuturesRateHelper>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            RateHelper::accept(v);
    }

    DepositRateHelper::DepositRateHelper(const std::variant<Rate, Handle<Quote>>& rate,
                                         const Period& tenor,
                                         Natural fixingDays,
                                         const Calendar& calendar,
                                         BusinessDayConvention convention,
                                         bool endOfMonth,
                                         const DayCounter& dayCounter)
    : RelativeDateRateHelper(rate) {
        iborIndex_ = ext::make_shared<IborIndex>("no-fix", // never take fixing into account
                      tenor, fixingDays,
                      Currency(), calendar, convention,
                      endOfMonth, dayCounter, termStructureHandle_);
        DepositRateHelper::initializeDates();
    }

    DepositRateHelper::DepositRateHelper(const std::variant<Rate, Handle<Quote>>& rate,
                                         const ext::shared_ptr<IborIndex>& i)
    : RelativeDateRateHelper(rate) {
        iborIndex_ = i->clone(termStructureHandle_);
        DepositRateHelper::initializeDates();
    }

    DepositRateHelper::DepositRateHelper(const std::variant<Rate, Handle<Quote>>& rate,
                                         Date fixingDate,
                                         const ext::shared_ptr<IborIndex>& i)
    : RelativeDateRateHelper(rate, false), fixingDate_(fixingDate) {
        iborIndex_ = i->clone(termStructureHandle_);
        DepositRateHelper::initializeDates();
    }

    Real DepositRateHelper::impliedQuote() const {
        QL_REQUIRE(termStructure_ != nullptr, "term structure not set");
        // the forecast fixing flag is set to true because
        // we do not want to take fixing into account
        return iborIndex_->fixing(fixingDate_, true);
    }

    void DepositRateHelper::setTermStructure(YieldTermStructure* t) {
        // do not set the relinkable handle as an observer -
        // force recalculation when needed---the index is not lazy
        bool observer = false;

        ext::shared_ptr<YieldTermStructure> temp(t, null_deleter());
        termStructureHandle_.linkTo(temp, observer);

        RelativeDateRateHelper::setTermStructure(t);
    }

    void DepositRateHelper::initializeDates() {
        if (updateDates_) {
            // if the evaluation date is not a business day
            // then move to the next business day
            Date referenceDate =
                iborIndex_->fixingCalendar().adjust(evaluationDate_);
            earliestDate_ = iborIndex_->valueDate(referenceDate);
            fixingDate_ = iborIndex_->fixingDate(earliestDate_);
        } else {
            earliestDate_ = iborIndex_->valueDate(fixingDate_);
        }
        maturityDate_ = iborIndex_->maturityDate(earliestDate_);
        pillarDate_ = latestDate_ = latestRelevantDate_ = maturityDate_;
    }

    void DepositRateHelper::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<DepositRateHelper>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            RateHelper::accept(v);
    }


    FraRateHelper::FraRateHelper(const std::variant<Rate, Handle<Quote>>& rate,
                                 Natural monthsToStart,
                                 Natural monthsToEnd,
                                 Natural fixingDays,
                                 const Calendar& calendar,
                                 BusinessDayConvention convention,
                                 bool endOfMonth,
                                 const DayCounter& dayCounter,
                                 Pillar::Choice pillarChoice,
                                 Date customPillarDate,
                                 bool useIndexedCoupon)
    : FraRateHelper(rate, monthsToStart*Months, monthsToEnd-monthsToStart, fixingDays, calendar,
        convention, endOfMonth, dayCounter, pillarChoice, customPillarDate, useIndexedCoupon) {
        QL_REQUIRE(monthsToEnd>monthsToStart,
                   "monthsToEnd (" << monthsToEnd <<
                   ") must be grater than monthsToStart (" << monthsToStart <<
                   ")");
    }

    FraRateHelper::FraRateHelper(const std::variant<Rate, Handle<Quote>>& rate,
                                 Natural monthsToStart,
                                 const ext::shared_ptr<IborIndex>& i,
                                 Pillar::Choice pillarChoice,
                                 Date customPillarDate,
                                 bool useIndexedCoupon)
    : FraRateHelper(rate, monthsToStart*Months, i, pillarChoice, customPillarDate, useIndexedCoupon)
    {}

    FraRateHelper::FraRateHelper(const std::variant<Rate, Handle<Quote>>& rate,
                                 Period periodToStart,
                                 Natural lengthInMonths,
                                 Natural fixingDays,
                                 const Calendar& calendar,
                                 BusinessDayConvention convention,
                                 bool endOfMonth,
                                 const DayCounter& dayCounter,
                                 Pillar::Choice pillarChoice,
                                 Date customPillarDate,
                                 bool useIndexedCoupon)
    : RelativeDateRateHelper(rate), periodToStart_(periodToStart),
      pillarChoice_(pillarChoice), useIndexedCoupon_(useIndexedCoupon) {
        // no way to take fixing into account,
        // even if we would like to for FRA over today
        iborIndex_ = ext::make_shared<IborIndex>("no-fix", // correct family name would be needed
                      lengthInMonths*Months,
                      fixingDays,
                      Currency(), calendar, convention,
                      endOfMonth, dayCounter, termStructureHandle_);
        pillarDate_ = customPillarDate;
        FraRateHelper::initializeDates();
    }

    FraRateHelper::FraRateHelper(const std::variant<Rate, Handle<Quote>>& rate,
                                 Period periodToStart,
                                 const ext::shared_ptr<IborIndex>& i,
                                 Pillar::Choice pillarChoice,
                                 Date customPillarDate,
                                 bool useIndexedCoupon)
    : RelativeDateRateHelper(rate), periodToStart_(periodToStart),
      pillarChoice_(pillarChoice), useIndexedCoupon_(useIndexedCoupon) {
        // take fixing into account
        iborIndex_ = i->clone(termStructureHandle_);
        // We want to be notified of changes of fixings, but we don't
        // want notifications from termStructureHandle_ (they would
        // interfere with bootstrapping.)
        iborIndex_->unregisterWith(termStructureHandle_);
        registerWith(iborIndex_);
        pillarDate_ = customPillarDate;
        FraRateHelper::initializeDates();
    }

    FraRateHelper::FraRateHelper(const std::variant<Rate, Handle<Quote>>& rate,
                                 Natural immOffsetStart,
                                 Natural immOffsetEnd,
                                 const ext::shared_ptr<IborIndex>& i,
                                 Pillar::Choice pillarChoice,
                                 Date customPillarDate,
                                 bool useIndexedCoupon)
    : RelativeDateRateHelper(rate), immOffsetStart_(immOffsetStart), immOffsetEnd_(immOffsetEnd),
      pillarChoice_(pillarChoice), useIndexedCoupon_(useIndexedCoupon) {
        // take fixing into account
        iborIndex_ = i->clone(termStructureHandle_);
        // see above
        iborIndex_->unregisterWith(termStructureHandle_);
        registerWith(iborIndex_);
        pillarDate_ = customPillarDate;
        FraRateHelper::initializeDates();
    }

    FraRateHelper::FraRateHelper(const std::variant<Rate, Handle<Quote>>& rate,
                                 Date startDate,
                                 Date endDate,
                                 const ext::shared_ptr<IborIndex>& i,
                                 Pillar::Choice pillarChoice,
                                 Date customPillarDate,
                                 bool useIndexedCoupon)
    : RelativeDateRateHelper(rate, false), pillarChoice_(pillarChoice),
      useIndexedCoupon_(useIndexedCoupon) {
        // take fixing into account
        iborIndex_ = i->clone(termStructureHandle_);
        // see above
        iborIndex_->unregisterWith(termStructureHandle_);
        registerWith(iborIndex_);
        earliestDate_ = startDate;
        maturityDate_ = endDate;
        pillarDate_ = customPillarDate;
        FraRateHelper::initializeDates();
    }

    Real FraRateHelper::impliedQuote() const {
        QL_REQUIRE(termStructure_ != nullptr, "term structure not set");
        if (useIndexedCoupon_)
            return iborIndex_->fixing(fixingDate_, true);
        else
            return (termStructure_->discount(earliestDate_) /
                        termStructure_->discount(maturityDate_) -
                    1.0) /
                   spanningTime_;
    }

    void FraRateHelper::setTermStructure(YieldTermStructure* t) {
        // do not set the relinkable handle as an observer -
        // force recalculation when needed---the index is not lazy
        bool observer = false;

        ext::shared_ptr<YieldTermStructure> temp(t, null_deleter());
        termStructureHandle_.linkTo(temp, observer);

        RelativeDateRateHelper::setTermStructure(t);
    }

    namespace {
        Date nthImmDate(const Date& asof, const Size n) {
            Date imm = asof;
            for (Size i = 0; i < n; ++i) {
                imm = IMM::nextDate(imm, true);
            }
            return imm;
        }
    }

    void FraRateHelper::initializeDates() {
        if (updateDates_) {
            // if the evaluation date is not a business day
            // then move to the next business day
            Date referenceDate =
                iborIndex_->fixingCalendar().adjust(evaluationDate_);
            Date spotDate = iborIndex_->fixingCalendar().advance(
                referenceDate, iborIndex_->fixingDays()*Days);
            if (periodToStart_) { // NOLINT(readability-implicit-bool-conversion)
                earliestDate_ = iborIndex_->fixingCalendar().advance(
                    spotDate, *periodToStart_, iborIndex_->businessDayConvention(),
                    iborIndex_->endOfMonth());
                // maturity date is calculated from spot date
                maturityDate_ = iborIndex_->fixingCalendar().advance(
                    spotDate, *periodToStart_ + iborIndex_->tenor(), iborIndex_->businessDayConvention(),
                    iborIndex_->endOfMonth());

            } else if ((immOffsetStart_) && (immOffsetEnd_)) { // NOLINT(readability-implicit-bool-conversion)
                earliestDate_ = iborIndex_->fixingCalendar().adjust(nthImmDate(spotDate, *immOffsetStart_));
                maturityDate_ = iborIndex_->fixingCalendar().adjust(nthImmDate(spotDate, *immOffsetEnd_));
            } else {
                QL_FAIL("neither periodToStart nor immOffsetStart/End given");
            }
        }

        if (useIndexedCoupon_)
            // latest relevant date is calculated from earliestDate_
            latestRelevantDate_ = iborIndex_->maturityDate(earliestDate_);
        else {
            latestRelevantDate_ = maturityDate_;
            spanningTime_ = iborIndex_->dayCounter().yearFraction(earliestDate_, maturityDate_);
        }

        switch (pillarChoice_) {
          case Pillar::MaturityDate:
            pillarDate_ = maturityDate_;
            break;
          case Pillar::LastRelevantDate:
            pillarDate_ = latestRelevantDate_;
            break;
          case Pillar::CustomDate:
            // pillarDate_ already assigned at construction time
            QL_REQUIRE(pillarDate_ >= earliestDate_,
                       "pillar date (" << pillarDate_ << ") must be later "
                       "than or equal to the instrument's earliest date (" <<
                       earliestDate_ << ")");
            QL_REQUIRE(pillarDate_ <= latestRelevantDate_,
                       "pillar date (" << pillarDate_ << ") must be before "
                       "or equal to the instrument's latest relevant date (" <<
                       latestRelevantDate_ << ")");
            break;
          default:
            QL_FAIL("unknown Pillar::Choice(" << Integer(pillarChoice_) << ")");
        }

        latestDate_ = pillarDate_; // backward compatibility

        fixingDate_ = iborIndex_->fixingDate(earliestDate_);
    }

    void FraRateHelper::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<FraRateHelper>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            RateHelper::accept(v);
    }


    SwapRateHelper::SwapRateHelper(const std::variant<Rate, Handle<Quote>>& rate,
                                   const ext::shared_ptr<SwapIndex>& swapIndex,
                                   Handle<Quote> spread,
                                   const Period& fwdStart,
                                   Handle<YieldTermStructure> discount,
                                   Pillar::Choice pillarChoice,
                                   Date customPillarDate,
                                   bool endOfMonth,
                                   const ext::optional<bool>& useIndexedCoupons)
    : SwapRateHelper(rate, swapIndex->tenor(), swapIndex->fixingCalendar(),
        swapIndex->fixedLegTenor().frequency(), swapIndex->fixedLegConvention(),
        swapIndex->dayCounter(), swapIndex->iborIndex(), std::move(spread), fwdStart,
        std::move(discount), Null<Natural>(), pillarChoice, customPillarDate, endOfMonth,
        useIndexedCoupons) {}

    SwapRateHelper::SwapRateHelper(const std::variant<Rate, Handle<Quote>>& rate,
                                   const Period& tenor,
                                   Calendar calendar,
                                   Frequency fixedFrequency,
                                   BusinessDayConvention fixedConvention,
                                   DayCounter fixedDayCount,
                                   const ext::shared_ptr<IborIndex>& iborIndex,
                                   Handle<Quote> spread,
                                   const Period& fwdStart,
                                   Handle<YieldTermStructure> discount,
                                   Natural settlementDays,
                                   Pillar::Choice pillarChoice,
                                   Date customPillarDate,
                                   bool endOfMonth,
                                   const ext::optional<bool>& useIndexedCoupons,
                                   const ext::optional<BusinessDayConvention>& floatConvention)
    : RelativeDateRateHelper(rate), settlementDays_(settlementDays), tenor_(tenor),
      pillarChoice_(pillarChoice), calendar_(std::move(calendar)),
      fixedConvention_(fixedConvention), fixedFrequency_(fixedFrequency),
      fixedDayCount_(std::move(fixedDayCount)), spread_(std::move(spread)), endOfMonth_(endOfMonth),
      fwdStart_(fwdStart), discountHandle_(std::move(discount)),
      useIndexedCoupons_(useIndexedCoupons), floatConvention_(floatConvention) {
        initialize(iborIndex, customPillarDate);
    }

    SwapRateHelper::SwapRateHelper(const std::variant<Rate, Handle<Quote>>& rate,
                                   const Date& startDate,
                                   const Date& endDate,
                                   Calendar calendar,
                                   Frequency fixedFrequency,
                                   BusinessDayConvention fixedConvention,
                                   DayCounter fixedDayCount,
                                   const ext::shared_ptr<IborIndex>& iborIndex,
                                   Handle<Quote> spread,
                                   Handle<YieldTermStructure> discount,
                                   Pillar::Choice pillarChoice,
                                   Date customPillarDate,
                                   bool endOfMonth,
                                   const ext::optional<bool>& useIndexedCoupons,
                                   const ext::optional<BusinessDayConvention>& floatConvention)
    : RelativeDateRateHelper(rate, false), startDate_(startDate), endDate_(endDate),
      pillarChoice_(pillarChoice), calendar_(std::move(calendar)),
      fixedConvention_(fixedConvention), fixedFrequency_(fixedFrequency),
      fixedDayCount_(std::move(fixedDayCount)), spread_(std::move(spread)), endOfMonth_(endOfMonth),
      discountHandle_(std::move(discount)), useIndexedCoupons_(useIndexedCoupons),
      floatConvention_(floatConvention) {
        QL_REQUIRE(fixedFrequency != Once,
            "fixedFrequency == Once is not supported when passing explicit "
            "startDate and endDate");
        initialize(iborIndex, customPillarDate);
    }

    void SwapRateHelper::initialize(const ext::shared_ptr<IborIndex>& iborIndex,
                                    Date customPillarDate) {
        // take fixing into account
        iborIndex_ = iborIndex->clone(termStructureHandle_);
        // We want to be notified of changes of fixings, but we don't
        // want notifications from termStructureHandle_ (they would
        // interfere with bootstrapping.)
        iborIndex_->unregisterWith(termStructureHandle_);

        registerWith(iborIndex_);
        registerWith(spread_);
        registerWith(discountHandle_);

        pillarDate_ = customPillarDate;
        SwapRateHelper::initializeDates();
    }

    void SwapRateHelper::initializeDates() {

        // 1. do not pass the spread here, as it might be a Quote
        //    i.e. it can dynamically change
        // 2. input discount curve Handle might be empty now but it could
        //    be assigned a curve later; use a RelinkableHandle here
        auto tmp = MakeVanillaSwap(tenor_, iborIndex_, 0.0, fwdStart_)
            .withSettlementDays(settlementDays_)  // resets effectiveDate
            .withEffectiveDate(startDate_)
            .withTerminationDate(endDate_)
            .withDiscountingTermStructure(discountRelinkableHandle_)
            .withFixedLegDayCount(fixedDayCount_)
            .withFixedLegTenor(fixedFrequency_ == Once ? tenor_ : Period(fixedFrequency_))
            .withFixedLegConvention(fixedConvention_)
            .withFixedLegTerminationDateConvention(fixedConvention_)
            .withFixedLegCalendar(calendar_)
            .withFixedLegEndOfMonth(endOfMonth_)
            .withFloatingLegCalendar(calendar_)
            .withFloatingLegEndOfMonth(endOfMonth_)
            .withIndexedCoupons(useIndexedCoupons_);
        if (floatConvention_) {
            tmp.withFloatingLegConvention(*floatConvention_)
               .withFloatingLegTerminationDateConvention(*floatConvention_);
        }
        swap_ = tmp;

        simplifyNotificationGraph(*swap_, true);

        earliestDate_ = swap_->startDate();
        maturityDate_ = swap_->maturityDate();

        ext::shared_ptr<IborCoupon> lastCoupon =
            ext::dynamic_pointer_cast<IborCoupon>(swap_->floatingLeg().back());
        latestRelevantDate_ = std::max(maturityDate_, lastCoupon->fixingEndDate());

        switch (pillarChoice_) {
          case Pillar::MaturityDate:
            pillarDate_ = maturityDate_;
            break;
          case Pillar::LastRelevantDate:
            pillarDate_ = latestRelevantDate_;
            break;
          case Pillar::CustomDate:
            // pillarDate_ already assigned at construction time
            QL_REQUIRE(pillarDate_ >= earliestDate_,
                "pillar date (" << pillarDate_ << ") must be later "
                "than or equal to the instrument's earliest date (" <<
                earliestDate_ << ")");
            QL_REQUIRE(pillarDate_ <= latestRelevantDate_,
                "pillar date (" << pillarDate_ << ") must be before "
                "or equal to the instrument's latest relevant date (" <<
                latestRelevantDate_ << ")");
            break;
          default:
            QL_FAIL("unknown Pillar::Choice(" << Integer(pillarChoice_) << ")");
        }

        latestDate_ = pillarDate_; // backward compatibility

    }

    void SwapRateHelper::setTermStructure(YieldTermStructure* t) {
        // do not set the relinkable handle as an observer -
        // force recalculation when needed
        bool observer = false;

        ext::shared_ptr<YieldTermStructure> temp(t, null_deleter());
        termStructureHandle_.linkTo(temp, observer);

        if (discountHandle_.empty())
            discountRelinkableHandle_.linkTo(temp, observer);
        else
            discountRelinkableHandle_.linkTo(*discountHandle_, observer);

        RelativeDateRateHelper::setTermStructure(t);
    }

    Real SwapRateHelper::impliedQuote() const {
        QL_REQUIRE(termStructure_ != nullptr, "term structure not set");
        // we didn't register as observers - force calculation
        swap_->deepUpdate();
        // weak implementation... to be improved
        static const Spread basisPoint = 1.0e-4;
        Real floatingLegNPV = swap_->floatingLegNPV();
        Spread spread = spread_.empty() ? 0.0 : spread_->value();
        Real spreadNPV = swap_->floatingLegBPS()/basisPoint*spread;
        Real totNPV = - (floatingLegNPV+spreadNPV);
        Real result = totNPV/(swap_->fixedLegBPS()/basisPoint);
        return result;
    }

    void SwapRateHelper::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<SwapRateHelper>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            RateHelper::accept(v);
    }

    BMASwapRateHelper::BMASwapRateHelper(const Handle<Quote>& liborFraction,
                                         const Period& tenor,
                                         Natural settlementDays,
                                         Calendar calendar,
                                         // bma leg
                                         const Period& bmaPeriod,
                                         BusinessDayConvention bmaConvention,
                                         DayCounter bmaDayCount,
                                         ext::shared_ptr<BMAIndex> bmaIndex,
                                         // libor leg
                                         ext::shared_ptr<IborIndex> iborIndex)
    : RelativeDateRateHelper(liborFraction), tenor_(tenor), settlementDays_(settlementDays),
      calendar_(std::move(calendar)), bmaPeriod_(bmaPeriod), bmaConvention_(bmaConvention),
      bmaDayCount_(std::move(bmaDayCount)), bmaIndex_(std::move(bmaIndex)),
      iborIndex_(std::move(iborIndex)) {
        registerWith(iborIndex_);
        registerWith(bmaIndex_);
        BMASwapRateHelper::initializeDates();
    }

    void BMASwapRateHelper::initializeDates() {
        // if the evaluation date is not a business day
        // then move to the next business day
        JointCalendar jc(calendar_,
                         iborIndex_->fixingCalendar());
        Date referenceDate = jc.adjust(evaluationDate_);
        earliestDate_ =
            calendar_.advance(referenceDate, settlementDays_ * Days, Following);

        Date maturity = earliestDate_ + tenor_;

        // dummy BMA index with curve/swap arguments
        ext::shared_ptr<BMAIndex> clonedIndex(new BMAIndex(termStructureHandle_));

        Schedule bmaSchedule =
            MakeSchedule().from(earliestDate_).to(maturity)
                          .withTenor(bmaPeriod_)
                          .withCalendar(bmaIndex_->fixingCalendar())
                          .withConvention(bmaConvention_)
                          .backwards();

        Schedule liborSchedule =
            MakeSchedule().from(earliestDate_).to(maturity)
                          .withTenor(iborIndex_->tenor())
                          .withCalendar(iborIndex_->fixingCalendar())
                          .withConvention(iborIndex_->businessDayConvention())
                          .endOfMonth(iborIndex_->endOfMonth())
                          .backwards();

        swap_ = ext::make_shared<BMASwap>(Swap::Payer, 100.0,
                                          liborSchedule,
                                          0.75, // arbitrary
                                          0.0,
                                          iborIndex_,
                                          iborIndex_->dayCounter(),
                                          bmaSchedule,
                                          clonedIndex,
                                          bmaDayCount_);
        swap_->setPricingEngine(ext::shared_ptr<PricingEngine>(new
            DiscountingSwapEngine(iborIndex_->forwardingTermStructure())));

        Date d = calendar_.adjust(swap_->maturityDate(), Following);
        Weekday w = d.weekday();
        Date nextWednesday = (w >= 4) ?
            d + (11 - w) * Days :
            d + (4 - w) * Days;
        latestDate_ = clonedIndex->valueDate(
                         clonedIndex->fixingCalendar().adjust(nextWednesday));
    }

    void BMASwapRateHelper::setTermStructure(YieldTermStructure* t) {
        // do not set the relinkable handle as an observer -
        // force recalculation when needed
        bool observer = false;

        ext::shared_ptr<YieldTermStructure> temp(t, null_deleter());
        termStructureHandle_.linkTo(temp, observer);

        RelativeDateRateHelper::setTermStructure(t);
    }

    Real BMASwapRateHelper::impliedQuote() const {
        QL_REQUIRE(termStructure_ != nullptr, "term structure not set");
        // we didn't register as observers - force calculation
        swap_->deepUpdate();
        return swap_->fairLiborFraction();
    }

    void BMASwapRateHelper::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<BMASwapRateHelper>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            RateHelper::accept(v);
    }

    FxSwapRateHelper::FxSwapRateHelper(const Handle<Quote>& fwdPoint,
                                       Handle<Quote> spotFx,
                                       const Period& tenor,
                                       Natural fixingDays,
                                       Calendar calendar,
                                       BusinessDayConvention convention,
                                       bool endOfMonth,
                                       bool isFxBaseCurrencyCollateralCurrency,
                                       Handle<YieldTermStructure> coll,
                                       Calendar tradingCalendar)
    : RelativeDateRateHelper(fwdPoint), spot_(std::move(spotFx)), tenor_(tenor),
      fixingDays_(fixingDays), cal_(std::move(calendar)), conv_(convention), eom_(endOfMonth),
      isFxBaseCurrencyCollateralCurrency_(isFxBaseCurrencyCollateralCurrency),
      collHandle_(std::move(coll)), tradingCalendar_(std::move(tradingCalendar)) {
        registerWith(spot_);
        registerWith(collHandle_);

        if (tradingCalendar_.empty())
            jointCalendar_ = cal_;
        else
            jointCalendar_ = JointCalendar(tradingCalendar_, cal_,
                                           JoinHolidays);
        FxSwapRateHelper::initializeDates();
    }

    FxSwapRateHelper::FxSwapRateHelper(const Handle<Quote>& fwdPoint,
                                       Handle<Quote> spotFx,
                                       const Date& startDate,
                                       const Date& endDate,
                                       bool isFxBaseCurrencyCollateralCurrency,
                                       Handle<YieldTermStructure> coll)
    : RelativeDateRateHelper(fwdPoint, false), spot_(std::move(spotFx)),
      isFxBaseCurrencyCollateralCurrency_(isFxBaseCurrencyCollateralCurrency),
      collHandle_(std::move(coll)) {
        registerWith(spot_);
        registerWith(collHandle_);
        earliestDate_ = startDate;
        latestDate_ = endDate;
    }

    void FxSwapRateHelper::initializeDates() {
        if (!updateDates_) return;
        // if the evaluation date is not a business day
        // then move to the next business day
        Date refDate = cal_.adjust(evaluationDate_);
        earliestDate_ = cal_.advance(refDate, fixingDays_*Days);

        if (!tradingCalendar_.empty()) {
            // check if fx trade can be settled in US, if not, adjust it
            earliestDate_ = jointCalendar_.adjust(earliestDate_);
            latestDate_ = jointCalendar_.advance(earliestDate_, tenor_,
                                                 conv_, eom_);
        } else {
            latestDate_ = cal_.advance(earliestDate_, tenor_, conv_, eom_);
        }
    }

    Real FxSwapRateHelper::impliedQuote() const {
        QL_REQUIRE(termStructure_ != nullptr, "term structure not set");

        QL_REQUIRE(!collHandle_.empty(), "collateral term structure not set");

        DiscountFactor d1 = collHandle_->discount(earliestDate_);
        DiscountFactor d2 = collHandle_->discount(latestDate_);
        Real collRatio = d1 / d2;
        d1 = termStructureHandle_->discount(earliestDate_);
        d2 = termStructureHandle_->discount(latestDate_);
        Real ratio = d1 / d2;
        Real spot = spot_->value();
        if (isFxBaseCurrencyCollateralCurrency_) {
            return (ratio/collRatio-1)*spot;
        } else {
            return (collRatio/ratio-1)*spot;
        }
    }

    void FxSwapRateHelper::setTermStructure(YieldTermStructure* t) {
        // do not set the relinkable handle as an observer -
        // force recalculation when needed
        bool observer = false;

        ext::shared_ptr<YieldTermStructure> temp(t, null_deleter());
        termStructureHandle_.linkTo(temp, observer);

        collRelinkableHandle_.linkTo(*collHandle_, observer);

        RelativeDateRateHelper::setTermStructure(t);
    }

    void FxSwapRateHelper::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<FxSwapRateHelper>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            RateHelper::accept(v);
    }

}
]]></document_content>
  </document>
  <document index="71">
    <source>yield/zeroyieldstructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004 StatPro Italia srl
 Copyright (C) 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/yield/zeroyieldstructure.hpp>

namespace QuantLib {

    ZeroYieldStructure::ZeroYieldStructure(const DayCounter& dc)
    : YieldTermStructure(dc) {}

    ZeroYieldStructure::ZeroYieldStructure(
                                    const Date& refDate,
                                    const Calendar& cal,
                                    const DayCounter& dc,
                                    const std::vector<Handle<Quote> >& jumps,
                                    const std::vector<Date>& jumpDates)
    : YieldTermStructure(refDate, cal, dc, jumps, jumpDates) {}

    ZeroYieldStructure::ZeroYieldStructure(
                                    Natural settlementDays,
                                    const Calendar& cal,
                                    const DayCounter& dc,
                                    const std::vector<Handle<Quote> >& jumps,
                                    const std::vector<Date>& jumpDates)
    : YieldTermStructure(settlementDays, cal, dc, jumps, jumpDates) {}

}
]]></document_content>
  </document>
  <document index="72">
    <source>yieldtermstructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2009 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <utility>

namespace QuantLib {

    namespace {
        // time interval used in finite differences
        const Time dt = 0.0001;
    }

    YieldTermStructure::YieldTermStructure(const DayCounter& dc) : TermStructure(dc) {}

    YieldTermStructure::YieldTermStructure(const Date& referenceDate,
                                           const Calendar& cal,
                                           const DayCounter& dc,
                                           std::vector<Handle<Quote> > jumps,
                                           const std::vector<Date>& jumpDates)
    : TermStructure(referenceDate, cal, dc), jumps_(std::move(jumps)), jumpDates_(jumpDates),
      jumpTimes_(jumpDates.size()), nJumps_(jumps_.size()) {
        setJumps(YieldTermStructure::referenceDate());
        for (Size i=0; i<nJumps_; ++i)
            registerWith(jumps_[i]);
    }

    YieldTermStructure::YieldTermStructure(Natural settlementDays,
                                           const Calendar& cal,
                                           const DayCounter& dc,
                                           std::vector<Handle<Quote> > jumps,
                                           const std::vector<Date>& jumpDates)
    : TermStructure(settlementDays, cal, dc), jumps_(std::move(jumps)), jumpDates_(jumpDates),
      jumpTimes_(jumpDates.size()), nJumps_(jumps_.size()) {
        setJumps(YieldTermStructure::referenceDate());
        for (Size i=0; i<nJumps_; ++i)
            registerWith(jumps_[i]);
    }

    void YieldTermStructure::setJumps(const Date& referenceDate) {
        if (jumpDates_.empty() && !jumps_.empty()) { // turn of year dates
            jumpDates_.resize(nJumps_);
            jumpTimes_.resize(nJumps_);
            Year y = referenceDate.year();
            for (Size i=0; i<nJumps_; ++i)
                jumpDates_[i] = Date(31, December, y+i);
        } else { // fixed dates
            QL_REQUIRE(jumpDates_.size()==nJumps_,
                       "mismatch between number of jumps (" << nJumps_ <<
                       ") and jump dates (" << jumpDates_.size() << ")");
        }
        for (Size i=0; i<nJumps_; ++i)
            jumpTimes_[i] = timeFromReference(jumpDates_[i]);
        latestReference_ = referenceDate;
    }

    DiscountFactor YieldTermStructure::discount(Time t,
                                                bool extrapolate) const {
        checkRange(t, extrapolate);

        if (jumps_.empty())
            return discountImpl(t);

        DiscountFactor jumpEffect = 1.0;
        for (Size i=0; i<nJumps_; ++i) {
            if (jumpTimes_[i]>0 && jumpTimes_[i]<t) {
                QL_REQUIRE(jumps_[i]->isValid(),
                           "invalid " << io::ordinal(i+1) << " jump quote");
                DiscountFactor thisJump = jumps_[i]->value();
                QL_REQUIRE(thisJump > 0.0,
                           "invalid " << io::ordinal(i+1) << " jump value: " <<
                           thisJump);
                jumpEffect *= thisJump;
            }
        }
        return jumpEffect * discountImpl(t);
    }

    InterestRate YieldTermStructure::zeroRate(const Date& d,
                                              const DayCounter& dayCounter,
                                              Compounding comp,
                                              Frequency freq,
                                              bool extrapolate) const {
        Time t = timeFromReference(d);
        if (t == 0) {
            Real compound = 1.0/discount(dt, extrapolate);
            // t has been calculated with a possibly different daycounter
            // but the difference should not matter for very small times
            return InterestRate::impliedRate(compound,
                                             dayCounter, comp, freq,
                                             dt);
        }
        Real compound = 1.0/discount(t, extrapolate);
        return InterestRate::impliedRate(compound,
                                         dayCounter, comp, freq,
                                         referenceDate(), d);
    }

    InterestRate YieldTermStructure::zeroRate(Time t,
                                              Compounding comp,
                                              Frequency freq,
                                              bool extrapolate) const {
        if (t==0.0) t = dt;
        Real compound = 1.0/discount(t, extrapolate);
        return InterestRate::impliedRate(compound,
                                         dayCounter(), comp, freq,
                                         t);
    }

    InterestRate YieldTermStructure::forwardRate(const Date& d1,
                                                 const Date& d2,
                                                 const DayCounter& dayCounter,
                                                 Compounding comp,
                                                 Frequency freq,
                                                 bool extrapolate) const {
        if (d1==d2) {
            checkRange(d1, extrapolate);
            Time t1 = std::max(timeFromReference(d1) - dt/2.0, 0.0);
            Time t2 = t1 + dt;
            Real compound =
                discount(t1, true)/discount(t2, true);
            // times have been calculated with a possibly different daycounter
            // but the difference should not matter for very small times
            return InterestRate::impliedRate(compound,
                                             dayCounter, comp, freq,
                                             dt);
        }
        QL_REQUIRE(d1 < d2,  d1 << " later than " << d2);
        Real compound = discount(d1, extrapolate)/discount(d2, extrapolate);
        return InterestRate::impliedRate(compound,
                                         dayCounter, comp, freq,
                                         d1, d2);
    }

    InterestRate YieldTermStructure::forwardRate(Time t1,
                                                 Time t2,
                                                 Compounding comp,
                                                 Frequency freq,
                                                 bool extrapolate) const {
        Real compound;
        if (t2==t1) {
            checkRange(t1, extrapolate);
            t1 = std::max(t1 - dt/2.0, 0.0);
            t2 = t1 + dt;
            compound = discount(t1, true)/discount(t2, true);
        } else {
            QL_REQUIRE(t2>t1, "t2 (" << t2 << ") < t1 (" << t2 << ")");
            compound = discount(t1, extrapolate)/discount(t2, extrapolate);
        }
        return InterestRate::impliedRate(compound,
                                         dayCounter(), comp, freq,
                                         t2-t1);
    }

    void YieldTermStructure::update() {
        TermStructure::update();
        Date newReference = Date();
        try {
            newReference = referenceDate();
            if (newReference != latestReference_)
                setJumps(newReference);
        } catch (Error&) {
            if (newReference == Date()) {
                // the curve couldn't calculate the reference
                // date. Most of the times, this is because some
                // underlying handle wasn't set, so we can just absorb
                // the exception and continue; the jumps will be set
                // correctly when a valid underlying is set.
                return;
            } else {
                // something else happened during the call to
                // setJumps(), so we let the exception bubble up.
                throw;
            }
        }
    }

}
]]></document_content>
  </document>
</documents>