<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>americanpayoffatexpiry.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/americanpayoffatexpiry.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {

    AmericanPayoffAtExpiry::AmericanPayoffAtExpiry(
         Real spot, DiscountFactor discount, DiscountFactor dividendDiscount,
         Real variance, const ext::shared_ptr<StrikedTypePayoff>& payoff,
         bool knock_in)
    : spot_(spot), discount_(discount), dividendDiscount_(dividendDiscount),
      variance_(variance), knock_in_(knock_in) {

        QL_REQUIRE(spot_>0.0,
                   "positive spot value required");

        QL_REQUIRE(discount_>0.0,
                   "positive discount required");

        QL_REQUIRE(dividendDiscount_>0.0,
                   "positive dividend discount required");

        QL_REQUIRE(variance_>=0.0,
                   "negative variance not allowed");

        stdDev_ = std::sqrt(variance_);

        Option::Type type   = payoff->optionType();
        strike_ = payoff->strike();
        forward_ = spot_ * dividendDiscount_ / discount_;

        mu_ = std::log(dividendDiscount_/discount_)/variance_ - 0.5;

        // binary cash-or-nothing payoff?
        ext::shared_ptr<CashOrNothingPayoff> coo =
            ext::dynamic_pointer_cast<CashOrNothingPayoff>(payoff);
        if (coo != nullptr) {
            K_ = coo->cashPayoff();
        }

        // binary asset-or-nothing payoff?
        ext::shared_ptr<AssetOrNothingPayoff> aoo =
            ext::dynamic_pointer_cast<AssetOrNothingPayoff>(payoff);
        if (aoo != nullptr) {
            K_ = forward_;
            mu_ += 1.0;
        }


        log_H_S_ = std::log(strike_/spot_);
        Real log_S_H_ = std::log(spot_/strike_);

        double eta;
        double phi;
        switch (type) {
            case Option::Call:
                if (knock_in_) {
                   // up-and-in cash-(at-expiry)-or-nothing option
                   // a.k.a. american call with cash-or-nothing payoff
                   eta = -1.0;
                   phi =  1.0;
                } else {
                   // up-and-out cash-(at-expiry)-or-nothing option
				   eta = -1.0;
				   phi = -1.0;
                }
                break;
            case Option::Put:
               if (knock_in_) {
                   // down-and-in cash-(at-expiry)-or-nothing option
                   // a.k.a. american put with cash-or-nothing payoff
                   eta =  1.0;
                   phi = -1.0;
                } else {
                   // down-and-out cash-(at-expiry)-or-nothing option
				   eta =  1.0;
				   phi =  1.0;
                }
                break;
            default:
                QL_FAIL("invalid option type");
         }


        if (variance_>=QL_EPSILON) {
            D1_ = phi*(log_S_H_/stdDev_ + mu_*stdDev_);
            D2_ = eta*(log_H_S_/stdDev_ + mu_*stdDev_);

            CumulativeNormalDistribution f;
            cum_d1_ = f(D1_);
            cum_d2_ = f(D2_);
            n_d1_ = f.derivative(D1_);
            n_d2_ = f.derivative(D2_);
        } else {
            if (log_S_H_ * phi >0)
                cum_d1_= 1.0;
            else
                cum_d1_= 0.0;
            if (log_H_S_ * eta >0)
                cum_d2_= 1.0;
            else
                cum_d2_= 0.0;
            n_d1_ = 0.0;
            n_d2_ = 0.0;
        }


        switch (type) {
            case Option::Call:
                if (strike_<=spot_) {
                    if (knock_in_) {
                        // up-and-in cash-(at-expiry)-or-nothing option
                        // a.k.a. american call with cash-or-nothing payoff
                        cum_d1_     = 0.5;
                        cum_d2_     = 0.5;
                    } else {
                        // up-and-out cash-(at-expiry)-or-nothing option
                        // already knocked out
                        cum_d1_     = 0.0;
                        cum_d2_     = 0.0;
                    }
                    n_d1_       = 0.0;
                    n_d2_       = 0.0;
                }
                break;
            case Option::Put:
				if (strike_>=spot_) {
                    if (knock_in_) {
					    // down-and-in cash-(at-expiry)-or-nothing option
					    // a.k.a. american put with cash-or-nothing payoff
                        cum_d1_     = 0.5;
                        cum_d2_     = 0.5;
                    } else {
					    // down-and-out cash-(at-expiry)-or-nothing option
                        // already knocked out
                        cum_d1_     = 0.0;
                        cum_d2_     = 0.0;
                    }
                    n_d1_       = 0.0;
                    n_d2_       = 0.0;
                }
                break;
            default:
                QL_FAIL("invalid option type");
         }


        inTheMoney_ = (type==Option::Call && strike_<spot_) ||
                      (type==Option::Put  && strike_>spot_);
        if (inTheMoney_) {
            X_ = 1.0;
            Y_ = 1.0;
        } else {
            X_ = 1.0;
            if (cum_d2_ == 0.0)
                Y_ = 0.0; // check needed on some extreme cases
            else
                Y_ = std::pow(Real(strike_/spot_), Real(2.0*mu_));
        }
        if (!knock_in_)
           Y_ *= -1.0; 
    }

}

]]></document_content>
  </document>
  <document index="2">
    <source>americanpayoffathit.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/americanpayoffathit.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {

    AmericanPayoffAtHit::AmericanPayoffAtHit(
         Real spot, DiscountFactor discount, DiscountFactor dividendDiscount,
         Real variance, const ext::shared_ptr<StrikedTypePayoff>& payoff)
    : spot_(spot), discount_(discount), dividendDiscount_(dividendDiscount),
      variance_(variance) {

        QL_REQUIRE(spot_>0.0,
                   "positive spot value required");

        QL_REQUIRE(discount_>0.0,
                   "positive discount required");

        QL_REQUIRE(dividendDiscount_>0.0,
                   "positive dividend discount required");

        QL_REQUIRE(variance_>=0.0,
                   "negative variance not allowed");

        stdDev_ = std::sqrt(variance_);

        Option::Type type   = payoff->optionType();
        strike_ = payoff->strike();


        log_H_S_ = std::log(strike_/spot_);

        Real n_d1, n_d2;
        if (variance_>=QL_EPSILON) {
            if (discount_==0.0 && dividendDiscount_==0.0) {
                mu_     = - 0.5;
                lambda_ = 0.5;
            } else if (discount_==0.0) {
                QL_FAIL("null discount not handled yet");
            } else {
                mu_ = std::log(dividendDiscount_/discount_)/variance_ - 0.5;
                lambda_ = std::sqrt(mu_*mu_-2.0*std::log(discount_)/variance_);
            }
            D1_ = log_H_S_/stdDev_ + lambda_*stdDev_;
            D2_ = D1_ - 2.0*lambda_*stdDev_;
            CumulativeNormalDistribution f;
            cum_d1_ = f(D1_);
            cum_d2_ = f(D2_);
            n_d1 = f.derivative(D1_);
            n_d2 = f.derivative(D2_);
        } else {
            // not tested yet
            mu_ = std::log(dividendDiscount_/discount_)/variance_ - 0.5;
            lambda_ = std::sqrt(mu_*mu_-2.0*std::log(discount_)/variance_);
            if (log_H_S_>0) {
                cum_d1_= 1.0;
                cum_d2_= 1.0;
            } else {
                cum_d1_= 0.0;
                cum_d2_= 0.0;
            }
            n_d1 = 0.0;
            n_d2 = 0.0;
        }


        switch (type) {
            // up-and-in cash-(at-hit)-or-nothing option
            // a.k.a. american call with cash-or-nothing payoff
            case Option::Call:
                if (strike_>spot_) {
                    alpha_     = 1.0-cum_d1_;//  N(-d1)
                    DalphaDd1_ =    -  n_d1;// -n( d1)
                    beta_      = 1.0-cum_d2_;//  N(-d2)
                    DbetaDd2_  =    -  n_d2;// -n( d2)
                } else {
                    alpha_     = 0.5;
                    DalphaDd1_ = 0.0;
                    beta_      = 0.5;
                    DbetaDd2_  = 0.0;
                }
                break;
            // down-and-in cash-(at-hit)-or-nothing option
            // a.k.a. american put with cash-or-nothing payoff
            case Option::Put:
                if (strike_<spot_) {
                    alpha_     =     cum_d1_;//  N(d1)
                    DalphaDd1_ =       n_d1;//  n(d1)
                    beta_      =     cum_d2_;//  N(d2)
                    DbetaDd2_  =       n_d2;//  n(d2)
                } else {
                    alpha_     = 0.5;
                    DalphaDd1_ = 0.0;
                    beta_      = 0.5;
                    DbetaDd2_  = 0.0;
                }
                break;
            default:
                QL_FAIL("invalid option type");
         }


        muPlusLambda_  = mu_ + lambda_;
        muMinusLambda_ = mu_ - lambda_;
        inTheMoney_ = (type==Option::Call && strike_<spot_) ||
                      (type==Option::Put  && strike_>spot_);

        if (inTheMoney_) {
            forward_   = 1.0;
            X_         = 1.0;
            DXDstrike_ = 0.0;
        } else {
            forward_   = std::pow(strike_/spot_, muPlusLambda_);
            X_         = std::pow(strike_/spot_, muMinusLambda_);
//            DXDstrike_ = ......;
        }


        // Binary Cash-Or-Nothing payoff?
        ext::shared_ptr<CashOrNothingPayoff> coo =
            ext::dynamic_pointer_cast<CashOrNothingPayoff>(payoff);
        if (coo != nullptr) {
            K_ = coo->cashPayoff();
            DKDstrike_ = 0.0;
        }

        // Binary Asset-Or-Nothing payoff?
        ext::shared_ptr<AssetOrNothingPayoff> aoo =
            ext::dynamic_pointer_cast<AssetOrNothingPayoff>(payoff);
        if (aoo != nullptr) {
            if (inTheMoney_) {
                K_ = spot_;
                DKDstrike_ = 0.0;
            } else {
                K_ = aoo->strike();
                DKDstrike_ = 1.0;
            }
        }
    }


    Real AmericanPayoffAtHit::delta() const {
        Real tempDelta = - spot_ * stdDev_;
        Real DalphaDs = DalphaDd1_/tempDelta;
        Real DbetaDs  = DbetaDd2_/tempDelta;

        Real DforwardDs, DXDs;
        if (inTheMoney_) {
            DforwardDs = 0.0;
            DXDs       = 0.0;
        } else {
            DforwardDs = -muPlusLambda_  * forward_ / spot_;
            DXDs       = -muMinusLambda_ * X_       / spot_;
        }

        return K_ * (
              DalphaDs * forward_ + alpha_ * DforwardDs
            + DbetaDs  * X_       + beta_  * DXDs
            );
    }


    Real AmericanPayoffAtHit::gamma() const {
        Real tempDelta = - spot_ * stdDev_;
        Real DalphaDs = DalphaDd1_/tempDelta;
        Real DbetaDs  = DbetaDd2_/tempDelta;
        Real D2alphaDs2 = -DalphaDs/spot_*(1-D1_/stdDev_);
        Real D2betaDs2  = -DbetaDs /spot_*(1-D2_/stdDev_);

        Real DforwardDs, DXDs, D2forwardDs2, D2XDs2;
        if (inTheMoney_) {
            DforwardDs = 0.0;
            DXDs       = 0.0;
            D2forwardDs2 = 0.0;
            D2XDs2       = 0.0;
        } else {
            DforwardDs = -muPlusLambda_  * forward_ / spot_;
            DXDs       = -muMinusLambda_ * X_       / spot_;
            D2forwardDs2 = muPlusLambda_  * forward_ / (spot_*spot_)*(1+muPlusLambda_);
            D2XDs2       = muMinusLambda_ * X_       / (spot_*spot_)*(1+muMinusLambda_);
        }

        return K_ * (
              D2alphaDs2 * forward_   + DalphaDs * DforwardDs
            + DalphaDs   * DforwardDs + alpha_   * D2forwardDs2
            + D2betaDs2  * X_         + DbetaDs  * DXDs
            + DbetaDs    * DXDs       + beta_    * D2XDs2
            );

    }


    Real AmericanPayoffAtHit::rho(Time maturity) const {
        QL_REQUIRE(maturity>=0.0,
                   "negative maturity not allowed");

        // actually D.Dr / T
        Real DalphaDr = -DalphaDd1_/(lambda_*stdDev_) * (1.0 + mu_);
        Real DbetaDr  =  DbetaDd2_ /(lambda_*stdDev_) * (1.0 + mu_);
        Real DforwardDr, DXDr;
        if (inTheMoney_) {
            DforwardDr = 0.0;
            DXDr       = 0.0;
        } else {
            DforwardDr = forward_ * (1.0+(1.0+mu_)/lambda_) * log_H_S_ / variance_;
            DXDr       = X_       * (1.0-(1.0+mu_)/lambda_) * log_H_S_ / variance_;
        }

        return maturity * K_ * (
              DalphaDr * forward_
            + alpha_   * DforwardDr
            + DbetaDr  * X_
            + beta_    * DXDr
            );
    }

}

]]></document_content>
  </document>
  <document index="3">
    <source>asian/analytic_cont_geom_av_price.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/asian/analytic_cont_geom_av_price.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    AnalyticContinuousGeometricAveragePriceAsianEngine::
        AnalyticContinuousGeometricAveragePriceAsianEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticContinuousGeometricAveragePriceAsianEngine::calculate()
                                                                       const {
        QL_REQUIRE(arguments_.averageType == Average::Geometric,
                   "not a geometric average option");
        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European Option");

        // Check if this is a seasoned option
        if (arguments_.startDate != Date()) {
            QL_FAIL("seasoned continuous geometric Asian options not yet supported - "
                    "requires adjustment of forward price and variance based on "
                    "accumulated geometric average. This feature needs mathematical "
                    "review and implementation.");
        }

        Date exercise = arguments_.exercise->lastDate();

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        Volatility volatility =
            process_->blackVolatility()->blackVol(exercise, payoff->strike());
        Real variance =
            process_->blackVolatility()->blackVariance(exercise,
                                                       payoff->strike());
        DiscountFactor riskFreeDiscount =
            process_->riskFreeRate()->discount(exercise);

        DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
        DayCounter divdc = process_->dividendYield()->dayCounter();
        DayCounter voldc = process_->blackVolatility()->dayCounter();

        Spread dividendYield = 0.5 * (
            process_->riskFreeRate()->zeroRate(exercise, rfdc,
                                               Continuous, NoFrequency).rate() +
            process_->dividendYield()->zeroRate(exercise, divdc,
                                                Continuous, NoFrequency).rate() +
            volatility*volatility/6.0);

        Time t_q = divdc.yearFraction(
            process_->dividendYield()->referenceDate(), exercise);
        DiscountFactor dividendDiscount = std::exp(-dividendYield*t_q);

        Real spot = process_->stateVariable()->value();
        QL_REQUIRE(spot > 0.0, "negative or null underlying");
        Real forward = spot * dividendDiscount / riskFreeDiscount;

        BlackCalculator black(payoff, forward, std::sqrt(variance/3.0),
                              riskFreeDiscount);

        results_.value = black.value();
        results_.delta = black.delta(spot);
        results_.gamma = black.gamma(spot);

        results_.dividendRho = black.dividendRho(t_q)/2.0;

        Time t_r = rfdc.yearFraction(process_->riskFreeRate()->referenceDate(),
                                     arguments_.exercise->lastDate());
        results_.rho = black.rho(t_r) + 0.5 * black.dividendRho(t_q);

        Time t_v = voldc.yearFraction(
            process_->blackVolatility()->referenceDate(),
            arguments_.exercise->lastDate());
        results_.vega = black.vega(t_v)/std::sqrt(3.0) +
                        black.dividendRho(t_q)*volatility/6.0;
        try {
            results_.theta = black.theta(spot, t_v);
        } catch (Error&) {
            results_.theta = Null<Real>();
        }
    }

}

]]></document_content>
  </document>
  <document index="4">
    <source>asian/analytic_discr_geom_av_price.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2005 Gary Kennedy
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/pricingengines/asian/analytic_discr_geom_av_price.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/pricingengines/greeks.hpp>
#include <numeric>
#include <utility>

namespace QuantLib {

    AnalyticDiscreteGeometricAveragePriceAsianEngine::
        AnalyticDiscreteGeometricAveragePriceAsianEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticDiscreteGeometricAveragePriceAsianEngine::calculate() const {

        /* this engine cannot really check for the averageType==Geometric
           since it can be used as control variate for the Arithmetic version
        QL_REQUIRE(arguments_.averageType == Average::Geometric,
                   "not a geometric average option");
        */

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European Option");

        Real runningLog;
        Size pastFixings;
        if (arguments_.averageType == Average::Geometric) {
            QL_REQUIRE(arguments_.runningAccumulator>0.0,
                       "positive running product required: "
                       << arguments_.runningAccumulator << " not allowed");
            runningLog =
                std::log(arguments_.runningAccumulator);
            pastFixings = arguments_.pastFixings;
        } else {  // it is being used as control variate
            runningLog = 1.0;
            pastFixings = 0;
        }

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        Date referenceDate = process_->riskFreeRate()->referenceDate();
        DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
        DayCounter divdc = process_->dividendYield()->dayCounter();
        DayCounter voldc = process_->blackVolatility()->dayCounter();
        std::vector<Time> fixingTimes;
        Size i;
        for (i=0; i<arguments_.fixingDates.size(); i++) {
            if (arguments_.fixingDates[i]>=referenceDate) {
                Time t = voldc.yearFraction(referenceDate,
                    arguments_.fixingDates[i]);
                fixingTimes.push_back(t);
            }
        }

        Size remainingFixings = fixingTimes.size();
        Size numberOfFixings = pastFixings + remainingFixings;
        Real N = static_cast<Real>(numberOfFixings);

        Real pastWeight   = pastFixings/N;
        Real futureWeight = 1.0-pastWeight;

        Time timeSum = std::accumulate(fixingTimes.begin(),
                                       fixingTimes.end(), Real(0.0));

        Volatility vola = process_->blackVolatility()->blackVol(
                                              arguments_.exercise->lastDate(),
                                              payoff->strike());
        Real temp = 0.0;
        for (i=pastFixings+1; i<numberOfFixings; i++)
            temp += fixingTimes[i-pastFixings-1]*(N-i);
        Real variance = vola*vola /N/N * (timeSum+ 2.0*temp);
        Real dsigG_dsig = std::sqrt((timeSum + 2.0*temp))/N;
        Real sigG = vola * dsigG_dsig;
        Real dmuG_dsig = -(vola * timeSum)/N;

        Date exDate = arguments_.exercise->lastDate();
        Rate dividendRate = process_->dividendYield()->
            zeroRate(exDate, divdc, Continuous, NoFrequency);
        Rate riskFreeRate = process_->riskFreeRate()->
            zeroRate(exDate, rfdc, Continuous, NoFrequency);
        Rate nu = riskFreeRate - dividendRate - 0.5*vola*vola;

        Real s = process_->stateVariable()->value();
        QL_REQUIRE(s > 0.0, "positive underlying value required");

        Size M = (pastFixings == 0 ? 1 : pastFixings);
        Real muG = pastWeight * runningLog/M +
            futureWeight * std::log(s) + nu*timeSum/N;
        Real forwardPrice = std::exp(muG + variance / 2.0);

        DiscountFactor riskFreeDiscount = process_->riskFreeRate()->discount(
                                             arguments_.exercise->lastDate());

        BlackCalculator black(payoff, forwardPrice, std::sqrt(variance),
                              riskFreeDiscount);

        results_.value = black.value();
        results_.delta = futureWeight*black.delta(forwardPrice)*forwardPrice/s;
        results_.gamma = forwardPrice*futureWeight/(s*s)
                *(  black.gamma(forwardPrice)*futureWeight*forwardPrice
                  - pastWeight*black.delta(forwardPrice) );

        Real Nx_1, nx_1;
        CumulativeNormalDistribution CND;
        NormalDistribution ND;
        if (sigG > QL_EPSILON) {
            Real x_1  = (muG-std::log(payoff->strike())+variance)/sigG;
            Nx_1 = CND(x_1);
            nx_1 = ND(x_1);
        } else {
            Nx_1 = (muG > std::log(payoff->strike()) ? 1.0 : 0.0);
            nx_1 = 0.0;
        }
        results_.vega = forwardPrice * riskFreeDiscount *
                   ( (dmuG_dsig + sigG * dsigG_dsig)*Nx_1 + nx_1*dsigG_dsig );

        if (payoff->optionType() == Option::Put)
            results_.vega -= riskFreeDiscount * forwardPrice *
                                              (dmuG_dsig + sigG * dsigG_dsig);

        Time tRho = rfdc.yearFraction(process_->riskFreeRate()->referenceDate(),
                                      arguments_.exercise->lastDate());
        results_.rho = black.rho(tRho)*timeSum/(N*tRho)
                      - (tRho-timeSum/N)*results_.value;

        Time tDiv = divdc.yearFraction(
                           process_->dividendYield()->referenceDate(),
                           arguments_.exercise->lastDate());

        results_.dividendRho = black.dividendRho(tDiv)*timeSum/(N*tDiv);

        results_.strikeSensitivity = black.strikeSensitivity();

        results_.theta = blackScholesTheta(process_,
                                           results_.value,
                                           results_.delta,
                                           results_.gamma);
    }
}

]]></document_content>
  </document>
  <document index="5">
    <source>asian/analytic_discr_geom_av_strike.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/pricingengines/asian/analytic_discr_geom_av_strike.hpp>
#include <utility>

namespace QuantLib {

    AnalyticDiscreteGeometricAverageStrikeAsianEngine::
        AnalyticDiscreteGeometricAverageStrikeAsianEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticDiscreteGeometricAverageStrikeAsianEngine::calculate() const {

        QL_REQUIRE(arguments_.averageType == Average::Geometric,
                   "not a geometric average option");

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European option");

        QL_REQUIRE(arguments_.runningAccumulator > 0.0,
                   "positive running product required: "
                   << arguments_.runningAccumulator << "not allowed");
        Real runningLog = std::log(arguments_.runningAccumulator);
        Size pastFixings = arguments_.pastFixings;
        QL_REQUIRE(pastFixings == 0, "past fixings currently not managed");

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
        DayCounter divdc = process_->dividendYield()->dayCounter();
        DayCounter voldc = process_->blackVolatility()->dayCounter();

        std::vector<Time> fixingTimes;
        for (auto& fixingDate : arguments_.fixingDates) {
            if (fixingDate >= arguments_.fixingDates[0]) {
                Time t = voldc.yearFraction(arguments_.fixingDates[0], fixingDate);
                fixingTimes.push_back(t);
            }
        }

        Size remainingFixings = fixingTimes.size();
        Size numberOfFixings = pastFixings + remainingFixings;
        Real N = static_cast<Real>(numberOfFixings);

        Real pastWeight   = pastFixings/N;
        Real futureWeight = 1.0-pastWeight;

        Time timeSum = std::accumulate(fixingTimes.begin(),
                                       fixingTimes.end(), Real(0.0));

        Time residualTime = rfdc.yearFraction(arguments_.fixingDates[pastFixings],
                                              arguments_.exercise->lastDate());


        Real underlying = process_->stateVariable()->value();
        QL_REQUIRE(underlying > 0.0, "positive underlying value required");

        Volatility volatility = process_->blackVolatility()->blackVol(
                                                arguments_.exercise->lastDate(),
                                                underlying);

        Date exDate = arguments_.exercise->lastDate();
        Rate dividendRate = process_->dividendYield()->
            zeroRate(exDate, divdc, Continuous, NoFrequency);

        Rate riskFreeRate = process_->riskFreeRate()->
            zeroRate(exDate, rfdc, Continuous, NoFrequency);

        Rate nu = riskFreeRate - dividendRate - 0.5*volatility*volatility;

        Real temp = 0.0;
        for (Size i=pastFixings+1; i<numberOfFixings; i++)
            temp += fixingTimes[i-pastFixings-1]*(N-i);
        Real variance = volatility*volatility /N/N * (timeSum + 2.0*temp);
        Real covarianceTerm = volatility*volatility/N * timeSum;
        Real sigmaSum_2 = variance + volatility*volatility*residualTime -
                                     2.0*covarianceTerm;

        Size M = (pastFixings == 0 ? 1 : pastFixings);
        Real runningLogAverage = runningLog/M;

        Real muG = pastWeight * runningLogAverage +
                   futureWeight * std::log(underlying) +
                   nu*timeSum/N;

        CumulativeNormalDistribution f;

        Real y1 = (std::log(underlying)+
                     (riskFreeRate-dividendRate)*residualTime-
                      muG - variance/2.0 + sigmaSum_2/2.0)
                      /std::sqrt(sigmaSum_2);
        Real y2 = y1-std::sqrt(sigmaSum_2);

        switch (payoff->optionType()) {
          case Option::Call:
            results_.value = underlying*std::exp(-dividendRate*residualTime)
                *f(y1)-
                std::exp(muG + variance/2.0 - riskFreeRate*residualTime)
                *f(y2);
            break;
          case Option::Put:
            results_.value = -underlying*std::exp(-dividendRate*residualTime)
                *f(-y1)+
                std::exp(muG + variance/2.0 - riskFreeRate*residualTime)
                *f(-y2);
            break;
          default:
            QL_FAIL("invalid option type");
        }
    }

}

]]></document_content>
  </document>
  <document index="6">
    <source>asian/choiasianengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2025 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/instruments/basketoption.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/pricingengines/asian/choiasianengine.hpp>
#include <ql/pricingengines/basket/choibasketengine.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>

namespace QuantLib {

    ChoiAsianEngine::ChoiAsianEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Real lambda,
        Size maxNrIntegrationSteps)
    : process_(std::move(process)),
      lambda_(lambda),
      maxNrIntegrationSteps_(maxNrIntegrationSteps) {
        registerWith(process_);
    }

    void ChoiAsianEngine::calculate() const {
        QL_REQUIRE(arguments_.averageType == Average::Type::Arithmetic,
            "must be Average::Type Arithmetic ");

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
            "not a European Option");

        const ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non plain vanilla payoff given");

        std::vector<Date> fixingDates = arguments_.fixingDates;
        std::sort(fixingDates.begin(), fixingDates.end());

        Size futureFixings = fixingDates.size();
        Size pastFixings = arguments_.pastFixings;
        Real runningAccumulator = arguments_.runningAccumulator;

        const Date exerciseDate = arguments_.exercise->lastDate();
        const Handle<YieldTermStructure> rTS = process_->riskFreeRate();

        if (   futureFixings > 0
            && process_->time(fixingDates.front()) == Time(0)) {
            // push today fixing to past fixings
            fixingDates.erase(fixingDates.begin());
            futureFixings--;
            pastFixings++;
            runningAccumulator += process_->x0();
        }

        if (futureFixings == 0) {
            QL_REQUIRE(pastFixings > 0, "no past fixings given");
            results_.value = (*payoff)(runningAccumulator/pastFixings)
                * rTS->discount(exerciseDate);

            return;
        }

        QL_REQUIRE(fixingDates.back() <= exerciseDate,
            "last fixing date must be before exercise date");
        QL_REQUIRE(process_->time(fixingDates.front()) >= 0.0,
            "first fixing date is in the past");

        QL_REQUIRE(std::adjacent_find(fixingDates.begin(), fixingDates.end())
            == fixingDates.end(), "two fixing dates are the same");

        const Real accruedAverage = (pastFixings != 0)
            ? Real(runningAccumulator / (pastFixings + futureFixings))
            : 0.0;

        const Real strike = payoff->strike() - accruedAverage;
        QL_REQUIRE(strike >= 0.0, "effective strike should to be positive");

        const Handle<YieldTermStructure> qTS = process_->dividendYield();
        const Handle<BlackVolTermStructure> volTS = process_->blackVolatility();
        const Date volRefDate = volTS->referenceDate();
        const DayCounter volDc = volTS->dayCounter();

        if (futureFixings > 1) {
            std::vector<Time> fixingTimes(futureFixings), variances(futureFixings);
            for (Size i=0; i < futureFixings; ++i) {
                const Date& fixingDate = fixingDates[i];
                fixingTimes[i] = volDc.yearFraction(volRefDate,  fixingDate);
                variances[i] = process_->blackVolatility()->blackVariance(fixingDate, strike);
            }

            Matrix rho(futureFixings, futureFixings);
            for (Size i=0; i < rho.rows(); ++i)
                for (Size j=i; j < rho.columns(); ++j)
                    rho[i][j] = rho[j][i] =
                        variances[std::min(i,j)] / std::sqrt(variances[i]*variances[j]);

            const Handle<YieldTermStructure> zeroTS(
                ext::make_shared<FlatForward>(rTS->referenceDate(), 0.0, rTS->dayCounter())
            );

            std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > processes;
            processes.reserve(futureFixings);
            for (Size i=0; i < futureFixings; ++i) {
                const Date& fixingDate = fixingDates[i];
                const Volatility sig = volTS->blackVol(fixingDate, payoff->strike())
                    * std::sqrt(fixingTimes[i]/fixingTimes.back());

                processes.emplace_back(
                    ext::make_shared<GeneralizedBlackScholesProcess>(
                        Handle<Quote>(
                            ext::make_shared<SimpleQuote>(
                                process_->x0()*qTS->discount(fixingDate)/rTS->discount(fixingDate)
                            )
                        ),
                        zeroTS, zeroTS,
                        Handle<BlackVolTermStructure>(
                           ext::make_shared<BlackConstantVol>(
                              volRefDate, volTS->calendar(),
                              Handle<Quote>(ext::make_shared<SimpleQuote>(sig)),
                              volDc
                           )
                        )
                    )
                );
            }

            BasketOption basketOption(
                ext::make_shared<AverageBasketPayoff>(
                    ext::make_shared<PlainVanillaPayoff>(payoff->optionType(), strike),
                    Array(futureFixings, 1.0/(futureFixings + pastFixings))
                ),
                ext::make_shared<EuropeanExercise>(fixingDates.back())
            );
            basketOption.setPricingEngine(
                ext::make_shared<ChoiBasketEngine>(
                    processes, rho, lambda_, maxNrIntegrationSteps_)
            );

            results_.value = basketOption.NPV() * rTS->discount(exerciseDate);
        }
        else if (futureFixings == 1) {
            results_.value = blackFormula(
                payoff->optionType(),
                strike,
                process_->x0()/(pastFixings + futureFixings)
                    *qTS->discount(fixingDates.back())/rTS->discount(fixingDates.back()),
                std::sqrt(volTS->blackVariance(fixingDates.back(), strike)),
                rTS->discount(exerciseDate)
            );
        }
    }
}
]]></document_content>
  </document>
  <document index="7">
    <source>asian/continuousarithmeticasianlevyengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/asian/continuousarithmeticasianlevyengine.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <utility>

using namespace std;

namespace QuantLib {

    ContinuousArithmeticAsianLevyEngine::ContinuousArithmeticAsianLevyEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Handle<Quote> currentAverage)
    : process_(std::move(process)), currentAverage_(std::move(currentAverage)) {
        registerWith(process_);
        registerWith(currentAverage_);
    }

    ContinuousArithmeticAsianLevyEngine::ContinuousArithmeticAsianLevyEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Handle<Quote> currentAverage,
        Date startDate)
    : process_(std::move(process)), currentAverage_(std::move(currentAverage)),
      startDate_(startDate) {
        registerWith(process_);
        registerWith(currentAverage_);
    }

    void ContinuousArithmeticAsianLevyEngine::calculate() const {
        QL_REQUIRE(arguments_.averageType == Average::Arithmetic,
                   "not an Arithmetic average option");
        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European Option");

        // Prefer start date from option if available, otherwise use constructor parameter.
        // At least one must be specified.
        Date startDate = (arguments_.startDate != Date()) ? arguments_.startDate : startDate_;
        QL_REQUIRE(startDate != Date(), "start date not provided");
        QL_REQUIRE(startDate <= process_->riskFreeRate()->referenceDate(),
                   "start date must be earlier than or equal to reference date");

        DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
        DayCounter divdc = process_->dividendYield()->dayCounter();
        DayCounter voldc = process_->blackVolatility()->dayCounter();
        Real spot = process_->stateVariable()->value();

        // payoff
        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        // original time to maturity
        Date maturity = arguments_.exercise->lastDate();
        Time T = rfdc.yearFraction(startDate,
                                   arguments_.exercise->lastDate());
        // remaining time to maturity
        Time T2 = rfdc.yearFraction(process_->riskFreeRate()->referenceDate(),
                                    arguments_.exercise->lastDate());

        Real strike = payoff->strike();

        Volatility volatility =
            process_->blackVolatility()->blackVol(maturity, strike);

        CumulativeNormalDistribution N;

        Rate riskFreeRate = process_->riskFreeRate()->
            zeroRate(maturity, rfdc, Continuous, NoFrequency);
        Rate dividendYield = process_->dividendYield()->
            zeroRate(maturity, divdc, Continuous, NoFrequency);
        Real b = riskFreeRate - dividendYield;

        Real Se = (std::fabs(b) > 1000*QL_EPSILON) 
            ? Real((spot/(T*b))*(exp((b-riskFreeRate)*T2)-exp(-riskFreeRate*T2)))
            : Real(spot*T2/T * std::exp(-riskFreeRate*T2));

        Real X;
        if (T2 < T) {
            QL_REQUIRE(!currentAverage_.empty() && currentAverage_->isValid(),
                       "current average required for seasoned option");
            X = strike - ((T-T2)/T)*currentAverage_->value();
        } else {
            X = strike;
        }

        Real m = (std::fabs(b) > 1000*QL_EPSILON) ? ((exp(b*T2)-1)/b) : T2;

        Real M = (2*spot*spot/(b+volatility*volatility)) *
            (((exp((2*b+volatility*volatility)*T2)-1)
              / (2*b+volatility*volatility))-m);

        Real D = M/(T*T);

        Real V = log(D)-2*(riskFreeRate*T2+log(Se));

        Real d1 = (1/sqrt(V))*((log(D)/2)-log(X));
        Real d2 = d1-sqrt(V);

        if(payoff->optionType()==Option::Call)
            results_.value = Se*N(d1) - X*exp(-riskFreeRate*T2)*N(d2);
        else
            results_.value = Se*N(d1) - X*exp(-riskFreeRate*T2)*N(d2)
                             - Se + X*exp(-riskFreeRate*T2);
    }

}
]]></document_content>
  </document>
  <document index="8">
    <source>asian/fdblackscholesasianengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Ralph Schreyer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/methods/finitedifferences/meshers/fdmblackscholesmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsimple2dbssolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmarithmeticaveragecondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/pricingengines/asian/fdblackscholesasianengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {


    FdBlackScholesAsianEngine::FdBlackScholesAsianEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Size tGrid,
        Size xGrid,
        Size aGrid,
        const FdmSchemeDesc& schemeDesc)
    : process_(std::move(process)), tGrid_(tGrid), xGrid_(xGrid), aGrid_(aGrid),
      schemeDesc_(schemeDesc) {}


    void FdBlackScholesAsianEngine::calculate() const {

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "European exercise supported only");
        QL_REQUIRE(arguments_.averageType == Average::Arithmetic,
                   "Arithmetic averaging supported only");
        QL_REQUIRE(   arguments_.runningAccumulator == 0
                   || arguments_.pastFixings > 0,
                   "Running average requires at least one past fixing");

        // 1. Mesher
        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        const Time maturity = process_->time(arguments_.exercise->lastDate());
        const ext::shared_ptr<Fdm1dMesher> equityMesher(
            new FdmBlackScholesMesher(xGrid_, process_, maturity,
                                      payoff->strike()));

        const Real spot = process_->x0();
        QL_REQUIRE(spot > 0.0, "negative or null underlying given");

        const Real avg = (arguments_.runningAccumulator == 0)
                 ? spot : arguments_.runningAccumulator/arguments_.pastFixings;

        const Real normInvEps = InverseCumulativeNormal()(1-0.0001);
        const Real sigmaSqrtT 
            = process_->blackVolatility()->blackVol(maturity, payoff->strike())
                                                        *std::sqrt(maturity);
        const Real r = sigmaSqrtT*normInvEps;

        Real xMin = std::min(std::log(avg)  - 0.25*r, std::log(spot) - 1.5*r);
        Real xMax = std::max(std::log(avg)  + 0.25*r, std::log(spot) + 1.5*r);

        const ext::shared_ptr<Fdm1dMesher> averageMesher(
            new FdmBlackScholesMesher(aGrid_, process_, maturity,
                                      payoff->strike(), xMin, xMax));

        const ext::shared_ptr<FdmMesher> mesher (
            new FdmMesherComposite(equityMesher, averageMesher));

        // 2. Calculator
        ext::shared_ptr<FdmInnerValueCalculator> calculator(
                                new FdmLogInnerValue(payoff, mesher, 1));

        // 3. Step conditions
        std::list<ext::shared_ptr<StepCondition<Array> > > stepConditions;
        std::list<std::vector<Time> > stoppingTimes;

        // 3.1 Arithmetic average step conditions
        std::vector<Time> averageTimes;
        for (auto& fixingDate : arguments_.fixingDates) {
            Time t = process_->time(fixingDate);
            QL_REQUIRE(t >= 0, "Fixing dates must not contain past date");
            averageTimes.push_back(t);
        }
        stoppingTimes.emplace_back(averageTimes);
        stepConditions.push_back(ext::shared_ptr<StepCondition<Array> >(
                new FdmArithmeticAverageCondition(
                        averageTimes, arguments_.runningAccumulator,
                        arguments_.pastFixings, mesher, 0)));

        ext::shared_ptr<FdmStepConditionComposite> conditions(
                new FdmStepConditionComposite(stoppingTimes, stepConditions));

        // 4. Boundary conditions
        const FdmBoundaryConditionSet boundaries;

        // 5. Solver
        FdmSolverDesc solverDesc = { mesher, boundaries, conditions,
                                     calculator, maturity, tGrid_, 0 };
        ext::shared_ptr<FdmSimple2dBSSolver> solver(
              new FdmSimple2dBSSolver(
                              Handle<GeneralizedBlackScholesProcess>(process_),
                              payoff->strike(), solverDesc, schemeDesc_));

        results_.value = solver->valueAt(spot, avg);
        results_.delta = solver->deltaAt(spot, avg, spot*0.01);
        results_.gamma = solver->gammaAt(spot, avg, spot*0.01);
    }
}
]]></document_content>
  </document>
  <document index="9">
    <source>asian/mc_discr_arith_av_price.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/asian/mc_discr_geom_av_price.hpp>
#include <ql/pricingengines/asian/mc_discr_arith_av_price.hpp>

namespace QuantLib {

    ArithmeticAPOPathPricer::ArithmeticAPOPathPricer(
                                         Option::Type type,
                                         Real strike, DiscountFactor discount,
                                         Real runningSum, Size pastFixings)
    : payoff_(type, strike), discount_(discount),
      runningSum_(runningSum), pastFixings_(pastFixings) {
        QL_REQUIRE(strike>=0.0,
            "strike less than zero not allowed");
    }

    Real ArithmeticAPOPathPricer::operator()(const Path& path) const  {
        Size n = path.length();
        QL_REQUIRE(n>1, "the path cannot be empty");

        Real sum;
        Size fixings;
        if (path.timeGrid().mandatoryTimes()[0]==0.0) {
            // include initial fixing
            sum = std::accumulate(path.begin(),path.end(),runningSum_);
            fixings = pastFixings_ + n;
        } else {
            sum = std::accumulate(path.begin()+1,path.end(),runningSum_);
            fixings = pastFixings_ + n - 1;
        }
        Real averagePrice = sum/fixings;
        return discount_ * payoff_(averagePrice);
    }

}
]]></document_content>
  </document>
  <document index="10">
    <source>asian/mc_discr_arith_av_price_heston.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/asian/mc_discr_arith_av_price_heston.hpp>
#include <utility>

namespace QuantLib {

    ArithmeticAPOHestonPathPricer::ArithmeticAPOHestonPathPricer(Option::Type type,
                                                                 Real strike,
                                                                 DiscountFactor discount,
                                                                 std::vector<Size> fixingIndices,
                                                                 Real runningSum,
                                                                 Size pastFixings)
    : payoff_(type, strike), discount_(discount), fixingIndices_(std::move(fixingIndices)),
      runningSum_(runningSum), pastFixings_(pastFixings) {
        QL_REQUIRE(strike>=0.0,
            "strike less than zero not allowed");
    }

    Real ArithmeticAPOHestonPathPricer::operator()(const MultiPath& multiPath) const  {
        const Path& path = multiPath[0];
        const Size n = multiPath.pathSize();
        QL_REQUIRE(n>0, "the path cannot be empty");

        Real sum = runningSum_;
        Size fixings = pastFixings_ + fixingIndices_.size();

        for (unsigned long fixingIndice : fixingIndices_) {
            sum += path[fixingIndice];
        }

        Real averagePrice = sum/fixings;
        return discount_ * payoff_(averagePrice);
    }

}
]]></document_content>
  </document>
  <document index="11">
    <source>asian/mc_discr_arith_av_strike.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/asian/mc_discr_arith_av_strike.hpp>

namespace QuantLib {

    ArithmeticASOPathPricer::ArithmeticASOPathPricer(Option::Type type,
                                                     DiscountFactor discount,
                                                     Real runningSum,
                                                     Size pastFixings)
    : type_(type), discount_(discount),
      runningSum_(runningSum), pastFixings_(pastFixings) {}


    Real ArithmeticASOPathPricer::operator()(const Path& path) const  {
        Size n = path.length();
        QL_REQUIRE(n > 1, "the path cannot be empty");

        Real averageStrike;
        if (path.timeGrid().mandatoryTimes()[0]==0.0) {
            // include initial fixing
            averageStrike =
                std::accumulate(path.begin(),path.end(),runningSum_) /
                (pastFixings_ + n);
        } else {
            averageStrike =
                std::accumulate(path.begin()+1,path.end(),runningSum_) /
                (pastFixings_ + n - 1);
        }

        return discount_
            * PlainVanillaPayoff(type_, averageStrike)(path.back());
    }

}

]]></document_content>
  </document>
  <document index="12">
    <source>asian/mc_discr_geom_av_price.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/asian/mc_discr_geom_av_price.hpp>

namespace QuantLib {

    GeometricAPOPathPricer::GeometricAPOPathPricer(
                                         Option::Type type,
                                         Real strike, DiscountFactor discount,
                                         Real runningProduct, Size pastFixings)
    : payoff_(type, strike), discount_(discount),
      runningProduct_(runningProduct), pastFixings_(pastFixings) {
        QL_REQUIRE(strike>=0.0, "negative strike given");
    }

    Real GeometricAPOPathPricer::operator()(const Path& path) const {
        Size n = path.length() - 1;
        QL_REQUIRE(n>0, "the path cannot be empty");

        Real averagePrice;
        Real product = runningProduct_;
        Size fixings = n+pastFixings_;
        if (path.timeGrid().mandatoryTimes()[0]==0.0) {
            fixings += 1;
            product *= path.front();
        }
        // care must be taken not to overflow product
        constexpr double maxValue = QL_MAX_REAL;
        averagePrice = 1.0;
        for (Size i=1; i<n+1; i++) {
            Real price = path[i];
            if (product < maxValue/price) {
                product *= price;
            } else {
                averagePrice *= std::pow(product, 1.0/fixings);
                product = price;
            }
        }
        averagePrice *= std::pow(product, 1.0/fixings);
        return discount_ * payoff_(averagePrice);
    }

}
]]></document_content>
  </document>
  <document index="13">
    <source>asian/mc_discr_geom_av_price_heston.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Jack Gillett
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/asian/mc_discr_geom_av_price_heston.hpp>
#include <utility>

namespace QuantLib {

    GeometricAPOHestonPathPricer::GeometricAPOHestonPathPricer(Option::Type type,
                                                               Real strike,
                                                               DiscountFactor discount,
                                                               std::vector<Size> fixingIndices,
                                                               Real runningProduct,
                                                               Size pastFixings)
    : payoff_(type, strike), discount_(discount), fixingIndices_(std::move(fixingIndices)),
      runningProduct_(runningProduct), pastFixings_(pastFixings) {
        QL_REQUIRE(strike>=0.0,
            "strike less than zero not allowed");
    }

    Real GeometricAPOHestonPathPricer::operator()(const MultiPath& multiPath) const  {
        const Path& path = multiPath[0];
        const Size n = multiPath.pathSize();
        QL_REQUIRE(n>0, "the path cannot be empty");

        Real averagePrice = 1.0;
        Real product = runningProduct_;
        Size fixings = pastFixings_ + fixingIndices_.size();

        // care must be taken not to overflow product
        constexpr double maxValue = QL_MAX_REAL;
        for (unsigned long fixingIndice : fixingIndices_) {
            Real price = path[fixingIndice];
            if (product < maxValue/price) {
                product *= price;
            } else {
                averagePrice *= std::pow(product, 1.0/fixings);
                product = price;
            }
        }

        averagePrice *= std::pow(product, 1.0/fixings);
        return discount_ * payoff_(averagePrice);
    }

}
]]></document_content>
  </document>
  <document index="14">
    <source>asian/turnbullwakemanasianengine.cpp</source>
    <document_content><![CDATA[/*
 Copyright (C) 2021 Skandinaviska Enskilda Banken AB (publ)

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/asian/turnbullwakemanasianengine.hpp>
#include <ql/pricingengines/blackcalculator.hpp>

using namespace QuantLib;

void TurnbullWakemanAsianEngine::calculate() const {

    // Enforce a few required things
    QL_REQUIRE(arguments_.exercise->type() == Exercise::European, "not a European Option");
    QL_REQUIRE(arguments_.averageType == Average::Type::Arithmetic,
               "must be Arithmetic Average::Type");

    // Calculate the accrued portion
    Size pastFixings = arguments_.pastFixings;
    Size futureFixings = arguments_.fixingDates.size();
    Real accruedAverage = 0;
    if (pastFixings != 0) {
        accruedAverage = arguments_.runningAccumulator / (pastFixings + futureFixings);
    }
    results_.additionalResults["accrued"] = accruedAverage;

    Real discount = process_->riskFreeRate()->discount(arguments_.exercise->lastDate());
    results_.additionalResults["discount"] = discount;

    ext::shared_ptr<PlainVanillaPayoff> payoff =
        ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
    QL_REQUIRE(payoff, "non-plain payoff given");

    // We will read the volatility off the surface at the effective strike
    Real effectiveStrike = payoff->strike() - accruedAverage;
    results_.additionalResults["strike"] = payoff->strike();
    results_.additionalResults["effective_strike"] = effectiveStrike;

    // If the effective strike is negative, exercise resp. permanent OTM is guaranteed and the
    // valuation is made easy
    Size m = futureFixings + pastFixings;
    if (effectiveStrike <= 0.0) {
        // For a reference, see "Option Pricing Formulas", Haug, 2nd ed, p. 193
        if (payoff->optionType() == Option::Type::Call) {
            Real spot = process_->stateVariable()->value();
            Real S_A_hat = accruedAverage;
            for (const auto& fd : arguments_.fixingDates) {
                S_A_hat += (spot * process_->dividendYield()->discount(fd) /
                            process_->riskFreeRate()->discount(fd)) /
                           m;
            }
            results_.value = discount * (S_A_hat - payoff->strike());
            results_.delta = discount * (S_A_hat - accruedAverage) / spot;
        } else if (payoff->optionType() == Option::Type::Put) {
            results_.value = 0;
            results_.delta = 0;
        }
        results_.gamma = 0;
        return;
    }

    // We should only get this far when the effectiveStrike > 0 but will check anyway
    QL_REQUIRE(effectiveStrike > 0.0, "expected effectiveStrike to be positive");

    // Expected value of the non-accrued portion of the average prices
    // In general, m will equal n below if there is no accrued. If accrued, m > n.
    Real EA = 0.0;
    std::vector<Real> forwards;
    std::vector<Time> times;
    std::vector<Real> spotVars;
    std::vector<Real> spotVolsVec; // additional results only
    Real spot = process_->stateVariable()->value();

    for (const auto& fd : arguments_.fixingDates) {
        DiscountFactor dividendDiscount = process_->dividendYield()->discount(fd);
        DiscountFactor riskFreeDiscountForFwdEstimation = process_->riskFreeRate()->discount(fd);

        forwards.push_back(spot * dividendDiscount / riskFreeDiscountForFwdEstimation);
        times.push_back(process_->blackVolatility()->timeFromReference(fd));

        spotVars.push_back(
            process_->blackVolatility()->blackVariance(times.back(), effectiveStrike));
        spotVolsVec.push_back(std::sqrt(spotVars.back() / times.back()));

        EA += forwards.back();
    }
    EA /= m;

    // Expected value of A^2.
    Real EA2 = 0.0;
    Size n = forwards.size();

    for (Size i = 0; i < n; ++i) {
        EA2 += forwards[i] * forwards[i] * exp(spotVars[i]);
        for (Size j = 0; j < i; ++j) {
            EA2 += 2 * forwards[i] * forwards[j] * exp(spotVars[j]);
        }
    }

    EA2 /= m * m;

    // Calculate value
    Real tn = times.back();
    Real sigma = sqrt(log(EA2 / (EA * EA)) / tn);

    // Populate results
    BlackCalculator black(payoff->optionType(), effectiveStrike, EA, sigma * sqrt(tn), discount);

    results_.value = black.value();
    results_.delta = black.delta(spot);
    results_.gamma = black.gamma(spot);

    results_.additionalResults["forward"] = EA;
    results_.additionalResults["exp_A_2"] = EA2;
    results_.additionalResults["tte"] = tn;
    results_.additionalResults["sigma"] = sigma;
    results_.additionalResults["times"] = times;
    results_.additionalResults["spotVols"] = spotVolsVec;
    results_.additionalResults["forwards"] = forwards;
}
]]></document_content>
  </document>
  <document index="15">
    <source>bacheliercalculator.cpp</source>
    <document_content><![CDATA[﻿/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/comparison.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/pricingengines/bacheliercalculator.hpp>

namespace QuantLib {

    class BachelierCalculator::Calculator : public AcyclicVisitor,
                                        public Visitor<Payoff>,
                                        public Visitor<PlainVanillaPayoff>,
                                        public Visitor<CashOrNothingPayoff>,
                                        public Visitor<AssetOrNothingPayoff>,
                                        public Visitor<GapPayoff> {
      private:
        BachelierCalculator& bachelier_;

      public:
        explicit Calculator(BachelierCalculator& bachelier) : bachelier_(bachelier) {}
        void visit(Payoff&) override;
        void visit(PlainVanillaPayoff&) override;
        void visit(CashOrNothingPayoff&) override;
        void visit(AssetOrNothingPayoff&) override;
        void visit(GapPayoff&) override;
    };


    BachelierCalculator::BachelierCalculator(const ext::shared_ptr<StrikedTypePayoff>& p,
                                     Real forward,
                                     Real stdDev,
                                     Real discount)
    : strike_(p->strike()), forward_(forward), stdDev_(stdDev),
      discount_(discount), variance_(stdDev*stdDev) {
        initialize(p);
    }

    BachelierCalculator::BachelierCalculator(
        Option::Type optionType, Real strike, Real forward, Real stdDev, Real discount)
    : strike_(strike), forward_(forward), stdDev_(stdDev),
      discount_(discount), variance_(stdDev*stdDev) {
        initialize(ext::shared_ptr<StrikedTypePayoff>(new PlainVanillaPayoff(optionType, strike)));
    }

    void BachelierCalculator::initialize(const ext::shared_ptr<StrikedTypePayoff>& p) {
        QL_REQUIRE(stdDev_ >= 0.0, "stdDev (" << stdDev_ << ") must be non-negative");
        QL_REQUIRE(discount_ > 0.0, "discount (" << discount_ << ") must be positive");

        // For Bachelier model, we use d = (F - K) / σ instead of the Black-Scholes d1, d2
        if (stdDev_ >= QL_EPSILON) {
            // Bachelier d parameter: d = (F - K) / σ
            d_ = (forward_ - strike_) / stdDev_;
            
            CumulativeNormalDistribution f;
            cum_d_ = f(d_);
            n_d_ = f.derivative(d_);
        } else {
            // When volatility is zero
            if (close(forward_, strike_)) {
                d_ = 0;
                cum_d_ = 0.5;
                n_d_ = M_SQRT_2 * M_1_SQRTPI;
            } else if (forward_ > strike_) {
                d_ = QL_MAX_REAL;
                cum_d_ = 1.0;
                n_d_ = 0.0;
            } else {
                d_ = QL_MIN_REAL;
                cum_d_ = 0.0;
                n_d_ = 0.0;
            }
        }

        x_ = strike_;
        DxDstrike_ = 1.0;
        DxDs_ = 0.0;

        // For Bachelier model, the option values are:
        // Call: max(F-K, 0) = (F-K)*N(d) + σ*n(d)
        // Put:  max(K-F, 0) = (K-F)*N(-d) + σ*n(d)
        // 
        // We represent this as: discount * (forward * alpha + x * beta)
        // where for Bachelier:
        // Call: alpha = N(d), beta = -N(d) + σ*n(d)/x (when x != 0)
        // Put:  alpha = -N(-d), beta = N(-d) + σ*n(d)/x (when x != 0)
        
        switch (p->optionType()) {
            case Option::Call:
                alpha_ = cum_d_;        // N(d)
                DalphaDd_ = n_d_;       // n(d)
                beta_ = -cum_d_;        // -N(d) - base part
                DbetaDd_ = -n_d_;       // -n(d)
                break;
            case Option::Put:
                alpha_ = cum_d_ - 1.0;  // N(d) - 1 = -N(-d)
                DalphaDd_ = n_d_;       // n(d)
                beta_ = 1.0 - cum_d_;   // 1 - N(d) = N(-d)
                DbetaDd_ = -n_d_;       // -n(d)
                break;
            default:
                QL_FAIL("invalid option type");
        }

        // now dispatch on type.
        Calculator calc(*this);
        p->accept(calc);
    }

    void BachelierCalculator::Calculator::visit(Payoff& p) {
        QL_FAIL("unsupported payoff type: " << p.name());
    }

    void BachelierCalculator::Calculator::visit(PlainVanillaPayoff&) {}

    void BachelierCalculator::Calculator::visit(CashOrNothingPayoff& payoff) {
        bachelier_.alpha_ = bachelier_.DalphaDd_ = 0.0;
        bachelier_.x_ = payoff.cashPayoff();
        bachelier_.DxDstrike_ = 0.0;
        switch (payoff.optionType()) {
            case Option::Call:
                bachelier_.beta_ = bachelier_.cum_d_;
                bachelier_.DbetaDd_ = bachelier_.n_d_;
                break;
            case Option::Put:
                bachelier_.beta_ = 1.0 - bachelier_.cum_d_;
                bachelier_.DbetaDd_ = -bachelier_.n_d_;
                break;
            default:
                QL_FAIL("invalid option type");
        }
    }

    void BachelierCalculator::Calculator::visit(AssetOrNothingPayoff& payoff) {
        bachelier_.beta_ = bachelier_.DbetaDd_ = 0.0;
        switch (payoff.optionType()) {
            case Option::Call:
                bachelier_.alpha_ = bachelier_.cum_d_;
                bachelier_.DalphaDd_ = bachelier_.n_d_;
                break;
            case Option::Put:
                bachelier_.alpha_ = 1.0 - bachelier_.cum_d_;
                bachelier_.DalphaDd_ = -bachelier_.n_d_;
                break;
            default:
                QL_FAIL("invalid option type");
        }
    }

    void BachelierCalculator::Calculator::visit(GapPayoff& payoff) {
        bachelier_.x_ = payoff.secondStrike();
        bachelier_.DxDstrike_ = 0.0;
    }

    Real BachelierCalculator::value() const {
        // Bachelier option value formula:
        // Call: (F-K)*N(d) + σ*n(d)
        // Put:  (K-F)*N(-d) + σ*n(d)
        // where d = (F-K)/σ
        
        Real intrinsic = forward_ - strike_;
        Real timeValue = 0.0;
        
        if (stdDev_ > QL_EPSILON) {
            timeValue = stdDev_ * n_d_;
        }
        
        Real result;
        if (alpha_ >= 0) // Call option (alpha_ = N(d) >= 0)
            result = intrinsic * cum_d_ + timeValue;
        else // Put option (alpha_ = N(d) - 1 < 0)
            result = -intrinsic * (1.0 - cum_d_) + timeValue;
        
        return discount_ * std::max(result, 0.0);
    }

    Real BachelierCalculator::delta(Real spot) const {

        // For Bachelier model:
        // Delta = dV/dS = (dV/dF) * (dF/dS)
        // where dF/dS = F/S (assuming forward = spot * exp(r*T))
        // and dV/dF = N(d) for calls, -N(-d) for puts
        
        Real DforwardDs = forward_ / spot;
        Real deltaFwd = deltaForward();

        return deltaFwd * DforwardDs;
    }

    Real BachelierCalculator::deltaForward() const {
        // For Bachelier model:
        // Delta_Forward = dV/dF = N(d) for calls, -N(-d) for puts
        // where d = (F-K)/σ
        
        if (alpha_ >= 0) { // Call option
            return discount_ * cum_d_; // N(d)
        } else { // Put option  
            return discount_ * (cum_d_ - 1.0); // N(d) - 1 = -N(-d)
        }
    }

    Real BachelierCalculator::elasticity(Real spot) const {
        Real val = value();
        Real del = delta(spot);
        if (val > QL_EPSILON)
            return del / val * spot;
        else if (std::fabs(del) < QL_EPSILON)
            return 0.0;
        else if (del > 0.0)
            return QL_MAX_REAL;
        else
            return QL_MIN_REAL;
    }

    Real BachelierCalculator::elasticityForward() const {
        Real val = value();
        Real del = deltaForward();
        if (val > QL_EPSILON)
            return del / val * forward_;
        else if (std::fabs(del) < QL_EPSILON)
            return 0.0;
        else if (del > 0.0)
            return QL_MAX_REAL;
        else
            return QL_MIN_REAL;
    }

    Real BachelierCalculator::gamma(Real spot) const {

        // For Bachelier model:
        // Gamma = d²V/dS² = d/dS(dV/dS) = d/dS(N(d) * dF/dS) * dF/dS
        // = n(d) * (1/σ) * (dF/dS)² * (dd/dF)
        // where dd/dF = 1/σ
        
        if (stdDev_ <= QL_EPSILON) {
            return 0.0;
        }
        
        Real DforwardDs = forward_ / spot;
        Real gammaForward = n_d_ / stdDev_; // dn(d)/dF = n(d) * (1/σ) * (dd/dF) = n(d)/σ
        
        return discount_ * gammaForward * DforwardDs * DforwardDs;
    }

    Real BachelierCalculator::gammaForward() const {
        // For Bachelier model:
        // Gamma_Forward = d²V/dF² = d/dF(N(d)) = n(d) * dd/dF = n(d)/σ
        
        if (stdDev_ <= QL_EPSILON) {
            return 0.0;
        }
        
        return discount_ * n_d_ / stdDev_;
    }

    Real BachelierCalculator::theta(Real spot, Time maturity) const {

        QL_REQUIRE(maturity >= 0.0, "maturity (" << maturity << ") must be non-negative");
        if (close(maturity, 0.0)) return 0.0;
        
        // Theta = -dV/dt = -(r*V - r*S*Delta + 0.5*σ²*Gamma)

        return -(std::log(discount_) * value() + std::log(forward_ / spot) * spot * delta(spot) +
                 0.5 * variance_ * gamma(spot)) / maturity;
    }

    Real BachelierCalculator::vega(Time maturity) const {
        QL_REQUIRE(maturity >= 0.0, "negative maturity not allowed");

        // For Bachelier model:
        // Vega = dV/dσ = d/dσ[(F-K)*N(d) + σ*n(d)]
        // = (F-K)*n(d)*dd/dσ + n(d) + σ*n'(d)*dd/dσ
        // where d = (F-K)/σ, so dd/dσ = -(F-K)/σ² = -d/σ
        // and n'(d) = -d*n(d)
        // Therefore: Vega = n(d) + σ*(-d*n(d))*(-d/σ) = n(d) + d²*n(d) = n(d)*(1 + d²) - (F-K)*n(d)*d/σ
        // Simplifying: Vega = n(d) for Bachelier model
        
        if (maturity <= QL_EPSILON || stdDev_ <= QL_EPSILON) {
            return 0.0;
        }
        
        return discount_ * std::sqrt(maturity) * n_d_;
    }

    Real BachelierCalculator::rho(Time maturity) const {
        QL_REQUIRE(maturity >= 0.0, "negative maturity not allowed");
        
        // For Bachelier model:
        // Rho = dV/dr = T * (discount * delta_forward * forward - value)
        // where delta_forward = N(d) for calls, N(d)-1 for puts
        
        Real deltaFwd = deltaForward();
        Real rho_value = maturity * (deltaFwd * forward_ - value());
        
        return rho_value;
    }

    Real BachelierCalculator::dividendRho(Time maturity) const {
        QL_REQUIRE(maturity >= 0.0, "negative maturity not allowed");
        
        // For Bachelier model:
        // Dividend rho = -T * discount * delta_forward * forward
        // where delta_forward = N(d) for calls, N(d)-1 for puts
        
        Real deltaFwd = (alpha_ >= 0) ? cum_d_ : (cum_d_ - 1.0);
        
        return -maturity * discount_ * deltaFwd * forward_;
    }

    Real BachelierCalculator::strikeSensitivity() const {
        // For Bachelier model:
        // dV/dK = -N(d) for calls, N(-d) for puts
        // where d = (F-K)/σ, so dd/dK = -1/σ
        
        if (alpha_ >= 0) { // Call option
            return -discount_ * cum_d_; // -N(d)
        } else { // Put option
            return discount_ * (1.0 - cum_d_); // N(-d) = 1 - N(d)
        }
    }


    Real BachelierCalculator::strikeGamma() const {
        // For Bachelier model:
        // d²V/dK² = d/dK(-N(d)) = -n(d) * dd/dK = -n(d) * (-1/σ) = n(d)/σ
        // This is the same for both calls and puts
        
        if (stdDev_ <= QL_EPSILON) {
            return 0.0;
        }
        
        return discount_ * n_d_ / stdDev_;
    }

    // Sensitivity of Vega to forward (Vanna)
    Real BachelierCalculator::vanna(Time maturity) const {
        if (maturity <= QL_EPSILON || stdDev_ <= QL_EPSILON) {
            return 0.0;
        }
        // d_ is (F-K)/stdDev_
        // n_d_ is n(d)
        // Vanna = -d * n(d) / stdDev_ * sqrt(T)
        return -d_ * n_d_ * std::sqrt(maturity) / stdDev_;
    }

    // Sensitivity of Vega to volatility (Volga)
    Real BachelierCalculator::volga(Time maturity) const {
        if (maturity <= QL_EPSILON || stdDev_ <= QL_EPSILON) {
            return 0.0;
        }
        // Volga = d^2 / stdDev_ * Vega
        Real vega = this->vega(maturity);
        return (d_ * d_ / stdDev_) * vega;
    }
}
]]></document_content>
  </document>
  <document index="16">
    <source>barrier/analyticbarrierengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2002, 2003 Ferdinando Ametrano
 Copyright (C) 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2003 Neil Firth
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/barrier/analyticbarrierengine.hpp>
#include <utility>

namespace QuantLib {

    AnalyticBarrierEngine::AnalyticBarrierEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticBarrierEngine::calculate() const {

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        QL_REQUIRE(payoff->strike()>0.0,
                   "strike must be positive");

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "only european style option are supported");

        Real strike = payoff->strike();
        Real spot = process_->x0();
        QL_REQUIRE(spot > 0.0, "negative or null underlying given");
        QL_REQUIRE(!triggered(spot), "barrier touched");

        Barrier::Type barrierType = arguments_.barrierType;

        switch (payoff->optionType()) {
          case Option::Call:
            switch (barrierType) {
              case Barrier::DownIn:
                if (strike >= barrier())
                    results_.value = C(1,1) + E(1);
                else
                    results_.value = A(1) - B(1) + D(1,1) + E(1);
                break;
              case Barrier::UpIn:
                if (strike >= barrier())
                    results_.value = A(1) + E(-1);
                else
                    results_.value = B(1) - C(-1,1) + D(-1,1) + E(-1);
                break;
              case Barrier::DownOut:
                if (strike >= barrier())
                    results_.value = A(1) - C(1,1) + F(1);
                else
                    results_.value = B(1) - D(1,1) + F(1);
                break;
              case Barrier::UpOut:
                if (strike >= barrier())
                    results_.value = F(-1);
                else
                    results_.value = A(1) - B(1) + C(-1,1) - D(-1,1) + F(-1);
                break;
            }
            break;
          case Option::Put:
            switch (barrierType) {
              case Barrier::DownIn:
                if (strike >= barrier())
                    results_.value = B(-1) - C(1,-1) + D(1,-1) + E(1);
                else
                    results_.value = A(-1) + E(1);
                break;
              case Barrier::UpIn:
                if (strike >= barrier())
                    results_.value = A(-1) - B(-1) + D(-1,-1) + E(-1);
                else
                    results_.value = C(-1,-1) + E(-1);
                break;
              case Barrier::DownOut:
                if (strike >= barrier())
                    results_.value = A(-1) - B(-1) + C(1,-1) - D(1,-1) + F(1);
                else
                    results_.value = F(1);
                break;
              case Barrier::UpOut:
                if (strike >= barrier())
                    results_.value = B(-1) - D(-1,-1) + F(-1);
                else
                    results_.value = A(-1) - C(-1,-1) + F(-1);
                break;
            }
            break;
          default:
            QL_FAIL("unknown type");
        }
    }


    Real AnalyticBarrierEngine::underlying() const {
        return process_->x0();
    }

    Real AnalyticBarrierEngine::strike() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        return payoff->strike();
    }

    Volatility AnalyticBarrierEngine::volatility() const {
        return process_->blackVolatility()->blackVol(
                    arguments_.exercise->lastDate(),
                    strike());
    }

    Real AnalyticBarrierEngine::stdDeviation() const {
        return std::sqrt(process_->blackVolatility()->blackVariance(
                        arguments_.exercise->lastDate(),
                        strike()));
    }

    Real AnalyticBarrierEngine::barrier() const {
        return arguments_.barrier;
    }

    Real AnalyticBarrierEngine::rebate() const {
        return arguments_.rebate;
    }

    Rate AnalyticBarrierEngine::riskFreeRate() const {
        return process_->riskFreeRate()->zeroRate(
                    arguments_.exercise->lastDate(),
                    process_->riskFreeRate()->dayCounter(),
                    Continuous, NoFrequency);
    }

    DiscountFactor AnalyticBarrierEngine::riskFreeDiscount() const {
        return process_->riskFreeRate()->discount(
                    arguments_.exercise->lastDate());
    }

    Rate AnalyticBarrierEngine::dividendYield() const {
        return process_->dividendYield()->zeroRate(
                    arguments_.exercise->lastDate(),
                    process_->dividendYield()->dayCounter(),
                    Continuous, NoFrequency);
    }

    DiscountFactor AnalyticBarrierEngine::dividendDiscount() const {
        return process_->dividendYield()->discount(
                    arguments_.exercise->lastDate());
    }

    Rate AnalyticBarrierEngine::mu() const {
        Volatility vol = volatility();
        return (riskFreeRate() - dividendYield())/(vol * vol) - 0.5;
    }

    Real AnalyticBarrierEngine::muSigma() const {
        return (1 + mu()) * stdDeviation();
    }

    Real AnalyticBarrierEngine::A(Real phi) const {
        Real x1 =
            std::log(underlying()/strike())/stdDeviation() + muSigma();
        Real N1 = f_(phi*x1);
        Real N2 = f_(phi*(x1-stdDeviation()));

        return phi*(underlying() * dividendDiscount() * N1
                      - strike() * riskFreeDiscount() * N2);
    }

    Real AnalyticBarrierEngine::B(Real phi) const {
        Real x2 =
            std::log(underlying()/barrier())/stdDeviation() + muSigma();
        Real N1 = f_(phi*x2);
        Real N2 = f_(phi*(x2-stdDeviation()));
        return phi*(underlying() * dividendDiscount() * N1
                      - strike() * riskFreeDiscount() * N2);
    }

    Real AnalyticBarrierEngine::C(Real eta, Real phi) const {
        Real HS = barrier()/underlying();
        Real powHS0 = std::pow(HS, 2 * mu());
        Real powHS1 = powHS0 * HS * HS;
        Real y1 = std::log(barrier()*HS/strike())/stdDeviation() + muSigma();
        Real N1 = f_(eta*y1);
        Real N2 = f_(eta*(y1-stdDeviation()));
        // when N1 or N2 are zero, the corresponding powHS might
        // be infinity, resulting in a NaN for their products.  The limit should be 0.
        return phi*(underlying() * dividendDiscount() * (N1 == 0.0 ? Real(0.0) : Real(powHS1 * N1))
                      - strike() * riskFreeDiscount() * (N2 == 0.0 ? Real(0.0) : Real(powHS0 * N2)));
    }

    Real AnalyticBarrierEngine::D(Real eta, Real phi) const {
        Real HS = barrier()/underlying();
        Real powHS0 = std::pow(HS, 2 * mu());
        Real powHS1 = powHS0 * HS * HS;
        Real y2 = std::log(barrier()/underlying())/stdDeviation() + muSigma();
        Real N1 = f_(eta*y2);
        Real N2 = f_(eta*(y2-stdDeviation()));
        // when N1 or N2 are zero, the corresponding powHS might
        // be infinity, resulting in a NaN for their products.  The limit should be 0.
        return phi*(underlying() * dividendDiscount() * (N1 == 0.0 ? Real(0.0) : Real(powHS1 * N1))
                      - strike() * riskFreeDiscount() * (N2 == 0.0 ? Real(0.0) : Real(powHS0 * N2)));
    }

    Real AnalyticBarrierEngine::E(Real eta) const {
        if (rebate() > 0) {
            Real powHS0 = std::pow(barrier()/underlying(), 2 * mu());
            Real x2 =
                std::log(underlying()/barrier())/stdDeviation() + muSigma();
            Real y2 =
                std::log(barrier()/underlying())/stdDeviation() + muSigma();
            Real N1 = f_(eta*(x2 - stdDeviation()));
            Real N2 = f_(eta*(y2 - stdDeviation()));
            // when N2 is zero, powHS0 might be infinity, resulting in
            // a NaN for their product.  The limit should be 0.
            return rebate() * riskFreeDiscount() * (N1 - (N2 == 0.0 ? Real(0.0) : Real(powHS0 * N2)));
        } else {
            return 0.0;
        }
    }

    Real AnalyticBarrierEngine::F(Real eta) const {
        if (rebate() > 0) {
            Rate m = mu();
            Volatility vol = volatility();
            Real lambda = std::sqrt(m*m + 2.0*riskFreeRate()/(vol * vol));
            Real HS = barrier()/underlying();
            Real powHSplus = std::pow(HS, m + lambda);
            Real powHSminus = std::pow(HS, m - lambda);

            Real sigmaSqrtT = stdDeviation();
            Real z = std::log(barrier()/underlying())/sigmaSqrtT
                + lambda * sigmaSqrtT;

            Real N1 = f_(eta * z);
            Real N2 = f_(eta * (z - 2.0 * lambda * sigmaSqrtT));
            // when N1 or N2 are zero, the corresponding powHS might
            // be infinity, resulting in a NaN for their product.  The limit should be 0.
            return rebate() * ((N1 == 0.0 ? Real(0.0) : Real(powHSplus * N1)) + (N2 == 0.0 ? Real(0.0) : Real(powHSminus * N2)));
        } else {
            return 0.0;
        }
    }

}
]]></document_content>
  </document>
  <document index="17">
    <source>barrier/analyticbinarybarrierengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/pricingengines/barrier/analyticbinarybarrierengine.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <utility>

namespace QuantLib {

    // calc helper object 
    class AnalyticBinaryBarrierEngine_helper
    {
    
    public:
        AnalyticBinaryBarrierEngine_helper(
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             const ext::shared_ptr<StrikedTypePayoff> &payoff,
             const ext::shared_ptr<AmericanExercise> &exercise,
             const BarrierOption::arguments &arguments):
        process_(process),
        payoff_(payoff),
        exercise_(exercise),
        arguments_(arguments)
        {
        }

        Real payoffAtExpiry(Real spot, Real variance, Real discount);
    private:
        const ext::shared_ptr<GeneralizedBlackScholesProcess>& process_;
        const ext::shared_ptr<StrikedTypePayoff> &payoff_;
        const ext::shared_ptr<AmericanExercise> &exercise_;
        const BarrierOption::arguments &arguments_;
    };


    AnalyticBinaryBarrierEngine::AnalyticBinaryBarrierEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticBinaryBarrierEngine::calculate() const {

        ext::shared_ptr<AmericanExercise> ex =
            ext::dynamic_pointer_cast<AmericanExercise>(arguments_.exercise);
        QL_REQUIRE(ex, "non-American exercise given");
        QL_REQUIRE(ex->payoffAtExpiry(), "payoff must be at expiry");
        QL_REQUIRE(ex->dates()[0] <=
                   process_->blackVolatility()->referenceDate(),
                   "American option with window exercise not handled yet");

        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        Real spot = process_->stateVariable()->value();
        QL_REQUIRE(spot > 0.0, "negative or null underlying given");

        Real variance =
            process_->blackVolatility()->blackVariance(ex->lastDate(),
                                                       payoff->strike());
        Real barrier = arguments_.barrier;
        QL_REQUIRE(barrier>0.0,
                   "positive barrier value required");
        Barrier::Type barrierType = arguments_.barrierType;

        // KO degenerate cases
        if ( (barrierType == Barrier::DownOut && spot <= barrier) ||
             (barrierType == Barrier::UpOut && spot >= barrier))
        {
            // knocked out, no value
            results_.value = 0;
            results_.delta = 0;
            results_.gamma = 0;
            results_.vega = 0;
            results_.theta = 0;
            results_.rho = 0;
            results_.dividendRho = 0;
            return;
        }

        // KI degenerate cases
        if ((barrierType == Barrier::DownIn && spot <= barrier) ||
           (barrierType == Barrier::UpIn && spot >= barrier)) {
            // knocked in - is a digital european
            ext::shared_ptr<Exercise> exercise(new EuropeanExercise(
                                             arguments_.exercise->lastDate()));

            ext::shared_ptr<PricingEngine> engine(
                                       new AnalyticEuropeanEngine(process_));

            VanillaOption opt(payoff, exercise);
            opt.setPricingEngine(engine);
            results_.value = opt.NPV();
            results_.delta = opt.delta();
            results_.gamma = opt.gamma();
            results_.vega = opt.vega();
            results_.theta = opt.theta();
            results_.rho = opt.rho();
            results_.dividendRho = opt.dividendRho();
            return;
        }

        Rate riskFreeDiscount =
            process_->riskFreeRate()->discount(ex->lastDate());

        AnalyticBinaryBarrierEngine_helper helper(process_,
           payoff, ex, arguments_);
        results_.value = helper.payoffAtExpiry(spot, variance, riskFreeDiscount);
    }

    Real AnalyticBinaryBarrierEngine_helper::payoffAtExpiry(
         Real spot, Real variance, Real discount)
    {
        Rate dividendDiscount =
            process_->dividendYield()->discount(exercise_->lastDate());

        QL_REQUIRE(spot>0.0,
                   "positive spot value required");

        QL_REQUIRE(discount>0.0,
                   "positive discount required");

        QL_REQUIRE(dividendDiscount>0.0,
                   "positive dividend discount required");

        QL_REQUIRE(variance>=0.0,
                   "negative variance not allowed");

        Option::Type type   = payoff_->optionType();
        Real strike = payoff_->strike();
        Real barrier = arguments_.barrier;
        QL_REQUIRE(barrier>0.0,
                   "positive barrier value required");
        Barrier::Type barrierType = arguments_.barrierType;

        Real stdDev = std::sqrt(variance);
        Real mu = std::log(dividendDiscount/discount)/variance - 0.5;
        Real K = 0;

        // binary cash-or-nothing payoff?
        ext::shared_ptr<CashOrNothingPayoff> coo =
            ext::dynamic_pointer_cast<CashOrNothingPayoff>(payoff_);
        if (coo != nullptr) {
            K = coo->cashPayoff();
        }

        // binary asset-or-nothing payoff?
        ext::shared_ptr<AssetOrNothingPayoff> aoo =
            ext::dynamic_pointer_cast<AssetOrNothingPayoff>(payoff_);
        if (aoo != nullptr) {
            mu += 1.0; 
            K = spot * dividendDiscount / discount; // forward
        }

        Real log_S_X = std::log(spot/strike);
        Real log_S_H = std::log(spot/barrier);
        Real log_H_S = std::log(barrier/spot);
        Real log_H2_SX = std::log(barrier*barrier/(spot*strike));
        Real H_S_2mu = std::pow(barrier/spot, 2*mu);

        Real eta = (barrierType == Barrier::DownIn ||
                    barrierType == Barrier::DownOut ? 1.0 : -1.0);
        Real phi = (type == Option::Call ? 1.0 : -1.0);

        Real x1, x2, y1, y2;
        Real cum_x1, cum_x2, cum_y1, cum_y2;
        if (variance>=QL_EPSILON) {

            // we calculate using mu*stddev instead of (mu+1)*stddev
            // because cash-or-nothing don't need it. asset-or-nothing
            // mu is really mu+1
            x1 = phi*(log_S_X/stdDev + mu*stdDev);
            x2 = phi*(log_S_H/stdDev + mu*stdDev);
            y1 = eta*(log_H2_SX/stdDev + mu*stdDev);
            y2 = eta*(log_H_S/stdDev + mu*stdDev);

            CumulativeNormalDistribution f;
            cum_x1 = f(x1);
            cum_x2 = f(x2);
            cum_y1 = f(y1);
            cum_y2 = f(y2);
        } else {
            if (log_S_X>0)
                cum_x1= 1.0;
            else
                cum_x1= 0.0;
            if (log_S_H>0)
                cum_x2= 1.0;
            else
                cum_x2= 0.0;
            if (log_H2_SX>0)
                cum_y1= 1.0;
            else
                cum_y1= 0.0;
            if (log_H_S>0)
                cum_y2= 1.0;
            else
                cum_y2= 0.0;
        }

        Real alpha = 0;

        switch (barrierType) {
            case Barrier::DownIn:
               if (type == Option::Call) {
                  // down-in and call
                  if (strike >= barrier) {
                     // B3 (eta=1, phi=1)
                     alpha = H_S_2mu * cum_y1;  
                  } else {
                     // B1-B2+B4 (eta=1, phi=1)
                     alpha = cum_x1 - cum_x2 + H_S_2mu * cum_y2; 
                  }
               }
               else {
                  // down-in and put 
                  if (strike >= barrier) {
                     // B2-B3+B4 (eta=1, phi=-1)
                     alpha = cum_x2 + H_S_2mu*(-cum_y1 + cum_y2);
                  } else {
                     // B1 (eta=1, phi=-1)
                     alpha = cum_x1;
                  }
               }
               break;

            case Barrier::UpIn:
               if (type == Option::Call) {
                  // up-in and call
                  if (strike >= barrier) {
                     // B1 (eta=-1, phi=1)
                     alpha = cum_x1;  
                  } else {
                     // B2-B3+B4 (eta=-1, phi=1)
                     alpha = cum_x2 + H_S_2mu * (-cum_y1 + cum_y2);
                  }
               }
               else {
                  // up-in and put 
                  if (strike >= barrier) {
                     // B1-B2+B4 (eta=-1, phi=-1)
                     alpha = cum_x1 - cum_x2 + H_S_2mu * cum_y2;
                  } else {
                     // B3 (eta=-1, phi=-1)
                     alpha = H_S_2mu * cum_y1;  
                  }
               }
               break;

            case Barrier::DownOut:
               if (type == Option::Call) {
                  // down-out and call
                  if (strike >= barrier) {
                     // B1-B3 (eta=1, phi=1)
                     alpha = cum_x1 - H_S_2mu * cum_y1; 
                  } else {
                     // B2-B4 (eta=1, phi=1)
                     alpha = cum_x2 - H_S_2mu * cum_y2; 
                  }
               }
               else {
                  // down-out and put 
                  if (strike >= barrier) {
                     // B1-B2+B3-B4 (eta=1, phi=-1)
                     alpha = cum_x1 - cum_x2 + H_S_2mu * (cum_y1-cum_y2);
                  } else {
                     // always 0
                     alpha = 0;  
                  }
               }
               break;
            case Barrier::UpOut:
               if (type == Option::Call) {
                  // up-out and call
                  if (strike >= barrier) {
                     // always 0
                     alpha = 0;  
                  } else {
                     // B1-B2+B3-B4 (eta=-1, phi=1)
                     alpha = cum_x1 - cum_x2 + H_S_2mu * (cum_y1-cum_y2);
                  }
               }
               else {
                  // up-out and put 
                  if (strike >= barrier) {
                     // B2-B4 (eta=-1, phi=-1)
                     alpha = cum_x2 - H_S_2mu * cum_y2;
                  } else {
                     // B1-B3 (eta=-1, phi=-1)
                     alpha = cum_x1 - H_S_2mu * cum_y1;
                  }
               }
               break;
            default:
                QL_FAIL("invalid barrier type");
        }

        return discount * K * alpha;
    }



}

]]></document_content>
  </document>
  <document index="18">
    <source>barrier/analyticdoublebarrierbinaryengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/barrier/analyticdoublebarrierbinaryengine.hpp>
#include <utility>

using std::fabs;

namespace QuantLib {

   // number of iterations ...
   static Real PI= 3.14159265358979323846264338327950;

    // calc helper object 
    class AnalyticDoubleBarrierBinaryEngine_helper
    {
    
    public:
        AnalyticDoubleBarrierBinaryEngine_helper(
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             const ext::shared_ptr<CashOrNothingPayoff> &payoff,
             const DoubleBarrierOption::arguments &arguments):
        process_(process),
        payoff_(payoff),
        arguments_(arguments)
        {
        }

        Real payoffAtExpiry(Real spot, Real variance,
                            DoubleBarrier::Type barrierType,
                            Size maxIteration = 100,
                            Real requiredConvergence = 1e-8);
        Real payoffKIKO(Real spot, Real variance,
                        DoubleBarrier::Type barrierType,
                        Size maxIteration = 1000,
                        Real requiredConvergence = 1e-8);

    private:

        const ext::shared_ptr<GeneralizedBlackScholesProcess>& process_;
        const ext::shared_ptr<CashOrNothingPayoff> &payoff_;
        const DoubleBarrierOption::arguments &arguments_;
    };


    // helper object methods
    Real AnalyticDoubleBarrierBinaryEngine_helper::payoffAtExpiry(
         Real spot, Real variance, DoubleBarrier::Type barrierType,
         Size maxIteration, Real requiredConvergence)
    {
        QL_REQUIRE(spot>0.0,
                   "positive spot value required");

        QL_REQUIRE(variance>=0.0,
                   "negative variance not allowed");

        Time residualTime = process_->time(arguments_.exercise->lastDate());
        QL_REQUIRE(residualTime>0.0,
                   "expiration time must be > 0");

        // Option::Type type   = payoff_->optionType(); // this is not used ?
        Real cash = payoff_->cashPayoff();
        Real barrier_lo = arguments_.barrier_lo;
        Real barrier_hi = arguments_.barrier_hi;

        Real sigmaq = variance/residualTime;
        Real r = process_->riskFreeRate()->zeroRate(residualTime, Continuous,
                                             NoFrequency);
        Real q = process_->dividendYield()->zeroRate(residualTime,
                                                   Continuous, NoFrequency);
        Real b = r - q;

        Real alpha = -0.5 * ( 2*b/sigmaq - 1);
        Real beta = -0.25 * std::pow(( 2*b/sigmaq - 1), 2) - 2 * r/sigmaq;
        Real Z = std::log(barrier_hi / barrier_lo);
        Real factor = ((2*PI*cash)/std::pow(Z,2)); // common factor
        Real lo_alpha = std::pow(spot/barrier_lo, alpha); 
        Real hi_alpha = std::pow(spot/barrier_hi, alpha); 

        Real tot = 0, term = 0;
        for (Size i = 1 ; i < maxIteration ; ++i)
        {
           Real term1 = (lo_alpha-std::pow(-1.0, (int)i)*hi_alpha) /
                              (std::pow(alpha,2)+std::pow(i*PI/Z, 2));
           Real term2 = std::sin(i*PI/Z * std::log(spot/barrier_lo));
           Real term3 = std::exp(-0.5*(std::pow(i*PI/Z,2)-beta)*variance);
           term = factor * i * term1 * term2 * term3;
           tot += term;
        }

        // Check if convergence is sufficiently fast (for extreme parameters with big alpha the convergence can be very
        // poor, see for example Hui "One-touch double barrier binary option value")
        QL_REQUIRE(std::fabs(term) < requiredConvergence, "serie did not converge sufficiently fast");

        if (barrierType == DoubleBarrier::KnockOut)
           return std::max(tot, 0.0); // KO
        else {
           Rate discount = process_->riskFreeRate()->discount(
                                             arguments_.exercise->lastDate());
           QL_REQUIRE(discount>0.0,
                        "positive discount required");
           return std::max(cash * discount - tot, 0.0); // KI
        }
    }

    // helper object methods
    Real AnalyticDoubleBarrierBinaryEngine_helper::payoffKIKO(
         Real spot, Real variance, DoubleBarrier::Type barrierType,
         Size maxIteration, Real requiredConvergence)
    {
        QL_REQUIRE(spot>0.0,
                   "positive spot value required");

        QL_REQUIRE(variance>=0.0,
                   "negative variance not allowed");

        Time residualTime = process_->time(arguments_.exercise->lastDate());
        QL_REQUIRE(residualTime>0.0,
                   "expiration time must be > 0");

        Real cash = payoff_->cashPayoff();
        Real barrier_lo = arguments_.barrier_lo;
        Real barrier_hi = arguments_.barrier_hi;
        if (barrierType == DoubleBarrier::KOKI)
           std::swap(barrier_lo, barrier_hi);

        Real sigmaq = variance/residualTime;
        Real r = process_->riskFreeRate()->zeroRate(residualTime, Continuous,
                                             NoFrequency);
        Real q = process_->dividendYield()->zeroRate(residualTime,
                                                   Continuous, NoFrequency);
        Real b = r - q;

        Real alpha = -0.5 * ( 2*b/sigmaq - 1);
        Real beta = -0.25 * std::pow(( 2*b/sigmaq - 1), 2) - 2 * r/sigmaq;
        Real Z = std::log(barrier_hi / barrier_lo);
        Real log_S_L = std::log(spot / barrier_lo);

        Real tot = 0, term = 0;
        for (Size i = 1 ; i < maxIteration ; ++i)
        {
            Real factor = std::pow(i*PI/Z,2)-beta;
            Real term1 = (beta - std::pow(i*PI/Z,2) * std::exp(-0.5*factor*variance)) / factor;
            Real term2 = std::sin(i * PI/Z * log_S_L);
            term = (2.0/(i*PI)) * term1 * term2;
            tot += term;
        }
        tot += 1 - log_S_L / Z;
        tot *= cash*std::pow(spot/barrier_lo, alpha);

        // Check if convergence is sufficiently fast
        QL_REQUIRE(fabs(term) < requiredConvergence, "serie did not converge sufficiently fast");

        return std::max(tot, 0.0);
    }

    AnalyticDoubleBarrierBinaryEngine::AnalyticDoubleBarrierBinaryEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticDoubleBarrierBinaryEngine::calculate() const {

        if (arguments_.barrierType == DoubleBarrier::KIKO ||
            arguments_.barrierType == DoubleBarrier::KOKI) {
            ext::shared_ptr<AmericanExercise> ex =
                ext::dynamic_pointer_cast<AmericanExercise>(
                                                   arguments_.exercise);
            QL_REQUIRE(ex, "KIKO/KOKI options must have American exercise");
            QL_REQUIRE(ex->dates()[0] <=
                       process_->blackVolatility()->referenceDate(),
                       "American option with window exercise not handled yet");
        } else {
            ext::shared_ptr<EuropeanExercise> ex =
                ext::dynamic_pointer_cast<EuropeanExercise>(
                                                   arguments_.exercise);
            QL_REQUIRE(ex, "non-European exercise given");
        }
        ext::shared_ptr<CashOrNothingPayoff> payoff =
            ext::dynamic_pointer_cast<CashOrNothingPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "a cash-or-nothing payoff must be given");

        Real spot = process_->stateVariable()->value();
        QL_REQUIRE(spot > 0.0, "negative or null underlying given");

        Real variance =
            process_->blackVolatility()->blackVariance(
                                             arguments_.exercise->lastDate(),
                                             payoff->strike());
        Real barrier_lo = arguments_.barrier_lo;
        Real barrier_hi = arguments_.barrier_hi;
        DoubleBarrier::Type barrierType = arguments_.barrierType;
        QL_REQUIRE(barrier_lo>0.0,
                   "positive low barrier value required");
        QL_REQUIRE(barrier_hi>0.0,
                   "positive high barrier value required");
        QL_REQUIRE(barrier_lo < barrier_hi,
                   "barrier_lo must be < barrier_hi");
        QL_REQUIRE(barrierType == DoubleBarrier::KnockIn ||
                   barrierType == DoubleBarrier::KnockOut ||
                   barrierType == DoubleBarrier::KIKO ||
                   barrierType == DoubleBarrier::KOKI,
                   "Unsupported barrier type");

        // degenerate cases
        switch (barrierType) {
          case DoubleBarrier::KnockOut:
            if (spot <= barrier_lo || spot >= barrier_hi) {
                // knocked out, no value
                results_.value = 0;
                results_.delta = 0;
                results_.gamma = 0;
                results_.vega = 0;
                results_.rho = 0;
                return;
            }
            break;

          case DoubleBarrier::KnockIn:
            if (spot <= barrier_lo || spot >= barrier_hi) {
                // knocked in - pays
                results_.value = payoff->cashPayoff();
                results_.delta = 0;
                results_.gamma = 0;
                results_.vega = 0;
                results_.rho = 0;
                return;
            }
            break;

          case DoubleBarrier::KIKO:
            if (spot >= barrier_hi) {
                // knocked out, no value
                results_.value = 0;
                results_.delta = 0;
                results_.gamma = 0;
                results_.vega = 0;
                results_.rho = 0;
                return;
            } else if (spot <= barrier_lo) {
                // knocked in, pays
                results_.value = payoff->cashPayoff();
                results_.delta = 0;
                results_.gamma = 0;
                results_.vega = 0;
                results_.rho = 0;
                return;
            }
            break;

          case DoubleBarrier::KOKI:
            if (spot <= barrier_lo) {
                // knocked out, no value
                results_.value = 0;
                results_.delta = 0;
                results_.gamma = 0;
                results_.vega = 0;
                results_.rho = 0;
                return;
            } else if (spot >= barrier_hi) {
                // knocked in, pays
                results_.value = payoff->cashPayoff();
                results_.delta = 0;
                results_.gamma = 0;
                results_.vega = 0;
                results_.rho = 0;
                return;
            }
            break;
        }

        AnalyticDoubleBarrierBinaryEngine_helper helper(process_,
           payoff, arguments_);
        switch (barrierType)
        {
          case DoubleBarrier::KnockOut:
          case DoubleBarrier::KnockIn:
            results_.value = helper.payoffAtExpiry(spot, variance, barrierType);
            break;

          case DoubleBarrier::KIKO:
          case DoubleBarrier::KOKI:
            results_.value = helper.payoffKIKO(spot, variance, barrierType);
            break;
        }
    }

}

]]></document_content>
  </document>
  <document index="19">
    <source>barrier/analyticdoublebarrierengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/barrier/analyticdoublebarrierengine.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <utility>

namespace QuantLib {

    AnalyticDoubleBarrierEngine::AnalyticDoubleBarrierEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process, int series)
    : process_(std::move(process)), series_(series) {
        registerWith(process_);
    }

    void AnalyticDoubleBarrierEngine::calculate() const {

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "this engine handles only european options");

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        Real strike = payoff->strike();
        QL_REQUIRE(strike>0.0,
                   "strike must be positive");

        Real spot = underlying();
        QL_REQUIRE(spot > 0.0, "negative or null underlying given");
        QL_REQUIRE(!triggered(spot), "barrier(s) already touched");

        DoubleBarrier::Type barrierType = arguments_.barrierType;

        if (triggered(spot)) {
           if (barrierType == DoubleBarrier::KnockIn)
               results_.value = vanillaEquivalent();  // knocked in
           else
               results_.value = 0.0;  // knocked out
        } else {
           switch (payoff->optionType()) {
             case Option::Call:
               switch (barrierType) {
                 case DoubleBarrier::KnockIn:
                   results_.value = callKI();
                   break;
                 case DoubleBarrier::KnockOut:
                   results_.value = callKO();
                   break;
                 case DoubleBarrier::KIKO:
                 case DoubleBarrier::KOKI:
                   QL_FAIL("unsupported double-barrier type: "
                           << barrierType);
                 default:
                   QL_FAIL("unknown double-barrier type: "
                           << barrierType);
               }
               break;
             case Option::Put:
               switch (barrierType) {
                 case DoubleBarrier::KnockIn:
                   results_.value = putKI();
                   break;
                 case DoubleBarrier::KnockOut:
                   results_.value = putKO();
                   break;
                 case DoubleBarrier::KIKO:
                 case DoubleBarrier::KOKI:
                   QL_FAIL("unsupported double-barrier type: "
                           << barrierType);
                 default:
                   QL_FAIL("unknown double-barrier type: "
                           << barrierType);
               }
               break;
             default:
               QL_FAIL("unknown type");
           }
        }
    }


    Real AnalyticDoubleBarrierEngine::underlying() const {
        return process_->x0();
    }

    Real AnalyticDoubleBarrierEngine::strike() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        return payoff->strike();
    }

    Time AnalyticDoubleBarrierEngine::residualTime() const {
        return process_->time(arguments_.exercise->lastDate());
    }

    Volatility AnalyticDoubleBarrierEngine::volatility() const {
        return process_->blackVolatility()->blackVol(residualTime(), strike());
    }

    Real AnalyticDoubleBarrierEngine::volatilitySquared() const {
        return volatility() * volatility();
    }

    Real AnalyticDoubleBarrierEngine::stdDeviation() const {
        return volatility() * std::sqrt(residualTime());
    }

    Real AnalyticDoubleBarrierEngine::barrierLo() const {
        return arguments_.barrier_lo;
    }

    Real AnalyticDoubleBarrierEngine::barrierHi() const {
        return arguments_.barrier_hi;
    }

    Rate AnalyticDoubleBarrierEngine::riskFreeRate() const {
        return process_->riskFreeRate()->zeroRate(residualTime(), Continuous,
                                                  NoFrequency);
    }

    DiscountFactor AnalyticDoubleBarrierEngine::riskFreeDiscount() const {
        return process_->riskFreeRate()->discount(residualTime());
    }

    Rate AnalyticDoubleBarrierEngine::dividendYield() const {
        return process_->dividendYield()->zeroRate(residualTime(),
                                                   Continuous, NoFrequency);
    }

    DiscountFactor AnalyticDoubleBarrierEngine::dividendDiscount() const {
        return process_->dividendYield()->discount(residualTime());
    }

    Rate AnalyticDoubleBarrierEngine::costOfCarry() const {
        return riskFreeRate() - dividendYield();
    }

    Real AnalyticDoubleBarrierEngine::vanillaEquivalent() const {
        // Call KI equates to vanilla - callKO
        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        Real forwardPrice = underlying() * dividendDiscount() / riskFreeDiscount();
        BlackCalculator black(payoff, forwardPrice, stdDeviation(), riskFreeDiscount());
        Real vanilla = black.value();
        if (vanilla < 0.0)
           vanilla = 0.0;
        return vanilla;
    }

    Real AnalyticDoubleBarrierEngine::callKO() const {
       // N.B. for flat barriers mu3=mu1 and mu2=0
       Real mu1 = 2 * costOfCarry() / volatilitySquared() + 1;
       Real bsigma = (costOfCarry() + volatilitySquared() / 2.0) * residualTime() / stdDeviation();

       Real acc1 = 0;
       Real acc2 = 0;
       for (int n = -series_ ; n <= series_ ; ++n) {
          Real L2n = std::pow(barrierLo(), 2 * n);
          Real U2n = std::pow(barrierHi(), 2 * n);
          Real d1 = std::log( underlying()* U2n / (strike() * L2n) ) / stdDeviation() + bsigma;
          Real d2 = std::log( underlying()* U2n / (barrierHi() * L2n) ) / stdDeviation() + bsigma;
          Real d3 = std::log( std::pow(barrierLo(), 2 * n + 2) / (strike() * underlying() * U2n) ) / stdDeviation() + bsigma;
          Real d4 = std::log( std::pow(barrierLo(), 2 * n + 2) / (barrierHi() * underlying() * U2n) ) / stdDeviation() + bsigma;

          acc1 += std::pow( std::pow(barrierHi(), n) / std::pow(barrierLo(), n), mu1 ) * 
                  (f_(d1) - f_(d2)) -
                  std::pow( std::pow(barrierLo(), n+1) / (std::pow(barrierHi(), n) * underlying()), mu1 ) * 
                  (f_(d3) - f_(d4));

          acc2 += std::pow( std::pow(barrierHi(), n) / std::pow(barrierLo(), n), mu1-2) * 
                  (f_(d1 - stdDeviation()) - f_(d2 - stdDeviation())) -
                  std::pow( std::pow(barrierLo(), n+1) / (std::pow(barrierHi(), n) * underlying()), mu1-2 ) * 
                  (f_(d3-stdDeviation()) - f_(d4-stdDeviation()));
       }

       Real rend = std::exp(-dividendYield() * residualTime());
       Real kov = underlying() * rend * acc1 - strike() * riskFreeDiscount() * acc2;
       return std::max(0.0, kov);
    }
    
    Real AnalyticDoubleBarrierEngine::callKI() const {
        // Call KI equates to vanilla - callKO
        return std::max(0.0, vanillaEquivalent() - callKO());
    }

    Real AnalyticDoubleBarrierEngine::putKO() const {
       Real mu1 = 2 * costOfCarry() / volatilitySquared() + 1;
       Real bsigma = (costOfCarry() + volatilitySquared() / 2.0) * residualTime() / stdDeviation();

       Real acc1 = 0;
       Real acc2 = 0;
       for (int n = -series_ ; n <= series_ ; ++n) {
          Real L2n = std::pow(barrierLo(), 2 * n);
          Real U2n = std::pow(barrierHi(), 2 * n);
          Real y1 = std::log( underlying()* U2n / (std::pow(barrierLo(), 2 * n + 1)) ) / stdDeviation() + bsigma;
          Real y2 = std::log( underlying()* U2n / (strike() * L2n) ) / stdDeviation() + bsigma;
          Real y3 = std::log( std::pow(barrierLo(), 2 * n + 2) / (barrierLo() * underlying() * U2n) ) / stdDeviation() + bsigma;
          Real y4 = std::log( std::pow(barrierLo(), 2 * n + 2) / (strike() * underlying() * U2n) ) / stdDeviation() + bsigma;

          acc1 += std::pow( std::pow(barrierHi(), n) / std::pow(barrierLo(), n), mu1-2) * 
                  (f_(y1 - stdDeviation()) - f_(y2 - stdDeviation())) -
                  std::pow( std::pow(barrierLo(), n+1) / (std::pow(barrierHi(), n) * underlying()), mu1-2 ) * 
                  (f_(y3-stdDeviation()) - f_(y4-stdDeviation()));

          acc2 += std::pow( std::pow(barrierHi(), n) / std::pow(barrierLo(), n), mu1 ) * 
                  (f_(y1) - f_(y2)) -
                  std::pow( std::pow(barrierLo(), n+1) / (std::pow(barrierHi(), n) * underlying()), mu1 ) * 
                  (f_(y3) - f_(y4));

       }

       Real rend = std::exp(-dividendYield() * residualTime());
       Real kov = strike() * riskFreeDiscount() * acc1 - underlying() * rend  * acc2;
       return std::max(0.0, kov);
    }
    
    Real AnalyticDoubleBarrierEngine::putKI() const {
        // Put KI equates to vanilla - putKO
        return std::max(0.0, vanillaEquivalent() - putKO());
    }

    
}

]]></document_content>
  </document>
  <document index="20">
    <source>barrier/analyticpartialtimebarrieroptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/barrier/analyticpartialtimebarrieroptionengine.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <utility>

namespace QuantLib {

    AnalyticPartialTimeBarrierOptionEngine::AnalyticPartialTimeBarrierOptionEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::calculate(PartialTimeBarrierOption::arguments& arguments,
                                                          const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                                                          const ext::shared_ptr<GeneralizedBlackScholesProcess>& process) const {
        Barrier::Type barrierType = arguments.barrierType;
        PartialBarrier::Range barrierRange = arguments.barrierRange;
        Rate r = process->riskFreeRate()->zeroRate(residualTime(), Continuous,
                                                  NoFrequency);
        Rate q = process->dividendYield()->zeroRate(residualTime(), Continuous,
                                                  NoFrequency);
        Real barrier = arguments.barrier;
        Real strike = payoff->strike();
        
        switch (barrierType) {
          case Barrier::DownOut:
            switch (barrierRange) {
              case PartialBarrier::Start:
                return CA(1, barrier, strike, r, q);
              case PartialBarrier::EndB1:
                return CoB1(barrier, strike, r, q);
              case PartialBarrier::EndB2:
                return CoB2(Barrier::DownOut, barrier, strike, r, q);
              default:
                QL_FAIL("invalid barrier range");
            }
            break;

          case Barrier::DownIn:
            switch (barrierRange) {
              case PartialBarrier::Start:
                return CIA(1, barrier, strike, r, q);
              case PartialBarrier::EndB1:
              case PartialBarrier::EndB2:
                QL_FAIL("Down-and-in partial-time end barrier is not implemented");
              default:
                QL_FAIL("invalid barrier range");
            }
            break;

          case Barrier::UpOut:
            switch (barrierRange) {
              case PartialBarrier::Start:
                return CA(-1, barrier, strike, r, q);
              case PartialBarrier::EndB1:
                return CoB1(barrier, strike, r, q);
              case PartialBarrier::EndB2:
                return CoB2(Barrier::UpOut, barrier, strike, r, q);
              default:
                QL_FAIL("invalid barrier range");
            }
            break;

            case Barrier::UpIn:
              switch (barrierRange) {
                case PartialBarrier::Start:
                  return CIA(-1, barrier, strike, r, q);
                case PartialBarrier::EndB1:
                case PartialBarrier::EndB2:
                  QL_FAIL("Up-and-in partial-time end barrier is not implemented");
                default:
                  QL_FAIL("invalid barrier range");
              }
              break;
            default:
              QL_FAIL("unknown barrier type");
          }
    }

    void AnalyticPartialTimeBarrierOptionEngine::calculate() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        QL_REQUIRE(payoff->strike()>0.0,
                   "strike must be positive");

        Real spot = process_->x0();
        QL_REQUIRE(spot > 0.0, "negative or null underlying given");

        auto getSymmetricBarrierType = [](Barrier::Type barrierType) -> Barrier::Type {
          if (barrierType == Barrier::UpIn) return Barrier::DownIn;
          if (barrierType == Barrier::DownIn) return Barrier::UpIn;
          if (barrierType == Barrier::UpOut) return Barrier::DownOut;
          return Barrier::UpOut;
        };

        auto tmp_arguments_ = arguments_;
        if (payoff->optionType() == Option::Put)
        {
          Real spotSq = spot * spot;
          Real callStrike = spotSq / payoff->strike();
          ext::shared_ptr<PlainVanillaPayoff> callPayoff =
            ext::make_shared<PlainVanillaPayoff>(Option::Call, callStrike);
          tmp_arguments_.barrierType = getSymmetricBarrierType(arguments_.barrierType);
          tmp_arguments_.barrier = spotSq / arguments_.barrier;
          tmp_arguments_.payoff = callPayoff;
          auto callProcess = ext::make_shared<GeneralizedBlackScholesProcess>(
              process_->stateVariable(),
              process_->riskFreeRate(),
              process_->dividendYield(),
              process_->blackVolatility()
            );

          results_.value = payoff->strike() / spot * calculate(tmp_arguments_, callPayoff, callProcess);
        } else
          results_.value = calculate(tmp_arguments_, payoff, process_);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::CoB2(
                                      Barrier::Type barrierType, 
                                      Real barrier, Real strike, Rate r, Rate q) const {
        Real result = 0.0;
        Real b = r - q;
        Real T = residualTime();
        Real S = underlying();
        Real mu_ = mu(strike, b);
        Real g1_ = g1(barrier, strike, b);
        Real g2_ = g2(barrier, strike, b);
        Real g3_ = g3(barrier, strike, b);
        Real g4_ = g4(barrier, strike, b);
        Real e1_ = e1(barrier, strike, b);
        Real e2_ = e2(barrier, strike, b);
        Real e3_ = e3(barrier, strike, b);
        Real e4_ = e4(barrier, strike, b);
        Real rho_ = rho();
        Real HSMu = HS(S, barrier, 2 * mu_);
        Real HSMu1 = HS(S, barrier, 2 * (mu_ + 1));
        Real X1 = strike * std::exp(-r * T);

        if (strike < barrier){
            switch (barrierType) {
              case Barrier::DownOut:
                result = S * std::exp((b - r) * T);
                result *= (M(g1_, e1_, rho_) - HSMu1 * M(g3_, -e3_, -rho_));
                result -= X1 * (M(g2_, e2_, rho_)-HSMu*M(g4_, -e4_, -rho_));
                return result;

              case Barrier::UpOut:
                result = S * std::exp((b - r) * T);
                result *= (M(-g1_, -e1_, rho_) - HSMu1 * M(-g3_, e3_, -rho_));
                result -= X1 * (M(-g2_, -e2_, rho_) - HSMu * M(-g4_, e4_, -rho_));
                result -= S * std::exp((b - r) * T) * 
                          (M(-d1(strike, b), -e1_, rho_) - HSMu1 * 
                          M(e3_, -f1(barrier, strike, b),-rho_));
                result += X1 * (M(-d2(strike, b), -e2_, rho_) - HSMu * 
                          M(e4_, -f2(barrier, strike, b), -rho_));
                return result;

              default:
                QL_FAIL("invalid barrier type");
            }
        } else {
            QL_FAIL("case of strike>barrier is not implemented for OutEnd B2 type");
        }
    }

    Real AnalyticPartialTimeBarrierOptionEngine::CoB1(Real barrier, Real strike, Rate r, Rate q) const {
        Real result = 0.0;
        Rate b = r - q;
        Real T = residualTime();
        Real S = underlying();
        Real mu_ = mu(strike, b);
        Real g1_ = g1(barrier, strike, b);
        Real g2_ = g2(barrier, strike, b);
        Real g3_ = g3(barrier, strike, b);
        Real g4_ = g4(barrier, strike, b);
        Real e1_ = e1(barrier, strike, b);
        Real e2_ = e2(barrier, strike, b);
        Real e3_ = e3(barrier, strike, b);
        Real e4_ = e4(barrier, strike, b);
        Real rho_ = rho();
        Real HSMu = HS(S, barrier, 2 * mu_);
        Real HSMu1 = HS(S, barrier, 2 * (mu_ + 1));
        Real X1 = strike * std::exp(-r * T);

        if (strike > barrier) {
            result = S * std::exp((b - r) * T);
            result *= (M(d1(strike, b), e1_, rho_) - HSMu1 * M(f1(barrier, strike, b), -e3_, -rho_));
            result -= X1 * (M(d2(strike, b), e2_, rho_) - HSMu * M(f2(barrier, strike, b), -e4_, -rho_));
            return result;
        } else {
            Real S1 = S * std::exp((b - r) * T);
            result = S1;
            result *= (M(-g1_, -e1_, rho_) - HSMu1 * M(-g3_,e3_,-rho_));
            result -= X1 * (M(-g2_, -e2_, rho_) - HSMu * M(-g4_, e4_, -rho_));
            result -= S1 * (M(-d1(strike, b), -e1_, rho_) - HSMu1 * M(-f1(barrier, strike, b), e3_, -rho_));
            result += X1 * (M(-d2(strike, b), -e2_, rho_) - HSMu * M(-f2(barrier, strike, b), e4_, -rho_));
            result += S1 * (M(g1_, e1_, rho_) - HSMu1 * M(g3_, -e3_, -rho_));
            result -= X1 * (M(g2_, e2_, rho_) - HSMu * M(g4_, -e4_, -rho_));
            return result;
        }
    }

    // eta = -1: Up-and-In Call
    // eta =  1: Down-and-In Call
    Real AnalyticPartialTimeBarrierOptionEngine::CIA(Integer eta, Real barrier, Real strike, Rate r, Rate q) const {
        ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(arguments_.exercise);

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);

        VanillaOption europeanOption(payoff, exercise);

        europeanOption.setPricingEngine(
                        ext::make_shared<AnalyticEuropeanEngine>(process_));

        return europeanOption.NPV() - CA(eta, barrier, strike, r, q);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::CA(Integer eta, Real barrier, Real strike, Rate r, Rate q) const {
        //Partial-Time-Start- OUT  Call Option calculation
        Real b = r - q;
        Real rho_ = rho();
        Real T = residualTime();
        Real S = underlying();
        Real mu_ = mu(strike, b);
        Real e1_ = e1(barrier, strike, b);
        Real e2_ = e2(barrier, strike, b);
        Real e3_ = e3(barrier, strike, b);
        Real e4_ = e4(barrier, strike, b);
        Real HSMu = HS(S, barrier,2 * mu_);
        Real HSMu1 = HS(S, barrier, 2 * (mu_ + 1));

        Real result;
        result = S * std::exp((b - r) * T);
        result *= (M(d1(strike, b), eta * e1_, eta * rho_)-HSMu1 * 
                  M(f1(barrier, strike, b), eta * e3_, eta * rho_));
        result -= (strike * std::exp(-r * T) * 
                  (M(d2(strike, b),eta * e2_, eta * rho_) - HSMu *
                  M(f2(barrier, strike, b), eta * e4_, eta * rho_)));
        return result;
    }

    Real AnalyticPartialTimeBarrierOptionEngine::underlying() const {
        return process_->x0();
    }

    Time AnalyticPartialTimeBarrierOptionEngine::residualTime() const {
        return process_->time(arguments_.exercise->lastDate());
    }

    Time AnalyticPartialTimeBarrierOptionEngine::coverEventTime() const {
        return process_->time(arguments_.coverEventDate);
    }

    Volatility AnalyticPartialTimeBarrierOptionEngine::volatility(Time t, Real strike) const {
        return process_->blackVolatility()->blackVol(t, strike);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::f1(Real barrier, Real strike, Rate b) const {
        Real S = underlying();
        Real T = residualTime();
        Real sigma = volatility(T, strike);
        return (std::log(S / strike) + 2 * std::log(barrier / S) + 
              (b + (std::pow(sigma, 2) / 2))*T) / (sigma*std::sqrt(T));
    }

    Real AnalyticPartialTimeBarrierOptionEngine::f2(Real barrier, Real strike, Rate b) const {
        Time T = residualTime();
        return f1(barrier, strike, b) - volatility(T, strike) * std::sqrt(T);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::M(Real a, Real b, Real rho) const {
        BivariateCumulativeNormalDistributionDr78 CmlNormDist(rho);
        return CmlNormDist(a,b);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::rho() const {
        return std::sqrt(coverEventTime() / residualTime());
    }

    Rate AnalyticPartialTimeBarrierOptionEngine::mu(Real strike, Rate b) const {
        Volatility vol = volatility(coverEventTime(), strike);
        return (b - (vol * vol) / 2) / (vol * vol);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::d1(Real strike, Rate b) const {
        Time T2 = residualTime();
        Volatility vol = volatility(T2, strike);
        return (std::log(underlying() / strike) + (b + vol * vol / 2) * T2) / (std::sqrt(T2) * vol);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::d2(Real strike, Rate b) const {
        Time T2 = residualTime();
        Volatility vol = volatility(T2, strike);
        return d1(strike, b) - vol * std::sqrt(T2);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::e1(Real barrier, Real strike, Rate b) const {
        Time T1 = coverEventTime();
        Volatility vol = volatility(T1, strike);
        return (std::log(underlying() / barrier) + (b + vol * vol / 2) * T1) / (std::sqrt(T1) * vol);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::e2(Real barrier, Real strike, Rate b) const {
        Time T1 = coverEventTime();
        Volatility vol = volatility(T1, strike);
        return e1(barrier, strike, b) - vol * std::sqrt(T1);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::e3(Real barrier, Real strike, Rate b) const {
        Time T1 = coverEventTime();
        Real vol = volatility(T1, strike);
        return e1(barrier, strike, b) + (2 * std::log(barrier / underlying()) / (vol * std::sqrt(T1)));
    }

    Real AnalyticPartialTimeBarrierOptionEngine::e4(Real barrier, Real strike, Rate b) const {
        Time t = coverEventTime();
        return e3(barrier, strike, b) - volatility(t, strike) * std::sqrt(t);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::g1(Real barrier, Real strike, Rate b) const {
        Time T2 = residualTime();
        Volatility vol = volatility(T2, strike);
        return (std::log(underlying() / barrier) + (b + vol * vol / 2) * T2) / (std::sqrt(T2) * vol);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::g2(Real barrier, Real strike, Rate b) const {
        Time T2 = residualTime();
        Volatility vol = volatility(T2, strike);
        return g1(barrier, strike, b) - vol * std::sqrt(T2);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::g3(Real barrier, Real strike, Rate b) const {
        Time T2 = residualTime();
        Real vol = volatility(T2, strike);
        return g1(barrier, strike, b) + (2 * std::log(barrier / underlying()) /(vol * std::sqrt(T2)));
    }

    Real AnalyticPartialTimeBarrierOptionEngine::g4(Real barrier, Real strike, Rate b) const {
        Time T2 = residualTime();
        Real vol = volatility(T2, strike);
        return g3(barrier, strike, b) - vol * std::sqrt(T2);
    }

    Real AnalyticPartialTimeBarrierOptionEngine::HS(Real S, Real H, Real power) const {
        return std::pow((H / S), power);
    }

}

]]></document_content>
  </document>
  <document index="21">
    <source>barrier/analyticsoftbarrierengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2025 William Day

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include <ql/exercise.hpp>
#include <ql/pricingengines/barrier/analyticsoftbarrierengine.hpp>
#include <ql/instruments/barrieroption.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <utility>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/pricingengines/barrier/analyticbarrierengine.hpp>
#include <iostream>


namespace QuantLib {

    AnalyticSoftBarrierEngine::AnalyticSoftBarrierEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }


    void AnalyticSoftBarrierEngine::calculate() const {

        // Market data
        Real S = underlying();
        Real X = strike();
        Rate r = riskFreeRate();
        Rate q = dividendYield();
        Volatility sigma = volatility();

        // Barrier parameters
        Real U = barrierHi();
        Real L = barrierLo();
        Barrier::Type barrierType = arguments_.barrierType;
        
        // Stability tweak for r and q
        const Real epsilon = 1e-6;  
        if (std::abs(r - q) < 1e-10) {
            r = q + epsilon;  // Avoids mu = 0.5 singularity
        }

        // Option parameters
        Time T = residualTime();
        ext::shared_ptr<PlainVanillaPayoff> payoff = ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff); 
        Option::Type optionType = payoff->optionType();
        Integer eta = (optionType == Option::Call ? 1 : -1);
        Rate b = r - q; // cost of carry

        validateInputs(S, X, r, q, T, U, L, optionType, barrierType, sigma);

        bool isKnockedIn = (barrierType == Barrier::DownIn && S <= L) || 
                          (barrierType == Barrier::UpIn && S >= U);
        bool isKnockedOut = (barrierType == Barrier::DownOut && S <= L) || 
                          (barrierType == Barrier::UpOut && S >= U);

        bool isSingleBarrier = (std::fabs(U - L) < 1e-4);  
        

        // edge case 1: fully knocked in options should be priced as vanilla (there are no more barrier features to consider)
        if (isKnockedIn) {
              results_.value = vanillaEquivalent();
              return;
            }

        // edge case 2: knocked out options are worthless
        else if (isKnockedOut) {   
            results_.value = 0.0;  
            return;
            }
        
        // edge case 3: Haug formula breaks when U=L, use single barrier option formula instead
        if (isSingleBarrier) {
            results_.value = standardBarrierEquivalent();
            return;
        }

        // soft barrier pricing logic
        Real w = knockInValue(S, X, r, sigma, T, U, L, b, optionType,eta);
        results_.value = (barrierType == Barrier::DownIn || barrierType == Barrier::UpIn)
            ? w                     // knock in price
            : vanillaEquivalent() - w;  // knock out price
        }
    

    // Implements the formula to calculate 'w' from the Haug textbook, used in soft barrier pricing
    Real AnalyticSoftBarrierEngine::knockInValue(Real S, Real X, Rate r, Volatility sigma, Time T,
                                                Real U, Real L, Real b, Option::Type optionType,
                                                Integer eta) const {
        // constant terms                                              
        const Real mu = (b + 0.5 * sigma * sigma) / (sigma * sigma);
        const Real sqrtT = std::sqrt(T);
        const Real lambda1 = std::exp(-0.5 * sigma * sigma * T * (mu + 0.5) * (mu - 0.5));
        const Real lambda2 = std::exp(-0.5 * sigma * sigma * T * (mu - 0.5) * (mu - 1.5));
        const Real SX = S * X;
        const Real logU2_SX = std::log((U * U) / SX);
        const Real logL2_SX = std::log((L * L) / SX);

        // d and e terms
        const Real d1 = logU2_SX / (sigma * sqrtT) + mu * sigma * sqrtT;
        const Real d2 = d1 - (mu + 0.5) * sigma * sqrtT;
        const Real d3 = logU2_SX / (sigma * sqrtT) + (mu - 1) * sigma * sqrtT;
        const Real d4 = d3 - (mu - 0.5) * sigma * sqrtT;

        const Real e1 = logL2_SX / (sigma * sqrtT) + mu * sigma * sqrtT;
        const Real e2 = e1 - (mu + 0.5) * sigma * sqrtT;
        const Real e3 = logL2_SX / (sigma * sqrtT) + (mu - 1) * sigma * sqrtT;
        const Real e4 = e3 - (mu - 0.5) * sigma * sqrtT;

        const Real Nd1 = f_(eta * d1);
        const Real Nd2 = f_(eta * d2);
        const Real Nd3 = f_(eta * d3);
        const Real Nd4 = f_(eta * d4);
        const Real Ne1 = f_(eta * e1);
        const Real Ne2 = f_(eta * e2);
        const Real Ne3 = f_(eta * e3);
        const Real Ne4 = f_(eta * e4);


        // term 1
        Real term1 = eta * S * std::exp((b - r) * T) * std::pow(S, -2.0 * mu)
            * std::pow(SX, mu + 0.5) / (2.0 * (mu + 0.5));


        term1 *= std::pow(U * U / SX, mu + 0.5) * Nd1 - lambda1 * Nd2
            - std::pow(L * L / SX, mu + 0.5) * Ne1 + lambda1 * Ne2;


        // term 2
        Real term2 = eta * X * std::exp(-r * T) * std::pow(S, -2.0 * (mu - 1))
            * std::pow(SX, mu - 0.5) / (2.0 * (mu - 0.5));


        term2 *= std::pow(U * U / SX, mu - 0.5) * Nd3 - lambda2 * Nd4
            - std::pow(L * L / SX, mu - 0.5) * Ne3 + lambda2 * Ne4;


        // final result
        Real w = (1.0 / (U - L)) * (term1 - term2);
        return w;
    }


    // helper function to check inputs are reasonable
    void AnalyticSoftBarrierEngine::validateInputs(Real S, Real X, Rate r, Rate q, Time T, Real U, Real L,
                                                   Option::Type optionType, Barrier::Type barrierType,
                                                   Real sigma) const {
        // Core Parameter checks                                                
        QL_REQUIRE(S > 0.0, "Spot price must be > 0");
        QL_REQUIRE(X > 0.0, "Strike price must be > 0");
        QL_REQUIRE(T > 0.0, "Option must have time to maturity > 0");
        QL_REQUIRE(sigma > 0, "Volatility must be > 0");
        QL_REQUIRE(optionType == Option::Call || optionType == Option::Put, "Invalid option type");                                       
        QL_REQUIRE(r <= 1.0 && r >= -0.05, "Interest rate must be between -5% and 100%");
        QL_REQUIRE(q <= 1.0 && q >= -0.1, "Dividend yield must be between -10% and 100%");

        
        // Barrier type checks
        QL_REQUIRE(
          barrierType == Barrier::DownIn ||
          barrierType == Barrier::DownOut ||
          barrierType == Barrier::UpIn ||
          barrierType == Barrier::UpOut,
          "Invalid barrier type");
        QL_REQUIRE(L != Null<Real>(), "no low barrier given");
        QL_REQUIRE(U != Null<Real>(), "no high barrier given");
        QL_REQUIRE(U > 0.0 && L > 0.0, "Barrier levels must be positive");
        QL_REQUIRE(U >= L, "Upper barrier must be greater than or equal to lower barrier");
        }
    

    // helper functions 
    Real AnalyticSoftBarrierEngine::underlying() const {
        return process_->x0();
    }

    Real AnalyticSoftBarrierEngine::strike() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff = ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);  
        QL_REQUIRE(payoff, "non-plain payoff given");
        return payoff->strike();
    }

    Time AnalyticSoftBarrierEngine::residualTime() const {
        return process_->time(arguments_.exercise->lastDate());
    }

    Volatility AnalyticSoftBarrierEngine::volatility() const {
        return process_->blackVolatility()->blackVol(residualTime(), strike());
    }

    Real AnalyticSoftBarrierEngine::stdDeviation() const {
        return volatility() * std::sqrt(residualTime());
    }

    Real AnalyticSoftBarrierEngine::barrierLo() const {
        return arguments_.barrier_lo;
    }

    Real AnalyticSoftBarrierEngine::barrierHi() const {
        return arguments_.barrier_hi;
    }

    Rate AnalyticSoftBarrierEngine::riskFreeRate() const {
        return process_->riskFreeRate()->zeroRate(residualTime(), Continuous, NoFrequency);
    }

    DiscountFactor AnalyticSoftBarrierEngine::riskFreeDiscount() const {
        return process_->riskFreeRate()->discount(residualTime());
    }

    Rate AnalyticSoftBarrierEngine::dividendYield() const {
        return process_->dividendYield()->zeroRate(residualTime(),Continuous, NoFrequency);
    }

    DiscountFactor AnalyticSoftBarrierEngine::dividendDiscount() const {
        return process_->dividendYield()->discount(residualTime());
    }
            

    Real AnalyticSoftBarrierEngine::vanillaEquivalent() const {
        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        Real forwardPrice = underlying() * dividendDiscount() / riskFreeDiscount();
        BlackCalculator black(payoff, forwardPrice, stdDeviation(), riskFreeDiscount());
        Real vanilla = black.value();
        return std::max(vanilla, 0.0);

    }       

    Real AnalyticSoftBarrierEngine::standardBarrierEquivalent() const {

    ext::shared_ptr<StrikedTypePayoff> payoff =
        ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
    QL_REQUIRE(payoff, "Payoff could not be cast to StrikedTypePayoff");

    BarrierOption tempOption(
        arguments_.barrierType,
        arguments_.barrier_hi,
        0.0,
        payoff,
        arguments_.exercise
    );

    Real spotVal = underlying();
    Real qVal = dividendYield();
    Real rVal = riskFreeRate();
    Volatility volVal = volatility();

    Handle<Quote> spot(ext::make_shared<SimpleQuote>(spotVal));
    Handle<YieldTermStructure> q(ext::make_shared<FlatForward>(0, TARGET(), qVal, Actual360()));
    Handle<YieldTermStructure> r(ext::make_shared<FlatForward>(0, TARGET(), rVal, Actual360()));
    Handle<BlackVolTermStructure> vol(ext::make_shared<BlackConstantVol>(0, TARGET(), volVal, Actual360()));


    ext::shared_ptr<GeneralizedBlackScholesProcess> process =
        ext::make_shared<GeneralizedBlackScholesProcess>(spot, q, r, vol);
    tempOption.setPricingEngine(ext::make_shared<AnalyticBarrierEngine>(process));

    Real npv = tempOption.NPV();
    Real result = std::max(npv, 0.0);
    return result;
}

}

]]></document_content>
  </document>
  <document index="22">
    <source>barrier/analytictwoassetbarrierengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/barrier/analytictwoassetbarrierengine.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <utility>

namespace QuantLib {

    AnalyticTwoAssetBarrierEngine::AnalyticTwoAssetBarrierEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
        Handle<Quote> rho)
    : process1_(std::move(process1)), process2_(std::move(process2)), rho_(std::move(rho)) {
        registerWith(process1_);
        registerWith(process2_);
        registerWith(rho_);
    }

    void AnalyticTwoAssetBarrierEngine::calculate() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        QL_REQUIRE(payoff->strike()>0.0,"strike must be positive");

        Real spot2 = process2_->x0();
        // option is triggered by S2
        QL_REQUIRE(spot2 > 0.0, "negative or null underlying given");
        QL_REQUIRE(!triggered(spot2), "barrier touched");

        Barrier::Type barrierType = arguments_.barrierType;

        switch (payoff->optionType()) {
          case Option::Call:
            switch (barrierType) {
              case Barrier::DownOut:
                results_.value = A(1,-1) +B(1,-1) ;
                break;
              case Barrier::UpOut:
                results_.value = A(1,1) + B(1,1) ;
                break;
              case Barrier::DownIn:
                results_.value = call()-(A(1,-1) +B(1,-1) );
                break;
              case Barrier::UpIn:
                results_.value = call()-(A(1,1) +B(1,1));
                break;
            }
            break;
          case Option::Put:
            switch (barrierType) {
              case Barrier::DownOut:
                results_.value = A(-1,-1)+B(-1,-1) ;
                break;
              case Barrier::UpOut:
                results_.value = A(-1,1)+B(-1,1) ;
                break;
              case Barrier::DownIn:
                results_.value = put()-(A(-1,-1) +B(-1,-1) );
                break;
              case Barrier::UpIn:
                results_.value = put()-(A(-1,1) +B(-1,1) );
                break;
            }
            break;
          default:
            QL_FAIL("unknown type");
        }
    }

    Real AnalyticTwoAssetBarrierEngine::underlying1() const {
        return process1_->x0();
    }

    Real AnalyticTwoAssetBarrierEngine::underlying2() const {
        return process2_->x0();
    }

    Real AnalyticTwoAssetBarrierEngine::strike() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        return payoff->strike();
    }

    Time AnalyticTwoAssetBarrierEngine::residualTime() const {
        return process1_->time(arguments_.exercise->lastDate());
    }

    Volatility AnalyticTwoAssetBarrierEngine::volatility1() const {
        return process1_->blackVolatility()->blackVol(residualTime(), strike());
    }

    Volatility AnalyticTwoAssetBarrierEngine::volatility2() const {
        return process2_->blackVolatility()->blackVol(residualTime(), strike());
    }

    Real AnalyticTwoAssetBarrierEngine::barrier() const {
        return arguments_.barrier;
    }

    Real AnalyticTwoAssetBarrierEngine::rho() const {
        return rho_->value();
    }

    Rate AnalyticTwoAssetBarrierEngine::riskFreeRate() const {
        return process1_->riskFreeRate()->zeroRate(residualTime(),
                                                   Continuous, NoFrequency);
    }


    Rate AnalyticTwoAssetBarrierEngine::dividendYield1() const {
        return process1_->dividendYield()->zeroRate(residualTime(),
                                                    Continuous, NoFrequency);
    }

    Rate AnalyticTwoAssetBarrierEngine::dividendYield2() const {
        return process2_->dividendYield()->zeroRate(residualTime(),
                                                    Continuous, NoFrequency);
    }

    Rate AnalyticTwoAssetBarrierEngine::costOfCarry1() const {
        return riskFreeRate() - dividendYield1();
    }

    Rate AnalyticTwoAssetBarrierEngine::costOfCarry2() const {
        return riskFreeRate() - dividendYield2();
    }

    Real AnalyticTwoAssetBarrierEngine::d1() const {
        return (std::log(underlying1()/strike())+(mu(costOfCarry1(),volatility1())+volatility1()*volatility1())*residualTime())/
            (volatility1()*std::sqrt(residualTime()));
    }

    Real AnalyticTwoAssetBarrierEngine::d2() const {
        return d1() - volatility1()*std::sqrt(residualTime());
    }

    Real AnalyticTwoAssetBarrierEngine::d3() const {
        return d1()+ (2*rho()*std::log(barrier()/underlying2()))/(volatility2()*std::sqrt(residualTime()));
    }

    Real AnalyticTwoAssetBarrierEngine::d4() const {
        return d2()+ (2*rho()*std::log(barrier()/underlying2()))/(volatility2()*std::sqrt(residualTime()));
    }

    Real AnalyticTwoAssetBarrierEngine::e1() const {
        return (std::log(barrier()/underlying2())-(mu(costOfCarry2(),volatility2())+rho()*volatility1()*volatility2())*residualTime())/
        (volatility2()*std::sqrt(residualTime()));
    }

    Real AnalyticTwoAssetBarrierEngine::e2() const {
         return e1()+rho()*volatility1()*std::sqrt(residualTime());
    }

    Real AnalyticTwoAssetBarrierEngine::e3() const {
            return e1()-(2*std::log(barrier()/underlying2()))/(volatility2()*std::sqrt(residualTime()));
    }

    Real AnalyticTwoAssetBarrierEngine::e4() const {
        return e2()-(2*std::log(barrier()/underlying2()))/(volatility2()*std::sqrt(residualTime()));
    }

    Real AnalyticTwoAssetBarrierEngine::mu(Real b, Real vol) const {
        return b-(vol*vol)/2;
    }

    Real AnalyticTwoAssetBarrierEngine::call() const {
        CumulativeNormalDistribution nd;
        return underlying1()*nd(d1())-strike()*std::exp(-riskFreeRate()*residualTime())*nd(d2());
    }

    Real AnalyticTwoAssetBarrierEngine::put() const {
        CumulativeNormalDistribution nd;
        return strike()*std::exp(-riskFreeRate()*residualTime())*nd(-d2())-underlying1()*nd(-d1());
    }

    Real AnalyticTwoAssetBarrierEngine::A(Real eta, Real phi) const {
        Real S1 = underlying1(), S2 = underlying2();
        Rate b1 = costOfCarry1(), b2 = costOfCarry2();
        Rate r = riskFreeRate();
        Time T = residualTime();
        Real H = barrier(), X = strike();
        Volatility sigma1 = volatility1(), sigma2 = volatility2();
        Real rho = rho_->value();

        Rate mu1 = b1 - sigma1*sigma1/2.0;
        Rate mu2 = b2 - sigma2*sigma2/2.0;

        Real d1 = (std::log(S1/X)+(mu1+sigma1*sigma1)*T)/
            (sigma1*std::sqrt(T));
        Real d2 = d1 - sigma1*std::sqrt(T);
        Real d3 = d1 + (2*rho*std::log(H/S2))/(sigma2*std::sqrt(T));
        Real d4 = d2 + (2*rho*std::log(H/S2))/(sigma2*std::sqrt(T));

        Real e1 = (std::log(H/S2)-(mu2+rho*sigma1*sigma2)*T)/
            (sigma2*std::sqrt(T));
        Real e2 = e1 + rho*sigma1*std::sqrt(T);
        Real e3 = e1 - (2*std::log(H/S2))/(sigma2*std::sqrt(T));
        Real e4 = e2 - (2*std::log(H/S2))/(sigma2*std::sqrt(T));

        Real w =
            eta*S1*std::exp((b1-r)*T) *
            (M(eta*d1, phi*e1,-eta*phi*rho)
             -std::exp((2*(mu2+rho*sigma1*sigma2)*std::log(H/S2))/(sigma2*sigma2))
             *M(eta*d3, phi*e3, -eta*phi*rho))

            - eta*X*std::exp(-r*T) *
            (M(eta*d2, phi*e2, -eta*phi*rho)
             -std::exp((2*mu2*std::log(H/S2))/(sigma2*sigma2))*
             M(eta*d4, phi*e4, -eta*phi*rho) ) ;

        return w;
    }

    Real AnalyticTwoAssetBarrierEngine::B(Real, Real) const {
        return 0.0;
    }

    Real AnalyticTwoAssetBarrierEngine::M(Real m_a, Real m_b, Real rho) const {
        BivariateCumulativeNormalDistributionDr78 f(rho);
        return f(m_a, m_b);
    }

}

]]></document_content>
  </document>
  <document index="23">
    <source>barrier/discretizedbarrieroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/barrier/discretizedbarrieroption.hpp>
#include <vector>

namespace QuantLib {

    DiscretizedBarrierOption::DiscretizedBarrierOption(
                                         const BarrierOption::arguments& args,
                                         const StochasticProcess& process,
                                         const TimeGrid& grid)
    : arguments_(args), vanilla_(arguments_, process, grid) {
        QL_REQUIRE(!args.exercise->dates().empty(), "specify at least one stopping date");

        stoppingTimes_.resize(args.exercise->dates().size());
        for (Size i=0; i<stoppingTimes_.size(); ++i) {
            stoppingTimes_[i] =
                process.time(args.exercise->date(i));
            if (!grid.empty()) {
                // adjust to the given grid
                stoppingTimes_[i] = grid.closestTime(stoppingTimes_[i]);
            }
        }
    }

    void DiscretizedBarrierOption::reset(Size size) {
        vanilla_.initialize(method(), time());
        values_ = Array(size, 0.0);
        adjustValues();
    }

    void DiscretizedBarrierOption::postAdjustValuesImpl() {
        if (arguments_.barrierType==Barrier::DownIn ||
                     arguments_.barrierType==Barrier::UpIn) {
            vanilla_.rollback(time());
        }
        Array grid = method()->grid(time());
        checkBarrier(values_, grid);
    }

    void DiscretizedBarrierOption::checkBarrier(Array &optvalues, const Array &grid) const {

        Time now = time();
        bool endTime = isOnTime(stoppingTimes_.back());
        bool stoppingTime = false;         
        switch (arguments_.exercise->type()) {
          case Exercise::American:
            if (now <= stoppingTimes_[1] &&
                now >= stoppingTimes_[0])
                stoppingTime = true;
            break;
          case Exercise::European:
            if (isOnTime(stoppingTimes_[0]))
                stoppingTime = true;
            break;
          case Exercise::Bermudan:
              for (Real i : stoppingTimes_) {
                  if (isOnTime(i)) {
                      stoppingTime = true;
                      break;
                  }
              }
            break;
          default:
            QL_FAIL("invalid option type");
        }
        for (Size j=0; j<optvalues.size(); j++) {
            switch (arguments_.barrierType) {
              case Barrier::DownIn:
                  if (grid[j] <= arguments_.barrier) {
                     // knocked in
                     if (stoppingTime) {
                        optvalues[j] = std::max(vanilla_.values()[j],
                                      (*arguments_.payoff)(grid[j]));
                     }
                     else
                         optvalues[j] = vanilla_.values()[j]; 
                  }
                  else if (endTime)
                      optvalues[j] = arguments_.rebate;
                  break;
              case Barrier::DownOut:
                  if (grid[j] <= arguments_.barrier)
                      optvalues[j] = arguments_.rebate; // knocked out
                  else if (stoppingTime) {
                      optvalues[j] = std::max(optvalues[j],
                                     (*arguments_.payoff)(grid[j]));
                  }
                  break;
              case Barrier::UpIn:
                  if (grid[j] >= arguments_.barrier) {
                     // knocked in
                     if (stoppingTime) {
                         optvalues[j] = std::max(vanilla_.values()[j],
                                      (*arguments_.payoff)(grid[j]));
                     }
                     else
                         optvalues[j] = vanilla_.values()[j]; 
                  }
                  else if (endTime)
                      optvalues[j] = arguments_.rebate;
                  break;
              case Barrier::UpOut:
                  if (grid[j] >= arguments_.barrier)
                     optvalues[j] = arguments_.rebate; // knocked out
                  else if (stoppingTime)
                      optvalues[j] = std::max(optvalues[j],
                                     (*arguments_.payoff)(grid[j]));
                  break;
              default:
                  QL_FAIL("invalid barrier type");
            }
        }
    }



    DiscretizedDermanKaniBarrierOption::DiscretizedDermanKaniBarrierOption(
                                         const BarrierOption::arguments& args,
                                         const StochasticProcess& process,
                                         const TimeGrid& grid)
    : unenhanced_(args, process, grid) {
    }

    void DiscretizedDermanKaniBarrierOption::reset(Size size) {
        unenhanced_.initialize(method(), time());
        values_ = Array(size, 0.0);
        adjustValues();
    }

    void DiscretizedDermanKaniBarrierOption::postAdjustValuesImpl() {
        unenhanced_.rollback(time());

        Array grid = method()->grid(time());
        adjustBarrier(values_, grid);
        unenhanced_.checkBarrier(values_, grid); // compute payoffs
    }

    void DiscretizedDermanKaniBarrierOption::adjustBarrier(Array &optvalues, const Array &grid) {
        Real barrier = unenhanced_.arguments().barrier;
        Real rebate = unenhanced_.arguments().rebate;
        switch (unenhanced_.arguments().barrierType) {
           case Barrier::DownIn:
              for (Size j=0; j<optvalues.size()-1; ++j) {
                  if (grid[j]<=barrier && grid[j+1] > barrier) {
                      // grid[j+1] above barrier, grid[j] under (in),
                      // interpolate optvalues[j+1]
                      Real ltob = (barrier-grid[j]);
                      Real htob = (grid[j+1]-barrier);
                      Real htol = (grid[j+1]-grid[j]);
                      Real u1 = unenhanced_.values()[j+1];
                      Real t1 = unenhanced_.vanilla()[j+1];
                      optvalues[j+1] = std::max(0.0, (ltob*t1+htob*u1)/htol);
                  }
              }
              break;
           case Barrier::DownOut:
              for (Size j=0; j<optvalues.size()-1; ++j) {
                  if (grid[j]<=barrier && grid[j+1] > barrier) {
                      // grid[j+1] above barrier, grid[j] under (out),
                      // interpolate optvalues[j+1]
                      Real a = (barrier-grid[j])*rebate;
                      Real b = (grid[j+1]-barrier)*unenhanced_.values()[j+1];
                      Real c = (grid[j+1]-grid[j]);
                      optvalues[j+1] = std::max(0.0, (a+b)/c);
                  }
              }
              break;
           case Barrier::UpIn:
              for (Size j=0; j<optvalues.size()-1; ++j) {
                  if (grid[j] < barrier && grid[j+1] >= barrier) {
                      // grid[j+1] above barrier (in), grid[j] under, 
                      // interpolate optvalues[j]
                      Real ltob = (barrier-grid[j]);
                      Real htob = (grid[j+1]-barrier);
                      Real htol = (grid[j+1]-grid[j]);
                      Real u = unenhanced_.values()[j];
                      Real t = unenhanced_.vanilla()[j];
                      optvalues[j] = std::max(0.0, (ltob*u+htob*t)/htol); // derman std
                  }
               }
              break;
           case Barrier::UpOut:
              for (Size j=0; j<optvalues.size()-1; ++j) {
                  if (grid[j] < barrier && grid[j+1] >= barrier) {
                      // grid[j+1] above barrier (out), grid[j] under, 
                      // interpolate optvalues[j]
                      Real a = (barrier-grid[j])*unenhanced_.values()[j];
                      Real b = (grid[j+1]-barrier)*rebate;
                      Real c = (grid[j+1]-grid[j]);
                      optvalues[j] = std::max(0.0, (a+b)/c);
                  }
              }
              break;
        }
    }

}

]]></document_content>
  </document>
  <document index="24">
    <source>barrier/fdblackscholesbarrierengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/methods/finitedifferences/meshers/fdmblackscholesmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/solvers/fdmblackscholessolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdirichletboundary.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdividendhandler.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/pricingengines/barrier/fdblackscholesbarrierengine.hpp>
#include <ql/pricingengines/barrier/fdblackscholesrebateengine.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesvanillaengine.hpp>
#include <utility>

namespace QuantLib {

    FdBlackScholesBarrierEngine::FdBlackScholesBarrierEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Size tGrid,
        Size xGrid,
        Size dampingSteps,
        const FdmSchemeDesc& schemeDesc,
        bool localVol,
        Real illegalLocalVolOverwrite)
    : process_(std::move(process)),
      tGrid_(tGrid), xGrid_(xGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), localVol_(localVol),
      illegalLocalVolOverwrite_(illegalLocalVolOverwrite) {

        registerWith(process_);
    }

    FdBlackScholesBarrierEngine::FdBlackScholesBarrierEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        DividendSchedule dividends,
        Size tGrid,
        Size xGrid,
        Size dampingSteps,
        const FdmSchemeDesc& schemeDesc,
        bool localVol,
        Real illegalLocalVolOverwrite)
    : process_(std::move(process)), dividends_(std::move(dividends)),
      tGrid_(tGrid), xGrid_(xGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), localVol_(localVol),
      illegalLocalVolOverwrite_(illegalLocalVolOverwrite) {

        registerWith(process_);
    }

    void FdBlackScholesBarrierEngine::calculate() const {

        // 1. Mesher
        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);

        QL_REQUIRE(payoff, "non-striked type payoff given");
        QL_REQUIRE(payoff->strike() > 0.0, "strike must be positive");

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "only european style option are supported");

        const auto spot = process_->x0();
        QL_REQUIRE(spot > 0.0, "negative or null underlying given");
        QL_REQUIRE(!triggered(spot), "barrier touched");

        const Time maturity = process_->time(arguments_.exercise->lastDate());

        Real xMin=Null<Real>();
        Real xMax=Null<Real>();
        if (   arguments_.barrierType == Barrier::DownIn
            || arguments_.barrierType == Barrier::DownOut) {
            xMin = std::log(arguments_.barrier);
        }
        if (   arguments_.barrierType == Barrier::UpIn
            || arguments_.barrierType == Barrier::UpOut) {
            xMax = std::log(arguments_.barrier);
        }

        const ext::shared_ptr<Fdm1dMesher> equityMesher(
            new FdmBlackScholesMesher(
                xGrid_, process_, maturity, payoff->strike(),
                xMin, xMax, 0.0001, 1.5,
                std::make_pair(Null<Real>(), Null<Real>()),
                dividends_));
        
        const ext::shared_ptr<FdmMesher> mesher (
            ext::make_shared<FdmMesherComposite>(equityMesher));

        // 2. Calculator
        ext::shared_ptr<FdmInnerValueCalculator> calculator(
            ext::make_shared<FdmLogInnerValue>(payoff, mesher, 0));

        // 3. Step conditions
        std::list<ext::shared_ptr<StepCondition<Array> > > stepConditions;
        std::list<std::vector<Time> > stoppingTimes;

        // 3.1 Step condition if discrete dividends
        ext::shared_ptr<FdmDividendHandler> dividendCondition(
            ext::make_shared<FdmDividendHandler>(dividends_, mesher,
                                   process_->riskFreeRate()->referenceDate(),
                                   process_->riskFreeRate()->dayCounter(), 0));

        if (!dividends_.empty()) {
            stepConditions.push_back(dividendCondition);
            std::vector<Time> dividendTimes = dividendCondition->dividendTimes();
            // this effectively excludes times after maturity
            for (auto& t: dividendTimes)
                t = std::min(maturity, t);
            stoppingTimes.push_back(dividendTimes);
        }

        ext::shared_ptr<FdmStepConditionComposite> conditions(
            ext::make_shared<FdmStepConditionComposite>(stoppingTimes, stepConditions));

        // 4. Boundary conditions
        FdmBoundaryConditionSet boundaries;
        if (   arguments_.barrierType == Barrier::DownIn
            || arguments_.barrierType == Barrier::DownOut) {
            boundaries.push_back(
                ext::make_shared<FdmDirichletBoundary>(mesher, arguments_.rebate, 0,
                                         FdmDirichletBoundary::Lower));

        }

        if (   arguments_.barrierType == Barrier::UpIn
            || arguments_.barrierType == Barrier::UpOut) {
            boundaries.push_back(
                ext::make_shared<FdmDirichletBoundary>(mesher, arguments_.rebate, 0,
                                         FdmDirichletBoundary::Upper));
        }

        // 5. Solver
        FdmSolverDesc solverDesc = { mesher, boundaries, conditions, calculator,
                                     maturity, tGrid_, dampingSteps_ };

        ext::shared_ptr<FdmBlackScholesSolver> solver(
            ext::make_shared<FdmBlackScholesSolver>(
                               Handle<GeneralizedBlackScholesProcess>(process_),
                               payoff->strike(), solverDesc, schemeDesc_,
                               localVol_, illegalLocalVolOverwrite_));

        results_.value = solver->valueAt(spot);
        results_.delta = solver->deltaAt(spot);
        results_.gamma = solver->gammaAt(spot);
        results_.theta = solver->thetaAt(spot);

        // 6. Calculate vanilla option and rebate for in-barriers
        if (   arguments_.barrierType == Barrier::DownIn
            || arguments_.barrierType == Barrier::UpIn) {
            // Cast the payoff
            ext::shared_ptr<StrikedTypePayoff> payoff =
                    ext::dynamic_pointer_cast<StrikedTypePayoff>(
                                                            arguments_.payoff);
            // Calculate the vanilla option
            
            VanillaOption vanillaOption(payoff, arguments_.exercise);
            
            vanillaOption.setPricingEngine(
                ext::make_shared<FdBlackScholesVanillaEngine>(
                        process_, dividends_, tGrid_, xGrid_,
                        0, // dampingSteps
                        schemeDesc_, localVol_, illegalLocalVolOverwrite_));

            // Calculate the rebate value
            BarrierOption rebateOption(arguments_.barrierType,
                                       arguments_.barrier,
                                       arguments_.rebate,
                                       payoff, arguments_.exercise);
            
            const Size min_grid_size = 50;
            const Size rebateDampingSteps 
                = (dampingSteps_ > 0) ? std::min(Size(1), dampingSteps_/2) : 0; 

            rebateOption.setPricingEngine(ext::make_shared<FdBlackScholesRebateEngine>(
                            process_, dividends_, tGrid_, std::max(min_grid_size, xGrid_/5), 
                            rebateDampingSteps, schemeDesc_, localVol_, 
                            illegalLocalVolOverwrite_));

            results_.value = vanillaOption.NPV()   + rebateOption.NPV()   - results_.value;
            results_.delta = vanillaOption.delta() + rebateOption.delta() - results_.delta;
            results_.gamma = vanillaOption.gamma() + rebateOption.gamma() - results_.gamma;
            results_.theta = vanillaOption.theta() + rebateOption.theta() - results_.theta;
        }
    }
}
]]></document_content>
  </document>
  <document index="25">
    <source>barrier/fdblackscholesrebateengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/methods/finitedifferences/meshers/fdmblackscholesmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/solvers/fdmblackscholessolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdirichletboundary.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/pricingengines/barrier/fdblackscholesrebateengine.hpp>
#include <utility>

namespace QuantLib {

    FdBlackScholesRebateEngine::FdBlackScholesRebateEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Size tGrid,
        Size xGrid,
        Size dampingSteps,
        const FdmSchemeDesc& schemeDesc,
        bool localVol,
        Real illegalLocalVolOverwrite)
    : process_(std::move(process)),
      tGrid_(tGrid), xGrid_(xGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), localVol_(localVol),
      illegalLocalVolOverwrite_(illegalLocalVolOverwrite) {

        registerWith(process_);
    }

    FdBlackScholesRebateEngine::FdBlackScholesRebateEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        DividendSchedule dividends,
        Size tGrid,
        Size xGrid,
        Size dampingSteps,
        const FdmSchemeDesc& schemeDesc,
        bool localVol,
        Real illegalLocalVolOverwrite)
    : process_(std::move(process)), dividends_(std::move(dividends)),
      tGrid_(tGrid), xGrid_(xGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), localVol_(localVol),
      illegalLocalVolOverwrite_(illegalLocalVolOverwrite) {

        registerWith(process_);
    }

    void FdBlackScholesRebateEngine::calculate() const {

        // 1. Mesher
        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        const Time maturity = process_->time(arguments_.exercise->lastDate());

        Real xMin=Null<Real>();
        Real xMax=Null<Real>();
        if (   arguments_.barrierType == Barrier::DownIn
            || arguments_.barrierType == Barrier::DownOut) {
            xMin = std::log(arguments_.barrier);
        }
        if (   arguments_.barrierType == Barrier::UpIn
            || arguments_.barrierType == Barrier::UpOut) {
            xMax = std::log(arguments_.barrier);
        }

        const ext::shared_ptr<Fdm1dMesher> equityMesher(
            new FdmBlackScholesMesher(
                xGrid_, process_, maturity, payoff->strike(),
                xMin, xMax, 0.0001, 1.5,
                std::make_pair(Null<Real>(), Null<Real>()),
                dividends_));
        
        const ext::shared_ptr<FdmMesher> mesher (
            new FdmMesherComposite(equityMesher));
        
        // 2. Calculator
        const ext::shared_ptr<StrikedTypePayoff> rebatePayoff(
                new CashOrNothingPayoff(Option::Call, 0.0, arguments_.rebate));
        const ext::shared_ptr<FdmInnerValueCalculator> calculator(
                                new FdmLogInnerValue(rebatePayoff, mesher, 0));

        // 3. Step conditions
        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "only european style option are supported");
        
        const ext::shared_ptr<FdmStepConditionComposite> conditions =
            FdmStepConditionComposite::vanillaComposite(
                                dividends_, arguments_.exercise, 
                                mesher, calculator, 
                                process_->riskFreeRate()->referenceDate(),
                                process_->riskFreeRate()->dayCounter());

        // 4. Boundary conditions
        FdmBoundaryConditionSet  boundaries;
        if (   arguments_.barrierType == Barrier::DownIn
            || arguments_.barrierType == Barrier::DownOut) {
            boundaries.push_back(FdmBoundaryConditionSet::value_type(
                new FdmDirichletBoundary(mesher, arguments_.rebate, 0,
                                         FdmDirichletBoundary::Lower)));

        }
        if (   arguments_.barrierType == Barrier::UpIn
            || arguments_.barrierType == Barrier::UpOut) {
            boundaries.push_back(FdmBoundaryConditionSet::value_type(
                new FdmDirichletBoundary(mesher, arguments_.rebate, 0,
                                         FdmDirichletBoundary::Upper)));
        }

        // 5. Solver
        FdmSolverDesc solverDesc = { mesher, boundaries, conditions, calculator,
                                     maturity, tGrid_, dampingSteps_ };

        const ext::shared_ptr<FdmBlackScholesSolver> solver(
                new FdmBlackScholesSolver(
                                Handle<GeneralizedBlackScholesProcess>(process_),
                                payoff->strike(), solverDesc, schemeDesc_,
                                localVol_, illegalLocalVolOverwrite_));

        const Real spot = process_->x0();
        results_.value = solver->valueAt(spot);
        results_.delta = solver->deltaAt(spot);
        results_.gamma = solver->gammaAt(spot);
        results_.theta = solver->thetaAt(spot);
    }
}
]]></document_content>
  </document>
  <document index="26">
    <source>barrier/fdhestonbarrierengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/meshers/fdmblackscholesmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmhestonvariancemesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdirichletboundary.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdividendhandler.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/pricingengines/barrier/fdhestonbarrierengine.hpp>
#include <ql/pricingengines/barrier/fdhestonrebateengine.hpp>
#include <ql/pricingengines/vanilla/fdhestonvanillaengine.hpp>
#include <utility>

namespace QuantLib {

    FdHestonBarrierEngine::FdHestonBarrierEngine(const ext::shared_ptr<HestonModel>& model,
                                                 Size tGrid,
                                                 Size xGrid,
                                                 Size vGrid,
                                                 Size dampingSteps,
                                                 const FdmSchemeDesc& schemeDesc,
                                                 ext::shared_ptr<LocalVolTermStructure> leverageFct,
                                                 const Real mixingFactor)
    : GenericModelEngine<HestonModel,
                         BarrierOption::arguments,
                         BarrierOption::results>(model),
      tGrid_(tGrid), xGrid_(xGrid), vGrid_(vGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), leverageFct_(std::move(leverageFct)), mixingFactor_(mixingFactor) {}

    FdHestonBarrierEngine::FdHestonBarrierEngine(const ext::shared_ptr<HestonModel>& model,
                                                 DividendSchedule dividends,
                                                 Size tGrid,
                                                 Size xGrid,
                                                 Size vGrid,
                                                 Size dampingSteps,
                                                 const FdmSchemeDesc& schemeDesc,
                                                 ext::shared_ptr<LocalVolTermStructure> leverageFct,
                                                 const Real mixingFactor)
    : GenericModelEngine<HestonModel,
                         BarrierOption::arguments,
                         BarrierOption::results>(model),
      dividends_(std::move(dividends)),
      tGrid_(tGrid), xGrid_(xGrid), vGrid_(vGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), leverageFct_(std::move(leverageFct)), mixingFactor_(mixingFactor) {}

    void FdHestonBarrierEngine::calculate() const {

        // 1. Mesher
        const ext::shared_ptr<HestonProcess>& process = model_->process();
        const Time maturity = process->time(arguments_.exercise->lastDate());

        // 1.1 The variance mesher
        const Size tGridMin = 5;
        const Size tGridAvgSteps = std::max(tGridMin, tGrid_/50);

        const ext::shared_ptr<FdmHestonLocalVolatilityVarianceMesher> vMesher
            = ext::make_shared<FdmHestonLocalVolatilityVarianceMesher>(
                  vGrid_, process, leverageFct_, maturity, tGridAvgSteps, 0.0001, mixingFactor_);

        // 1.2 The equity mesher
        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);

        Real xMin=Null<Real>();
        Real xMax=Null<Real>();
        if (   arguments_.barrierType == Barrier::DownIn
            || arguments_.barrierType == Barrier::DownOut) {
            xMin = std::log(arguments_.barrier);
        }
        if (   arguments_.barrierType == Barrier::UpIn
            || arguments_.barrierType == Barrier::UpOut) {
            xMax = std::log(arguments_.barrier);
        }

        const ext::shared_ptr<Fdm1dMesher> equityMesher(
            new FdmBlackScholesMesher(
                xGrid_,
                FdmBlackScholesMesher::processHelper(
                    process->s0(), process->dividendYield(),
                    process->riskFreeRate(), vMesher->volaEstimate()),
                maturity, payoff->strike(),
                xMin, xMax, 0.0001, 1.5,
                std::make_pair(Null<Real>(), Null<Real>()),
                dividends_));

        const ext::shared_ptr<FdmMesher> mesher (
			ext::make_shared<FdmMesherComposite>(equityMesher, vMesher));

        // 2. Calculator
        ext::shared_ptr<FdmInnerValueCalculator> calculator(
			ext::make_shared<FdmLogInnerValue>(payoff, mesher, 0));

        // 3. Step conditions
        std::list<ext::shared_ptr<StepCondition<Array> > > stepConditions;
        std::list<std::vector<Time> > stoppingTimes;

        // 3.1 Step condition if discrete dividends
        ext::shared_ptr<FdmDividendHandler> dividendCondition(
			ext::make_shared<FdmDividendHandler>(dividends_, mesher,
                                   process->riskFreeRate()->referenceDate(),
                                   process->riskFreeRate()->dayCounter(), 0));

        if (!dividends_.empty()) {
            stepConditions.push_back(dividendCondition);
            std::vector<Time> dividendTimes = dividendCondition->dividendTimes();
            // this effectively excludes times after maturity
            for (auto& t: dividendTimes)
                t = std::min(maturity, t);
            stoppingTimes.push_back(dividendTimes);
        }

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "only european style option are supported");

        ext::shared_ptr<FdmStepConditionComposite> conditions(
			ext::make_shared<FdmStepConditionComposite>(stoppingTimes, stepConditions));

        // 4. Boundary conditions
        FdmBoundaryConditionSet boundaries;
        if (   arguments_.barrierType == Barrier::DownIn
            || arguments_.barrierType == Barrier::DownOut) {
            boundaries.push_back(
				ext::make_shared<FdmDirichletBoundary>(mesher, arguments_.rebate, 0,
                                         FdmDirichletBoundary::Lower));

        }
        if (   arguments_.barrierType == Barrier::UpIn
            || arguments_.barrierType == Barrier::UpOut) {
            boundaries.push_back(
				ext::make_shared<FdmDirichletBoundary>(mesher, arguments_.rebate, 0,
                                         FdmDirichletBoundary::Upper));
        }

        // 5. Solver
        FdmSolverDesc solverDesc = { mesher, boundaries, conditions,
                                     calculator, maturity,
                                     tGrid_, dampingSteps_ };

        ext::shared_ptr<FdmHestonSolver> solver(ext::make_shared<FdmHestonSolver>(
                    Handle<HestonProcess>(process), solverDesc, schemeDesc_,
                    Handle<FdmQuantoHelper>(), leverageFct_, mixingFactor_));

        const Real spot = process->s0()->value();
        results_.value = solver->valueAt(spot, process->v0());
        results_.delta = solver->deltaAt(spot, process->v0());
        results_.gamma = solver->gammaAt(spot, process->v0());
        results_.theta = solver->thetaAt(spot, process->v0());

        // 6. Calculate vanilla option and rebate for in-barriers
        if (   arguments_.barrierType == Barrier::DownIn
            || arguments_.barrierType == Barrier::UpIn) {
            // Cast the payoff
            ext::shared_ptr<StrikedTypePayoff> payoff =
                    ext::dynamic_pointer_cast<StrikedTypePayoff>(
                                                            arguments_.payoff);
            // Calculate the vanilla option
            VanillaOption vanillaOption(payoff, arguments_.exercise);
            vanillaOption.setPricingEngine(ext::shared_ptr<PricingEngine>(
				ext::make_shared<FdHestonVanillaEngine>(*model_, dividends_,
                                                        tGrid_, xGrid_,
                                                        vGrid_, dampingSteps_,
                                                        schemeDesc_)));
            // Calculate the rebate value
            BarrierOption rebateOption(arguments_.barrierType,
                                       arguments_.barrier,
                                       arguments_.rebate,
                                       payoff, arguments_.exercise);
            const Size xGridMin = 20;
            const Size vGridMin = 10;
            const Size rebateDampingSteps 
                = (dampingSteps_ > 0) ? std::min(Size(1), dampingSteps_/2) : 0; 
            rebateOption.setPricingEngine(
                ext::make_shared<FdHestonRebateEngine>(*model_, dividends_,
                                                       tGrid_,
                                                       std::max(xGridMin, xGrid_/4), 
                                                       std::max(vGridMin, vGrid_/4),
                                                       rebateDampingSteps,
                                                       schemeDesc_));

            results_.value = vanillaOption.NPV()   + rebateOption.NPV()   - results_.value;
            results_.delta = vanillaOption.delta() + rebateOption.delta() - results_.delta;
            results_.gamma = vanillaOption.gamma() + rebateOption.gamma() - results_.gamma;
            results_.theta = vanillaOption.theta() + rebateOption.theta() - results_.theta;
        }
    }
}
]]></document_content>
  </document>
  <document index="27">
    <source>barrier/fdhestondoublebarrierengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/meshers/fdmblackscholesmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmhestonvariancemesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdirichletboundary.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdividendhandler.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/pricingengines/barrier/fdhestonrebateengine.hpp>
#include <ql/pricingengines/barrier/fdhestondoublebarrierengine.hpp>
#include <ql/pricingengines/vanilla/fdhestonvanillaengine.hpp>
#include <utility>

namespace QuantLib {

    FdHestonDoubleBarrierEngine::FdHestonDoubleBarrierEngine(
        const ext::shared_ptr<HestonModel>& model,
        Size tGrid,
        Size xGrid,
        Size vGrid,
        Size dampingSteps,
        const FdmSchemeDesc& schemeDesc,
        ext::shared_ptr<LocalVolTermStructure> leverageFct,
        const Real mixingFactor)
    : GenericModelEngine<HestonModel, DoubleBarrierOption::arguments, DoubleBarrierOption::results>(
          model),
      tGrid_(tGrid), xGrid_(xGrid), vGrid_(vGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), leverageFct_(std::move(leverageFct)), mixingFactor_(mixingFactor) {}

    void FdHestonDoubleBarrierEngine::calculate() const {

        QL_REQUIRE(arguments_.barrierType == DoubleBarrier::KnockOut,
                "only Knock-Out double barrier options are supported");

        // 1. Mesher
        const ext::shared_ptr<HestonProcess>& process = model_->process();
        const Time maturity = process->time(arguments_.exercise->lastDate());

        // 1.1 The variance mesher
        const Size tGridMin = 5;
        const Size tGridAvgSteps = std::max(tGridMin, tGrid_/50);

        const ext::shared_ptr<FdmHestonLocalVolatilityVarianceMesher> vMesher
            = ext::make_shared<FdmHestonLocalVolatilityVarianceMesher>(
                  vGrid_, process, leverageFct_, maturity, tGridAvgSteps, 0.0001, mixingFactor_);

        // 1.2 The equity mesher
        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);

        Real xMin = std::log(arguments_.barrier_lo);
        Real xMax = std::log(arguments_.barrier_hi);

        const ext::shared_ptr<Fdm1dMesher> equityMesher(
            new FdmBlackScholesMesher(
                xGrid_,
                FdmBlackScholesMesher::processHelper(
                    process->s0(), process->dividendYield(),
                    process->riskFreeRate(), vMesher->volaEstimate()),
                maturity, payoff->strike(), xMin, xMax));

        const ext::shared_ptr<FdmMesher> mesher (
            new FdmMesherComposite(equityMesher, vMesher));

        // 2. Calculator
        const ext::shared_ptr<FdmInnerValueCalculator> calculator(
                                new FdmLogInnerValue(payoff, mesher, 0));

        // 3. Step conditions
        std::list<ext::shared_ptr<StepCondition<Array> > > stepConditions;
        std::list<std::vector<Time> > stoppingTimes;

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "only european style option are supported");

        ext::shared_ptr<FdmStepConditionComposite> conditions(
                new FdmStepConditionComposite(stoppingTimes, stepConditions));

        // 4. Boundary conditions
        FdmBoundaryConditionSet boundaries;
        boundaries.push_back(FdmBoundaryConditionSet::value_type(
            new FdmDirichletBoundary(mesher, arguments_.rebate, 0,
                                     FdmDirichletBoundary::Lower)));

        boundaries.push_back(FdmBoundaryConditionSet::value_type(
            new FdmDirichletBoundary(mesher, arguments_.rebate, 0,
                                     FdmDirichletBoundary::Upper)));

        // 5. Solver
        FdmSolverDesc solverDesc = { mesher, boundaries, conditions,
                                     calculator, maturity,
                                     tGrid_, dampingSteps_ };

        ext::shared_ptr<FdmHestonSolver> solver(new FdmHestonSolver(
                    Handle<HestonProcess>(process), solverDesc, schemeDesc_,
                    Handle<FdmQuantoHelper>(), leverageFct_, mixingFactor_));

        const Real spot = process->s0()->value();
        results_.value = solver->valueAt(spot, process->v0());
        results_.delta = solver->deltaAt(spot, process->v0());
        results_.gamma = solver->gammaAt(spot, process->v0());
        results_.theta = solver->thetaAt(spot, process->v0());
    }
}
]]></document_content>
  </document>
  <document index="28">
    <source>barrier/fdhestonrebateengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/meshers/fdmblackscholesmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmhestonvariancemesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdirichletboundary.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/pricingengines/barrier/fdhestonrebateengine.hpp>
#include <utility>

namespace QuantLib {

    QL_DEPRECATED_DISABLE_WARNING

    FdHestonRebateEngine::FdHestonRebateEngine(const ext::shared_ptr<HestonModel>& model,
                                               Size tGrid,
                                               Size xGrid,
                                               Size vGrid,
                                               Size dampingSteps,
                                               const FdmSchemeDesc& schemeDesc,
                                               ext::shared_ptr<LocalVolTermStructure> leverageFct,
                                               const Real mixingFactor)
    : GenericModelEngine<HestonModel,
                         BarrierOption::arguments,
                         BarrierOption::results>(model),
      tGrid_(tGrid), xGrid_(xGrid), vGrid_(vGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), leverageFct_(std::move(leverageFct)), mixingFactor_(mixingFactor) {}

    FdHestonRebateEngine::FdHestonRebateEngine(const ext::shared_ptr<HestonModel>& model,
                                               DividendSchedule dividends,
                                               Size tGrid,
                                               Size xGrid,
                                               Size vGrid,
                                               Size dampingSteps,
                                               const FdmSchemeDesc& schemeDesc,
                                               ext::shared_ptr<LocalVolTermStructure> leverageFct,
                                               const Real mixingFactor)
    : GenericModelEngine<HestonModel,
                         BarrierOption::arguments,
                         BarrierOption::results>(model),
      dividends_(std::move(dividends)),
      tGrid_(tGrid), xGrid_(xGrid), vGrid_(vGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), leverageFct_(std::move(leverageFct)), mixingFactor_(mixingFactor) {}

    QL_DEPRECATED_ENABLE_WARNING

    void FdHestonRebateEngine::calculate() const {

        // 1. Mesher
        const ext::shared_ptr<HestonProcess>& process = model_->process();
        const Time maturity = process->time(arguments_.exercise->lastDate());

        // 1.1 The variance mesher
        const Size tGridMin = 5;
        const Size tGridAvgSteps = std::max(tGridMin, tGrid_/50);

        const ext::shared_ptr<FdmHestonLocalVolatilityVarianceMesher> vMesher
            = ext::make_shared<FdmHestonLocalVolatilityVarianceMesher>(
                  vGrid_, process, leverageFct_, maturity, tGridAvgSteps, 0.0001, mixingFactor_);

        // 1.2 The equity mesher
        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);

        Real xMin=Null<Real>();
        Real xMax=Null<Real>();
        if (   arguments_.barrierType == Barrier::DownIn
            || arguments_.barrierType == Barrier::DownOut) {
            xMin = std::log(arguments_.barrier);
        }
        if (   arguments_.barrierType == Barrier::UpIn
            || arguments_.barrierType == Barrier::UpOut) {
            xMax = std::log(arguments_.barrier);
        }

        const ext::shared_ptr<Fdm1dMesher> equityMesher(
            new FdmBlackScholesMesher(
                xGrid_,
                FdmBlackScholesMesher::processHelper(
                    process->s0(), process->dividendYield(),
                    process->riskFreeRate(), vMesher->volaEstimate()),
                maturity, payoff->strike(),
                xMin, xMax, 0.0001, 1.5,
                std::make_pair(Null<Real>(), Null<Real>()),
                dividends_));

        const ext::shared_ptr<FdmMesher> mesher (
            new FdmMesherComposite(equityMesher, vMesher));

        // 2. Calculator
        const ext::shared_ptr<StrikedTypePayoff> rebatePayoff(
                new CashOrNothingPayoff(Option::Call, 0.0, arguments_.rebate));
        const ext::shared_ptr<FdmInnerValueCalculator> calculator(
                                new FdmLogInnerValue(rebatePayoff, mesher, 0));

        // 3. Step conditions
        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "only european style option are supported");

        const ext::shared_ptr<FdmStepConditionComposite> conditions = 
             FdmStepConditionComposite::vanillaComposite(
                                 dividends_, arguments_.exercise, 
                                 mesher, calculator, 
                                 process->riskFreeRate()->referenceDate(),
                                 process->riskFreeRate()->dayCounter());

        // 4. Boundary conditions
        FdmBoundaryConditionSet boundaries;
        if (   arguments_.barrierType == Barrier::DownIn
            || arguments_.barrierType == Barrier::DownOut) {
            boundaries.push_back(FdmBoundaryConditionSet::value_type(
                new FdmDirichletBoundary(mesher, arguments_.rebate, 0,
                                         FdmDirichletBoundary::Lower)));

        }
        if (   arguments_.barrierType == Barrier::UpIn
            || arguments_.barrierType == Barrier::UpOut) {
            boundaries.push_back(FdmBoundaryConditionSet::value_type(
                new FdmDirichletBoundary(mesher, arguments_.rebate, 0,
                                         FdmDirichletBoundary::Upper)));
        }

        // 5. Solver
        FdmSolverDesc solverDesc = { mesher, boundaries, conditions,
                                     calculator, maturity,
                                     tGrid_, dampingSteps_ };

        ext::shared_ptr<FdmHestonSolver> solver(new FdmHestonSolver(
                    Handle<HestonProcess>(process), solverDesc, schemeDesc_,
                    Handle<FdmQuantoHelper>(), leverageFct_, mixingFactor_));

        const Real spot = process->s0()->value();
        results_.value = solver->valueAt(spot, process->v0());
        results_.delta = solver->deltaAt(spot, process->v0());
        results_.gamma = solver->gammaAt(spot, process->v0());
        results_.theta = solver->thetaAt(spot, process->v0());
    }
}
]]></document_content>
  </document>
  <document index="29">
    <source>barrier/mcbarrierengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Neil Firth
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2003, 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/barrier/mcbarrierengine.hpp>
#include <utility>

namespace QuantLib {

    BarrierPathPricer::BarrierPathPricer(Barrier::Type barrierType,
                                         Real barrier,
                                         Real rebate,
                                         Option::Type type,
                                         Real strike,
                                         std::vector<DiscountFactor> discounts,
                                         ext::shared_ptr<StochasticProcess1D> diffProcess,
                                         PseudoRandom::ursg_type sequenceGen)
    : barrierType_(barrierType), barrier_(barrier), rebate_(rebate),
      diffProcess_(std::move(diffProcess)), sequenceGen_(std::move(sequenceGen)),
      payoff_(type, strike), discounts_(std::move(discounts)) {
        QL_REQUIRE(strike>=0.0,
                   "strike less than zero not allowed");
        QL_REQUIRE(barrier>0.0,
                   "barrier less/equal zero not allowed");
    }


    Real BarrierPathPricer::operator()(const Path& path) const {
        static Size null = Null<Size>();
        Size n = path.length();
        QL_REQUIRE(n>1, "the path cannot be empty");

        bool isOptionActive = false;
        Size knockNode = null;
        Real asset_price = path.front();
        Real new_asset_price;
        Real x, y;
        Volatility vol;
        const TimeGrid& timeGrid = path.timeGrid();
        Time dt;
        std::vector<Real> u = sequenceGen_.nextSequence().value;
        Size i;

        switch (barrierType_) {
          case Barrier::DownIn:
            isOptionActive = false;
            for (i = 0; i < n-1; i++) {
                new_asset_price = path[i+1];
                // terminal or initial vol?
                vol = diffProcess_->diffusion(timeGrid[i],asset_price);
                dt = timeGrid.dt(i);

                x = std::log(new_asset_price / asset_price);
                y = 0.5*(x - std::sqrt (x*x - 2*vol*vol*dt*std::log(u[i])));
                y = asset_price * std::exp(y);
                if (y <= barrier_) {
                    isOptionActive = true;
                    if (knockNode == null)
                        knockNode = i+1;
                }
                asset_price = new_asset_price;
            }
            break;
          case Barrier::UpIn:
            isOptionActive = false;
            for (i = 0; i < n-1; i++) {
                new_asset_price = path[i+1];
                // terminal or initial vol?
                vol = diffProcess_->diffusion(timeGrid[i],asset_price);
                dt = timeGrid.dt(i);

                x = std::log(new_asset_price / asset_price);
                y = 0.5*(x + std::sqrt(x*x - 2*vol*vol*dt*std::log((1-u[i]))));
                y = asset_price * std::exp(y);
                if (y >= barrier_) {
                    isOptionActive = true;
                    if (knockNode == null)
                        knockNode = i+1;
                }
                asset_price = new_asset_price;
            }
            break;
          case Barrier::DownOut:
            isOptionActive = true;
            for (i = 0; i < n-1; i++) {
                new_asset_price = path[i+1];
                // terminal or initial vol?
                vol = diffProcess_->diffusion(timeGrid[i],asset_price);
                dt = timeGrid.dt(i);

                x = std::log(new_asset_price / asset_price);
                y = 0.5*(x - std::sqrt(x*x - 2*vol*vol*dt*std::log(u[i])));
                y = asset_price * std::exp(y);
                if (y <= barrier_) {
                    isOptionActive = false;
                    if (knockNode == null)
                        knockNode = i+1;
                }
                asset_price = new_asset_price;
            }
            break;
          case Barrier::UpOut:
            isOptionActive = true;
            for (i = 0; i < n-1; i++) {
                new_asset_price = path[i+1];
                // terminal or initial vol?
                vol = diffProcess_->diffusion(timeGrid[i],asset_price);
                dt = timeGrid.dt(i);

                x = std::log(new_asset_price / asset_price);
                y = 0.5*(x + std::sqrt(x*x - 2*vol*vol*dt*std::log((1-u[i]))));
                y = asset_price * std::exp(y);
                if (y >= barrier_) {
                    isOptionActive = false;
                    if (knockNode == null)
                        knockNode = i+1;
                }
                asset_price = new_asset_price;
            }
            break;
          default:
            QL_FAIL("unknown barrier type");
        }

        if (isOptionActive) {
            return payoff_(asset_price) * discounts_.back();
        } else {
            switch (barrierType_) {
              case Barrier::UpIn:
              case Barrier::DownIn:
                return rebate_*discounts_.back();
              case Barrier::UpOut:
              case Barrier::DownOut:
                return rebate_*discounts_[knockNode];
              default:
                QL_FAIL("unknown barrier type");
            }
        }
    }


    BiasedBarrierPathPricer::BiasedBarrierPathPricer(Barrier::Type barrierType,
                                                     Real barrier,
                                                     Real rebate,
                                                     Option::Type type,
                                                     Real strike,
                                                     std::vector<DiscountFactor> discounts)
    : barrierType_(barrierType), barrier_(barrier), rebate_(rebate), payoff_(type, strike),
      discounts_(std::move(discounts)) {
        QL_REQUIRE(strike>=0.0,
                   "strike less than zero not allowed");
        QL_REQUIRE(barrier>0.0,
                   "barrier less/equal zero not allowed");
    }


    Real BiasedBarrierPathPricer::operator()(const Path& path) const {
        static Size null = Null<Size>();
        Size n = path.length();
        QL_REQUIRE(n>1, "the path cannot be empty");

        bool isOptionActive = false;
        Size knockNode = null;
        Real asset_price = path.front();
        Size i;

        switch (barrierType_) {
          case Barrier::DownIn:
            isOptionActive = false;
            for (i = 1; i < n; i++) {
                asset_price = path[i];
                if (asset_price <= barrier_) {
                    isOptionActive = true;
                    if (knockNode == null)
                        knockNode = i;
                }
            }
            break;
          case Barrier::UpIn:
            isOptionActive = false;
            for (i = 1; i < n; i++) {
                asset_price = path[i];
                if (asset_price >= barrier_) {
                    isOptionActive = true;
                    if (knockNode == null)
                        knockNode = i;
                }
            }
            break;
          case Barrier::DownOut:
            isOptionActive = true;
            for (i = 1; i < n; i++) {
                asset_price = path[i];
                if (asset_price <= barrier_) {
                    isOptionActive = false;
                    if (knockNode == null)
                        knockNode = i;
                }
            }
            break;
          case Barrier::UpOut:
            isOptionActive = true;
            for (i = 1; i < n; i++) {
                asset_price = path[i];
                if (asset_price >= barrier_) {
                    isOptionActive = false;
                    if (knockNode == null)
                        knockNode = i;
                }
            }
            break;
          default:
            QL_FAIL("unknown barrier type");
        }

        if (isOptionActive) {
            return payoff_(asset_price) * discounts_.back();
        } else {
            switch (barrierType_) {
              case Barrier::UpIn:
              case Barrier::DownIn:
                return rebate_*discounts_.back();
              case Barrier::UpOut:
              case Barrier::DownOut:
                return rebate_*discounts_[knockNode];
              default:
                QL_FAIL("unknown barrier type");
            }
        }
    }

}
]]></document_content>
  </document>
  <document index="30">
    <source>basket/bjerksundstenslandspreadengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2024 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/basket/bjerksundstenslandspreadengine.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <utility>

namespace QuantLib {

    BjerksundStenslandSpreadEngine::BjerksundStenslandSpreadEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
        Real correlation)
    : SpreadBlackScholesVanillaEngine(std::move(process1), std::move(process2), correlation) {
    }

    Real BjerksundStenslandSpreadEngine::calculate(
        Real f1, Real f2, Real k, Option::Type optionType,
        Real variance1, Real variance2, DiscountFactor df) const {

        const Real cp = (optionType == Option::Call) ? 1 : -1;

        const Real a = f2 + k;
        const Real b = f2/a;

        const Real sigma1 = std::sqrt(variance1);
        const Real sigma2 = std::sqrt(variance2);

        const Real stdev = std::sqrt(
            variance1 + b*b*variance2 - 2*rho_*b*sigma1*sigma2);

        const Real lfa = std::log(f1/a);

        const Real d1 =
            (lfa + (0.5*variance1 + 0.5*b*b*variance2 - b*rho_*sigma1*sigma2))/stdev;
        const Real d2 =
            (lfa + (-0.5*variance1 + variance2*b*(0.5*b - 1) + rho_*sigma1*sigma2))/stdev;
        const Real d3 = (lfa + (-0.5*variance1 + 0.5*b*b*variance2))/stdev;

        const CumulativeNormalDistribution phi;
        return df*cp*(f1*phi(cp*d1) - f2*phi(cp*d2) - k*phi(cp*d3));
    }
}


]]></document_content>
  </document>
  <document index="31">
    <source>basket/choibasketengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2024 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file choibasketengine.cpp
*/

#include <ql/exercise.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/math/matrixutilities/svd.hpp>
#include <ql/math/matrixutilities/householder.hpp>
#include <ql/math/matrixutilities/getcovariance.hpp>
#include <ql/math/matrixutilities/choleskydecomposition.hpp>
#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/pricingengines/basket/choibasketengine.hpp>
#include <ql/pricingengines/basket/vectorbsmprocessextractor.hpp>
#include <ql/pricingengines/basket/singlefactorbsmbasketengine.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>

#include <boost/math/special_functions/sign.hpp>

namespace QuantLib {

    ChoiBasketEngine::ChoiBasketEngine(
        std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > processes,
        Matrix rho, Real lambda,
        Size maxNrIntegrationSteps,
        bool calcFwdDelta, bool controlVariate)
    : n_(processes.size()),
      processes_(std::move(processes)),
      rho_(std::move(rho)),
      lambda_(lambda),
      maxNrIntegrationSteps_(maxNrIntegrationSteps),
      calcFwdDelta_(calcFwdDelta || controlVariate),
      controlVariate_(controlVariate) {

        QL_REQUIRE(n_ > 0, "No Black-Scholes process is given.");
        QL_REQUIRE(n_ == rho_.size1() && rho_.size1() == rho_.size2(),
            "process and correlation matrix must have the same size.");

        QL_REQUIRE(lambda_ > 0.0, "lambda must be positive");

        std::for_each(processes_.begin(), processes_.end(),
            [this](const auto& p) { registerWith(p); });
    }

    void ChoiBasketEngine::calculate() const {
        const ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(arguments_.exercise);
        QL_REQUIRE(exercise, "not an European exercise");

        const Date maturityDate = exercise->lastDate();

        const detail::VectorBsmProcessExtractor pExtractor(processes_);
        const Array s = pExtractor.getSpot();
        const Array dq = pExtractor.getDividendYieldDf(maturityDate);
        const DiscountFactor dr0 = pExtractor.getInterestRateDf(maturityDate);

        Array stdDev = Sqrt(pExtractor.getBlackVariance(maturityDate));
        std::transform(stdDev.begin(), stdDev.end(), stdDev.begin(),
            [](Real x) -> Real { return std::max(QL_EPSILON*QL_EPSILON, x); }
        );

        const Array fwd = s * dq/dr0;

        const ext::shared_ptr<AverageBasketPayoff> avgPayoff =
            (ext::dynamic_pointer_cast<AverageBasketPayoff>(arguments_.payoff) != nullptr)
            ? ext::dynamic_pointer_cast<AverageBasketPayoff>(arguments_.payoff)
            : (ext::dynamic_pointer_cast<SpreadBasketPayoff>(arguments_.payoff) != nullptr)
                ? ext::make_shared<AverageBasketPayoff>(
                    ext::dynamic_pointer_cast<SpreadBasketPayoff>(
                        arguments_.payoff)->basePayoff(),
                    Array({1.0, -1.0})
                  )
                : ext::shared_ptr<AverageBasketPayoff>();

        QL_REQUIRE(avgPayoff, "average or spread basket payoff expected");

        const Array weights = avgPayoff->weights();

        QL_REQUIRE(n_ == weights.size() && n_ > 1,
             "wrong number of weights arguments in payoff");

        const Array g = weights*fwd / Norm2(weights*fwd);

        const Matrix Sigma = getCovariance(stdDev.begin(), stdDev.end(), rho_);
        Array vStar1 = Sigma*g;
        vStar1 /= std::sqrt(DotProduct(g, vStar1));

        const Matrix C = CholeskyDecomposition(Sigma);

        const Real eps = 100*std::sqrt(QL_EPSILON);
        // publication sets tol=0, pyfeng implementation sets tol=0.01
        const Real tol = 100*std::sqrt(QL_EPSILON);

        bool flip = false;
        for (Size i=0; i < n_; ++i)
            if (boost::math::sign(g[i])*vStar1[i] < tol*stdDev[i]) {
                flip = true;
                vStar1[i] = eps * boost::math::sign(g[i]) * stdDev[i];
            }

        Array q1(n_);
        if (flip) {
            //q1 = inverse(C)*vStar1;
            for (Size i=0; i < n_; ++i)
                q1[i] = (vStar1[i] - std::inner_product(
                    C.row_begin(i), C.row_begin(i) + i, q1.begin(), Real(0.0)))/C[i][i];

            vStar1 /= Norm2(q1);
        }
        else {
            q1 = transpose(C)*g;
        }
        q1 /= Norm2(q1);

        Array e1(n_, 0.0);
        e1[0] = 1.0;

        const Matrix R = HouseholderTransformation(
            HouseholderReflection(e1).reflectionVector(q1)).getMatrix();
        Matrix R_2_n = Matrix(n_, n_-1);
        for (Size i=0; i < n_; ++i)
            std::copy(R.row_begin(i)+1, R.row_end(i), R_2_n.row_begin(i));

        const SVD svd(C*R_2_n);
        const Matrix& U = svd.U();
        const Array& sv = svd.singularValues();

        Matrix v(n_, n_-1);
        for (Size i=0; i < n_-1; ++i)
            std::transform(
                U.column_begin(i), U.column_end(i), v.column_begin(i),
                [i, &sv](Real x) -> Real { return sv[i]*x; }
            );

        std::vector<Size> nIntOrder(n_-1);
        Real lambda = lambda_;
        const Real alpha = 1/std::abs(DotProduct(g, vStar1));
        do {
            const Real intScale = lambda * alpha;
            for (Size i=0; i < n_-1; ++i)
                nIntOrder[i] = Size(std::lround(1 + intScale*sv[i]));

            lambda*=0.9;

            QL_REQUIRE(lambda/lambda_ > 1e-10,
                "can not rescale lambda to fit max integration order");
        } while (std::accumulate(
                     nIntOrder.begin(), nIntOrder.end(), 1.0, std::multiplies<>())
                > Real(maxNrIntegrationSteps_));

        std::vector<ext::shared_ptr<SimpleQuote> > quotes;
        std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > p;
        for (Size i=0; i < n_; ++i) {
            quotes.push_back(ext::make_shared<SimpleQuote>(fwd[i]));

            const Handle<BlackVolTermStructure> bv = processes_[i]->blackVolatility();
            const Volatility vol = vStar1[i] / std::sqrt(
                bv->dayCounter().yearFraction(bv->referenceDate(), maturityDate)
            );
            p.push_back(
                ext::make_shared<BlackProcess>(
                    Handle<Quote>(quotes[i]),
                    processes_[i]->riskFreeRate(),
                    Handle<BlackVolTermStructure>(
                       ext::make_shared<BlackConstantVol>(
                          bv->referenceDate(), bv->calendar(),
                          Handle<Quote>(ext::make_shared<SimpleQuote>(vol)),
                          bv->dayCounter()
                       )
                    )
                )
            );
        }

        BasketOption option(avgPayoff, exercise);
        option.setPricingEngine(ext::make_shared<SingleFactorBsmBasketEngine>(p));

        Array vq(n_);
        for (Size i=0; i < n_; ++i)
            vq[i] = 0.5*std::accumulate(
                v.row_begin(i), v.row_end(i), Real(0.0),
                [](Real acc, Real x) -> Real { return acc + x*x; }
            );

        MultiDimGaussianIntegration ghq(
            nIntOrder,
            [](const Size n) { return ext::make_shared<GaussHermiteIntegration>(n); }
        );
        const Real normFactor = std::pow(M_PI, -0.5*nIntOrder.size());

        std::vector<Real> dStore;
        dStore.reserve(ghq.weights().size());
        const auto bsm1dPricer = [&](const Array& z) -> Real {
            const Array f = Exp(-M_SQRT2*(v*z) - vq) * fwd;

            for (Size i=0; i < f.size(); ++i)
                quotes[i]->setValue(f[i]);

            dStore.push_back(ext::any_cast<Real>(option.additionalResults().at("d")));
            return std::exp(-DotProduct(z, z)) * option.NPV();
        };

        results_.value = ghq(bsm1dPricer) * normFactor;

        if (calcFwdDelta_) {
            const ext::shared_ptr<PlainVanillaPayoff> payoff =
                 ext::dynamic_pointer_cast<PlainVanillaPayoff>(avgPayoff->basePayoff());
            QL_REQUIRE(payoff, "non-plain vanilla payoff given");
            const Real putIndicator = (payoff->optionType() == Option::Call) ? 0.0 : -1.0;

            Size dStoreCounter;
            const CumulativeNormalDistribution N;

            Array fwdDelta(n_), fHat(n_);
            for (Size k=0; k < n_; ++k) {
                dStoreCounter = 0;

                const auto deltaPricer = [&](const Array& z) -> Real {
                    const Real d = dStore[dStoreCounter++];
                    const Real vz = std::inner_product(
                        v.row_begin(k), v.row_end(k), z.begin(), Real(0.0));
                    const Real f = std::exp(-M_SQRT2*vz - vq[k]);

                    return std::exp(-DotProduct(z, z)) * f * N(d + vStar1[k]);
                };

                fwdDelta[k] = dr0*weights[k]*(ghq(deltaPricer) * normFactor + putIndicator);

                const std::string deltaName = "forwardDelta " + std::to_string(k);
                results_.additionalResults[deltaName] = fwdDelta[k];
            }

            if (controlVariate_) {
                for (Size k=0; k < n_; ++k) {
                    const auto fHatPricer =  [&](const Array& z) -> Real {
                        const Real vz = std::inner_product(
                            v.row_begin(k), v.row_end(k), z.begin(), Real(0.0));
                        const Real f = std::exp(-M_SQRT2*vz - vq[k]);

                        return std::exp(-DotProduct(z, z)) * f;
                    };
                fHat[k] = ghq(fHatPricer) * normFactor;
                }
                const Array cv = fwdDelta*fwd*(fHat-1.0);
                results_.value -= std::accumulate(cv.begin(), cv.end(), Real(0.0));
            }
        }
    }
}
]]></document_content>
  </document>
  <document index="32">
    <source>basket/denglizhoubasketengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2024 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include <ql/exercise.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/matrixutilities/pseudosqrt.hpp>
#include <ql/math/matrixutilities/choleskydecomposition.hpp>
#include <ql/pricingengines/basket/vectorbsmprocessextractor.hpp>
#include <ql/pricingengines/basket/denglizhoubasketengine.hpp>

namespace QuantLib {

    DengLiZhouBasketEngine::DengLiZhouBasketEngine(
        std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > processes,
        Matrix rho)
    : n_(processes.size()),
      processes_(std::move(processes)),
      rho_(std::move(rho)) {

        QL_REQUIRE(n_ > 0, "No Black-Scholes process is given.");
        QL_REQUIRE(n_ == rho_.size1() && rho_.size1() == rho_.size2(),
            "process and correlation matrix must have the same size.");

        std::for_each(processes_.begin(), processes_.end(),
            [this](const auto& p) { registerWith(p); });
    }

    void DengLiZhouBasketEngine::calculate() const {
        const ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(arguments_.exercise);
        QL_REQUIRE(exercise, "not an European exercise");
        const Date maturityDate = exercise->lastDate();

        const ext::shared_ptr<AverageBasketPayoff> avgPayoff =
            (ext::dynamic_pointer_cast<AverageBasketPayoff>(arguments_.payoff) != nullptr)
            ? ext::dynamic_pointer_cast<AverageBasketPayoff>(arguments_.payoff)
            : (ext::dynamic_pointer_cast<SpreadBasketPayoff>(arguments_.payoff) != nullptr)
                ? ext::make_shared<AverageBasketPayoff>(
                    ext::dynamic_pointer_cast<SpreadBasketPayoff>(
                        arguments_.payoff)->basePayoff(),
                    Array({1.0, -1.0})
                  )
                : ext::shared_ptr<AverageBasketPayoff>();

        QL_REQUIRE(avgPayoff, "average or spread basket payoff expected");

        const Array weights = avgPayoff->weights();
        QL_REQUIRE(n_ == weights.size() && n_ > 1,
             "wrong number of weights arguments in payoff");

        const detail::VectorBsmProcessExtractor pExtractor(processes_);
        const Array s = pExtractor.getSpot();
        const Array dq = pExtractor.getDividendYieldDf(maturityDate);
        const Array v = pExtractor.getBlackVariance(maturityDate);
        const DiscountFactor dr0 = pExtractor.getInterestRateDf(maturityDate);

        std::vector< std::tuple<Real, Size, Real, Real, Real> > p;
        p.reserve(n_);

        for (Size i=0; i < n_; ++i)
            p.emplace_back(weights[i], i, s[i], dq[i], v[i]);

        const ext::shared_ptr<PlainVanillaPayoff> payoff =
             ext::dynamic_pointer_cast<PlainVanillaPayoff>(avgPayoff->basePayoff());
        QL_REQUIRE(payoff, "non-plain vanilla payoff given");

        Matrix rho;
        if (payoff->strike() < 0.0) {
            p.emplace_back(1.0, n_, -payoff->strike(), dr0, 0.0);
            rho = Matrix(n_+1, n_+1);
            for (Size i=0; i < n_; ++i) {
                std::copy(rho_.row_begin(i), rho_.row_end(i), rho.row_begin(i));
                rho[n_][i] = rho[i][n_] = 0.0;
            }
            rho[n_][n_] = 1.0;
        }
        else
            rho = rho_;

        const Real strike = std::max(0.0, payoff->strike());

        // positive weights first
        std::sort(p.begin(), p.end(), std::greater<>());

        const Size M = std::distance(
            p.begin(),
            std::lower_bound(p.begin(), p.end(), Real(0),
                [](const auto& p, const Real& value) -> bool { return std::get<0>(p) > value;}            )
        );

        QL_REQUIRE(M > 0, "at least one positive asset weight must be given");
        QL_REQUIRE(M < p.size(), "at least one negative asset weight must be given");

        const Size N = p.size() - M;

        Matrix nRho(N+1, N+1);
        Array _s(N+1), _dq(N+1), _v(N+1);

        if (M > 1) {
            Array F(M), vol(M);
            for (Size i=0; i < M; ++i) {
                vol[i] = std::sqrt(std::get<4>(p[i]));
                F[i] = std::get<0>(p[i])*std::get<2>(p[i])*std::get<3>(p[i])/dr0;
            }

            const Real S0 = std::accumulate(
                p.begin(), p.begin()+M, Real(0.0),
                [](const Real& value, const auto& p) -> Real {
                    return value + std::get<0>(p)*std::get<2>(p);
            });
            const Real F0 = std::accumulate(F.begin(), F.end(), Real(0.0));
            const DiscountFactor dq_S0 = F0/S0*dr0;

            Real v_s = 0.0;
            for (Size i=0; i < M; ++i)
                for (Size j=0; j < M; ++j)
                    v_s += vol[i]*vol[j]*F[i]*F[j]
                        *rho[std::get<1>(p[i])][std::get<1>(p[j])];

            v_s /= F0*F0;
            _s[0] = S0; _dq[0] = dq_S0; _v[0] = v_s;

            nRho[0][0] = 1.0;

            for (Size i=0; i < N; ++i) {
                Real rhoHat = 0.0;
                for (Size j=0; j < M; ++j)
                    rhoHat += rho[std::get<1>(p[M+i])][std::get<1>(p[j])]*vol[j]*F[j];

                nRho[i+1][0] = nRho[0][i+1]
                      = std::min(1.0, std::max(-1.0, rhoHat/(std::sqrt(v_s)*F0)));
            }
        }
        else {
            _s[0]  = std::abs(std::get<0>(p[0])*std::get<2>(p[0]));
            _dq[0] = std::get<3>(p[0]);
            _v[0]  = std::get<4>(p[0]);
            for (Size i=0; i < N+1; ++i)
                nRho[0][i] = nRho[i][0] = rho[std::get<1>(p[i])][std::get<1>(p[0])];
        }

        for (Size i=0; i < N; ++i) {
            _s[i+1]  = std::abs(std::get<0>(p[M+i])*std::get<2>(p[M+i]));
            _dq[i+1] = std::get<3>(p[M+i]);
            _v[i+1]  = std::get<4>(p[M+i]);

            const Size idx = std::get<1>(p[M+i]);
            for (Size j=0; j < N; ++j)
                nRho[i+1][j+1] = rho[idx][std::get<1>(p[M+j])];
        }

        const Real callValue
            = DengLiZhouBasketEngine::calculate_vanilla_call(Log(_s), dr0, _dq, _v, nRho, strike);

        if (payoff->optionType() == Option::Call)
            results_.value = std::max(0.0, callValue);
        else {
            const Real fwd = _s[0]*_dq[0] - dr0*strike
                - std::inner_product(_s.begin()+1, _s.end(), _dq.begin()+1, Real(0.0));
            results_.value = std::max(0.0, callValue - fwd);
        }
    }

    Real DengLiZhouBasketEngine::I(Real u, Real tF2, const Matrix& D, const Matrix& DF, Size i) {
        const Real psi = 1.0/
            (1.0 + std::inner_product(
                 D.row_begin(i), D.row_end(i), D.row_begin(i), Real(0.0)));
        const Real sqrtPsi = std::sqrt(psi);

        const Real n_uSqrtPsi = NormalDistribution()(u*sqrtPsi);
        const Real J_0 = CumulativeNormalDistribution()(u*sqrtPsi);

        const Real vFv = std::inner_product(
            DF.row_begin(i), DF.row_end(i), D.row_begin(i), Real(0.0));
        const Real J_1 = psi*sqrtPsi*(psi*u*u - 1.0) * vFv * n_uSqrtPsi;

        const Real vFFv = std::inner_product(
            DF.row_begin(i), DF.row_end(i), DF.row_begin(i), Real(0.0));
        const Real J_2 = u*psi*sqrtPsi*n_uSqrtPsi*(
                2 * tF2
                + vFv*vFv*(squared(squared(psi*u))
                           - 10.0*psi*psi*psi*u*u + 15*psi*psi)
                + vFFv * (4*psi*psi*u*u - 12*psi)
        );

        return J_0 + J_1 - 0.5*J_2;
    }

    Real DengLiZhouBasketEngine::calculate_vanilla_call(
        const Array& x, DiscountFactor dr, const Array& dq,
        const Array& v, const Matrix& rho, Real K) {

        const Array mu = x + Log(dq/dr) - 0.5 * v;
        const Array nu = Sqrt(v);

        const Real R = std::accumulate(
            mu.begin()+1, mu.end(), Real(0),
            [](Real a, Real b) -> Real { return a + std::exp(b); }
        );

        const Size N = x.size()-1;

        Matrix sig11(N, N);
        for (Size i=0; i < N; ++i)
            std::copy(rho.row_begin(i+1)+1, rho.row_end(i+1), sig11.row_begin(i));
        const Array sig10(rho.row_begin(0)+1, rho.row_end(0));

        const Matrix sqSig11 = pseudoSqrt(sig11, SalvagingAlgorithm::Principal);
        const Array sig11Inv10 = CholeskySolveFor(CholeskyDecomposition(sig11), sig10);

        const Real sig_xy = 1.0 - DotProduct(sig10, sig11Inv10);
        QL_REQUIRE(sig_xy > 0.0, "approximation loses validity");
        const Real sqSig_xy = std::sqrt(sig_xy);

        const Real a = -0.5/sqSig_xy;
        Matrix E(N, N);
        for (Size i=1; i <= N; ++i)
            for (Size j=i; j <= N; ++j)
                E(i-1, j-1) = E(j-1, i-1) =
                     a*(((i==j)? squared(nu[j])*std::exp(mu[j])/(nu[0]*(R+K)) : Real(0.0))
                        -nu[i]*nu[j]*std::exp(mu[i]+mu[j])/(nu[0]*squared(R + K)) );

        const Matrix F = sqSig11*E*sqSig11;

        Real trF(0), trF2(0);
        for (Size i=0; i < N; ++i) {
            trF += F[i][i];
            trF2 += squared(F[i][i]) +
                 2.0*std::accumulate(
                     F.row_begin(i)+i+1, F.row_end(i), Real(0),
                     [](Real a, Real b) -> Real {return a+b*b;}
                 );
        }

        const Real c = -(std::log(R + K) - mu[0])/(nu[0]*sqSig_xy);

        const Array d = (sig11Inv10
            - Exp(Array(mu.begin()+1, mu.end()))*Array(nu.begin()+1,nu.end())/(nu[0]*(R+K)))/sqSig_xy;

        const Array Esig10 = E*sig10;
        const Matrix Esig11 = E*sig11;
        const Array sig11d = sig11*d;

        Array C(N+2);
        C[0] = c + trF + nu[0]*sqSig_xy + nu[0]*DotProduct(sig10, d)
             + squared(nu[0])*DotProduct(sig10, Esig10);
        C[N+1] = c + trF;

        for (Size k=1; k < N+1; ++k)
            C[k] = c + trF + nu[k]*sig11d[k-1] + squared(nu[k])
                * std::inner_product(sig11.row_begin(k-1), sig11.row_end(k-1),
                                     Esig11.column_begin(k-1), Real(0.0));

        std::vector<Array> D(N+2);
        D[0] = sqSig11*(d + 2*nu[0]*Esig10);
        D[N+1] = sqSig11*d;
        for (Size k=1; k < N+1; ++k)
            D[k] = sqSig11*(d + 2*nu[k]*Array(Esig11.column_begin(k-1), Esig11.column_end(k-1)));

        Matrix DM(N+2, N);
        for (Size k=0; k < N+2; ++k)
            std::copy(D[k].begin(), D[k].end(), DM.row_begin(k));

        const Matrix DF = DM*F;

        Real npv = dr*std::exp(mu[0] + 0.5*squared(nu[0])) * I(C[0], trF2, DM, DF, 0)
            - K*dr*I(C.back(), trF2, DM, DF, N+1);

        for (Size k=1; k <= N; ++k)
            npv -= dr*std::exp(mu[k] + 0.5*squared(nu[k])) * I(C[k], trF2, DM, DF, k);

        return npv;
    }
}
]]></document_content>
  </document>
  <document index="33">
    <source>basket/fd2dblackscholesvanillaengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/methods/finitedifferences/solvers/fdm2dblackscholessolver.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/meshers/fdmblackscholesmesher.hpp>
#include <ql/pricingengines/basket/fd2dblackscholesvanillaengine.hpp>

namespace QuantLib {

    Fd2dBlackScholesVanillaEngine::Fd2dBlackScholesVanillaEngine(
        const ext::shared_ptr<GeneralizedBlackScholesProcess>& p1,
        const ext::shared_ptr<GeneralizedBlackScholesProcess>& p2,
        Real correlation,
        Size xGrid, Size yGrid,
        Size tGrid, Size dampingSteps,
        const FdmSchemeDesc& schemeDesc,
        bool localVol,
        Real illegalLocalVolOverwrite)
    : p1_(p1),
      p2_(p2),
      correlation_(correlation),
      xGrid_(xGrid), yGrid_(yGrid), tGrid_(tGrid),
      dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc),
      localVol_(localVol),
      illegalLocalVolOverwrite_(illegalLocalVolOverwrite) {
        registerWith(p1);
        registerWith(p2);
    }

    void Fd2dBlackScholesVanillaEngine::calculate() const {
        // 1. Payoff
        const ext::shared_ptr<BasketPayoff> payoff =
            ext::dynamic_pointer_cast<BasketPayoff>(arguments_.payoff);

        // 2. Mesher
        const Time maturity = p1_->time(arguments_.exercise->lastDate());
        const ext::shared_ptr<Fdm1dMesher> em1(
            new FdmBlackScholesMesher(
                    xGrid_, p1_, maturity, p1_->x0(), 
                    Null<Real>(), Null<Real>(), 0.0001, 1.5, 
                    std::pair<Real, Real>(p1_->x0(), 0.1)));

        const ext::shared_ptr<Fdm1dMesher> em2(
            new FdmBlackScholesMesher(
                    yGrid_, p2_, maturity, p2_->x0(),
                    Null<Real>(), Null<Real>(), 0.0001, 1.5, 
                    std::pair<Real, Real>(p2_->x0(), 0.1)));

        const ext::shared_ptr<FdmMesher> mesher (
            new FdmMesherComposite(em1, em2));

        // 3. Calculator
        const ext::shared_ptr<FdmInnerValueCalculator> calculator(
                                new FdmLogBasketInnerValue(payoff, mesher));

        // 4. Step conditions
        const ext::shared_ptr<FdmStepConditionComposite> conditions =
            FdmStepConditionComposite::vanillaComposite(
                                    DividendSchedule(), arguments_.exercise, 
                                    mesher, calculator, 
                                    p1_->riskFreeRate()->referenceDate(),
                                    p1_->riskFreeRate()->dayCounter());

        // 5. Boundary conditions
        const FdmBoundaryConditionSet boundaries;

        // 6. Solver
        const FdmSolverDesc solverDesc = { mesher, boundaries,
                                           conditions, calculator,
                                           maturity, tGrid_, dampingSteps_ };

        ext::shared_ptr<Fdm2dBlackScholesSolver> solver(
                new Fdm2dBlackScholesSolver(
                             Handle<GeneralizedBlackScholesProcess>(p1_),
                             Handle<GeneralizedBlackScholesProcess>(p2_),
                             correlation_, solverDesc, schemeDesc_,
                             localVol_, illegalLocalVolOverwrite_));

        const Real x = p1_->x0();
        const Real y = p2_->x0();

        results_.value = solver->valueAt(x, y);
        results_.delta = solver->deltaXat(x, y) + solver->deltaYat(x, y);
        results_.gamma = solver->gammaXat(x, y) + solver->gammaYat(x, y)
             + 2*solver->gammaXYat(x, y);
        results_.theta = solver->thetaAt(x, y);
    }
}
]]></document_content>
  </document>
  <document index="34">
    <source>basket/fdndimblackscholesvanillaengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2024 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/math/matrixutilities/getcovariance.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/matrixutilities/symmetricschurdecomposition.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/meshers/predefined1dmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmwienerop.hpp>
#include <ql/methods/finitedifferences/solvers/fdmndimsolver.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/pricingengines/basket/fdndimblackscholesvanillaengine.hpp>
#include <ql/pricingengines/basket/vectorbsmprocessextractor.hpp>
#include <boost/preprocessor/iteration/local.hpp>
#include <utility>

namespace QuantLib {

    namespace detail {
        class FdmPCABasketInnerValue: public FdmInnerValueCalculator {
          public:
            FdmPCABasketInnerValue(
                ext::shared_ptr<BasketPayoff> payoff,
                ext::shared_ptr<FdmMesher> mesher,
                Array logS0, const Array& vols,
                std::vector<ext::shared_ptr<YieldTermStructure>> qTS,
                ext::shared_ptr<YieldTermStructure> rTS,
                Matrix Q, Array l)
            : n_(logS0.size()),
              payoff_(std::move(payoff)),
              mesher_(std::move(mesher)),
              logS0_(std::move(logS0)), v_(vols*vols),
              qTS_(std::move(qTS)),
              rTS_(std::move(rTS)),
              Q_(std::move(Q)), l_(std::move(l)),
              cachedT_(Null<Real>()),
              qf_(n_) { }

            Real innerValue(const FdmLinearOpIterator& iter, Time t) override {
                if (!close_enough(t, cachedT_)) {
                    rf_ = rTS_->discount(t);
                    for (Size i=0; i < n_; ++i)
                        qf_[i] = qTS_[i]->discount(t);
                }
                Array x(n_);
                for (Size i=0; i < n_; ++i)
                    x[i] = mesher_->location(iter, i);

                const Array S = Exp(Q_*x - 0.5*v_*t + logS0_)*qf_/rf_;

                return (*payoff_)(S);
            }
            Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override {
                return innerValue(iter, t);
            }

          private:
            const Size n_;
            const ext::shared_ptr<BasketPayoff> payoff_;
            const ext::shared_ptr<FdmMesher> mesher_;
            const Array logS0_, v_;
            const std::vector<ext::shared_ptr<YieldTermStructure>> qTS_;
            const ext::shared_ptr<YieldTermStructure> rTS_;
            const Matrix Q_;
            const Array l_;
            Time cachedT_;
            Array qf_;
            DiscountFactor rf_;
        };
    }

    FdndimBlackScholesVanillaEngine::FdndimBlackScholesVanillaEngine(
        std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > processes,
        Matrix rho,
        std::vector<Size> xGrids,
        Size tGrid, Size dampingSteps,
        const FdmSchemeDesc& schemeDesc)
    : processes_(std::move(processes)),
      rho_(std::move(rho)),
      xGrids_(std::move(xGrids)),
      tGrid_(tGrid),
      dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc) {

        QL_REQUIRE(!processes_.empty(), "no Black-Scholes process is given.");
        QL_REQUIRE(rho_.size1() == rho_.size2()
                && rho_.size1() == processes_.size(),
                "correlation matrix has the wrong size.");
        QL_REQUIRE(xGrids_.size() == 1 || xGrids_.size() == processes_.size(),
                "wrong number of xGrids is given.");

        std::for_each(processes_.begin(), processes_.end(),
            [this](const auto& p) { registerWith(p); });
    }

    FdndimBlackScholesVanillaEngine::FdndimBlackScholesVanillaEngine(
        std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > processes,
        Matrix rho, Size xGrid, Size tGrid, Size dampingSteps,
        const FdmSchemeDesc& schemeDesc)
    : FdndimBlackScholesVanillaEngine(
        std::move(processes), std::move(rho), std::vector<Size>(1, xGrid), tGrid, dampingSteps, schemeDesc)
    {}


    void FdndimBlackScholesVanillaEngine::calculate() const {
        #ifndef PDE_MAX_SUPPORTED_DIM
        #define PDE_MAX_SUPPORTED_DIM 4
        #endif
        QL_REQUIRE(processes_.size() <= PDE_MAX_SUPPORTED_DIM,
            "This engine does not support " << processes_.size() << " underlyings. "
            << "Max number of underlyings is " << PDE_MAX_SUPPORTED_DIM << ". "
            << "Please change preprocessor constant PDE_MAX_SUPPORTED_DIM and recompile "
            << "if a larger number of underlyings is needed.");

        const Date maturityDate = arguments_.exercise->lastDate();
        const Time maturity = processes_[0]->time(maturityDate);
        const Real sqrtT = std::sqrt(maturity);

        const detail::VectorBsmProcessExtractor pExtractor(processes_);
        const Array s = pExtractor.getSpot();
        const Array dq = pExtractor.getDividendYieldDf(maturityDate);
        const Array stdDev = Sqrt(pExtractor.getBlackVariance(maturityDate));
        const Array vols = stdDev / sqrtT;

        const SymmetricSchurDecomposition schur(
            getCovariance(vols.begin(), vols.end(), rho_));
        const Matrix& Q = schur.eigenvectors();
        const Array& l = schur.eigenvalues();

        const Real eps = 1e-4;
        std::vector<ext::shared_ptr<Fdm1dMesher> > meshers;

        for (Size i=0; i < processes_.size(); ++i) {
            const Size xGrid = (xGrids_.size() > 1)
                ? xGrids_[i]
                : std::max(Size(4), Size(xGrids_[0]*std::pow(l[i]/l[0], 0.1)));
            QL_REQUIRE(xGrid >= 4, "minimum grid size is four");

            const Real xStepStize = (1.0-2*eps)/(xGrid-1);

            std::vector<Real> x(xGrid);
            for (Size j=0; j < xGrid; ++j)
                x[j] = 1.3*std::sqrt(l[i])*sqrtT
                    *InverseCumulativeNormal()(eps + j*xStepStize);

            meshers.emplace_back(ext::make_shared<Predefined1dMesher>(x));
        }

        const ext::shared_ptr<FdmMesherComposite> mesher =
            ext::make_shared<FdmMesherComposite>(meshers);

        const ext::shared_ptr<BasketPayoff> payoff
            = ext::dynamic_pointer_cast<BasketPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "basket payoff expected");

        const ext::shared_ptr<YieldTermStructure> rTS =
            processes_[0]->riskFreeRate().currentLink();

        std::vector<ext::shared_ptr<YieldTermStructure>> qTS(processes_.size());
        for (Size i=0; i < processes_.size(); ++i)
            qTS[i] = processes_[i]->dividendYield().currentLink();

        const ext::shared_ptr<FdmInnerValueCalculator> calculator =
            ext::make_shared<detail::FdmPCABasketInnerValue>(
                payoff, mesher,
                Log(s), stdDev/sqrtT,
                qTS, rTS,
                Q, l
            );

        const ext::shared_ptr<FdmStepConditionComposite> conditions
            = FdmStepConditionComposite::vanillaComposite(
                DividendSchedule(), arguments_.exercise,
                mesher, calculator,
                rTS->referenceDate(), rTS->dayCounter());

        const FdmBoundaryConditionSet boundaries;
        const FdmSolverDesc solverDesc
            = { mesher, boundaries, conditions, calculator,
                maturity, tGrid_, dampingSteps_ };

        const bool isEuropean =
            ext::dynamic_pointer_cast<EuropeanExercise>(arguments_.exercise) != nullptr;
        const ext::shared_ptr<FdmWienerOp> op =
            ext::make_shared<FdmWienerOp>(
                mesher,
                (isEuropean)? ext::shared_ptr<YieldTermStructure>() : rTS,
                l);

        switch(processes_.size()) {
            #define BOOST_PP_LOCAL_MACRO(n) \
                case n : \
                    results_.value = ext::make_shared<FdmNdimSolver<n>>( \
                        solverDesc, schemeDesc_, op)->interpolateAt( \
                            std::vector<Real>(processes_.size(), 0.0)); \
                break;
            #define BOOST_PP_LOCAL_LIMITS (1, PDE_MAX_SUPPORTED_DIM)
            #include BOOST_PP_LOCAL_ITERATE()
          default:
            QL_FAIL("Not implemented for " << processes_.size() << " processes");
        }

        if (isEuropean)
            results_.value *= pExtractor.getInterestRateDf(maturityDate);
    }
}
]]></document_content>
  </document>
  <document index="35">
    <source>basket/kirkengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/functional.hpp>
#include <ql/pricingengines/basket/kirkengine.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <utility>

namespace QuantLib {

    KirkEngine::KirkEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
                           ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
                           Real correlation)
    : SpreadBlackScholesVanillaEngine(std::move(process1), std::move(process2), correlation) {
    }

    Real KirkEngine::calculate(
        Real f1, Real f2, Real strike, Option::Type optionType,
        Real variance1, Real variance2, DiscountFactor df) const {
        
        const Real f = f1/(f2 + strike);
        const Real v 
            = std::sqrt(variance1 
                        + variance2*squared(f2/(f2+strike))
                        - 2*rho_*std::sqrt(variance1*variance2)
                            *(f2/(f2+strike)));
        
        BlackCalculator black(
             ext::make_shared<PlainVanillaPayoff>(
                 optionType,1.0),
             f, v, df);
        
        return (f2 + strike)*black.value();
    }
}

]]></document_content>
  </document>
  <document index="36">
    <source>basket/mcamericanbasketengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Neil Firth
 Copyright (C) 2006 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/montecarlo/lsmbasissystem.hpp>
#include <ql/pricingengines/basket/mcamericanbasketengine.hpp>
#include <utility>

namespace QuantLib {

    AmericanBasketPathPricer::AmericanBasketPathPricer(
        Size assetNumber,
        ext::shared_ptr<Payoff> payoff,
        Size polynomialOrder,
        LsmBasisSystem::PolynomialType polynomialType)
    : assetNumber_(assetNumber), payoff_(std::move(payoff)),
      v_(LsmBasisSystem::multiPathBasisSystem(assetNumber_, polynomialOrder, polynomialType)) {
        QL_REQUIRE(   polynomialType == LsmBasisSystem::Monomial
                   || polynomialType == LsmBasisSystem::Laguerre
                   || polynomialType == LsmBasisSystem::Hermite
                   || polynomialType == LsmBasisSystem::Hyperbolic
                   || polynomialType == LsmBasisSystem::Chebyshev2nd,
                   "insufficient polynomial type");

        const ext::shared_ptr<BasketPayoff> basketPayoff
            = ext::dynamic_pointer_cast<BasketPayoff>(payoff_);
        QL_REQUIRE(basketPayoff, "payoff not a basket payoff");

        const ext::shared_ptr<StrikedTypePayoff> strikePayoff
            = ext::dynamic_pointer_cast<StrikedTypePayoff>(basketPayoff->basePayoff());

        if (strikePayoff != nullptr) {
            scalingValue_/=strikePayoff->strike();
        }

        v_.emplace_back([&](const Array& state) { return this->payoff(state); });
    }

    Array AmericanBasketPathPricer::state(const MultiPath& path,
                                          Size t) const {
        QL_REQUIRE(path.assetNumber() == assetNumber_, "invalid multipath");

        Array tmp(assetNumber_);
        for (Size i=0; i<assetNumber_; ++i) {
            tmp[i] = path[i][t]*scalingValue_;
        }

        return tmp;
    }

    Real AmericanBasketPathPricer::payoff(const Array& state) const {
        const ext::shared_ptr<BasketPayoff> basketPayoff
            = ext::dynamic_pointer_cast<BasketPayoff>(payoff_);
        QL_REQUIRE(basketPayoff, "payoff not a basket payoff");

        Real value = basketPayoff->accumulate(state);
        return (*payoff_)(value/scalingValue_);
    }

    Real AmericanBasketPathPricer::operator()(const MultiPath& path,
                                              Size t) const {
        return this->payoff(this->state(path, t));
    }

    std::vector<std::function<Real(Array)> >
    AmericanBasketPathPricer::basisSystem() const {
        return v_;
    }

}
]]></document_content>
  </document>
  <document index="37">
    <source>basket/mceuropeanbasketengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003 Neil Firth
 Copyright (C) 2003 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/basket/mceuropeanbasketengine.hpp>
#include <utility>

namespace QuantLib {

    EuropeanMultiPathPricer::EuropeanMultiPathPricer(ext::shared_ptr<BasketPayoff> payoff,
                                                     DiscountFactor discount)
    : payoff_(std::move(payoff)), discount_(discount) {}

    Real EuropeanMultiPathPricer::operator()(const MultiPath& multiPath)
                                                                      const {
        Size n = multiPath.pathSize();
        QL_REQUIRE(n>0, "the path cannot be empty");

        Size numAssets = multiPath.assetNumber();
        QL_REQUIRE(numAssets>0, "there must be some paths");

        Size j;
        // calculate the final price of each asset
        Array finalPrice(numAssets, 0.0);
        for (j = 0; j < numAssets; j++)
            finalPrice[j] = multiPath[j].back();
        return (*payoff_)(finalPrice) * discount_;
    }

}

]]></document_content>
  </document>
  <document index="38">
    <source>basket/operatorsplittingspreadengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2024 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/functional.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/pricingengines/basket/operatorsplittingspreadengine.hpp>

#include <utility>

namespace QuantLib {

    OperatorSplittingSpreadEngine::OperatorSplittingSpreadEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
        Real correlation,
        Order order)
    : SpreadBlackScholesVanillaEngine(std::move(process1), std::move(process2), correlation),
      order_(order) {
    }

    Real OperatorSplittingSpreadEngine::calculate(
        Real f1, Real f2, Real k, Option::Type optionType,
        Real variance1, Real variance2, DiscountFactor df) const {

        const auto callPutParityPrice = [f1, f2, df, k, optionType](Real callPrice) -> Real {
            if (optionType == Option::Call)
                return callPrice;
            else
                return callPrice - df*(f1-f2-k);
        };

        const Real vol1 = std::sqrt(variance1);
        const Real vol2 = std::sqrt(variance2);
        const Real sig2 = vol2*f2/(f2+k);
        const Real sig_m = std::sqrt(variance1 +sig2*(sig2 - 2*rho_*vol1));

        const Real d1 = (std::log(f1) - std::log(f2 + k))/sig_m + 0.5*sig_m;
        const Real d2 = d1 - sig_m;

        const CumulativeNormalDistribution N;

        const Real kirkCallNPV = df*(f1*N(d1) - (f2 + k)*N(d2));

        const Real vs = vol2/(sig_m*sig_m);
        const Real rs = squared(rho_*vol1 - sig2);

        const Real oPlt = -sig2*sig2*k*df*NormalDistribution()(d2)*vs
            *( -d2*rs/sig2 - 0.5*vs*sig_m * k / (f2+k)
                *(rs*d1*d2  + (1-rho_*rho_)*variance1));

        if (order_ == First)
            return callPutParityPrice(kirkCallNPV + 0.5*oPlt);

        QL_REQUIRE(order_ == Second, "unknown approximation type");
        
        /*
           In the original paper, the second-order approximation was computed using numerical differentiation.
           The following Mathematica scripts calculates the approximation to the n'th order.

           vol2Hat[R2_] := vol2*(R2 - K)/R2
           volMinusHat[R2_] := Sqrt[vol1^2 - 2*rho*vol1*vol2Hat[R2] + vol2Hat[R2]^2]
           zeta1[R1_, R2_] := 1/(volMinusHat[R2]*Sqrt[t])*(Log[R1] + volMinusHat[R2]^2*t/2)
           zeta2[R1_, R2_] := zeta1[R1, R2] - volMinusHat[R2]*Sqrt[t]
           pLT[R1_, R2_] := Exp[-r*t]*R2*(R1*CDF[NormalDistribution[0, 1], zeta1[R1, R2]]
                                           - CDF[NormalDistribution[0, 1], zeta2[R1, R2]])
           opt[R1_, R2_] := (1/2*vol2Hat[R2]^2*R2^2*D[#, {R2, 2}] + (rho*vol1 - vol2Hat[R2])*vol2Hat[R2]*R1*R2*
                               D[#, R1, R2] - (rho*vol1 - vol2Hat[R2])*vol2Hat[R2]*R1*D[#, R1]) &

           pStrange1[R1_, R2_] := pLT[R1, R2] + (t/2)^1/Factorial[1]*opt[R1, R2][pLT[R1, R2]]
           pStrange2[R1_, R2_] := pStrange1[R1, R2] + (t/2)^2/Factorial[2]*opt[R1, R2][opt[R1, R2][pLT[R1, R2]]]
         */

        const Real R2 = f2+k;
        const Real R1 = f1/R2;
        const Real vol12 = vol1*vol1;
        const Real vol22 = vol2*vol2;
        const Real vol23 = vol22*vol2;

        if (rs < std::pow(QL_EPSILON, 0.625)) {
            const Real vol24 = vol22*vol22;
            const Real vol26 = vol22*vol24;
            const Real k2 = k*k;
            const Real R22 = R2*R2;
            const Real R24 = R22*R22;
            const Real kmR22 = squared(k-R2);
            const Real lnR1 = std::log(R1);
            
            const Real ooPlt = -0.0625*(k2*kmR22*vol26*(-8*R22*R24*(7*k2 - 7*k*R2 + R22)*vol12*vol12 
                + kmR22*R24*vol12*(-112*k*R2 + 16*R22 + k2*(124 + 3*vol12))*vol22 - 2*kmR22*kmR22*R22*
                (-28*k*R2 + 4*R22 + k2*(34 + 3*vol12))*vol24 + 3*k2*kmR22*kmR22*kmR22*vol26 - 4*k*(k -R2)*
                R24*lnR1*(-4*R22*vol12 + 4*kmR22*vol22 + 3*k*(k - R2)*vol22*lnR1)))
                /(std::exp(squared(-(R22*vol12) + kmR22*vol22 +    2*R22*lnR1)/(8*R24*vol12 - 8*kmR22*R22*vol22))*
                M_SQRTPI*M_SQRT2*R22*R24*R2*squared(R22*vol12 - kmR22*vol22)*std::sqrt(vol12 - (kmR22*vol22)/R22));

            return callPutParityPrice(kirkCallNPV + 0.5*oPlt + 0.125*ooPlt);        
        } 
                
        const Real F2 = f2;

        const Real F22 = F2*F2;
        const Real F23 = F22*F2;
        const Real F24 = F22*F22;

        const Real iR2 = 1.0/R2;
        const Real iR22 = iR2*iR2;
        const Real iR23 = iR22*iR2;
        const Real iR24 = iR22*iR22;
        const Real a = vol12 - 2*F2*iR2*rho_*vol1*vol2 + F22*iR22*vol22;
        const Real a2 = a*a;
        const Real b = a/2+std::log(R1);
        const Real b2 = b*b;
        const Real c = std::sqrt(a);
        const Real d = b/c;
        const Real e = rho_*vol1 - F2*iR2*vol2;
        const Real e2 = e*e;
        const Real f = d-c;
        const Real g = -2*iR2*rho_*vol1*vol2 + 2*F2*iR22*rho_*vol1*vol2 + 2*F2*iR22*vol22 - 2*F22*iR23*vol22;
        const Real h = rho_*rho_;
        const Real j = 1-h;
        const Real iat = 1/c;
        const Real l = b*iat - c;
        const Real m = f*(1 - (R2*rho_*vol1)/(F2*vol2)) - (e*iR2*k*(d*l + (j*vol12)/(e*e))*vol2)/(2.*c);
        const Real n = (iat*(1 - (R2*rho_*vol1)/(F2*vol2)))/R1 - (e*iR2*k*((f*iat)/R1 + b/(a*R1))*vol2)/(2.*c);
        const Real o = df*std::exp(-0.5*f*f);
        const Real p = d*l + (j*vol12)/(e*e);
        const Real q = (-2*j*vol12*(-(iR2*vol2) + F2*iR22*vol2))/(e*e*e);
        const Real s = q - (b2*g)/(2.*a2) - (b*f*g)/(2.*a*c) + (f*g)/(2.*c);
        const Real u = f*(-((rho_*vol1)/(F2*vol2)) + (R2*rho_*vol1)/(F22*vol2));
        const Real v = -0.5*(b*g*(1 - (R2*rho_*vol1)/(F2*vol2)))/(a*c);
        const Real w = (3*g*g)/(4.*a2*c) - (4*iR22*rho_*vol1*vol2 - 4*F2*iR23*rho_*vol1*vol2 +
                2*iR22*vol22 - 8*F2*iR23*vol22 + 6*F22*iR24*vol22)/(2.*a*c);
        const Real x = u + v + (e*g*iR2*k*p*vol2)/(4.*a*c) + (e*iR22*k*p*vol2)/(2.*c) -
                (e*iR2*k*s*vol2)/(2.*c) - (iR2*k*p*vol2*(-(iR2*vol2) + F2*iR22*vol2))/(2.*c);
        const Real y = (4*iR22 - 4*F2*iR23)*rho_*vol1*vol2 + (2*iR22 - 8*F2*iR23 + 6*F22*iR24)*vol22;
        const Real z = 4*iR22*rho_*vol1*vol2 - 4*F2*iR23*rho_*vol1*vol2 + 2*iR22*vol22 -
                8*F2*iR23*vol22 + 6*F22*iR24*vol22;

        const Real ooPlt = (k*o*vol23*(-2*c*b2*e2*e*(-1 + f*f)*F23*F24*g*g*iR22*m*vol23 +
                2*b2*e2*e2*F23*F24*g*g*iR2*iR22*k*vol22*vol22 + 2*a*b*e2*e*F23*F22*g*iR22*vol2*(-8*
                e2*F2*iR2*k*vol22 + 7*f*F22*g*m*vol22) - a*c*e2*e*F23*F22*g*iR22*vol2*(4*e*F2*
                vol2*(-2*b*(-1 + f*f)*m + e*f*iR2*k*vol2) + F22*g*(16*m + e*(2*f + 3*b*iat)*iR2*k*vol2)*vol22) -
                4*a2*a*c*e2*(e2*F22*vol2*(4*F22*iat*iR22*R2*rho_*vol1 + 8*F23*iR22*n*R1*vol2 -
                4*F24*3*iR23*n*R1*vol2 - F23*iR22*(4*iat*rho_*vol1 + F22*iR2*k*p*vol23*w))
                + 4*F23*F22*vol22*vol22*(iR22*(-2*F2*iR2 + 3*F22*iR22)*m + F22*(2*iR2 - 3*F2*iR22)*iR23*m
                + F22*iR22*(-iR2 + F2*iR22)*x) + 2*e*F22*(2*F24*F2*iR24*n*R1*vol23 +
                2*f*F2*F22*iR22*rho_*vol1*vol22 - 2*f*F22*iR22*R2*rho_*vol1*vol22 -
                b*F24*iR22*R2*rho_*vol1*vol22*w - 2*F24*vol2*(iR23*n*R1*vol22 + 4*iR23*m*vol22 - 2*iR22*vol22*x) +
                F23*(2*iR22*m*vol23 + 6*F22*iR24*m*vol23 + b*F22*iR22*vol23*w - 4*F22*iR23*vol23*x))) +
                2*a2*c*e2*F23*F22*vol2*(8*F22*g*iR22*(-iR2 + F2*iR22)*m*vol23 +
                e2*iR22*vol2*(8*F2*g*n*R1 + b*F22*iat*iR2*k*vol22*(y - z)) +
                4*e*vol22*(4*F2*g*iR22*m + F22*(-4*g*iR23*m + 2*g*iR22*x + iR22*m*z))) +
                2*a2*a*F22*(-4*e2*e2*e*f*F24*iat*iR24*k*vol23 + 8*e*F2*F24*iR23*(-iR22 + F2*iR23)*j*k*vol12*vol23*vol22 +
                12*F2*F24*iR23*squared(iR2 - F2*iR22)*j*k*vol12*vol23*vol23 +
                e2*e2*F2*vol22*(2*F24*iR22*k*vol22*(2*(iR23*p - iR22*s) + b2*iat*iR2*w) + f*(4*F22*iR22*(4*m +
                F22*iat*iR2*iR22*k*vol22) - 4*F23*(6*iR23*m + iat*iR24*k*vol22 - 2*iR22*x)
                + F24*iR23*k*vol22*(2*b*w + iat*y))) - 2*e2*e*F22*iR22*(4*f*F22*(iR2 - F2*iR22)*m*vol23 +
                F22*vol22*(F2*vol2*(2*k*(F2*iR24*p + F2*iR24*p + iR22*s - iR23*(2*p + F2*s))*vol22 + y - z)
                + R2*rho_*vol1*(-y + z)))) - 2*a2*e2*F23*(2*e2*e*F23*iR22*k*(2*b*iR22 + g*(-1 + f*iat)*iR2)*vol23 +
                4*b*f*F22*F22*g*iR22*(-iR2 + F2*iR22)*m*vol22*vol22 +
                2*e2*F22*iR22*vol2*(2*b*F2*iR2*(iR2 - F2*iR22)*k*vol23 + g*(2*R2*rho_*vol1 + 2*F2*(-1 + 3*f*m +
                b*f*n*R1)*vol2 + F22*k*(-(iR22*p) + iR2*s)*vol23)) + e*vol22*(F2*F22*g*iR22*(g*R2*rho_*vol1 + F2*g*(-1 + f*m)*vol2 +
                2*F2*iR2*(-iR2 + F2*iR22)*k*p*vol23) + 2*b*(2*F2*F22*g*iR22*rho_*vol1 - 2*F22*g*iR22*R2*rho_*vol1 +
                4*f*F23*g*iR22*m*vol2 + f*F24*vol2*(-4*g*iR23*m + 2*g*iR22*x +
                iR22*m*z))))))/(16.*a2*a2*c*e2*F23*M_SQRT2*M_SQRTPI*vol2);

        return callPutParityPrice(kirkCallNPV + 0.5*oPlt + 0.125*ooPlt);
    }
}


]]></document_content>
  </document>
  <document index="39">
    <source>basket/singlefactorbsmbasketengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2024 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file singlefactorbsmbasketengine.cpp
*/

#include <ql/exercise.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/math/solvers1d/newton.hpp>
#include <ql/math/solvers1d/ridder.hpp>
#include <ql/math/solvers1d/halley.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/pricingengines/basket/vectorbsmprocessextractor.hpp>
#include <ql/pricingengines/basket/singlefactorbsmbasketengine.hpp>

namespace QuantLib {

    namespace detail {
        SumExponentialsRootSolver::SumExponentialsRootSolver(
            Array a, Array sig, Real K)
          : a_(std::move(a)), sig_(std::move(sig)), K_(K) {
            QL_REQUIRE(a_.size() == sig_.size(),
                    "Arrays must have the same size");
        }

        Real SumExponentialsRootSolver::operator()(Real x) const {
            ++fCtr_;

            Real s = 0.0;
            for (Size i=0; i < a_.size(); ++i)
                s += a_[i]*std::exp(sig_[i]*x);
            return s - K_;
        }

        Real SumExponentialsRootSolver::derivative(Real x) const {
            ++fPrimeCtr_;

            Real s = 0.0;
            for (Size i=0; i < a_.size(); ++i)
                s += a_[i]*sig_[i]*std::exp(sig_[i]*x);
            return s;
        }

        Real SumExponentialsRootSolver::secondDerivative(Real x) const {
            ++fDoublePrimeCtr_;

            Real s = 0.0;
            for (Size i=0; i < a_.size(); ++i)
                s += a_[i]*squared(sig_[i])*std::exp(sig_[i]*x);
            return s;
        }

        Size SumExponentialsRootSolver::getFCtr() const {
            return fCtr_;
        }

        Size SumExponentialsRootSolver::getDerivativeCtr() const {
            return fPrimeCtr_;
        }

        Size SumExponentialsRootSolver::getSecondDerivativeCtr() const {
            return fDoublePrimeCtr_;
        }

        Real SumExponentialsRootSolver::getRoot(Real xTol, Strategy strategy) const {
            const Array attr = a_*sig_;
            QL_REQUIRE(
                std::all_of(
                    attr.begin(), attr.end(),
                    [](Real x) -> bool { return x >= 0.0; }
                ),
                "a*sig should not be negative"
            );

            const bool logProb =
                std::all_of(
                    a_.begin(), a_.end(),
                    [](Real x) -> bool { return x > 0;}
            );

            QL_REQUIRE(K_ > 0 || !logProb,
                "non-positive strikes only allowed for spread options");

            // linear approximation
            const Real denom = std::accumulate(attr.begin(), attr.end(), Real(0.0));
            const Real xInit = (std::abs(denom) > 1000*QL_EPSILON)
                ? std::min(10.0, std::max(-10.0,
                      (K_ - std::accumulate(a_.begin(), a_.end(), Real(0.0)))/denom)
                  )
                : Real(0.0);

            switch(strategy) {
              case Brent:
                return QuantLib::Brent().solve(*this, xTol, xInit, 1.0);
              case Newton:
                return QuantLib::Newton().solve(*this, xTol, xInit, 1.0);
              case Ridder:
                return QuantLib::Ridder().solve(*this, xTol, xInit, 1.0);
              case Halley:
                return QuantLib::Halley().solve(*this, xTol, xInit, 1.0);
              default:
                QL_FAIL("unknown strategy type");
            }
        }
    }

    SingleFactorBsmBasketEngine::SingleFactorBsmBasketEngine(
        std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > p,
        Real xTol)
      : xTol_(xTol),
        n_(p.size()), processes_(std::move(p)) {

        std::for_each(processes_.begin(), processes_.end(),
            [this](const auto& p) { registerWith(p); });
    }

    void SingleFactorBsmBasketEngine::calculate() const {
        const ext::shared_ptr<AverageBasketPayoff> avgPayoff =
            ext::dynamic_pointer_cast<AverageBasketPayoff>(arguments_.payoff);
        QL_REQUIRE(avgPayoff, "average basket payoff expected");
        const ext::shared_ptr<PlainVanillaPayoff> payoff =
             ext::dynamic_pointer_cast<PlainVanillaPayoff>(avgPayoff->basePayoff());
        QL_REQUIRE(payoff, "non-plain vanilla payoff given");
        const Real strike = payoff->strike();

        const Array weights = avgPayoff->weights();
        QL_REQUIRE(n_ == weights.size(),
             "wrong number of weights arguments in payoff");

        const ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(arguments_.exercise);
        QL_REQUIRE(exercise, "not an European exercise");
        const Date maturityDate = exercise->lastDate();

        const detail::VectorBsmProcessExtractor pExtractor(processes_);
        const Array s = pExtractor.getSpot();
        const Array dq = pExtractor.getDividendYieldDf(maturityDate);
        const DiscountFactor dr0 = pExtractor.getInterestRateDf(maturityDate);

        const Array stdDev = pExtractor.getBlackStdDev(maturityDate);
        const Array v = stdDev*stdDev;

        const Array fwdBasket = weights * s * dq /dr0;

        // first check if all vols are zero -> intrinsic case
        if (std::all_of(
                stdDev.begin(), stdDev.end(),
                [](Real x) -> bool { return close_enough(x, 0.0); }
            )) {
            results_.value = dr0*payoff->operator()(
                std::accumulate(fwdBasket.begin(), fwdBasket.end(), Real(0.0)));
        }
        else {
            const Real d = -detail::SumExponentialsRootSolver(
                fwdBasket*Exp(-0.5*v), stdDev, strike)
                    .getRoot(xTol_, detail::SumExponentialsRootSolver::Brent);

            const CumulativeNormalDistribution N;
            const Real cp = (payoff->optionType() == Option::Call) ? 1.0 : -1.0;

            results_.value = cp * dr0 *
                std::inner_product(
                    fwdBasket.begin(), fwdBasket.end(), stdDev.begin(),
                    Real(-strike*N(cp*d)),
                    std::plus<>(),
                    [d, cp, &N](Real x, Real y) -> Real { return x*N(cp*(d+y)); }
                );

            results_.additionalResults["d"] = d;
        }
    }
}

]]></document_content>
  </document>
  <document index="40">
    <source>basket/spreadblackscholesvanillaengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2024 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/basket/spreadblackscholesvanillaengine.hpp>

namespace QuantLib {

    SpreadBlackScholesVanillaEngine::SpreadBlackScholesVanillaEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
        Real correlation)
    : process1_(std::move(process1)),
      process2_(std::move(process2)),
      rho_(correlation) {
        registerWith(process1_);
        registerWith(process2_);
    }

    void SpreadBlackScholesVanillaEngine::calculate() const {
        const ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(arguments_.exercise);
        QL_REQUIRE(exercise, "not an European exercise");

        const ext::shared_ptr<SpreadBasketPayoff> spreadPayoff =
            ext::dynamic_pointer_cast<SpreadBasketPayoff>(arguments_.payoff);
        QL_REQUIRE(spreadPayoff," spread payoff expected");

        const ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                                                   spreadPayoff->basePayoff());
        QL_REQUIRE(payoff, "non-plain payoff given");
        const Real strike = payoff->strike();
        const Option::Type optionType = payoff->optionType();


        const Date maturityDate = exercise->lastDate();
        const Real f1 = process1_->stateVariable()->value()
            / process1_->riskFreeRate()->discount(maturityDate)
            * process1_->dividendYield()->discount(maturityDate);

        const Real f2 = process2_->stateVariable()->value()
            / process2_->riskFreeRate()->discount(maturityDate)
            * process2_->dividendYield()->discount(maturityDate);

        const Real variance1 =
            process1_->blackVolatility()->blackVariance(maturityDate, f1);
        const Real variance2 =
            process2_->blackVolatility()->blackVariance(maturityDate, f2);

        const DiscountFactor df =
            process1_->riskFreeRate()->discount(exercise->lastDate());

        results_.value = calculate(f1, f2, strike, optionType, variance1, variance2, df);
    }
}
]]></document_content>
  </document>
  <document index="41">
    <source>basket/stulzengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano
 Copyright (C) 2004 Neil Firth
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/pricingengines/basket/stulzengine.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        // calculate the value of euro min basket call
        Real euroTwoAssetMinBasketCall(Real forward1, Real forward2,
                                       Real strike,
                                       DiscountFactor riskFreeDiscount,
                                       Real variance1, Real variance2,
                                       Real rho) {

            Real stdDev1 = std::sqrt(variance1);
            Real stdDev2 = std::sqrt(variance2);

            Real variance = variance1 + variance2 - 2*rho*stdDev1*stdDev2;
            Real stdDev = std::sqrt(variance);

            Real modRho1 = (rho * stdDev2 - stdDev1) / stdDev;
            Real modRho2 = (rho * stdDev1 - stdDev2) / stdDev;

            Real D1 = (std::log(forward1/forward2) + 0.5*variance) / stdDev;

            Real alfa, beta, gamma;
            if (strike != 0.0) {
                auto bivCNorm =
                    BivariateCumulativeNormalDistribution(rho);
                auto bivCNormMod2 =
                    BivariateCumulativeNormalDistribution(modRho2);
                auto bivCNormMod1 =
                    BivariateCumulativeNormalDistribution(modRho1);

                Real D1_1 =
                    (std::log(forward1/strike) + 0.5*variance1) / stdDev1;
                Real D1_2 =
                    (std::log(forward2/strike) + 0.5*variance2) / stdDev2;
                alfa = bivCNormMod1(D1_1, -D1);
                beta = bivCNormMod2(D1_2, D1 - stdDev);
                gamma = bivCNorm(D1_1 - stdDev1, D1_2 - stdDev2);
            } else {
                CumulativeNormalDistribution cum;
                alfa = cum(-D1);
                beta = cum(D1 - stdDev);
                gamma = 1.0;
            }

            return riskFreeDiscount *
                (forward1*alfa + forward2*beta - strike*gamma);

        }

        // calculate the value of euro max basket call
        Real euroTwoAssetMaxBasketCall(Real forward1, Real forward2,
                                       Real strike,
                                       DiscountFactor riskFreeDiscount,
                                       Real variance1, Real variance2,
                                       Real rho) {

            ext::shared_ptr<StrikedTypePayoff> payoff(new
                PlainVanillaPayoff(Option::Call, strike));

            Real black1 = blackFormula(payoff->optionType(), payoff->strike(),
                forward1, std::sqrt(variance1)) * riskFreeDiscount;

            Real black2 = blackFormula(payoff->optionType(), payoff->strike(),
                forward2, std::sqrt(variance2)) * riskFreeDiscount;

            return black1 + black2 -
                euroTwoAssetMinBasketCall(forward1, forward2, strike,
                                          riskFreeDiscount,
                                          variance1, variance2, rho);
        }
    }

    StulzEngine::StulzEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
                             ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
                             Real correlation)
    : process1_(std::move(process1)), process2_(std::move(process2)), rho_(correlation) {
        registerWith(process1_);
        registerWith(process2_);
    }

    void StulzEngine::calculate() const {

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European Option");

        ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(arguments_.exercise);
        QL_REQUIRE(exercise, "not an European Option");

        ext::shared_ptr<BasketPayoff> basket_payoff =
            ext::dynamic_pointer_cast<BasketPayoff>(arguments_.payoff);

        ext::shared_ptr<MinBasketPayoff> min_basket =
            ext::dynamic_pointer_cast<MinBasketPayoff>(arguments_.payoff);

        ext::shared_ptr<MaxBasketPayoff> max_basket =
            ext::dynamic_pointer_cast<MaxBasketPayoff>(arguments_.payoff);
        QL_REQUIRE(min_basket || max_basket, "unknown basket type");

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(basket_payoff->basePayoff());
        QL_REQUIRE(payoff, "non-plain payoff given");

        Real strike = payoff->strike();

        Real variance1 = process1_->blackVolatility()->blackVariance(
                                                exercise->lastDate(), strike);
        Real variance2 = process2_->blackVolatility()->blackVariance(
                                                exercise->lastDate(), strike);

        DiscountFactor riskFreeDiscount =
            process1_->riskFreeRate()->discount(exercise->lastDate());

        // cannot handle non zero dividends, so don't believe this...
        DiscountFactor dividendDiscount1 =
            process1_->dividendYield()->discount(exercise->lastDate());
        DiscountFactor dividendDiscount2 =
            process2_->dividendYield()->discount(exercise->lastDate());

        Real forward1 = process1_->stateVariable()->value() *
            dividendDiscount1 / riskFreeDiscount;
        Real forward2 = process2_->stateVariable()->value() *
            dividendDiscount2 / riskFreeDiscount;

        if (max_basket != nullptr) {
            switch (payoff->optionType()) {
              // euro call on a two asset max basket
              case Option::Call:
                results_.value =
                    euroTwoAssetMaxBasketCall(forward1, forward2, strike,
                                              riskFreeDiscount,
                                              variance1, variance2,
                                              rho_);

                break;
              // euro put on a two asset max basket
              case Option::Put:
                results_.value = strike * riskFreeDiscount -
                    euroTwoAssetMaxBasketCall(forward1, forward2, 0.0,
                                              riskFreeDiscount,
                                              variance1, variance2, rho_) +
                    euroTwoAssetMaxBasketCall(forward1, forward2, strike,
                                              riskFreeDiscount,
                                              variance1, variance2, rho_);
                break;
              default:
                QL_FAIL("unknown option type");
            }
        } else if (min_basket != nullptr) {
            switch (payoff->optionType()) {
              // euro call on a two asset min basket
              case Option::Call:
                results_.value =
                    euroTwoAssetMinBasketCall(forward1, forward2, strike,
                                              riskFreeDiscount,
                                              variance1, variance2,
                                              rho_);
                break;
              // euro put on a two asset min basket
              case Option::Put:
                results_.value = strike * riskFreeDiscount -
                    euroTwoAssetMinBasketCall(forward1, forward2, 0.0,
                                              riskFreeDiscount,
                                              variance1, variance2, rho_) +
                    euroTwoAssetMinBasketCall(forward1, forward2, strike,
                                              riskFreeDiscount,
                                              variance1, variance2, rho_);
                break;
              default:
                QL_FAIL("unknown option type");
            }
        } else {
            QL_FAIL("unknown type");
        }
    }

}

]]></document_content>
  </document>
  <document index="42">
    <source>basket/vectorbsmprocessextractor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2024 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vectorbsmprocessextractor.cpp
*/
#include <ql/math/functional.hpp>
#include <ql/math/comparison.hpp>

#include <ql/pricingengines/basket/vectorbsmprocessextractor.hpp>

namespace QuantLib::detail {

        VectorBsmProcessExtractor::VectorBsmProcessExtractor(
            std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > p)
          : processes_(std::move(p)) {
        }

        Array VectorBsmProcessExtractor::extractProcesses(
            const std::function<Real(
                const ext::shared_ptr<GeneralizedBlackScholesProcess>&)>& f) const {

            Array x(processes_.size());
            std::transform(processes_.begin(), processes_.end(), x.begin(), f);

            return x;
        }

        DiscountFactor VectorBsmProcessExtractor::getInterestRateDf(
            const Date& maturityDate) const {
            const Array dr = extractProcesses(
                [maturityDate](const auto& p) -> DiscountFactor {
                    return p->riskFreeRate()->discount(maturityDate);
                }
            );

            QL_REQUIRE(
                std::equal(
                    dr.begin()+1, dr.end(), dr.begin(),
                    [](Real a, Real b) -> bool { return close_enough(a, b);}
                ),
                "interest rates need to be the same for all underlyings"
            );

            return dr[0];
        }

        Array VectorBsmProcessExtractor::getSpot() const {
            return extractProcesses([](const auto& p) -> Real { return p->x0(); });
        }

        Array VectorBsmProcessExtractor::getDividendYieldDf(
            const Date& maturityDate) const {
            return extractProcesses(
                [maturityDate](const auto& p) -> DiscountFactor {
                    return p->dividendYield()->discount(maturityDate);
                }
            );
        }

        Array VectorBsmProcessExtractor::getBlackVariance(
            const Date& maturityDate) const {
            return extractProcesses(
                [maturityDate](const auto& p) -> Volatility {
                    return p->blackVolatility()->blackVariance(maturityDate, p->x0());
                }
            );
        }

        Array VectorBsmProcessExtractor::getBlackStdDev(
            const Date& maturityDate) const {
            return extractProcesses(
                [maturityDate](const auto& p) -> Volatility {
                    const Time maturity = p->blackVolatility()->timeFromReference(maturityDate);
                    return p->blackVolatility()->blackVol(maturityDate, p->x0())*std::sqrt(maturity);
                }
            );
        }

}

]]></document_content>
  </document>
  <document index="43">
    <source>blackcalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004, 2005, 2006 Ferdinando Ametrano
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/comparison.hpp>

namespace QuantLib {

    class BlackCalculator::Calculator : public AcyclicVisitor,
                                        public Visitor<Payoff>,
                                        public Visitor<PlainVanillaPayoff>,
                                        public Visitor<CashOrNothingPayoff>,
                                        public Visitor<AssetOrNothingPayoff>,
                                        public Visitor<GapPayoff> {
      private:
        BlackCalculator& black_;
      public:
        explicit Calculator(BlackCalculator& black) : black_(black) {}
        void visit(Payoff&) override;
        void visit(PlainVanillaPayoff&) override;
        void visit(CashOrNothingPayoff&) override;
        void visit(AssetOrNothingPayoff&) override;
        void visit(GapPayoff&) override;
    };


    BlackCalculator::BlackCalculator(const ext::shared_ptr<StrikedTypePayoff>& p,
                                     Real forward,
                                     Real stdDev,
                                     Real discount)
    : strike_(p->strike()), forward_(forward), stdDev_(stdDev),
      discount_(discount), variance_(stdDev*stdDev) {
        initialize(p);
    }

    BlackCalculator::BlackCalculator(Option::Type optionType,
                                     Real strike,
                                     Real forward,
                                     Real stdDev,
                                     Real discount)
    : strike_(strike), forward_(forward), stdDev_(stdDev),
      discount_(discount), variance_(stdDev*stdDev) {
        initialize(ext::shared_ptr<StrikedTypePayoff>(new
            PlainVanillaPayoff(optionType, strike)));
    }

    void BlackCalculator::initialize(const ext::shared_ptr<StrikedTypePayoff>& p) {
        QL_REQUIRE(strike_>=0.0,
                   "strike (" << strike_ << ") must be non-negative");
        QL_REQUIRE(forward_>0.0,
                   "forward (" << forward_ << ") must be positive");
        //QL_REQUIRE(displacement_>=0.0,
        //           "displacement (" << displacement_ << ") must be non-negative");
        QL_REQUIRE(stdDev_>=0.0,
                   "stdDev (" << stdDev_ << ") must be non-negative");
        QL_REQUIRE(discount_>0.0,
                   "discount (" << discount_ << ") must be positive");

        if (stdDev_>=QL_EPSILON) {
            if (close(strike_, 0.0)) {
                d1_ = QL_MAX_REAL;
                d2_ = QL_MAX_REAL;
                cum_d1_ = 1.0;
                cum_d2_ = 1.0;
                n_d1_ = 0.0;
                n_d2_ = 0.0;
            } else {
                d1_ = std::log(forward_/strike_)/stdDev_ + 0.5*stdDev_;
                d2_ = d1_-stdDev_;
                CumulativeNormalDistribution f;
                cum_d1_ = f(d1_);
                cum_d2_ = f(d2_);
                n_d1_ = f.derivative(d1_);
                n_d2_ = f.derivative(d2_);
            }
        } else {
            if (close(forward_, strike_)) {
                d1_ = 0;
                d2_ = 0;
                cum_d1_ = 0.5;
                cum_d2_ = 0.5;
                n_d1_ = M_SQRT_2 * M_1_SQRTPI;
                n_d2_ = M_SQRT_2 * M_1_SQRTPI;
            } else if (forward_>strike_) {
                d1_ = QL_MAX_REAL;
                d2_ = QL_MAX_REAL;
                cum_d1_ = 1.0;
                cum_d2_ = 1.0;
                n_d1_ = 0.0;
                n_d2_ = 0.0;
            } else {
                d1_ = QL_MIN_REAL;
                d2_ = QL_MIN_REAL;
                cum_d1_ = 0.0;
                cum_d2_ = 0.0;
                n_d1_ = 0.0;
                n_d2_ = 0.0;
            }
        }

        x_ = strike_;
        DxDstrike_ = 1.0;

        // the following one will probably disappear as soon as
        // super-share will be properly handled
        DxDs_ = 0.0;

        // this part is always executed.
        // in case of plain-vanilla payoffs, it is also the only part
        // which is executed.
        switch (p->optionType()) {
          case Option::Call:
            alpha_     =  cum_d1_;//  N(d1)
            DalphaDd1_ =    n_d1_;//  n(d1)
            beta_      = -cum_d2_;// -N(d2)
            DbetaDd2_  = -  n_d2_;// -n(d2)
            break;
          case Option::Put:
            alpha_     = -1.0+cum_d1_;// -N(-d1)
            DalphaDd1_ =        n_d1_;//  n( d1)
            beta_      =  1.0-cum_d2_;//  N(-d2)
            DbetaDd2_  =     -  n_d2_;// -n( d2)
            break;
          default:
            QL_FAIL("invalid option type");
        }

        // now dispatch on type.

        Calculator calc(*this);
        p->accept(calc);
    }

    void BlackCalculator::Calculator::visit(Payoff& p) {
        QL_FAIL("unsupported payoff type: " << p.name());
    }

    void BlackCalculator::Calculator::visit(PlainVanillaPayoff&) {}

    void BlackCalculator::Calculator::visit(CashOrNothingPayoff& payoff) {
        black_.alpha_ = black_.DalphaDd1_ = 0.0;
        black_.x_ = payoff.cashPayoff();
        black_.DxDstrike_ = 0.0;
        switch (payoff.optionType()) {
          case Option::Call:
            black_.beta_     = black_.cum_d2_;
            black_.DbetaDd2_ = black_.n_d2_;
            break;
          case Option::Put:
            black_.beta_     = 1.0-black_.cum_d2_;
            black_.DbetaDd2_ =    -black_.n_d2_;
            break;
          default:
            QL_FAIL("invalid option type");
        }
    }

    void BlackCalculator::Calculator::visit(AssetOrNothingPayoff& payoff) {
        black_.beta_ = black_.DbetaDd2_ = 0.0;
        switch (payoff.optionType()) {
          case Option::Call:
            black_.alpha_     = black_.cum_d1_;
            black_.DalphaDd1_ = black_.n_d1_;
            break;
          case Option::Put:
            black_.alpha_     = 1.0-black_.cum_d1_;
            black_.DalphaDd1_ = -black_.n_d1_;
            break;
          default:
            QL_FAIL("invalid option type");
        }
    }

    void BlackCalculator::Calculator::visit(GapPayoff& payoff) {
        black_.x_ = payoff.secondStrike();
        black_.DxDstrike_ = 0.0;
    }

    Real BlackCalculator::value() const {
        Real result = discount_ * (forward_ * alpha_ + x_ * beta_);
        return result;
    }

    Real BlackCalculator::delta(Real spot) const {

        QL_REQUIRE(spot > 0.0, "positive spot value required: " <<
                   spot << " not allowed");

        // Handle zero volatility case
        if (stdDev_ <= QL_EPSILON) {
            // For zero volatility, delta is:
            // ITM Call: 1.0, OTM Call: 0.0, ATM Call: 0.5
            // ITM Put: -1.0, OTM Put: 0.0, ATM Put: -0.5
            Real DforwardDs = forward_ / spot;
            if (close(forward_, strike_)) {
                // ATM case
                if (alpha_ >= 0) { // Call
                    return discount_ * 0.5 * DforwardDs;
                } else { // Put
                    return discount_ * (-0.5) * DforwardDs;
                }
            } else if (forward_ > strike_) {
                // ITM Call, OTM Put
                if (alpha_ >= 0) { // Call
                    return discount_ * 1.0 * DforwardDs;
                } else { // Put  
                    return 0.0;
                }
            } else {
                // OTM Call, ITM Put
                if (alpha_ >= 0) { // Call
                    return 0.0;
                } else { // Put
                    return discount_ * (-1.0) * DforwardDs;
                }
            }
        }

        Real DforwardDs = forward_ / spot;

        Real temp = stdDev_*spot;
        Real DalphaDs = DalphaDd1_/temp;
        Real DbetaDs  = DbetaDd2_/temp;
        Real temp2 = DalphaDs * forward_ + alpha_ * DforwardDs
                      +DbetaDs  * x_       + beta_  * DxDs_;

        return discount_ * temp2;
    }

    Real BlackCalculator::deltaForward() const {

        // Handle zero volatility case
        if (stdDev_ <= QL_EPSILON) {
            // For zero volatility, forward delta is:
            // ITM Call: 1.0, OTM Call: 0.0, ATM Call: 0.5
            // ITM Put: -1.0, OTM Put: 0.0, ATM Put: -0.5
            if (close(forward_, strike_)) {
                // ATM case
                if (alpha_ >= 0) { // Call
                    return discount_ * 0.5;
                } else { // Put
                    return discount_ * (-0.5);
                }
            } else if (forward_ > strike_) {
                // ITM Call, OTM Put
                if (alpha_ >= 0) { // Call
                    return discount_ * 1.0;
                } else { // Put
                    return 0.0;
                }
            } else {
                // OTM Call, ITM Put
                if (alpha_ >= 0) { // Call
                    return 0.0;
                } else { // Put
                    return discount_ * (-1.0);
                }
            }
        }

        Real temp = stdDev_*forward_;
        Real DalphaDforward = DalphaDd1_/temp;
        Real DbetaDforward  = DbetaDd2_/temp;
        Real temp2 = DalphaDforward * forward_ + alpha_
                      +DbetaDforward  * x_; // DXDforward = 0.0

        return discount_ * temp2;
    }

    Real BlackCalculator::elasticity(Real spot) const {
        Real val = value();
        Real del = delta(spot);
        if (val>QL_EPSILON)
            return del/val*spot;
        else if (std::fabs(del)<QL_EPSILON)
            return 0.0;
        else if (del>0.0)
            return QL_MAX_REAL;
        else
            return QL_MIN_REAL;
    }

    Real BlackCalculator::elasticityForward() const {
        Real val = value();
        Real del = deltaForward();
        if (val>QL_EPSILON)
            return del/val*forward_;
        else if (std::fabs(del)<QL_EPSILON)
            return 0.0;
        else if (del>0.0)
            return QL_MAX_REAL;
        else
            return QL_MIN_REAL;
    }

    Real BlackCalculator::gamma(Real spot) const {

        QL_REQUIRE(spot > 0.0, "positive spot value required: " <<
                   spot << " not allowed");

        // Handle zero volatility case
        if (stdDev_ <= QL_EPSILON) {
            // For zero volatility, gamma is always 0 (no convexity)
            return 0.0;
        }

        Real DforwardDs = forward_ / spot;

        Real temp = stdDev_*spot;
        Real DalphaDs = DalphaDd1_/temp;
        Real DbetaDs  = DbetaDd2_/temp;

        Real D2alphaDs2 = - DalphaDs/spot*(1+d1_/stdDev_);
        Real D2betaDs2  = - DbetaDs /spot*(1+d2_/stdDev_);

        Real temp2 = D2alphaDs2 * forward_ + 2.0 * DalphaDs * DforwardDs
                      +D2betaDs2  * x_       + 2.0 * DbetaDs  * DxDs_;

        return  discount_ * temp2;
    }

    Real BlackCalculator::gammaForward() const {

        // Handle zero volatility case
        if (stdDev_ <= QL_EPSILON) {
            // For zero volatility, gamma is always 0 (no convexity)
            return 0.0;
        }

        Real temp = stdDev_*forward_;
        Real DalphaDforward = DalphaDd1_/temp;
        Real DbetaDforward  = DbetaDd2_/temp;

        Real D2alphaDforward2 = - DalphaDforward/forward_*(1+d1_/stdDev_);
        Real D2betaDforward2  = - DbetaDforward /forward_*(1+d2_/stdDev_);

        Real temp2 = D2alphaDforward2 * forward_ + 2.0 * DalphaDforward
                      +D2betaDforward2  * x_; // DXDforward = 0.0

        return discount_ * temp2;
    }

    Real BlackCalculator::theta(Real spot,
                                Time maturity) const {

        QL_REQUIRE(maturity>=0.0,
                   "maturity (" << maturity << ") must be non-negative");
        if (close(maturity, 0.0)) return 0.0;
        return -( std::log(discount_)            * value()
                 +std::log(forward_/spot) * spot * delta(spot)
                 +0.5*variance_ * spot  * spot * gamma(spot))/maturity;
    }

    Real BlackCalculator::vega(Time maturity) const {
        QL_REQUIRE(maturity>=0.0,
                   "negative maturity not allowed");

        // Handle zero volatility case
        if (stdDev_ <= QL_EPSILON) {
            return 0.0;
        }

        Real temp = std::log(strike_/forward_)/variance_;
        // actually DalphaDsigma / SQRT(T)
        Real DalphaDsigma = DalphaDd1_*(temp+0.5);
        Real DbetaDsigma  = DbetaDd2_ *(temp-0.5);

        Real temp2 = DalphaDsigma * forward_ + DbetaDsigma * x_;

        return discount_ * std::sqrt(maturity) * temp2;
    }

    Real BlackCalculator::rho(Time maturity) const {
        QL_REQUIRE(maturity>=0.0,
                   "negative maturity not allowed");

        // Handle zero volatility case
        if (stdDev_ <= QL_EPSILON) {
            // For zero volatility, rho = T * (delta_forward * forward - value/discount)
            Real deltaFwd = deltaForward();
            return maturity * (deltaFwd * forward_ - value());
        }

        // actually DalphaDr / T
        Real DalphaDr = DalphaDd1_/stdDev_;
        Real DbetaDr  = DbetaDd2_/stdDev_;
        Real temp = DalphaDr * forward_ + alpha_ * forward_ + DbetaDr * x_;

        return maturity * (discount_ * temp - value());
    }

    Real BlackCalculator::dividendRho(Time maturity) const {
        QL_REQUIRE(maturity>=0.0,
                   "negative maturity not allowed");

        // Handle zero volatility case
        if (stdDev_ <= QL_EPSILON) {
            // For zero volatility, dividend rho = -T * discount * delta_forward * forward
            Real deltaFwd = deltaForward() / discount_;  // Remove discount to get pure delta
            return -maturity * discount_ * deltaFwd * forward_;
        }

        // actually DalphaDq / T
        Real DalphaDq = -DalphaDd1_/stdDev_;
        Real DbetaDq  = -DbetaDd2_/stdDev_;

        Real temp = DalphaDq * forward_ - alpha_ * forward_ + DbetaDq * x_;

        return maturity * discount_ * temp;
    }

    Real BlackCalculator::strikeSensitivity() const {

        // Handle zero volatility case  
        if (stdDev_ <= QL_EPSILON) {
            // For zero volatility, strike sensitivity is:
            // Call: -N(d2) where d2 -> 1 (ITM), 0 (OTM), 0.5 (ATM)
            // Put: N(-d2) = 1 - N(d2)
            if (close(forward_, strike_)) {
                // ATM case
                if (alpha_ >= 0) { // Call
                    return -discount_ * 0.5;
                } else { // Put
                    return discount_ * 0.5;
                }
            } else if (forward_ > strike_) {
                // ITM Call, OTM Put
                if (alpha_ >= 0) { // Call
                    return -discount_ * 1.0;
                } else { // Put
                    return discount_ * 0.0;
                }
            } else {
                // OTM Call, ITM Put
                if (alpha_ >= 0) { // Call
                    return -discount_ * 0.0;
                } else { // Put
                    return discount_ * 1.0;
                }
            }
        }

        Real temp = stdDev_*strike_;
        Real DalphaDstrike = -DalphaDd1_/temp;
        Real DbetaDstrike  = -DbetaDd2_/temp;

        Real temp2 =
            DalphaDstrike * forward_ + DbetaDstrike * x_ + beta_ * DxDstrike_;

        return discount_ * temp2;
    }


    Real BlackCalculator::strikeGamma() const {

        // Handle zero volatility case
        if (stdDev_ <= QL_EPSILON) {
            // For zero volatility, strike gamma is 0 (no convexity)
            return 0.0;
        }

        Real temp = stdDev_*strike_;
        Real DalphaDstrike = -DalphaDd1_/temp;
        Real DbetaDstrike  = -DbetaDd2_/temp;

        Real D2alphaD2strike = -DalphaDstrike/strike_*(1-d1_/stdDev_);
        Real D2betaD2strike  = -DbetaDstrike /strike_*(1-d2_/stdDev_);

        Real temp2 =
                D2alphaD2strike * forward_ + D2betaD2strike * x_
                + 2.0*DbetaDstrike *DxDstrike_;

        return discount_ * temp2;
    }

    //! Sensitivity of vega to spot (Vanna)
    Real BlackCalculator::vanna(Real spot, Time maturity) const {
        QL_REQUIRE(spot > 0.0, "positive spot value required: " << spot << " not allowed");
        QL_REQUIRE(maturity >= 0.0, "negative maturity not allowed");

        if (stdDev_ <= QL_EPSILON) {
            return 0.0;
        }

        // Calculate Vega
        Real vega = this->vega(maturity);

        // d2 = d1 - stdDev_
        // Vanna = -d2 / (spot * stdDev_) * Vega
        return -d2_ / (spot * stdDev_) * vega;
    }

    //! Sensitivity of vega to volatility (Volga/Vomma)
    Real BlackCalculator::volga(Time maturity) const {
        QL_REQUIRE(maturity >= 0.0, "negative maturity not allowed");

        if (stdDev_ <= QL_EPSILON) {
            return 0.0;
        }

        // Calculate Vega
        Real vega = this->vega(maturity);

        // Volga = Vega * d1 * d2 / stdDev_
        return vega * d1_ * d2_ / stdDev_;
    }
}
]]></document_content>
  </document>
  <document index="44">
    <source>blackdeltacalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/blackdeltacalculator.hpp>

namespace QuantLib {

    QL_DEPRECATED_DISABLE_WARNING

    BlackDeltaCalculator::BlackDeltaCalculator(
                        Option::Type ot,
                        DeltaVolQuote::DeltaType dt,
                        Real spot,
                        DiscountFactor dDiscount,   // domestic discount
                        DiscountFactor fDiscount,   // foreign  discount
                        Real stdDev):
    dt_(dt), ot_(ot),
    dDiscount_(dDiscount), fDiscount_(fDiscount),
    stdDev_(stdDev), spot_(spot),
    forward_(spot*fDiscount/dDiscount), phi_(Integer(ot)) {

        QL_REQUIRE(spot_>0.0,
                   "positive spot value required: " <<
                   spot_ << " not allowed");
        QL_REQUIRE(dDiscount_>0.0,
                   "positive domestic discount factor required: " <<
                   dDiscount_ << " not allowed");
        QL_REQUIRE(fDiscount_>0.0,
                   "positive foreign discount factor required: " <<
                   fDiscount_ << " not allowed");
        QL_REQUIRE(stdDev_>=0.0,
                   "non-negative standard deviation required: "
                   << stdDev_ << " not allowed");

        fExpPos_    = forward_ * std::exp(0.5 * stdDev_ * stdDev_);
        fExpNeg_    = forward_ * std::exp(-0.5 * stdDev_ * stdDev_);
    }


    Real BlackDeltaCalculator::deltaFromStrike(Real strike) const {

        QL_REQUIRE(strike >=0.0,
                   "positive strike value required: " <<
                   strike << " not allowed");

        Real res = 0.0;

        switch(dt_){
          case DeltaVolQuote::Spot:
            res = phi_ * fDiscount_ * cumD1(strike);
            break;

          case DeltaVolQuote::Fwd:
            res = phi_ * cumD1(strike);
            break;

          case DeltaVolQuote::PaSpot:
            res = phi_ * fDiscount_ * cumD2(strike) * strike / forward_;
            break;

          case DeltaVolQuote::PaFwd:
            res = phi_ * cumD2(strike) * strike/  forward_;
            break;

          default:
            QL_FAIL("invalid delta type");
        }
        return res;
    }

    Real BlackDeltaCalculator::strikeFromDelta(Real delta) const {
        return(strikeFromDelta(delta, dt_));
    }

    Real BlackDeltaCalculator::strikeFromDelta(Real delta,
                                               DeltaVolQuote::DeltaType dt)
                                                                        const{
        Real res = 0.0;
        Real arg = 0.0;
        InverseCumulativeNormal invNorm;

        QL_REQUIRE(delta*phi_ >= 0.0, "Option type and delta are incoherent.");

        switch (dt) {
          case DeltaVolQuote::Spot:
            QL_REQUIRE(std::fabs(delta)<=fDiscount_,
                       "Spot delta out of range.");

            arg = -phi_ * invNorm(phi_ * delta / fDiscount_) * stdDev_ + 0.5 * stdDev_ * stdDev_;
            res = forward_ * std::exp(arg);
            break;

          case DeltaVolQuote::Fwd:
            QL_REQUIRE(std::fabs(delta)<=1.0,
                       "Forward delta out of range.");

            arg = -phi_ * invNorm(phi_ * delta) * stdDev_ + 0.5 * stdDev_ * stdDev_;
            res = forward_ * std::exp(arg);
            break;

          case DeltaVolQuote::PaSpot:
          case DeltaVolQuote::PaFwd: {
              // This has to be solved numerically. One of the
              // problems is that the premium adjusted call delta is
              // not monotonic in strike, such that two solutions
              // might occur. The one right to the max of the delta is
              // considered to be the correct strike.  Some proper
              // interval bounds for the strike need to be chosen, the
              // numerics can otherwise be very unreliable and
              // unstable.  I've chosen Brent over Newton, since the
              // interval can be specified explicitly and we can not
              // run into the area on the left of the maximum.  The
              // put delta doesn't have this property and can be
              // solved without any problems, but also numerically.
              auto f = [&](Real strike) {
                return deltaFromStrike(strike) - delta;
              };

              Brent solver;
              solver.setMaxEvaluations(1000);
              Real accuracy = 1.0e-10;

              Real rightLimit = 0.0;
              Real leftLimit = 0.0;

              // Strike of not premium adjusted is always to the right of premium adjusted
              if (dt == DeltaVolQuote::PaSpot) {
                  rightLimit = strikeFromDelta(delta, DeltaVolQuote::Spot);
              } else {
                  rightLimit = strikeFromDelta(delta, DeltaVolQuote::Fwd);
              }

              if (phi_ < 0) { // if put
                  res = solver.solve(f, accuracy, rightLimit, 0.0, spot_*100.0);
                  break;
              } else {

                  // find out the left limit which is the strike
                  // corresponding to the value where premium adjusted
                  // deltas have their maximum
                  auto g = [&](Real strike) {
                    return cumD2(strike) * stdDev_ - nD2(strike);
                  };

                  leftLimit = solver.solve(g, accuracy, rightLimit * 0.5,
                                         0.0, rightLimit);

                  Real guess = leftLimit+(rightLimit - leftLimit) * 0.5;

                  res = solver.solve(f, accuracy, guess, leftLimit, rightLimit);
              } // end if phi<0 else

              break;
          }

          default:
            QL_FAIL("invalid delta type");
        }

        return res;
    }

    Real BlackDeltaCalculator::atmStrike(DeltaVolQuote::AtmType atmT) const {

        Real res = 0.0;

        switch(atmT) {
          case DeltaVolQuote::AtmSpot:
            res = spot_;
            break;

          case DeltaVolQuote::AtmDeltaNeutral:
            if(dt_ == DeltaVolQuote::Spot || dt_ == DeltaVolQuote::Fwd){
                res = fExpPos_;
            } else {
                res = fExpNeg_;
            }
            break;

          case DeltaVolQuote::AtmFwd:
            res = forward_;
            break;

          case DeltaVolQuote::AtmGammaMax: case DeltaVolQuote::AtmVegaMax:
            res = fExpPos_;
            break;

          case DeltaVolQuote::AtmPutCall50:
            QL_REQUIRE(dt_ == DeltaVolQuote::Fwd,
                       "|PutDelta|=CallDelta=0.50 only possible for forward delta.");
            res = fExpPos_;
            break;

          default:
            QL_FAIL("invalid atm type");
        }

        return res;
    }


    Real BlackDeltaCalculator::cumD1(Real strike) const {

        Real d1_=0.0;
        Real cum_d1_pos_ = 1.0; // N(d1)
        Real cum_d1_neg_ = 0.0; // N(-d1)

        CumulativeNormalDistribution f;

        if (stdDev_>=QL_EPSILON) {
            if(strike>0) {
                d1_ = std::log(forward_/strike)/stdDev_ + 0.5*stdDev_;
                return f(phi_*d1_);
            }
        } else {
            if (forward_<strike) {
                cum_d1_pos_ = 0.0;
                cum_d1_neg_ = 1.0;
            } else if(forward_==strike){
                d1_ = 0.5*stdDev_;
                return f(phi_*d1_);
            }
        }

        if (phi_>0) { // if Call
            return cum_d1_pos_;
        } else {
            return cum_d1_neg_;
        }
    }


    Real BlackDeltaCalculator::nD1(Real strike) const {

        Real d1_=0.0;
        Real n_d1_ = 0.0; // n(d1)

        if (stdDev_>=QL_EPSILON){
            if(strike>0){
                d1_ = std::log(forward_/strike)/stdDev_ + 0.5*stdDev_;
                CumulativeNormalDistribution f;
                n_d1_ = f.derivative(d1_);
            }
        }

        return n_d1_;
    }


    Real BlackDeltaCalculator::cumD2(Real strike) const {

        Real d2_=0.0;
        Real cum_d2_pos_= 1.0;  // N(d2)
        Real cum_d2_neg_= 0.0;  // N(-d2)

        CumulativeNormalDistribution f;

        if (stdDev_>=QL_EPSILON){

            if(strike>0){
                d2_ = std::log(forward_/strike)/stdDev_ - 0.5*stdDev_;
                return f(phi_*d2_);
            }

        } else {

            if (forward_<strike) {
                cum_d2_pos_= 0.0;
                cum_d2_neg_= 1.0;
            } else if (forward_==strike) {
                d2_ = -0.5*stdDev_;
                return(f(phi_*d2_));
            }

        }

        if (phi_>0) { // if Call
            return cum_d2_pos_;
        } else {
            return cum_d2_neg_;
        }
    }


    Real BlackDeltaCalculator::nD2(Real strike) const {

        Real d2_=0.0;
        Real n_d2_= 0.0; // n(d2)

        if (stdDev_>=QL_EPSILON){
            if(strike>0){
                d2_ = std::log(forward_/strike)/stdDev_ - 0.5*stdDev_;
                CumulativeNormalDistribution f;
                n_d2_ = f.derivative(d2_);
            }
        }

        return n_d2_;
    }


    void BlackDeltaCalculator::setDeltaType(DeltaVolQuote::DeltaType dt){
        dt_=dt;
    }

    void BlackDeltaCalculator::setOptionType(Option::Type ot){
        ot_=ot;
        phi_=Integer(ot_);
    }


    // helper classes

    BlackDeltaPremiumAdjustedSolverClass::BlackDeltaPremiumAdjustedSolverClass(
                        Option::Type ot,
                        DeltaVolQuote::DeltaType dt,
                        Real spot,
                        DiscountFactor dDiscount,   // domestic discount
                        DiscountFactor fDiscount,   // foreign  discount
                        Real stdDev,
                        Real delta):
    bdc_(ot,dt,spot,dDiscount,fDiscount,stdDev), delta_(delta) {}


    Real BlackDeltaPremiumAdjustedSolverClass::operator()(Real strike) const {
        return bdc_.deltaFromStrike(strike)-delta_;
    }


    BlackDeltaPremiumAdjustedMaxStrikeClass::BlackDeltaPremiumAdjustedMaxStrikeClass(
                        Option::Type ot,
                        DeltaVolQuote::DeltaType dt,
                        Real spot,
                        DiscountFactor dDiscount,   // domestic discount
                        DiscountFactor fDiscount,   // foreign  discount
                        Real stdDev):
    bdc_(ot,dt,spot,dDiscount,fDiscount,stdDev), stdDev_(stdDev) {}

    Real BlackDeltaPremiumAdjustedMaxStrikeClass::operator()(Real strike) const {
        return bdc_.cumD2(strike)*stdDev_ - bdc_.nD2(strike);
    }

    QL_DEPRECATED_ENABLE_WARNING
}
]]></document_content>
  </document>
  <document index="45">
    <source>blackformula.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2012 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi
 Copyright (C) 2006 StatPro Italia srl
 Copyright (C) 2007 Cristina Duminuco
 Copyright (C) 2007 Chiara Fornarola
 Copyright (C) 2013 Gary Kennedy
 Copyright (C) 2015, 2024 Peter Caspers
 Copyright (C) 2017 Klaus Spanderen
 Copyright (C) 2019 Wojciech Ślusarski
 Copyright (C) 2020 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/blackformula.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/solvers1d/newtonsafe.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <boost/math/distributions/normal.hpp>
#include <boost/math/special_functions/fpclassify.hpp>
#include <boost/math/special_functions/atanh.hpp>
#include <boost/math/special_functions/sign.hpp>

namespace {
    void checkParameters(QuantLib::Real strike,
                         QuantLib::Real forward,
                         QuantLib::Real displacement)
    {
        QL_REQUIRE(displacement >= 0.0, "displacement ("
                                            << displacement
                                            << ") must be non-negative");
        QL_REQUIRE(strike + displacement >= 0.0,
                   "strike + displacement (" << strike << " + " << displacement
                                             << ") must be non-negative");
        QL_REQUIRE(forward + displacement > 0.0, "forward + displacement ("
                                                     << forward << " + "
                                                     << displacement
                                                     << ") must be positive");
    }
}

namespace QuantLib {

    Real blackFormula(Option::Type optionType,
                      Real strike,
                      Real forward,
                      Real stdDev,
                      Real discount,
                      Real displacement)
    {
        checkParameters(strike, forward, displacement);
        QL_REQUIRE(stdDev>=0.0,
                   "stdDev (" << stdDev << ") must be non-negative");
        QL_REQUIRE(discount>0.0,
                   "discount (" << discount << ") must be positive");

        auto sign = Integer(optionType);

        if (stdDev == 0.0)
            return std::max((forward-strike) * sign, Real(0.0)) * discount;

        forward = forward + displacement;
        strike = strike + displacement;

        // since displacement is non-negative strike==0 iff displacement==0
        // so returning forward*discount is OK
        if (strike==0.0)
            return (optionType==Option::Call ? Real(forward*discount) : 0.0);

        Real d1 = std::log(forward/strike)/stdDev + 0.5*stdDev;
        Real d2 = d1 - stdDev;
        CumulativeNormalDistribution phi;
        Real nd1 = phi(sign * d1);
        Real nd2 = phi(sign * d2);
        Real result = discount * sign * (forward*nd1 - strike*nd2);
        QL_ENSURE(result>=0.0,
                  "negative value (" << result << ") for " <<
                  stdDev << " stdDev, " <<
                  optionType << " option, " <<
                  strike << " strike , " <<
                  forward << " forward");
        return result;
    }

    Real blackFormula(const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                      Real forward,
                      Real stdDev,
                      Real discount,
                      Real displacement) {
        return blackFormula(payoff->optionType(),
            payoff->strike(), forward, stdDev, discount, displacement);
    }

    Real blackFormulaForwardDerivative(Option::Type optionType,
                                       Real strike,
                                       Real forward,
                                       Real stdDev,
                                       Real discount,
                                       Real displacement)
    {
        checkParameters(strike, forward, displacement);
        QL_REQUIRE(stdDev>=0.0,
                   "stdDev (" << stdDev << ") must be non-negative");
        QL_REQUIRE(discount>0.0,
                   "discount (" << discount << ") must be positive");

        auto sign = Integer(optionType);

        if (stdDev == 0.0)
            return sign * std::max(1.0 * boost::math::sign((forward - strike) * sign), 0.0) * discount;

        forward = forward + displacement;
        strike = strike + displacement;

        if (strike == 0.0)
            return (optionType == Option::Call ? discount : 0.0);

        Real d1 = std::log(forward/strike)/stdDev + 0.5*stdDev;
        CumulativeNormalDistribution phi;
        return sign * phi(sign * d1) * discount;
    }

    Real blackFormulaForwardDerivative(const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                                       Real forward,
                                       Real stdDev,
                                       Real discount,
                                       Real displacement) 
    {
        return blackFormulaForwardDerivative(payoff->optionType(),
            payoff->strike(), forward, stdDev, discount, displacement);
    }

    Real blackFormulaImpliedStdDevApproximation(Option::Type optionType,
                                                Real strike,
                                                Real forward,
                                                Real blackPrice,
                                                Real discount,
                                                Real displacement)
    {
        checkParameters(strike, forward, displacement);
        QL_REQUIRE(blackPrice>=0.0,
                   "blackPrice (" << blackPrice << ") must be non-negative");
        QL_REQUIRE(discount>0.0,
                   "discount (" << discount << ") must be positive");

        Real stdDev;
        forward = forward + displacement;
        strike = strike + displacement;
        if (strike==forward)
            // Brenner-Subrahmanyan (1988) and Feinstein (1988) ATM approx.
            stdDev = blackPrice/discount*std::sqrt(2.0 * M_PI)/forward;
        else {
            // Corrado and Miller extended moneyness approximation
            Real moneynessDelta = Integer(optionType) * (forward-strike);
            Real moneynessDelta_2 = moneynessDelta/2.0;
            Real temp = blackPrice/discount - moneynessDelta_2;
            Real moneynessDelta_PI = moneynessDelta*moneynessDelta/M_PI;
            Real temp2 = temp*temp-moneynessDelta_PI;
            if (temp2<0.0) // approximation breaks down, 2 alternatives:
                // 1. zero it
                temp2=0.0;
                // 2. Manaster-Koehler (1982) efficient Newton-Raphson seed
                //return std::fabs(std::log(forward/strike))*std::sqrt(2.0);
            temp2 = std::sqrt(temp2);
            temp += temp2;
            temp *= std::sqrt(2.0 * M_PI);
            stdDev = temp/(forward+strike);
        }
        QL_ENSURE(stdDev>=0.0,
                  "stdDev (" << stdDev << ") must be non-negative");
        return stdDev;
    }

    Real blackFormulaImpliedStdDevApproximation(
                      const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                      Real forward,
                      Real blackPrice,
                      Real discount,
                      Real displacement) {
        return blackFormulaImpliedStdDevApproximation(payoff->optionType(),
            payoff->strike(), forward, blackPrice, discount, displacement);
    }

    Real blackFormulaImpliedStdDevChambers(Option::Type optionType,
                                                Real strike,
                                                Real forward,
                                                Real blackPrice,
                                                Real blackAtmPrice,
                                                Real discount,
                                                Real displacement) {
        checkParameters(strike, forward, displacement);
        QL_REQUIRE(blackPrice >= 0.0,
                   "blackPrice (" << blackPrice << ") must be non-negative");
        QL_REQUIRE(blackAtmPrice >= 0.0, "blackAtmPrice ("
                                             << blackAtmPrice
                                             << ") must be non-negative");
        QL_REQUIRE(discount > 0.0, "discount (" << discount
                                                << ") must be positive");

        Real stdDev;

        forward = forward + displacement;
        strike = strike + displacement;
        blackPrice /= discount;
        blackAtmPrice /= discount;

        Real s0 = M_SQRT2 * M_SQRTPI * blackAtmPrice /
                  forward; // Brenner-Subrahmanyam formula
        Real priceAtmVol =
            blackFormula(optionType, strike, forward, s0, 1.0, 0.0);
        Real dc = blackPrice - priceAtmVol;

        if (close(dc, 0.0)) {
            stdDev = s0;
        } else {
            Real d1 =
                blackFormulaStdDevDerivative(strike, forward, s0, 1.0, 0.0);
            Real d2 = blackFormulaStdDevSecondDerivative(strike, forward, s0,
                                                         1.0, 0.0);
            Real ds = 0.0;
            Real tmp = d1 * d1 + 2.0 * d2 * dc;
            if (std::fabs(d2) > 1E-10 && tmp >= 0.0)
                ds = (-d1 + std::sqrt(tmp)) / d2; // second order approximation
            else
                if(std::fabs(d1) > 1E-10)
                    ds = dc / d1; // first order approximation
            stdDev = s0 + ds;
        }

        QL_ENSURE(stdDev >= 0.0, "stdDev (" << stdDev
                                            << ") must be non-negative");
        return stdDev;
    }

    Real blackFormulaImpliedStdDevChambers(
        const ext::shared_ptr<PlainVanillaPayoff> &payoff,
        Real forward,
        Real blackPrice,
        Real blackAtmPrice,
        Real discount,
        Real displacement) {
        return blackFormulaImpliedStdDevChambers(
            payoff->optionType(), payoff->strike(), forward, blackPrice,
            blackAtmPrice, discount, displacement);
    }

    namespace {
        Real Af(Real x) {
            return 0.5*(1.0+boost::math::sign(x)
                *std::sqrt(1.0-std::exp(-M_2_PI*x*x)));
        }
    }

    Real blackFormulaImpliedStdDevApproximationRS(
        Option::Type type, Real K, Real F,
        Real marketValue, Real df, Real displacement) {

        checkParameters(K, F, displacement);
        QL_REQUIRE(marketValue >= 0.0,
                   "blackPrice (" << marketValue << ") must be non-negative");
        QL_REQUIRE(df > 0.0, "discount (" << df << ") must be positive");

        F = F + displacement;
        K = K + displacement;

        const Real ey = F/K;
        const Real ey2 = ey*ey;
        const Real y = std::log(ey);
        const Real alpha = marketValue/(K*df);
        const Real R = 2 * alpha + ((type == Option::Call) ? Real(-ey + 1.0) : ey - 1.0);
        const Real R2 = R*R;

        const Real a = std::exp((1.0-M_2_PI)*y);
        const Real A = squared(a - 1.0/a);
        const Real b = std::exp(M_2_PI*y);
        const Real B = 4.0*(b + 1/b)
            - 2*K/F*(a + 1.0/a)*(ey2 + 1 - R2);
        const Real C = (R2-squared(ey-1))*(squared(ey+1)-R2)/ey2;

        const Real beta = 2*C/(B+std::sqrt(B*B+4*A*C));
        const Real gamma = -M_PI_2*std::log(beta);

        if (y >= 0.0) {
            const Real M0 = K*df*(
                (type == Option::Call) ? Real(ey*Af(std::sqrt(2*y)) - 0.5)
                                       : 0.5-ey*Af(-std::sqrt(2*y)));

            if (marketValue <= M0)
                return std::sqrt(gamma+y)-std::sqrt(gamma-y);
            else
                return std::sqrt(gamma+y)+std::sqrt(gamma-y);
        }
        else {
            const Real M0 = K*df*(
                (type == Option::Call) ? Real(0.5*ey - Af(-std::sqrt(-2*y)))
                                       : Af(std::sqrt(-2*y)) - 0.5*ey);

            if (marketValue <= M0)
                return std::sqrt(gamma-y)-std::sqrt(gamma+y);
            else
                return std::sqrt(gamma+y)+std::sqrt(gamma-y);
        }
    }

    Real blackFormulaImpliedStdDevApproximationRS(
        const ext::shared_ptr<PlainVanillaPayoff> &payoff,
        Real F, Real marketValue,
        Real df, Real displacement) {

        return blackFormulaImpliedStdDevApproximationRS(
            payoff->optionType(), payoff->strike(),
            F, marketValue, df, displacement);
    }

    class BlackImpliedStdDevHelper {
      public:
        BlackImpliedStdDevHelper(Option::Type optionType,
                                 Real strike,
                                 Real forward,
                                 Real undiscountedBlackPrice,
                                 Real displacement = 0.0)
        : halfOptionType_(0.5 * Integer(optionType)),
          signedStrike_(Integer(optionType) * (strike+displacement)),
          signedForward_(Integer(optionType) * (forward+displacement)),
          undiscountedBlackPrice_(undiscountedBlackPrice)
        {
            checkParameters(strike, forward, displacement);
            QL_REQUIRE(undiscountedBlackPrice>=0.0,
                       "undiscounted Black price (" <<
                       undiscountedBlackPrice << ") must be non-negative");
            signedMoneyness_ = Integer(optionType) * std::log((forward+displacement)/(strike+displacement));
        }

        Real operator()(Real stdDev) const {
            #if defined(QL_EXTRA_SAFETY_CHECKS)
            QL_REQUIRE(stdDev>=0.0,
                       "stdDev (" << stdDev << ") must be non-negative");
            #endif
            if (stdDev==0.0)
                return std::max(signedForward_-signedStrike_, Real(0.0))
                                                   - undiscountedBlackPrice_;
            Real temp = halfOptionType_*stdDev;
            Real d = signedMoneyness_/stdDev;
            Real signedD1 = d + temp;
            Real signedD2 = d - temp;
            Real result = signedForward_ * N_(signedD1)
                - signedStrike_ * N_(signedD2);
            // numerical inaccuracies can yield a negative answer
            return std::max(Real(0.0), result) - undiscountedBlackPrice_;
        }
        Real derivative(Real stdDev) const {
            #if defined(QL_EXTRA_SAFETY_CHECKS)
            QL_REQUIRE(stdDev>=0.0,
                       "stdDev (" << stdDev << ") must be non-negative");
            #endif
            Real signedD1 = signedMoneyness_/stdDev + halfOptionType_*stdDev;
            return signedForward_*N_.derivative(signedD1);
        }
      private:
        Real halfOptionType_;
        Real signedStrike_, signedForward_;
        Real undiscountedBlackPrice_, signedMoneyness_;
        CumulativeNormalDistribution N_;
    };


    Real blackFormulaImpliedStdDev(Option::Type optionType,
                                   Real strike,
                                   Real forward,
                                   Real blackPrice,
                                   Real discount,
                                   Real displacement,
                                   Real guess,
                                   Real accuracy,
                                   Natural maxIterations)
    {
        checkParameters(strike, forward, displacement);

        QL_REQUIRE(discount>0.0,
                   "discount (" << discount << ") must be positive");

        QL_REQUIRE(blackPrice>=0.0,
                   "option price (" << blackPrice << ") must be non-negative");
        // check the price of the "other" option implied by put-call paity
        Real otherOptionPrice = blackPrice - Integer(optionType) * (forward-strike)*discount;
        QL_REQUIRE(otherOptionPrice>=0.0,
                   "negative " << Option::Type(-1*optionType) <<
                   " price (" << otherOptionPrice <<
                   ") implied by put-call parity. No solution exists for " <<
                   optionType << " strike " << strike <<
                   ", forward " << forward <<
                   ", price " << blackPrice <<
                   ", deflator " << discount);

        // solve for the out-of-the-money option which has
        // greater vega/price ratio, i.e.
        // it is numerically more robust for implied vol calculations
        if (optionType==Option::Put && strike>forward) {
            optionType = Option::Call;
            blackPrice = otherOptionPrice;
        }
        if (optionType==Option::Call && strike<forward) {
            optionType = Option::Put;
            blackPrice = otherOptionPrice;
        }

        strike = strike + displacement;
        forward = forward + displacement;

        if (guess==Null<Real>())
            guess = blackFormulaImpliedStdDevApproximation(
                optionType, strike, forward, blackPrice, discount, displacement);
        else
            QL_REQUIRE(guess>=0.0,
                       "stdDev guess (" << guess << ") must be non-negative");
        BlackImpliedStdDevHelper f(optionType, strike, forward,
                                   blackPrice/discount);
        NewtonSafe solver;
        solver.setMaxEvaluations(maxIterations);
        Real minSdtDev = 0.0, maxStdDev = 24.0; // 24 = 300% * sqrt(60)
        Real stdDev = solver.solve(f, accuracy, guess, minSdtDev, maxStdDev);
        QL_ENSURE(stdDev>=0.0,
                  "stdDev (" << stdDev << ") must be non-negative");
        return stdDev;
    }

    Real blackFormulaImpliedStdDev(
                        const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                        Real forward,
                        Real blackPrice,
                        Real discount,
                        Real displacement,
                        Real guess,
                        Real accuracy,
                        Natural maxIterations) {
        return blackFormulaImpliedStdDev(payoff->optionType(), payoff->strike(),
            forward, blackPrice, discount, displacement, guess, accuracy, maxIterations);
    }


    namespace {
        Real Np(Real x, Real v) {
            return CumulativeNormalDistribution()(x/v + 0.5*v);
        }
        Real Nm(Real x, Real v) {
            return std::exp(-x)*CumulativeNormalDistribution()(x/v - 0.5*v);
        }
        Real phi(Real x, Real v) {
            const Real ax = 2*std::fabs(x);
            const Real v2 = v*v;
            return (v2-ax)/(v2+ax);
        }
        Real F(Real v, Real x, Real cs, Real w) {
            return cs+Nm(x,v)+w*Np(x,v);
        }
        Real G(Real v, Real x, Real cs, Real w) {
            const Real q = F(v,x,cs,w)/(1+w);

            // Acklam's inverse w/o Halley's refinement step
            // does not provide enough accuracy. But both together are
            // slower than the boost replacement.
            const Real k = MaddockInverseCumulativeNormal()(q);

            return k + std::sqrt(k*k + 2*std::fabs(x));
        }
    }

    Real blackFormulaImpliedStdDevLiRS(
        Option::Type optionType,
        Real strike,
        Real forward,
        Real blackPrice,
        Real discount,
        Real displacement,
        Real guess,
        Real w,
        Real accuracy,
        Natural maxIterations) {

        QL_REQUIRE(discount>0.0,
                   "discount (" << discount << ") must be positive");

        QL_REQUIRE(blackPrice>=0.0,
                   "option price (" << blackPrice << ") must be non-negative");

        strike = strike + displacement;
        forward = forward + displacement;

        if (guess == Null<Real>()) {
            guess = blackFormulaImpliedStdDevApproximationRS(
                optionType, strike, forward,
                blackPrice, discount, displacement);
        }
        else {
            QL_REQUIRE(guess>=0.0,
                "stdDev guess (" << guess << ") must be non-negative");
        }

        Real x = std::log(forward/strike);
        Real cs = (optionType == Option::Call)
            ? Real(blackPrice / (forward*discount))
            : (blackPrice/ (forward*discount) + 1.0 - strike/forward);

        QL_REQUIRE(cs >= 0.0, "normalized call price (" << cs
                   << ") must be positive");

        if (x > 0) {
            // use in-out duality
            cs = forward/strike*cs + 1.0 - forward/strike;
            QL_REQUIRE(cs >= 0.0, "negative option price from in-out duality");
            x = -x;
        }

        Size nIter = 0;
        Real dv, vk, vkp1 = guess;

        do {
            vk = vkp1;
            const Real alphaK = (1+w)/(1+phi(x,vk));
            vkp1 = alphaK*G(vk,x,cs,w) + (1-alphaK)*vk;
            dv = std::fabs(vkp1 - vk);
        } while (dv > accuracy && ++nIter < maxIterations);

        QL_REQUIRE(dv <= accuracy, "max iterations exceeded");
        QL_REQUIRE(vk >= 0.0, "stdDev (" << vk << ") must be non-negative");

        return vk;
    }

    Real blackFormulaImpliedStdDevLiRS(
        const ext::shared_ptr<PlainVanillaPayoff>& payoff,
        Real forward,
        Real blackPrice,
        Real discount,
        Real displacement,
        Real guess,
        Real omega,
        Real accuracy,
        Natural maxIterations) {

        return blackFormulaImpliedStdDevLiRS(
            payoff->optionType(), payoff->strike(),
            forward, blackPrice, discount, displacement,
            guess, omega, accuracy, maxIterations);
    }


    Real blackFormulaCashItmProbability(Option::Type optionType,
                                        Real strike,
                                        Real forward,
                                        Real stdDev,
                                        Real displacement) {
        checkParameters(strike, forward, displacement);

        auto sign = Integer(optionType);

        if (stdDev==0.0)
            return (forward * sign > strike * sign ? 1.0 : 0.0);

        forward = forward + displacement;
        strike = strike + displacement;
        if (strike==0.0)
            return (optionType == Option::Call ? 1.0 : 0.0);
        Real d2 = std::log(forward/strike)/stdDev - 0.5*stdDev;
        CumulativeNormalDistribution phi;
        return phi(sign * d2);
    }

    Real blackFormulaCashItmProbability(
                        const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                        Real forward,
                        Real stdDev,
                        Real displacement) {
        return blackFormulaCashItmProbability(payoff->optionType(),
            payoff->strike(), forward, stdDev , displacement);
    }

    Real blackFormulaAssetItmProbability(
                        Option::Type optionType,
                        Real strike,
                        Real forward,
                        Real stdDev,
                        Real displacement) {
        checkParameters(strike, forward, displacement);

        auto sign = Integer(optionType);

        if (stdDev==0.0)
            return (forward * sign < strike * sign ? 1.0 : 0.0);

        forward = forward + displacement;
        strike = strike + displacement;
        if (strike == 0.0)
            return (optionType == Option::Call ? 1.0 : 0.0);
        Real d1 = std::log(forward/strike)/stdDev + 0.5*stdDev;
        CumulativeNormalDistribution phi;
        return phi(sign * d1);
    }

    Real blackFormulaAssetItmProbability(
                        const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                        Real forward,
                        Real stdDev,
                        Real displacement) {
        return blackFormulaAssetItmProbability(payoff->optionType(),
            payoff->strike(), forward, stdDev , displacement);
    }

    Real blackFormulaVolDerivative(Rate strike,
                                      Rate forward,
                                      Real stdDev,
                                      Real expiry,
                                      Real discount,
                                      Real displacement)
    {
        return  blackFormulaStdDevDerivative(strike,
                                     forward,
                                     stdDev,
                                     discount,
                                     displacement)*std::sqrt(expiry);
    }

    Real blackFormulaStdDevDerivative(Rate strike,
                                      Rate forward,
                                      Real stdDev,
                                      Real discount,
                                      Real displacement)
    {
        checkParameters(strike, forward, displacement);
        QL_REQUIRE(stdDev>=0.0,
                   "stdDev (" << stdDev << ") must be non-negative");
        QL_REQUIRE(discount>0.0,
                   "discount (" << discount << ") must be positive");

        forward = forward + displacement;
        strike = strike + displacement;

        if (stdDev==0.0 || strike==0.0)
            return 0.0;

        Real d1 = std::log(forward/strike)/stdDev + .5*stdDev;
        return discount * forward *
            CumulativeNormalDistribution().derivative(d1);
    }

    Real blackFormulaStdDevDerivative(
                        const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                        Real forward,
                        Real stdDev,
                        Real discount,
                        Real displacement) {
        return blackFormulaStdDevDerivative(payoff->strike(), forward,
                                     stdDev, discount, displacement);
    }

    Real blackFormulaStdDevSecondDerivative(Rate strike,
                                            Rate forward,
                                            Real stdDev,
                                            Real discount,
                                            Real displacement)
    {
        checkParameters(strike, forward, displacement);
        QL_REQUIRE(stdDev>=0.0,
                   "stdDev (" << stdDev << ") must be non-negative");
        QL_REQUIRE(discount>0.0,
                   "discount (" << discount << ") must be positive");

        forward = forward + displacement;
        strike = strike + displacement;

        if (stdDev==0.0 || strike==0.0)
            return 0.0;

        Real d1 = std::log(forward/strike)/stdDev + .5*stdDev;
        Real d1p = -std::log(forward/strike)/(stdDev*stdDev) + .5;
        return discount * forward *
            NormalDistribution().derivative(d1) * d1p;
    }

    Real blackFormulaStdDevSecondDerivative(
                        const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                        Real forward,
                        Real stdDev,
                        Real discount,
                        Real displacement) {
        return blackFormulaStdDevSecondDerivative(payoff->strike(), forward,
                                     stdDev, discount, displacement);
    }

    Real bachelierBlackFormula(Option::Type optionType,
                               Real strike,
                               Real forward,
                               Real stdDev,
                               Real discount)
    {
        QL_REQUIRE(stdDev>=0.0,
                   "stdDev (" << stdDev << ") must be non-negative");
        QL_REQUIRE(discount>0.0,
                   "discount (" << discount << ") must be positive");
        Real d = (forward-strike) * Integer(optionType), h = d / stdDev;
        if (stdDev==0.0)
            return discount*std::max(d, 0.0);
        CumulativeNormalDistribution phi;
        Real result = discount*(stdDev*phi.derivative(h) + d*phi(h));
        QL_ENSURE(result>=0.0,
                  "negative value (" << result << ") for " <<
                  stdDev << " stdDev, " <<
                  optionType << " option, " <<
                  strike << " strike , " <<
                  forward << " forward");
        return result;
    }

    Real bachelierBlackFormula(
                        const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                        Real forward,
                        Real stdDev,
                        Real discount) {
        return bachelierBlackFormula(payoff->optionType(),
            payoff->strike(), forward, stdDev, discount);
    }

    Real bachelierBlackFormulaForwardDerivative(
        Option::Type optionType, Real strike, Real forward, Real stdDev, Real discount)
    {
        QL_REQUIRE(stdDev>=0.0,
                   "stdDev (" << stdDev << ") must be non-negative");
        QL_REQUIRE(discount>0.0,
                   "discount (" << discount << ") must be positive");
        auto sign = Integer(optionType);
        if (stdDev == 0.0)
            return sign * std::max(1.0 * boost::math::sign((forward - strike) * sign), 0.0) * discount;
        Real d = (forward - strike) * sign, h = d / stdDev;
        CumulativeNormalDistribution phi;
        return sign * phi(h) * discount;
    }

    Real bachelierBlackFormulaForwardDerivative(
        const ext::shared_ptr<PlainVanillaPayoff>& payoff,
        Real forward,
        Real stdDev,
        Real discount)
    {
        return bachelierBlackFormulaForwardDerivative(payoff->optionType(),
            payoff->strike(), forward, stdDev, discount);
    }

    static Real h(Real eta) {

        const static Real  A0          = 3.994961687345134e-1;
        const static Real  A1          = 2.100960795068497e+1;
        const static Real  A2          = 4.980340217855084e+1;
        const static Real  A3          = 5.988761102690991e+2;
        const static Real  A4          = 1.848489695437094e+3;
        const static Real  A5          = 6.106322407867059e+3;
        const static Real  A6          = 2.493415285349361e+4;
        const static Real  A7          = 1.266458051348246e+4;

        const static Real  B0          = 1.000000000000000e+0;
        const static Real  B1          = 4.990534153589422e+1;
        const static Real  B2          = 3.093573936743112e+1;
        const static Real  B3          = 1.495105008310999e+3;
        const static Real  B4          = 1.323614537899738e+3;
        const static Real  B5          = 1.598919697679745e+4;
        const static Real  B6          = 2.392008891720782e+4;
        const static Real  B7          = 3.608817108375034e+3;
        const static Real  B8          = -2.067719486400926e+2;
        const static Real  B9          = 1.174240599306013e+1;

        QL_REQUIRE(eta>=0.0,
                       "eta (" << eta << ") must be non-negative");

        const Real num = A0 + eta * (A1 + eta * (A2 + eta * (A3 + eta * (A4 + eta
                    * (A5 + eta * (A6 + eta * A7))))));

        const Real den = B0 + eta * (B1 + eta * (B2 + eta * (B3 + eta * (B4 + eta
                    * (B5 + eta * (B6 + eta * (B7 + eta * (B8 + eta * B9))))))));

        return std::sqrt(eta) * (num / den);

    }

    Real bachelierBlackFormulaImpliedVolChoi(Option::Type optionType,
                                             Real strike,
                                             Real forward,
                                             Real tte,
                                             Real bachelierPrice,
                                             Real discount) {

        const static Real SQRT_QL_EPSILON = std::sqrt(QL_EPSILON);

        QL_REQUIRE(tte>0.0,
                   "tte (" << tte << ") must be positive");

        Real forwardPremium = bachelierPrice/discount;

        Real straddlePremium;
        if (optionType==Option::Call){
            straddlePremium = 2.0 * forwardPremium - (forward - strike);
        } else {
            straddlePremium = 2.0 * forwardPremium + (forward - strike);
        }

        Real nu = (forward - strike) / straddlePremium;
        QL_REQUIRE(nu<1.0 || close_enough(nu,1.0),
                   "nu (" << nu << ") must be <= 1.0");
        QL_REQUIRE(nu>-1.0 || close_enough(nu,-1.0),
                     "nu (" << nu << ") must be >= -1.0");

        nu = std::max(-1.0 + QL_EPSILON, std::min(nu,1.0 - QL_EPSILON));

        // nu / arctanh(nu) -> 1 as nu -> 0
        Real eta = (std::fabs(nu) < SQRT_QL_EPSILON) ? 1.0 : Real(nu / boost::math::atanh(nu));

        Real heta = h(eta);

        Real impliedBpvol = std::sqrt(M_PI / (2 * tte)) * straddlePremium * heta;

        return impliedBpvol;
    }

    namespace {

        boost::math::normal_distribution<Real> normal_dist;

        Real phi(const Real x) {
            return boost::math::pdf(normal_dist, x);
        }

        Real Phi(const Real x) {
            return boost::math::cdf(normal_dist, x);
        }

        Real PhiTilde(const Real x) {
            return Phi(x) + phi(x) / x;
        }

        Real inversePhiTilde(const Real PhiTildeStar) {
            QL_REQUIRE(PhiTildeStar < 0.0,
                       "inversePhiTilde(" << PhiTildeStar << "): negative argument required");
            Real xbar;
            if (PhiTildeStar < -0.001882039271) {
                Real g = 1.0 / (PhiTildeStar - 0.5);
                Real xibar =
                    (0.032114372355 -
                     g * g *
                         (0.016969777977 - g * g * (2.6207332461E-3 - 9.6066952861E-5 * g * g))) /
                    (1.0 -
                     g * g * (0.6635646938 - g * g * (0.14528712196 - 0.010472855461 * g * g)));
                xbar = g * (0.3989422804014326 + xibar * g * g);
            } else {
                Real h = std::sqrt(-std::log(-PhiTildeStar));
                xbar =
                    (9.4883409779 - h * (9.6320903635 - h * (0.58556997323 + 2.1464093351 * h))) /
                    (1.0 - h * (0.65174820867 + h * (1.5120247828 + 6.6437847132E-5 * h)));
            }
            Real q = (PhiTilde(xbar) - PhiTildeStar) / phi(xbar);
            Real xstar =
                xbar +
                3.0 * q * xbar * xbar * (2.0 - q * xbar * (2.0 + xbar * xbar)) /
                    (6.0 + q * xbar *
                               (-12.0 +
                                xbar * (6.0 * q + xbar * (-6.0 + q * xbar * (3.0 + xbar * xbar)))));
            return xstar;
        }

    } // namespace

    Real bachelierBlackFormulaImpliedVol(Option::Type optionType,
                                         Real strike,
                                         Real forward,
                                         Real tte,
                                         Real bachelierPrice,
                                         Real discount) {

        Real theta = optionType == Option::Call ? 1.0 : -1.0;

        // compound bechelierPrice, so that effectively discount = 1

        bachelierPrice /= discount;

        // handle case strike = forward

        if (close_enough(strike, forward)) {
            return bachelierPrice / (std::sqrt(tte) * phi(0.0));
        }

        // handle case strike != forward

        Real timeValue = bachelierPrice - std::max(theta * (forward - strike), 0.0);

        if (close_enough(timeValue, 0.0))
            return 0.0;

        QL_REQUIRE(timeValue > 0.0, "bachelierBlackFormulaImpliedVolExact(theta="
                                        << theta << ",strike=" << strike << ",forward=" << forward
                                        << ",tte=" << tte << ",price=" << bachelierPrice
                                        << "): option price implies negative time value ("
                                        << timeValue << ")");

        Real PhiTildeStar = -std::abs(timeValue / (strike - forward));
        Real xstar = inversePhiTilde(PhiTildeStar);
        Real impliedVol = std::abs((strike - forward) / (xstar * std::sqrt(tte)));

        return impliedVol;
    }

    Real bachelierBlackFormulaStdDevDerivative(Rate strike,
                                      Rate forward,
                                      Real stdDev,
                                      Real discount)
    {
        QL_REQUIRE(stdDev>=0.0,
                   "stdDev (" << stdDev << ") must be non-negative");
        QL_REQUIRE(discount>0.0,
                   "discount (" << discount << ") must be positive");

        if (stdDev==0.0)
            return 0.0;

        Real d1 = (forward - strike)/stdDev;
        return discount *
            CumulativeNormalDistribution().derivative(d1);
    }

    Real bachelierBlackFormulaStdDevDerivative(
                        const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                        Real forward,
                        Real stdDev,
                        Real discount) {
        return bachelierBlackFormulaStdDevDerivative(payoff->strike(), forward,
                                     stdDev, discount);
    }

    Real bachelierBlackFormulaAssetItmProbability(
                        Option::Type optionType,
                        Real strike,
                        Real forward,
                        Real stdDev) {
        QL_REQUIRE(stdDev>=0.0,
                   "stdDev (" << stdDev << ") must be non-negative");
        Real d = (forward - strike) * Integer(optionType), h = d / stdDev;
        if (stdDev==0.0)
            return std::max(d, 0.0);
        CumulativeNormalDistribution phi;
        Real result = phi(h);
        return result;
    }

    Real bachelierBlackFormulaAssetItmProbability(
                        const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                        Real forward,
                        Real stdDev) {
        return bachelierBlackFormulaAssetItmProbability(payoff->optionType(),
            payoff->strike(), forward, stdDev);
    }
}
]]></document_content>
  </document>
  <document index="46">
    <source>blackscholescalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/blackscholescalculator.hpp>

namespace QuantLib {

    BlackScholesCalculator::BlackScholesCalculator(
                        const ext::shared_ptr<StrikedTypePayoff>& payoff,
                        Real spot,
                        DiscountFactor growth,
                        Real stdDev,
                        DiscountFactor discount)
    : BlackCalculator(payoff, spot*growth/discount, stdDev, discount),
      spot_(spot), growth_(growth)
    {
        QL_REQUIRE(spot_>0.0,
                   "spot (" << spot_ << ") must be positive");
        QL_REQUIRE(growth_>0.0,
                   "growth (" << growth_ << ") must be positive");
    }

    BlackScholesCalculator::BlackScholesCalculator(Option::Type type,
                                                   Real strike,
                                                   Real spot,
                                                   DiscountFactor growth,
                                                   Real stdDev,
                                                   DiscountFactor discount)
    : BlackCalculator(type, strike, spot*growth/discount, stdDev, discount),
      spot_(spot), growth_(growth)
    {
        QL_REQUIRE(spot_>0.0,
                   "spot (" << spot_ << ") must be positive");
        QL_REQUIRE(growth_>0.0,
                   "growth (" << growth_ << ") must be positive");
    }

}
]]></document_content>
  </document>
  <document index="47">
    <source>bond/bondfunctions.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Nathan Abbott
 Copyright (C) 2007, 2008, 2009, 2010 Ferdinando Ametrano
 Copyright (C) 2007 Chiara Fornarola
 Copyright (C) 2008 Simon Ibbotson
 Copyright (C) 2004 M-Dimension Consulting Inc.
 Copyright (C) 2005, 2006, 2007, 2008, 2009 StatPro Italia srl
 Copyright (C) 2004 Jeff Yu

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/solvers1d/newtonsafe.hpp>
#include <ql/pricingengines/bond/bondfunctions.hpp>

namespace QuantLib {

    Date BondFunctions::startDate(const Bond& bond) {
        return CashFlows::startDate(bond.cashflows());
    }

    Date BondFunctions::maturityDate(const Bond& bond) {
        return CashFlows::maturityDate(bond.cashflows());
    }

    bool BondFunctions::isTradable(const Bond& bond,
                                   Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        return bond.notional(settlement)!=0.0;
    }

    Leg::const_reverse_iterator
    BondFunctions::previousCashFlow(const Bond& bond,
                                    Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        return CashFlows::previousCashFlow(bond.cashflows(),
                                           false, settlement);
    }

    Leg::const_iterator BondFunctions::nextCashFlow(const Bond& bond,
                                                    Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        return CashFlows::nextCashFlow(bond.cashflows(),
                                       false, settlement);
    }

    Date BondFunctions::previousCashFlowDate(const Bond& bond,
                                             Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        return CashFlows::previousCashFlowDate(bond.cashflows(),
                                               false, settlement);
    }

    Date BondFunctions::nextCashFlowDate(const Bond& bond,
                                         Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        return CashFlows::nextCashFlowDate(bond.cashflows(),
                                           false, settlement);
    }

    Real BondFunctions::previousCashFlowAmount(const Bond& bond,
                                               Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        return CashFlows::previousCashFlowAmount(bond.cashflows(),
                                                 false, settlement);
    }

    Real BondFunctions::nextCashFlowAmount(const Bond& bond,
                                           Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        return CashFlows::nextCashFlowAmount(bond.cashflows(),
                                             false, settlement);
    }

    Rate BondFunctions::previousCouponRate(const Bond& bond,
                                           Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        return CashFlows::previousCouponRate(bond.cashflows(),
                                             false, settlement);
    }

    Rate BondFunctions::nextCouponRate(const Bond& bond,
                                       Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        return CashFlows::nextCouponRate(bond.cashflows(),
                                         false, settlement);
    }

    Date BondFunctions::accrualStartDate(const Bond& bond,
                                         Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " (maturity being " << bond.maturityDate() << ")");

        return CashFlows::accrualStartDate(bond.cashflows(),
                                           false, settlement);
    }

    Date BondFunctions::accrualEndDate(const Bond& bond,
                                       Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " (maturity being " << bond.maturityDate() << ")");

        return CashFlows::accrualEndDate(bond.cashflows(),
                                         false, settlement);
    }

    Date BondFunctions::referencePeriodStart(const Bond& bond,
                                             Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " (maturity being " << bond.maturityDate() << ")");

        return CashFlows::referencePeriodStart(bond.cashflows(),
                                               false, settlement);
    }

    Date BondFunctions::referencePeriodEnd(const Bond& bond,
                                           Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " (maturity being " << bond.maturityDate() << ")");

        return CashFlows::referencePeriodEnd(bond.cashflows(),
                                             false, settlement);
    }

    Time BondFunctions::accrualPeriod(const Bond& bond,
                                      Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " (maturity being " << bond.maturityDate() << ")");

        return CashFlows::accrualPeriod(bond.cashflows(),
                                        false, settlement);
    }

    Date::serial_type BondFunctions::accrualDays(const Bond& bond,
                                                 Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " (maturity being " << bond.maturityDate() << ")");

        return CashFlows::accrualDays(bond.cashflows(),
                                      false, settlement);
    }

    Time BondFunctions::accruedPeriod(const Bond& bond,
                                      Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " (maturity being " << bond.maturityDate() << ")");

        return CashFlows::accruedPeriod(bond.cashflows(),
                                        false, settlement);
    }

    Date::serial_type BondFunctions::accruedDays(const Bond& bond,
                                                 Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " (maturity being " << bond.maturityDate() << ")");

        return CashFlows::accruedDays(bond.cashflows(),
                                      false, settlement);
    }

    Real BondFunctions::accruedAmount(const Bond& bond,
                                      Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        if (!BondFunctions::isTradable(bond, settlement))
            return 0.0;

        return CashFlows::accruedAmount(bond.cashflows(),
                                        false, settlement) *
            100.0 / bond.notional(settlement);
    }



    Real BondFunctions::cleanPrice(const Bond& bond,
                                   const YieldTermStructure& discountCurve,
                                   Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        return dirtyPrice(bond, discountCurve, settlement) - bond.accruedAmount(settlement);
    }

    Real BondFunctions::dirtyPrice(const Bond& bond,
                                   const YieldTermStructure& discountCurve,
                                   Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " settlement date (maturity being " <<
                   bond.maturityDate() << ")");

        Real dirtyPrice = CashFlows::npv(bond.cashflows(), discountCurve,
                                         false, settlement) *
            100.0 / bond.notional(settlement);
        return dirtyPrice;
    }

    Real BondFunctions::bps(const Bond& bond,
                            const YieldTermStructure& discountCurve,
                            Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " (maturity being " << bond.maturityDate() << ")");

        return CashFlows::bps(bond.cashflows(), discountCurve,
                              false, settlement) *
            100.0 / bond.notional(settlement);
    }

    Rate BondFunctions::atmRate(const Bond& bond,
                                const YieldTermStructure& discountCurve,
                                Date settlement,
                                const Bond::Price price) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " (maturity being " << bond.maturityDate() << ")");

        Real npv = Null<Real>();
        if (price.isValid()) {
            Real dirtyPrice =
                price.amount() +
                (price.type() == Bond::Price::Clean ? bond.accruedAmount(settlement) : 0);

            Real currentNotional = bond.notional(settlement);
            npv = dirtyPrice / 100.0 * currentNotional;

        }
        return CashFlows::atmRate(bond.cashflows(), discountCurve,
                                  false, settlement, settlement,
                                  npv);
    }

    Real BondFunctions::cleanPrice(const Bond& bond,
                                   const InterestRate& yield,
                                   Date settlement) {
        return dirtyPrice(bond, yield, settlement) - bond.accruedAmount(settlement);
    }

    Real BondFunctions::cleanPrice(const Bond& bond,
                                   Rate yield,
                                   const DayCounter& dayCounter,
                                   Compounding compounding,
                                   Frequency frequency,
                                   Date settlement) {
        InterestRate y(yield, dayCounter, compounding, frequency);
        return cleanPrice(bond, y, settlement);
    }

    Real BondFunctions::dirtyPrice(const Bond& bond,
                                   const InterestRate& yield,
                                   Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " (maturity being " << bond.maturityDate() << ")");

        Real dirtyPrice = CashFlows::npv(bond.cashflows(), yield,
                                         false, settlement) *
            100.0 / bond.notional(settlement);
        return dirtyPrice;
    }

    Real BondFunctions::dirtyPrice(const Bond& bond,
                                   Rate yield,
                                   const DayCounter& dayCounter,
                                   Compounding compounding,
                                   Frequency frequency,
                                   Date settlement) {
        InterestRate y(yield, dayCounter, compounding, frequency);
        return dirtyPrice(bond, y, settlement);
    }

    Real BondFunctions::bps(const Bond& bond,
                            const InterestRate& yield,
                            Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " (maturity being " << bond.maturityDate() << ")");

        return CashFlows::bps(bond.cashflows(), yield,
                              false, settlement) *
            100.0 / bond.notional(settlement);
    }

    Real BondFunctions::bps(const Bond& bond,
                            Rate yield,
                            const DayCounter& dayCounter,
                            Compounding compounding,
                            Frequency frequency,
                            Date settlement) {
        InterestRate y(yield, dayCounter, compounding, frequency);
        return bps(bond, y, settlement);
    }

    Rate BondFunctions::yield(const Bond& bond,
                              Bond::Price price,
                              const DayCounter& dayCounter,
                              Compounding compounding,
                              Frequency frequency,
                              Date settlement,
                              Real accuracy,
                              Size maxIterations,
                              Rate guess) {
        NewtonSafe solver;
        solver.setMaxEvaluations(maxIterations);
        return yield<NewtonSafe>(solver, bond, price, dayCounter,
                                 compounding, frequency, settlement,
                                 accuracy, guess);
    }

    Time BondFunctions::duration(const Bond& bond,
                                 const InterestRate& yield,
                                 Duration::Type type,
                                 Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " (maturity being " << bond.maturityDate() << ")");

        return CashFlows::duration(bond.cashflows(), yield,
                                   type,
                                   false, settlement);
    }

    Time BondFunctions::duration(const Bond& bond,
                                 Rate yield,
                                 const DayCounter& dayCounter,
                                 Compounding compounding,
                                 Frequency frequency,
                                 Duration::Type type,
                                 Date settlement) {
        InterestRate y(yield, dayCounter, compounding, frequency);
        return duration(bond, y, type, settlement);
    }

    Real BondFunctions::convexity(const Bond& bond,
                                  const InterestRate& yield,
                                  Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " (maturity being " << bond.maturityDate() << ")");

        return CashFlows::convexity(bond.cashflows(), yield,
                                    false, settlement);
    }

    Real BondFunctions::convexity(const Bond& bond,
                                  Rate yield,
                                  const DayCounter& dayCounter,
                                  Compounding compounding,
                                  Frequency frequency,
                                  Date settlement) {
        InterestRate y(yield, dayCounter, compounding, frequency);
        return convexity(bond, y, settlement);
    }

    Real BondFunctions::basisPointValue(const Bond& bond,
                                        const InterestRate& yield,
                                        Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " (maturity being " << bond.maturityDate() << ")");

        return CashFlows::basisPointValue(bond.cashflows(), yield,
                                          false, settlement);
    }

    Real BondFunctions::basisPointValue(const Bond& bond,
                              Rate yield,
                              const DayCounter& dayCounter,
                              Compounding compounding,
                              Frequency frequency,
                                        Date settlement) {
        InterestRate y(yield, dayCounter, compounding, frequency);
        return basisPointValue(bond, y, settlement);
    }

    Real BondFunctions::yieldValueBasisPoint(const Bond& bond,
                                             const InterestRate& yield,
                                             Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " (maturity being " << bond.maturityDate() << ")");

        return CashFlows::yieldValueBasisPoint(bond.cashflows(), yield,
                                               false, settlement);
    }

    Real BondFunctions::yieldValueBasisPoint(const Bond& bond,
                                             Rate yield,
                                             const DayCounter& dayCounter,
                                             Compounding compounding,
                                             Frequency frequency,
                                             Date settlement) {
        InterestRate y(yield, dayCounter, compounding, frequency);
        return yieldValueBasisPoint(bond, y, settlement);
    }

    Real BondFunctions::cleanPrice(const Bond& bond,
                                   const ext::shared_ptr<YieldTermStructure>& d,
                                   Spread zSpread,
                                   const DayCounter& dc,
                                   Compounding comp,
                                   Frequency freq,
                                   Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        return dirtyPrice(bond, d, zSpread, dc, comp, freq, settlement) - bond.accruedAmount(settlement);
    }

    Real BondFunctions::dirtyPrice(const Bond& bond,
                                   const ext::shared_ptr<YieldTermStructure>& d,
                                   Spread zSpread,
                                   const DayCounter& dc,
                                   Compounding comp,
                                   Frequency freq,
                                   Date settlement) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " (maturity being " << bond.maturityDate() << ")");

        Real dirtyPrice = CashFlows::npv(bond.cashflows(), d,
                                         zSpread, dc, comp, freq,
                                         false, settlement) *
            100.0 / bond.notional(settlement);
        return dirtyPrice;
    }

    Spread BondFunctions::zSpread(const Bond& bond,
                                  Bond::Price price,
                                  const ext::shared_ptr<YieldTermStructure>& d,
                                  const DayCounter& dayCounter,
                                  Compounding compounding,
                                  Frequency frequency,
                                  Date settlement,
                                  Real accuracy,
                                  Size maxIterations,
                                  Rate guess) {
        if (settlement == Date())
            settlement = bond.settlementDate();

        QL_REQUIRE(BondFunctions::isTradable(bond, settlement),
                   "non tradable at " << settlement <<
                   " (maturity being " << bond.maturityDate() << ")");

        Real dirtyPrice =
            price.amount() +
            (price.type() == Bond::Price::Clean ? bond.accruedAmount(settlement) : 0);

        dirtyPrice /= 100.0 / bond.notional(settlement);

        return CashFlows::zSpread(bond.cashflows(),
                                  dirtyPrice,
                                  d,
                                  dayCounter, compounding, frequency,
                                  false, settlement, settlement,
                                  accuracy, maxIterations, guess);
    }
}
]]></document_content>
  </document>
  <document index="48">
    <source>bond/discountingbondengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflows.hpp>
#include <ql/pricingengines/bond/discountingbondengine.hpp>
#include <ql/optional.hpp>
#include <utility>

namespace QuantLib {

    DiscountingBondEngine::DiscountingBondEngine(
        Handle<YieldTermStructure> discountCurve,
        const ext::optional<bool>& includeSettlementDateFlows)
    : discountCurve_(std::move(discountCurve)),
      includeSettlementDateFlows_(includeSettlementDateFlows) {
        registerWith(discountCurve_);
    }

    void DiscountingBondEngine::calculate() const {
        QL_REQUIRE(!discountCurve_.empty(),
                   "discounting term structure handle is empty");

        results_.valuationDate = (*discountCurve_)->referenceDate();

        bool includeRefDateFlows = includeSettlementDateFlows_ ? // NOLINT(readability-implicit-bool-conversion)
                                       *includeSettlementDateFlows_ :
                                       Settings::instance().includeReferenceDateEvents();

        results_.value = CashFlows::npv(arguments_.cashflows,
                                        **discountCurve_,
                                        includeRefDateFlows,
                                        results_.valuationDate,
                                        results_.valuationDate);

        // a bond's cashflow on settlement date is never taken into
        // account, so we might have to play it safe and recalculate
        if (!includeRefDateFlows
                     && results_.valuationDate == arguments_.settlementDate) {
            // same parameters as above, we can avoid another call
            results_.settlementValue = results_.value;
        } else {
            // no such luck
            results_.settlementValue =
                CashFlows::npv(arguments_.cashflows,
                               **discountCurve_,
                               false,
                               arguments_.settlementDate,
                               arguments_.settlementDate);
        }
    }

}
]]></document_content>
  </document>
  <document index="49">
    <source>bond/discretizedconvertible.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2006 Theo Boafo
 Copyright (C) 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/bond/discretizedconvertible.hpp>
#include <ql/math/comparison.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    DiscretizedConvertible::DiscretizedConvertible(
        ConvertibleBond::arguments args,
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        DividendSchedule dividends,
        Handle<Quote> creditSpread,
        const TimeGrid& grid)
    : arguments_(std::move(args)), process_(std::move(process)),
      creditSpread_(std::move(creditSpread)) {

        for (const auto& dividend : dividends) {
            if (!dividend->hasOccurred(arguments_.settlementDate, false)) {
                dividends_.push_back(dividend);
                dividendDates_.push_back(dividend->date());
            }
        }

        dividendValues_ = Array(dividends_.size(), 0.0);

        Date settlementDate = process_->riskFreeRate()->referenceDate();
        for (Size i=0; i<dividends.size(); i++) {
            if (dividends[i]->date() >= settlementDate) {
                dividendValues_[i] =
                    dividends[i]->amount() *
                    process_->riskFreeRate()->discount(
                                             dividends[i]->date());
            }
        }

        DayCounter dayCounter = process_->riskFreeRate()->dayCounter();
        Date bondSettlement = arguments_.settlementDate;

        stoppingTimes_.resize(arguments_.exercise->dates().size());
        for (Size i=0; i<stoppingTimes_.size(); ++i)
            stoppingTimes_[i] =
                dayCounter.yearFraction(bondSettlement,
                                        arguments_.exercise->date(i));

        callabilityTimes_.resize(arguments_.callabilityDates.size());
        for (Size i=0; i<callabilityTimes_.size(); ++i)
            callabilityTimes_[i] =
                dayCounter.yearFraction(bondSettlement,
                                        arguments_.callabilityDates[i]);

        couponTimes_.clear();
        couponAmounts_.clear();
        for (Size i = 0; i < arguments_.cashflows.size() - 1; ++i) {
            if (!arguments_.cashflows[i]->hasOccurred(bondSettlement, false)) {
                couponTimes_.push_back(dayCounter.yearFraction(bondSettlement,
                                                               arguments_.cashflows[i]->date()));
                couponAmounts_.push_back(arguments_.cashflows[i]->amount());
            }
        }

        dividendTimes_.resize(dividendDates_.size());
        for (Size i=0; i<dividendTimes_.size(); ++i)
            dividendTimes_[i] =
                dayCounter.yearFraction(bondSettlement,
                                        dividendDates_[i]);

        if (!grid.empty()) {
            // adjust times to grid
            for (Real& stoppingTime : stoppingTimes_)
                stoppingTime = grid.closestTime(stoppingTime);
            for (Real& couponTime : couponTimes_)
                couponTime = grid.closestTime(couponTime);
            for (Real& callabilityTime : callabilityTimes_)
                callabilityTime = grid.closestTime(callabilityTime);
            for (Real& dividendTime : dividendTimes_)
                dividendTime = grid.closestTime(dividendTime);
        }
    }

    void DiscretizedConvertible::reset(Size size) {

        // Set to bond redemption values
        values_ = Array(size, arguments_.redemption);

        // coupon amounts should be added when adjusting
        // values_ = Array(size, arguments_.cashFlows.back()->amount());

        conversionProbability_ = Array(size, 0.0);
        spreadAdjustedRate_ = Array(size, 0.0);

        DayCounter rfdc  = process_->riskFreeRate()->dayCounter();

        // this takes care of convertibility and conversion probabilities
        adjustValues();

        Real creditSpread = creditSpread_->value();

        Date exercise = arguments_.exercise->lastDate();

        Rate riskFreeRate =
            process_->riskFreeRate()->zeroRate(exercise, rfdc,
                                               Continuous, NoFrequency);

        // Calculate blended discount rate to be used on roll back.
        for (Size j=0; j<values_.size(); j++) {
           spreadAdjustedRate_[j] =
               conversionProbability_[j] * riskFreeRate +
               (1-conversionProbability_[j])*(riskFreeRate + creditSpread);
        }
    }

    void DiscretizedConvertible::postAdjustValuesImpl() {

        bool convertible = false;
        switch (arguments_.exercise->type()) {
          case Exercise::American:
            if (time() <= stoppingTimes_[1] && time() >= stoppingTimes_[0])
                convertible = true;
            break;
          case Exercise::European:
            if (isOnTime(stoppingTimes_[0]))
                convertible = true;
            break;
          case Exercise::Bermudan:
              for (Real stoppingTime : stoppingTimes_) {
                  if (isOnTime(stoppingTime))
                      convertible = true;
              }
            break;
          default:
            QL_FAIL("invalid option type");
        }

        for (Size i=0; i<callabilityTimes_.size(); i++) {
            if (isOnTime(callabilityTimes_[i]))
                applyCallability(i,convertible);
        }

        for (Size i=0; i<couponTimes_.size(); i++) {
            if (isOnTime(couponTimes_[i]))
                addCoupon(i);
        }

        if (convertible)
            applyConvertibility();
    }

    void DiscretizedConvertible::applyConvertibility() {
        Array grid = adjustedGrid();
        for (Size j=0; j<values_.size(); j++) {
            Real payoff = arguments_.conversionRatio*grid[j];
            if (values_[j] <= payoff) {
                values_[j] = payoff;
                conversionProbability_[j] = 1.0;
            }
        }
    }

    void DiscretizedConvertible::applyCallability(Size i, bool convertible) {
        Size j;
        Array grid = adjustedGrid();
        switch (arguments_.callabilityTypes[i]) {
          case Callability::Call:
            if (arguments_.callabilityTriggers[i] != Null<Real>()) {
                Real conversionValue =
                    arguments_.redemption/arguments_.conversionRatio;
                Real trigger =
                    conversionValue*arguments_.callabilityTriggers[i];
                for (j=0; j<values_.size(); j++) {
                    // the callability is conditioned by the trigger...
                    if (grid[j] >= trigger) {
                        // ...and might trigger conversion
                        values_[j] =
                            std::min(std::max(
                                          arguments_.callabilityPrices[i],
                                          arguments_.conversionRatio*grid[j]),
                                     values_[j]);
                    }
                }
            } else if (convertible) {
                for (j=0; j<values_.size(); j++) {
                    // exercising the callability might trigger conversion
                    values_[j] =
                        std::min(std::max(arguments_.callabilityPrices[i],
                                          arguments_.conversionRatio*grid[j]),
                                 values_[j]);
                }
            } else {
                for (j=0; j<values_.size(); j++) {
                    values_[j] = std::min(arguments_.callabilityPrices[i],
                                          values_[j]);
                }
            }
            break;
          case Callability::Put:
            for (j=0; j<values_.size(); j++) {
                values_[j] = std::max(values_[j],
                                      arguments_.callabilityPrices[i]);
            }
            break;
          default:
            QL_FAIL("unknown callability type");
        }
    }

    void DiscretizedConvertible::addCoupon(Size i) {
        values_ += couponAmounts_[i];
    }

    Array DiscretizedConvertible::adjustedGrid() const {
        Time t = time();
        Array grid = method()->grid(t);
        // add back all dividend amounts in the future
        for (Size i=0; i<dividends_.size(); i++) {
            Time dividendTime = dividendTimes_[i];
            if (dividendTime >= t || close(dividendTime,t)) {
                const ext::shared_ptr<Dividend>& d = dividends_[i];
                DiscountFactor dividendDiscount =
                    process_->riskFreeRate()->discount(dividendTime) /
                    process_->riskFreeRate()->discount(t);
                for (Real& j : grid)
                    j += d->amount(j) * dividendDiscount;
            }
        }
        return grid;
    }

}

]]></document_content>
  </document>
  <document index="50">
    <source>bond/riskybondengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2021 Lew Wei Hao

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/bond/riskybondengine.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/coupon.hpp>
#include <utility>


namespace QuantLib {

    RiskyBondEngine::RiskyBondEngine(Handle<DefaultProbabilityTermStructure> defaultTS,
                                     Real recoveryRate,
                                     Handle<YieldTermStructure> yieldTS)
    : defaultTS_(std::move(defaultTS)), 
      recoveryRate_(recoveryRate), 
      yieldTS_(std::move(yieldTS)) {
        registerWith(defaultTS_);
        registerWith(yieldTS_);
    }

    void RiskyBondEngine::calculate() const {
        Date npvDate = yieldTS()->referenceDate();
        Date settlementDate = arguments_.settlementDate;
        Date startDate = CashFlows::startDate(arguments_.cashflows);
        Date d1 = std::max(npvDate, startDate);

        Real NPV = 0.0;
        Real settlementValue = 0.0;
        for (auto& cf : arguments_.cashflows) {
            Date d2 = cf->date();
            if (d2 > npvDate) {

                Real weightedCouponAmount = cf->amount() * defaultTS()->survivalProbability(d2);
                NPV += weightedCouponAmount * yieldTS()->discount(d2);
                if (d2 > settlementDate)
                    settlementValue += weightedCouponAmount * yieldTS()->discount(d2);

                auto coupon = ext::dynamic_pointer_cast<Coupon>(cf);
                if (coupon != nullptr) {
                    Date defaultDate = d1 + (d2 - d1) / 2;
                    Real weightedRecovery = coupon->nominal() * recoveryRate() *
                                    (defaultTS()->survivalProbability(d1) -
                                     defaultTS()->survivalProbability(d2)); 
                    NPV += weightedRecovery * yieldTS()->discount(defaultDate);
                    if (d2 > settlementDate)
                        settlementValue += weightedRecovery * yieldTS()->discount(defaultDate);

                    d1 = d2;
                }
            }
        }

        results_.value = NPV;
        results_.settlementValue = settlementValue / yieldTS()->discount(settlementDate);
        results_.valuationDate = npvDate;
    }

}
]]></document_content>
  </document>
  <document index="51">
    <source>capfloor/analyticcapfloorengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/capfloor/analyticcapfloorengine.hpp>
#include <ql/optional.hpp>
#include <utility>

namespace QuantLib {

    AnalyticCapFloorEngine::AnalyticCapFloorEngine(const ext::shared_ptr<AffineModel>& model,
                                                   Handle<YieldTermStructure> termStructure)
    : GenericModelEngine<AffineModel, CapFloor::arguments, CapFloor::results>(model),
      termStructure_(std::move(termStructure)) {
        registerWith(termStructure_);
    }


    void AnalyticCapFloorEngine::calculate() const {
        QL_REQUIRE(!model_.empty(), "null model");

        Date referenceDate;
        DayCounter dayCounter;

        ext::shared_ptr<TermStructureConsistentModel> tsmodel =
            ext::dynamic_pointer_cast<TermStructureConsistentModel>(*model_);
        if (tsmodel != nullptr) {
            referenceDate = tsmodel->termStructure()->referenceDate();
            dayCounter = tsmodel->termStructure()->dayCounter();
        } else {
            referenceDate = termStructure_->referenceDate();
            dayCounter = termStructure_->dayCounter();
        }

        Real value = 0.0;
        CapFloor::Type type = arguments_.type;
        Size nPeriods = arguments_.endDates.size();

        bool includeRefDatePayments =
            Settings::instance().includeReferenceDateEvents();
        if (referenceDate == Settings::instance().evaluationDate()) {
            ext::optional<bool> includeTodaysPayments =
                Settings::instance().includeTodaysCashFlows();
            if (includeTodaysPayments) // NOLINT(readability-implicit-bool-conversion)
                includeRefDatePayments = *includeTodaysPayments;
        }

        for (Size i=0; i<nPeriods; i++) {

            Time fixingTime =
                dayCounter.yearFraction(referenceDate,
                                        arguments_.fixingDates[i]);
            Time paymentTime =
                dayCounter.yearFraction(referenceDate,
                                        arguments_.endDates[i]);

            bool not_expired =
                includeRefDatePayments ? paymentTime >= 0.0 : paymentTime > 0.0;

            if (not_expired) {
                Time tenor = arguments_.accrualTimes[i];
                Rate fixing = arguments_.forwards[i];
                if (fixingTime <= 0.0) {
                    if (type == CapFloor::Cap || type == CapFloor::Collar) {
                        DiscountFactor discount = model_->discount(paymentTime);
                        Rate strike = arguments_.capRates[i];
                        value += discount * arguments_.nominals[i] * tenor
                               * arguments_.gearings[i]
                               * std::max(0.0, fixing - strike);
                    }
                    if (type == CapFloor::Floor || type == CapFloor::Collar) {
                        DiscountFactor discount = model_->discount(paymentTime);
                        Rate strike = arguments_.floorRates[i];
                        Real mult = (type == CapFloor::Floor) ? 1.0 : -1.0;
                        value += discount * arguments_.nominals[i] * tenor
                               * mult * arguments_.gearings[i]
                               * std::max(0.0, strike - fixing);
                    }
                } else {
                    Time maturity =
                        dayCounter.yearFraction(referenceDate,
                                                arguments_.startDates[i]);
                    if (type == CapFloor::Cap || type == CapFloor::Collar) {
                        Real temp = 1.0+arguments_.capRates[i]*tenor;
                        value += arguments_.nominals[i] *
                            arguments_.gearings[i] * temp *
                            model_->discountBondOption(Option::Put, 1.0/temp,
                                                       maturity, paymentTime);
                    }
                    if (type == CapFloor::Floor || type == CapFloor::Collar) {
                        Real temp = 1.0+arguments_.floorRates[i]*tenor;
                        Real mult = (type == CapFloor::Floor) ? 1.0 : -1.0;
                        value += arguments_.nominals[i] *
                            arguments_.gearings[i] * temp * mult *
                            model_->discountBondOption(Option::Call, 1.0/temp,
                                                       maturity, paymentTime);
                    }
                }
            }
        }

        results_.value = value;
    }

}
]]></document_content>
  </document>
  <document index="52">
    <source>capfloor/bacheliercapfloorengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014, 2015 Michael von den Driesch
 Copyright (C) 2019 Wojciech Ślusarski

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/blackformula.hpp>
#include <ql/pricingengines/capfloor/bacheliercapfloorengine.hpp>
#include <ql/termstructures/volatility/optionlet/constantoptionletvol.hpp>
#include <ql/termstructures/volatility/optionlet/strippedoptionletadapter.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <utility>

namespace QuantLib {

    BachelierCapFloorEngine::BachelierCapFloorEngine(Handle<YieldTermStructure> discountCurve,
                                                     Volatility v,
                                                     const DayCounter& dc)
    : discountCurve_(std::move(discountCurve)),
      vol_(ext::shared_ptr<OptionletVolatilityStructure>(
          new ConstantOptionletVolatility(0, NullCalendar(), Following, v, dc))) {
        registerWith(discountCurve_);
    }

    BachelierCapFloorEngine::BachelierCapFloorEngine(Handle<YieldTermStructure> discountCurve,
                                                     const Handle<Quote>& v,
                                                     const DayCounter& dc)
    : discountCurve_(std::move(discountCurve)),
      vol_(ext::shared_ptr<OptionletVolatilityStructure>(
          new ConstantOptionletVolatility(0, NullCalendar(), Following, v, dc))) {
        registerWith(discountCurve_);
        registerWith(vol_);
    }

    BachelierCapFloorEngine::BachelierCapFloorEngine(
        Handle<YieldTermStructure> discountCurve, Handle<OptionletVolatilityStructure> volatility)
    : discountCurve_(std::move(discountCurve)), vol_(std::move(volatility)) {
        QL_REQUIRE(vol_->volatilityType() == Normal,
                   "BachelierCapFloorEngine should only be used for vol "
                   "surfaces stripped with normal model. Options were stripped "
                   "with model "
                       << vol_->volatilityType());
        registerWith(discountCurve_);
        registerWith(vol_);
    }

    void BachelierCapFloorEngine::calculate() const {
        Real value = 0.0;
        Real vega = 0.0;
        Size optionlets = arguments_.startDates.size();
        std::vector<Real> values(optionlets, 0.0);
        std::vector<Real> deltas(optionlets, 0.0);
        std::vector<Real> vegas(optionlets, 0.0);
        std::vector<Real> stdDevs(optionlets, 0.0);
        std::vector<DiscountFactor> discountFactors(optionlets, 0.0);
        CapFloor::Type type = arguments_.type;
        Date today = vol_->referenceDate();
        Date settlement = discountCurve_->referenceDate();

        for (Size i=0; i<optionlets; ++i) {
            Date paymentDate = arguments_.endDates[i];
            // handling of settlementDate, npvDate and includeSettlementFlows
            // should be implemented.
            // For the time being just discard expired caplets
            if (paymentDate > settlement) {
                DiscountFactor d = discountCurve_->discount(paymentDate);
                discountFactors[i] = d;
                Real accrualFactor = arguments_.nominals[i] *
                                   arguments_.gearings[i] *
                                   arguments_.accrualTimes[i];
                Real discountedAccrual = d * accrualFactor;

                Rate forward = arguments_.forwards[i];

                Date fixingDate = arguments_.fixingDates[i];
                Time sqrtTime = 0.0;
                if (fixingDate > today)
                    sqrtTime = std::sqrt(vol_->timeFromReference(fixingDate));

                if (type == CapFloor::Cap || type == CapFloor::Collar) {
                    Rate strike = arguments_.capRates[i];
                    if (sqrtTime>0.0) {
                        stdDevs[i] = std::sqrt(vol_->blackVariance(fixingDate,
                                                                   strike));
                        vegas[i] = bachelierBlackFormulaStdDevDerivative(strike,
                            forward, stdDevs[i], discountedAccrual) * sqrtTime;
                        deltas[i] = bachelierBlackFormulaAssetItmProbability(Option::Call,
                            strike, forward, stdDevs[i]);
                    }
                    // include caplets with past fixing date
                    values[i] = bachelierBlackFormula(Option::Call,
                        strike, forward, stdDevs[i], discountedAccrual);
                }
                if (type == CapFloor::Floor || type == CapFloor::Collar) {
                    Rate strike = arguments_.floorRates[i];
                    Real floorletVega = 0.0;
                    Real floorletDelta = 0.0;
                    if (sqrtTime>0.0) {
                        stdDevs[i] = std::sqrt(vol_->blackVariance(fixingDate,
                                                                   strike));
                        floorletVega = bachelierBlackFormulaStdDevDerivative(strike,
                            forward, stdDevs[i], discountedAccrual) * sqrtTime;
                        floorletDelta = Integer(Option::Put) * bachelierBlackFormulaAssetItmProbability(
                                                        Option::Put, strike, forward, 
                                                        stdDevs[i]);
                    }
                    Real floorlet = bachelierBlackFormula(Option::Put,
                        strike, forward, stdDevs[i], discountedAccrual);
                    if (type == CapFloor::Floor) {
                        values[i] = floorlet;
                        vegas[i] = floorletVega;
                        deltas[i] = floorletDelta;
                    } else {
                        // a collar is long a cap and short a floor
                        values[i] -= floorlet;
                        vegas[i] -= floorletVega;
                        deltas[i] -= floorletDelta;
                    }
                }
                value += values[i];
                vega += vegas[i];
            }
        }
        results_.value = value;
        results_.additionalResults["vega"] = vega;

        results_.additionalResults["optionletsPrice"] = values;
        results_.additionalResults["optionletsVega"] = vegas;
        results_.additionalResults["optionletsDelta"] = deltas;
        results_.additionalResults["optionletsDiscountFactor"] = discountFactors;
        results_.additionalResults["optionletsAtmForward"] = arguments_.forwards;
        if (type != CapFloor::Collar)
            results_.additionalResults["optionletsStdDev"] = stdDevs;
    }

}
]]></document_content>
  </document>
  <document index="53">
    <source>capfloor/blackcapfloorengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2006, 2007 StatPro Italia srl
 Copyright (C) 2015 Michael von den Driesch
 Copyright (C) 2019 Wojciech Ślusarski

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/blackformula.hpp>
#include <ql/pricingengines/capfloor/blackcapfloorengine.hpp>
#include <ql/termstructures/volatility/optionlet/constantoptionletvol.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <utility>

namespace QuantLib {

    BlackCapFloorEngine::BlackCapFloorEngine(Handle<YieldTermStructure> discountCurve,
                                             Volatility v,
                                             const DayCounter& dc,
                                             Real displacement)
    : discountCurve_(std::move(discountCurve)),
      vol_(ext::shared_ptr<OptionletVolatilityStructure>(
          new ConstantOptionletVolatility(0, NullCalendar(), Following, v, dc))),
      displacement_(displacement) {
        registerWith(discountCurve_);
    }

    BlackCapFloorEngine::BlackCapFloorEngine(Handle<YieldTermStructure> discountCurve,
                                             const Handle<Quote>& v,
                                             const DayCounter& dc,
                                             Real displacement)
    : discountCurve_(std::move(discountCurve)),
      vol_(ext::shared_ptr<OptionletVolatilityStructure>(
          new ConstantOptionletVolatility(0, NullCalendar(), Following, v, dc))),
      displacement_(displacement) {
        registerWith(discountCurve_);
        registerWith(vol_);
    }

    BlackCapFloorEngine::BlackCapFloorEngine(Handle<YieldTermStructure> discountCurve,
                                             Handle<OptionletVolatilityStructure> volatility,
                                             Real displacement)
    : discountCurve_(std::move(discountCurve)), vol_(std::move(volatility)) {
        QL_REQUIRE(
            vol_->volatilityType() == ShiftedLognormal,
            "BlackCapFloorEngine should only be used for vol surfaces stripped "
            "with shifted log normal model. Options were stripped with model "
                << vol_->volatilityType());
        if (displacement != Null< Real >()) {
            displacement_ = displacement;
            QL_REQUIRE(vol_->displacement() == displacement_,
                       "Displacement used for stripping and provided for "
                       "pricing differ. Model displacement was : "
                           << vol_->displacement());
        } else
            displacement_ = vol_->displacement();
        registerWith(discountCurve_);
        registerWith(vol_);
    }

    void BlackCapFloorEngine::calculate() const {
        Real value = 0.0;
        Real vega = 0.0;
        Size optionlets = arguments_.startDates.size();
        std::vector<Real> values(optionlets, 0.0);
        std::vector<Real> deltas(optionlets, 0.0);
        std::vector<Real> vegas(optionlets, 0.0);
        std::vector<Real> stdDevs(optionlets, 0.0);
        std::vector<DiscountFactor> discountFactors(optionlets, 0.0);
        CapFloor::Type type = arguments_.type;
        Date today = vol_->referenceDate();
        Date settlement = discountCurve_->referenceDate();

        for (Size i=0; i<optionlets; ++i) {
            Date paymentDate = arguments_.endDates[i];
            // handling of settlementDate, npvDate and includeSettlementFlows
            // should be implemented.
            // For the time being just discard expired caplets
            if (paymentDate > settlement) {
                DiscountFactor d = discountCurve_->discount(paymentDate);
                discountFactors[i] = d;
                Real accrualFactor = arguments_.nominals[i] *
                                   arguments_.gearings[i] *
                                   arguments_.accrualTimes[i];
                Real discountedAccrual = d * accrualFactor;
                Rate forward = arguments_.forwards[i];

                Date fixingDate = arguments_.fixingDates[i];
                Time sqrtTime = 0.0;
                if (fixingDate > today)
                    sqrtTime = std::sqrt(vol_->timeFromReference(fixingDate));

                if (type == CapFloor::Cap || type == CapFloor::Collar) {
                    Rate strike = arguments_.capRates[i];
                    if (sqrtTime>0.0) {
                        stdDevs[i] = std::sqrt(vol_->blackVariance(fixingDate,
                                                                   strike));
                        vegas[i] = blackFormulaStdDevDerivative(strike,
                            forward, stdDevs[i], discountedAccrual, displacement_) 
                            * sqrtTime;
                        deltas[i] = blackFormulaAssetItmProbability(Option::Call,
                            strike, forward, stdDevs[i], displacement_);
                    }
                    // include caplets with past fixing date
                    values[i] = blackFormula(Option::Call,
                        strike, forward, stdDevs[i], discountedAccrual, 
                        displacement_);
                }
                if (type == CapFloor::Floor || type == CapFloor::Collar) {
                    Rate strike = arguments_.floorRates[i];
                    Real floorletVega = 0.0;
                    Real floorletDelta = 0.0;
                    if (sqrtTime>0.0) {
                        stdDevs[i] = std::sqrt(vol_->blackVariance(fixingDate,
                                                                   strike));
                        floorletVega = blackFormulaStdDevDerivative(strike,
                            forward, stdDevs[i], discountedAccrual, displacement_) 
                            * sqrtTime;
                        floorletDelta = Integer(Option::Put) * blackFormulaAssetItmProbability(
                                                        Option::Put, strike, forward, 
                                                        stdDevs[i], displacement_);
                    }
                    Real floorlet = blackFormula(Option::Put,
                        strike, forward, stdDevs[i], discountedAccrual, displacement_);
                    if (type == CapFloor::Floor) {
                        values[i] = floorlet;
                        vegas[i] = floorletVega;
                        deltas[i] = floorletDelta;
                    } else {
                        // a collar is long a cap and short a floor
                        values[i] -= floorlet;
                        vegas[i] -= floorletVega;
                        deltas[i] -= floorletDelta; 
                    }
                }
                value += values[i];
                vega += vegas[i];
            }
        }
        results_.value = value;
        results_.additionalResults["vega"] = vega;

        results_.additionalResults["optionletsPrice"] = values;
        results_.additionalResults["optionletsVega"] = vegas;
        results_.additionalResults["optionletsDelta"] = deltas;
        results_.additionalResults["optionletsDiscountFactor"] = discountFactors;
        results_.additionalResults["optionletsAtmForward"] = arguments_.forwards;
        if (type != CapFloor::Collar)
            results_.additionalResults["optionletsStdDev"] = stdDevs;
    }

}
]]></document_content>
  </document>
  <document index="54">
    <source>capfloor/discretizedcapfloor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/capfloor/discretizedcapfloor.hpp>

namespace QuantLib {

    DiscretizedCapFloor::DiscretizedCapFloor(const CapFloor::arguments& args,
                                             const Date& referenceDate,
                                             const DayCounter& dayCounter)
    : arguments_(args) {

        startTimes_.resize(args.startDates.size());
        for (Size i=0; i<startTimes_.size(); ++i)
            startTimes_[i] = dayCounter.yearFraction(referenceDate,
                                                     args.startDates[i]);

        endTimes_.resize(args.endDates.size());
        for (Size i=0; i<endTimes_.size(); ++i)
            endTimes_[i] = dayCounter.yearFraction(referenceDate,
                                                   args.endDates[i]);
    }
    
    void DiscretizedCapFloor::reset(Size size) {
        values_ = Array(size, 0.0);
        adjustValues();
    }

    std::vector<Time> DiscretizedCapFloor::mandatoryTimes() const {
        std::vector<Time> times = startTimes_;
        std::copy(endTimes_.begin(), endTimes_.end(),
                  std::back_inserter(times));
        return times;
    }

    void DiscretizedCapFloor::preAdjustValuesImpl() {
        for (Size i=0; i<startTimes_.size(); i++) {
            if (isOnTime(startTimes_[i])) {
                Time end = endTimes_[i];
                Time tenor = arguments_.accrualTimes[i];
                DiscretizedDiscountBond bond;
                bond.initialize(method(), end);
                bond.rollback(time_);

                CapFloor::Type type = arguments_.type;
                Real gearing = arguments_.gearings[i];
                Real nominal = arguments_.nominals[i];

                if ( (type == CapFloor::Cap) ||
                     (type == CapFloor::Collar)) {
                    Real accrual = 1.0 + arguments_.capRates[i]*tenor;
                    Real strike = 1.0/accrual;
                    for (Size j=0; j<values_.size(); j++)
                        values_[j] += nominal*accrual*gearing*
                            std::max<Real>(strike - bond.values()[j], 0.0);
                }

                if ( (type == CapFloor::Floor) ||
                     (type == CapFloor::Collar)) {
                    Real accrual = 1.0 + arguments_.floorRates[i]*tenor;
                    Real strike = 1.0/accrual;
                    Real mult = (type == CapFloor::Floor)?1.0:-1.0;
                    for (Size j=0; j<values_.size(); j++)
                        values_[j] += nominal*accrual*mult*gearing*
                            std::max<Real>(bond.values()[j] - strike, 0.0);
                }
            }
        }
    }

    void DiscretizedCapFloor::postAdjustValuesImpl() {
        for (Size i=0; i<endTimes_.size(); i++) {
            if (isOnTime(endTimes_[i])) {
                if (startTimes_[i] < 0.0) {
                    Real nominal = arguments_.nominals[i];
                    Time accrual = arguments_.accrualTimes[i];
                    Rate fixing = arguments_.forwards[i];
                    Real gearing = arguments_.gearings[i];
                    CapFloor::Type type = arguments_.type;

                    if (type == CapFloor::Cap || type == CapFloor::Collar) {
                        Rate cap = arguments_.capRates[i];
                        Rate capletRate = std::max(fixing-cap, 0.0);
                        values_ += capletRate*accrual*nominal*gearing;
                    }

                    if (type == CapFloor::Floor || type == CapFloor::Collar) {
                        Rate floor = arguments_.floorRates[i];
                        Rate floorletRate = std::max(floor-fixing, 0.0);
                        if (type == CapFloor::Floor)
                            values_ += floorletRate*accrual*nominal*gearing;
                        else
                            values_ -= floorletRate*accrual*nominal*gearing;
                    }
                }
            }
        }
    }

}
]]></document_content>
  </document>
  <document index="55">
    <source>capfloor/gaussian1dcapfloorengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/capfloor/gaussian1dcapfloorengine.hpp>
#include <ql/math/interpolations/cubicinterpolation.hpp>
#include <ql/payoff.hpp>

namespace QuantLib {

    void Gaussian1dCapFloorEngine::calculate() const {

        for (Real spread : arguments_.spreads)
            QL_REQUIRE(spread == 0.0, "Non zero spreads (" << spread << ") are not allowed.");

        Size optionlets = arguments_.startDates.size();
        std::vector<Real> values(optionlets, 0.0);
        std::vector<Real> forwards(optionlets, 0.0);
        Real value = 0.0;

        Date settlement = model_->termStructure()->referenceDate();

        CapFloor::Type type = arguments_.type;

        Array z = model_->yGrid(stddevs_, integrationPoints_);
        Array p(z.size());

        for (Size i = 0; i < optionlets; ++i) {

            Date valueDate = arguments_.startDates[i];
            Date paymentDate = arguments_.endDates[i];
            ext::shared_ptr<IborIndex> iborIndex =
                ext::dynamic_pointer_cast<IborIndex>(arguments_.indexes[i]);
            // if we do not find an ibor index with associated forwarding curve
            // we fall back on the model curve

            if (paymentDate > settlement) {

                Real f = arguments_.nominals[i] * arguments_.gearings[i];
                Date fixingDate = arguments_.fixingDates[i];
                Time fixingTime =
                    model_->termStructure()->timeFromReference(fixingDate);

                Real strike;

                if (type == CapFloor::Cap || type == CapFloor::Collar) {
                    strike = arguments_.capRates[i];
                    if (fixingDate <= settlement) {
                        values[i] =
                            std::max(arguments_.forwards[i] - strike, 0.0) * f *
                            arguments_.accrualTimes[i];
                    } else {

                        // todo add openmp support later on (as in gaussian1dswaptionengine)

                        for (Size j = 0; j < z.size(); j++) {
                            Real floatingLegNpv;
                            if (iborIndex != nullptr)
                                floatingLegNpv =
                                    arguments_.accrualTimes[i] *
                                    model_->forwardRate(fixingDate, fixingDate,
                                                        z[j], iborIndex) *
                                    model_->zerobond(paymentDate, fixingDate,
                                                     z[j], discountCurve_);
                            else
                                floatingLegNpv =
                                    (model_->zerobond(valueDate, fixingDate,
                                                      z[j]) -
                                     model_->zerobond(paymentDate, fixingDate,
                                                      z[j]));
                            Real fixedLegNpv =
                                arguments_.capRates[i] *
                                arguments_.accrualTimes[i] *
                                model_->zerobond(paymentDate, fixingDate, z[j]);
                            p[j] =
                                std::max((floatingLegNpv - fixedLegNpv), 0.0) /
                                model_->numeraire(fixingTime, z[j],
                                                  discountCurve_);
                        }
                        CubicInterpolation payoff(
                            z.begin(), z.end(), p.begin(),
                            CubicInterpolation::Spline, true,
                            CubicInterpolation::Lagrange, 0.0,
                            CubicInterpolation::Lagrange, 0.0);
                        Real price = 0.0;
                        for (Size j = 0; j < z.size() - 1; j++) {
                            price += Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                0.0, payoff.cCoefficients()[j],
                                payoff.bCoefficients()[j],
                                payoff.aCoefficients()[j], p[j], z[j], z[j],
                                z[j + 1]);
                        }
                        if (extrapolatePayoff_) {
                            if (flatPayoffExtrapolation_) {
                                price +=
                                    Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                        0.0, 0.0, 0.0, 0.0, p[z.size() - 2],
                                        z[z.size() - 2], z[z.size() - 1],
                                        100.0);
                                price +=
                                    Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                        0.0, 0.0, 0.0, 0.0, p[0], z[0], -100.0,
                                        z[0]);
                            } else {
                                price +=
                                    Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                        0.0,
                                        payoff.cCoefficients()[z.size() - 2],
                                        payoff.bCoefficients()[z.size() - 2],
                                        payoff.aCoefficients()[z.size() - 2],
                                        p[z.size() - 2], z[z.size() - 2],
                                        z[z.size() - 1], 100.0);
                            }
                        }
                        values[i] =
                            price *
                            model_->numeraire(0.0, 0.0, discountCurve_) * f;
                    }
                }
                if (type == CapFloor::Floor || type == CapFloor::Collar) {
                    strike = arguments_.floorRates[i];
                    Real floorlet;
                    if (fixingDate <= settlement) {
                        floorlet =
                            std::max(-(arguments_.forwards[i] - strike), 0.0) *
                            f * arguments_.accrualTimes[i];
                    } else {
                        for (Size j = 0; j < z.size(); j++) {
                            Real floatingLegNpv;
                            if (iborIndex != nullptr)
                                floatingLegNpv =
                                    arguments_.accrualTimes[i] *
                                    model_->forwardRate(fixingDate, fixingDate,
                                                        z[j], iborIndex) *
                                    model_->zerobond(paymentDate, fixingDate,
                                                     z[j], discountCurve_);
                            else
                                floatingLegNpv =
                                    (model_->zerobond(valueDate, fixingDate,
                                                      z[j]) -
                                     model_->zerobond(paymentDate, fixingDate,
                                                      z[j]));
                            Real fixedLegNpv =
                                arguments_.floorRates[i] *
                                arguments_.accrualTimes[i] *
                                model_->zerobond(paymentDate, fixingDate, z[j]);
                            p[j] =
                                std::max(-(floatingLegNpv - fixedLegNpv), 0.0) /
                                model_->numeraire(fixingTime, z[j],
                                                  discountCurve_);
                        }
                        CubicInterpolation payoff(
                            z.begin(), z.end(), p.begin(),
                            CubicInterpolation::Spline, true,
                            CubicInterpolation::Lagrange, 0.0,
                            CubicInterpolation::Lagrange, 0.0);
                        Real price = 0.0;
                        for (Size j = 0; j < z.size() - 1; j++) {
                            price += Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                0.0, payoff.cCoefficients()[j],
                                payoff.bCoefficients()[j],
                                payoff.aCoefficients()[j], p[j], z[j], z[j],
                                z[j + 1]);
                        }
                        if (extrapolatePayoff_) {
                            if (flatPayoffExtrapolation_) {
                                price +=
                                    Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                        0.0, 0.0, 0.0, 0.0, p[z.size() - 2],
                                        z[z.size() - 2], z[z.size() - 1],
                                        100.0);
                                price +=
                                    Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                        0.0, 0.0, 0.0, 0.0, p[0], z[0], -100.0,
                                        z[0]);
                            } else {
                                price +=
                                    Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                        0.0, payoff.cCoefficients()[0],
                                        payoff.bCoefficients()[0],
                                        payoff.aCoefficients()[0], p[0], z[0],
                                        -100.0, z[0]);
                            }
                        }
                        floorlet = price *
                                   model_->numeraire(0.0, 0.0, discountCurve_) *
                                   f;
                    }
                    if (type == CapFloor::Floor) {
                        values[i] = floorlet;
                    } else {
                        // a collar is long a cap and short a floor
                        values[i] -= floorlet;
                    }
                }

                value += values[i];
            }
        }

        results_.value = value;

        results_.additionalResults["optionletsPrice"] = values;
        results_.additionalResults["optionletsAtmForward"] = forwards;
    }

}
]]></document_content>
  </document>
  <document index="56">
    <source>capfloor/mchullwhiteengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Banca Profilo S.p.A.
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/capfloor/mchullwhiteengine.hpp>
#include <utility>

namespace QuantLib::detail {

        HullWhiteCapFloorPricer::HullWhiteCapFloorPricer(const CapFloor::arguments& args,
                                                         ext::shared_ptr<HullWhite> model,
                                                         Time forwardMeasureTime)
        : args_(args), model_(std::move(model)), forwardMeasureTime_(forwardMeasureTime) {
            endDiscount_ =
                model_->termStructure()->discount(forwardMeasureTime_);

            Date referenceDate = model_->termStructure()->referenceDate();
            DayCounter dayCounter = model_->termStructure()->dayCounter();

            startTimes_.resize(args.startDates.size());
            for (Size i=0; i<startTimes_.size(); ++i)
                startTimes_[i] = dayCounter.yearFraction(referenceDate,
                                                         args.startDates[i]);

            endTimes_.resize(args.endDates.size());
            for (Size i=0; i<endTimes_.size(); ++i)
                endTimes_[i] = dayCounter.yearFraction(referenceDate,
                                                       args.endDates[i]);

            fixingTimes_.resize(args.fixingDates.size());
            for (Size i=0; i<fixingTimes_.size(); ++i)
                fixingTimes_[i] = dayCounter.yearFraction(referenceDate,
                                                          args.fixingDates[i]);
        }

        Real HullWhiteCapFloorPricer::operator()(const Path& path) const {

            bool isCap = (args_.type == CapFloor::Cap);
            Real npv = 0.0;
            Time Tb = forwardMeasureTime_;

            Size pastFixings = 0;
            for (Size i = 0; i<fixingTimes_.size(); i++) {
                Time tau = args_.accrualTimes[i];
                Time start = startTimes_[i],
                     end = endTimes_[i],
                     fixing = fixingTimes_[i];
                if (end <= 0.0) {
                    // the fixing is in the past...
                    pastFixings++;
                    // ...and the caplet is expired; nothing more to do.
                } else {
                    Rate ri_1, ri_2, currentLibor;
                    if (fixing <= 0.0) {
                        // current caplet. The fixing is in the past...
                        pastFixings++;
                        // ...so it is determined.
                        currentLibor = args_.forwards[i];
                        // However, the short rate at caplet expiry is not.
                        ri_2 = path[i-pastFixings+2];
                    } else {
                        // future caplet. Everything is to be forecast.
                        // The number of past fixings is used as an offset
                        // to index into the path.
                        ri_1 = path[i-pastFixings+1];
                        ri_2 = path[i-pastFixings+2];

                        DiscountFactor d1 =
                            model_->discountBond(fixing, start, ri_1);
                        DiscountFactor d2 =
                            model_->discountBond(fixing, end, ri_1);
                        currentLibor = (d1/d2-1)/tau;
                    }

                    Real accrualFactor =
                        1.0/model_->discountBond(end, Tb, ri_2);

                    Rate strike = isCap?
                        args_.capRates[i] :
                        args_.floorRates[i];
                    Real payoff = isCap?
                        std::max(currentLibor - strike, 0.0) :
                    std::max(strike - currentLibor, 0.0);

                    npv += payoff * tau * args_.gearings[i] *
                           args_.nominals[i] * accrualFactor;
                }
            }
            npv *= endDiscount_;
            return  npv;
        }

    }

]]></document_content>
  </document>
  <document index="57">
    <source>capfloor/treecapfloorengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/shortrate/onefactormodel.hpp>
#include <ql/pricingengines/capfloor/discretizedcapfloor.hpp>
#include <ql/pricingengines/capfloor/treecapfloorengine.hpp>
#include <utility>

namespace QuantLib {

    TreeCapFloorEngine::TreeCapFloorEngine(const ext::shared_ptr<ShortRateModel>& model,
                                           Size timeSteps,
                                           Handle<YieldTermStructure> termStructure)
    : LatticeShortRateModelEngine<CapFloor::arguments, CapFloor::results>(model, timeSteps),
      termStructure_(std::move(termStructure)) {
        registerWith(termStructure_);
    }

    TreeCapFloorEngine::TreeCapFloorEngine(const ext::shared_ptr<ShortRateModel>& model,
                                           const TimeGrid& timeGrid,
                                           Handle<YieldTermStructure> termStructure)
    : LatticeShortRateModelEngine<CapFloor::arguments, CapFloor::results>(model, timeGrid),
      termStructure_(std::move(termStructure)) {
        registerWith(termStructure_);
    }

    void TreeCapFloorEngine::calculate() const {

        QL_REQUIRE(!model_.empty(), "no model specified");

        Date referenceDate;
        DayCounter dayCounter;

        ext::shared_ptr<TermStructureConsistentModel> tsmodel =
            ext::dynamic_pointer_cast<TermStructureConsistentModel>(*model_);
        if (tsmodel != nullptr) {
            referenceDate = tsmodel->termStructure()->referenceDate();
            dayCounter = tsmodel->termStructure()->dayCounter();
        } else {
            referenceDate = termStructure_->referenceDate();
            dayCounter = termStructure_->dayCounter();
        }

        DiscretizedCapFloor capfloor(arguments_, referenceDate, dayCounter);
        ext::shared_ptr<Lattice> lattice;

        if (lattice_ != nullptr) {
            lattice = lattice_;
        } else {
            std::vector<Time> times = capfloor.mandatoryTimes();
            TimeGrid timeGrid(times.begin(), times.end(), timeSteps_);
            lattice = model_->tree(timeGrid);
        }

        Time firstTime = dayCounter.yearFraction(referenceDate,
                                                 arguments_.startDates.front());
        Time lastTime = dayCounter.yearFraction(referenceDate,
                                                arguments_.endDates.back());
        capfloor.initialize(lattice, lastTime);
        capfloor.rollback(firstTime);

        results_.value = capfloor.presentValue();
    }

}


]]></document_content>
  </document>
  <document index="58">
    <source>cliquet/analyticcliquetengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/pricingengines/cliquet/analyticcliquetengine.hpp>
#include <utility>

namespace QuantLib {

    AnalyticCliquetEngine::AnalyticCliquetEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticCliquetEngine::calculate() const {

        QL_REQUIRE(arguments_.accruedCoupon == Null<Real>() &&
                   arguments_.lastFixing == Null<Real>(),
                   "this engine cannot price options already started");
        QL_REQUIRE(arguments_.localCap == Null<Real>() &&
                   arguments_.localFloor == Null<Real>() &&
                   arguments_.globalCap == Null<Real>() &&
                   arguments_.globalFloor == Null<Real>(),
                   "this engine cannot price capped/floored options");

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European option");

        ext::shared_ptr<PercentageStrikePayoff> moneyness =
            ext::dynamic_pointer_cast<PercentageStrikePayoff>(
                                                           arguments_.payoff);
        QL_REQUIRE(moneyness, "wrong payoff given");

        std::vector<Date> resetDates = arguments_.resetDates;
        resetDates.push_back(arguments_.exercise->lastDate());

        Real underlying = process_->stateVariable()->value();
        QL_REQUIRE(underlying > 0.0, "negative or null underlying");
        Real strike = underlying * moneyness->strike();
        ext::shared_ptr<StrikedTypePayoff> payoff(
                      new PlainVanillaPayoff(moneyness->optionType(),strike));

        results_.value = 0.0;
        results_.delta = results_.gamma = 0.0;
        results_.theta = 0.0;
        results_.rho = results_.dividendRho = 0.0;
        results_.vega = 0.0;

        for (Size i = 1; i < resetDates.size(); i++) {

            Real weight =
                process_->dividendYield()->discount(resetDates[i-1]);
            DiscountFactor discount =
                process_->riskFreeRate()->discount(resetDates[i]) /
                process_->riskFreeRate()->discount(resetDates[i-1]);
            DiscountFactor qDiscount =
                process_->dividendYield()->discount(resetDates[i]) /
                process_->dividendYield()->discount(resetDates[i-1]);
            Real forward = underlying*qDiscount/discount;
            Real variance =
                process_->blackVolatility()->blackForwardVariance(
                                        resetDates[i-1],resetDates[i],strike);

            BlackCalculator black(payoff, forward, std::sqrt(variance), discount);

            DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
            DayCounter divdc = process_->dividendYield()->dayCounter();
            DayCounter voldc = process_->blackVolatility()->dayCounter();

            results_.value += weight * black.value();
            results_.delta += weight * (black.delta(underlying) +
                                        moneyness->strike() * discount *
                                        black.beta());
            results_.gamma += 0.0;
            results_.theta += process_->dividendYield()->forwardRate(
                resetDates[i-1], resetDates[i], rfdc, Continuous, NoFrequency) *
                weight * black.value();

            Time dt = rfdc.yearFraction(resetDates[i-1],resetDates[i]);
            results_.rho += weight * black.rho(dt);

            Time t = divdc.yearFraction(
                                    process_->dividendYield()->referenceDate(),
                                    resetDates[i-1]);
            dt = divdc.yearFraction(resetDates[i-1],resetDates[i]);
            results_.dividendRho += weight * (black.dividendRho(dt) -
                                              t * black.value());

            dt = voldc.yearFraction(resetDates[i-1], resetDates[i]);
            results_.vega += weight * black.vega(dt);
        }

    }

}

]]></document_content>
  </document>
  <document index="59">
    <source>cliquet/analyticperformanceengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/pricingengines/cliquet/analyticperformanceengine.hpp>
#include <utility>

namespace QuantLib {

    AnalyticPerformanceEngine::AnalyticPerformanceEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticPerformanceEngine::calculate() const {

        QL_REQUIRE(arguments_.accruedCoupon == Null<Real>() &&
                   arguments_.lastFixing == Null<Real>(),
                   "this engine cannot price options already started");
        QL_REQUIRE(arguments_.localCap == Null<Real>() &&
                   arguments_.localFloor == Null<Real>() &&
                   arguments_.globalCap == Null<Real>() &&
                   arguments_.globalFloor == Null<Real>(),
                   "this engine cannot price capped/floored options");

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European option");

        ext::shared_ptr<PercentageStrikePayoff> moneyness =
            ext::dynamic_pointer_cast<PercentageStrikePayoff>(
                                                           arguments_.payoff);
        QL_REQUIRE(moneyness, "wrong payoff given");

        std::vector<Date> resetDates = arguments_.resetDates;
        resetDates.push_back(arguments_.exercise->lastDate());

        Real underlying = process_->stateVariable()->value();
        QL_REQUIRE(underlying > 0.0, "negative or null underlying");

        ext::shared_ptr<StrikedTypePayoff> payoff(
                        new PlainVanillaPayoff(moneyness->optionType(), 1.0));

        results_.value = 0.0;
        results_.delta = results_.gamma = 0.0;
        results_.theta = 0.0;
        results_.rho = results_.dividendRho = 0.0;
        results_.vega = 0.0;

        for (Size i = 1; i < resetDates.size(); i++) {

            DiscountFactor discount =
                process_->riskFreeRate()->discount(resetDates[i-1]);
            DiscountFactor rDiscount =
                process_->riskFreeRate()->discount(resetDates[i]) /
                process_->riskFreeRate()->discount(resetDates[i-1]);
            DiscountFactor qDiscount =
                process_->dividendYield()->discount(resetDates[i]) /
                process_->dividendYield()->discount(resetDates[i-1]);
            Real forward = (1.0/moneyness->strike())*qDiscount/rDiscount;
            Real variance =
                process_->blackVolatility()->blackForwardVariance(
                                        resetDates[i-1],resetDates[i],
                                        underlying * moneyness->strike());

            BlackCalculator black(payoff, forward, std::sqrt(variance), rDiscount);

            DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
            DayCounter divdc = process_->dividendYield()->dayCounter();
            DayCounter voldc = process_->blackVolatility()->dayCounter();

            results_.value += discount * moneyness->strike() * black.value();
            results_.delta += 0.0;
            results_.gamma += 0.0;
            results_.theta += process_->riskFreeRate()->forwardRate(
                resetDates[i-1], resetDates[i], rfdc, Continuous, NoFrequency) *
                discount * moneyness->strike() * black.value();

            Time dt = rfdc.yearFraction(resetDates[i-1],resetDates[i]);
            Time t = rfdc.yearFraction(
                                  process_->riskFreeRate()->referenceDate(),
                                  resetDates[i-1]);
            results_.rho += discount * moneyness->strike() *
                (black.rho(dt) - t * black.value());

            dt = divdc.yearFraction(resetDates[i-1],resetDates[i]);
            results_.dividendRho += discount * moneyness->strike() *
                black.dividendRho(dt);

            dt = voldc.yearFraction(resetDates[i-1], resetDates[i]);
            results_.vega += discount * moneyness->strike() * black.vega(dt);
        }

    }

}

]]></document_content>
  </document>
  <document index="60">
    <source>cliquet/mcperformanceengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/cliquet/mcperformanceengine.hpp>
#include <utility>

namespace QuantLib {

    PerformanceOptionPathPricer::PerformanceOptionPathPricer(Option::Type type,
                                                             Real strike,
                                                             std::vector<DiscountFactor> discounts)
    : strike_(strike), type_(type), discounts_(std::move(discounts)) {}

    Real PerformanceOptionPathPricer::operator()(const Path& path) const {

        Size n = path.length();
        QL_REQUIRE(n==discounts_.size()+1, "discounts/options mismatch");
        PlainVanillaPayoff payoff(type_,strike_);

        Real sum = 0.0;
        for (Size i = 2 ; i < n; i++) {
            sum += discounts_[i-1] * payoff(path[i]/path[i-1]);
        }

        return sum;
    }

}

]]></document_content>
  </document>
  <document index="61">
    <source>credit/integralcdsengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2008, 2009 StatPro Italia srl
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/instruments/claim.hpp>
#include <ql/pricingengines/credit/integralcdsengine.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/optional.hpp>
#include <utility>

namespace QuantLib {

    IntegralCdsEngine::IntegralCdsEngine(const Period& step,
                                         Handle<DefaultProbabilityTermStructure> probability,
                                         Real recoveryRate,
                                         Handle<YieldTermStructure> discountCurve,
                                         const ext::optional<bool>& includeSettlementDateFlows)
    : integrationStep_(step), probability_(std::move(probability)), recoveryRate_(recoveryRate),
      discountCurve_(std::move(discountCurve)),
      includeSettlementDateFlows_(includeSettlementDateFlows) {
        registerWith(probability_);
        registerWith(discountCurve_);
    }

    void IntegralCdsEngine::calculate() const {
        QL_REQUIRE(integrationStep_ != Period(),
                   "null period set");
        QL_REQUIRE(!discountCurve_.empty(),
                   "no discount term structure set");
        QL_REQUIRE(!probability_.empty(),
                   "no probability term structure set");

        Date today = Settings::instance().evaluationDate();
        Date settlementDate = discountCurve_->referenceDate();

        // Upfront amount.
        Real upfPVO1 = 0.0;
        results_.upfrontNPV = 0.0;
        if (!arguments_.upfrontPayment->hasOccurred(
            settlementDate, includeSettlementDateFlows_)) {
            upfPVO1 = discountCurve_->discount(arguments_.upfrontPayment->date());
            results_.upfrontNPV = upfPVO1 * arguments_.upfrontPayment->amount();
        }

        // Accrual rebate.
        results_.accrualRebateNPV = 0.;
        // NOLINTNEXTLINE(readability-implicit-bool-conversion)
        if (arguments_.accrualRebate &&
            !arguments_.accrualRebate->hasOccurred(settlementDate, includeSettlementDateFlows_)) {
            results_.accrualRebateNPV =
                discountCurve_->discount(arguments_.accrualRebate->date()) *
                arguments_.accrualRebate->amount();
        }

        results_.couponLegNPV = 0.0;
        results_.defaultLegNPV = 0.0;
        for (Size i=0; i<arguments_.leg.size(); ++i) {
            if (arguments_.leg[i]->hasOccurred(settlementDate,
                                               includeSettlementDateFlows_))
                continue;

            ext::shared_ptr<FixedRateCoupon> coupon =
                ext::dynamic_pointer_cast<FixedRateCoupon>(arguments_.leg[i]);

            // In order to avoid a few switches, we calculate the NPV
            // of both legs as a positive quantity. We'll give them
            // the right sign at the end.

            Date paymentDate = coupon->date(),
                 startDate = (i == 0 ? arguments_.protectionStart :
                                       coupon->accrualStartDate()),
                 endDate = coupon->accrualEndDate();
            Date effectiveStartDate =
                (startDate <= today && today <= endDate) ? today : startDate;
            Real couponAmount = coupon->amount();

            Probability S = probability_->survivalProbability(paymentDate);

            // On one side, we add the fixed rate payments in case of
            // survival.
            results_.couponLegNPV +=
                S * couponAmount * discountCurve_->discount(paymentDate);

            // On the other side, we add the payment (and possibly the
            // accrual) in case of default.

            Period step = integrationStep_;
            Date d0 = effectiveStartDate;
            Date d1 = std::min(d0 + step, endDate);
            Probability P0 = probability_->defaultProbability(d0);
            DiscountFactor endDiscount = discountCurve_->discount(paymentDate);
            do {
                DiscountFactor B =
                    arguments_.paysAtDefaultTime ?
                    discountCurve_->discount(d1) :
                    endDiscount;

                Probability P1 = probability_->defaultProbability(d1);
                Probability dP = P1 - P0;

                // accrual...
                if (arguments_.settlesAccrual) {
                    if (arguments_.paysAtDefaultTime)
                        results_.couponLegNPV +=
                            coupon->accruedAmount(d1) * B * dP;
                    else
                        results_.couponLegNPV +=
                            couponAmount * B * dP;
                }

                // ...and claim.
                Real claim = arguments_.claim->amount(d1,
                                                      arguments_.notional,
                                                      recoveryRate_);
                results_.defaultLegNPV += claim * B * dP;

                // setup for next time around the loop
                P0 = P1;
                d0 = d1;
                d1 = std::min(d0 + step, endDate);
            } while (d0 < endDate);
        }

        Real upfrontSign = 1.0;
        switch (arguments_.side) {
          case Protection::Seller:
            results_.defaultLegNPV *= -1.0;
            results_.accrualRebateNPV *= -1.0;
            break;
          case Protection::Buyer:
            results_.couponLegNPV *= -1.0;
            results_.upfrontNPV   *= -1.0;
            upfrontSign = -1.0;
            break;
          default:
            QL_FAIL("unknown protection side");
        }

        results_.value =
            results_.defaultLegNPV + results_.couponLegNPV +
                results_.upfrontNPV + results_.accrualRebateNPV;
        results_.errorEstimate = Null<Real>();

        if (results_.couponLegNPV != 0.0) {
            results_.fairSpread =
                -results_.defaultLegNPV*arguments_.spread
                    /(results_.couponLegNPV + results_.accrualRebateNPV);
        } else {
            results_.fairSpread = Null<Rate>();
        }

        if (upfPVO1 > 0.0) {
            results_.fairUpfront =
                -upfrontSign*(results_.defaultLegNPV + results_.couponLegNPV +
                    results_.accrualRebateNPV)
                / (upfPVO1 * arguments_.notional);
        } else {
            results_.fairUpfront = Null<Rate>();
        }

        static const Rate basisPoint = 1.0e-4;

        if (arguments_.spread != 0.0) {
            results_.couponLegBPS =
                results_.couponLegNPV*basisPoint/arguments_.spread;
        } else {
            results_.couponLegBPS = Null<Rate>();
        }

        // NOLINTNEXTLINE(readability-implicit-bool-conversion)
        if (arguments_.upfront && *arguments_.upfront != 0.0) {
            results_.upfrontBPS =
                results_.upfrontNPV*basisPoint/(*arguments_.upfront);
        } else {
            results_.upfrontBPS = Null<Rate>();
        }
    }

}
]]></document_content>
  </document>
  <document index="62">
    <source>credit/isdacdsengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/instruments/claim.hpp>
#include <ql/math/interpolations/forwardflatinterpolation.hpp>
#include <ql/pricingengines/credit/isdacdsengine.hpp>
#include <ql/termstructures/credit/flathazardrate.hpp>
#include <ql/termstructures/credit/piecewisedefaultcurve.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/yield/piecewiseyieldcurve.hpp>
#include <ql/time/calendars/weekendsonly.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/optional.hpp>
#include <utility>

namespace QuantLib {

    IsdaCdsEngine::IsdaCdsEngine(Handle<DefaultProbabilityTermStructure> probability,
                                 Real recoveryRate,
                                 Handle<YieldTermStructure> discountCurve,
                                 const ext::optional<bool>& includeSettlementDateFlows,
                                 const NumericalFix numericalFix,
                                 const AccrualBias accrualBias,
                                 const ForwardsInCouponPeriod forwardsInCouponPeriod)
    : probability_(std::move(probability)), recoveryRate_(recoveryRate),
      discountCurve_(std::move(discountCurve)),
      includeSettlementDateFlows_(includeSettlementDateFlows), numericalFix_(numericalFix),
      accrualBias_(accrualBias), forwardsInCouponPeriod_(forwardsInCouponPeriod) {

        registerWith(probability_);
        registerWith(discountCurve_);
    }

    void IsdaCdsEngine::calculate() const {

        QL_REQUIRE(numericalFix_ == None || numericalFix_ == Taylor,
                   "numerical fix must be None or Taylor");
        QL_REQUIRE(accrualBias_ == HalfDayBias || accrualBias_ == NoBias,
                   "accrual bias must be HalfDayBias or NoBias");
        QL_REQUIRE(forwardsInCouponPeriod_ == Flat ||
                       forwardsInCouponPeriod_ == Piecewise,
                   "forwards in coupon period must be Flat or Piecewise");

        // it would be possible to handle the cases which are excluded below,
        // but the ISDA engine is not explicitly specified to handle them,
        // so we just forbid them too

        Actual365Fixed dc;
        Actual360 dc1;
        Actual360 dc2(true);

        Date evalDate = Settings::instance().evaluationDate();

        // check if given curves are ISDA compatible
        // (the interpolation is checked below)

        QL_REQUIRE(!discountCurve_.empty(), "no discount term structure set");
        QL_REQUIRE(!probability_.empty(), "no probability term structure set");
        QL_REQUIRE(discountCurve_->dayCounter() == dc,
                   "yield term structure day counter ("
                       << discountCurve_->dayCounter()
                       << ") should be Act/365(Fixed)");
        QL_REQUIRE(probability_->dayCounter() == dc,
                   "probability term structure day counter ("
                       << probability_->dayCounter() << ") should be "
                       << "Act/365(Fixed)");
        QL_REQUIRE(discountCurve_->referenceDate() == evalDate,
                   "yield term structure reference date ("
                       << discountCurve_->referenceDate()
                       << " should be evaluation date (" << evalDate << ")");
        QL_REQUIRE(probability_->referenceDate() == evalDate,
                   "probability term structure reference date ("
                       << probability_->referenceDate()
                       << " should be evaluation date (" << evalDate << ")");
        QL_REQUIRE(arguments_.settlesAccrual,
                   "ISDA engine not compatible with non accrual paying CDS");
        QL_REQUIRE(arguments_.paysAtDefaultTime,
                   "ISDA engine not compatible with end period payment");
        QL_REQUIRE(ext::dynamic_pointer_cast<FaceValueClaim>(arguments_.claim) != nullptr,
                   "ISDA engine not compatible with non face value claim");

        Date maturity = arguments_.maturity;
        Date effectiveProtectionStart =
            std::max<Date>(arguments_.protectionStart, evalDate + 1);

        // collect nodes from both curves and sort them
        std::vector<Date> yDates, cDates;

        // the calls to dates() below might not trigger bootstrap (because
        // they will call the InterpolatedCurve methods, not the ones from
        // PiecewiseYieldCurve or PiecewiseDefaultCurve) so we force it here
        discountCurve_->discount(0.0);
        probability_->defaultProbability(0.0);

        if(ext::shared_ptr<InterpolatedDiscountCurve<LogLinear> > castY1 =
            ext::dynamic_pointer_cast<
                InterpolatedDiscountCurve<LogLinear> >(*discountCurve_)) {
            yDates = castY1->dates();
        } else if(ext::shared_ptr<InterpolatedForwardCurve<BackwardFlat> >
        castY2 = ext::dynamic_pointer_cast<
            InterpolatedForwardCurve<BackwardFlat> >(*discountCurve_)) {
            yDates = castY2->dates();
        } else if(ext::shared_ptr<InterpolatedForwardCurve<ForwardFlat> >
        castY3 = ext::dynamic_pointer_cast<
            InterpolatedForwardCurve<ForwardFlat> >(*discountCurve_)) {
            yDates = castY3->dates();
        } else if(ext::shared_ptr<FlatForward> castY4 =
            ext::dynamic_pointer_cast<FlatForward>(*discountCurve_)) {
            // no dates to extract
        } else {
            QL_FAIL("Yield curve must be flat forward interpolated");
        }

        if(ext::shared_ptr<InterpolatedSurvivalProbabilityCurve<LogLinear> >
        castC1 = ext::dynamic_pointer_cast<
            InterpolatedSurvivalProbabilityCurve<LogLinear> >(
            *probability_)) {
            cDates = castC1->dates();
        } else if(
        ext::shared_ptr<InterpolatedHazardRateCurve<BackwardFlat> > castC2 =
            ext::dynamic_pointer_cast<
            InterpolatedHazardRateCurve<BackwardFlat> >(*probability_)) {
            cDates = castC2->dates();
        } else if(
        ext::shared_ptr<FlatHazardRate> castC3 =
            ext::dynamic_pointer_cast<FlatHazardRate>(*probability_)) {
            // no dates to extract
        } else{
            QL_FAIL("Credit curve must be flat forward interpolated");
        }

        std::vector<Date> nodes;
        std::set_union(yDates.begin(), yDates.end(), cDates.begin(), cDates.end(), std::back_inserter(nodes));


        if(nodes.empty()){
            nodes.push_back(maturity);
        }
        const Real nFix = (numericalFix_ == None ? 1E-50 : 0.0);

        // protection leg pricing (npv is always negative at this stage)
        Real protectionNpv = 0.0;

        Date d0 = effectiveProtectionStart-1;
        Real P0 = discountCurve_->discount(d0);
        Real Q0 = probability_->survivalProbability(d0);
        Date d1;
        auto it =
            std::upper_bound(nodes.begin(), nodes.end(), effectiveProtectionStart);

        for(;it != nodes.end(); ++it) {
            if(*it > maturity) {
                d1 = maturity;
                it = nodes.end() - 1; //early exit
            } else {
                d1 = *it;
            }
            Real P1 = discountCurve_->discount(d1);
            Real Q1 = probability_->survivalProbability(d1);

            Real fhat = std::log(P0) - std::log(P1);
            Real hhat = std::log(Q0) - std::log(Q1);
            Real fhphh = fhat + hhat;

            if (fhphh < 1E-4 && numericalFix_ == Taylor) {
                Real fhphhq = fhphh * fhphh;
                protectionNpv +=
                    P0 * Q0 * hhat * (1.0 - 0.5 * fhphh + 1.0 / 6.0 * fhphhq -
                                      1.0 / 24.0 * fhphhq * fhphh +
                                      1.0 / 120 * fhphhq * fhphhq);
            } else {
                protectionNpv += hhat / (fhphh + nFix) * (P0 * Q0 - P1 * Q1);
            }
            d0 = d1;
            P0 = P1;
            Q0 = Q1;
        }
        protectionNpv *= arguments_.claim->amount(
            Date(), arguments_.notional, recoveryRate_);

        results_.defaultLegNPV = protectionNpv;

        // premium leg pricing (npv is always positive at this stage)

        Real premiumNpv = 0.0, defaultAccrualNpv = 0.0;
        for (auto& i : arguments_.leg) {
            ext::shared_ptr<FixedRateCoupon> coupon = ext::dynamic_pointer_cast<FixedRateCoupon>(i);

            QL_REQUIRE(coupon->dayCounter() == dc ||
                           coupon->dayCounter() == dc1 ||
                           coupon->dayCounter() == dc2,
                       "ISDA engine requires a coupon day counter Act/365Fixed "
                           << "or Act/360 (" << coupon->dayCounter() << ")");

            // premium coupons
            if (!i->hasOccurred(effectiveProtectionStart, includeSettlementDateFlows_)) {
                premiumNpv +=
                    coupon->amount() *
                    discountCurve_->discount(coupon->date()) *
                    probability_->survivalProbability(coupon->date()-1);
            }

            // default accruals

            if (!detail::simple_event(coupon->accrualEndDate())
                     .hasOccurred(effectiveProtectionStart, false)) {
                Date start = std::max<Date>(coupon->accrualStartDate(),
                                            effectiveProtectionStart)-1;
                Date end = coupon->date()-1;
                Real tstart =
                    discountCurve_->timeFromReference(coupon->accrualStartDate()-1) -
                    (accrualBias_ == HalfDayBias ? 1.0 / 730.0 : 0.0);
                std::vector<Date> localNodes;
                localNodes.push_back(start);
                //add intermediary nodes, if any
                if (forwardsInCouponPeriod_ == Piecewise) {
                    auto it0 =
                        std::upper_bound(nodes.begin(), nodes.end(), start);
                    auto it1 =
                        std::lower_bound(nodes.begin(), nodes.end(), end);
                    localNodes.insert(localNodes.end(), it0, it1);
                }
                localNodes.push_back(end);

                Real defaultAccrThisNode = 0.;
                auto node = localNodes.begin();
                Real t0 = discountCurve_->timeFromReference(*node);
                Real P0 = discountCurve_->discount(*node);
                Real Q0 = probability_->survivalProbability(*node);

                for (++node; node != localNodes.end(); ++node) {
                    Real t1 = discountCurve_->timeFromReference(*node);
                    Real P1 = discountCurve_->discount(*node);
                    Real Q1 = probability_->survivalProbability(*node);
                    Real fhat = std::log(P0) - std::log(P1);
                    Real hhat = std::log(Q0) - std::log(Q1);
                    Real fhphh = fhat + hhat;
                    if (fhphh < 1E-4 && numericalFix_ == Taylor) {
                        // see above, terms up to (f+h)^3 seem more than enough,
                        // what exactly is implemented in the standard isda C
                        // code ?
                        Real fhphhq = fhphh * fhphh;
                        defaultAccrThisNode +=
                            hhat * P0 * Q0 *
                            ((t0 - tstart) *
                                 (1.0 - 0.5 * fhphh + 1.0 / 6.0 * fhphhq -
                                  1.0 / 24.0 * fhphhq * fhphh) +
                             (t1 - t0) *
                                 (0.5 - 1.0 / 3.0 * fhphh + 1.0 / 8.0 * fhphhq -
                                  1.0 / 30.0 * fhphhq * fhphh));
                    } else {
                        defaultAccrThisNode +=
                            (hhat / (fhphh + nFix)) *
                            ((t1 - t0) * ((P0 * Q0 - P1 * Q1) / (fhphh + nFix) -
                                          P1 * Q1) +
                             (t0 - tstart) * (P0 * Q0 - P1 * Q1));
                    }

                    t0 = t1;
                    P0 = P1;
                    Q0 = Q1;
                }
                defaultAccrualNpv += defaultAccrThisNode * arguments_.notional *
                    coupon->rate() * 365. / 360.;
			}
        }


        results_.couponLegNPV = premiumNpv + defaultAccrualNpv;

        // upfront flow npv

        Real upfPVO1 = 0.0;
        results_.upfrontNPV = 0.0;
        if (!arguments_.upfrontPayment->hasOccurred(
                evalDate, includeSettlementDateFlows_)) {
            upfPVO1 =
                discountCurve_->discount(arguments_.upfrontPayment->date());
            if(arguments_.upfrontPayment->amount() != 0.) {
                results_.upfrontNPV = upfPVO1 * arguments_.upfrontPayment->amount();
            }
        }

        results_.accrualRebateNPV = 0.;
        // NOLINTNEXTLINE(readability-implicit-bool-conversion)
        if (arguments_.accrualRebate && arguments_.accrualRebate->amount() != 0. &&
            !arguments_.accrualRebate->hasOccurred(evalDate, includeSettlementDateFlows_)) {
            results_.accrualRebateNPV =
                discountCurve_->discount(arguments_.accrualRebate->date()) *
                arguments_.accrualRebate->amount();
        }

        Real upfrontSign = 1.0;
        switch (arguments_.side) {
          case Protection::Seller:
            results_.defaultLegNPV *= -1.0;
            results_.accrualRebateNPV *= -1.0;
            break;
          case Protection::Buyer:
            results_.couponLegNPV *= -1.0;
            results_.upfrontNPV   *= -1.0;
            upfrontSign = -1.0;
            break;
          default:
            QL_FAIL("unknown protection side");
        }

        results_.value = results_.defaultLegNPV + results_.couponLegNPV +
                         results_.upfrontNPV + results_.accrualRebateNPV;

        results_.errorEstimate = Null<Real>();

        if (results_.couponLegNPV != 0.0) {
            results_.fairSpread =
                -results_.defaultLegNPV * arguments_.spread /
                (results_.couponLegNPV + results_.accrualRebateNPV);
        } else {
            results_.fairSpread = Null<Rate>();
        }

        Real upfrontSensitivity = upfPVO1 * arguments_.notional;
        if (upfrontSensitivity != 0.0) {
            results_.fairUpfront =
                -upfrontSign * (results_.defaultLegNPV + results_.couponLegNPV +
                                results_.accrualRebateNPV) /
                upfrontSensitivity;
        } else {
            results_.fairUpfront = Null<Rate>();
        }

        static const Rate basisPoint = 1.0e-4;

        if (arguments_.spread != 0.0) {
            results_.couponLegBPS =
                results_.couponLegNPV * basisPoint / arguments_.spread;
        } else {
            results_.couponLegBPS = Null<Rate>();
        }

        // NOLINTNEXTLINE(readability-implicit-bool-conversion)
        if (arguments_.upfront && *arguments_.upfront != 0.0) {
            results_.upfrontBPS =
                results_.upfrontNPV * basisPoint / (*arguments_.upfront);
        } else {
            results_.upfrontBPS = Null<Rate>();
        }
    }
}
]]></document_content>
  </document>
  <document index="63">
    <source>credit/midpointcdsengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 Jose Aparicio
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2008, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/instruments/claim.hpp>
#include <ql/pricingengines/credit/midpointcdsengine.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/optional.hpp>
#include <utility>

namespace QuantLib {

    MidPointCdsEngine::MidPointCdsEngine(Handle<DefaultProbabilityTermStructure> probability,
                                         Real recoveryRate,
                                         Handle<YieldTermStructure> discountCurve,
                                         const ext::optional<bool>& includeSettlementDateFlows)
    : probability_(std::move(probability)), recoveryRate_(recoveryRate),
      discountCurve_(std::move(discountCurve)),
      includeSettlementDateFlows_(includeSettlementDateFlows) {
        registerWith(probability_);
        registerWith(discountCurve_);
    }

    void MidPointCdsEngine::calculate() const {
        QL_REQUIRE(!discountCurve_.empty(),
                   "no discount term structure set");
        QL_REQUIRE(!probability_.empty(),
                   "no probability term structure set");

        Date today = Settings::instance().evaluationDate();
        Date settlementDate = discountCurve_->referenceDate();

        // Upfront amount.
        Real upfPVO1 = 0.0;
        results_.upfrontNPV = 0.0;
        if (!arguments_.upfrontPayment->hasOccurred(
            settlementDate, includeSettlementDateFlows_)) {
            upfPVO1 = discountCurve_->discount(arguments_.upfrontPayment->date());
            results_.upfrontNPV = upfPVO1 * arguments_.upfrontPayment->amount();
        }

        // Accrual rebate.
        results_.accrualRebateNPV = 0.;
        // NOLINTNEXTLINE(readability-implicit-bool-conversion)
        if (arguments_.accrualRebate &&
            !arguments_.accrualRebate->hasOccurred(settlementDate, includeSettlementDateFlows_)) {
            results_.accrualRebateNPV =
                discountCurve_->discount(arguments_.accrualRebate->date()) *
                arguments_.accrualRebate->amount();
        }

        results_.couponLegNPV  = 0.0;
        results_.defaultLegNPV = 0.0;
        for (Size i=0; i<arguments_.leg.size(); ++i) {
            if (arguments_.leg[i]->hasOccurred(settlementDate,
                                               includeSettlementDateFlows_))
                continue;

            ext::shared_ptr<FixedRateCoupon> coupon =
                ext::dynamic_pointer_cast<FixedRateCoupon>(arguments_.leg[i]);

            // In order to avoid a few switches, we calculate the NPV
            // of both legs as a positive quantity. We'll give them
            // the right sign at the end.

            Date paymentDate = coupon->date(),
                 startDate = coupon->accrualStartDate(),
                 endDate = coupon->accrualEndDate();
            // this is the only point where it might not coincide
            if (i==0)
                startDate = arguments_.protectionStart;
            Date effectiveStartDate =
                (startDate <= today && today <= endDate) ? today : startDate;
            Date defaultDate = // mid-point
                effectiveStartDate + (endDate-effectiveStartDate)/2;

            Probability S = probability_->survivalProbability(paymentDate);
            Probability P = probability_->defaultProbability(
                                                effectiveStartDate,
                                                endDate);

            // on one side, we add the fixed rate payments in case of
            // survival...
            results_.couponLegNPV +=
                S * coupon->amount() *
                discountCurve_->discount(paymentDate);
            // ...possibly including accrual in case of default.
            if (arguments_.settlesAccrual) {
                if (arguments_.paysAtDefaultTime) {
                    results_.couponLegNPV +=
                        P * coupon->accruedAmount(defaultDate) *
                        discountCurve_->discount(defaultDate);
                } else {
                    // pays at the end
                    results_.couponLegNPV +=
                        P * coupon->amount() *
                        discountCurve_->discount(paymentDate);
                }
            }

            // on the other side, we add the payment in case of default.
            Real claim = arguments_.claim->amount(defaultDate,
                                                  arguments_.notional,
                                                  recoveryRate_);
            if (arguments_.paysAtDefaultTime) {
                results_.defaultLegNPV +=
                    P * claim * discountCurve_->discount(defaultDate);
            } else {
                results_.defaultLegNPV +=
                    P * claim * discountCurve_->discount(paymentDate);
            }
        }

        Real upfrontSign = 1.0;
        switch (arguments_.side) {
          case Protection::Seller:
            results_.defaultLegNPV *= -1.0;
            results_.accrualRebateNPV *= -1.0;
            break;
          case Protection::Buyer:
            results_.couponLegNPV *= -1.0;
            results_.upfrontNPV   *= -1.0;
            upfrontSign = -1.0;
            break;
          default:
            QL_FAIL("unknown protection side");
        }

        results_.value =
            results_.defaultLegNPV + results_.couponLegNPV +
            results_.upfrontNPV + results_.accrualRebateNPV;
        results_.errorEstimate = Null<Real>();

        if (results_.couponLegNPV != 0.0) {
            results_.fairSpread =
                -results_.defaultLegNPV*arguments_.spread/
                    (results_.couponLegNPV + results_.accrualRebateNPV);
        } else {
            results_.fairSpread = Null<Rate>();
        }

        if (upfPVO1 > 0.0) {
            results_.fairUpfront =
                -upfrontSign*(results_.defaultLegNPV + results_.couponLegNPV +
                    results_.accrualRebateNPV)
                / (upfPVO1 * arguments_.notional);
        } else {
            results_.fairUpfront = Null<Rate>();
        }

        static const Rate basisPoint = 1.0e-4;

        if (arguments_.spread != 0.0) {
            results_.couponLegBPS =
                results_.couponLegNPV*basisPoint/arguments_.spread;
        } else {
            results_.couponLegBPS = Null<Rate>();
        }

        // NOLINTNEXTLINE(readability-implicit-bool-conversion)
        if (arguments_.upfront && *arguments_.upfront != 0.0) {
            results_.upfrontBPS =
                results_.upfrontNPV*basisPoint/(*arguments_.upfront);
        } else {
            results_.upfrontBPS = Null<Rate>();
        }
    }

}
]]></document_content>
  </document>
  <document index="64">
    <source>exotic/analyticamericanmargrabeengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/exotic/analyticamericanmargrabeengine.hpp>
#include <ql/pricingengines/vanilla/bjerksundstenslandengine.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <utility>

namespace QuantLib {

    AnalyticAmericanMargrabeEngine::AnalyticAmericanMargrabeEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
        Real correlation)
    : process1_(std::move(process1)), process2_(std::move(process2)), rho_(correlation) {
        registerWith(process1_);
        registerWith(process2_);
    }

    void AnalyticAmericanMargrabeEngine::calculate() const {

        QL_REQUIRE(arguments_.exercise->type() == Exercise::American,
                   "not an American option");

        ext::shared_ptr<AmericanExercise> exercise =
            ext::dynamic_pointer_cast<AmericanExercise>(arguments_.exercise);
        QL_REQUIRE(exercise, "not an American option");

        ext::shared_ptr<NullPayoff> payoff0 =
            ext::dynamic_pointer_cast<NullPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff0, "not a null payoff");

        // The option can be priced as an American single-asset option
        // with an adjusted process and payoff.

        Date today = Settings::instance().evaluationDate();

        DayCounter rfdc  = process1_->riskFreeRate()->dayCounter();
        Time t = rfdc.yearFraction(process1_->riskFreeRate()->referenceDate(),
                                   arguments_.exercise->lastDate());

        Real s1 = process1_->stateVariable()->value();
        Real s2 = process2_->stateVariable()->value();

        ext::shared_ptr<SimpleQuote> spot(new SimpleQuote(arguments_.Q1*s1));

        ext::shared_ptr<StrikedTypePayoff> payoff(
                      new PlainVanillaPayoff(Option::Call, arguments_.Q2*s2));

        DiscountFactor dividendDiscount1 =
            process1_->dividendYield()->discount(exercise->lastDate());
        Rate q1 = -std::log(dividendDiscount1)/t;

        DiscountFactor dividendDiscount2 =
            process2_->dividendYield()->discount(exercise->lastDate());
        Rate q2 = -std::log(dividendDiscount2)/t;

        ext::shared_ptr<YieldTermStructure> qTS(
                                            new FlatForward(today, q1, rfdc));

        ext::shared_ptr<YieldTermStructure> rTS(
                                            new FlatForward(today, q2, rfdc));

        Real variance1 = process1_->blackVolatility()->blackVariance(
                                                exercise->lastDate(), s1);
        Real variance2 = process2_->blackVolatility()->blackVariance(
                                                exercise->lastDate(), s2);
        Real variance = variance1 + variance2
                      - 2*rho_*std::sqrt(variance1)*std::sqrt(variance2);
        Volatility volatility = std::sqrt(variance/t);

        ext::shared_ptr<BlackVolTermStructure> volTS(
               new BlackConstantVol(today, NullCalendar(), volatility, rfdc));

        ext::shared_ptr<BlackScholesMertonProcess> stochProcess(new
            BlackScholesMertonProcess(Handle<Quote>(spot),
                                      Handle<YieldTermStructure>(qTS),
                                      Handle<YieldTermStructure>(rTS),
                                      Handle<BlackVolTermStructure>(volTS)));

        ext::shared_ptr<PricingEngine> engine(
                     new BjerksundStenslandApproximationEngine(stochProcess));

        VanillaOption option(payoff, exercise);
        option.setPricingEngine(engine);

        results_.value = option.NPV();
    }

}
]]></document_content>
  </document>
  <document index="65">
    <source>exotic/analyticcomplexchooserengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/exotic/analyticcomplexchooserengine.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>
#include <utility>

using std::pow;
using std::log;
using std::exp;
using std::sqrt;

namespace QuantLib {

    AnalyticComplexChooserEngine::AnalyticComplexChooserEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticComplexChooserEngine::calculate() const {
        Real S = process_->x0();
        Real b;
        Real v;
        Real Xc = arguments_.strikeCall;
        Real Xp = arguments_.strikePut;
        Time T = choosingTime();
        Time Tc = callMaturity() - T;
        Time Tp = putMaturity() - T;

        Real i = criticalValue();

        b = riskFreeRate(T) - dividendYield(T);
        v = volatility(T);
        Real d1 = (log(S / i) + (b + pow(v, 2) / 2)*T) / (v*sqrt(T));
        Real d2 = d1 - v*sqrt(T);

        b = riskFreeRate(T + Tc) - dividendYield(T + Tc);
        v = volatility(Tc);
        Real y1 = (log(S / Xc) + (b + pow(v, 2) / 2)*Tc) / (v*sqrt(Tc));

        b = riskFreeRate(T + Tp) - dividendYield(T + Tp);
        v = volatility(Tp);
        Real y2 = (log(S / Xp) + (b + pow(v, 2) / 2)*Tp) / (v*sqrt(Tp));

        Real rho1 = sqrt(T / Tc);
        Real rho2 = sqrt(T / Tp);
        b = riskFreeRate(T + Tc) - dividendYield(T + Tc);
        Real r = riskFreeRate(T + Tc);
        Real ComplexChooser = S * exp((b - r)*Tc) *  BivariateCumulativeNormalDistributionDr78(rho1)(d1, y1)
            - Xc * exp(-r*Tc)*BivariateCumulativeNormalDistributionDr78(rho1)(d2, y1 - v * sqrt(Tc)) ;
        b = riskFreeRate(T + Tp) - dividendYield(T + Tp);
        r = riskFreeRate(T + Tp);
        ComplexChooser -= S * exp((b - r)*Tp) * BivariateCumulativeNormalDistributionDr78(rho2)(-d1, -y2);
        ComplexChooser += Xp * exp(-r*Tp) * BivariateCumulativeNormalDistributionDr78(rho2)(-d2, -y2 + v * sqrt(Tp));

        results_.value = ComplexChooser;
    }

    BlackScholesCalculator AnalyticComplexChooserEngine::bsCalculator(
                                   Real spot, Option::Type optionType) const {
        Real vol;
        DiscountFactor growth;
        DiscountFactor discount;
        Time T = choosingTime();

        // payoff
        ext::shared_ptr<PlainVanillaPayoff > vanillaPayoff;
        if (optionType == Option::Call){
            //TC-T
            Time t=callMaturity()-2*T;
            vanillaPayoff = ext::make_shared<PlainVanillaPayoff>(
                                          Option::Call, strike(Option::Call));
            //QuantLib requires sigma * sqrt(t) rather than just sigma/volatility
            vol = volatility(t) * std::sqrt(t);
            growth = dividendDiscount(t);
            discount = riskFreeDiscount(t);
        } else{
            Time t=putMaturity()-2*T;
            vanillaPayoff = ext::make_shared<PlainVanillaPayoff>(
                                            Option::Put, strike(Option::Put));
            vol = volatility(t) * std::sqrt(t);
            growth = dividendDiscount(t);
            discount = riskFreeDiscount(t);
        }

        BlackScholesCalculator bs(vanillaPayoff, spot, growth, vol, discount);
        return bs;
    }

    Real AnalyticComplexChooserEngine::criticalValue() const{
        Real Sv = process_->x0();

        BlackScholesCalculator bs=bsCalculator(Sv,Option::Call);
        Real ci = bs.value();
        Real dc = bs.delta();

        bs=bsCalculator(Sv,Option::Put);
        Real Pi = bs.value();
        Real dp = bs.delta();

        Real yi = ci - Pi;
        Real di = dc - dp;
        Real epsilon = 0.001;

        //Newton-Raphson process
        while (std::fabs(yi) > epsilon){
            Sv = Sv - yi / di;

            bs=bsCalculator(Sv,Option::Call);
            ci = bs.value();
            dc = bs.delta();

            bs=bsCalculator(Sv,Option::Put);
            Pi = bs.value();
            dp = bs.delta();

            yi = ci - Pi;
            di = dc - dp;
        }
        return Sv;
    }


    Real AnalyticComplexChooserEngine::strike(Option::Type optionType) const {
        if (optionType == Option::Call)
            return arguments_.strikeCall;
        else
            return arguments_.strikePut;
    }

    Time AnalyticComplexChooserEngine::choosingTime() const {
        return process_->time(arguments_.choosingDate);
    }

    Time AnalyticComplexChooserEngine::putMaturity() const {
        return process_->time(arguments_.exercisePut->lastDate());
    }

    Time AnalyticComplexChooserEngine::callMaturity() const {
        return process_->time(arguments_.exerciseCall->lastDate());
    }

    Volatility AnalyticComplexChooserEngine::volatility(Time t) const {
        return process_->blackVolatility()->blackVol(t, arguments_.strikeCall);
    }

    Rate AnalyticComplexChooserEngine::dividendYield(Time t) const {
        return process_->dividendYield()->zeroRate(t, Continuous, NoFrequency);
    }

    DiscountFactor AnalyticComplexChooserEngine::dividendDiscount(Time t) const {
        return process_->dividendYield()->discount(t);
    }

    Rate AnalyticComplexChooserEngine::riskFreeRate(Time t) const {
        return process_->riskFreeRate()->zeroRate(t, Continuous, NoFrequency);
    }

    DiscountFactor AnalyticComplexChooserEngine::riskFreeDiscount(Time t) const {
        return process_->riskFreeRate()->discount(t);
    }

}
]]></document_content>
  </document>
  <document index="66">
    <source>exotic/analyticcompoundoptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/exotic/analyticcompoundoptionengine.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        // Helper Class needed to solve an implicit problem of finding a
        // spot to a corresponding option price.
        class ImpliedSpotHelper {
          public:
            ImpliedSpotHelper(DiscountFactor dividendDiscount,
                              DiscountFactor riskFreeDiscount,
                              Real standardDeviation,
                              ext::shared_ptr<PlainVanillaPayoff> payoff,
                              Real strike)
            : dividendDiscount_(dividendDiscount), riskFreeDiscount_(riskFreeDiscount),
              standardDeviation_(standardDeviation), strike_(strike), payoff_(std::move(payoff)) {}
            Real operator()(Real spot) const {
                Real forwardPrice = spot*dividendDiscount_/riskFreeDiscount_;
                Real value = blackFormula(payoff_, forwardPrice,
                                          standardDeviation_,riskFreeDiscount_);
                return value - strike_;
            }
          private:
            DiscountFactor dividendDiscount_;
            DiscountFactor riskFreeDiscount_;
            Real standardDeviation_;
            Real strike_;
            ext::shared_ptr<PlainVanillaPayoff> payoff_;
        };

    }

    AnalyticCompoundOptionEngine::AnalyticCompoundOptionEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticCompoundOptionEngine::calculate() const {

        QL_REQUIRE(strikeDaughter()>0.0,
                   "Daughter strike must be positive");

        QL_REQUIRE(strikeMother()>0.0,
                   "Mother strike must be positive");

        QL_REQUIRE(spot() > 0.0, "negative or null underlying given");

        /* Solver Setup ***************************************************/
        Date helpDate(process_->riskFreeRate()->referenceDate());
        Date helpMaturity=helpDate+(maturityDaughter()-maturityMother())*Days;
        Real vol =process_->blackVolatility()->blackVol(helpMaturity,
                                                        strikeDaughter());

        Time helpTimeToMat=process_->time(helpMaturity);
        vol=vol*std::sqrt(helpTimeToMat);

        DiscountFactor dividendDiscount =
            process_->dividendYield()->discount(helpMaturity);

        DiscountFactor riskFreeDiscount =
            process_->riskFreeRate()->discount(helpMaturity);


        ext::shared_ptr<ImpliedSpotHelper> f(
                new ImpliedSpotHelper(dividendDiscount, riskFreeDiscount,
                                      vol, payoffDaughter(), strikeMother()));

        Brent solver;
        solver.setMaxEvaluations(1000);
        Real accuracy = 1.0e-6;

        Real sSolved=solver.solve(*f, accuracy, strikeDaughter(), 1.0e-6, strikeDaughter()*1000.0);
        Real X=transformX(sSolved); // transform stock to return as in Wystup's book
        /* Solver Setup Finished*****************************************/

        Real phi=typeDaughter(); // -1 or 1
        Real w=typeMother(); // -1 or 1

        Real rho=std::sqrt(residualTimeMother()/residualTimeDaughter());
        BivariateCumulativeNormalDistributionDr78 N2(w*rho) ;

        DiscountFactor ddD=dividendDiscountDaughter();
        DiscountFactor rdD=riskFreeDiscountDaughter();
        //DiscountFactor ddM=dividendDiscountMother();
        DiscountFactor rdM=riskFreeDiscountMother();

        Real XmSM=X-stdDeviationMother();
        Real S=spot();
        Real dP=dPlus();
        Real dPT12=dPlusTau12(sSolved);
        Real vD=volatilityDaughter();

        Real dM=dMinus();
        Real strD=strikeDaughter();
        Real strM=strikeMother();
        Real rTM=residualTimeMother();
        Real rTD=residualTimeDaughter();

        Real rD=riskFreeRateDaughter();
        Real dD=dividendRateDaughter();

        Real N2XmSM=N2(-phi*w*XmSM,phi*dP);
        Real N2X=N2(-phi*w*X,phi*dM);
        Real NeX=N_(-phi*w*e(X));
        Real NX=N_(-phi*w*X);
        Real NT12=N_(phi*dPT12);
        Real ndP=n_(dP);
        Real nXm=n_(XmSM);
        Real invMTime=1/std::sqrt(rTM);
        Real invDTime=1/std::sqrt(rTD);

        Real tempRes=phi*w*S*ddD*N2XmSM-phi*w*strD*rdD*N2X-w*strM*rdM*NX;
        Real tempDelta=phi*w*ddD*N2XmSM;
        Real tempGamma=(ddD/(vD*S))*(invMTime*nXm*NT12+w*invDTime*ndP*NeX);
        Real tempVega=ddD*S*((1/invMTime)*nXm*NT12+w*(1/invDTime)*ndP*NeX);
        Real tempTheta=phi*w*dD*S*ddD*N2XmSM-phi*w*rD*strD*rdD*N2X-w*rD*strM*rdM*NX;
        tempTheta-=0.5*vD*S*ddD*(invMTime*nXm*NT12+w*invDTime*ndP*NeX);

        results_.value=tempRes;
        results_.delta=tempDelta;
        results_.gamma=tempGamma;
        results_.vega=tempVega;
        results_.theta=tempTheta;
    }

    Real AnalyticCompoundOptionEngine::typeDaughter() const {
        // returns -1 or 1 according to put or call
        return (Real) payoffDaughter()->optionType();
    }

    Real AnalyticCompoundOptionEngine::typeMother() const {
        return (Real) payoffMother()->optionType();
    }

    Date AnalyticCompoundOptionEngine::maturityDaughter() const {
        return arguments_.daughterExercise->lastDate();
    }

    Date AnalyticCompoundOptionEngine::maturityMother() const {
        return arguments_.exercise->lastDate();
    }

    Time AnalyticCompoundOptionEngine::residualTimeDaughter() const {
        return process_->time(maturityDaughter());
    }

    Time AnalyticCompoundOptionEngine::residualTimeMother() const {
        return process_->time(maturityMother());
    }

    Time AnalyticCompoundOptionEngine::residualTimeMotherDaughter() const {
        return residualTimeDaughter()-residualTimeMother();
    }


    Real AnalyticCompoundOptionEngine::volatilityDaughter() const {
        return process_->blackVolatility()->blackVol(maturityDaughter(),
                                                     strikeDaughter());
    }


    Real AnalyticCompoundOptionEngine::volatilityMother() const {
        return process_->blackVolatility()->blackVol(maturityMother(),
                                                     strikeMother());
    }

    Real AnalyticCompoundOptionEngine::stdDeviationDaughter() const {
        return volatilityDaughter()*std::sqrt(residualTimeDaughter());
    }

    Real AnalyticCompoundOptionEngine::stdDeviationMother() const {
        return volatilityMother()*std::sqrt(residualTimeMother());
    }


    ext::shared_ptr<PlainVanillaPayoff>
    AnalyticCompoundOptionEngine::payoffDaughter() const {
        ext::shared_ptr<PlainVanillaPayoff> dPayoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                                                   arguments_.daughterPayoff);
        QL_REQUIRE(dPayoff, "non-plain payoff given");
        return dPayoff;
    }

    ext::shared_ptr<PlainVanillaPayoff>
    AnalyticCompoundOptionEngine::payoffMother() const {
        ext::shared_ptr<PlainVanillaPayoff> mPayoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(mPayoff, "non-plain payoff given");
        return mPayoff;
    }

    Real AnalyticCompoundOptionEngine::strikeMother() const {
        return payoffMother()->strike();
    }

    Real AnalyticCompoundOptionEngine::strikeDaughter() const {
        return payoffDaughter()->strike();
    }

    DiscountFactor AnalyticCompoundOptionEngine::riskFreeDiscountDaughter() const {
        return process_->riskFreeRate()->discount(residualTimeDaughter());
    }

    DiscountFactor AnalyticCompoundOptionEngine::riskFreeDiscountMother() const {
        return process_->riskFreeRate()->discount(residualTimeMother());
    }

    DiscountFactor AnalyticCompoundOptionEngine::riskFreeDiscountMotherDaughter() const {
        return process_->riskFreeRate()->discount(residualTimeMotherDaughter());
    }

    DiscountFactor AnalyticCompoundOptionEngine::dividendDiscountDaughter() const {
        return process_->dividendYield()->discount(residualTimeDaughter());
    }

    DiscountFactor AnalyticCompoundOptionEngine::dividendDiscountMother() const {
        return process_->dividendYield()->discount(residualTimeMother());
    }

    DiscountFactor AnalyticCompoundOptionEngine::dividendDiscountMotherDaughter() const {
        return process_->dividendYield()->discount(residualTimeMotherDaughter());
    }

    Real AnalyticCompoundOptionEngine::dPlus() const {
        Real forward = spot() * dividendDiscountDaughter() / riskFreeDiscountDaughter();
        Real sd=stdDeviationDaughter();
        return std::log(forward/strikeDaughter())/sd+0.5*sd;
    }

    Real AnalyticCompoundOptionEngine::dMinus() const {
        return dPlus()-stdDeviationDaughter();
    }

    Real AnalyticCompoundOptionEngine::dPlusTau12(Real S) const {
        Real forward = S * dividendDiscountMotherDaughter() / riskFreeDiscountMotherDaughter();
        Real sd=volatilityDaughter()*std::sqrt(residualTimeMotherDaughter());
        return std::log(forward/strikeDaughter())/sd+0.5*sd;
    }

    Real AnalyticCompoundOptionEngine::spot() const {
        return process_->x0();
    }

    Real AnalyticCompoundOptionEngine::riskFreeRateDaughter() const {
        return process_->riskFreeRate()->zeroRate(residualTimeDaughter(),
                                                  Continuous,
                                                  NoFrequency);
    }

    Real AnalyticCompoundOptionEngine::dividendRateDaughter() const {
        return process_->dividendYield()->zeroRate(residualTimeDaughter(),
                                                   Continuous,
                                                   NoFrequency);
    }

    Real AnalyticCompoundOptionEngine::transformX(Real X) const {

        Real sd=stdDeviationMother();
        Real resX=riskFreeDiscountMother()*X/(spot()*dividendDiscountMother());
        resX=resX*std::exp(0.5*sd*sd);
        resX=std::log(resX);

        return resX/sd;
    }

    Real AnalyticCompoundOptionEngine::e(Real X) const {
        Real rtM=residualTimeMother();
        Real rtD=residualTimeDaughter();

        return (X*std::sqrt(rtD)+std::sqrt(rtM)*dMinus())/std::sqrt(rtD-rtM);
    }

}
]]></document_content>
  </document>
  <document index="67">
    <source>exotic/analyticeuropeanmargrabeengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/exotic/analyticeuropeanmargrabeengine.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <utility>

namespace QuantLib {

    AnalyticEuropeanMargrabeEngine::AnalyticEuropeanMargrabeEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
        Real correlation)
    : process1_(std::move(process1)), process2_(std::move(process2)), rho_(correlation) {
        registerWith(process1_);
        registerWith(process2_);
    }

    void AnalyticEuropeanMargrabeEngine::calculate() const {

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European Option");

        ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(arguments_.exercise);
        QL_REQUIRE(exercise, "not an European Option");

        ext::shared_ptr<NullPayoff> payoff =
            ext::dynamic_pointer_cast<NullPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non a Null Payoff type");

        Integer quantity1 = arguments_.Q1;
        Integer quantity2 = arguments_.Q2;

        Real s1  = process1_->stateVariable()->value();
        Real s2  = process2_->stateVariable()->value();

        Real variance1 = process1_->blackVolatility()->blackVariance(
                                                exercise->lastDate(), s1);
        Real variance2 = process2_->blackVolatility()->blackVariance(
                                                exercise->lastDate(), s2);

        DiscountFactor riskFreeDiscount =
            process1_->riskFreeRate()->discount(exercise->lastDate());

        DiscountFactor dividendDiscount1 =
            process1_->dividendYield()->discount(exercise->lastDate());
        DiscountFactor dividendDiscount2 =
            process2_->dividendYield()->discount(exercise->lastDate());

        Real forward1 = process1_->stateVariable()->value() *
            dividendDiscount1 / riskFreeDiscount;
        Real forward2 = process2_->stateVariable()->value() *
            dividendDiscount2 / riskFreeDiscount;

        Real stdDev1 = std::sqrt(variance1);
        Real stdDev2 = std::sqrt(variance2);
        Real variance = variance1 + variance2 - 2*rho_*stdDev1*stdDev2;
        Real stdDev = std::sqrt(variance);
        Real d1 = (std::log((quantity1*forward1)/(quantity2*forward2))
                   + 0.5*variance) / stdDev;
        Real d2 = d1 - stdDev;
        Real Nd1, Nd2, nd1, nd2;
        CumulativeNormalDistribution cum;
        NormalDistribution norm;
        Nd1 = cum(d1);
        Nd2 = cum(d2);
        nd1 = norm(d1);
        nd2 = norm(d2);
        DayCounter rfdc  = process1_->riskFreeRate()->dayCounter();
        Time t = rfdc.yearFraction(process1_->riskFreeRate()->referenceDate(),
                                  arguments_.exercise->lastDate());
        Real sqt = std::sqrt(t);
        Real q1  = -std::log(dividendDiscount1)/(sqt*sqt);
        Real q2  = -std::log(dividendDiscount2)/(sqt*sqt);

        results_.value =
            riskFreeDiscount * (quantity1*forward1*Nd1 - quantity2*forward2*Nd2);

        // Greeks
        results_.delta1 = riskFreeDiscount*(quantity1*forward1*Nd1)/s1;
        results_.delta2 = -riskFreeDiscount*(quantity2*forward2*Nd2)/s2;
        results_.gamma1 = (riskFreeDiscount*(quantity1*forward1*nd1)/s1)/(quantity1*s1*stdDev);
        results_.gamma2 = (-riskFreeDiscount*(quantity2*forward2*nd2)/s2)/(-quantity2*s2*stdDev);
        Real vega       = riskFreeDiscount*(quantity1*forward1*nd1)*sqt;
        results_.theta  = -((stdDev*vega/sqt)/(2*t)-(q1*quantity1*s1*results_.delta1)-(q2*quantity2*s2*results_.delta2));
        results_.rho    = 0.0;
    }

}
]]></document_content>
  </document>
  <document index="68">
    <source>exotic/analyticholderextensibleoptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/exotic/analyticholderextensibleoptionengine.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>
#include <utility>

using std::pow;
using std::log;
using std::exp;
using std::sqrt;

namespace QuantLib {

    AnalyticHolderExtensibleOptionEngine::AnalyticHolderExtensibleOptionEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticHolderExtensibleOptionEngine::calculate() const {
        //Spot
        Real S = process_->x0();
        Real r = riskFreeRate();
        Real b = r - dividendYield();
        Real X1 = strike();
        Real X2 = arguments_.secondStrike;
        Time T2 = secondExpiryTime();
        Time t1 = firstExpiryTime();
        Real A = arguments_.premium;


        Real z1 = this->z1();

        Real z2 = this->z2();

        Real rho = sqrt(t1 / T2);


        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);

        //QuantLib requires sigma * sqrt(T) rather than just sigma/volatility
        Real vol = volatility();

        //calculate dividend discount factor assuming continuous compounding (e^-rt)
        DiscountFactor growth = dividendDiscount(t1);
        //calculate payoff discount factor assuming continuous compounding
        DiscountFactor discount = riskFreeDiscount(t1);
        Real result = 0;
        constexpr double minusInf = -std::numeric_limits<double>::infinity();

        Real y1 = this->y1(payoff->optionType()),
             y2 = this->y2(payoff->optionType());
        if (payoff->optionType() == Option::Call) {
            //instantiate payoff function for a call
            ext::shared_ptr<PlainVanillaPayoff> vanillaCallPayoff =
                ext::make_shared<PlainVanillaPayoff>(Option::Call, X1);
            Real BSM = BlackScholesCalculator(vanillaCallPayoff, S, growth, vol*sqrt(t1), discount).value();
            result = BSM
                + S*exp((b - r)*T2)*M2(y1, y2, minusInf, z1, rho)
                - X2*exp(-r*T2)*M2(y1 - vol*sqrt(t1), y2 - vol*sqrt(t1), minusInf, z1 - vol*sqrt(T2), rho)
                - S*exp((b - r)*t1)*N2(y1, z2) + X1*exp(-r*t1)*N2(y1 - vol*sqrt(t1), z2 - vol*sqrt(t1))
                - A*exp(-r*t1)*N2(y1 - vol*sqrt(t1), y2 - vol*sqrt(t1));
        } else {
            //instantiate payoff function for a call
            ext::shared_ptr<PlainVanillaPayoff> vanillaPutPayoff =
                ext::make_shared<PlainVanillaPayoff>(Option::Put, X1);
            result = BlackScholesCalculator(vanillaPutPayoff, S, growth, vol*sqrt(t1), discount).value()
                - S*exp((b - r)*T2)*M2(y1, y2, minusInf, -z1, rho)
                + X2*exp(-r*T2)*M2(y1 - vol*sqrt(t1), y2 - vol*sqrt(t1), minusInf, -z1 + vol*sqrt(T2), rho)
                + S*exp((b - r)*t1)*N2(z2, y2) - X1*exp(-r*t1)*N2(z2 - vol*sqrt(t1), y2 - vol*sqrt(t1))
                - A*exp(-r*t1)*N2(y1 - vol*sqrt(t1), y2 - vol*sqrt(t1));
        }
        this->results_.value = result;
    }

    Real AnalyticHolderExtensibleOptionEngine::I1Call() const {
        Real Sv = process_->x0();
        Real A = arguments_.premium;

        if(A==0)
        {
            return 0;
        }
        else
        {
            BlackScholesCalculator bs = bsCalculator(Sv, Option::Call);
            Real ci = bs.value();
            Real dc = bs.delta();

            Real yi = ci - A;
            //da/ds = 0
            Real di = dc - 0;
            Real epsilon = 0.001;

            //Newton-Raphson process
            while (std::fabs(yi) > epsilon){
                Sv = Sv - yi / di;

                bs = bsCalculator(Sv, Option::Call);
                ci = bs.value();
                dc = bs.delta();

                yi = ci - A;
                di = dc - 0;
            }
            return Sv;
        }
    }

    Real AnalyticHolderExtensibleOptionEngine::I2Call() const {
        Real Sv = process_->x0();
        Real X1 = strike();
        Real X2 = arguments_.secondStrike;
        Real A = arguments_.premium;
        Time T2 = secondExpiryTime();
        Time t1 = firstExpiryTime();
        Real r=riskFreeRate();

        Real val=X1-X2*std::exp(-r*(T2-t1));
        if(A< val){
            return std::numeric_limits<Real>::infinity();
        } else {
            BlackScholesCalculator bs = bsCalculator(Sv, Option::Call);
            Real ci = bs.value();
            Real dc = bs.delta();

            Real yi = ci - A - Sv + X1;
            //da/ds = 1
            Real di = dc - 1;
            Real epsilon = 0.001;

            //Newton-Raphson process
            while (std::fabs(yi) > epsilon){
                Sv = Sv - yi / di;

                bs = bsCalculator(Sv, Option::Call);
                ci = bs.value();
                dc = bs.delta();

                yi = ci - A - Sv + X1;
                di = dc - 1;
            }
            return Sv;
        }
    }

    Real AnalyticHolderExtensibleOptionEngine::I1Put() const {
        Real Sv = process_->x0();
        //Srtike
        Real X1 = strike();
        //Premium
        Real A = arguments_.premium;

        BlackScholesCalculator bs = bsCalculator(Sv, Option::Put);
        Real pi = bs.value();
        Real dc = bs.delta();

        Real yi = pi - A + Sv - X1;
        //da/ds = 1
        Real di = dc - 1;
        Real epsilon = 0.001;

        //Newton-Raphson prosess
        while (std::fabs(yi) > epsilon){
            Sv = Sv - yi / di;

            bs = bsCalculator(Sv, Option::Put);
            pi = bs.value();
            dc = bs.delta();

            yi = pi - A + Sv - X1;
            di = dc - 1;
        }
        return Sv;
    }

    Real AnalyticHolderExtensibleOptionEngine::I2Put() const {
        Real Sv = process_->x0();
        Real A = arguments_.premium;
        if(A==0){
            return std::numeric_limits<Real>::infinity();
        }
        else{
            BlackScholesCalculator bs = bsCalculator(Sv, Option::Put);
            Real pi = bs.value();
            Real dc = bs.delta();

            Real yi = pi - A;
            //da/ds = 0
            Real di = dc - 0;
            Real epsilon = 0.001;

            //Newton-Raphson prosess
            while (std::fabs(yi) > epsilon){
                Sv = Sv - yi / di;

                bs = bsCalculator(Sv, Option::Put);
                pi = bs.value();
                dc = bs.delta();

                yi = pi - A;
                di = dc - 0;
            }
            return Sv;
        }
    }


    BlackScholesCalculator AnalyticHolderExtensibleOptionEngine::bsCalculator(
                                    Real spot, Option::Type optionType) const {
        //Real spot = process_->x0();
        Real vol;
        DiscountFactor growth;
        DiscountFactor discount;
        Real X2 = arguments_.secondStrike;
        Time T2 = secondExpiryTime();
        Time t1 = firstExpiryTime();
        Time t = T2 - t1;

        //payoff
        ext::shared_ptr<PlainVanillaPayoff > vanillaPayoff =
            ext::make_shared<PlainVanillaPayoff>(optionType, X2);

        //QuantLib requires sigma * sqrt(T) rather than just sigma/volatility
        vol = volatility() * std::sqrt(t);
        //calculate dividend discount factor assuming continuous compounding (e^-rt)
        growth = dividendDiscount(t);
        //calculate payoff discount factor assuming continuous compounding
        discount = riskFreeDiscount(t);

        BlackScholesCalculator bs(vanillaPayoff, spot, growth, vol, discount);
        return bs;
    }

    Real AnalyticHolderExtensibleOptionEngine::M2(Real a, Real b, Real c, Real d, Real rho) const {
        BivariateCumulativeNormalDistributionDr78 CmlNormDist(rho);
        return CmlNormDist(b, d) - CmlNormDist(a, d) - CmlNormDist(b, c) + CmlNormDist(a,c);
    }

    Real AnalyticHolderExtensibleOptionEngine::N2(Real a, Real b) const {
        CumulativeNormalDistribution  NormDist;
        return NormDist(b) - NormDist(a);
    }

    Real AnalyticHolderExtensibleOptionEngine::strike() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        return payoff->strike();
    }

    Time AnalyticHolderExtensibleOptionEngine::firstExpiryTime() const {
        return process_->time(arguments_.exercise->lastDate());
    }

    Time AnalyticHolderExtensibleOptionEngine::secondExpiryTime() const {
        return process_->time(arguments_.secondExpiryDate);
    }

    Volatility AnalyticHolderExtensibleOptionEngine::volatility() const {
        return process_->blackVolatility()->blackVol(firstExpiryTime(), strike());
    }
    Rate AnalyticHolderExtensibleOptionEngine::riskFreeRate() const {
        return process_->riskFreeRate()->zeroRate(firstExpiryTime(), Continuous,
            NoFrequency);
    }
    Rate AnalyticHolderExtensibleOptionEngine::dividendYield() const {
        return process_->dividendYield()->zeroRate(firstExpiryTime(),
            Continuous, NoFrequency);
    }

    DiscountFactor AnalyticHolderExtensibleOptionEngine::dividendDiscount(Time t) const {
        return process_->dividendYield()->discount(t);
    }

    DiscountFactor AnalyticHolderExtensibleOptionEngine::riskFreeDiscount(Time t) const {
        return process_->riskFreeRate()->discount(t);
    }

    Real AnalyticHolderExtensibleOptionEngine::y1(Option::Type type) const {
        Real S = process_->x0();
        Real I2 = (type == Option::Call) ? I2Call() : I2Put();

        Real b = riskFreeRate() - dividendYield();
        Real vol = volatility();
        Time t1 = firstExpiryTime();

        return (log(S / I2) + (b + pow(vol, 2) / 2)*t1) / (vol*sqrt(t1));
    }

    Real AnalyticHolderExtensibleOptionEngine::y2(Option::Type type) const {
        Real S = process_->x0();
        Real I1 = (type == Option::Call) ? I1Call() : I1Put();

        Real b = riskFreeRate() - dividendYield();
        Real vol = volatility();
        Time t1 = firstExpiryTime();

        return (log(S / I1) + (b + pow(vol, 2) / 2)*t1) / (vol*sqrt(t1));
    }

    Real AnalyticHolderExtensibleOptionEngine::z1() const {
        Real S = process_->x0();
        Real X2 = arguments_.secondStrike;
        Real b = riskFreeRate() - dividendYield();
        Real vol = volatility();
        Time T2 = secondExpiryTime();

        return (log(S / X2) + (b + pow(vol, 2) / 2)*T2) / (vol*sqrt(T2));
    }

    Real AnalyticHolderExtensibleOptionEngine::z2() const {
        Real S = process_->x0();
        Real X1 = strike();

        Real b = riskFreeRate() - dividendYield();
        Real vol = volatility();
        Time t1 = firstExpiryTime();

        return (log(S / X1) + (b + pow(vol, 2) / 2)*t1) / (vol*sqrt(t1));
    }

}
]]></document_content>
  </document>
  <document index="69">
    <source>exotic/analyticsimplechooserengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/exotic/analyticsimplechooserengine.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <utility>

namespace QuantLib {

    AnalyticSimpleChooserEngine::AnalyticSimpleChooserEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticSimpleChooserEngine::calculate() const {
        Date today = Settings::instance().evaluationDate();
        DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
        DayCounter divdc = process_->dividendYield()->dayCounter();
        DayCounter voldc = process_->blackVolatility()->dayCounter();
        QL_REQUIRE(rfdc==divdc,
                   "Risk-free rate and dividend yield must"
                   "have the same day counter");
        QL_REQUIRE(rfdc==voldc,
                   "Risk-free rate and volatility must"
                   "have the same day counter");
        Real spot = process_->stateVariable()->value();
        auto payoff = ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        Real strike = payoff->strike();
        Volatility volatility = process_->blackVolatility()->blackVol(
                                                arguments_.exercise->lastDate(),
                                                strike);
        Date maturity = arguments_.exercise->lastDate();
        Real timeToMaturity = rfdc.yearFraction(today,maturity);
        Real timeToChoosing = rfdc.yearFraction(today,arguments_.choosingDate);
        Rate dividendRate =
            process_->dividendYield()->zeroRate(maturity, divdc,
                                                Continuous, NoFrequency);
        Rate riskFreeRate =
            process_->riskFreeRate()->zeroRate(maturity, rfdc,
                                               Continuous, NoFrequency);

        QL_REQUIRE(spot > 0.0, "negative or null spot value");
        QL_REQUIRE(strike > 0.0, "negative or null strike value");
        QL_REQUIRE(volatility > 0.0,
                   "negative or null volatility");
        QL_REQUIRE(timeToChoosing > 0.0,
                   "choosing date earlier than or equal to evaluation date");

        Real d = (std::log(spot/strike)
            + ((riskFreeRate-dividendRate) + volatility*volatility*0.5)*timeToMaturity)
            /(volatility*std::sqrt(timeToMaturity));

        Real y = (std::log(spot/strike) + (riskFreeRate-dividendRate)*timeToMaturity
            + (volatility*volatility*timeToChoosing/2))
            /(volatility*std::sqrt(timeToChoosing));

        CumulativeNormalDistribution f;

        results_.value = spot*std::exp(-dividendRate*timeToMaturity)*f(d)
            - strike*std::exp(-riskFreeRate*timeToMaturity)
            *f(d-volatility*std::sqrt(timeToMaturity))
            -spot*std::exp(-dividendRate*timeToMaturity)*f(-y)
            +strike*std::exp(-riskFreeRate*timeToMaturity)
            *f(-y+volatility*std::sqrt(timeToChoosing));
     }

}
]]></document_content>
  </document>
  <document index="70">
    <source>exotic/analytictwoassetcorrelationengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/exotic/analytictwoassetcorrelationengine.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>
#include <utility>

using std::log;

namespace QuantLib {

    AnalyticTwoAssetCorrelationEngine::AnalyticTwoAssetCorrelationEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> p1,
        ext::shared_ptr<GeneralizedBlackScholesProcess> p2,
        Handle<Quote> correlation)
    : p1_(std::move(p1)), p2_(std::move(p2)), correlation_(std::move(correlation)) {
        registerWith(p1_);
        registerWith(p2_);
        registerWith(correlation_);
    }

    void AnalyticTwoAssetCorrelationEngine::calculate() const {
        BivariateCumulativeNormalDistributionDr78 M(correlation_->value());

        const ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");
        QL_REQUIRE(payoff->strike()>0.0, "strike must be positive");
        ext::shared_ptr<Exercise> exercise = arguments_.exercise;
        Real strike = payoff->strike();//X1
        Real spot = p1_->x0();
        QL_REQUIRE(spot > 0.0, "negative or null underlying given");

        Volatility sigma1 =
            p1_->blackVolatility()->blackVol(p1_->time(exercise->lastDate()),
                                             payoff->strike());
        Volatility sigma2 =
            p2_->blackVolatility()->blackVol(p2_->time(exercise->lastDate()),
                                             payoff->strike());

        Time T = p2_->time(arguments_.exercise->lastDate());

        Real s1=p1_->x0();
        Real s2=p2_->x0();
        Rate q1= p1_->dividendYield()->zeroRate(T, Continuous, NoFrequency);
        Rate q2= p2_->dividendYield()->zeroRate(T, Continuous, NoFrequency);
        Rate r=p1_->riskFreeRate()->zeroRate(T, Continuous, NoFrequency);
        Rate b1=r-q1;
        Rate b2=r-q2;
        Real rho = correlation_->value();

        Real y1=(log(s1/strike)+(b1-(sigma1*sigma1)/2)*T)/(sigma1*std::sqrt(T));
        Real y2=(log(s2/arguments_.X2)+(b2-(sigma2*sigma2)/2)*T)/(sigma2*std::sqrt(T));

        switch (payoff->optionType()) {
          case Option::Call:
            results_.value=s2*std::exp((b2-r)*T)*M(y2+sigma2*std::sqrt(T),y1+rho*sigma2*std::sqrt(T))-arguments_.X2*std::exp(-r*T)*M(y2,y1);
            break;
          case Option::Put:
            results_.value=arguments_.X2*std::exp(-r*T)*M(-y2,-y1)-s2*std::exp((b2-r)*T)*M(-y2-sigma2*std::sqrt(T),-y1-rho*sigma2*std::sqrt(T));
            break;
          default:
            QL_FAIL("unknown option type");
        }
    }

}
]]></document_content>
  </document>
  <document index="71">
    <source>exotic/analyticwriterextensibleoptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/exotic/analyticwriterextensibleoptionengine.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <utility>

using namespace std;

namespace QuantLib {

    AnalyticWriterExtensibleOptionEngine::AnalyticWriterExtensibleOptionEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticWriterExtensibleOptionEngine::calculate() const {
        // We take all the arguments:

        ext::shared_ptr<PlainVanillaPayoff> payoff1 =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff1, "not a plain vanilla payoff");

        ext::shared_ptr<PlainVanillaPayoff> payoff2 =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff2);
        QL_REQUIRE(payoff2, "not a plain vanilla payoff");

        ext::shared_ptr<Exercise> exercise1 = arguments_.exercise;

        ext::shared_ptr<Exercise> exercise2 = arguments_.exercise2;


        // We create and apply the calculate process:

        Option::Type type = payoff1->optionType();

        // STEP 1:

        // S = spot
        Real spot = process_->stateVariable()->value();

        // For the B&S formulae:
        DayCounter dividendDC = process_->dividendYield()->dayCounter();
        Rate dividend = process_->dividendYield()->zeroRate(
                  exercise1->lastDate(), dividendDC, Continuous, NoFrequency);

        DayCounter riskFreeDC = process_->riskFreeRate()->dayCounter();
        Rate riskFree = process_->riskFreeRate()->zeroRate(
                  exercise1->lastDate(), riskFreeDC, Continuous, NoFrequency);

        // The time to maturity:
        Time t1 = riskFreeDC.yearFraction(
                                    process_->riskFreeRate()->referenceDate(),
                                    arguments_.exercise->lastDate());
        Time t2 = riskFreeDC.yearFraction(
                                    process_->riskFreeRate()->referenceDate(),
                                    arguments_.exercise2->lastDate());

        // b = r-q:
        Real b = riskFree - dividend;

        Real forwardPrice = spot * std::exp(b*t1);

        Volatility volatility = process_->blackVolatility()->blackVol(
                                    exercise1->lastDate(), payoff1->strike());

        Real stdDev = volatility*std::sqrt(t1);

        Real discount = std::exp(-riskFree*t1);

        // Call the B&S method:
        Real black = blackFormula(type, payoff1->strike(),
                                  forwardPrice, stdDev, discount);

        // STEP 2:

        // Standard bivariate normal distribution:
        Real ro = std::sqrt(t1/t2);
        Real z1 = (std::log(spot/payoff2->strike()) +
                   (b+std::pow(volatility, 2)/2)*t2)/(volatility*std::sqrt(t2));
        Real z2 = (std::log(spot/payoff1->strike()) +
                   (b+std::pow(volatility, 2)/2)*t1)/(volatility*std::sqrt(t1));

        // Call the bivariate method:
        BivariateCumulativeNormalDistributionWe04DP biv(-ro);


        // STEP 3:

        Real bivariate1, bivariate2, result;

        // Final computing:
        if (type == Option::Call) {
            // Call case:
            bivariate1 = biv(z1, -z2);
            bivariate2 = biv(z1-volatility*std::sqrt(t2),
                             -z2+volatility*std::sqrt(t1));
            result = black + spot*std::exp((b-riskFree)*t2)*bivariate1
                - payoff2->strike()*std::exp((-riskFree)*t2)*bivariate2;
        } else {
            // Put case:
            bivariate1 = biv(-z1, z2);
            bivariate2 = biv(-z1+volatility*std::sqrt(t2),
                             z2-volatility*std::sqrt(t1));
            result = black - spot*std::exp((b-riskFree)*t2)*bivariate1
                + payoff2->strike()*std::exp((-riskFree)*t2)*bivariate2;
        }

        // Save the result:
        results_.value = result;
    }

}
]]></document_content>
  </document>
  <document index="72">
    <source>forward/mcforwardeuropeanbsengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/
 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.
 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/forward/mcforwardeuropeanbsengine.hpp>

namespace QuantLib {

    ForwardEuropeanBSPathPricer::ForwardEuropeanBSPathPricer(
                                          Option::Type type,
                                          Real moneyness,
                                          Size resetIndex,
                                          DiscountFactor discount)
    : type_(type), moneyness_(moneyness), resetIndex_(resetIndex),
      discount_(discount)
       {
        QL_REQUIRE(moneyness>=0.0,
                   "moneyness less than zero not allowed");
    }

    Real ForwardEuropeanBSPathPricer::operator()(const Path& path) const {
        Size n = path.length() - 1;
        QL_REQUIRE(n>0, "the path cannot be empty");

        const Real resetLevel = path[resetIndex_];
        const Real strike = resetLevel * moneyness_;
        const PlainVanillaPayoff payoff = PlainVanillaPayoff(type_, strike);

        return payoff(path.back()) * discount_;
    }

}]]></document_content>
  </document>
  <document index="73">
    <source>forward/mcforwardeuropeanhestonengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/
 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.
 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/forward/mcforwardeuropeanhestonengine.hpp>

namespace QuantLib {

    ForwardEuropeanHestonPathPricer::ForwardEuropeanHestonPathPricer(
                                          Option::Type type,
                                          Real moneyness,
                                          Size resetIndex,
                                          DiscountFactor discount)
    : type_(type), moneyness_(moneyness), resetIndex_(resetIndex),
      discount_(discount)
       {
        QL_REQUIRE(moneyness>=0.0,
                   "moneyness less than zero not allowed");
    }

    Real ForwardEuropeanHestonPathPricer::operator()(const MultiPath& multiPath) const {
        const Path& path = multiPath[0];
        const Size n = multiPath.pathSize();
        QL_REQUIRE(n>0, "the path cannot be empty");

        const Real resetLevel = path[resetIndex_];
        const Real strike = resetLevel * moneyness_;
        const PlainVanillaPayoff payoff = PlainVanillaPayoff(type_, strike);

        return payoff(path.back()) * discount_;
    }

}]]></document_content>
  </document>
  <document index="74">
    <source>futures/discountingperpetualfuturesengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2025 Hiroto Ogawa

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/integrals/trapezoidintegral.hpp>
#include <ql/math/interpolations/backwardflatinterpolation.hpp>
#include <ql/math/interpolations/cubicinterpolation.hpp>
#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/pricingengines/futures/discountingperpetualfuturesengine.hpp>
#include <ql/time/daycounters/yearfractiontodate.hpp>
#include <ql/settings.hpp>

namespace QuantLib {

    DiscountingPerpetualFuturesEngine::DiscountingPerpetualFuturesEngine(
        const Handle<YieldTermStructure>& domesticDiscountCurve,
        const Handle<YieldTermStructure>& foreignDiscountCurve,
        const Handle<Quote>& assetSpot,
        const std::vector<Time>& fundingTimes,
        const std::vector<Rate>& fundingRates,
        const std::vector<Spread>& interestRateDiffs,
        const DiscountingPerpetualFuturesEngine::InterpolationType fundingInterpType,
        const Real maxT)
    : domesticDiscountCurve_(domesticDiscountCurve),
      foreignDiscountCurve_(foreignDiscountCurve), assetSpot_(assetSpot),
      fundingTimes_(fundingTimes), fundingRates_(fundingRates),
      interestRateDiffs_(interestRateDiffs), fundingInterpType_(fundingInterpType), maxT_(maxT) {
        registerWith(domesticDiscountCurve_);
        registerWith(foreignDiscountCurve_);
        registerWith(assetSpot_);
        QL_REQUIRE(!fundingTimes_.empty(), "fundingTimes is empty");
        QL_REQUIRE(!fundingRates_.empty(), "fundingRates is empty");
        QL_REQUIRE(!interestRateDiffs_.empty(), "interestRateDiffs is empty");
        QL_REQUIRE(fundingTimes_.size() == fundingRates_.size(),
                   "fundingTimes and fundingRates must have the same size.");
        QL_REQUIRE(fundingTimes_.size() == interestRateDiffs_.size(),
                   "fundingTimes and interestRateDiffs must have the same size.");
    }

    void DiscountingPerpetualFuturesEngine::calculate() const {
        QL_REQUIRE(!domesticDiscountCurve_.empty(),
                   "domestic discounting term structure handle is empty");
        QL_REQUIRE(!foreignDiscountCurve_.empty(),
                   "foreign discounting term structure handle is empty");
        QL_REQUIRE(!assetSpot_.empty(), "asset spot handle is empty");

        results_.value = 0.0;
        results_.errorEstimate = Null<Real>();

        QL_REQUIRE(
            arguments_.payoffType == PerpetualFutures::Linear ||
                arguments_.payoffType == PerpetualFutures::Inverse,
            "Only Linear and Inverse payoffs are supported in DiscountingPerpetualFuturesEngine");

        // Linear payoff <--> Inverse payoff:
        // 1. exchange domestic and foreign curves
        // 2. future price: f <--> 1/f
        auto effDomCurve = arguments_.payoffType == PerpetualFutures::Linear ?
                               domesticDiscountCurve_ : foreignDiscountCurve_;
        auto effForCurve = arguments_.payoffType == PerpetualFutures::Linear ?
                               foreignDiscountCurve_ : domesticDiscountCurve_;

        Period fundingFreq = arguments_.fundingFrequency;
        Date refDate = Settings::instance().evaluationDate();
        DayCounter dc = arguments_.dc;
        Calendar cal = arguments_.cal;
        
        Interpolation fundingRateInterp =
            DiscountingPerpetualFuturesEngine::selectInterpolation(fundingTimes_, fundingRates_);
        fundingRateInterp.enableExtrapolation();
        QL_REQUIRE(fundingRateInterp(fundingRateInterp.xMax()) > 0,
                   "fundingRate at max time is negative. Because the last funding rate is "
                   "flatly extrapolated, integral diverges.");
        Interpolation interestRateDiffInterp =
            DiscountingPerpetualFuturesEngine::selectInterpolation(fundingTimes_,
                                                                   interestRateDiffs_);
        interestRateDiffInterp.enableExtrapolation();

        Real factor = 0.;
        if (fundingFreq.length() > 0) { 
            // discrete-time case
            std::vector<Real> timeGrid;
            Real tGrid = 0.;
            while (tGrid < maxT_) {
                timeGrid.push_back(tGrid);
                Real tUnit = 0.;
                Date date = yearFractionToDate(dc, refDate, tGrid);
                Real daysInYear = dc.dayCount(Date(1, January, date.year()), Date(1, January, date.year()+1));
                switch (fundingFreq.units()) { 
                    case Years:
                        tGrid += fundingFreq.length();
                        break;
                    case Months:
                        tUnit = 1. / 12.;
                        tGrid += tUnit * fundingFreq.length();
                        break;
                    case Weeks:
                    case Days:
                        tGrid = dc.yearFraction(refDate, cal.advance(date, fundingFreq));
                        break;
                    case Hours:
                        tUnit = 1. / daysInYear / 24.;
                        tGrid += tUnit * fundingFreq.length();
                        break;
                    case Minutes:
                        tUnit = 1. / daysInYear / 24. / 60.;
                        tGrid += tUnit * fundingFreq.length();
                        break;
                    case Seconds:
                        tUnit = 1. / daysInYear / 24. / 60. / 60.;
                        tGrid += tUnit * fundingFreq.length();
                        break;
                    case Milliseconds:
                        tUnit = 1. / daysInYear / 24. / 60. / 60. / 1000.;
                        tGrid += tUnit * fundingFreq.length();
                        break;
                    case Microseconds:
                        tUnit = 1. / daysInYear / 24. / 60. / 60. / 1000. / 1000.;
                        tGrid += tUnit * fundingFreq.length();
                        break;
                    default:
                        QL_FAIL("Unknown unit in fundingFrequency");
                }
            }
            std::vector<Rate> fundingRateGrid(timeGrid.size());
            std::vector<Spread> interestRateDiffGrid(timeGrid.size());
            for (Size i = 0; i < timeGrid.size(); ++i) {
                Real time = timeGrid[i];
                fundingRateGrid[i] = fundingRateInterp(time);
                interestRateDiffGrid[i] = interestRateDiffInterp(time);
            }
            
            if (arguments_.fundingType == PerpetualFutures::FundingWithCurrentSpot) {
                Real ratio = 1.;
                Size i;
                for (i = 0; i < timeGrid.size() - 1; ++i) {
                    Real time = timeGrid[i];
                    Real nextTime = timeGrid[i + 1];
                    ratio = effForCurve->discount(nextTime) / effForCurve->discount(time)
                          / effDomCurve->discount(nextTime) * effDomCurve->discount(time);
                    fundingRateGrid[i] *= ratio;
                    interestRateDiffGrid[i] *= ratio;
                }
                // for i = timeGrid.size() - 1
                fundingRateGrid[i] *= ratio;
                interestRateDiffGrid[i] *= ratio;
            }
            auto productIRDiff = [timeGrid, fundingRateGrid](Size i) {
                Real ret = 1.;
                for (Size j = 0; j <= i; ++j) {
                    ret /= 1. + fundingRateGrid[j];
                }
                return ret;
            };
            Real sum = 0.;
            std::vector<Real> df_dom, df_for;
            for (Size i = 0; i < timeGrid.size() - 1; ++i) {
                Real time = timeGrid[i];
                sum += productIRDiff(i) * (fundingRateGrid[i] - interestRateDiffGrid[i])
                       * effForCurve->discount(time) / effDomCurve->discount(time);
                df_dom.push_back(effDomCurve->discount(time));
                df_for.push_back(effForCurve->discount(time));
            }
            Size iLast = timeGrid.size() - 1;
            Real timeLast = timeGrid[iLast];
            Real productIRDiffLast = productIRDiff(iLast);
            Real fundingRateGridLast = fundingRateGrid[iLast];
            Real interestRateDiffGridLast = interestRateDiffGrid[iLast];

            Real domRateLast =
                effDomCurve->forwardRate(timeLast, timeLast, Continuous, NoFrequency).rate();
            Real forRateLast =
                effForCurve->forwardRate(timeLast, timeLast, Continuous, NoFrequency).rate();

            // for t > maxT_, assume flat extrapolation on all rates
            Real lastTerm = productIRDiffLast
                             * (fundingRateGridLast - interestRateDiffGridLast)
                             * effForCurve->discount(timeLast) / effDomCurve->discount(timeLast);
            Real timeStep = (timeGrid.back() - timeGrid.front()) / (timeGrid.size() - 1);
            Real ratio =
                1. / (1. + fundingRateGridLast) * exp(-timeStep * (forRateLast - domRateLast));
            sum += lastTerm / (1. - ratio);
            factor = sum;

        } else {
            // continuous-time case
            TrapezoidIntegral<Default> integrator(1.e-6, 30);
            Real fundingRateXMax = fundingRateInterp.xMax();
            auto expIRDiff = [&fundingRateInterp, &integrator, fundingRateXMax](Real s) -> Real {
                if (s < fundingRateXMax) {
                    return exp(-integrator(fundingRateInterp, 0., s));
                } else {
                    return exp(-integrator(fundingRateInterp, 0., fundingRateXMax) -
                               fundingRateInterp(fundingRateXMax) * (s - fundingRateXMax));
                }
            };

            auto timeIntegrand = [fundingRateInterp, interestRateDiffInterp, integrator, expIRDiff,
                                  effDomCurve, effForCurve](Real s) -> Real {
                return (fundingRateInterp(s) - interestRateDiffInterp(s)) * expIRDiff(s)
                       * effForCurve->discount(s) / effDomCurve->discount(s);
            };
            factor = integrator(timeIntegrand, 0., maxT_);

            // for t > maxT_, assume flat extrapolaiton on all rates
            Real fundingRateLast = fundingRateInterp(maxT_);
            Real interestRateDiffLast = interestRateDiffInterp(maxT_);
            Real expIRDiff_last = expIRDiff(maxT_);
            Real domRateLast =
                effDomCurve->forwardRate(maxT_, maxT_, Continuous, NoFrequency).rate();
            Real forRateLast =
                effForCurve->forwardRate(maxT_, maxT_, Continuous, NoFrequency).rate();
            Real ratio = fundingRateLast + forRateLast - domRateLast;
            factor += (fundingRateLast - interestRateDiffLast) * expIRDiff_last *
                      effForCurve->discount(maxT_) / effDomCurve->discount(maxT_) / ratio;
        }

        if (arguments_.payoffType == PerpetualFutures::Linear) {
            results_.value = assetSpot_->value() * factor;
        } else {
            results_.value = assetSpot_->value() / factor;
        }
    }

    Interpolation
    DiscountingPerpetualFuturesEngine::selectInterpolation(const std::vector<Time>& times,
                                                           const std::vector<Real>& values) const {
        Interpolation interpolator;
        switch (fundingInterpType_) {
            case Linear:
                interpolator = LinearInterpolation(times.begin(), times.end(), values.begin());
                break;
            case PiecewiseConstant:
                interpolator =
                    BackwardFlatInterpolation(times.begin(), times.end(), values.begin());
                break;
            case CubicSpline:
                interpolator = CubicNaturalSpline(times.begin(), times.end(), values.begin());
                break;
            default:
                QL_FAIL("Unknown interpolation type");
        }
        return interpolator;
    }

}
]]></document_content>
  </document>
  <document index="75">
    <source>greeks.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/greeks.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    Real blackScholesTheta(
                   const ext::shared_ptr<GeneralizedBlackScholesProcess>& p,
                   Real value, Real delta, Real gamma) {

        Real u = p->stateVariable()->value();
        Rate r = p->riskFreeRate()->zeroRate(0.0, Continuous);
        Rate q = p->dividendYield()->zeroRate(0.0, Continuous);
        Volatility v = p->localVolatility()->localVol(0.0, u);

        return r*value -(r-q)*u*delta - 0.5*v*v*u*u*gamma;
    }

    Real defaultThetaPerDay(Real theta) {
        return theta/365.0;
    }

}
]]></document_content>
  </document>
  <document index="76">
    <source>inflation/inflationcapfloorengines.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */


#include <ql/pricingengines/blackformula.hpp>
#include <ql/pricingengines/inflation/inflationcapfloorengines.hpp>
#include <ql/termstructures/volatility/inflation/yoyinflationoptionletvolatilitystructure.hpp>
#include <utility>

namespace QuantLib {


    YoYInflationCapFloorEngine::YoYInflationCapFloorEngine(
        ext::shared_ptr<YoYInflationIndex> index,
        Handle<YoYOptionletVolatilitySurface> volatility,
        Handle<YieldTermStructure> nominalTermStructure)
    : index_(std::move(index)), volatility_(std::move(volatility)),
      nominalTermStructure_(std::move(nominalTermStructure)) {
        registerWith(index_);
        registerWith(volatility_);
        registerWith(nominalTermStructure_);
    }


    void YoYInflationCapFloorEngine::setVolatility(
            const Handle<YoYOptionletVolatilitySurface> &v) {
        if (!volatility_.empty())
            unregisterWith(volatility_);
        volatility_ = v;
        registerWith(volatility_);
        update();
    }


    void YoYInflationCapFloorEngine::calculate() const {

        // copy black version then adapt to others

        Real value = 0.0;
        Size optionlets = arguments_.startDates.size();
        std::vector<Real> values(optionlets, 0.0);
        std::vector<Real> stdDevs(optionlets, 0.0);
        std::vector<Real> forwards(optionlets, 0.0);
        YoYInflationCapFloor::Type type = arguments_.type;

        auto yoyTS = index()->yoyInflationTermStructure();

        Date settlement = nominalTermStructure_->referenceDate();

        for (Size i=0; i<optionlets; ++i) {
            Date paymentDate = arguments_.payDates[i];
            if (paymentDate > settlement) { // discard expired caplets
                DiscountFactor d = arguments_.nominals[i] *
                    arguments_.gearings[i] *
                    nominalTermStructure_->discount(paymentDate) *
                arguments_.accrualTimes[i];

                // We explicitly have the index and assume that
                // the fixing is natural, i.e. no convexity adjustment.
                // If that was required then we would also need
                // nominal vols in the pricing engine, i.e. a different engine.
                // This also means that we do not need the coupon to have
                // a pricing engine to return the swaplet rate and then
                // the adjusted fixing in the instrument.
                forwards[i] = yoyTS->yoyRate(arguments_.fixingDates[i]);
                Rate forward = forwards[i];

                Date fixingDate = arguments_.fixingDates[i];
                Time sqrtTime = 0.0;
                if (fixingDate > volatility_->baseDate()){
                    sqrtTime = std::sqrt(
                        volatility_->timeFromBase(fixingDate));
                }

                if (type == YoYInflationCapFloor::Cap || type == YoYInflationCapFloor::Collar) {
                    Rate strike = arguments_.capRates[i];
                    if (sqrtTime>0.0) {
                        stdDevs[i] = std::sqrt(
                            volatility_->totalVariance(fixingDate, strike, Period(0,Days)));

                    }

                    // sttDev=0 for already-fixed dates so everything on forward
                    values[i] = optionletImpl(Option::Call, strike,
                                              forward, stdDevs[i], d);
                }
                if (type == YoYInflationCapFloor::Floor || type == YoYInflationCapFloor::Collar) {
                    Rate strike = arguments_.floorRates[i];
                    if (sqrtTime>0.0) {
                        stdDevs[i] = std::sqrt(
                            volatility_->totalVariance(fixingDate, strike, Period(0,Days)));
                    }
                    Real floorlet = optionletImpl(Option::Put, strike,
                                                  forward, stdDevs[i], d);
                    if (type == YoYInflationCapFloor::Floor) {
                        values[i] = floorlet;
                    } else {
                        // a collar is long a cap and short a floor
                        values[i] -= floorlet;
                    }

                }
                value += values[i];
            }
        }
        results_.value = value;

        results_.additionalResults["optionletsPrice"] = values;
        results_.additionalResults["optionletsAtmForward"] = forwards;
        if (type != YoYInflationCapFloor::Collar)
            results_.additionalResults["optionletsStdDev"] = stdDevs;
    }


    //======================================================================
    // pricer implementations
    //======================================================================

    YoYInflationBlackCapFloorEngine::YoYInflationBlackCapFloorEngine(
                    const ext::shared_ptr<YoYInflationIndex>& index,
                    const Handle<YoYOptionletVolatilitySurface>& volatility,
                    const Handle<YieldTermStructure>& nominalTermStructure)
    : YoYInflationCapFloorEngine(index, volatility, nominalTermStructure) {}


    Real YoYInflationBlackCapFloorEngine::optionletImpl(Option::Type type, Rate strike,
                                                        Rate forward, Real stdDev,
                                                        Real d) const
    {
        return blackFormula(type, strike,
                            forward, stdDev, d);
    }



    YoYInflationUnitDisplacedBlackCapFloorEngine
    ::YoYInflationUnitDisplacedBlackCapFloorEngine(
                    const ext::shared_ptr<YoYInflationIndex>& index,
                    const Handle<YoYOptionletVolatilitySurface>& volatility,
                    const Handle<YieldTermStructure>& nominalTermStructure)
    : YoYInflationCapFloorEngine(index, volatility, nominalTermStructure) {}


    Real YoYInflationUnitDisplacedBlackCapFloorEngine::optionletImpl(
                                                        Option::Type type, Rate strike,
                                                        Rate forward, Real stdDev,
                                                        Real d) const
    {
        // could use displacement parameter in blackFormula but this is clearer
        return blackFormula(type, strike+1.0,
                            forward+1.0, stdDev, d);
    }


    YoYInflationBachelierCapFloorEngine::YoYInflationBachelierCapFloorEngine(
                    const ext::shared_ptr<YoYInflationIndex>& index,
                    const Handle<YoYOptionletVolatilitySurface>& volatility,
                    const Handle<YieldTermStructure>& nominalTermStructure)
    : YoYInflationCapFloorEngine(index, volatility, nominalTermStructure) {}


    Real YoYInflationBachelierCapFloorEngine::optionletImpl(Option::Type type, Rate strike,
                                                        Rate forward, Real stdDev,
                                                        Real d) const
    {
        return bachelierBlackFormula(type, strike,
                                     forward, stdDev, d);
    }

}

]]></document_content>
  </document>
  <document index="77">
    <source>lookback/analyticcontinuousfixedlookback.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/lookback/analyticcontinuousfixedlookback.hpp>
#include <utility>

namespace QuantLib {

    AnalyticContinuousFixedLookbackEngine::AnalyticContinuousFixedLookbackEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticContinuousFixedLookbackEngine::calculate() const {

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "Non-plain payoff given");

        QL_REQUIRE(process_->x0() > 0.0, "negative or null underlying");

        Real strike = payoff->strike();

        switch (payoff->optionType()) {
          case Option::Call:
            QL_REQUIRE(payoff->strike()>=0.0,
                       "Strike must be positive or null");
            if (strike <= minmax())
                results_.value = A(1) + C(1);
            else
                results_.value = B(1);
            break;
          case Option::Put:
            QL_REQUIRE(payoff->strike()>0.0,
                       "Strike must be positive");
            if (strike >= minmax())
                results_.value = A(-1) + C(-1);
            else
                results_.value = B(-1);
            break;
          default:
            QL_FAIL("Unknown type");
        }
    }


    Real AnalyticContinuousFixedLookbackEngine::underlying() const {
        return process_->x0();
    }

    Real AnalyticContinuousFixedLookbackEngine::strike() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "Non-plain payoff given");
        return payoff->strike();
    }

    Time AnalyticContinuousFixedLookbackEngine::residualTime() const {
        return process_->time(arguments_.exercise->lastDate());
    }

    Volatility AnalyticContinuousFixedLookbackEngine::volatility() const {
        return process_->blackVolatility()->blackVol(residualTime(), strike());
    }

    Real AnalyticContinuousFixedLookbackEngine::stdDeviation() const {
        return volatility() * std::sqrt(residualTime());
    }

    Rate AnalyticContinuousFixedLookbackEngine::riskFreeRate() const {
        return process_->riskFreeRate()->zeroRate(residualTime(), Continuous,
                                                  NoFrequency);
    }

    DiscountFactor AnalyticContinuousFixedLookbackEngine::riskFreeDiscount()
                              const {
        return process_->riskFreeRate()->discount(residualTime());
    }

    Rate AnalyticContinuousFixedLookbackEngine::dividendYield() const {
        return process_->dividendYield()->zeroRate(residualTime(),
                                                   Continuous, NoFrequency);
    }

    DiscountFactor AnalyticContinuousFixedLookbackEngine::dividendDiscount()
                              const {
        return process_->dividendYield()->discount(residualTime());
    }

    Real AnalyticContinuousFixedLookbackEngine::minmax() const {
        return arguments_.minmax;
    }

    Real AnalyticContinuousFixedLookbackEngine::A(Real eta) const {
        Volatility vol = volatility();
        Real lambda = 2.0*(riskFreeRate() - dividendYield())/(vol*vol);
        Real ss = underlying()/minmax();
        Real d1 =
            std::log(ss)/stdDeviation() + 0.5*(lambda+1.0)*stdDeviation();
        Real N1 = f_(eta*d1);
        Real N2 = f_(eta*(d1-stdDeviation()));
        Real N3 = f_(eta*(d1-lambda*stdDeviation()));
        Real N4 = f_(eta*d1);
        Real powss = std::pow(ss, -lambda);
        return eta*(underlying() * dividendDiscount() * N1 -
                    minmax() * riskFreeDiscount() * N2 -
                    underlying() * riskFreeDiscount() *
                    (powss * N3 - dividendDiscount()* N4/riskFreeDiscount())/
            lambda);
    }

    Real AnalyticContinuousFixedLookbackEngine::B(Real eta) const {
        Volatility vol = volatility();
        Real lambda = 2.0*(riskFreeRate() - dividendYield())/(vol*vol);
        Real ss = underlying()/strike();
        Real d1 =
            std::log(ss)/stdDeviation() + 0.5*(lambda+1.0)*stdDeviation();
        Real N1 = f_(eta*d1);
        Real N2 = f_(eta*(d1-stdDeviation()));
        Real N3 = f_(eta*(d1-lambda*stdDeviation()));
        Real N4 = f_(eta*d1);
        Real powss = std::pow(ss, -lambda);
        return eta*(underlying() * dividendDiscount() * N1 -
                    strike() * riskFreeDiscount() * N2 -
                    underlying() * riskFreeDiscount() *
                    (powss * N3 - dividendDiscount()* N4/riskFreeDiscount())/
            lambda);
    }

    Real AnalyticContinuousFixedLookbackEngine::C(Real eta) const {
        return eta*(riskFreeDiscount()*(minmax() - strike()));
    }

}

]]></document_content>
  </document>
  <document index="78">
    <source>lookback/analyticcontinuousfloatinglookback.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/lookback/analyticcontinuousfloatinglookback.hpp>
#include <utility>

namespace QuantLib {

    AnalyticContinuousFloatingLookbackEngine::AnalyticContinuousFloatingLookbackEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticContinuousFloatingLookbackEngine::calculate() const {

        ext::shared_ptr<FloatingTypePayoff> payoff =
            ext::dynamic_pointer_cast<FloatingTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "Non-floating payoff given");

        QL_REQUIRE(process_->x0() > 0.0, "negative or null underlying");

        switch (payoff->optionType()) {
          case Option::Call:
            results_.value = A(1);
            break;
          case Option::Put:
            results_.value = A(-1);
            break;
          default:
            QL_FAIL("Unknown type");
        }
    }

    Real AnalyticContinuousFloatingLookbackEngine::underlying() const {
        return process_->x0();
    }

    Time AnalyticContinuousFloatingLookbackEngine::residualTime() const {
        return process_->time(arguments_.exercise->lastDate());
    }

    Volatility AnalyticContinuousFloatingLookbackEngine::volatility() const {
        return process_->blackVolatility()->blackVol(residualTime(), minmax());
    }

    Real AnalyticContinuousFloatingLookbackEngine::stdDeviation() const {
        return volatility() * std::sqrt(residualTime());
    }

    Rate AnalyticContinuousFloatingLookbackEngine::riskFreeRate() const {
        return process_->riskFreeRate()->zeroRate(residualTime(), Continuous,
                                                  NoFrequency);
    }

    DiscountFactor AnalyticContinuousFloatingLookbackEngine::riskFreeDiscount()
                                 const {
        return process_->riskFreeRate()->discount(residualTime());
    }

    Rate AnalyticContinuousFloatingLookbackEngine::dividendYield() const {
        return process_->dividendYield()->zeroRate(residualTime(),
                                                   Continuous, NoFrequency);
    }

    DiscountFactor AnalyticContinuousFloatingLookbackEngine::dividendDiscount()
                                 const {
        return process_->dividendYield()->discount(residualTime());
    }

    Real AnalyticContinuousFloatingLookbackEngine::minmax() const {
        return arguments_.minmax;
    }

    Real AnalyticContinuousFloatingLookbackEngine::A(Real eta) const {
        Volatility vol = volatility();
        Real lambda = 2.0*(riskFreeRate() - dividendYield())/(vol*vol);
        Real s = underlying()/minmax();
        Real d1 = std::log(s)/stdDeviation() + 0.5*(lambda+1.0)*stdDeviation();
        Real n1 = f_(eta*d1);
        Real n2 = f_(eta*(d1-stdDeviation()));
        Real n3 = f_(eta*(-d1+lambda*stdDeviation()));
        Real n4 = f_(eta*-d1);
        Real pow_s = std::pow(s, -lambda);
        return eta*((underlying() * dividendDiscount() * n1 -
                    minmax() * riskFreeDiscount() * n2) +
                    (underlying() * riskFreeDiscount() *
                    (pow_s * n3 - dividendDiscount()* n4/riskFreeDiscount())/
            lambda));
    }

}

]]></document_content>
  </document>
  <document index="79">
    <source>lookback/analyticcontinuouspartialfixedlookback.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/lookback/analyticcontinuouspartialfixedlookback.hpp>
#include <utility>

namespace QuantLib {

    AnalyticContinuousPartialFixedLookbackEngine::AnalyticContinuousPartialFixedLookbackEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticContinuousPartialFixedLookbackEngine::calculate() const {

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "Non-plain payoff given");

        QL_REQUIRE(process_->x0() > 0.0, "negative or null underlying");

        switch (payoff->optionType()) {
          case Option::Call:
            QL_REQUIRE(payoff->strike()>=0.0,
                       "Strike must be positive or null");
            results_.value = A(1);
            break;
          case Option::Put:
            QL_REQUIRE(payoff->strike()>0.0,
                       "Strike must be positive");
            results_.value = A(-1);
            break;
          default:
            QL_FAIL("Unknown type");
        }
    }


    Real AnalyticContinuousPartialFixedLookbackEngine::underlying() const {
        return process_->x0();
    }

    Real AnalyticContinuousPartialFixedLookbackEngine::strike() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "Non-plain payoff given");
        return payoff->strike();
    }

    Time AnalyticContinuousPartialFixedLookbackEngine::residualTime() const {
        return process_->time(arguments_.exercise->lastDate());
    }

    Volatility AnalyticContinuousPartialFixedLookbackEngine::volatility() const {
        return process_->blackVolatility()->blackVol(residualTime(), strike());
    }

    Real AnalyticContinuousPartialFixedLookbackEngine::stdDeviation() const {
        return volatility() * std::sqrt(residualTime());
    }

    Rate AnalyticContinuousPartialFixedLookbackEngine::riskFreeRate() const {
        return process_->riskFreeRate()->zeroRate(residualTime(), Continuous,
                                                  NoFrequency);
    }

    DiscountFactor AnalyticContinuousPartialFixedLookbackEngine::riskFreeDiscount()
                              const {
        return process_->riskFreeRate()->discount(residualTime());
    }

    Rate AnalyticContinuousPartialFixedLookbackEngine::dividendYield() const {
        return process_->dividendYield()->zeroRate(residualTime(),
                                                   Continuous, NoFrequency);
    }

    DiscountFactor AnalyticContinuousPartialFixedLookbackEngine::dividendDiscount()
                              const {
        return process_->dividendYield()->discount(residualTime());
    }

    Time AnalyticContinuousPartialFixedLookbackEngine::lookbackPeriodStartTime() const {
        return process_->time(arguments_.lookbackPeriodStart);
    }

    Real AnalyticContinuousPartialFixedLookbackEngine::A(Real eta) const {
        bool differentStartOfLookback = lookbackPeriodStartTime() != residualTime();
        Real carry = riskFreeRate() - dividendYield();

        Volatility vol = volatility();
        Real x = 2.0*carry/(vol*vol);
        Real s = underlying()/strike();
        Real ls = std::log(s);
        Real d1 = ls/stdDeviation() + 0.5*(x+1.0)*stdDeviation();
        Real d2 = d1 - stdDeviation();

        Real e1 = 0, e2 = 0;
        if (differentStartOfLookback)
        {
            e1 = (carry + vol * vol / 2) * (residualTime() - lookbackPeriodStartTime()) / (vol * std::sqrt(residualTime() - lookbackPeriodStartTime()));
            e2 = e1 - vol * std::sqrt(residualTime() - lookbackPeriodStartTime());
        }

        Real f1 = (ls + (carry + vol * vol / 2) * lookbackPeriodStartTime()) / (vol * std::sqrt(lookbackPeriodStartTime()));
        Real f2 = f1 - vol * std::sqrt(lookbackPeriodStartTime());

        Real n1 = f_(eta*d1);
        Real n2 = f_(eta*d2);

        BivariateCumulativeNormalDistributionWe04DP cnbn1(-1), cnbn2(0), cnbn3(0);
        if (differentStartOfLookback) {
            cnbn1 = BivariateCumulativeNormalDistributionWe04DP (-std::sqrt(lookbackPeriodStartTime() / residualTime()));
            cnbn2 = BivariateCumulativeNormalDistributionWe04DP (std::sqrt(1 - lookbackPeriodStartTime() / residualTime()));
            cnbn3 = BivariateCumulativeNormalDistributionWe04DP (-std::sqrt(1 - lookbackPeriodStartTime() / residualTime()));
        }

        Real n3 = cnbn1(eta*(d1-x*stdDeviation()), eta*(-f1+2.0* carry * std::sqrt(lookbackPeriodStartTime()) / vol));
        Real n4 = cnbn2(eta*e1, eta*d1);
        Real n5 = cnbn3(-eta*e1, eta*d1);
        Real n6 = cnbn1(eta*f2, -eta*d2);
        Real n7 = f_(eta*f1);
        Real n8 = f_(-eta*e2);

        Real pow_s = std::pow(s, -x);
        Real carryDiscount = std::exp(-carry * (residualTime() - lookbackPeriodStartTime()));
        return eta*(underlying() * dividendDiscount() * n1 
                    - strike() * riskFreeDiscount() * n2
                    + underlying() * riskFreeDiscount() / x 
                    * (-pow_s * n3 + dividendDiscount() / riskFreeDiscount() * n4)
                    - underlying() * dividendDiscount() * n5 
                    - strike() * riskFreeDiscount() * n6 
                    + carryDiscount * dividendDiscount() 
                    * (1 - 0.5 * vol * vol / carry) * 
                    underlying() * n7 * n8);
    }
}

]]></document_content>
  </document>
  <document index="80">
    <source>lookback/analyticcontinuouspartialfloatinglookback.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/lookback/analyticcontinuouspartialfloatinglookback.hpp>
#include <utility>

namespace QuantLib {

    AnalyticContinuousPartialFloatingLookbackEngine::
        AnalyticContinuousPartialFloatingLookbackEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticContinuousPartialFloatingLookbackEngine::calculate() const {

        ext::shared_ptr<FloatingTypePayoff> payoff =
            ext::dynamic_pointer_cast<FloatingTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "Non-floating payoff given");

        QL_REQUIRE(process_->x0() > 0.0, "negative or null underlying");

        switch (payoff->optionType()) {
          case Option::Call:
            results_.value = A(1);
            break;
          case Option::Put:
            results_.value = A(-1);
            break;
          default:
            QL_FAIL("Unknown type");
        }
    }

    Real AnalyticContinuousPartialFloatingLookbackEngine::underlying() const {
        return process_->x0();
    }

    Time AnalyticContinuousPartialFloatingLookbackEngine::residualTime() const {
        return process_->time(arguments_.exercise->lastDate());
    }

    Volatility AnalyticContinuousPartialFloatingLookbackEngine::volatility() const {
        return process_->blackVolatility()->blackVol(residualTime(), minmax());
    }

    Real AnalyticContinuousPartialFloatingLookbackEngine::stdDeviation() const {
        return volatility() * std::sqrt(residualTime());
    }

    Rate AnalyticContinuousPartialFloatingLookbackEngine::riskFreeRate() const {
        return process_->riskFreeRate()->zeroRate(residualTime(), Continuous,
                                                  NoFrequency);
    }

    DiscountFactor AnalyticContinuousPartialFloatingLookbackEngine::riskFreeDiscount()
                                 const {
        return process_->riskFreeRate()->discount(residualTime());
    }

    Rate AnalyticContinuousPartialFloatingLookbackEngine::dividendYield() const {
        return process_->dividendYield()->zeroRate(residualTime(),
                                                   Continuous, NoFrequency);
    }

    DiscountFactor AnalyticContinuousPartialFloatingLookbackEngine::dividendDiscount()
                                 const {
        return process_->dividendYield()->discount(residualTime());
    }

    Real AnalyticContinuousPartialFloatingLookbackEngine::minmax() const {
        return arguments_.minmax;
    }

    Real AnalyticContinuousPartialFloatingLookbackEngine::lambda() const {
        return arguments_.lambda;
    }

    Time AnalyticContinuousPartialFloatingLookbackEngine::lookbackPeriodEndTime() const {
        return process_->time(arguments_.lookbackPeriodEnd);
    }


    Real AnalyticContinuousPartialFloatingLookbackEngine::A(Real eta) const {
        bool fullLookbackPeriod = lookbackPeriodEndTime() == residualTime();
        Real carry = riskFreeRate() - dividendYield();
        Volatility vol = volatility();
        Real x = 2.0*carry/(vol*vol);
        Real s = underlying()/minmax();

        Real ls = std::log(s);
        Real d1 = ls/stdDeviation() + 0.5*(x+1.0)*stdDeviation();
        Real d2 = d1 - stdDeviation();

        Real e1 = 0, e2 = 0;
        if (!fullLookbackPeriod)
        {
            e1 = (carry + vol * vol / 2) * (residualTime() - lookbackPeriodEndTime()) / (vol * std::sqrt(residualTime() - lookbackPeriodEndTime()));
            e2 = e1 - vol * std::sqrt(residualTime() - lookbackPeriodEndTime());
        }

        Real f1 = (ls + (carry + vol * vol / 2) * lookbackPeriodEndTime()) / (vol * std::sqrt(lookbackPeriodEndTime()));
        Real f2 = f1 - vol * std::sqrt(lookbackPeriodEndTime());

        Real l1 = std::log(lambda()) / vol;
        Real g1 = l1 / std::sqrt(residualTime());

        Real n1 = f_(eta*(d1 - g1));
        Real n2 = f_(eta*(d2 - g1));

        BivariateCumulativeNormalDistributionWe04DP cnbn1(1), cnbn2(0), cnbn3(-1);
        if (!fullLookbackPeriod) {
            cnbn1 = BivariateCumulativeNormalDistributionWe04DP (std::sqrt(lookbackPeriodEndTime() / residualTime()));
            cnbn2 = BivariateCumulativeNormalDistributionWe04DP (-std::sqrt(1 - lookbackPeriodEndTime() / residualTime()));
            cnbn3 = BivariateCumulativeNormalDistributionWe04DP (-std::sqrt(lookbackPeriodEndTime() / residualTime()));
        }

        Real n3 = cnbn1(eta*(-f1+2.0* carry * std::sqrt(lookbackPeriodEndTime()) / vol), eta*(-d1+x*stdDeviation()-g1));
        Real n4 = 0, n5 = 0, n6 = 0, n7 = 0;
        if (!fullLookbackPeriod)
        {
            Real g2 = l1 / std::sqrt(residualTime() - lookbackPeriodEndTime());
            n4 = cnbn2(-eta*(d1+g1), eta*(e1 + g2));
            n5 = cnbn2(-eta*(d1-g1), eta*(e1 - g2));
            n6 = cnbn3(eta*-f2, eta*(d2 - g1));
            n7 = f_(eta*(e2 - g2));
        }
        else
        {
            n4 = f_(-eta*(d1+g1));
        }

        Real n8 = f_(-eta*f1);
        Real pow_s = std::pow(s, -x);
        Real pow_l = std::pow(lambda(), x);

        if (!fullLookbackPeriod)
        {
            return eta*(underlying() * dividendDiscount() * n1 -
                        lambda() * minmax() * riskFreeDiscount() * n2 + 
                        underlying() * riskFreeDiscount() * lambda() / x *
                        (pow_s * n3 - dividendDiscount() / riskFreeDiscount() * pow_l * n4)
                        + underlying() * dividendDiscount() * n5 + 
                        riskFreeDiscount() * lambda() * minmax() * n6 -
                        std::exp(-carry * (residualTime() - lookbackPeriodEndTime())) * 
                        dividendDiscount() * (1 + 0.5 * vol * vol / carry) * lambda() * 
                        underlying() * n7 * n8);
        }
        else
        {
            //Simpler calculation
            return eta*(underlying() * dividendDiscount() * n1 -
                        lambda() * minmax() * riskFreeDiscount() * n2 + 
                        underlying() * riskFreeDiscount() * lambda() / x *
                        (pow_s * n3 - dividendDiscount() / riskFreeDiscount() * pow_l * n4));
        }
    }
}

]]></document_content>
  </document>
  <document index="81">
    <source>lookback/mclookbackengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Lew Wei Hao

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/lookback/mclookbackengine.hpp>
#include <algorithm>

namespace QuantLib {

    class LookbackFixedPathPricer : public PathPricer<Path> {
      public:
        LookbackFixedPathPricer(Option::Type type,
                                Real strike,
                                DiscountFactor discount);
        Real operator()(const Path& path) const override;

      private:
        PlainVanillaPayoff payoff_;
        DiscountFactor discount_;
    };

    class LookbackPartialFixedPathPricer : public PathPricer<Path> {
      public:
        LookbackPartialFixedPathPricer(Time lookbackStart,
                                       Option::Type type,
                                       Real strike,
                                       DiscountFactor discount);
        Real operator()(const Path& path) const override;

      private:
        Time lookbackStart_;
        PlainVanillaPayoff payoff_;
        DiscountFactor discount_;
    };

    class LookbackFloatingPathPricer : public PathPricer<Path> {
      public:
        LookbackFloatingPathPricer(Option::Type type,
                                   DiscountFactor discount);
        Real operator()(const Path& path) const override;

      private:
        FloatingTypePayoff payoff_;
        DiscountFactor discount_;
    };

    class LookbackPartialFloatingPathPricer : public PathPricer<Path> {
      public:
        LookbackPartialFloatingPathPricer(Time lookbackEnd,
                                          Option::Type type,
                                          DiscountFactor discount);
        Real operator()(const Path& path) const override;

      private:
        Time lookbackEnd_;
        FloatingTypePayoff payoff_;
        DiscountFactor discount_;
    };

    namespace detail {

        ext::shared_ptr<PathPricer<Path> >
        mc_lookback_path_pricer(
               const ContinuousFixedLookbackOption::arguments& args,
               const GeneralizedBlackScholesProcess& process,
               DiscountFactor discount) {
            ext::shared_ptr<PlainVanillaPayoff> payoff =
                ext::dynamic_pointer_cast<PlainVanillaPayoff>(args.payoff);
            QL_REQUIRE(payoff, "non-plain payoff given");

            return ext::shared_ptr<PathPricer<Path> >(
                new LookbackFixedPathPricer(payoff->optionType(),
                                            payoff->strike(),
                                            discount));
        }

        ext::shared_ptr<PathPricer<Path> >
        mc_lookback_path_pricer(
               const ContinuousPartialFixedLookbackOption::arguments& args,
               const GeneralizedBlackScholesProcess& process,
               DiscountFactor discount) {
            ext::shared_ptr<PlainVanillaPayoff> payoff =
                ext::dynamic_pointer_cast<PlainVanillaPayoff>(args.payoff);
            QL_REQUIRE(payoff, "non-plain payoff given");

            Time lookbackStart = process.time(args.lookbackPeriodStart);

            return ext::shared_ptr<PathPricer<Path> >(
                new LookbackPartialFixedPathPricer(lookbackStart,
                                                   payoff->optionType(),
                                                   payoff->strike(),
                                                   discount));
        }

        ext::shared_ptr<PathPricer<Path> >
        mc_lookback_path_pricer(
               const ContinuousFloatingLookbackOption::arguments& args,
               const GeneralizedBlackScholesProcess& process,
               DiscountFactor discount) {
            ext::shared_ptr<FloatingTypePayoff> payoff =
                ext::dynamic_pointer_cast<FloatingTypePayoff>(args.payoff);
            QL_REQUIRE(payoff, "non-floating payoff given");

            return ext::shared_ptr<PathPricer<Path> >(
                new LookbackFloatingPathPricer(payoff->optionType(),
                                               discount));
        }

        ext::shared_ptr<PathPricer<Path> >
        mc_lookback_path_pricer(
               const ContinuousPartialFloatingLookbackOption::arguments& args,
               const GeneralizedBlackScholesProcess& process,
               DiscountFactor discount) {
            ext::shared_ptr<FloatingTypePayoff> payoff =
                ext::dynamic_pointer_cast<FloatingTypePayoff>(args.payoff);
            QL_REQUIRE(payoff, "non-floating payoff given");

            Time lookbackEnd = process.time(args.lookbackPeriodEnd);

            return ext::shared_ptr<PathPricer<Path> >(
                new LookbackPartialFloatingPathPricer(lookbackEnd,
                                                      payoff->optionType(),
                                                      discount));
        }

    }


    LookbackFixedPathPricer::LookbackFixedPathPricer(
        Option::Type type,
        Real strike,
        DiscountFactor discount)
    : payoff_(type, strike), discount_(discount) {
        QL_REQUIRE(strike>=0.0,
                   "strike less than zero not allowed");
    }

    Real LookbackFixedPathPricer::operator()(const Path& path) const {
        QL_REQUIRE(!path.empty(), "the path cannot be empty");

        Real underlying;
        switch (payoff_.optionType()) {
          case Option::Put:
            underlying = *std::min_element(path.begin()+1, path.end());
            break;
          case Option::Call:
            underlying = *std::max_element(path.begin()+1, path.end());
            break;
          default:
            QL_FAIL("unknown option type");
        }

        return payoff_(underlying) * discount_;
    }


    LookbackPartialFixedPathPricer::LookbackPartialFixedPathPricer(
        Time lookbackStart,
        Option::Type type,
        Real strike,
        const DiscountFactor discount)
    : lookbackStart_(lookbackStart), payoff_(type, strike), discount_(discount) {
        QL_REQUIRE(strike>=0.0,
                   "strike less than zero not allowed");
    }

    Real LookbackPartialFixedPathPricer::operator()(const Path& path) const {
        QL_REQUIRE(!path.empty(), "the path cannot be empty");

        const TimeGrid& timeGrid = path.timeGrid();
        Size startIndex = timeGrid.closestIndex(lookbackStart_);
        Real underlying;
        switch (payoff_.optionType()) {
          case Option::Put:
            underlying = *std::min_element(path.begin()+startIndex+1, path.end());
            break;
          case Option::Call:
            underlying = *std::max_element(path.begin()+startIndex+1, path.end());
            break;
          default:
            QL_FAIL("unknown option type");
        }

        return payoff_(underlying) * discount_;
    }


    LookbackFloatingPathPricer::LookbackFloatingPathPricer(
        Option::Type type,
        const DiscountFactor discount)
    : payoff_(type), discount_(discount) {}

    Real LookbackFloatingPathPricer::operator()(const Path& path) const {
        QL_REQUIRE(!path.empty(), "the path cannot be empty");

        Real terminalPrice = path.back();
        Real strike;
        switch (payoff_.optionType()) {
          case Option::Call:
            strike = *std::min_element(path.begin()+1, path.end());
            break;
          case Option::Put:
            strike = *std::max_element(path.begin()+1, path.end());
            break;
          default:
            QL_FAIL("unknown option type");
        }

        return payoff_(terminalPrice, strike) * discount_;
    }


    LookbackPartialFloatingPathPricer::LookbackPartialFloatingPathPricer(
        Time lookbackEnd,
        Option::Type type,
        DiscountFactor discount)
        : lookbackEnd_(lookbackEnd), payoff_(type), discount_(discount) {}

    Real LookbackPartialFloatingPathPricer::operator()(const Path& path) const {
        QL_REQUIRE(!path.empty(), "the path cannot be empty");

        const TimeGrid& timeGrid = path.timeGrid();
        Size endIndex = timeGrid.closestIndex(lookbackEnd_);
        Real terminalPrice = path.back();
        Real strike;

        switch (payoff_.optionType()) {
          case Option::Call:
            strike = *std::min_element(path.begin()+1, path.begin()+endIndex+1);
            break;
          case Option::Put:
            strike = *std::max_element(path.begin()+1, path.begin()+endIndex+1);
            break;
          default:
            QL_FAIL("unknown option type");
        }

        return payoff_(terminalPrice, strike) * discount_;
    }

}
]]></document_content>
  </document>
  <document index="82">
    <source>swap/cvaswapengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/swap/cvaswapengine.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/floatingratecoupon.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/instruments/makevanillaswap.hpp>
#include <ql/exercise.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/termstructures/credit/flathazardrate.hpp>
#include <ql/pricingengines/swaption/blackswaptionengine.hpp>
#include <ql/time/calendars/nullcalendar.hpp>

namespace QuantLib {
  
  CounterpartyAdjSwapEngine::CounterpartyAdjSwapEngine(
      const Handle<YieldTermStructure>& discountCurve,
      const Handle<PricingEngine>& swaptionEngine,
      const Handle<DefaultProbabilityTermStructure>& ctptyDTS,
      Real ctptyRecoveryRate,
      const Handle<DefaultProbabilityTermStructure>& invstDTS,
      Real invstRecoveryRate)
  : baseSwapEngine_(Handle<PricingEngine>(
      ext::make_shared<DiscountingSwapEngine>(discountCurve))),
    swaptionletEngine_(swaptionEngine),
    discountCurve_(discountCurve),
    defaultTS_(ctptyDTS), 
    ctptyRecoveryRate_(ctptyRecoveryRate),
    invstDTS_(invstDTS.empty() ? Handle<DefaultProbabilityTermStructure>(
        ext::make_shared<FlatHazardRate>(0, NullCalendar(), 1.e-12, 
        ctptyDTS->dayCounter()) ) : invstDTS ),
    invstRecoveryRate_(invstRecoveryRate)
  {
      registerWith(discountCurve);
      registerWith(ctptyDTS);
      registerWith(invstDTS_);
      registerWith(swaptionEngine);
  }

    CounterpartyAdjSwapEngine::CounterpartyAdjSwapEngine(
        const Handle<YieldTermStructure>& discountCurve,
        const Volatility blackVol,
        const Handle<DefaultProbabilityTermStructure>& ctptyDTS,
        Real ctptyRecoveryRate,
        const Handle<DefaultProbabilityTermStructure>& invstDTS,
        Real invstRecoveryRate)
  : baseSwapEngine_(Handle<PricingEngine>(
      ext::make_shared<DiscountingSwapEngine>(discountCurve))),
    swaptionletEngine_(Handle<PricingEngine>(
      ext::make_shared<BlackSwaptionEngine>(discountCurve,
        blackVol))),
    discountCurve_(discountCurve),
    defaultTS_(ctptyDTS), 
    ctptyRecoveryRate_(ctptyRecoveryRate),
    invstDTS_(invstDTS.empty() ? Handle<DefaultProbabilityTermStructure>(
        ext::make_shared<FlatHazardRate>(0, NullCalendar(), 1.e-12, 
        ctptyDTS->dayCounter()) ) : invstDTS ),
    invstRecoveryRate_(invstRecoveryRate)
  {
      registerWith(discountCurve);
      registerWith(ctptyDTS);
      registerWith(invstDTS_);
  }

  CounterpartyAdjSwapEngine::CounterpartyAdjSwapEngine(
        const Handle<YieldTermStructure>& discountCurve,
        const Handle<Quote>& blackVol,
        const Handle<DefaultProbabilityTermStructure>& ctptyDTS,
        Real ctptyRecoveryRate,
        const Handle<DefaultProbabilityTermStructure>& invstDTS,
        Real invstRecoveryRate)
  : baseSwapEngine_(Handle<PricingEngine>(
      ext::make_shared<DiscountingSwapEngine>(discountCurve))),
    swaptionletEngine_(Handle<PricingEngine>(
      ext::make_shared<BlackSwaptionEngine>(discountCurve,
        blackVol))),
    discountCurve_(discountCurve),
    defaultTS_(ctptyDTS), 
    ctptyRecoveryRate_(ctptyRecoveryRate),
    invstDTS_(invstDTS.empty() ? Handle<DefaultProbabilityTermStructure>(
        ext::make_shared<FlatHazardRate>(0, NullCalendar(), 1.e-12, 
        ctptyDTS->dayCounter()) ) : invstDTS ),
    invstRecoveryRate_(invstRecoveryRate)
  {
      registerWith(discountCurve);
      registerWith(ctptyDTS);
      registerWith(invstDTS_);
      registerWith(blackVol);
  }

  void CounterpartyAdjSwapEngine::calculate() const {
      /* both DTS, YTS ref dates and pricing date consistency 
         checks? settlement... */
    QL_REQUIRE(!discountCurve_.empty(),
                 "no discount term structure set");
    QL_REQUIRE(!defaultTS_.empty(),
                 "no ctpty default term structure set");
    QL_REQUIRE(!swaptionletEngine_.empty(),
                 "no swap option engine set");

    QL_REQUIRE(arguments_.nominal != Null<Real>(),
               "non-constant nominals are not supported yet");

    Date priceDate = defaultTS_->referenceDate();

    Real cumOptVal = 0., 
        cumPutVal = 0.;
    // Vanilla swap so 0 leg is floater

    auto nextFD = 
      arguments_.fixedPayDates.begin();
    Date swapletStart = priceDate;
    while (*nextFD < priceDate) ++nextFD;

    // Compute fair spread for strike value:
    // copy args into the non risky engine
    auto* noCVAArgs = dynamic_cast<Swap::arguments*>(baseSwapEngine_->getArguments());
    QL_REQUIRE(noCVAArgs != nullptr, "wrong argument type");

    noCVAArgs->legs = this->arguments_.legs;
    noCVAArgs->payer = this->arguments_.payer;

    baseSwapEngine_->calculate();

    ext::shared_ptr<FixedRateCoupon> coupon = ext::dynamic_pointer_cast<FixedRateCoupon>(arguments_.legs[0][0]);
    QL_REQUIRE(coupon,"dynamic cast of fixed leg coupon failed.");
    Rate baseSwapRate = coupon->rate();

    const auto* vSResults = dynamic_cast<const Swap::results*>(baseSwapEngine_->getResults());
    QL_REQUIRE(vSResults != nullptr, "wrong result type");

    Rate baseSwapFairRate = -baseSwapRate * vSResults->legNPV[1] / 
        vSResults->legNPV[0];
    Real baseSwapNPV = vSResults->value;

    Swap::Type reversedType = arguments_.type == Swap::Payer ? Swap::Receiver : Swap::Payer;

    // Swaplet options summatory:
    while(nextFD != arguments_.fixedPayDates.end()) {
      // iFD coupon not fixed, create swaptionlet:
      ext::shared_ptr<FloatingRateCoupon> floatCoupon = ext::dynamic_pointer_cast<FloatingRateCoupon>(arguments_.legs[1][0]);
      QL_REQUIRE(floatCoupon,"dynamic cast of floating leg coupon failed.");
      ext::shared_ptr<IborIndex> swapIndex = ext::dynamic_pointer_cast<IborIndex>(floatCoupon->index());
      QL_REQUIRE(swapIndex,"dynamic cast of floating leg index failed.");

      // Alternatively one could cap this period to, say, 1M 
      // Period swapPeriod = ext::dynamic_pointer_cast<FloatingRateCoupon>(
      //   arguments_.legs[1][0])->index()->tenor();

      Period baseSwapsTenor(arguments_.fixedPayDates.back().serialNumber() 
	    - swapletStart.serialNumber(), Days);
      ext::shared_ptr<VanillaSwap> swaplet = MakeVanillaSwap(
        baseSwapsTenor,
        swapIndex, 
        baseSwapFairRate // strike
        )
	    .withType(arguments_.type)
	    .withNominal(arguments_.nominal)
          ////////	    .withSettlementDays(2)
        .withEffectiveDate(swapletStart)
        .withTerminationDate(arguments_.fixedPayDates.back());
      ext::shared_ptr<VanillaSwap> revSwaplet = MakeVanillaSwap(
        baseSwapsTenor,
        swapIndex, 
        baseSwapFairRate // strike
        )
	    .withType(reversedType)
	    .withNominal(arguments_.nominal)
          /////////	    .withSettlementDays(2)
        .withEffectiveDate(swapletStart)
        .withTerminationDate(arguments_.fixedPayDates.back());

      Swaption swaptionlet(swaplet, 
        ext::make_shared<EuropeanExercise>(swapletStart));
      Swaption putSwaplet(revSwaplet, 
        ext::make_shared<EuropeanExercise>(swapletStart));
      swaptionlet.setPricingEngine(swaptionletEngine_.currentLink());
      putSwaplet.setPricingEngine(swaptionletEngine_.currentLink());

      // atm underlying swap means that the value of put = value
      // call so this double pricing is not needed
      cumOptVal += swaptionlet.NPV() * defaultTS_->defaultProbability(
          swapletStart, *nextFD);
      cumPutVal += putSwaplet.NPV()  * invstDTS_->defaultProbability(
	      swapletStart, *nextFD);

      swapletStart = *nextFD;
      ++nextFD;
    }
  
    results_.value = baseSwapNPV - (1.-ctptyRecoveryRate_) * cumOptVal
        + (1.-invstRecoveryRate_) * cumPutVal;

    results_.fairRate =  -baseSwapRate * (vSResults->legNPV[1] 
        - (1.-ctptyRecoveryRate_) * cumOptVal + 
          (1.-invstRecoveryRate_) * cumPutVal )
      / vSResults->legNPV[0];

  }


}
]]></document_content>
  </document>
  <document index="83">
    <source>swap/discountingswapengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 StatPro Italia srl
 Copyright (C) 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflows.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/optional.hpp>
#include <utility>

namespace QuantLib {

    DiscountingSwapEngine::DiscountingSwapEngine(
        Handle<YieldTermStructure> discountCurve,
        const ext::optional<bool>& includeSettlementDateFlows,
        Date settlementDate,
        Date npvDate)
    : discountCurve_(std::move(discountCurve)),
      includeSettlementDateFlows_(includeSettlementDateFlows), settlementDate_(settlementDate),
      npvDate_(npvDate) {
        registerWith(discountCurve_);
    }

    void DiscountingSwapEngine::calculate() const {
        QL_REQUIRE(!discountCurve_.empty(),
                   "discounting term structure handle is empty");

        results_.value = 0.0;
        results_.errorEstimate = Null<Real>();

        Date refDate = discountCurve_->referenceDate();

        Date settlementDate = settlementDate_;
        if (settlementDate_==Date()) {
            settlementDate = refDate;
        } else {
            QL_REQUIRE(settlementDate>=refDate,
                       "settlement date (" << settlementDate << ") before "
                       "discount curve reference date (" << refDate << ")");
        }

        results_.valuationDate = npvDate_;
        if (npvDate_==Date()) {
            results_.valuationDate = refDate;
        } else {
            QL_REQUIRE(npvDate_>=refDate,
                       "npv date (" << npvDate_  << ") before "
                       "discount curve reference date (" << refDate << ")");
        }
        results_.npvDateDiscount = discountCurve_->discount(results_.valuationDate);

        Size n = arguments_.legs.size();
        results_.legNPV.resize(n);
        results_.legBPS.resize(n);
        results_.startDiscounts.resize(n);
        results_.endDiscounts.resize(n);

        bool includeRefDateFlows = includeSettlementDateFlows_ ? // NOLINT(readability-implicit-bool-conversion)
                                       *includeSettlementDateFlows_ :
                                       Settings::instance().includeReferenceDateEvents();

        for (Size i=0; i<n; ++i) {
            try {
                const YieldTermStructure& discount_ref = **discountCurve_;
                std::tie(results_.legNPV[i], results_.legBPS[i]) =
                    CashFlows::npvbps(arguments_.legs[i],
                                      discount_ref,
                                      includeRefDateFlows,
                                      settlementDate,
                                      results_.valuationDate);
                results_.legNPV[i] *= arguments_.payer[i];
                results_.legBPS[i] *= arguments_.payer[i];

                if (!arguments_.legs[i].empty()) {
                    Date d1 = CashFlows::startDate(arguments_.legs[i]);
                    if (d1>=refDate)
                        results_.startDiscounts[i] = discountCurve_->discount(d1);
                    else
                        results_.startDiscounts[i] = Null<DiscountFactor>();

                    Date d2 = CashFlows::maturityDate(arguments_.legs[i]);
                    if (d2>=refDate)
                        results_.endDiscounts[i] = discountCurve_->discount(d2);
                    else
                        results_.endDiscounts[i] = Null<DiscountFactor>();
                } else {
                    results_.startDiscounts[i] = Null<DiscountFactor>();
                    results_.endDiscounts[i] = Null<DiscountFactor>();
                }

            } catch (std::exception &e) {
                QL_FAIL(io::ordinal(i+1) << " leg: " << e.what());
            }
            results_.value += results_.legNPV[i];
        }
    }

}
]]></document_content>
  </document>
  <document index="84">
    <source>swap/discretizedswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2007 StatPro Italia srl
 Copyright (C) 2022 Ralf Konrad Eckel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/swap/discretizedswap.hpp>
#include <ql/settings.hpp>
#include <utility>

namespace QuantLib {
    namespace {
        inline bool isResetTimeInPast(const Time& resetTime,
                                      const Time& payTime,
                                      const bool& includeTodaysCashFlows) {
            return (resetTime < 0.0) &&
                   ((payTime > 0.0) || (includeTodaysCashFlows && (payTime == 0.0)));
        }
    }

    DiscretizedSwap::DiscretizedSwap(const VanillaSwap::arguments& args,
                                     const Date& referenceDate,
                                     const DayCounter& dayCounter)
    : DiscretizedSwap(
          args,
          referenceDate,
          dayCounter,
          std::vector<CouponAdjustment>(args.fixedPayDates.size(), CouponAdjustment::pre),
          std::vector<CouponAdjustment>(args.floatingPayDates.size(), CouponAdjustment::pre)) {}

    DiscretizedSwap::DiscretizedSwap(const VanillaSwap::arguments& args,
                                     const Date& referenceDate,
                                     const DayCounter& dayCounter,
                                     std::vector<CouponAdjustment> fixedCouponAdjustments,
                                     std::vector<CouponAdjustment> floatingCouponAdjustments)
    : arguments_(args), fixedCouponAdjustments_(std::move(fixedCouponAdjustments)),
      floatingCouponAdjustments_(std::move(floatingCouponAdjustments)) {
        QL_REQUIRE(
            fixedCouponAdjustments_.size() == arguments_.fixedPayDates.size(),
            "The fixed coupon adjustments must have the same size as the number of fixed coupons.");
        QL_REQUIRE(floatingCouponAdjustments_.size() == arguments_.floatingPayDates.size(),
                   "The floating coupon adjustments must have the same size as the number of "
                   "floating coupons.");

        // NOLINTNEXTLINE(readability-implicit-bool-conversion)
        auto includeTodaysCashFlows = Settings::instance().includeTodaysCashFlows() &&
                                      *Settings::instance().includeTodaysCashFlows(); // NOLINT(bugprone-unchecked-optional-access)

        auto nrOfFixedCoupons = args.fixedResetDates.size();
        fixedResetTimes_.resize(nrOfFixedCoupons);
        fixedPayTimes_.resize(nrOfFixedCoupons);
        fixedResetTimeIsInPast_.resize(nrOfFixedCoupons);
        for (Size i = 0; i < nrOfFixedCoupons; ++i) {
            auto resetTime = dayCounter.yearFraction(referenceDate, args.fixedResetDates[i]);
            auto payTime = dayCounter.yearFraction(referenceDate, args.fixedPayDates[i]);
            auto resetIsInPast = isResetTimeInPast(resetTime, payTime, includeTodaysCashFlows);

            fixedResetTimes_[i] = resetTime;
            fixedPayTimes_[i] = payTime;
            fixedResetTimeIsInPast_[i] = resetIsInPast;
            if (resetIsInPast)
                fixedCouponAdjustments_[i] = CouponAdjustment::post;
        }

        auto nrOfFloatingCoupons = args.floatingResetDates.size();
        floatingResetTimes_.resize(nrOfFloatingCoupons);
        floatingPayTimes_.resize(nrOfFloatingCoupons);
        floatingResetTimeIsInPast_.resize(nrOfFloatingCoupons);
        for (Size i = 0; i < nrOfFloatingCoupons; ++i) {
            auto resetTime = dayCounter.yearFraction(referenceDate, args.floatingResetDates[i]);
            auto payTime = dayCounter.yearFraction(referenceDate, args.floatingPayDates[i]);
            auto resetIsInPast = isResetTimeInPast(resetTime, payTime, includeTodaysCashFlows);

            floatingResetTimes_[i] = resetTime;
            floatingPayTimes_[i] = payTime;
            floatingResetTimeIsInPast_[i] = resetIsInPast;
            if (resetIsInPast)
                floatingCouponAdjustments_[i] = CouponAdjustment::post;
        }
    }

    void DiscretizedSwap::reset(Size size) {
        values_ = Array(size, 0.0);
        adjustValues();
    }

    std::vector<Time> DiscretizedSwap::mandatoryTimes() const {
        std::vector<Time> times;
        for (Real t : fixedResetTimes_) {
            if (t >= 0.0)
                times.push_back(t);
        }
        for (Real t : fixedPayTimes_) {
            if (t >= 0.0)
                times.push_back(t);
        }
        for (Real t : floatingResetTimes_) {
            if (t >= 0.0)
                times.push_back(t);
        }
        for (Real t : floatingPayTimes_) {
            if (t >= 0.0)
                times.push_back(t);
        }
        return times;
    }

    void DiscretizedSwap::preAdjustValuesImpl() {
        // floating payments
        for (Size i = 0; i < floatingResetTimes_.size(); i++) {
            Time t = floatingResetTimes_[i];
            if (floatingCouponAdjustments_[i] == CouponAdjustment::pre && t >= 0.0 && isOnTime(t)) {
                addFloatingCoupon(i);
            }
        }
        // fixed payments
        for (Size i = 0; i < fixedResetTimes_.size(); i++) {
            Time t = fixedResetTimes_[i];
            if (fixedCouponAdjustments_[i] == CouponAdjustment::pre && t >= 0.0 && isOnTime(t)) {
                addFixedCoupon(i);
            }
        }
    }

    void DiscretizedSwap::postAdjustValuesImpl() {
        // floating payments
        for (Size i = 0; i < floatingResetTimes_.size(); i++) {
            Time t = floatingResetTimes_[i];
            if (floatingCouponAdjustments_[i] == CouponAdjustment::post && t >= 0.0 && isOnTime(t)) {
                addFloatingCoupon(i);
            }
        }
        // fixed payments
        for (Size i = 0; i < fixedResetTimes_.size(); i++) {
            Time t = fixedResetTimes_[i];
            if (fixedCouponAdjustments_[i] == CouponAdjustment::post && t >= 0.0 && isOnTime(t)) {
                addFixedCoupon(i);
            }
        }

        // fixed coupons whose reset time is in the past won't be managed
        // in preAdjustValues()
        for (Size i = 0; i < fixedPayTimes_.size(); i++) {
            Time t = fixedPayTimes_[i];
            if (fixedResetTimeIsInPast_[i] && isOnTime(t)) {
                Real fixedCoupon = arguments_.fixedCoupons[i];
                if (arguments_.type == Swap::Payer)
                    values_ -= fixedCoupon;
                else
                    values_ += fixedCoupon;
            }
        }

        // the same applies to floating payments whose rate is already fixed
        for (Size i = 0; i < floatingPayTimes_.size(); i++) {
            Time t = floatingPayTimes_[i];
            if (floatingResetTimeIsInPast_[i] && isOnTime(t)) {
                Real currentFloatingCoupon = arguments_.floatingCoupons[i];
                QL_REQUIRE(currentFloatingCoupon != Null<Real>(),
                           "current floating coupon not given");
                if (arguments_.type == Swap::Payer)
                    values_ += currentFloatingCoupon;
                else
                    values_ -= currentFloatingCoupon;
            }
        }
    }

    void DiscretizedSwap::addFixedCoupon(Size i) {
        DiscretizedDiscountBond bond;
        bond.initialize(method(), fixedPayTimes_[i]);
        bond.rollback(time_);

        Real fixedCoupon = arguments_.fixedCoupons[i];
        for (Size j = 0; j < values_.size(); j++) {
            Real coupon = fixedCoupon * bond.values()[j];
            if (arguments_.type == Swap::Payer)
                values_[j] -= coupon;
            else
                values_[j] += coupon;
        }
    }

    void DiscretizedSwap::addFloatingCoupon(Size i) {
        DiscretizedDiscountBond bond;
        bond.initialize(method(), floatingPayTimes_[i]);
        bond.rollback(time_);

        QL_REQUIRE(arguments_.nominal != Null<Real>(),
                   "non-constant nominals are not supported yet");

        Real nominal = arguments_.nominal;
        Time T = arguments_.floatingAccrualTimes[i];
        Spread spread = arguments_.floatingSpreads[i];
        Real accruedSpread = nominal * T * spread;
        for (Size j = 0; j < values_.size(); j++) {
            Real coupon = nominal * (1.0 - bond.values()[j]) + accruedSpread * bond.values()[j];
            if (arguments_.type == Swap::Payer)
                values_[j] += coupon;
            else
                values_[j] -= coupon;
        }
    }
}
]]></document_content>
  </document>
  <document index="85">
    <source>swap/treeswapengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2005, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/swap/discretizedswap.hpp>
#include <ql/pricingengines/swap/treeswapengine.hpp>
#include <utility>

namespace QuantLib {

    TreeVanillaSwapEngine::TreeVanillaSwapEngine(const ext::shared_ptr<ShortRateModel>& model,
                                                 Size timeSteps,
                                                 Handle<YieldTermStructure> termStructure)
    : LatticeShortRateModelEngine<VanillaSwap::arguments, VanillaSwap::results>(model, timeSteps),
      termStructure_(std::move(termStructure)) {
        registerWith(termStructure_);
    }

    TreeVanillaSwapEngine::TreeVanillaSwapEngine(const ext::shared_ptr<ShortRateModel>& model,
                                                 const TimeGrid& timeGrid,
                                                 Handle<YieldTermStructure> termStructure)
    : LatticeShortRateModelEngine<VanillaSwap::arguments, VanillaSwap::results>(model, timeGrid),
      termStructure_(std::move(termStructure)) {
        registerWith(termStructure_);
    }

    void TreeVanillaSwapEngine::calculate() const {

        QL_REQUIRE(!model_.empty(), "no model specified");

        Date referenceDate;
        DayCounter dayCounter;

        ext::shared_ptr<TermStructureConsistentModel> tsmodel =
            ext::dynamic_pointer_cast<TermStructureConsistentModel>(*model_);
        if (tsmodel != nullptr) {
            referenceDate = tsmodel->termStructure()->referenceDate();
            dayCounter = tsmodel->termStructure()->dayCounter();
        } else {
            referenceDate = termStructure_->referenceDate();
            dayCounter = termStructure_->dayCounter();
        }

        DiscretizedSwap swap(arguments_, referenceDate, dayCounter);
        std::vector<Time> times = swap.mandatoryTimes();

        ext::shared_ptr<Lattice> lattice;
        if (lattice_ != nullptr) {
            lattice = lattice_;
        } else {
            TimeGrid timeGrid(times.begin(), times.end(), timeSteps_);
            lattice = model_->tree(timeGrid);
        }

        Time maxTime = *std::max_element(times.begin(), times.end());
        swap.initialize(lattice, maxTime);
        swap.rollback(0.0);

        results_.value = swap.presentValue();
    }

}
]]></document_content>
  </document>
  <document index="86">
    <source>swaption/basketgeneratingengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/swaption/basketgeneratingengine.hpp>
#include <ql/rebatedexercise.hpp>
#include <ql/math/optimization/levenbergmarquardt.hpp>
#include <ql/math/optimization/simplex.hpp>
#include <ql/models/shortrate/calibrationhelpers/swaptionhelper.hpp>
#include <ql/termstructures/volatility/swaption/swaptionvolcube.hpp>
#include <ql/quotes/simplequote.hpp>
#include <cmath>

using std::exp;
using std::fabs;

namespace QuantLib {

    std::vector<ext::shared_ptr<BlackCalibrationHelper>>
    BasketGeneratingEngine::calibrationBasket(
        const ext::shared_ptr<Exercise>& exercise,
        const ext::shared_ptr<SwapIndex>& standardSwapBase,
        const ext::shared_ptr<SwaptionVolatilityStructure>& swaptionVolatility,
        const CalibrationBasketType basketType) const {

        QL_REQUIRE(
            !standardSwapBase->forwardingTermStructure().empty(),
            "standard swap base forwarding term structure must not be empty.");
        QL_REQUIRE(
            !standardSwapBase->exogenousDiscount() ||
                !standardSwapBase->discountingTermStructure().empty(),
            "standard swap base discounting term structure must not be empty.");

        std::vector<ext::shared_ptr<BlackCalibrationHelper> > result;

        Date today = Settings::instance().evaluationDate();
        Size minIdxAlive = static_cast<Size>(
            std::upper_bound(exercise->dates().begin(), exercise->dates().end(),
                             today) -
            exercise->dates().begin());

        ext::shared_ptr<RebatedExercise> rebEx =
            ext::dynamic_pointer_cast<RebatedExercise>(exercise);

        for (Size i = minIdxAlive; i < exercise->dates().size(); i++) {

            Date expiry = exercise->date(i);
            Real rebate = 0.0;
            Date rebateDate = expiry;
            if (rebEx != nullptr) {
                rebate = rebEx->rebate(i);
                rebateDate = rebEx->rebatePaymentDate(i);
            }

            ext::shared_ptr<SwaptionHelper> helper;

            switch (basketType) {

            case Naive: {
                Real swapLength = swaptionVolatility->dayCounter().yearFraction(
                    standardSwapBase->valueDate(expiry), underlyingLastDate());
                ext::shared_ptr<SmileSection> sec =
                    swaptionVolatility->smileSection(
                        expiry,
                        static_cast<Size>(std::lround(swapLength * 12.0)) * Months,
                        true);
                Real atmStrike = sec->atmLevel();
                Real atmVol;
                if (atmStrike == Null<Real>())
                    atmVol = sec->volatility(0.03);
                else
                    atmVol = sec->volatility(atmStrike);
                Real shift = sec->shift();

                helper = ext::make_shared<SwaptionHelper>(
                    expiry, underlyingLastDate(),
                    Handle<Quote>(ext::make_shared<SimpleQuote>(atmVol)),
                    standardSwapBase->iborIndex(),
                    standardSwapBase->fixedLegTenor(),
                    standardSwapBase->dayCounter(),
                    standardSwapBase->iborIndex()->dayCounter(),
                    standardSwapBase->exogenousDiscount()
                        ? standardSwapBase->discountingTermStructure()
                        : standardSwapBase->forwardingTermStructure(),
                    BlackCalibrationHelper::RelativePriceError, Null<Real>(), 1.0,
                    swaptionVolatility->volatilityType() ,shift);

                break;
            }

            case MaturityStrikeByDeltaGamma: {

                // determine the npv, first and second order derivatives at
                // $y=0$ of the underlying swap

                const Real h = 0.0001; // finite difference step in $y$, make
                                       // this a parameter of the engine ?
                Real zSpreadDsc =
                    oas_.empty() ? Real(1.0)
                                 : exp(-oas_->value() *
                                       onefactormodel_->termStructure()
                                           ->dayCounter()
                                           .yearFraction(expiry, rebateDate));

                Real npvm = underlyingNpv(expiry, -h) +
                            rebate *
                                onefactormodel_->zerobond(rebateDate, expiry,
                                                          -h, discountCurve_) *
                                zSpreadDsc;
                Real npv = underlyingNpv(expiry, 0.0) +
                           rebate * onefactormodel_->zerobond(
                                        rebateDate, expiry, 0, discountCurve_) *
                               zSpreadDsc;
                Real npvp = underlyingNpv(expiry, h) +
                            rebate *
                                onefactormodel_->zerobond(rebateDate, expiry, h,
                                                          discountCurve_) *
                                zSpreadDsc;

                Real delta = (npvp - npvm) / (2.0 * h);
                Real gamma = (npvp - 2.0 * npv + npvm) / (h * h);

                QL_REQUIRE(npv * npv + delta * delta + gamma * gamma > 0.0,
                           "(npv,delta,gamma) must have a positive norm");

                // debug output
                // std::cout << "EXOTIC npv " << npv << " delta " << delta
                //           << " gamma " << gamma << std::endl;
                // Real xtmp = -5.0;
                // std::cout
                //     << "********************************************EXERCISE "
                //     << expiry << " ******************" << std::endl;
                // std::cout << "globalExoticNpv;";
                // while (xtmp <= 5.0 + QL_EPSILON) {
                //     std::cout << underlyingNpv(expiry, xtmp) << ";";
                //     xtmp += 0.1;
                // }
                // std::cout << std::endl;
                // end debug output

                // play safe, we restrict the maximum maturity so to easily fit
                // in the date class restriction
                Real maxMaturity =
                    swaptionVolatility->dayCounter().yearFraction(
                        expiry, Date::maxDate() - 365);

                ext::shared_ptr<MatchHelper> matchHelper_;
                matchHelper_ = ext::make_shared<MatchHelper>(
                    underlyingType(), npv, delta, gamma, *onefactormodel_,
                    standardSwapBase, expiry, maxMaturity, h);

                // Optimize
                Array initial = initialGuess(expiry);
                QL_REQUIRE(initial.size() == 3,
                           "initial guess must have size 3 (but is "
                               << initial.size() << ")");

                EndCriteria ec(1000, 200, 1E-8, 1E-8, 1E-8); // make these
                                                             // criteria and the
                                                             // optimizer itself
                                                             // parameters of
                                                             // the method ?
                Constraint constraint = NoConstraint();
                Problem p(*matchHelper_, constraint, initial);
                LevenbergMarquardt lm;

                EndCriteria::Type ret = lm.minimize(p, ec);
                QL_REQUIRE(ret != EndCriteria::None &&
                               ret != EndCriteria::Unknown &&
                               ret != EndCriteria::MaxIterations,
                           "optimizer returns error (" << ret << ")");
                Array solution = p.currentValue();

                Real maturity = fabs(solution[1]);

                Size years = (Size)std::floor(maturity);
                maturity -= (Real)years;
                maturity *= 12.0;
                Size months = (Size)std::floor(maturity + 0.5);
                if (years == 0 && months == 0)
                    months = 1; // ensure a maturity of at least one months
                // maturity -= (Real)months; maturity *= 365.25;
                // Size days = (Size)std::floor(maturity);

                Period matPeriod =
                    years * Years + months * Months; //+days*Days;

                ext::shared_ptr<SmileSection> sec =
                    swaptionVolatility->smileSection(expiry, matPeriod, true);
                Real shift = sec->shift();

                // we have to floor the strike of the calibration instrument,
                // see warning in the header
                solution[2] = std::max(
                    solution[2], 0.00001 - shift); // floor at 0.1bp - shift

                // also the calibrated nominal may be zero, so we floor it, too
                solution[0] =
                    std::max(solution[0], 0.000001); // float at 0.01bp

                Real vol = sec->volatility(solution[2]);

                helper = ext::make_shared<SwaptionHelper>(
                    expiry, matPeriod,
                    Handle<Quote>(ext::make_shared<SimpleQuote>(
                                      vol)),
                    standardSwapBase->iborIndex(),
                    standardSwapBase->fixedLegTenor(),
                    standardSwapBase->dayCounter(),
                    standardSwapBase->iborIndex()->dayCounter(),
                    standardSwapBase->exogenousDiscount()
                        ? standardSwapBase->discountingTermStructure()
                        : standardSwapBase->forwardingTermStructure(),
                    BlackCalibrationHelper::RelativePriceError, solution[2],
                    fabs(solution[0]), swaptionVolatility->volatilityType(), shift);
                break;
            }

            default:
                QL_FAIL("Calibration basket type not known (" << basketType
                                                              << ")");
            }

            result.push_back(helper);
        }

        return result;
    }
}
]]></document_content>
  </document>
  <document index="87">
    <source>swaption/blackswaptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2008 Ferdinando Ametrano
 Copyright (C) 2006 Cristina Duminuco
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2006, 2007 StatPro Italia srl
 Copyright (C) 2015, 2016, 2017 Peter Caspers
 Copyright (C) 2017 Paul Giltinan
 Copyright (C) 2017 Werner Kuerzinger

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/swaption/blackswaptionengine.hpp>

namespace QuantLib {

    BlackSwaptionEngine::BlackSwaptionEngine(
                        const Handle<YieldTermStructure> &discountCurve,
                        Volatility vol, const DayCounter &dc,
                        Real displacement, CashAnnuityModel model)
    : detail::BlackStyleSwaptionEngine<detail::Black76Spec>(discountCurve, vol, dc,
                                                            displacement, model) {}

    BlackSwaptionEngine::BlackSwaptionEngine(
                        const Handle<YieldTermStructure> &discountCurve,
                        const Handle<Quote> &vol,
                        const DayCounter &dc,
                        Real displacement,
                        CashAnnuityModel model)
    : detail::BlackStyleSwaptionEngine<detail::Black76Spec>(discountCurve, vol, dc,
                                                            displacement, model) {}

    BlackSwaptionEngine::BlackSwaptionEngine(
                        const Handle<YieldTermStructure> &discountCurve,
                        const Handle<SwaptionVolatilityStructure> &vol,
                        CashAnnuityModel model)
    : detail::BlackStyleSwaptionEngine<detail::Black76Spec>(discountCurve, vol,
                                                            model) {
        QL_REQUIRE(vol->volatilityType() == ShiftedLognormal,
                   "BlackSwaptionEngine requires (shifted) lognormal input "
                   "volatility");
    }


    BachelierSwaptionEngine::BachelierSwaptionEngine(
        const Handle<YieldTermStructure> &discountCurve, Volatility vol,
        const DayCounter &dc, CashAnnuityModel model)
    : detail::BlackStyleSwaptionEngine<detail::BachelierSpec>(discountCurve, vol,
                                                              dc, model) {}

    BachelierSwaptionEngine::BachelierSwaptionEngine(
        const Handle<YieldTermStructure> &discountCurve,
        const Handle<Quote> &vol, const DayCounter &dc, CashAnnuityModel model)
    : detail::BlackStyleSwaptionEngine<detail::BachelierSpec>(discountCurve, vol,
                                                              dc, model) {}

    BachelierSwaptionEngine::BachelierSwaptionEngine(
        const Handle<YieldTermStructure> &discountCurve,
        const Handle<SwaptionVolatilityStructure> &vol, CashAnnuityModel model)
    : detail::BlackStyleSwaptionEngine<detail::BachelierSpec>(discountCurve, vol,
                                                              model) {
        QL_REQUIRE(vol->volatilityType() == Normal,
                   "BachelierSwaptionEngine requires normal input volatility");
    }

} // namespace QuantLib
]]></document_content>
  </document>
  <document index="88">
    <source>swaption/discretizedswaption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2007 StatPro Italia srl
 Copyright (C) 2021, 2022 Ralf Konrad Eckel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/pricingengines/swap/discretizedswap.hpp>
#include <ql/pricingengines/swaption/discretizedswaption.hpp>

namespace QuantLib {

    namespace {

        bool withinPreviousWeek(const Date& d1, const Date& d2) { return d2 >= d1 - 7 && d2 <= d1; }

        bool withinNextWeek(const Date& d1, const Date& d2) { return d2 >= d1 && d2 <= d1 + 7; }

        bool withinOneWeek(const Date& d1, const Date& d2) {
            return withinPreviousWeek(d1, d2) || withinNextWeek(d1, d2);
        }
    }

    DiscretizedSwaption::DiscretizedSwaption(const Swaption::arguments& args,
                                             const Date& referenceDate,
                                             const DayCounter& dayCounter)
    : DiscretizedOption(
          ext::shared_ptr<DiscretizedAsset>(), args.exercise->type(), std::vector<Time>()),
      arguments_(args) {

        // Date adjustments can get time vectors out of synch.
        // Here, we try and collapse similar dates which could cause
        // a mispricing.
        Swaption::arguments snappedArgs;
        std::vector<CouponAdjustment> fixedCouponAdjustments;
        std::vector<CouponAdjustment> floatingCouponAdjustments;

        prepareSwaptionWithSnappedDates(arguments_, referenceDate, dayCounter, snappedArgs,
                                        fixedCouponAdjustments, floatingCouponAdjustments);

        exerciseTimes_.resize(snappedArgs.exercise->dates().size());
        for (Size i = 0; i < exerciseTimes_.size(); ++i)
            exerciseTimes_[i] =
                dayCounter.yearFraction(referenceDate, snappedArgs.exercise->date(i));

        Time lastFixedPayment =
            dayCounter.yearFraction(referenceDate, snappedArgs.fixedPayDates.back());
        Time lastFloatingPayment =
            dayCounter.yearFraction(referenceDate, snappedArgs.floatingPayDates.back());
        lastPayment_ = std::max(lastFixedPayment, lastFloatingPayment);

        underlying_ =
            ext::make_shared<DiscretizedSwap>(snappedArgs, referenceDate, dayCounter,
                                              fixedCouponAdjustments, floatingCouponAdjustments);
    }

    void DiscretizedSwaption::reset(Size size) {
        underlying_->initialize(method(), lastPayment_);
        DiscretizedOption::reset(size);
    }

    void DiscretizedSwaption::prepareSwaptionWithSnappedDates(
        const Swaption::arguments& args,
        const Date& referenceDate,
        const DayCounter& dayCounter,
        PricingEngine::arguments& snappedArgs,
        std::vector<CouponAdjustment>& fixedCouponAdjustments,
        std::vector<CouponAdjustment>& floatingCouponAdjustments) {

        std::vector<Date> fixedDates = args.swap->fixedSchedule().dates();
        std::vector<Date> floatDates = args.swap->floatingSchedule().dates();

        fixedCouponAdjustments.resize(args.swap->fixedLeg().size(),
                                      CouponAdjustment::pre);
        floatingCouponAdjustments.resize(args.swap->floatingLeg().size(),
                                         CouponAdjustment::pre);

        for (const auto& exerciseDate : args.exercise->dates()) {
            for (Size j = 0; j < fixedDates.size() - 1; j++) {
                auto unadjustedDate = fixedDates[j];
                if (exerciseDate != unadjustedDate && withinOneWeek(exerciseDate, unadjustedDate)) {
                    fixedDates[j] = exerciseDate;
                    if (withinPreviousWeek(exerciseDate, unadjustedDate))
                        fixedCouponAdjustments[j] = CouponAdjustment::post;
                }
            }

            for (Size j = 0; j < floatDates.size() - 1; j++) {
                auto unadjustedDate = floatDates[j];
                if (exerciseDate != unadjustedDate && withinOneWeek(exerciseDate, unadjustedDate)) {
                    floatDates[j] = exerciseDate;
                    if (withinPreviousWeek(exerciseDate, unadjustedDate))
                        floatingCouponAdjustments[j] = CouponAdjustment::post;
                }
            }
        }

        Schedule snappedFixedSchedule(fixedDates);
        Schedule snappedFloatSchedule(floatDates);

        auto snappedSwap = ext::make_shared<VanillaSwap>(
            args.swap->type(), args.swap->nominal(), snappedFixedSchedule, args.swap->fixedRate(),
            args.swap->fixedDayCount(), snappedFloatSchedule, args.swap->iborIndex(),
            args.swap->spread(), args.swap->floatingDayCount(), args.swap->paymentConvention());

        Swaption snappedSwaption(snappedSwap, args.exercise, args.settlementType,
                                 args.settlementMethod);

        snappedSwaption.setupArguments(&snappedArgs);
    }
}
]]></document_content>
  </document>
  <document index="89">
    <source>swaption/fdg2swaptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/processes/ornsteinuhlenbeckprocess.hpp>
#include <ql/pricingengines/swaption/fdg2swaptionengine.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/meshers/fdmsimpleprocess1dmesher.hpp>
#include <ql/methods/finitedifferences/solvers/fdmg2solver.hpp>
#include <ql/methods/finitedifferences/utilities/fdmaffinemodelswapinnervalue.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>

namespace QuantLib {

    FdG2SwaptionEngine::FdG2SwaptionEngine(
        const ext::shared_ptr<G2>& model,
        Size tGrid, Size xGrid, Size yGrid,
        Size dampingSteps, Real invEps,
        const FdmSchemeDesc& schemeDesc)
    : GenericModelEngine<G2, Swaption::arguments, Swaption::results>(model),
      tGrid_(tGrid),
      xGrid_(xGrid),
      yGrid_(yGrid),
      dampingSteps_(dampingSteps),
      invEps_(invEps),
      schemeDesc_(schemeDesc) {
    }

    void FdG2SwaptionEngine::calculate() const {
        QL_REQUIRE(!model_.empty(), "no model specified");

        // 1. Term structure
        const Handle<YieldTermStructure> ts = model_->termStructure();

        // 2. Mesher
        const DayCounter dc = ts->dayCounter();
        const Date referenceDate = ts->referenceDate();
        const Time maturity = dc.yearFraction(referenceDate,
                                              arguments_.exercise->lastDate());

        const ext::shared_ptr<OrnsteinUhlenbeckProcess> process1(
            new OrnsteinUhlenbeckProcess(model_->a(), model_->sigma()));

        const ext::shared_ptr<OrnsteinUhlenbeckProcess> process2(
            new OrnsteinUhlenbeckProcess(model_->b(), model_->eta()));

        const ext::shared_ptr<Fdm1dMesher> xMesher(
            new FdmSimpleProcess1dMesher(xGrid_,process1,maturity,1,invEps_));

        const ext::shared_ptr<Fdm1dMesher> yMesher(
            new FdmSimpleProcess1dMesher(yGrid_,process2,maturity,1,invEps_));

        const ext::shared_ptr<FdmMesher> mesher(
            new FdmMesherComposite(xMesher, yMesher));

        // 3. Inner Value Calculator
        const std::vector<Date>& exerciseDates = arguments_.exercise->dates();
        std::map<Time, Date> t2d;

        for (auto exerciseDate : exerciseDates) {
            const Time t = dc.yearFraction(referenceDate, exerciseDate);
            QL_REQUIRE(t >= 0, "exercise dates must not contain past date");

            t2d[t] = exerciseDate;
        }

        const Handle<YieldTermStructure> disTs = model_->termStructure();
        const Handle<YieldTermStructure> fwdTs
            = arguments_.swap->iborIndex()->forwardingTermStructure();

        QL_REQUIRE(fwdTs->dayCounter() == disTs->dayCounter(),
                "day counter of forward and discount curve must match");
        QL_REQUIRE(fwdTs->referenceDate() == disTs->referenceDate(),
                "reference date of forward and discount curve must match");

        const ext::shared_ptr<G2> fwdModel(
            new G2(fwdTs, model_->a(), model_->sigma(),
                   model_->b(), model_->eta(), model_->rho()));

        const ext::shared_ptr<FdmInnerValueCalculator> calculator(
             new FdmAffineModelSwapInnerValue<G2>(
                 model_.currentLink(), fwdModel,
                 arguments_.swap, t2d, mesher, 0));

        // 4. Step conditions
        const ext::shared_ptr<FdmStepConditionComposite> conditions =
             FdmStepConditionComposite::vanillaComposite(
                 DividendSchedule(), arguments_.exercise,
                 mesher, calculator, referenceDate, dc);

        // 5. Boundary conditions
        const FdmBoundaryConditionSet boundaries;

        // 6. Solver
        FdmSolverDesc solverDesc = { mesher, boundaries, conditions,
                                     calculator, maturity,
                                     tGrid_, dampingSteps_ };

        FdmG2Solver solver(model_, solverDesc, schemeDesc_);

        results_.value = solver.valueAt(0.0, 0.0);
    }
}
]]></document_content>
  </document>
  <document index="90">
    <source>swaption/fdhullwhiteswaptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/processes/ornsteinuhlenbeckprocess.hpp>
#include <ql/pricingengines/swaption/fdhullwhiteswaptionengine.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/meshers/fdmsimpleprocess1dmesher.hpp>
#include <ql/methods/finitedifferences/solvers/fdmhullwhitesolver.hpp>
#include <ql/methods/finitedifferences/utilities/fdmaffinemodelswapinnervalue.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>

namespace QuantLib {

    FdHullWhiteSwaptionEngine::FdHullWhiteSwaptionEngine(
        const ext::shared_ptr<HullWhite>& model,
        Size tGrid, Size xGrid, 
        Size dampingSteps, Real invEps,
        const FdmSchemeDesc& schemeDesc)
    : GenericModelEngine<HullWhite, 
                         Swaption::arguments, Swaption::results>(model),
      tGrid_(tGrid),
      xGrid_(xGrid),
      dampingSteps_(dampingSteps),
      invEps_(invEps),
      schemeDesc_(schemeDesc) {
    }

    void FdHullWhiteSwaptionEngine::calculate() const {
        QL_REQUIRE(!model_.empty(), "no model specified");

        // 1. Term structure
        const Handle<YieldTermStructure> ts = model_->termStructure();

        // 2. Mesher
        const DayCounter dc = ts->dayCounter();
        const Date referenceDate = ts->referenceDate();
        const Time maturity = dc.yearFraction(referenceDate,
                                              arguments_.exercise->lastDate());

        auto process = ext::make_shared<OrnsteinUhlenbeckProcess>(model_->a(), model_->sigma());
        auto shortRateMesher = ext::make_shared<FdmSimpleProcess1dMesher>(xGrid_, process, maturity, 1, invEps_);
        auto mesher = ext::make_shared<FdmMesherComposite>(shortRateMesher);

        // 3. Inner Value Calculator
        const std::vector<Date>& exerciseDates = arguments_.exercise->dates();
        std::map<Time, Date> t2d;

        for (auto exerciseDate : exerciseDates) {
            const Time t = dc.yearFraction(referenceDate, exerciseDate);
            QL_REQUIRE(t >= 0, "exercise dates must not contain past date");

            t2d[t] = exerciseDate;
        }

        const Handle<YieldTermStructure> disTs = model_->termStructure();
        const Handle<YieldTermStructure> fwdTs
            = arguments_.swap->iborIndex()->forwardingTermStructure();

        QL_REQUIRE(fwdTs->dayCounter() == disTs->dayCounter(),
                   "day counter of forward and discount curve must match");
        QL_REQUIRE(fwdTs->referenceDate() == disTs->referenceDate(),
                   "reference date of forward and discount curve must match");

        auto fwdModel = ext::make_shared<HullWhite>(fwdTs, model_->a(), model_->sigma());
        auto calculator = ext::make_shared<FdmAffineModelSwapInnerValue<HullWhite>>(
                 model_.currentLink(), fwdModel,
                 arguments_.swap, t2d, mesher, 0);

        // 4. Step conditions
        auto conditions =
             FdmStepConditionComposite::vanillaComposite(
                 DividendSchedule(), arguments_.exercise,
                 mesher, calculator, referenceDate, dc);

        // 5. Boundary conditions
        const FdmBoundaryConditionSet boundaries;

        // 6. Solver
        FdmSolverDesc solverDesc = { mesher, boundaries, conditions,
                                     calculator, maturity,
                                     tGrid_, dampingSteps_ };

        FdmHullWhiteSolver solver(model_, solverDesc, schemeDesc_);

        results_.value = solver.valueAt(0.0);
    }
}
]]></document_content>
  </document>
  <document index="91">
    <source>swaption/gaussian1dfloatfloatswaptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/swaption/gaussian1dfloatfloatswaptionengine.hpp>
#include <ql/experimental/coupons/swapspreadindex.hpp> // internal
#include <ql/math/interpolations/cubicinterpolation.hpp>
#include <ql/payoff.hpp>

namespace QuantLib {

    void Gaussian1dFloatFloatSwaptionEngine::calculate() const {

        QL_REQUIRE(arguments_.settlementMethod != Settlement::ParYieldCurve,
                   "cash settled (ParYieldCurve) swaptions not priced with "
                   "Gaussian1dFloatFloatSwaptionEngine");

        Date settlement = model_->termStructure()->referenceDate();

        if (arguments_.exercise->dates().back() <=
            settlement) { // swaption is expired,
                          // possibly generated swap
                          // is not
                          // valued
            results_.value = 0.0;
            return;
        }

        rebatedExercise_ =
            ext::dynamic_pointer_cast<RebatedExercise>(arguments_.exercise);

        std::pair<Real, Real> result =
            npvs(settlement, 0.0, includeTodaysExercise_, true);

        results_.value = result.first;
        results_.additionalResults["underlyingValue"] = result.second;
    }

    Real
    Gaussian1dFloatFloatSwaptionEngine::underlyingNpv(const Date &expiry,
                                                      const Real y) const {
        return npvs(expiry, y, true).second;
    }

    Swap::Type Gaussian1dFloatFloatSwaptionEngine::underlyingType() const {
        return arguments_.swap->type();
    }

    // NOLINTNEXTLINE(readability-const-return-type)
    const Date Gaussian1dFloatFloatSwaptionEngine::underlyingLastDate() const {
        Date l1 = arguments_.leg1PayDates.back();
        Date l2 = arguments_.leg2PayDates.back();
        return l2 >= l1 ? l2 : l1;
    }

    // NOLINTNEXTLINE(readability-const-return-type)
    const Array Gaussian1dFloatFloatSwaptionEngine::initialGuess(const Date &expiry) const {

        Size idx1 =
            std::upper_bound(arguments_.leg1ResetDates.begin(),
                             arguments_.leg1ResetDates.end(), expiry - 1) -
            arguments_.leg1ResetDates.begin();

        // very simple initial guess
        // check guess for nominal and weighted maturity !

        Real nominalSum1 = 0.0;
        for (Size i = idx1; i < arguments_.leg1ResetDates.size(); i++) {
            nominalSum1 += arguments_.nominal1[i];
        }
        Real nominalAvg1 = nominalSum1 /
            (arguments_.leg1ResetDates.size() - idx1);
        Real weightedMaturity1 = 0.0;
        for (Size i = idx1; i < arguments_.leg1ResetDates.size(); i++) {
            weightedMaturity1 +=
                arguments_.leg1AccrualTimes[i] * arguments_.nominal1[i];
        }
        weightedMaturity1 /= nominalAvg1;

        return {
            nominalAvg1,
            weightedMaturity1,
            0.03 // ???
        };
    }

    // calculate npv and underlying npv as of expiry date
    std::pair<Real, Real>
    Gaussian1dFloatFloatSwaptionEngine::npvs(const Date& expiry,
                                             const Real y,
                                             const bool includeExerciseOnExpiry,
                                             const bool considerProbabilities) const {

        // pricing

        // event dates are coupon fixing dates and exercise dates
        // we explicitly estimate cms and also libor coupons (although
        // the latter could be calculated analytically) to make the code
        // simpler

        std::vector<Date> events;
        events.insert(events.end(), arguments_.exercise->dates().begin(),
                      arguments_.exercise->dates().end());
        events.insert(events.end(), arguments_.leg1FixingDates.begin(),
                      arguments_.leg1FixingDates.end());
        events.insert(events.end(), arguments_.leg2FixingDates.begin(),
                      arguments_.leg2FixingDates.end());
        std::sort(events.begin(), events.end());

        auto it = std::unique(events.begin(), events.end());
        events.resize(std::distance(events.begin(), it));

        // only events on or after expiry are of interest by definition of the
        // deal part that is exericsed into.

        auto filit = std::upper_bound(events.begin(), events.end(),
                                      expiry - (includeExerciseOnExpiry ? 1 : 0));
        events.erase(events.begin(), filit);

        int idx = events.size() - 1;

        FloatFloatSwap swap = *arguments_.swap;
        Option::Type type =
            arguments_.type == Swap::Payer ? Option::Call : Option::Put;

        Array npv0(2 * integrationPoints_ + 1, 0.0),
            npv1(2 * integrationPoints_ + 1, 0.0); // arrays for npvs of the
                                                   // option
        Array npv0a(2 * integrationPoints_ + 1, 0.0),
            npv1a(2 * integrationPoints_ + 1, 0.0); // arrays for npvs of the
                                                    // underlying
        Array z = model_->yGrid(stddevs_, integrationPoints_);
        Array p(z.size(), 0.0), pa(z.size(), 0.0);

        // for probability computation
        std::vector<Array> npvp0, npvp1;
        // how many active exercise dates are there ?
        Size noEx =  arguments_.exercise->dates().size() -
            (std::upper_bound(arguments_.exercise->dates().begin(),
                         arguments_.exercise->dates().end(),
                         expiry - (includeExerciseOnExpiry ? 1 : 0)) -
             arguments_.exercise->dates().begin());
        Size exIdx = noEx; // current exercise index
        if (considerProbabilities && probabilities_ != None) {
            for (Size i = 0; i < noEx+1 ; ++i) {
                Array npvTmp0(2 * integrationPoints_ + 1, 0.0);
                Array npvTmp1(2 * integrationPoints_ + 1, 0.0);
                npvp0.push_back(npvTmp0);
                npvp1.push_back(npvTmp1);
            }
        }
        // end probability computation

        Date event1 = Date(), event0;
        Time event1Time = Null<Real>(), event0Time;

        ext::shared_ptr<IborIndex> ibor1 =
            ext::dynamic_pointer_cast<IborIndex>(arguments_.index1);
        ext::shared_ptr<SwapIndex> cms1 =
            ext::dynamic_pointer_cast<SwapIndex>(arguments_.index1);
        ext::shared_ptr<SwapSpreadIndex> cmsspread1 =
            ext::dynamic_pointer_cast<SwapSpreadIndex>(arguments_.index1);
        ext::shared_ptr<IborIndex> ibor2 =
            ext::dynamic_pointer_cast<IborIndex>(arguments_.index2);
        ext::shared_ptr<SwapIndex> cms2 =
            ext::dynamic_pointer_cast<SwapIndex>(arguments_.index2);
        ext::shared_ptr<SwapSpreadIndex> cmsspread2 =
            ext::dynamic_pointer_cast<SwapSpreadIndex>(arguments_.index2);

        QL_REQUIRE(ibor1 != nullptr || cms1 != nullptr || cmsspread1 != nullptr,
                   "index1 must be ibor or swap or swap spread index");
        QL_REQUIRE(ibor2 != nullptr || cms2 != nullptr || cmsspread2 != nullptr,
                   "index2 must be ibor or swap or swap spread index");

        do {

            // we are at event0 date, which can be a structured coupon fixing
            // date or an exercise date or both.

            bool isEventDate = true;
            if (idx == -1) {
                event0 = expiry;
                isEventDate = false;
            } else {
                event0 = events[idx];
                if (event0 == expiry)
                    idx = -1; // avoid double roll back if expiry equal to
                              // earliest event date
            }

            bool isExercise =
                std::find(arguments_.exercise->dates().begin(), arguments_.exercise->dates().end(),
                          event0) != arguments_.exercise->dates().end();

            bool isLeg1Fixing =
                std::find(arguments_.leg1FixingDates.begin(), arguments_.leg1FixingDates.end(),
                          event0) != arguments_.leg1FixingDates.end();

            bool isLeg2Fixing =
                std::find(arguments_.leg2FixingDates.begin(), arguments_.leg2FixingDates.end(),
                          event0) != arguments_.leg2FixingDates.end();

            event0Time = std::max(
                model_->termStructure()->timeFromReference(event0), 0.0);

            // todo add openmp support later on (as in gaussian1dswaptionengine)

            for (Size k = 0; k < (event0 > expiry ? npv0.size() : 1); k++) {

                // roll back

                Real price = 0.0, pricea = 0.0;
                if (event1Time != Null<Real>()) {
                    Real zSpreadDf = oas_.empty()
                                         ? Real(1.0)
                                         : std::exp(-oas_->value() *
                                                    (event1Time - event0Time));
                    Array yg =
                        model_->yGrid(stddevs_, integrationPoints_, event1Time,
                                      event0Time, event0 > expiry ? z[k] : y);
                    CubicInterpolation payoff0(
                        z.begin(), z.end(), npv1.begin(),
                        CubicInterpolation::Spline, true,
                        CubicInterpolation::Lagrange, 0.0,
                        CubicInterpolation::Lagrange, 0.0);
                    CubicInterpolation payoff0a(
                        z.begin(), z.end(), npv1a.begin(),
                        CubicInterpolation::Spline, true,
                        CubicInterpolation::Lagrange, 0.0,
                        CubicInterpolation::Lagrange, 0.0);
                    for (Size i = 0; i < yg.size(); i++) {
                        p[i] = payoff0(yg[i], true);
                        pa[i] = payoff0a(yg[i], true);
                    }
                    CubicInterpolation payoff1(
                        z.begin(), z.end(), p.begin(),
                        CubicInterpolation::Spline, true,
                        CubicInterpolation::Lagrange, 0.0,
                        CubicInterpolation::Lagrange, 0.0);
                    CubicInterpolation payoff1a(
                        z.begin(), z.end(), pa.begin(),
                        CubicInterpolation::Spline, true,
                        CubicInterpolation::Lagrange, 0.0,
                        CubicInterpolation::Lagrange, 0.0);
                    for (Size i = 0; i < z.size() - 1; i++) {
                        price += Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                     0.0, payoff1.cCoefficients()[i],
                                     payoff1.bCoefficients()[i],
                                     payoff1.aCoefficients()[i], p[i], z[i],
                                     z[i], z[i + 1]) *
                                 zSpreadDf;
                        pricea += Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                      0.0, payoff1a.cCoefficients()[i],
                                      payoff1a.bCoefficients()[i],
                                      payoff1a.aCoefficients()[i], pa[i], z[i],
                                      z[i], z[i + 1]) *
                                  zSpreadDf;
                    }
                    if (extrapolatePayoff_) {
                        if (flatPayoffExtrapolation_) {
                            price +=
                                Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                    0.0, 0.0, 0.0, 0.0, p[z.size() - 2],
                                    z[z.size() - 2], z[z.size() - 1], 100.0) *
                                zSpreadDf;
                            price += Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                         0.0, 0.0, 0.0, 0.0, p[0], z[0], -100.0,
                                         z[0]) *
                                     zSpreadDf;
                            pricea +=
                                Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                    0.0, 0.0, 0.0, 0.0, pa[z.size() - 2],
                                    z[z.size() - 2], z[z.size() - 1], 100.0) *
                                zSpreadDf;
                            pricea += Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                          0.0, 0.0, 0.0, 0.0, pa[0], z[0],
                                          -100.0, z[0]) *
                                      zSpreadDf;
                        } else {
                            if (type == Option::Call)
                                price +=
                                    Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                        0.0,
                                        payoff1.cCoefficients()[z.size() - 2],
                                        payoff1.bCoefficients()[z.size() - 2],
                                        payoff1.aCoefficients()[z.size() - 2],
                                        p[z.size() - 2], z[z.size() - 2],
                                        z[z.size() - 1], 100.0) *
                                    zSpreadDf;
                            if (type == Option::Put)
                                price +=
                                    Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                        0.0, payoff1.cCoefficients()[0],
                                        payoff1.bCoefficients()[0],
                                        payoff1.aCoefficients()[0], p[0], z[0],
                                        -100.0, z[0]) *
                                    zSpreadDf;
                            if (type == Option::Call)
                                pricea +=
                                    Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                        0.0,
                                        payoff1a.cCoefficients()[z.size() - 2],
                                        payoff1a.bCoefficients()[z.size() - 2],
                                        payoff1a.aCoefficients()[z.size() - 2],
                                        pa[z.size() - 2], z[z.size() - 2],
                                        z[z.size() - 1], 100.0) *
                                    zSpreadDf;
                            if (type == Option::Put)
                                pricea +=
                                    Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                        0.0, payoff1a.cCoefficients()[0],
                                        payoff1a.bCoefficients()[0],
                                        payoff1a.aCoefficients()[0], pa[0],
                                        z[0], -100.0, z[0]) *
                                    zSpreadDf;
                        }
                    }
                }

                npv0[k] = price;
                npv0a[k] = pricea;

                // for probability computation
                if (considerProbabilities && probabilities_ != None) {
                    for (Size m = 0; m < npvp0.size(); m++) {
                        Real price = 0.0;
                        if (event1Time != Null<Real>()) {
                            Real zSpreadDf =
                                oas_.empty()
                                    ? Real(1.0)
                                    : std::exp(-oas_->value() *
                                               (event1Time - event0Time));
                            Array yg = model_->yGrid(
                                stddevs_, integrationPoints_, event1Time,
                                event0Time, event0 > expiry ? z[k] : 0.0);
                            CubicInterpolation payoff0(
                                z.begin(), z.end(), npvp1[m].begin(),
                                CubicInterpolation::Spline, true,
                                CubicInterpolation::Lagrange, 0.0,
                                CubicInterpolation::Lagrange, 0.0);
                            for (Size i = 0; i < yg.size(); i++) {
                                p[i] = payoff0(yg[i], true);
                            }
                            CubicInterpolation payoff1(
                                z.begin(), z.end(), p.begin(),
                                CubicInterpolation::Spline, true,
                                CubicInterpolation::Lagrange, 0.0,
                                CubicInterpolation::Lagrange, 0.0);
                            for (Size i = 0; i < z.size() - 1; i++) {
                                price +=
                                    Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                        0.0, payoff1.cCoefficients()[i],
                                        payoff1.bCoefficients()[i],
                                        payoff1.aCoefficients()[i], p[i], z[i],
                                        z[i], z[i + 1]) *
                                    zSpreadDf;
                            }
                            if (extrapolatePayoff_) {
                                if (flatPayoffExtrapolation_) {
                                    price +=
                                        Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                                  0.0, 0.0, 0.0, 0.0,
                                                  p[z.size() - 2],
                                                  z[z.size() - 2],
                                                  z[z.size() - 1], 100.0) *
                                        zSpreadDf;
                                    price +=
                                        Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                                  0.0, 0.0, 0.0, 0.0, p[0],
                                                  z[0], -100.0, z[0]) *
                                        zSpreadDf;
                                } else {
                                    if (type == Option::Call)
                                        price +=
                                            Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                                      0.0,
                                                      payoff1.cCoefficients()
                                                          [z.size() - 2],
                                                      payoff1.bCoefficients()
                                                          [z.size() - 2],
                                                      payoff1.aCoefficients()
                                                          [z.size() - 2],
                                                      p[z.size() - 2],
                                                      z[z.size() - 2],
                                                      z[z.size() - 1], 100.0) *
                                            zSpreadDf;
                                    if (type == Option::Put)
                                        price +=
                                            Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                                      0.0,
                                                      payoff1
                                                          .cCoefficients()[0],
                                                      payoff1
                                                          .bCoefficients()[0],
                                                      payoff1
                                                          .aCoefficients()[0],
                                                      p[0], z[0], -100.0,
                                                      z[0]) *
                                            zSpreadDf;
                                }
                            }
                        }

                        npvp0[m][k] = price;
                    }
                }
                // end probability computation

                // event date calculations

                if (isEventDate) {

                    Real zk = event0 > expiry ? z[k] : y;

                    if (isLeg1Fixing) { // if event is a fixing date and
                                        // exercise date,
                        // the coupon is part of the exercise into right (by
                        // definition)
                        Size j = std::find(arguments_.leg1FixingDates.begin(),
                                           arguments_.leg1FixingDates.end(),
                                           event0) -
                                 arguments_.leg1FixingDates.begin();
                        Real zSpreadDf =
                            oas_.empty()
                                ? Real(1.0)
                                : std::exp(
                                      -oas_->value() *
                                      (model_->termStructure()
                                           ->dayCounter()
                                           .yearFraction(
                                                event0,
                                                arguments_.leg1PayDates[j])));
                        bool done = false;
                        do {
                            Real amount;
                            if (arguments_.leg1IsRedemptionFlow[j]) {
                                amount = arguments_.leg1Coupons[j];
                            } else {
                                Real estFixing = 0.0;
                                if (ibor1 != nullptr) {
                                    estFixing = model_->forwardRate(
                                        arguments_.leg1FixingDates[j], event0,
                                        zk, ibor1);
                                }
                                if (cms1 != nullptr) {
                                    estFixing = model_->swapRate(
                                        arguments_.leg1FixingDates[j],
                                        cms1->tenor(), event0, zk, cms1);
                                }
                                if (cmsspread1 != nullptr)
                                    estFixing =
                                        cmsspread1->gearing1() *
                                            model_->swapRate(
                                                arguments_.leg1FixingDates[j],
                                                cmsspread1->swapIndex1()
                                                    ->tenor(),
                                                event0, zk,
                                                cmsspread1->swapIndex1()) +
                                        cmsspread1->gearing2() *
                                            model_->swapRate(
                                                arguments_.leg1FixingDates[j],
                                                cmsspread1->swapIndex2()
                                                    ->tenor(),
                                                event0, zk,
                                                cmsspread1->swapIndex2());
                                Real rate =
                                    arguments_.leg1Spreads[j] +
                                    arguments_.leg1Gearings[j] * estFixing;
                                if (arguments_.leg1CappedRates[j] !=
                                    Null<Real>())
                                    rate = std::min(
                                        arguments_.leg1CappedRates[j], rate);
                                if (arguments_.leg1FlooredRates[j] !=
                                    Null<Real>())
                                    rate = std::max(
                                        arguments_.leg1FlooredRates[j], rate);
                                amount = rate * arguments_.nominal1[j] *
                                         arguments_.leg1AccrualTimes[j];
                            }

                            npv0a[k] -=
                                amount *
                                model_->zerobond(arguments_.leg1PayDates[j],
                                                 event0, zk, discountCurve_) /
                                model_->numeraire(event0Time, zk,
                                                  discountCurve_) *
                                zSpreadDf;

                            if (j < arguments_.leg1FixingDates.size() - 1) {
                                j++;
                                done =
                                    (event0 != arguments_.leg1FixingDates[j]);
                            } else
                                done = true;

                        } while (!done);
                    }

                    if (isLeg2Fixing) { // if event is a fixing date and
                                        // exercise date,
                        // the coupon is part of the exercise into right (by
                        // definition)
                        Size j = std::find(arguments_.leg2FixingDates.begin(),
                                           arguments_.leg2FixingDates.end(),
                                           event0) -
                                 arguments_.leg2FixingDates.begin();
                        Real zSpreadDf =
                            oas_.empty()
                                ? Real(1.0)
                                : std::exp(
                                      -oas_->value() *
                                      (model_->termStructure()
                                           ->dayCounter()
                                           .yearFraction(
                                                event0,
                                                arguments_.leg2PayDates[j])));
                        bool done;
                        do {
                            Real amount;
                            if (arguments_.leg2IsRedemptionFlow[j]) {
                                amount = arguments_.leg2Coupons[j];
                            } else {
                                Real estFixing = 0.0;
                                if (ibor2 != nullptr)
                                    estFixing = model_->forwardRate(arguments_.leg2FixingDates[j],event0,zk,ibor2);
                                if (cms2 != nullptr)
                                    estFixing = model_->swapRate(arguments_.leg2FixingDates[j],cms2->tenor(),event0,zk,cms2);
                                if (cmsspread2 != nullptr)
                                    estFixing =
                                        cmsspread2->gearing1() *
                                            model_->swapRate(
                                                arguments_.leg2FixingDates[j],
                                                cmsspread2->swapIndex1()
                                                    ->tenor(),
                                                event0, zk,
                                                cmsspread2->swapIndex1()) +
                                        cmsspread2->gearing2() *
                                            model_->swapRate(
                                                arguments_.leg2FixingDates[j],
                                                cmsspread2->swapIndex2()
                                                    ->tenor(),
                                                event0, zk,
                                                cmsspread2->swapIndex2());
                                Real rate =
                                    arguments_.leg2Spreads[j] +
                                    arguments_.leg2Gearings[j] * estFixing;
                                if (arguments_.leg2CappedRates[j] !=
                                    Null<Real>())
                                    rate = std::min(
                                        arguments_.leg2CappedRates[j], rate);
                                if (arguments_.leg2FlooredRates[j] !=
                                    Null<Real>())
                                    rate = std::max(
                                        arguments_.leg2FlooredRates[j], rate);
                                amount = rate * arguments_.nominal2[j] *
                                         arguments_.leg2AccrualTimes[j];
                            }

                            npv0a[k] +=
                                amount *
                                model_->zerobond(arguments_.leg2PayDates[j],
                                                 event0, zk, discountCurve_) /
                                model_->numeraire(event0Time, zk,
                                                  discountCurve_) *
                                zSpreadDf;
                            if (j < arguments_.leg2FixingDates.size() - 1) {
                                j++;
                                done =
                                    (event0 != arguments_.leg2FixingDates[j]);
                            } else
                                done = true;

                        } while (!done);
                    }

                    if (isExercise) {
                        Size j = std::find(arguments_.exercise->dates().begin(),
                                           arguments_.exercise->dates().end(),
                                           event0) -
                                 arguments_.exercise->dates().begin();
                        Real rebate = 0.0;
                        Real zSpreadDf = 1.0;
                        Date rebateDate = event0;
                        if (rebatedExercise_ != nullptr) {
                            rebate = rebatedExercise_->rebate(j);
                            rebateDate = rebatedExercise_->rebatePaymentDate(j);
                            zSpreadDf =
                                oas_.empty()
                                    ? Real(1.0)
                                    : std::exp(-oas_->value() *
                                               (model_->termStructure()
                                                    ->dayCounter()
                                                    .yearFraction(event0,
                                                                  rebateDate)));
                        }
                        Real exerciseValue =
                            (type == Option::Call ? 1.0 : -1.0) * npv0a[k] +
                            rebate * model_->zerobond(rebateDate, event0) *
                                zSpreadDf / model_->numeraire(event0Time, zk,
                                                              discountCurve_);

                        if (considerProbabilities && probabilities_ != None) {
                            if (exIdx == noEx) {
                                // if true we are at the latest date,
                                // so we init
                                // the no call probability
                                npvp0.back()[k] =
                                    probabilities_ == Naive
                                        ? Real(1.0)
                                        : 1.0 / (model_->zerobond(
                                                     event0Time, 0.0, 0.0,
                                                     discountCurve_) *
                                                 model_->numeraire(
                                                     event0, z[k],
                                                     discountCurve_));
                            }
                            if (exerciseValue >= npv0[k]) {
                                npvp0[exIdx-1][k] =
                                    probabilities_ == Naive
                                        ? Real(1.0)
                                        : 1.0 / (model_->zerobond(
                                                     event0Time, 0.0, 0.0,
                                                     discountCurve_) *
                                                 model_->numeraire(
                                                     event0Time, z[k],
                                                     discountCurve_));
                                for (Size ii = exIdx; ii < noEx+1; ++ii)
                                    npvp0[ii][k] = 0.0;
                            }
                        }
                        // end probability computation

                        npv0[k] = std::max(npv0[k], exerciseValue);
                    }
                }
            }

            if(isExercise)
                --exIdx;

            npv1.swap(npv0);
            npv1a.swap(npv0a);

            // for probability computation
            if(considerProbabilities && probabilities_ != None) {
                for(Size i=0;i<npvp0.size();++i) {
                    npvp1[i].swap(npvp0[i]);
                }
            }
            // end probability computation

            event1 = event0;
            event1Time = event0Time;

        } while (--idx >= -1);

        std::pair<Real, Real> res(
            npv1[0] * model_->numeraire(event1Time, y, discountCurve_),
            npv1a[0] * model_->numeraire(event1Time, y, discountCurve_) *
                (type == Option::Call ? 1.0 : -1.0));

        // for probability computation
        if (considerProbabilities && probabilities_ != None) {
            std::vector<Real> prob(noEx+1);
            for (Size i = 0; i < noEx+1; i++) {
                prob[i] = npvp1[i][0] *
                          (probabilities_ == Naive
                               ? 1.0
                               : model_->numeraire(0.0, 0.0, discountCurve_));
            }
            results_.additionalResults["probabilities"] = prob;
        }
        // end probability computation

        return res;
    }
}
]]></document_content>
  </document>
  <document index="92">
    <source>swaption/gaussian1djamshidianswaptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/solvers1d/brent.hpp>
#include <ql/pricingengines/swaption/gaussian1djamshidianswaptionengine.hpp>
#include <utility>

namespace QuantLib {

    class Gaussian1dJamshidianSwaptionEngine::rStarFinder {
      public:
        rStarFinder(const ext::shared_ptr<Gaussian1dModel>& model,
                    Real nominal,
                    const Date& maturityDate,
                    const Date& valueDate,
                    std::vector<Date> fixedPayDates,
                    const std::vector<Real>& amounts,
                    const Size startIndex)
        : strike_(nominal), maturityDate_(maturityDate), valueDate_(valueDate),
          startIndex_(startIndex), times_(std::move(fixedPayDates)), amounts_(amounts),
          model_(model) {}

        Real operator()(Rate y) const {
            Real value = strike_;
            Size size = times_.size();
            for (Size i = startIndex_; i < size; i++) {
                Real dbValue = model_->zerobond(times_[i], maturityDate_, y) /
                               model_->zerobond(valueDate_, maturityDate_, y);
                value -= amounts_[i] * dbValue;
            }
            return value;
        }

      private:
        Real strike_;
        Date maturityDate_, valueDate_;
        Size startIndex_;
        std::vector<Date> times_;
        const std::vector<Real> &amounts_;
        const ext::shared_ptr<Gaussian1dModel> &model_;
    };

    void Gaussian1dJamshidianSwaptionEngine::calculate() const {

        QL_REQUIRE(arguments_.settlementMethod != Settlement::ParYieldCurve,
                   "cash settled (ParYieldCurve) swaptions not priced with "
                   "Gaussian1dJamshidianSwaptionEngine");

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "cannot use the Jamshidian decomposition "
                   "on exotic swaptions");

        QL_REQUIRE(arguments_.swap->spread() == 0.0,
                   "non zero spread (" << arguments_.swap->spread()
                                       << ") not allowed"); // PC

        QL_REQUIRE(arguments_.nominal != Null<Real>(),
                   "non-constant nominals are not supported yet");

        Date referenceDate;
        DayCounter dayCounter;

        referenceDate = model_->termStructure()->referenceDate();
        dayCounter = model_->termStructure()->dayCounter();

        std::vector<Real> amounts(arguments_.fixedCoupons);
        amounts.back() += arguments_.nominal;

        Size startIndex = std::upper_bound(arguments_.fixedResetDates.begin(),
                                           arguments_.fixedResetDates.end(),
                                           arguments_.exercise->date(0) - 1) -
                          arguments_.fixedResetDates.begin();
        // only consider coupons with start date >= exercise dates

        rStarFinder finder(*model_, arguments_.nominal,
                           arguments_.exercise->date(0),
                           arguments_.fixedResetDates[startIndex],
                           arguments_.fixedPayDates, amounts, startIndex);
        Brent s1d;
        Rate minStrike = -8.0;
        Rate maxStrike = 8.0;
        s1d.setMaxEvaluations(10000);
        s1d.setLowerBound(minStrike);
        s1d.setUpperBound(maxStrike);
        Rate rStar = s1d.solve(finder, 1e-8, 0.00, minStrike,
                               maxStrike); // this is actually yStar

        Option::Type w =
            arguments_.type == Swap::Payer ? Option::Put : Option::Call;
        Size size = arguments_.fixedCoupons.size();

        Real value = 0.0;
        for (Size i = startIndex; i < size; i++) {
            // Real fixedPayTime =
            // dayCounter.yearFraction(referenceDate,arguments_.fixedPayDates[i]);
            Real strike =
                model_->zerobond(arguments_.fixedPayDates[i],
                                 arguments_.exercise->date(0), rStar) /
                model_->zerobond(arguments_.fixedResetDates[startIndex],
                                 arguments_.exercise->date(0), rStar);
            Real dboValue =
                model_->zerobondOption(w, arguments_.exercise->date(0),
                                       arguments_.fixedResetDates[startIndex],
                                       arguments_.fixedPayDates[i], strike);
            value += amounts[i] * dboValue;
        }
        results_.value = value;
    }
}
]]></document_content>
  </document>
  <document index="93">
    <source>swaption/gaussian1dnonstandardswaptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/swaption/gaussian1dnonstandardswaptionengine.hpp>
#include <ql/rebatedexercise.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/math/interpolations/cubicinterpolation.hpp>
#include <ql/payoff.hpp>

using std::exp;

namespace QuantLib {

    Real
    Gaussian1dNonstandardSwaptionEngine::underlyingNpv(const Date &expiry,
                                                       const Real y) const {

        // determine the indices on both legs representing the cashflows that
        // are part of the exercise into right

        Size fixedIdx =
            std::upper_bound(arguments_.fixedResetDates.begin(),
                             arguments_.fixedResetDates.end(), expiry - 1) -
            arguments_.fixedResetDates.begin();
        Size floatingIdx =
            std::upper_bound(arguments_.floatingResetDates.begin(),
                             arguments_.floatingResetDates.end(), expiry - 1) -
            arguments_.floatingResetDates.begin();

        // calculate the npv of these cashflows conditional on y at expiry

        Real type = (Real)arguments_.type;

        Real npv = 0.0;
        for (Size i = fixedIdx; i < arguments_.fixedResetDates.size(); i++) {
            npv -=
                arguments_.fixedCoupons[i] *
                model_->zerobond(arguments_.fixedPayDates[i], expiry, y,
                                 discountCurve_) *
                (oas_.empty()
                     ? Real(1.0)
                     : exp(-oas_->value() *
                           model_->termStructure()->dayCounter().yearFraction(
                               expiry, arguments_.fixedPayDates[i])));
        }

        for (Size i = floatingIdx; i < arguments_.floatingResetDates.size();
             i++) {
            Real amount;
            if (!arguments_.floatingIsRedemptionFlow[i])
                amount = (arguments_.floatingGearings[i] *
                              model_->forwardRate(
                                  arguments_.floatingFixingDates[i], expiry, y,
                                  arguments_.swap->iborIndex()) +
                          arguments_.floatingSpreads[i]) *
                         arguments_.floatingAccrualTimes[i] *
                         arguments_.floatingNominal[i];
            else
                amount = arguments_.floatingCoupons[i];
            npv +=
                amount * model_->zerobond(arguments_.floatingPayDates[i],
                                          expiry, y, discountCurve_) *
                (oas_.empty()
                     ? Real(1.0)
                     : exp(-oas_->value() *
                           model_->termStructure()->dayCounter().yearFraction(
                               expiry, arguments_.floatingPayDates[i])));
        }

        return type * npv;
    }

    Swap::Type Gaussian1dNonstandardSwaptionEngine::underlyingType() const {
        return arguments_.swap->type();
    }

    // NOLINTNEXTLINE(readability-const-return-type)
    const Date Gaussian1dNonstandardSwaptionEngine::underlyingLastDate() const {
        return arguments_.fixedPayDates.back();
    }

    // NOLINTNEXTLINE(readability-const-return-type)
    const Array Gaussian1dNonstandardSwaptionEngine::initialGuess(const Date &expiry) const {

        Size fixedIdx =
            std::upper_bound(arguments_.fixedResetDates.begin(),
                             arguments_.fixedResetDates.end(), expiry - 1) -
            arguments_.fixedResetDates.begin();

        Array initial(3);
        Real nominalSum = 0.0, weightedRate = 0.0, ind = 0.0;
        for (Size i = fixedIdx; i < arguments_.fixedResetDates.size(); i++) {
            nominalSum += arguments_.fixedNominal[i];
            Real rate = arguments_.fixedRate[i];
            if (close(rate, 0.0))
                rate = 0.03; // this value is at least better than zero
            weightedRate += arguments_.fixedNominal[i] * rate;
            if (arguments_.fixedNominal[i] > 1E-8) // exclude zero nominal periods
                ind += 1.0;
        }
        Real nominalAvg = nominalSum / ind;

        QL_REQUIRE(nominalSum > 0.0,
                   "sum of nominals on fixed leg must be positive ("
                       << nominalSum << ")");

        weightedRate /= nominalSum;
        initial[0] = nominalAvg;
        initial[1] =
            model_->termStructure()->timeFromReference(underlyingLastDate()) -
            model_->termStructure()->timeFromReference(expiry);
        initial[2] = weightedRate;

        return initial;
    }

    void Gaussian1dNonstandardSwaptionEngine::calculate() const {

        QL_REQUIRE(arguments_.settlementMethod != Settlement::ParYieldCurve,
                   "cash settled (ParYieldCurve) swaptions not priced with "
                   "Gaussian1dNonstandardSwaptionEngine");

        Date settlement = model_->termStructure()->referenceDate();

        if (arguments_.exercise->dates().back() <=
            settlement) { // swaption is expired, possibly generated swap is not
                          // valued
            results_.value = 0.0;
            return;
        }

        ext::shared_ptr<RebatedExercise> rebatedExercise =
            ext::dynamic_pointer_cast<RebatedExercise>(arguments_.exercise);

        int idx = arguments_.exercise->dates().size() - 1;
        int minIdxAlive = static_cast<int>(
            std::upper_bound(arguments_.exercise->dates().begin(),
                             arguments_.exercise->dates().end(), settlement) -
            arguments_.exercise->dates().begin());

        NonstandardSwap swap = *arguments_.swap;
        Option::Type type =
            arguments_.type == Swap::Payer ? Option::Call : Option::Put;

        Array npv0(2 * integrationPoints_ + 1, 0.0),
            npv1(2 * integrationPoints_ + 1, 0.0);
        Array z = model_->yGrid(stddevs_, integrationPoints_);
        Array p(z.size(), 0.0);

        // for probability computation
        std::vector<Array> npvp0, npvp1;
        if (probabilities_ != None) {
            for (int i = 0; i < idx - minIdxAlive + 2; ++i) {
                Array npvTmp0(2 * integrationPoints_ + 1, 0.0);
                Array npvTmp1(2 * integrationPoints_ + 1, 0.0);
                npvp0.push_back(npvTmp0);
                npvp1.push_back(npvTmp1);
            }
        }
        // end probability computation

        Date expiry1 = Date(), expiry0;
        Time expiry1Time = Null<Real>(), expiry0Time;

        do {

            if (idx == minIdxAlive - 1)
                expiry0 = settlement;
            else
                expiry0 = arguments_.exercise->dates()[idx];

            expiry0Time = std::max(
                model_->termStructure()->timeFromReference(expiry0), 0.0);

            Size j1 =
                std::upper_bound(arguments_.fixedResetDates.begin(),
                                 arguments_.fixedResetDates.end(), expiry0 - 1) -
                arguments_.fixedResetDates.begin();
            Size k1 =
                std::upper_bound(arguments_.floatingResetDates.begin(),
                                 arguments_.floatingResetDates.end(), expiry0 - 1) -
                arguments_.floatingResetDates.begin();

            // todo add openmp support later on (as in gaussian1dswaptionengine)

            for (Size k = 0; k < (expiry0 > settlement ? npv0.size() : 1);
                 k++) {

                Real price = 0.0;
                if (expiry1Time != Null<Real>()) {
                    Real zSpreadDf =
                        oas_.empty() ? Real(1.0)
                                     : std::exp(-oas_->value() *
                                                (expiry1Time - expiry0Time));
                    Array yg = model_->yGrid(stddevs_, integrationPoints_,
                                             expiry1Time, expiry0Time,
                                             expiry0 > settlement ? z[k] : 0.0);
                    CubicInterpolation payoff0(
                        z.begin(), z.end(), npv1.begin(),
                        CubicInterpolation::Spline, true,
                        CubicInterpolation::Lagrange, 0.0,
                        CubicInterpolation::Lagrange, 0.0);
                    for (Size i = 0; i < yg.size(); i++) {
                        p[i] = payoff0(yg[i], true);
                    }
                    CubicInterpolation payoff1(
                        z.begin(), z.end(), p.begin(),
                        CubicInterpolation::Spline, true,
                        CubicInterpolation::Lagrange, 0.0,
                        CubicInterpolation::Lagrange, 0.0);
                    for (Size i = 0; i < z.size() - 1; i++) {
                        price += Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                     0.0, payoff1.cCoefficients()[i],
                                     payoff1.bCoefficients()[i],
                                     payoff1.aCoefficients()[i], p[i], z[i],
                                     z[i], z[i + 1]) *
                                 zSpreadDf;
                    }
                    if (extrapolatePayoff_) {
                        if (flatPayoffExtrapolation_) {
                            price +=
                                Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                    0.0, 0.0, 0.0, 0.0, p[z.size() - 2],
                                    z[z.size() - 2], z[z.size() - 1], 100.0) *
                                zSpreadDf;
                            price += Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                         0.0, 0.0, 0.0, 0.0, p[0], z[0], -100.0,
                                         z[0]) *
                                     zSpreadDf;
                        } else {
                            if (type == Option::Call)
                                price +=
                                    Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                        0.0,
                                        payoff1.cCoefficients()[z.size() - 2],
                                        payoff1.bCoefficients()[z.size() - 2],
                                        payoff1.aCoefficients()[z.size() - 2],
                                        p[z.size() - 2], z[z.size() - 2],
                                        z[z.size() - 1], 100.0) *
                                    zSpreadDf;
                            if (type == Option::Put)
                                price +=
                                    Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                        0.0, payoff1.cCoefficients()[0],
                                        payoff1.bCoefficients()[0],
                                        payoff1.aCoefficients()[0], p[0], z[0],
                                        -100.0, z[0]) *
                                    zSpreadDf;
                        }
                    }
                }

                npv0[k] = price;

                // for probability computation
                if (probabilities_ != None) {
                    for (Size m = 0; m < npvp0.size(); m++) {
                        Real price = 0.0;
                        if (expiry1Time != Null<Real>()) {
                            Real zSpreadDf =
                                oas_.empty()
                                    ? Real(1.0)
                                    : std::exp(-oas_->value() *
                                               (expiry1Time - expiry0Time));
                            Array yg = model_->yGrid(
                                stddevs_, integrationPoints_, expiry1Time,
                                expiry0Time, expiry0 > settlement ? z[k] : 0.0);
                            CubicInterpolation payoff0(
                                z.begin(), z.end(), npvp1[m].begin(),
                                CubicInterpolation::Spline, true,
                                CubicInterpolation::Lagrange, 0.0,
                                CubicInterpolation::Lagrange, 0.0);
                            for (Size i = 0; i < yg.size(); i++) {
                                p[i] = payoff0(yg[i], true);
                            }
                            CubicInterpolation payoff1(
                                z.begin(), z.end(), p.begin(),
                                CubicInterpolation::Spline, true,
                                CubicInterpolation::Lagrange, 0.0,
                                CubicInterpolation::Lagrange, 0.0);
                            for (Size i = 0; i < z.size() - 1; i++) {
                                price +=
                                    Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                        0.0, payoff1.cCoefficients()[i],
                                        payoff1.bCoefficients()[i],
                                        payoff1.aCoefficients()[i], p[i], z[i],
                                        z[i], z[i + 1]) *
                                    zSpreadDf;
                            }
                            if (extrapolatePayoff_) {
                                if (flatPayoffExtrapolation_) {
                                    price +=
                                        Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                                  0.0, 0.0, 0.0, 0.0,
                                                  p[z.size() - 2],
                                                  z[z.size() - 2],
                                                  z[z.size() - 1], 100.0) *
                                        zSpreadDf;
                                    price +=
                                        Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                                  0.0, 0.0, 0.0, 0.0, p[0],
                                                  z[0], -100.0, z[0]) *
                                        zSpreadDf;
                                } else {
                                    if (type == Option::Call)
                                        price +=
                                            Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                                      0.0,
                                                      payoff1.cCoefficients()
                                                          [z.size() - 2],
                                                      payoff1.bCoefficients()
                                                          [z.size() - 2],
                                                      payoff1.aCoefficients()
                                                          [z.size() - 2],
                                                      p[z.size() - 2],
                                                      z[z.size() - 2],
                                                      z[z.size() - 1], 100.0) *
                                            zSpreadDf;
                                    if (type == Option::Put)
                                        price +=
                                            Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                                      0.0,
                                                      payoff1
                                                          .cCoefficients()[0],
                                                      payoff1
                                                          .bCoefficients()[0],
                                                      payoff1
                                                          .aCoefficients()[0],
                                                      p[0], z[0], -100.0,
                                                      z[0]) *
                                            zSpreadDf;
                                }
                            }
                        }

                        npvp0[m][k] = price;
                    }
                }
                // end probability computation

                if (expiry0 > settlement) {
                    Real floatingLegNpv = 0.0;
                    for (Size l = k1; l < arguments_.floatingCoupons.size();
                         l++) {
                        Real zSpreadDf =
                            oas_.empty()
                                ? Real(1.0)
                                : std::exp(
                                      -oas_->value() *
                                      (model_->termStructure()
                                           ->dayCounter()
                                           .yearFraction(
                                                expiry0,
                                                arguments_
                                                    .floatingPayDates[l])));
                        Real amount;
                        if (arguments_.floatingIsRedemptionFlow[l])
                            amount = arguments_.floatingCoupons[l];
                        else
                            amount = arguments_.floatingNominal[l] *
                                     arguments_.floatingAccrualTimes[l] *
                                     (arguments_.floatingGearings[l] *
                                          model_->forwardRate(
                                              arguments_.floatingFixingDates[l],
                                              expiry0, z[k],
                                              arguments_.swap->iborIndex()) +
                                      arguments_.floatingSpreads[l]);
                        floatingLegNpv +=
                            amount *
                            model_->zerobond(arguments_.floatingPayDates[l],
                                             expiry0, z[k], discountCurve_) *
                            zSpreadDf;
                    }
                    Real fixedLegNpv = 0.0;
                    for (Size l = j1; l < arguments_.fixedCoupons.size(); l++) {
                        Real zSpreadDf =
                            oas_.empty()
                                ? Real(1.0)
                                : std::exp(
                                      -oas_->value() *
                                      (model_->termStructure()
                                           ->dayCounter()
                                           .yearFraction(
                                                expiry0,
                                                arguments_.fixedPayDates[l])));
                        fixedLegNpv +=
                            arguments_.fixedCoupons[l] *
                            model_->zerobond(arguments_.fixedPayDates[l],
                                             expiry0, z[k], discountCurve_) *
                            zSpreadDf;
                    }
                    Real rebate = 0.0;
                    Real zSpreadDf = 1.0;
                    Date rebateDate = expiry0;
                    if (rebatedExercise != nullptr) {
                        rebate = rebatedExercise->rebate(idx);
                        rebateDate = rebatedExercise->rebatePaymentDate(idx);
                        zSpreadDf =
                            oas_.empty()
                                ? Real(1.0)
                                : std::exp(
                                      -oas_->value() *
                                      (model_->termStructure()
                                           ->dayCounter()
                                           .yearFraction(expiry0, rebateDate)));
                    }
                    Real exerciseValue =
                        ((type == Option::Call ? 1.0 : -1.0) *
                             (floatingLegNpv - fixedLegNpv) +
                         rebate * model_->zerobond(rebateDate, expiry0, z[k],
                                                   discountCurve_) *
                             zSpreadDf) /
                        model_->numeraire(expiry0Time, z[k], discountCurve_);

                    // for probability computation
                    if (probabilities_ != None) {
                        if (idx == static_cast<int>(
                                       arguments_.exercise->dates().size()) -
                                       1) // if true we are at the latest date,
                                          // so we init
                                          // the no call probability
                            npvp0.back()[k] =
                                probabilities_ == Naive
                                    ? Real(1.0)
                                    : 1.0 / (model_->zerobond(expiry0Time, 0.0,
                                                              0.0,
                                                              discountCurve_) *
                                             model_->numeraire(expiry0, z[k],
                                                               discountCurve_));
                        if (exerciseValue >= npv0[k]) {
                            npvp0[idx - minIdxAlive][k] =
                                probabilities_ == Naive
                                    ? Real(1.0)
                                    : 1.0 /
                                          (model_->zerobond(expiry0Time, 0.0,
                                                            0.0,
                                                            discountCurve_) *
                                           model_->numeraire(expiry0Time, z[k],
                                                             discountCurve_));
                            for (Size ii = idx - minIdxAlive + 1;
                                 ii < npvp0.size(); ii++)
                                npvp0[ii][k] = 0.0;
                        }
                    }
                    // end probability computation

                    npv0[k] = std::max(npv0[k], exerciseValue);
                }
            }

            npv1.swap(npv0);

            // for probability computation
            if (probabilities_ != None) {
                for (Size i = 0; i < npvp0.size(); i++)
                    npvp1[i].swap(npvp0[i]);
            }
            // end probability computation

            expiry1 = expiry0;
            expiry1Time = expiry0Time;

        } while (--idx >= minIdxAlive - 1);

        results_.value = npv1[0] * model_->numeraire(0.0, 0.0, discountCurve_);

        // for probability computation
        if (probabilities_ != None) {
            std::vector<Real> prob(npvp0.size());
            for (Size i = 0; i < npvp0.size(); i++) {
                prob[i] = npvp1[i][0] *
                          (probabilities_ == Naive
                               ? 1.0
                               : model_->numeraire(0.0, 0.0, discountCurve_));
            }
            results_.additionalResults["probabilities"] = prob;
        }
        // end probability computation
    }
}
]]></document_content>
  </document>
  <document index="94">
    <source>swaption/gaussian1dswaptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/swaption/gaussian1dswaptionengine.hpp>
#include <ql/math/interpolations/cubicinterpolation.hpp>
#include <ql/payoff.hpp>

namespace QuantLib {

    void Gaussian1dSwaptionEngine::calculate() const {

        QL_REQUIRE(arguments_.settlementMethod != Settlement::ParYieldCurve,
                   "cash settled (ParYieldCurve) swaptions not priced with "
                   "Gaussian1dSwaptionEngine");

        QL_REQUIRE(arguments_.nominal != Null<Real>(),
                   "non-constant nominals are not supported yet");

        Date settlement = model_->termStructure()->referenceDate();

        if (arguments_.exercise->dates().back() <=
            settlement) { // swaption is expired, possibly generated swap is not
                          // valued
            results_.value = 0.0;
            return;
        }

        int idx = static_cast<int>(arguments_.exercise->dates().size()) - 1;
        int minIdxAlive = static_cast<int>(
            std::upper_bound(arguments_.exercise->dates().begin(),
                             arguments_.exercise->dates().end(), settlement) -
            arguments_.exercise->dates().begin());

        auto swap = arguments_.swap;
        Option::Type type =
            arguments_.type == Swap::Payer ? Option::Call : Option::Put;
        const Schedule& fixedSchedule = swap->fixedSchedule();
        const Schedule& floatSchedule = swap->floatingSchedule();

        Array npv0(2 * integrationPoints_ + 1, 0.0),
            npv1(2 * integrationPoints_ + 1, 0.0);
        Array z = model_->yGrid(stddevs_, integrationPoints_);
        Array p(z.size(), 0.0);

        // for probability computation
        std::vector<Array> npvp0, npvp1;
        if (probabilities_ != None) {
            for (int i = 0; i < idx - minIdxAlive + 2; ++i) {
                Array npvTmp0(2 * integrationPoints_ + 1, 0.0);
                Array npvTmp1(2 * integrationPoints_ + 1, 0.0);
                npvp0.push_back(npvTmp0);
                npvp1.push_back(npvTmp1);
            }
        }
        // end probability computation

        Date expiry1 = Date(), expiry0;
        Time expiry1Time = Null<Real>(), expiry0Time;

        do {

            if (idx == minIdxAlive - 1)
                expiry0 = settlement;
            else
                expiry0 = arguments_.exercise->dates()[idx];

            expiry0Time = std::max(
                model_->termStructure()->timeFromReference(expiry0), 0.0);

            Size j1 =
                std::upper_bound(fixedSchedule.dates().begin(),
                                 fixedSchedule.dates().end(), expiry0 - 1) -
                fixedSchedule.dates().begin();
            Size k1 =
                std::upper_bound(floatSchedule.dates().begin(),
                                 floatSchedule.dates().end(), expiry0 - 1) -
                floatSchedule.dates().begin();

            // a lazy object is not thread safe, neither is the caching
            // in gsrprocess. therefore we trigger computations here such
            // that neither lazy object recalculation nor write access
            // during caching occurs in the parallized loop below.
            // this is known to work for the gsr and markov functional
            // model implementations of Gaussian1dModel
#ifdef _OPENMP
            if (expiry1Time != Null<Real>())
                model_->yGrid(stddevs_, integrationPoints_, expiry1Time,
                              expiry0Time, 0.0);
            if (expiry0 > settlement) {
                for (Size l = k1; l < arguments_.floatingCoupons.size(); l++) {
                    model_->forwardRate(arguments_.floatingFixingDates[l],
                                        expiry0, 0.0,
                                        arguments_.swap->iborIndex());
                    model_->zerobond(arguments_.floatingPayDates[l], expiry0,
                                     0.0, discountCurve_);
                }
                for (Size l = j1; l < arguments_.fixedCoupons.size(); l++) {
                    model_->zerobond(arguments_.fixedPayDates[l], expiry0, 0.0,
                                     discountCurve_);
                }
                model_->numeraire(expiry0Time, 0.0, discountCurve_);
            }
#endif

#pragma omp parallel for default(shared) firstprivate(p) if(expiry0>settlement)
            for (long k = 0; k < (expiry0 > settlement ? (long)npv0.size() : 1);
                 k++) {

                Real price = 0.0;
                if (expiry1Time != Null<Real>()) {
                    Array yg = model_->yGrid(stddevs_, integrationPoints_,
                                             expiry1Time, expiry0Time,
                                             expiry0 > settlement ? z[k] : 0.0);
                    CubicInterpolation payoff0(
                        z.begin(), z.end(), npv1.begin(),
                        CubicInterpolation::Spline, true,
                        CubicInterpolation::Lagrange, 0.0,
                        CubicInterpolation::Lagrange, 0.0);
                    for (Size i = 0; i < yg.size(); i++) {
                        p[i] = payoff0(yg[i], true);
                    }
                    CubicInterpolation payoff1(
                        z.begin(), z.end(), p.begin(),
                        CubicInterpolation::Spline, true,
                        CubicInterpolation::Lagrange, 0.0,
                        CubicInterpolation::Lagrange, 0.0);
                    for (Size i = 0; i < z.size() - 1; i++) {
                        price += Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                            0.0, payoff1.cCoefficients()[i],
                            payoff1.bCoefficients()[i],
                            payoff1.aCoefficients()[i], p[i], z[i], z[i],
                            z[i + 1]);
                    }
                    if (extrapolatePayoff_) {
                        if (flatPayoffExtrapolation_) {
                            price += Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                0.0, 0.0, 0.0, 0.0, p[z.size() - 2],
                                z[z.size() - 2], z[z.size() - 1], 100.0);
                            price += Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                0.0, 0.0, 0.0, 0.0, p[0], z[0], -100.0, z[0]);
                        } else {
                            if (type == Option::Call)
                                price +=
                                    Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                        0.0,
                                        payoff1.cCoefficients()[z.size() - 2],
                                        payoff1.bCoefficients()[z.size() - 2],
                                        payoff1.aCoefficients()[z.size() - 2],
                                        p[z.size() - 2], z[z.size() - 2],
                                        z[z.size() - 1], 100.0);
                            if (type == Option::Put)
                                price +=
                                    Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                        0.0, payoff1.cCoefficients()[0],
                                        payoff1.bCoefficients()[0],
                                        payoff1.aCoefficients()[0], p[0], z[0],
                                        -100.0, z[0]);
                        }
                    }
                }

                npv0[k] = price;

                // for probability computation
                if (probabilities_ != None) {
                    for (Size m = 0; m < npvp0.size(); m++) {
                        Real price = 0.0;
                        if (expiry1Time != Null<Real>()) {
                            Array yg = model_->yGrid(
                                stddevs_, integrationPoints_, expiry1Time,
                                expiry0Time, expiry0 > settlement ? z[k] : 0.0);
                            CubicInterpolation payoff0(
                                z.begin(), z.end(), npvp1[m].begin(),
                                CubicInterpolation::Spline, true,
                                CubicInterpolation::Lagrange, 0.0,
                                CubicInterpolation::Lagrange, 0.0);
                            for (Size i = 0; i < yg.size(); i++) {
                                p[i] = payoff0(yg[i], true);
                            }
                            CubicInterpolation payoff1(
                                z.begin(), z.end(), p.begin(),
                                CubicInterpolation::Spline, true,
                                CubicInterpolation::Lagrange, 0.0,
                                CubicInterpolation::Lagrange, 0.0);
                            for (Size i = 0; i < z.size() - 1; i++) {
                                price +=
                                    Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                        0.0, payoff1.cCoefficients()[i],
                                        payoff1.bCoefficients()[i],
                                        payoff1.aCoefficients()[i], p[i], z[i],
                                        z[i], z[i + 1]);
                            }
                            if (extrapolatePayoff_) {
                                if (flatPayoffExtrapolation_) {
                                    price +=
                                        Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                                  0.0, 0.0, 0.0, 0.0,
                                                  p[z.size() - 2],
                                                  z[z.size() - 2],
                                                  z[z.size() - 1], 100.0);
                                    price +=
                                        Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                                  0.0, 0.0, 0.0, 0.0, p[0],
                                                  z[0], -100.0, z[0]);
                                } else {
                                    if (type == Option::Call)
                                        price +=
                                            Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                                      0.0,
                                                      payoff1.cCoefficients()
                                                          [z.size() - 2],
                                                      payoff1.bCoefficients()
                                                          [z.size() - 2],
                                                      payoff1.aCoefficients()
                                                          [z.size() - 2],
                                                      p[z.size() - 2],
                                                      z[z.size() - 2],
                                                      z[z.size() - 1], 100.0);
                                    if (type == Option::Put)
                                        price +=
                                            Gaussian1dModel::gaussianShiftedPolynomialIntegral(
                                                      0.0,
                                                      payoff1
                                                          .cCoefficients()[0],
                                                      payoff1
                                                          .bCoefficients()[0],
                                                      payoff1
                                                          .aCoefficients()[0],
                                                      p[0], z[0], -100.0, z[0]);
                                }
                            }
                        }

                        npvp0[m][k] = price;
                    }
                }
                // end probability computation

                if (expiry0 > settlement) {
                    Real floatingLegNpv = 0.0;
                    for (Size l = k1; l < arguments_.floatingCoupons.size();
                         l++) {
                        floatingLegNpv +=
                            arguments_.nominal *
                            arguments_.floatingAccrualTimes[l] *
                            (arguments_.floatingSpreads[l] +
                             model_->forwardRate(
                                 arguments_.floatingFixingDates[l], expiry0,
                                 z[k], arguments_.swap->iborIndex())) *
                            model_->zerobond(arguments_.floatingPayDates[l],
                                             expiry0, z[k], discountCurve_);
                    }
                    Real fixedLegNpv = 0.0;
                    for (Size l = j1; l < arguments_.fixedCoupons.size(); l++) {
                        fixedLegNpv +=
                            arguments_.fixedCoupons[l] *
                            model_->zerobond(arguments_.fixedPayDates[l],
                                             expiry0, z[k], discountCurve_);
                    }
                    Real exerciseValue =
                        (type == Option::Call ? 1.0 : -1.0) *
                        (floatingLegNpv - fixedLegNpv) /
                        model_->numeraire(expiry0Time, z[k], discountCurve_);

                    // for probability computation
                    if (probabilities_ != None) {
                        if (idx == static_cast<int>(
                                       arguments_.exercise->dates().size()) -
                                       1) // if true we are at the latest date,
                                          // so we init
                                          // the no call probability
                            npvp0.back()[k] =
                                probabilities_ == Naive
                                    ? Real(1.0)
                                    : 1.0 / (model_->zerobond(expiry0Time, 0.0,
                                                              0.0,
                                                              discountCurve_) *
                                             model_->numeraire(expiry0, z[k],
                                                               discountCurve_));
                        if (exerciseValue >= npv0[k]) {
                            npvp0[idx - minIdxAlive][k] =
                                probabilities_ == Naive
                                    ? Real(1.0)
                                    : 1.0 /
                                          (model_->zerobond(expiry0Time, 0.0,
                                                            0.0,
                                                            discountCurve_) *
                                           model_->numeraire(expiry0Time, z[k],
                                                             discountCurve_));
                            for (Size ii = idx - minIdxAlive + 1;
                                 ii < npvp0.size(); ii++)
                                npvp0[ii][k] = 0.0;
                        }
                    }
                    // end probability computation

                    npv0[k] = std::max(npv0[k], exerciseValue);
                }
            }

            npv1.swap(npv0);

            // for probability computation
            if (probabilities_ != None) {
                for (Size i = 0; i < npvp0.size(); i++)
                    npvp1[i].swap(npvp0[i]);
            }
            // end probability computation

            expiry1 = expiry0;
            expiry1Time = expiry0Time;

        } while (--idx >= minIdxAlive - 1);

        results_.value = npv1[0] * model_->numeraire(0.0, 0.0, discountCurve_);

        // for probability computation
        if (probabilities_ != None) {
            std::vector<Real> prob(npvp0.size());
            for (Size i = 0; i < npvp0.size(); i++) {
                prob[i] = npvp1[i][0] *
                          (probabilities_ == Naive
                               ? 1.0
                               : model_->numeraire(0.0, 0.0, discountCurve_));
            }
            results_.additionalResults["probabilities"] = prob;
        }
        // end probability computation
    }
}
]]></document_content>
  </document>
  <document index="95">
    <source>swaption/jamshidianswaptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/solvers1d/brent.hpp>
#include <ql/pricingengines/swaption/jamshidianswaptionengine.hpp>
#include <utility>

namespace QuantLib {

    class JamshidianSwaptionEngine::rStarFinder {
      public:
        rStarFinder(const ext::shared_ptr<OneFactorAffineModel>& model,
                    Real nominal,
                    Time maturity,
                    Time valueTime,
                    std::vector<Time> fixedPayTimes,
                    const std::vector<Real>& amounts)
        : strike_(nominal), maturity_(maturity), valueTime_(valueTime),
          times_(std::move(fixedPayTimes)), amounts_(amounts), model_(model) {}

        Real operator()(Rate x) const {
            Real value = strike_;
            Real B = model_->discountBond(maturity_, valueTime_, x);
            Size size = times_.size();
            for (Size i=0; i<size; i++) {
                Real dbValue =
                    model_->discountBond(maturity_, times_[i], x) / B;
                value -= amounts_[i]*dbValue;
            }
            return value;
        }
      private:
        Real strike_;
        Time maturity_,valueTime_;
        std::vector<Time> times_;
        const std::vector<Real>& amounts_;
        const ext::shared_ptr<OneFactorAffineModel>& model_;
    };

    void JamshidianSwaptionEngine::calculate() const {

        QL_REQUIRE(arguments_.settlementMethod != Settlement::ParYieldCurve,
                   "cash settled (ParYieldCurve) swaptions not priced with "
                   "JamshidianSwaptionEngine");

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "cannot use the Jamshidian decomposition "
                   "on exotic swaptions");

        QL_REQUIRE(arguments_.swap->spread() == 0.0, "non zero spread (" << arguments_.swap->spread() << ") not allowed");

        QL_REQUIRE(arguments_.nominal != Null<Real>(),
                   "non-constant nominals are not supported yet");

        QL_REQUIRE(!model_.empty(), "no model specified");

        Date referenceDate;
        DayCounter dayCounter;

        ext::shared_ptr<TermStructureConsistentModel> tsmodel =
            ext::dynamic_pointer_cast<TermStructureConsistentModel>(*model_);
        if (tsmodel != nullptr) {
            referenceDate = tsmodel->termStructure()->referenceDate();
            dayCounter = tsmodel->termStructure()->dayCounter();
        } else {
            referenceDate = termStructure_->referenceDate();
            dayCounter = termStructure_->dayCounter();
        }

        std::vector<Real> amounts(arguments_.fixedCoupons);
        amounts.back() += arguments_.nominal;

        Real maturity = dayCounter.yearFraction(referenceDate,
                                                arguments_.exercise->date(0));

        std::vector<Time> fixedPayTimes(arguments_.fixedPayDates.size());
        Time valueTime = dayCounter.yearFraction(referenceDate,arguments_.fixedResetDates[0]);
        for (Size i=0; i<fixedPayTimes.size(); i++)
            fixedPayTimes[i] = dayCounter.yearFraction(referenceDate,
                                                       arguments_.fixedPayDates[i]);

        rStarFinder finder(*model_, arguments_.nominal, maturity, valueTime,
                           fixedPayTimes, amounts);
        Brent s1d;
        Rate minStrike = -10.0;
        Rate maxStrike = 10.0;
        s1d.setMaxEvaluations(10000);
        s1d.setLowerBound(minStrike);
        s1d.setUpperBound(maxStrike);
        Rate rStar = s1d.solve(finder, 1e-8, 0.05, minStrike, maxStrike);

        Option::Type w = arguments_.type==Swap::Payer ? Option::Put : Option::Call;
        Size size = arguments_.fixedCoupons.size();

        Real value = 0.0;
        Real B = model_->discountBond(maturity, valueTime, rStar);
        for (Size i=0; i<size; i++) {
            Real fixedPayTime =
                dayCounter.yearFraction(referenceDate,
                                        arguments_.fixedPayDates[i]);
            Real strike = model_->discountBond(maturity,
                                               fixedPayTime,
                                               rStar) / B;
            // Looks like the swaption decomposed into individual options adjusted for maturity. Each individual option is valued by Hull-White (or other one-factor model).
            Real dboValue = model_->discountBondOption(
                                               w, strike, maturity, valueTime,
                                               fixedPayTime);
            value += amounts[i]*dboValue;
        }
        results_.value = value;
    }

}

]]></document_content>
  </document>
  <document index="96">
    <source>swaption/treeswaptionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2005, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/swaption/discretizedswaption.hpp>
#include <ql/pricingengines/swaption/treeswaptionengine.hpp>
#include <utility>

namespace QuantLib {

    TreeSwaptionEngine::TreeSwaptionEngine(const ext::shared_ptr<ShortRateModel>& model,
                                           Size timeSteps,
                                           Handle<YieldTermStructure> termStructure)
    : LatticeShortRateModelEngine<Swaption::arguments, Swaption::results>(model, timeSteps),
      termStructure_(std::move(termStructure)) {
        registerWith(termStructure_);
    }

    TreeSwaptionEngine::TreeSwaptionEngine(const ext::shared_ptr<ShortRateModel>& model,
                                           const TimeGrid& timeGrid,
                                           Handle<YieldTermStructure> termStructure)
    : LatticeShortRateModelEngine<Swaption::arguments, Swaption::results>(model, timeGrid),
      termStructure_(std::move(termStructure)) {
        registerWith(termStructure_);
    }

    TreeSwaptionEngine::TreeSwaptionEngine(const Handle<ShortRateModel>& model,
                                           Size timeSteps,
                                           Handle<YieldTermStructure> termStructure)
    : LatticeShortRateModelEngine<Swaption::arguments, Swaption::results>(model, timeSteps),
      termStructure_(std::move(termStructure)) {
        registerWith(termStructure_);
    }

    void TreeSwaptionEngine::calculate() const {

        QL_REQUIRE(arguments_.settlementMethod != Settlement::ParYieldCurve,
                   "cash settled (ParYieldCurve) swaptions not priced with "
                   "TreeSwaptionEngine");
        QL_REQUIRE(!model_.empty(), "no model specified");

        Date referenceDate;
        DayCounter dayCounter;

        ext::shared_ptr<TermStructureConsistentModel> tsmodel =
            ext::dynamic_pointer_cast<TermStructureConsistentModel>(*model_);
        if (tsmodel != nullptr) {
            referenceDate = tsmodel->termStructure()->referenceDate();
            dayCounter = tsmodel->termStructure()->dayCounter();
        } else {
            referenceDate = termStructure_->referenceDate();
            dayCounter = termStructure_->dayCounter();
        }

        DiscretizedSwaption swaption(arguments_, referenceDate, dayCounter);
        ext::shared_ptr<Lattice> lattice;

        if (lattice_ != nullptr) {
            lattice = lattice_;
        } else {
            std::vector<Time> times = swaption.mandatoryTimes();
            TimeGrid timeGrid(times.begin(), times.end(), timeSteps_);
            lattice = model_->tree(timeGrid);
        }

        std::vector<Time> stoppingTimes(arguments_.exercise->dates().size());
        for (Size i=0; i<stoppingTimes.size(); ++i)
            stoppingTimes[i] =
                dayCounter.yearFraction(referenceDate,
                                        arguments_.exercise->date(i));

        swaption.initialize(lattice, stoppingTimes.back());

        Time nextExercise =
            *std::find_if(stoppingTimes.begin(), stoppingTimes.end(),
                          [](Time t){ return t >= 0.0; });
        swaption.rollback(nextExercise);

        results_.value = swaption.presentValue();
    }

}
]]></document_content>
  </document>
  <document index="97">
    <source>vanilla/analyticbsmhullwhiteengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticbsmhullwhiteengine.hpp
    \brief analytic Black-Scholes engines including stochastic interest rates
*/

#include <ql/pricingengines/vanilla/analyticbsmhullwhiteengine.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/termstructures/volatility/equityfx/blackvoltermstructure.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        class ShiftedBlackVolTermStructure : public BlackVolTermStructure {
          public:
            ShiftedBlackVolTermStructure(
                Real varianceOffset,
                const Handle<BlackVolTermStructure> & volTS)
                : BlackVolTermStructure(volTS->referenceDate(),
                                        volTS->calendar(),
                                        Following,
                                        volTS->dayCounter()),
                  varianceOffset_(varianceOffset),
                  volTS_(volTS) { }

            Real minStrike() const override { return volTS_->minStrike(); }
            Real maxStrike() const override { return volTS_->maxStrike(); }
            Date maxDate() const override { return volTS_->maxDate(); }

          protected:
            Real blackVarianceImpl(Time t, Real strike) const override {
                return volTS_->blackVariance(t, strike, true)+varianceOffset_;
            }
            Volatility blackVolImpl(Time t, Real strike) const override {
                Time nonZeroMaturity = (t==0.0 ? 0.00001 : t);
                Real var = blackVarianceImpl(nonZeroMaturity, strike);
                return std::sqrt(var/nonZeroMaturity);
            }

          private:
            const Real varianceOffset_;
            const Handle<BlackVolTermStructure> volTS_;
        };
    }

    AnalyticBSMHullWhiteEngine::AnalyticBSMHullWhiteEngine(
        Real equityShortRateCorrelation,
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        const ext::shared_ptr<HullWhite>& model)
    : GenericModelEngine<HullWhite, VanillaOption::arguments, VanillaOption::results>(model),
      rho_(equityShortRateCorrelation), process_(std::move(process)) {
        QL_REQUIRE(process_, "no Black-Scholes process specified");
        QL_REQUIRE(!model_.empty(), "no Hull-White model specified");
        registerWith(process_);
    }

    void AnalyticBSMHullWhiteEngine::calculate() const {

        QL_REQUIRE(process_->x0() > 0.0, "negative or null underlying given");

        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        const ext::shared_ptr<Exercise> exercise = arguments_.exercise;

        Time t = process_->riskFreeRate()->dayCounter().yearFraction(
                                    process_->riskFreeRate()->referenceDate(),
                                    exercise->lastDate());

        const Real a = model_->params()[0];
        const Real sigma = model_->params()[1];
        const Real eta =
            process_->blackVolatility()->blackVol(exercise->lastDate(),
                                                  payoff->strike());

        Real varianceOffset;
        if (a*t > std::pow(QL_EPSILON, 0.25)) {
            const Real v = sigma*sigma/(a*a)
                *(t + 2/a*std::exp(-a*t) - 1/(2*a)*std::exp(-2*a*t) - 3/(2*a));
            const Real mu = 2*rho_*sigma*eta/a*(t-1/a*(1-std::exp(-a*t)));

            varianceOffset = v + mu;
        }
        else {
            // low-a algebraic limit
            const Real v = sigma*sigma*t*t*t*(1/3.0-0.25*a*t+7/60.0*a*a*t*t);
            const Real mu = rho_*sigma*eta*t*t*(1-a*t/3.0+a*a*t*t/12.0);

            varianceOffset = v + mu;
        }

        Handle<BlackVolTermStructure> volTS(
             ext::shared_ptr<BlackVolTermStructure>(
              new ShiftedBlackVolTermStructure(varianceOffset,
                                               process_->blackVolatility())));

        ext::shared_ptr<GeneralizedBlackScholesProcess> adjProcess(
                new GeneralizedBlackScholesProcess(process_->stateVariable(),
                                                   process_->dividendYield(),
                                                   process_->riskFreeRate(),
                                                   volTS));

        ext::shared_ptr<AnalyticEuropeanEngine> bsmEngine(
                                      new AnalyticEuropeanEngine(adjProcess));

        VanillaOption(payoff, exercise).setupArguments(
                                                   bsmEngine->getArguments());
        bsmEngine->calculate();

        results_ = *dynamic_cast<const OneAssetOption::results*>(
                                                    bsmEngine->getResults());
    }
}
]]></document_content>
  </document>
  <document index="98">
    <source>vanilla/analyticcevengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticcevengine.cpp */

#include <ql/exercise.hpp>
#include <ql/math/functional.hpp>
#include <ql/pricingengines/vanilla/analyticcevengine.hpp>
#include <boost/math/distributions/non_central_chi_squared.hpp>
#include <boost/math/special_functions/gamma.hpp>
#include <utility>

namespace QuantLib {

    CEVCalculator::CEVCalculator(Real f0, Real alpha, Real beta)
    : f0_(f0),
      alpha_(alpha),
      beta_(beta),
      delta_((1.0-2.0*beta)/(1.0-beta)),
      x0_(X(f0)) { }

    Real CEVCalculator::X(Real f) const {
        return std::pow(f, 2.0*(1.0-beta_))/squared(alpha_*(1.0-beta_));
    }

    Real CEVCalculator::value(
        Option::Type optionType, Real strike, Time t) const {

        typedef boost::math::non_central_chi_squared_distribution<Real>
            nc_chi2;

        const Real kTilde = X(strike);

        if (optionType == Option::Call) {
            if (delta_ < 2.0) {
                return f0_ * (1.0 - boost::math::cdf(
                         nc_chi2(4.0-delta_, x0_/t), kTilde/t))
                     - strike * boost::math::cdf(
                         nc_chi2(2.0-delta_, kTilde/t), x0_/t);
            }
            else {
                const Real g =
                    boost::math::gamma_p(0.5*delta_-1.0,x0_/(2.0*t));

                return f0_ * (g - boost::math::cdf(
                         nc_chi2(delta_-2.0, kTilde/t), x0_/t))
                     - strike * boost::math::cdf(
                         nc_chi2(delta_, x0_/t), kTilde/t);
            }
        }
        else if (optionType == Option::Put) {
            if (delta_ < 2.0) {
                return - f0_ * boost::math::cdf(
                           nc_chi2(4.0-delta_, x0_/t), kTilde/t)
                       + strike * (1.0 - boost::math::cdf(
                           nc_chi2(2.0-delta_, kTilde/t), x0_/t));
            }
            else {
                return - f0_ * boost::math::cdf(
                           nc_chi2(delta_-2.0, kTilde/t), x0_/t)
                       + strike * (1.0 - boost::math::cdf(
                           nc_chi2(delta_, x0_/t), kTilde/t));
            }
        }
        else
            QL_FAIL("unknown option type");

    }

    AnalyticCEVEngine::AnalyticCEVEngine(Real f0,
                                         Real alpha,
                                         Real beta,
                                         Handle<YieldTermStructure> discountCurve)
    : calculator_(ext::make_shared<CEVCalculator>(f0, alpha, beta)),
      discountCurve_(std::move(discountCurve)) {
        registerWith(discountCurve_);
    }

    void AnalyticCEVEngine::calculate() const {

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European option");

        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        const Date exerciseDate = arguments_.exercise->lastDate();

        results_.value = calculator_->value(
                payoff->optionType(),
                payoff->strike(),
                discountCurve_->timeFromReference(exerciseDate))
            * discountCurve_->discount(exerciseDate);
    }

}
]]></document_content>
  </document>
  <document index="99">
    <source>vanilla/analyticdigitalamericanengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Neil Firth
 Copyright (C) 2004 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/americanpayoffatexpiry.hpp>
#include <ql/pricingengines/americanpayoffathit.hpp>
#include <ql/pricingengines/vanilla/analyticdigitalamericanengine.hpp>
#include <utility>

namespace QuantLib {

    AnalyticDigitalAmericanEngine::AnalyticDigitalAmericanEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void AnalyticDigitalAmericanEngine::calculate() const {

        ext::shared_ptr<AmericanExercise> ex =
            ext::dynamic_pointer_cast<AmericanExercise>(arguments_.exercise);
        QL_REQUIRE(ex, "non-American exercise given");
        QL_REQUIRE(ex->dates()[0] <=
                   process_->blackVolatility()->referenceDate(),
                   "American option with window exercise not handled yet");

        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        Real spot = process_->stateVariable()->value();
        QL_REQUIRE(spot > 0.0, "negative or null underlying given");

        Real variance =
            process_->blackVolatility()->blackVariance(ex->lastDate(),
                                                       payoff->strike());
        Rate dividendDiscount =
            process_->dividendYield()->discount(ex->lastDate());
        Rate riskFreeDiscount =
            process_->riskFreeRate()->discount(ex->lastDate());

        if(ex->payoffAtExpiry()) {
            AmericanPayoffAtExpiry pricer(spot, riskFreeDiscount,
                                          dividendDiscount, variance, 
                                          payoff, knock_in());
            results_.value = pricer.value();
        } else {
            AmericanPayoffAtHit pricer(spot, riskFreeDiscount,
                                       dividendDiscount, variance, payoff);
            results_.value = pricer.value();
            results_.delta = pricer.delta();
            results_.gamma = pricer.gamma();

            DayCounter rfdc = process_->riskFreeRate()->dayCounter();
            Time t = rfdc.yearFraction(
                                    process_->riskFreeRate()->referenceDate(),
                                    arguments_.exercise->lastDate());
            results_.rho = pricer.rho(t);
        }
    }

}

]]></document_content>
  </document>
  <document index="100">
    <source>vanilla/analyticdividendeuropeanengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/pricingengines/vanilla/analyticdividendeuropeanengine.hpp>
#include <utility>

namespace QuantLib {

    AnalyticDividendEuropeanEngine::AnalyticDividendEuropeanEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        DividendSchedule dividends)
    : process_(std::move(process)), dividends_(std::move(dividends)) {
        registerWith(process_);
    }

    void AnalyticDividendEuropeanEngine::calculate() const {

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European option");

        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        Date settlementDate = process_->riskFreeRate()->referenceDate();
        Real riskless = 0.0;
        Size i;
        for (i=0; i<dividends_.size(); i++) {
            const Date cashFlowDate = dividends_[i]->date();

            if (   cashFlowDate >= settlementDate
                && cashFlowDate <= arguments_.exercise->lastDate()) {

                riskless += dividends_[i]->amount() *
                    process_->riskFreeRate()->discount(cashFlowDate) /
                    process_->dividendYield()->discount(cashFlowDate);
            }
        }

        Real spot = process_->stateVariable()->value() - riskless;
        QL_REQUIRE(spot > 0.0,
                   "negative or null underlying after subtracting dividends");

        DiscountFactor dividendDiscount =
            process_->dividendYield()->discount(
                                             arguments_.exercise->lastDate());
        DiscountFactor riskFreeDiscount =
            process_->riskFreeRate()->discount(arguments_.exercise->lastDate());
        Real forwardPrice = spot * dividendDiscount / riskFreeDiscount;

        Real variance =
            process_->blackVolatility()->blackVariance(
                                              arguments_.exercise->lastDate(),
                                              payoff->strike());

        BlackCalculator black(payoff, forwardPrice, std::sqrt(variance),
                              riskFreeDiscount);

        results_.value = black.value();
        results_.delta = black.delta(spot);
        results_.gamma = black.gamma(spot);

        DayCounter rfdc = process_->riskFreeRate()->dayCounter();
        DayCounter dydc = process_->dividendYield()->dayCounter();
        DayCounter voldc = process_->blackVolatility()->dayCounter();
        Time t = voldc.yearFraction(
                                 process_->blackVolatility()->referenceDate(),
                                 arguments_.exercise->lastDate());
        results_.vega = black.vega(t);

        Real delta_theta = 0.0, delta_rho = 0.0;
        for (i = 0; i < dividends_.size(); i++) {
            Date d = dividends_[i]->date();

            if (   d >= settlementDate
                && d <= arguments_.exercise->lastDate()) {

                delta_theta -= dividends_[i]->amount() *
                  (  process_->riskFreeRate()->zeroRate(d,rfdc,Continuous,Annual).rate()
                   - process_->dividendYield()->zeroRate(d,dydc,Continuous,Annual).rate()) *
                  process_->riskFreeRate()->discount(d) /
                  process_->dividendYield()->discount(d);

                Time t = process_->time(d);
                delta_rho += dividends_[i]->amount() * t *
                             process_->riskFreeRate()->discount(t) /
                             process_->dividendYield()->discount(t);
            }
        }
        t = process_->time(arguments_.exercise->lastDate());
        try {
            results_.theta = black.theta(spot, t) +
                             delta_theta * black.delta(spot);
        } catch (Error&) {
            results_.theta = Null<Real>();
        }

        results_.rho = black.rho(t) +
                       delta_rho * black.delta(spot);
    }

}

]]></document_content>
  </document>
  <document index="101">
    <source>vanilla/analyticeuropeanengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <utility>

namespace QuantLib {

    AnalyticEuropeanEngine::AnalyticEuropeanEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    AnalyticEuropeanEngine::AnalyticEuropeanEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Handle<YieldTermStructure> discountCurve)
    : process_(std::move(process)), discountCurve_(std::move(discountCurve)) {
        registerWith(process_);
        registerWith(discountCurve_);
    }

    void AnalyticEuropeanEngine::calculate() const {

        // if the discount curve is not specified, we default to the
        // risk free rate curve embedded within the GBM process
        ext::shared_ptr<YieldTermStructure> discountPtr = 
            discountCurve_.empty() ? 
            process_->riskFreeRate().currentLink() :
            discountCurve_.currentLink();

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European option");

        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        Real variance =
            process_->blackVolatility()->blackVariance(
                                              arguments_.exercise->lastDate(),
                                              payoff->strike());
        DiscountFactor dividendDiscount =
            process_->dividendYield()->discount(
                                             arguments_.exercise->lastDate());
        DiscountFactor df = discountPtr->discount(arguments_.exercise->lastDate());
        DiscountFactor riskFreeDiscountForFwdEstimation =
            process_->riskFreeRate()->discount(arguments_.exercise->lastDate());
        Real spot = process_->stateVariable()->value();
        QL_REQUIRE(spot > 0.0, "negative or null underlying given");
        Real forwardPrice = spot * dividendDiscount / riskFreeDiscountForFwdEstimation;

        BlackCalculator black(payoff, forwardPrice, std::sqrt(variance),df);


        results_.value = black.value();
        results_.delta = black.delta(spot);
        results_.deltaForward = black.deltaForward();
        results_.elasticity = black.elasticity(spot);
        results_.gamma = black.gamma(spot);

        DayCounter rfdc  = discountPtr->dayCounter();
        DayCounter divdc = process_->dividendYield()->dayCounter();
        DayCounter voldc = process_->blackVolatility()->dayCounter();
        Time t = rfdc.yearFraction(process_->riskFreeRate()->referenceDate(),
                                   arguments_.exercise->lastDate());
        results_.rho = black.rho(t);

        t = divdc.yearFraction(process_->dividendYield()->referenceDate(),
                               arguments_.exercise->lastDate());
        results_.dividendRho = black.dividendRho(t);

        t = voldc.yearFraction(process_->blackVolatility()->referenceDate(),
                               arguments_.exercise->lastDate());
        results_.vega = black.vega(t);
        try {
            results_.theta = black.theta(spot, t);
            results_.thetaPerDay =
                black.thetaPerDay(spot, t);
        } catch (Error&) {
            results_.theta = Null<Real>();
            results_.thetaPerDay = Null<Real>();
        }

        results_.strikeSensitivity  = black.strikeSensitivity();
        results_.itmCashProbability = black.itmCashProbability();

        Real tte = process_->blackVolatility()->timeFromReference(arguments_.exercise->lastDate());
        results_.additionalResults["spot"] = spot;
        results_.additionalResults["dividendDiscount"] = dividendDiscount;
        results_.additionalResults["riskFreeDiscount"] = riskFreeDiscountForFwdEstimation;
        results_.additionalResults["forward"] = forwardPrice;
        results_.additionalResults["strike"] = payoff->strike();
        results_.additionalResults["volatility"] = Real(std::sqrt(variance / tte));
        results_.additionalResults["timeToExpiry"] = tte;
    }

}

]]></document_content>
  </document>
  <document index="102">
    <source>vanilla/analyticeuropeanvasicekengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Lew Wei Hao

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/integrals/simpsonintegral.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanvasicekengine.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        Real g_k(Real t, Real kappa){
            return (1 - std::exp(- kappa * t )) / kappa;
        }

        class integrand_vasicek {
          private:
            const Real sigma_s_;
            const Real sigma_r_;
            const Real correlation_;
            const Real kappa_;
            const Real T_;
          public:
            integrand_vasicek(Real sigma_s, Real sigma_r, Real correlation, Real kappa, Real T)
            : sigma_s_(sigma_s), sigma_r_(sigma_r), correlation_(correlation), kappa_(kappa), T_(T){}
            Real operator()(Real u) const {
                Real g = g_k(T_ - u, kappa_);
                return (sigma_s_ * sigma_s_) + (2 * correlation_ * sigma_s_ * sigma_r_ * g) + (sigma_r_ * sigma_r_ * g * g);
            }
        };

    }

    AnalyticBlackVasicekEngine::AnalyticBlackVasicekEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> blackProcess,
        ext::shared_ptr<Vasicek> vasicekProcess,
        Real correlation)
    : blackProcess_(std::move(blackProcess)), vasicekProcess_(std::move(vasicekProcess)),
      simpsonIntegral_(new SimpsonIntegral(1e-5, 1000)), correlation_(correlation) {
        registerWith(blackProcess_);
        registerWith(vasicekProcess_);
    }

    void AnalyticBlackVasicekEngine::calculate() const {
        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European option");

        ext::shared_ptr<StrikedTypePayoff> payoff =
                ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);

        QL_REQUIRE(payoff, "non-striked payoff given");

        CumulativeNormalDistribution f;

        Real t = 0;
        Real T = blackProcess_->riskFreeRate()->dayCounter().yearFraction(blackProcess_->riskFreeRate().currentLink()->referenceDate(),arguments_.exercise->lastDate());
        Real kappa = vasicekProcess_->a();
        Real S_t = blackProcess_->x0();
        Real K = payoff->strike();
        Real sigma_s = blackProcess_->blackVolatility()->blackVol(t, K);
        Real sigma_r = vasicekProcess_->sigma();
        Real r_t = vasicekProcess_->r0();

        Real zcb = vasicekProcess_->discountBond(t, T, r_t);
        Real epsilon = payoff->optionType() == Option::Call ? 1 : -1;
        Real upsilon = (*simpsonIntegral_)(integrand_vasicek(sigma_s, sigma_r, correlation_, kappa, T), t, T);
        Real d_positive = (std::log((S_t / K) / zcb) + upsilon / 2) / std::sqrt(upsilon);
        Real d_negative = (std::log((S_t / K) / zcb) - upsilon / 2) / std::sqrt(upsilon);
        Real n_d1 = f(epsilon * d_positive);
        Real n_d2 = f(epsilon * d_negative);

        results_.value = epsilon * ((S_t * n_d1) - (zcb * K * n_d2));
    }

}

]]></document_content>
  </document>
  <document index="103">
    <source>vanilla/analyticgjrgarchengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Yee Man Chan

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gjrgarchmodel.hpp
  \brief analytical approximation pricing engine for a GJR-GARCH option
  based on Edgeworth expansion
*/

#include <ql/pricingengines/vanilla/analyticgjrgarchengine.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/instruments/payoffs.hpp>
#include <cmath>

using std::exp;
using std::pow;

namespace QuantLib {


    AnalyticGJRGARCHEngine::AnalyticGJRGARCHEngine(
                              const ext::shared_ptr<GJRGARCHModel>& model)
    : GenericModelEngine<GJRGARCHModel,
                         VanillaOption::arguments,
                         VanillaOption::results>(model) {init_ = false;}

    void AnalyticGJRGARCHEngine::calculate() const {
        // this is a european option pricer
        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European option");

        // plain vanilla
        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        const ext::shared_ptr<GJRGARCHProcess>& process = model_->process();

        const Rate riskFreeDiscount = process->riskFreeRate()->discount(
                                            arguments_.exercise->lastDate());
        const Rate dividendDiscount = process->dividendYield()->discount(
                                            arguments_.exercise->lastDate());
        const Real spotPrice = process->s0()->value();
        QL_REQUIRE(spotPrice > 0.0, "negative or null underlying given");
        const Real strikePrice = payoff->strike();
        const Real term = process->time(arguments_.exercise->lastDate());
        Size T = Size(std::lround(process->daysPerYear()*term));
        Real r = -std::log(riskFreeDiscount/dividendDiscount)/(process->daysPerYear()*term);
        Real h1 = process->v0();
        Real b0 = process->omega();
        Real b2 = process->alpha();
        Real b1 = process->beta();
        Real b3 = process->gamma();
        Real la = process->lambda();
        Real N = CumulativeNormalDistribution()(la);
        Real n = std::exp(-la*la/2)/(M_SQRTPI*M_SQRT2);
        const Real s = spotPrice;
        const Real x = strikePrice;
        Real m1, m2, m3, v1, v2, v3, z1, z2, x1;
        Real ex, ex2, ex3, ex4;
        Real sEh = 0.0, sEh2 = 0.0, sEhh = 0.0, sEh1_2eh = 0.0;
        Real sEhhh = 0.0, sEh2h = 0.0, sEhh2 = 0.0, sEh3 = 0.0;
        Real sEh1_2eh2 = 0.0, sEh3_2eh = 0.0, sEh1_2ehh = 0.0, sEhh1_2eh = 0.0;
        Real sEhe2h = 0.0, sEh1_2eh1_2eh = 0.0;
        Real sEh3_2e3h = 0.0;
        Real SD1, SD2, SD3;
        Real ST1, ST2, ST3, ST4;
        Real SQ2, SQ4, SQ5;
        Size i, j, k;
        Real stdev, sigma, k3, k4;
        Real d, del, d_, C, A3, A4, Capp;
        bool constants_match = false;
        
        if (!init_ || b1 != b1_ || b2 != b2_ || b3 != b3_ || la != la_) {
            // compute the useful coefficients
            m1 = b1 + (b2+b3*N)*(1+la*la) + b3*la*n; // ok
            m2 = b1*b1 + b2*b2*(pow(la,4)+6*la*la+3)
                + (b3*b3+2*b2*b3)*( pow(la,4)*N
                                   +pow(la,3)*n+6*la*la*N+5*la*n+3*N)
                + 2*b1*b2*(1+la*la) + 2*b3*b1*(la*la*N+la*n+N); // ok
            m3 = pow(b1,3)
                + (3*b3*b3*b1+6*b1*b2*b3)*(pow(la,3)*n+5*la*n+3*N
                                           +pow(la,4)*N+6*la*la*N)
                + pow(b2,3)*(15+pow(la,6)+15*pow(la,4)+45*la*la)
                + (pow(b3,3)+3*b2*b2*b3+3*b3*b3*b2)
                *(pow(la,5)*n+14*pow(la,3)*n+33*la*n+15*N
                  +15*pow(la,4)*N+45*la*la*N+pow(la,6)*N)
                + 3*b1*b1*b2*(1+la*la) + 3*b1*b1*b3*(la*n+N+la*la*N)
                + 3*b1*b2*b2*(3+pow(la,4)+6*la*la); // ok
            v1 = -2*b2*la - 2*b3*(n+la*N); // ok
            v2 = -4*b2*b2*(3*la+pow(la,3))
                - (4*b3*b3+8*b2*b3)*(la*la*n+2*n+pow(la,3)*N+3*la*N)
                - 4*b1*b2*la - 4*b3*b1*(n+la*N); // ok
            v3 = -12*b3*b1*(b3+2*b2)*(la*la*n+2*n+pow(la,3)*N+3*la*N)
                - 6*pow(b2,3)*la*(15+pow(la,4)+10*la*la)
                - 6*b3*(b3*b3+3*b2*b2+3*b3*b2)
                *(9*la*la*n+8*n+15*la*N+pow(la,4)*n+pow(la,5)*N
                  +10*pow(la,3)*N)
                - 6*b1*b1*b2*la - 6*b3*b1*b1*(n+la*N)
                - 12*b2*b2*b1*(3*la+std::pow(la,3)); // ok
            z1 = b1 + b2*(3+la*la) + b3*(la*n+3*N+la*la*N); // ok
            z2 = b1*b1 + b2*b2*(15+pow(la,4)+18*la*la)
                + (b3*b3+2*b2*b3)*(pow(la,3)*n+17*la*n+15*N
                                   +pow(la,4)*N+18*la*la*N)
                + 2*b1*b2*(3+la*la) + 2*b3*b1*(la*n+3*N+la*la*N); // ok
            x1 = -6*b2*la - 2*b3*(4*n+3*la*N); // ok
            b1_ = b1; b2_ = b2; b3_ = b3; la_ = la;
            m1_ = m1; m2_ = m2; m3_ = m3; 
            v1_ = v1; v2_ = v2; v3_ = v3; z1_ = z1; z2_ = z2; x1_ = x1;
        } else {
            // these assignments are never used ?
            // b1 = b1_; b2 = b2_; b3 = b3_; la = la_;
            // m1 = m1_; m2 = m2_; m3 = m3_;
            // v1 = v1_; v2 = v2_; v3 = v3_; z1 = z1_; z2 = z2_; x1 = x1_;
            constants_match = true;
        }
        
        // compute the first four moments
        if (!init_ || !constants_match || b0 != b0_ || h1 != h1_ || T != T_) {
            // these assignments are never used ?
            //b1 = b1_; b2 = b2_; b3 = b3_; la = la_;
            m1 = m1_; m2 = m2_; m3 = m3_; 
            v1 = v1_; v2 = v2_; /*v3 = v3_;*/ z1 = z1_; /*z2 = z2_;*/ x1 = x1_;

            std::unique_ptr<Real[]> m1ai(new Real[T]);
            std::unique_ptr<Real[]> m2ai(new Real[T]);
            std::unique_ptr<Real[]> m3ai(new Real[T]);
            m1ai[0] = m2ai[0] = m3ai[0] = 1.0;
            for (i=1; i < T; ++i) {
                m1ai[i] = m1ai[i-1]*m1;
                m2ai[i] = m2ai[i-1]*m2;
                m3ai[i] = m3ai[i-1]*m3;
            }

            for (i = 0; i < T; ++i) {
                Real m1i = m1ai[i];
                Real m2i = m2ai[i];
                Real m3i = m3ai[i];

                Real m1im2i = m1i-m2i, m1im3i = m1i-m3i, m2im3i = m2i-m3i;
                Real Eh = b0*(1-m1i)/(1-m1) + m1i*h1; // ko
                Real Eh2 = b0*b0*((1+m1)*(1-m2i)/(1-m2)
                                  - 2*m1*m1im2i/(m1-m2))/(1-m1)
                    + 2*b0*m1*m1im2i*h1/(m1-m2)
                    + m2i*h1*h1; // ko
                Real Eh3 = pow(b0,3)*(
                    (1-m3i)/(1-m3)
                    + 3*m2*((1-m3i)/(1-m3)-m2im3i/(m2-m3))/(1-m2) 
                    + 3*m1*((1-m3i)/(1-m3)-m1im3i/(m1-m3))/(1-m1) 
                    + 6*m1*m2*(
                               ((1-m3i)/(1-m3)-m2im3i/(m2-m3))/(1-m2)
                               + (m2im3i/(m2-m3)-m1im3i/(m1-m3))/(m1-m2)
                               )/(1-m1))
                    + 3*b0*b0*m1*h1*(m1im3i/(m1-m3)
                                +2*m2*(m1im3i/(m1-m3)-m2im3i/(m2-m3))/(m1-m2))
                    + 3*b0*m2*h1*h1*m2im3i/(m2-m3) 
                    + m3i*h1*h1*h1; // ko
                Real Eh3_2 = .375*std::pow(Eh,-0.5)*Eh2+.625*std::pow(Eh,1.5);
                Real Eh5_2 = 1.875*std::pow(Eh,0.5)*Eh2-.875*std::pow(Eh,2.5);
                sEh += Eh;
                sEh2 += Eh2;
                sEh3 += Eh3;
                for (j = 0; j < T-i-1; ++j) {
                    Real Ehh = b0*Eh*(1-m1ai[j+1])/(1-m1)+ Eh2*m1ai[j+1]; // ko
                    Real Ehh2 = b0*b0*Eh*((1+m1)*(1-m2ai[j+1])/(1-m2) 
                                  - 2*m1*(m1ai[j+1]
                                          -m2ai[j+1])/(m1-m2))/(1-m1)
                        + 2*b0*m1*Eh2*(m1ai[j+1]-m2ai[j+1])/(m1-m2)
                        + m2ai[j+1]*Eh3; // ko
                    Real Eh2h = b0*Eh2*(1-m1ai[j+1])/(1-m1) 
                        + m1ai[j+1]*Eh3; // ok
                    Real Eh1_2eh = v1*m1ai[j]*Eh3_2; // ko
                    Real Eh1_2eh2 = 2*b0*v1*(m1ai[j+1]
                                             -m2ai[j+1])*Eh3_2/(m1-m2) 
                        + v2*m2ai[j]*Eh5_2; // ko
                    Real Ehij = b0*(1-m1ai[i+j+1])/(1-m1) 
                        + m1ai[i+j+1]*h1; // ko
                    Real Ehh3_2 = 0.375*Ehh2/std::sqrt(Ehij) 
                        + 0.75*std::sqrt(Ehij)*Ehh 
                        - 0.125*std::pow(Ehij,1.5)*Eh; // ko
                    Real Eh3_2eh = v1*m1ai[j]*Eh5_2; // ko
                    Real Eh3_2e3h = x1*m1ai[j]*Eh5_2; // ok
                    Real Eh1_2eh3_2 = 0.375*Eh1_2eh2/std::sqrt(Ehij) 
                        + 0.75*std::sqrt(Ehij)*Eh1_2eh; // ko
                    sEhh += Ehh;
                    sEh1_2eh += Eh1_2eh;
                    sEhh2 += Ehh2; 
                    sEh2h += Eh2h;
                    sEh1_2eh2 += Eh1_2eh2;
                    sEh3_2eh += Eh3_2eh;
                    sEhe2h += b0*Eh*(1-m1ai[j+1])/(1-m1) 
                        + z1*m1ai[j]*Eh2; // ko
                    sEh3_2e3h += Eh3_2e3h; // ok
                    for (k = 0; k < T-i-j-2; ++k) {
                        Real Ehhh = b0*Ehh*(1-m1ai[k+1])/(1-m1) 
                            + m1ai[k+1]*Ehh2; //ko
                        Real Eh1_2ehh = b0*Eh1_2eh*(1-m1ai[k+1])/(1-m1) 
                            + m1ai[k+1]*Eh1_2eh2; // ko
                        sEhhh += Ehhh;
                        sEh1_2ehh += Eh1_2ehh;
                        sEhh1_2eh += v1*m1ai[k]*Ehh3_2; // ko
                        sEh1_2eh1_2eh += v1*m1ai[k]*Eh1_2eh3_2; // ko
                    }
                }
            }
            
            ex = T*r - 0.5*sEh; 
            SD1 = 2*sEhh + sEh2;
            SD2 = sEh;
            SD3 = sEh1_2eh;
            ex2 = T*T*r*r - T*r*sEh + 0.25*SD1 + SD2 - SD3;
            ST1 = 6*sEhhh + (3*sEhh2 + (3*sEh2h + sEh3));
            ST2 = 3*sEh1_2eh;
            ST3 = 2*sEhh1_2eh + (2*sEh1_2ehh + (2*sEh3_2eh + sEh1_2eh2));
            ST4 = sEhe2h + (sEhh + (sEh2 + 2*sEh1_2eh1_2eh)); 
            ex3 = pow(T*r,3) - 1.5*T*T*r*r*sEh 
                + 3*T*r*(SD1/4+SD2-SD3) + (ST2-ST1/8+3*ST3/4-3*ST4/2);
            SQ2 = 6*sEhe2h + (12*sEh1_2eh1_2eh + 3*sEh2);     
            SQ4 = 2*sEhhh + 2*sEhh2;
            SQ5 = 3*sEhh1_2eh + 3*sEh1_2ehh + 3*sEh3_2eh 
                + 3*sEh1_2eh2 + sEh3_2e3h;
            ex4 = pow(T*r,4) - 2*pow(T*r,3)*sEh 
                + 6*T*T*r*r*(SD1/4+SD2-SD3) + T*r*(4*ST2-ST1/2+3*ST3-6*ST4) 
                + (SQ2+3*SQ4/2-2*SQ5);
            
            // compute variance, skewness, kurtosis
            sigma = ex2 - ex*ex;
            // 3rd central moment mu3
            k3 = ex3 - 3*sigma*ex - ex*ex*ex;
            // 4th central moment mu4
            k4 = ex4 + 6*ex*ex*ex2 - 3*ex*ex*ex*ex - 4*ex*ex3;
            k3 /= std::pow(sigma,1.5); // 3rd standardized moment, ie skewness 
            k4 /= pow(sigma,2); // 4th standardized moment, ie kurtosis
            ex_ = ex; sigma_ = sigma; 
            k3_ = k3; k4_ = k4; r_ = r; T_ = T; b0_ = b0; h1_ = h1;
        } else {
            ex = ex_; sigma = sigma_; 
            k3 = k3_; k4 = k4_; r = r_; T = T_; /*b0 = b0_; h1 = h1_;*/ // never used ?
        }
        
        // compute call option price
        stdev = std::sqrt(sigma);
        del = (ex - r*T + sigma/2)/stdev;
        d = (std::log(s/x) + (r*T+sigma/2))/stdev;
        d_ = d+del;
        C = s*std::exp(del*stdev)*CumulativeNormalDistribution()(d_) 
            - x*std::exp(-r*T)*CumulativeNormalDistribution()(d_-stdev);
        A3 = s*std::exp(del*stdev)*stdev*((2*stdev-d_)
                   *std::exp(-d_*d_/2)/std::sqrt(2*M_PI)
                   +sigma*CumulativeNormalDistribution()(d_))/6;
        A4 = s*std::exp(del*stdev)*stdev*(
            (d_*d_-1-3*stdev*(d_-stdev))*exp(-d_*d_/2)/std::sqrt(2*M_PI)
            -sigma*stdev*CumulativeNormalDistribution()(d_))/24;
        Capp = C + k3*A3 + (k4-3)*A4;
        init_ = true;

        switch (payoff->optionType()) {
          case Option::Call:
            results_.value = Capp;
            break;
          case Option::Put:
            results_.value = Capp+strikePrice*riskFreeDiscount/dividendDiscount
                -spotPrice;
            break;
          default:
            QL_FAIL("unknown option type");
        }
    }   
}
]]></document_content>
  </document>
  <document index="104">
    <source>vanilla/analytich1hwengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analytichestonengine.cpp
    \brief analytic Heston-Hull-White engine based on the H1-HW approximation
*/

#include <ql/math/distributions/gammadistribution.hpp>
#include <ql/pricingengines/vanilla/analytich1hwengine.hpp>

namespace QuantLib {
    // integration helper class
    class AnalyticH1HWEngine::Fj_Helper {

      public:
        Fj_Helper(const Handle<HestonModel>& hestonModel,
                  const ext::shared_ptr<HullWhite>& hullWhiteModel,
                  Real rho_xr, Time term, Real strike, Size j);

        std::complex<Real> operator()(Real u) const;

      private:
        Real c(Time t) const;
        Real lambda(Time t) const;
        Real Lambda(Time t) const;
        Real LambdaApprox(Time t) const;

        const Size j_;
        const Real lambda_, eta_;
        const Real v0_, kappa_, theta_, gamma_;
        const Real d_;
        const Real rhoSr_;
        const Time term_;
    };

    AnalyticH1HWEngine::Fj_Helper::Fj_Helper(
        const Handle<HestonModel>& hestonModel,
        const ext::shared_ptr<HullWhite>& hullWhiteModel,
        Real rhoSr, Time term, Real, Size j)
    : j_     (j),
      lambda_(hullWhiteModel->a()),
      eta_   (hullWhiteModel->sigma()),
      v0_    (hestonModel->v0()),
      kappa_ (hestonModel->kappa()),
      theta_ (hestonModel->theta()),
      gamma_ (hestonModel->sigma()),
      d_     (4.0*kappa_*theta_/(gamma_*gamma_)),
      rhoSr_ (rhoSr),
      term_  (term) {
    }

    Real AnalyticH1HWEngine::Fj_Helper::c(Time t) const {
        return gamma_*gamma_/(4*kappa_)*(1.0-std::exp(-kappa_*t));
    }

    Real AnalyticH1HWEngine::Fj_Helper::lambda(Time t) const {
        return  4.0*kappa_*v0_*std::exp(-kappa_*t)
               /(gamma_*gamma_*(1.0-std::exp(-kappa_*t)));
    }

    Real AnalyticH1HWEngine::Fj_Helper::LambdaApprox(Time t) const {
        return std::sqrt( c(t)*(lambda(t)-1.0)
                        + c(t)*d_*(1.0 + 1.0/(2.0*(d_+lambda(t)))));
    }

    Real AnalyticH1HWEngine::Fj_Helper::Lambda(Time t) const {
        const GammaFunction g = GammaFunction();
        const Size maxIter = 1000;
        const Real lambdaT = lambda(t);

        Size i=0;
        Real retVal = 0.0, s;

        do {
            Real k = static_cast<Real>(i);
            s=std::exp(k*std::log(0.5*lambdaT) + g.logValue(0.5*(1+d_)+k)
                        - g.logValue(k+1) - g.logValue(0.5*d_+k));
            retVal += s;
        } while (s > std::numeric_limits<float>::epsilon() && ++i < maxIter);

        QL_REQUIRE(i < maxIter, "can not calculate Lambda");

        retVal *= std::sqrt(2*c(t)) * std::exp(-0.5*lambdaT);
        return retVal;
    }

    std::complex<Real> AnalyticH1HWEngine::Fj_Helper::operator()(Real u) const {

        const Real gamma2 = gamma_*gamma_;

        Real a, b, c;
        if (8.0*kappa_*theta_/gamma2 > 1.0) {
            a = std::sqrt(theta_-gamma2/(8.0*kappa_));
            b = std::sqrt(v0_) - a;
            c =-std::log((LambdaApprox(1.0)-a)/b);
        }
        else {
            a = std::sqrt(gamma2/(2.0*kappa_))
                *std::exp(  GammaFunction().logValue(0.5*(d_+1.0))
                          - GammaFunction().logValue(0.5*d_));

            const Time t1 = 0.0;
            const Time t2 = 1.0/kappa_;

            const Real Lambda_t1 = std::sqrt(v0_);
            const Real Lambda_t2 = Lambda(t2);

            c = std::log((Lambda_t2-a)/(Lambda_t1-a))/(t1-t2);
            b = std::exp(c*t1)*(Lambda_t1-a);
        }

        const std::complex<Real> I4 =
            -1.0 / lambda_ * std::complex<Real>(u * u, ((j_ == 1U) ? -u : u)) *
            (b / c * (1.0 - std::exp(-c * term_)) + a * term_ +
             a / lambda_ * (std::exp(-lambda_ * term_) - 1.0) +
             b / (c - lambda_) * std::exp(-c * term_) * (1.0 - std::exp(-term_ * (lambda_ - c))));

        return eta_*rhoSr_*I4;
    }


    AnalyticH1HWEngine::AnalyticH1HWEngine(
        const ext::shared_ptr<HestonModel>& model,
        const ext::shared_ptr<HullWhite>& hullWhiteModel,
        Real rhoSr, Size integrationOrder)
    : AnalyticHestonHullWhiteEngine(model, hullWhiteModel, integrationOrder),
      rhoSr_(rhoSr) {
        QL_REQUIRE(rhoSr_ >= 0.0, "Fourier integration is not stable if "
                    "the equity interest rate correlation is negative");
    }

    AnalyticH1HWEngine::AnalyticH1HWEngine(
        const ext::shared_ptr<HestonModel>& model,
        const ext::shared_ptr<HullWhite>& hullWhiteModel,
        Real rhoSr, Real relTolerance, Size maxEvaluations)
    : AnalyticHestonHullWhiteEngine(model, hullWhiteModel,
                                    relTolerance, maxEvaluations),
      rhoSr_(rhoSr) {
    }

    std::complex<Real> AnalyticH1HWEngine::addOnTerm(Real u, Time t, Size j)
    const {
        return AnalyticHestonHullWhiteEngine::addOnTerm(u, t, j)
               + Fj_Helper(model_, hullWhiteModel_, rhoSr_, t, 0.0, j)(u);
    }
}

]]></document_content>
  </document>
  <document index="105">
    <source>vanilla/analytichestonengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2005, 2008 Klaus Spanderen
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hestonmodel.hpp
  \brief analytic pricing engine for a heston option
  based on fourier transformation
*/

#include <ql/instruments/payoffs.hpp>
#include <ql/math/integrals/discreteintegrals.hpp>
#include <ql/math/integrals/exponentialintegrals.hpp>
#include <ql/math/integrals/gausslobattointegral.hpp>
#include <ql/math/integrals/kronrodintegral.hpp>
#include <ql/math/integrals/simpsonintegral.hpp>
#include <ql/math/integrals/trapezoidintegral.hpp>
#include <ql/math/integrals/expsinhintegral.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/math/expm1.hpp>
#include <ql/math/functional.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/pricingengines/vanilla/analytichestonengine.hpp>
#include <boost/math/tools/minima.hpp>
#include <boost/math/special_functions/sign.hpp>
#include <functional>
#include <cmath>
#include <limits>
#include <utility>

#if defined(QL_PATCH_MSVC)
#pragma warning(disable: 4180)
#endif

namespace QuantLib {

    namespace {

        class integrand1 {
          private:
            const Real c_inf_;
            const std::function<Real(Real)> f_;
          public:
            integrand1(Real c_inf, std::function<Real(Real)> f) : c_inf_(c_inf), f_(std::move(f)) {}
            Real operator()(Real x) const {
                if ((1.0-x)*c_inf_ > QL_EPSILON)
                    return f_(-std::log(0.5-0.5*x)/c_inf_)/((1.0-x)*c_inf_);
                else
                    return 0.0;
            }
        };

        class integrand2 {
          private:
            const Real c_inf_;
            const std::function<Real(Real)> f_;
          public:
            integrand2(Real c_inf, std::function<Real(Real)> f) : c_inf_(c_inf), f_(std::move(f)) {}
            Real operator()(Real x) const {
                if (x*c_inf_ > QL_EPSILON) {
                    return f_(-std::log(x)/c_inf_)/(x*c_inf_);
                } else {
                    return 0.0;
                }
            }
        };

        class integrand3 {
          private:
            const integrand2 int_;
          public:
            integrand3(Real c_inf, const std::function<Real(Real)>& f)
            : int_(c_inf, f) {}

            Real operator()(Real x) const { return int_(1.0-x); }
        };

        class u_Max {
          public:
            u_Max(Real c_inf, Real epsilon) : c_inf_(c_inf), logEpsilon_(std::log(epsilon)) {}

            Real operator()(Real u) const {
                ++evaluations_;
                return c_inf_*u + std::log(u) + logEpsilon_;
            }

            Size evaluations() const { return evaluations_; }

          private:
            const Real c_inf_, logEpsilon_;
            mutable Size evaluations_ = 0;
        };


        class uHat_Max {
          public:
            uHat_Max(Real v0T2, Real epsilon) : v0T2_(v0T2), logEpsilon_(std::log(epsilon)) {}

            Real operator()(Real u) const {
                ++evaluations_;
                return v0T2_*u*u + std::log(u) + logEpsilon_;
            }

            Size evaluations() const { return evaluations_; }

          private:
            const Real v0T2_, logEpsilon_;
            mutable Size evaluations_ = 0;
        };
    }

    // helper class for integration
    class AnalyticHestonEngine::Fj_Helper {
    public:
      Fj_Helper(Real kappa, Real theta, Real sigma, Real v0,
                Real s0, Real rho,
                const AnalyticHestonEngine* engine,
                ComplexLogFormula cpxLog,
                Time term, Real strike, Real ratio, Size j);

      Real operator()(Real phi) const;

    private:
        const Size j_;
        //     const VanillaOption::arguments& arg_;
        const Real kappa_, theta_, sigma_, v0_;
        const ComplexLogFormula cpxLog_;

        // helper variables
        const Time term_;
        const Real x_, sx_, dd_;
        const Real sigma2_, rsigma_;
        const Real t0_;

        // log branch counter
        mutable int  b_ = 0;     // log branch counter
        mutable Real g_km1_ = 0; // imag part of last log value

        const AnalyticHestonEngine* const engine_;
    };

    AnalyticHestonEngine::Fj_Helper::Fj_Helper(Real kappa, Real theta,
        Real sigma, Real v0, Real s0, Real rho,
        const AnalyticHestonEngine* const engine,
        ComplexLogFormula cpxLog,
        Time term, Real strike, Real ratio, Size j)
        :
        j_(j),
        kappa_(kappa),
        theta_(theta),
        sigma_(sigma),
        v0_(v0),
        cpxLog_(cpxLog),
        term_(term),
        x_(std::log(s0)),
        sx_(std::log(strike)),
        dd_(x_-std::log(ratio)),
        sigma2_(sigma_*sigma_),
        rsigma_(rho*sigma_),
        t0_(kappa - ((j== 1)? rho*sigma : Real(0))),

        engine_(engine)
    {
    }

    Real AnalyticHestonEngine::Fj_Helper::operator()(Real phi) const
    {
        const Real rpsig(rsigma_*phi);

        const std::complex<Real> t1 = t0_+std::complex<Real>(0, -rpsig);
        const std::complex<Real> d =
            std::sqrt(t1*t1 - sigma2_*phi
                      *std::complex<Real>(-phi, (j_== 1)? 1 : -1));
        const std::complex<Real> ex = std::exp(-d*term_);
        const std::complex<Real> addOnTerm =
            engine_ != nullptr ? engine_->addOnTerm(phi, term_, j_) : Real(0.0);

        if (cpxLog_ == Gatheral) {
            if (phi != 0.0) {
                if (sigma_ > 1e-5) {
                    const std::complex<Real> p = (t1-d)/(t1+d);
                    const std::complex<Real> g
                                            = std::log((1.0 - p*ex)/(1.0 - p));

                    return
                        std::exp(v0_*(t1-d)*(1.0-ex)/(sigma2_*(1.0-ex*p))
                                 + (kappa_*theta_)/sigma2_*((t1-d)*term_-2.0*g)
                                 + std::complex<Real>(0.0, phi*(dd_-sx_))
                                 + addOnTerm
                                 ).imag()/phi;
                }
                else {
                    const std::complex<Real> td = phi/(2.0*t1)
                                   *std::complex<Real>(-phi, (j_== 1)? 1 : -1);
                    const std::complex<Real> p = td*sigma2_/(t1+d);
                    const std::complex<Real> g = p*(1.0-ex);

                    return
                        std::exp(v0_*td*(1.0-ex)/(1.0-p*ex)
                                 + (kappa_*theta_)*(td*term_-2.0*g/sigma2_)
                                 + std::complex<Real>(0.0, phi*(dd_-sx_))
                                 + addOnTerm
                                 ).imag()/phi;
                }
            }
            else {
                // use l'Hospital's rule to get lim_{phi->0}
                if (j_ == 1) {
                    const Real kmr = rsigma_-kappa_;
                    if (std::fabs(kmr) > 1e-7) {
                        return dd_-sx_
                            + (std::exp(kmr*term_)*kappa_*theta_
                               -kappa_*theta_*(kmr*term_+1.0) ) / (2*kmr*kmr)
                            - v0_*(1.0-std::exp(kmr*term_)) / (2.0*kmr);
                    }
                    else
                        // \kappa = \rho * \sigma
                        return dd_-sx_ + 0.25*kappa_*theta_*term_*term_
                                       + 0.5*v0_*term_;
                }
                else {
                    return dd_-sx_
                        - (std::exp(-kappa_*term_)*kappa_*theta_
                           +kappa_*theta_*(kappa_*term_-1.0))/(2*kappa_*kappa_)
                        - v0_*(1.0-std::exp(-kappa_*term_))/(2*kappa_);
                }
            }
        }
        else if (cpxLog_ == BranchCorrection) {
            const std::complex<Real> p = (t1+d)/(t1-d);

            // next term: g = std::log((1.0 - p*std::exp(d*term_))/(1.0 - p))
            std::complex<Real> g;

            // the exp of the following expression is needed.
            const std::complex<Real> e = std::log(p)+d*term_;

            // does it fit to the machine precision?
            if (std::exp(-e.real()) > QL_EPSILON) {
                g = std::log((1.0 - p/ex)/(1.0 - p));
            } else {
                // use a "big phi" approximation
                g = d*term_ + std::log(p/(p - 1.0));

                if (g.imag() > M_PI || g.imag() <= -M_PI) {
                    // get back to principal branch of the complex logarithm
                    Real im = std::fmod(g.imag(), 2*M_PI);
                    if (im > M_PI)
                        im -= 2*M_PI;
                    else if (im <= -M_PI)
                        im += 2*M_PI;

                    g = std::complex<Real>(g.real(), im);
                }
            }

            // be careful here as we have to use a log branch correction
            // to deal with the discontinuities of the complex logarithm.
            // the principal branch is not always the correct one.
            // (s. A. Sepp, chapter 4)
            // remark: there is still the change that we miss a branch
            // if the order of the integration is not high enough.
            const Real tmp = g.imag() - g_km1_;
            if (tmp <= -M_PI)
                ++b_;
            else if (tmp > M_PI)
                --b_;

            g_km1_ = g.imag();
            g += std::complex<Real>(0, 2*b_*M_PI);

            return std::exp(v0_*(t1+d)*(ex-1.0)/(sigma2_*(ex-p))
                            + (kappa_*theta_)/sigma2_*((t1+d)*term_-2.0*g)
                            + std::complex<Real>(0,phi*(dd_-sx_))
                            + addOnTerm
                            ).imag()/phi;
        }
        else {
            QL_FAIL("unknown complex logarithm formula");
        }
    }

    AnalyticHestonEngine::OptimalAlpha::OptimalAlpha(
        const Time t,
        const AnalyticHestonEngine* const enginePtr)
    : t_(t),
      fwd_(enginePtr->model_->process()->s0()->value()
              * enginePtr->model_->process()->dividendYield()->discount(t)
              / enginePtr->model_->process()->riskFreeRate()->discount(t)),
      kappa_(enginePtr->model_->kappa()),
      theta_(enginePtr->model_->theta()),
      sigma_(enginePtr->model_->sigma()),
      rho_(enginePtr->model_->rho()),
      eps_(std::pow(2, -int(0.5*std::numeric_limits<Real>::digits))),
      enginePtr_(enginePtr)
      {
        km_ = k(0.0, -1);
        kp_ = k(0.0,  1);
    }

    Real AnalyticHestonEngine::OptimalAlpha::alphaMax(Real strike) const {
        const Real eps = 1e-8;
        const auto cm = [this](Real k) -> Real { return M(k) - t_; };

        Real alpha_max;
        const Real adx = kappa_ - sigma_*rho_;
        if (adx > 0.0) {
            const Real kp_2pi = k(2*M_PI, 1);

            alpha_max = Brent().solve(
                cm, eps_, 0.5*(kp_ + kp_2pi), (1+eps)*kp_, (1-eps)*kp_2pi
            ) - 1.0;
        }
        else if (adx < 0.0) {
            const Time tCut = -2/(kappa_ - sigma_*rho_*kp_);
            if (t_ < tCut) {
                const Real kp_pi = k(M_PI, 1);
                alpha_max = Brent().solve(
                    cm, eps_, 0.5*(kp_ + kp_pi), (1+eps)*kp_, (1-eps)*kp_pi
                ) - 1.0;
            }
            else {
                alpha_max = Brent().solve(
                    cm, eps_, 0.5*(1.0 + kp_),
                    1 + eps, (1-eps)*kp_
                ) - 1.0;
            }
        }
        else { // adx == 0.0
            const Real kp_pi = k(M_PI, 1);
            alpha_max = Brent().solve(
                cm, eps_, 0.5*(kp_ + kp_pi), (1+eps)*kp_, (1-eps)*kp_pi
            ) - 1.0;
        }

        QL_REQUIRE(alpha_max >= 0.0, "alpha max must be larger than zero");

        return alpha_max;
    }

    std::pair<Real, Real>
    AnalyticHestonEngine::OptimalAlpha::alphaGreaterZero(Real strike) const {
        const Real alpha_max = alphaMax(strike);

        return findMinima(eps_, std::max(2*eps_, (1.0-1e-6)*alpha_max), strike);
    }

    Real AnalyticHestonEngine::OptimalAlpha::alphaMin(Real strike) const {
        const auto cm = [this](Real k) -> Real { return M(k) - t_; };

        const Real km_2pi = k(2*M_PI, -1);

        const Real alpha_min = Brent().solve(
            cm, eps_, 0.5*(km_2pi + km_), (1-1e-8)*km_2pi, (1+1e-8)*km_
        ) - 1.0;

        QL_REQUIRE(alpha_min <= -1.0, "alpha min must be smaller than minus one");

        return alpha_min;
    }

    std::pair<Real, Real>
    AnalyticHestonEngine::OptimalAlpha::alphaSmallerMinusOne(Real strike) const {
        const Real alpha_min = alphaMin(strike);

        return findMinima(
            std::min(-1.0-1e-6, -1.0 + (1.0-1e-6)*(alpha_min + 1.0)),
            -1.0 - eps_, strike
        );
    }

    Real AnalyticHestonEngine::OptimalAlpha::operator()(Real strike) const {
        try {
            const std::pair<Real, Real> minusOne = alphaSmallerMinusOne(strike);
            const std::pair<Real, Real> greaterZero = alphaGreaterZero(strike);

            if (minusOne.second < greaterZero.second) {
                return minusOne.first;
            }
            else {
                return greaterZero.first;
            }
        }
        catch (const Error&) {
            return -0.5;
        }

    }

    Size AnalyticHestonEngine::OptimalAlpha::numberOfEvaluations() const {
        return evaluations_;
    }

    std::pair<Real, Real> AnalyticHestonEngine::OptimalAlpha::findMinima(
        Real lower, Real upper, Real strike) const {
        const Real freq = std::log(fwd_/strike);

        return boost::math::tools::brent_find_minima(
            [freq, this](Real alpha) -> Real {
                ++evaluations_;
                const std::complex<Real> z(0, -(alpha+1));
                return enginePtr_->lnChF(z, t_).real()
                    - std::log(alpha*(alpha+1)) + alpha*freq;
            },
            lower, upper, int(0.5*std::numeric_limits<Real>::digits)
        );
    }

    Real AnalyticHestonEngine::OptimalAlpha::M(Real k) const {
        const Real beta = kappa_ - sigma_*rho_*k;

        if (k >= km_ && k <= kp_) {
            const Real D = std::sqrt(beta*beta - sigma_*sigma_*k*(k-1));
            return std::log((beta-D)/(beta+D)) / D;
        }
        else {
            const Real D_imag =
                std::sqrt(-(beta*beta - sigma_*sigma_*k*(k-1)));

            return 2/D_imag
                * ( ((beta>0.0)? M_PI : 0.0) - std::atan(D_imag/beta) );
        }
    }

    Real AnalyticHestonEngine::OptimalAlpha::k(Real x, Integer sgn) const {
        return ( (sigma_ - 2*rho_*kappa_)
                + sgn*std::sqrt(
                      squared(sigma_-2*rho_*kappa_)
                    + 4*(kappa_*kappa_ + x*x/(t_*t_))*(1-rho_*rho_)))
               /(2*sigma_*(1-rho_*rho_));
    }

    AnalyticHestonEngine::AP_Helper::AP_Helper(
        Time term, Real fwd, Real strike, ComplexLogFormula cpxLog,
        const AnalyticHestonEngine* const enginePtr,
        const Real alpha)
    : term_(term),
      fwd_(fwd),
      strike_(strike),
      freq_(std::log(fwd/strike)),
      cpxLog_(cpxLog),
      enginePtr_(enginePtr),
      alpha_(alpha),
      s_alpha_(std::exp(alpha*freq_))
      {
        QL_REQUIRE(enginePtr != nullptr, "pricing engine required");

        const Real v0    = enginePtr->model_->v0();
        const Real kappa = enginePtr->model_->kappa();
        const Real theta = enginePtr->model_->theta();
        const Real sigma = enginePtr->model_->sigma();
        const Real rho   = enginePtr->model_->rho();

        switch(cpxLog_) {
          case AndersenPiterbarg:
              vAvg_ = (1-std::exp(-kappa*term))*(v0 - theta)
                        /(kappa*term) + theta;
            break;
          case AndersenPiterbargOptCV:
              vAvg_ = -8.0*std::log(enginePtr->chF(
                         std::complex<Real>(0, alpha_), term).real())/term;
            break;
          case AsymptoticChF:
            phi_ = -(v0+term*kappa*theta)/sigma
                * std::complex<Real>(std::sqrt(1-rho*rho), rho);

            psi_ = std::complex<Real>(
                (kappa- 0.5*rho*sigma)*(v0 + term*kappa*theta)
                + kappa*theta*std::log(4*(1-rho*rho)),
                - ((0.5*rho*rho*sigma - kappa*rho)/std::sqrt(1-rho*rho)
                        *(v0 + kappa*theta*term)
                  - 2*kappa*theta*std::atan(rho/std::sqrt(1-rho*rho))))
                          /(sigma*sigma);
            [[fallthrough]];
          case AngledContour:
            vAvg_ = (1-std::exp(-kappa*term))*(v0 - theta)
                      /(kappa*term) + theta;
            [[fallthrough]];
          case AngledContourNoCV:
            {
              const Real r = rho - sigma*freq_ / (v0 + kappa*theta*term);
              tanPhi_ = std::tan(
                     (r*freq_ < 0.0)? M_PI/12*boost::math::sign(freq_) : 0.0
                );
            }
            break;
          default:
            QL_FAIL("unknown control variate");
        }
    }

    Real AnalyticHestonEngine::AP_Helper::operator()(Real u) const {
        QL_REQUIRE(   enginePtr_->addOnTerm(u, term_, 1)
                        == std::complex<Real>(0.0)
                   && enginePtr_->addOnTerm(u, term_, 2)
                        == std::complex<Real>(0.0),
                   "only Heston model is supported");

        constexpr std::complex<double> i(0, 1);

        if (cpxLog_ == AngledContour || cpxLog_ == AngledContourNoCV || cpxLog_ == AsymptoticChF) {
            const std::complex<Real> h_u(u, u*tanPhi_ - alpha_);
            const std::complex<Real> hPrime(h_u-i);

            std::complex<Real> phiBS(0.0);
            if (cpxLog_ == AngledContour)
                phiBS = std::exp(
                    -0.5*vAvg_*term_*(hPrime*hPrime +
                            std::complex<Real>(-hPrime.imag(), hPrime.real())));
            else if (cpxLog_ == AsymptoticChF)
                phiBS = std::exp(u*std::complex<Real>(1, tanPhi_)*phi_ + psi_);

            return std::exp(-u*tanPhi_*freq_)
                    *(std::exp(std::complex<Real>(0.0, u*freq_))
                      *std::complex<Real>(1, tanPhi_)
                      *(phiBS - enginePtr_->chF(hPrime, term_))/(h_u*hPrime)
                      ).real()*s_alpha_;
        }
        else if (cpxLog_ == AndersenPiterbarg || cpxLog_ == AndersenPiterbargOptCV) {
            const std::complex<Real> z(u, -alpha_);
            const std::complex<Real> zPrime(u, -alpha_-1);
            const std::complex<Real> phiBS = std::exp(
                -0.5*vAvg_*term_*(zPrime*zPrime +
                        std::complex<Real>(-zPrime.imag(), zPrime.real()))
            );

            return (std::exp(std::complex<Real> (0.0, u*freq_))
                * (phiBS - enginePtr_->chF(zPrime, term_)) / (z*zPrime)
                ).real()*s_alpha_;
        }
        else
            QL_FAIL("unknown control variate");
    }

    Real AnalyticHestonEngine::AP_Helper::controlVariateValue() const {
        if (   cpxLog_ == AngledContour
            || cpxLog_ == AndersenPiterbarg || cpxLog_ == AndersenPiterbargOptCV) {
              return BlackCalculator(
                  Option::Call, strike_, fwd_, std::sqrt(vAvg_*term_))
                      .value();
        }
        else if (cpxLog_ == AsymptoticChF) {
            QL_REQUIRE(alpha_ == -0.5, "alpha must be equal to -0.5");

            const std::complex<Real> phiFreq(phi_.real(), phi_.imag() + freq_);

            using namespace ExponentialIntegral;
            return fwd_ - std::sqrt(strike_*fwd_)/M_PI*
                (std::exp(psi_)*(
                      -2.0*Ci(-0.5*phiFreq)*std::sin(0.5*phiFreq)
                       +std::cos(0.5*phiFreq)*(M_PI+2.0*Si(0.5*phiFreq)))).real();
        }
        else if (cpxLog_ == AngledContourNoCV) {
            return     ((alpha_ <=  0.0)? fwd_ : 0.0)
                  -    ((alpha_ <= -1.0)? strike_ : 0.0)
                  -0.5*((alpha_ ==  0.0)? fwd_ :0.0)
                  +0.5*((alpha_ == -1.0)? strike_: 0.0);
        }
        else
            QL_FAIL("unknown control variate");
    }

    std::complex<Real> AnalyticHestonEngine::chF(
        const std::complex<Real>& z, Time t) const {
        if (model_->sigma() > 1e-6 || model_->kappa() < 1e-8) {
            return std::exp(lnChF(z, t));
        }
        else {
            const Real kappa = model_->kappa();
            const Real sigma = model_->sigma();
            const Real theta = model_->theta();
            const Real rho   = model_->rho();
            const Real v0    = model_->v0();

            const Real sigma2 = sigma*sigma;

            const Real kt = kappa*t;
            const Real ekt = std::exp(kt);
            const Real e2kt = std::exp(2*kt);
            const Real rho2 = rho*rho;
            const std::complex<Real> zpi = z + std::complex<Real>(0.0, 1.0);

            return std::exp(-(((theta - v0 + ekt*((-1 + kt)*theta + v0))
                    *z*zpi)/ekt)/(2.*kappa))

                + (std::exp(-(kt) - ((theta - v0 + ekt
                    *((-1 + kt)*theta + v0))*z*zpi)
                /(2.*ekt*kappa))*rho*(2*theta + kt*theta -
                    v0 - kt*v0 + ekt*((-2 + kt)*theta + v0))
                *(1.0 - std::complex<Real>(-z.imag(),z.real()))*z*z)
                    /(2.*kappa*kappa)*sigma

                   + (std::exp(-2*kt - ((theta - v0 + ekt
                *((-1 + kt)*theta + v0))*z*zpi)/(2.*ekt*kappa))*z*z*zpi
                *(-2*rho2*squared(2*theta + kt*theta - v0 -
                    kt*v0 + ekt*((-2 + kt)*theta + v0))
                  *z*z*zpi + 2*kappa*v0*(-zpi
                    + e2kt*(zpi + 4*rho2*z) - 2*ekt*(2*rho2*z
                    + kt*(zpi + rho2*(2 + kt)*z))) + kappa*theta*(zpi + e2kt
                *(-5.0*zpi - 24*rho2*z+ 2*kt*(zpi + 4*rho2*z)) +
                4*ekt*(zpi + 6*rho2*z + kt*(zpi + rho2*(4 + kt)*z)))))
                /(16.*squared(squared(kappa)))*sigma2;
        }
    }

    std::complex<Real> AnalyticHestonEngine::lnChF(
        const std::complex<Real>& z, Time t) const {

        const Real kappa = model_->kappa();
        const Real sigma = model_->sigma();
        const Real theta = model_->theta();
        const Real rho   = model_->rho();
        const Real v0    = model_->v0();

        const Real sigma2 = sigma*sigma;

        const std::complex<Real> g
            = kappa + rho*sigma*std::complex<Real>(z.imag(), -z.real());

        const std::complex<Real> D = std::sqrt(
            g*g + (z*z + std::complex<Real>(-z.imag(), z.real()))*sigma2);

        // reduce cancelation errors, see. L. Andersen and M. Lake
        std::complex<Real> r(g-D);
        if (g.real()*D.real() + g.imag()*D.imag() > 0.0) {
            r = -sigma2*z*std::complex<Real>(z.real(), z.imag()+1)/(g+D);
        }

        std::complex<Real> y;
        if (D.real() != 0.0 || D.imag() != 0.0) {
            y = expm1(-D*t)/(2.0*D);
        }
        else
            y = -0.5*t;

        const std::complex<Real> A
            = kappa*theta/sigma2*(r*t - 2.0*log1p(-r*y));
        const std::complex<Real> B
            = z*std::complex<Real>(z.real(), z.imag()+1)*y/(1.0-r*y);

        return A+v0*B;
    }

    AnalyticHestonEngine::AnalyticHestonEngine(
                              const ext::shared_ptr<HestonModel>& model,
                              Size integrationOrder)
    : GenericModelEngine<HestonModel,
                         VanillaOption::arguments,
                         VanillaOption::results>(model),
      evaluations_(0),
      cpxLog_     (OptimalCV),
      integration_(new Integration(
                          Integration::gaussLaguerre(integrationOrder))),
      andersenPiterbargEpsilon_(Null<Real>()),
      alpha_(-0.5) {
    }

    AnalyticHestonEngine::AnalyticHestonEngine(
                              const ext::shared_ptr<HestonModel>& model,
                              Real relTolerance, Size maxEvaluations)
    : GenericModelEngine<HestonModel,
                         VanillaOption::arguments,
                         VanillaOption::results>(model),
      evaluations_(0),
      cpxLog_(OptimalCV),
      integration_(new Integration(Integration::gaussLobatto(
                              relTolerance, Null<Real>(), maxEvaluations))),
      andersenPiterbargEpsilon_(1e-40),
      alpha_(-0.5) {
    }

    AnalyticHestonEngine::AnalyticHestonEngine(
                              const ext::shared_ptr<HestonModel>& model,
                              ComplexLogFormula cpxLog,
                              const Integration& integration,
                              Real andersenPiterbargEpsilon,
                              Real alpha)
    : GenericModelEngine<HestonModel,
                         VanillaOption::arguments,
                         VanillaOption::results>(model),
      evaluations_(0),
      cpxLog_(cpxLog),
      integration_(new Integration(integration)),
      andersenPiterbargEpsilon_(andersenPiterbargEpsilon),
      alpha_(alpha) {
        QL_REQUIRE(   cpxLog_ != BranchCorrection
                   || !integration.isAdaptiveIntegration(),
                   "Branch correction does not work in conjunction "
                   "with adaptive integration methods");
    }

    AnalyticHestonEngine::ComplexLogFormula
        AnalyticHestonEngine::optimalControlVariate(
        Time t, Real v0, Real kappa, Real theta, Real sigma, Real rho) {

        if (t > 0.15 && (v0+t*kappa*theta)/sigma*std::sqrt(1-rho*rho) < 0.15
                && ((kappa- 0.5*rho*sigma)*(v0 + t*kappa*theta)
                    + kappa*theta*std::log(4*(1-rho*rho)))/(sigma*sigma) < 0.1) {
            return AsymptoticChF;
        }
        else {
            return AngledContour;
        }
    }

    Size AnalyticHestonEngine::numberOfEvaluations() const {
        return evaluations_;
    }

    Real AnalyticHestonEngine::priceVanillaPayoff(
        const ext::shared_ptr<PlainVanillaPayoff>& payoff,
        const Date& maturity) const {

        const ext::shared_ptr<HestonProcess>& process = model_->process();
        const Real fwd = process->s0()->value()
             * process->dividendYield()->discount(maturity)
             / process->riskFreeRate()->discount(maturity);

        return priceVanillaPayoff(payoff, process->time(maturity), fwd);
    }

    Real AnalyticHestonEngine::priceVanillaPayoff(
        const ext::shared_ptr<PlainVanillaPayoff>& payoff, Time maturity) const {

        const ext::shared_ptr<HestonProcess>& process = model_->process();
        const Real fwd = process->s0()->value()
             * process->dividendYield()->discount(maturity)
             / process->riskFreeRate()->discount(maturity);

        return priceVanillaPayoff(payoff, maturity, fwd);
    }

    Real AnalyticHestonEngine::priceVanillaPayoff(
        const ext::shared_ptr<PlainVanillaPayoff>& payoff,
        Time maturity, Real fwd) const {

        Real value;

        const ext::shared_ptr<HestonProcess>& process = model_->process();
        const DiscountFactor dr = process->riskFreeRate()->discount(maturity);

        const Real strike = payoff->strike();
        const Real spot = process->s0()->value();
        QL_REQUIRE(spot > 0.0, "negative or null underlying given");

        const DiscountFactor df = spot/fwd;
        const DiscountFactor dd = dr/df;

        const Real kappa = model_->kappa();
        const Real sigma = model_->sigma();
        const Real theta = model_->theta();
        const Real rho   = model_->rho();
        const Real v0    = model_->v0();

        evaluations_ = 0;

        switch(cpxLog_) {
          case Gatheral:
          case BranchCorrection: {
            const Real c_inf = std::min(0.2, std::max(0.0001,
                std::sqrt(1.0-rho*rho)/sigma))*(v0 + kappa*theta*maturity);

            const Real p1 = integration_->calculate(c_inf,
                Fj_Helper(kappa, theta, sigma, v0, spot, rho, this,
                          cpxLog_, maturity, strike, df, 1))/M_PI;
            evaluations_ += integration_->numberOfEvaluations();

            const Real p2 = integration_->calculate(c_inf,
                Fj_Helper(kappa, theta, sigma, v0, spot, rho, this,
                          cpxLog_, maturity, strike, df, 2))/M_PI;
            evaluations_ += integration_->numberOfEvaluations();

            switch (payoff->optionType())
            {
              case Option::Call:
                value = spot*dd*(p1+0.5)
                               - strike*dr*(p2+0.5);
                break;
              case Option::Put:
                value = spot*dd*(p1-0.5)
                               - strike*dr*(p2-0.5);
                break;
              default:
                QL_FAIL("unknown option type");
            }
          }
          break;
          case AndersenPiterbarg:
          case AndersenPiterbargOptCV:
          case AsymptoticChF:
          case AngledContour:
          case AngledContourNoCV:
          case OptimalCV: {
            const Real c_inf =
                std::sqrt(1.0-rho*rho)*(v0 + kappa*theta*maturity)/sigma;

            const Real epsilon = andersenPiterbargEpsilon_
                *M_PI/(std::sqrt(strike*fwd)*dr);

            const std::function<Real()> uM = [&](){
                return Integration::andersenPiterbargIntegrationLimit(
                    c_inf, epsilon, v0, maturity);
            };

            const ComplexLogFormula finalLog = (cpxLog_ == OptimalCV)
                ? optimalControlVariate(maturity, v0, kappa, theta, sigma, rho)
                : cpxLog_;

            const AP_Helper cvHelper(
                 maturity, fwd, strike, finalLog, this, alpha_
            );

            const Real cvValue = cvHelper.controlVariateValue();

            const Real vAvg = (1-std::exp(-kappa*maturity))*(v0-theta)/(kappa*maturity) + theta;

            const Real scalingFactor = (cpxLog_ != OptimalCV && cpxLog_ != AsymptoticChF)
                ? std::max(0.25, std::min(1000.0, 0.25/std::sqrt(0.5*vAvg*maturity)))
                : Real(1.0);

            const Real h_cv =
                fwd/M_PI*integration_->calculate(c_inf, cvHelper, uM, scalingFactor);

            evaluations_ += integration_->numberOfEvaluations();

            switch (payoff->optionType())
            {
              case Option::Call:
                value = (cvValue + h_cv)*dr;
                break;
              case Option::Put:
                value = (cvValue + h_cv - (fwd - strike))*dr;
                break;
              default:
                QL_FAIL("unknown option type");
            }
          }
          break;
          default:
            QL_FAIL("unknown complex log formula");
        }

        return value;
    }

    void AnalyticHestonEngine::calculate() const
    {
        // this is a european option pricer
        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European option");

        // plain vanilla
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non plain vanilla payoff given");

        const Date exerciseDate = arguments_.exercise->lastDate();

        results_.value = priceVanillaPayoff(payoff, exerciseDate);
    }


    AnalyticHestonEngine::Integration::Integration(Algorithm intAlgo,
                                                   ext::shared_ptr<Integrator> integrator)
    : intAlgo_(intAlgo), integrator_(std::move(integrator)) {}

    AnalyticHestonEngine::Integration::Integration(
        Algorithm intAlgo, ext::shared_ptr<GaussianQuadrature> gaussianQuadrature)
    : intAlgo_(intAlgo), gaussianQuadrature_(std::move(gaussianQuadrature)) {}

    AnalyticHestonEngine::Integration
    AnalyticHestonEngine::Integration::gaussLobatto(
       Real relTolerance, Real absTolerance, Size maxEvaluations, bool useConvergenceEstimate) {
       return Integration(GaussLobatto,
                           ext::shared_ptr<Integrator>(
                               new GaussLobattoIntegral(maxEvaluations,
                                                        absTolerance,
                                                        relTolerance,
                                                        useConvergenceEstimate)));
    }

    AnalyticHestonEngine::Integration
    AnalyticHestonEngine::Integration::gaussKronrod(Real absTolerance,
                                                   Size maxEvaluations) {
        return Integration(GaussKronrod,
                           ext::shared_ptr<Integrator>(
                               new GaussKronrodAdaptive(absTolerance,
                                                        maxEvaluations)));
    }

    AnalyticHestonEngine::Integration
    AnalyticHestonEngine::Integration::simpson(Real absTolerance,
                                               Size maxEvaluations) {
        return Integration(Simpson,
                           ext::shared_ptr<Integrator>(
                               new SimpsonIntegral(absTolerance,
                                                   maxEvaluations)));
    }

    AnalyticHestonEngine::Integration
    AnalyticHestonEngine::Integration::trapezoid(Real absTolerance,
                                        Size maxEvaluations) {
        return Integration(Trapezoid,
                           ext::shared_ptr<Integrator>(
                              new TrapezoidIntegral<Default>(absTolerance,
                                                             maxEvaluations)));
    }

    AnalyticHestonEngine::Integration
    AnalyticHestonEngine::Integration::gaussLaguerre(Size intOrder) {
        QL_REQUIRE(intOrder <= 192, "maximum integraton order (192) exceeded");
        return Integration(GaussLaguerre,
                           ext::shared_ptr<GaussianQuadrature>(
                               new GaussLaguerreIntegration(intOrder)));
    }

    AnalyticHestonEngine::Integration
    AnalyticHestonEngine::Integration::gaussLegendre(Size intOrder) {
        return Integration(GaussLegendre,
                           ext::shared_ptr<GaussianQuadrature>(
                               new GaussLegendreIntegration(intOrder)));
    }

    AnalyticHestonEngine::Integration
    AnalyticHestonEngine::Integration::gaussChebyshev(Size intOrder) {
        return Integration(GaussChebyshev,
                           ext::shared_ptr<GaussianQuadrature>(
                               new GaussChebyshevIntegration(intOrder)));
    }

    AnalyticHestonEngine::Integration
    AnalyticHestonEngine::Integration::gaussChebyshev2nd(Size intOrder) {
        return Integration(GaussChebyshev2nd,
                           ext::shared_ptr<GaussianQuadrature>(
                               new GaussChebyshev2ndIntegration(intOrder)));
    }

    AnalyticHestonEngine::Integration
    AnalyticHestonEngine::Integration::discreteSimpson(Size evaluations) {
        return Integration(
            DiscreteSimpson, ext::shared_ptr<Integrator>(
                new DiscreteSimpsonIntegrator(evaluations)));
    }

    AnalyticHestonEngine::Integration
    AnalyticHestonEngine::Integration::discreteTrapezoid(Size evaluations) {
        return Integration(
            DiscreteTrapezoid, ext::shared_ptr<Integrator>(
                new DiscreteTrapezoidIntegrator(evaluations)));
    }

    AnalyticHestonEngine::Integration
    AnalyticHestonEngine::Integration::expSinh(Real relTolerance) {
        return Integration(
            ExpSinh, ext::shared_ptr<Integrator>(
                new ExpSinhIntegral(relTolerance)));
    }

    Size AnalyticHestonEngine::Integration::numberOfEvaluations() const {
        if (integrator_ != nullptr) {
            return integrator_->numberOfEvaluations();
        } else if (gaussianQuadrature_ != nullptr) {
            return gaussianQuadrature_->order();
        } else {
            QL_FAIL("neither Integrator nor GaussianQuadrature given");
        }
    }

    bool AnalyticHestonEngine::Integration::isAdaptiveIntegration() const {
        return intAlgo_ == GaussLobatto
            || intAlgo_ == GaussKronrod
            || intAlgo_ == Simpson
            || intAlgo_ == Trapezoid
            || intAlgo_ == ExpSinh;
    }

    Real AnalyticHestonEngine::Integration::calculate(
        Real c_inf,
        const std::function<Real(Real)>& f,
        const std::function<Real()>& maxBound,
        const Real scaling) const {

        Real retVal;

        switch(intAlgo_) {
          case GaussLaguerre:
            retVal = (*gaussianQuadrature_)(f);
            break;
          case GaussLegendre:
          case GaussChebyshev:
          case GaussChebyshev2nd:
            retVal = (*gaussianQuadrature_)(integrand1(c_inf, f));
            break;
          case ExpSinh:
            retVal = scaling*(*integrator_)(
                [scaling, f](Real x) -> Real { return f(scaling*x);},
                0.0, std::numeric_limits<Real>::max());
            break;
          case Simpson:
          case Trapezoid:
          case GaussLobatto:
          case GaussKronrod:
              if (maxBound && maxBound() != Null<Real>())
                  retVal = (*integrator_)(f, 0.0, maxBound());
              else
                  retVal = (*integrator_)(integrand2(c_inf, f), 0.0, 1.0);
              break;
          case DiscreteTrapezoid:
          case DiscreteSimpson:
              if (maxBound && maxBound() != Null<Real>())
                  retVal = (*integrator_)(f, 0.0, maxBound());
              else
                  retVal = (*integrator_)(integrand3(c_inf, f), 0.0, 1.0);
              break;
          default:
            QL_FAIL("unknwon integration algorithm");
        }

        return retVal;
     }

    Real AnalyticHestonEngine::Integration::calculate(
        Real c_inf,
        const std::function<Real(Real)>& f,
        Real maxBound) const {

        return AnalyticHestonEngine::Integration::calculate(
            c_inf, f, [=](){ return maxBound; });
    }

    Real AnalyticHestonEngine::Integration::andersenPiterbargIntegrationLimit(
        Real c_inf, Real epsilon, Real v0, Real t) {

        const Real uMaxGuess = -std::log(epsilon)/c_inf;
        const Real uMaxStep = 0.1*uMaxGuess;

        const Real uMax = Brent().solve(u_Max(c_inf, epsilon),
            QL_EPSILON*uMaxGuess, uMaxGuess, uMaxStep);

        try {
            const Real uHatMaxGuess = std::sqrt(-std::log(epsilon)/(0.5*v0*t));
            const Real uHatMax = Brent().solve(uHat_Max(0.5*v0*t, epsilon),
                QL_EPSILON*uHatMaxGuess, uHatMaxGuess, 0.001*uHatMaxGuess);

            return std::max(uMax, uHatMax);
        }
        catch (const Error&) {
            return uMax;
        }
    }


    void AnalyticHestonEngine::doCalculation(Real riskFreeDiscount,
                                             Real dividendDiscount,
                                             Real spotPrice,
                                             Real strikePrice,
                                             Real term,
                                             Real kappa, Real theta, Real sigma, Real v0, Real rho,
                                             const TypePayoff& type,
                                             const Integration& integration,
                                             const ComplexLogFormula cpxLog,
                                             const AnalyticHestonEngine* const enginePtr,
                                             Real& value,
                                             Size& evaluations) {

        const Real ratio = riskFreeDiscount/dividendDiscount;

        evaluations = 0;

        switch(cpxLog) {
          case Gatheral:
          case BranchCorrection: {
            const Real c_inf = std::min(0.2, std::max(0.0001,
                std::sqrt(1.0-rho*rho)/sigma))*(v0 + kappa*theta*term);

            const Real p1 = integration.calculate(c_inf,
                Fj_Helper(kappa, theta, sigma, v0, spotPrice, rho, enginePtr,
                          cpxLog, term, strikePrice, ratio, 1))/M_PI;
            evaluations += integration.numberOfEvaluations();

            const Real p2 = integration.calculate(c_inf,
                Fj_Helper(kappa, theta, sigma, v0, spotPrice, rho, enginePtr,
                          cpxLog, term, strikePrice, ratio, 2))/M_PI;
            evaluations += integration.numberOfEvaluations();

            switch (type.optionType())
            {
              case Option::Call:
                value = spotPrice*dividendDiscount*(p1+0.5)
                               - strikePrice*riskFreeDiscount*(p2+0.5);
                break;
              case Option::Put:
                value = spotPrice*dividendDiscount*(p1-0.5)
                               - strikePrice*riskFreeDiscount*(p2-0.5);
                break;
              default:
                QL_FAIL("unknown option type");
            }
          }
          break;
          case AndersenPiterbarg:
          case AndersenPiterbargOptCV:
          case AsymptoticChF:
          case OptimalCV: {
            const Real c_inf =
                std::sqrt(1.0-rho*rho)*(v0 + kappa*theta*term)/sigma;

            const Real fwdPrice = spotPrice / ratio;

            const Real epsilon = enginePtr->andersenPiterbargEpsilon_
                *M_PI/(std::sqrt(strikePrice*fwdPrice)*riskFreeDiscount);

            const std::function<Real()> uM = [&](){
                return Integration::andersenPiterbargIntegrationLimit(c_inf, epsilon, v0, term);
            };

            AP_Helper cvHelper(term, fwdPrice, strikePrice,
                (cpxLog == OptimalCV)
                    ? optimalControlVariate(term, v0, kappa, theta, sigma, rho)
                    : cpxLog,
                enginePtr
            );

            const Real cvValue = cvHelper.controlVariateValue();

            const Real h_cv = integration.calculate(c_inf, cvHelper, uM)
                * std::sqrt(strikePrice * fwdPrice)/M_PI;
            evaluations += integration.numberOfEvaluations();

            switch (type.optionType())
            {
              case Option::Call:
                value = (cvValue + h_cv)*riskFreeDiscount;
                break;
              case Option::Put:
                value = (cvValue + h_cv - (fwdPrice - strikePrice))*riskFreeDiscount;
                break;
              default:
                QL_FAIL("unknown option type");
            }
          }
          break;

          default:
            QL_FAIL("unknown complex log formula");
        }
    }
}
]]></document_content>
  </document>
  <document index="106">
    <source>vanilla/analytichestonhullwhiteengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Klaus Spanderen
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/vanilla/analytichestonhullwhiteengine.hpp>
#include <utility>

namespace QuantLib {

    AnalyticHestonHullWhiteEngine::AnalyticHestonHullWhiteEngine(
        const ext::shared_ptr<HestonModel>& hestonModel,
        ext::shared_ptr<HullWhite> hullWhiteModel,
        Size integrationOrder)
    : AnalyticHestonEngine(
            hestonModel, AnalyticHestonEngine::Gatheral,
            AnalyticHestonEngine::Integration::gaussLaguerre(integrationOrder)),
      hullWhiteModel_(std::move(hullWhiteModel)) {
        setParameters();
        registerWith(hullWhiteModel_);
    }

    AnalyticHestonHullWhiteEngine::AnalyticHestonHullWhiteEngine(
        const ext::shared_ptr<HestonModel>& hestonModel,
        ext::shared_ptr<HullWhite> hullWhiteModel,
        Real relTolerance,
        Size maxEvaluations)
    : AnalyticHestonEngine(
        hestonModel, AnalyticHestonEngine::Gatheral,
        AnalyticHestonEngine::Integration::gaussLobatto(
            relTolerance, Null<Real>(), maxEvaluations)),
      hullWhiteModel_(std::move(hullWhiteModel)) {
        setParameters();
        registerWith(hullWhiteModel_);
    }

    void AnalyticHestonHullWhiteEngine::update() {
        setParameters();
        AnalyticHestonEngine::update();
    }

    void AnalyticHestonHullWhiteEngine::calculate() const {

        const Real t = model_->process()->time(arguments_.exercise->lastDate());
        if (a_*t > std::pow(QL_EPSILON, 0.25)) {
            m_ = sigma_*sigma_/(2*a_*a_)
                *(t+2/a_*std::exp(-a_*t)-1/(2*a_)*std::exp(-2*a_*t)-3/(2*a_));
        }
        else {
            // low-a algebraic limit
            m_ = 0.5*sigma_*sigma_*t*t*t*(1/3.0-0.25*a_*t+7/60.0*a_*a_*t*t);
        }

        AnalyticHestonEngine::calculate();
    }

    void AnalyticHestonHullWhiteEngine::setParameters() {
        a_ = hullWhiteModel_->params()[0];
        sigma_ = hullWhiteModel_->params()[1];
    }

}
]]></document_content>
  </document>
  <document index="107">
    <source>vanilla/analyticpdfhestonengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014, 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticpdfhestonengine.cpp
    \brief Analytic engine for arbitrary European payoffs under the Heston model
*/

#include <ql/pricingengines/vanilla/analyticpdfhestonengine.hpp>
#include <ql/math/integrals/gausslobattointegral.hpp>
#include <ql/methods/finitedifferences/utilities/hestonrndcalculator.hpp>
#include <utility>

namespace QuantLib {

    AnalyticPDFHestonEngine::AnalyticPDFHestonEngine(ext::shared_ptr<HestonModel> model,
                                                     Real integrationEps_,
                                                     Size maxIntegrationIterations)
    : maxIntegrationIterations_(maxIntegrationIterations), integrationEps_(integrationEps_),
      model_(std::move(model)) {}

    void AnalyticPDFHestonEngine::calculate() const {
        // this is an European option pricer
        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European option");

        const ext::shared_ptr<HestonProcess>& process = model_->process();

        const Time t = process->time(arguments_.exercise->lastDate());

        const Real xMax = 8.0 * std::sqrt(process->theta()*t
            + (process->v0() - process->theta())
                *(1-std::exp(-process->kappa()*t))/process->kappa());

        const Real x0 = std::log(process->s0()->value());
        const Real rD = process->riskFreeRate()->discount(t);
        const Real qD = process->dividendYield()->discount(t);

        const Real drift = x0 + std::log(rD/qD);

        results_.value = GaussLobattoIntegral(maxIntegrationIterations_, integrationEps_)(
            [&](Real _x){ return weightedPayoff(_x, t); },
            -xMax+drift, xMax+drift);
    }

    Real AnalyticPDFHestonEngine::Pv(Real x_t, Time t) const {
        return HestonRNDCalculator(
            model_->process(), integrationEps_, maxIntegrationIterations_)
                .pdf(x_t, t);
    }

    Real AnalyticPDFHestonEngine::cdf(Real s, Time t) const {
        const Real x_t = std::log(s);
        return HestonRNDCalculator(
            model_->process(), integrationEps_, maxIntegrationIterations_)
                .cdf(x_t, t);
    }

    Real AnalyticPDFHestonEngine::weightedPayoff(Real x_t, Time t) const {
        const DiscountFactor rD
            = model_->process()->riskFreeRate()->discount(t);

        const Real s_t = std::exp(x_t);
        const Real payoff = (*arguments_.payoff)(s_t);

        return (payoff != 0.0) ? payoff*Pv(x_t, t)*rD : Real(0.0);
    }
}

]]></document_content>
  </document>
  <document index="108">
    <source>vanilla/analyticptdhestonengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2017 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticptdhestonengine.cpp
    \brief analytic piecewise time dependent Heston-model engine
*/

#include <ql/math/functional.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/pricingengines/vanilla/analyticptdhestonengine.hpp>
#include <ql/pricingengines/blackcalculator.hpp>

namespace QuantLib {

    // helper class for integration
    class AnalyticPTDHestonEngine::Fj_Helper {
      public:
        Fj_Helper(
            const Handle<PiecewiseTimeDependentHestonModel>& model,
            Time term, Real strike, Size j);
    
        Real operator()(Real phi) const;
        
      private:
        const Size j_;    
        const Time term_;
        const Real v0_, x_, sx_;
        
        std::vector<Rate> r_, q_;
        const ext::shared_ptr<YieldTermStructure> qTS_;
        const Handle<PiecewiseTimeDependentHestonModel> model_;
        
        const TimeGrid timeGrid_;
    };
        
    AnalyticPTDHestonEngine::Fj_Helper::Fj_Helper(
        const Handle<PiecewiseTimeDependentHestonModel>& model,
        Time term, Real strike, Size j)
    : j_(j),
      term_(term),

      v0_(model->v0()),
      x_ (std::log(model->s0())),
      sx_(std::log(strike)),
      r_(model->timeGrid().size()-1),
      q_(model->timeGrid().size()-1),
      model_(model),
      timeGrid_(model->timeGrid()){
        
        for (Size i=0; i <timeGrid_.size()-1; ++i) {
            const Time begin = std::min(term_, timeGrid_[i]);
            const Time end   = std::min(term_, timeGrid_[i+1]);
            r_[i] = model->riskFreeRate()
                    ->forwardRate(begin, end, Continuous, NoFrequency).rate();
            q_[i] = model->dividendYield()
                    ->forwardRate(begin, end, Continuous, NoFrequency).rate();
        }
    }
        
    Real AnalyticPTDHestonEngine::Fj_Helper::operator()(Real phi) const {

        // avoid numeric overflow for phi->0. 
        // todo: use l'Hospital's rule use to get lim_{phi->0}
        phi = std::max(Real(std::numeric_limits<float>::epsilon()), phi);
        
        std::complex<Real> D = 0.0;
        std::complex<Real> C = 0.0;

        for (Size i=timeGrid_.size()-1; i > 0; --i) {
            const Time begin = timeGrid_[i-1];
            if (begin < term_) {
                const Time end = std::min(term_, timeGrid_[i]);
                const Time tau = end-begin;
                const Time t   = 0.5*(end+begin);
                
                const Real rho = model_->rho(t);
                const Real sigma = model_->sigma(t);
                const Real kappa = model_->kappa(t);
                const Real theta = model_->theta(t);

                const Real sigma2 = sigma*sigma;
                const Real t0 = kappa - ((j_== 1)? Real(rho*sigma) : 0);
                const Real rpsig = rho*sigma*phi;

                const std::complex<Real> t1 = t0+std::complex<Real>(0, -rpsig);
                const std::complex<Real> d  = std::sqrt(t1*t1 - sigma2*phi
                                 *std::complex<Real>(-phi, (j_== 1)? 1 : -1));
                const std::complex<Real> g = (t1-d)/(t1+d);
                const std::complex<Real> gt 
                                       = (t1-d - D*sigma2)/(t1+d - D*sigma2);
                
                D = (t1+d)/sigma2*(g-gt*std::exp(-d*tau))
                    /(1.0-gt*std::exp(-d*tau));
                
                const std::complex<Real> lng 
                    = std::log((1.0 - gt*std::exp(-d*tau))/(1.0 - gt));
                
                C =(kappa*theta)/sigma2*((t1-d)*tau-2.0*lng)
                    + std::complex<Real>(0.0, phi*(r_[i-1]-q_[i-1])*tau) + C;
            }
        }
        return std::exp(v0_*D+C+std::complex<Real>(0.0, phi*(x_ - sx_))).imag()
                /phi; 
    }

    class AnalyticPTDHestonEngine::AP_Helper {
      public:
        AP_Helper(Time term, Real s0, Real strike, Real ratio,
                  Volatility sigmaBS,
                  const AnalyticPTDHestonEngine* const enginePtr)
        : term_(term),
          sigmaBS_(sigmaBS),
          x_(std::log(s0)),
          sx_(std::log(strike)),
          dd_(x_-std::log(ratio)),
          enginePtr_(enginePtr) {
            QL_REQUIRE(enginePtr != nullptr, "pricing engine required");
        }

        Real operator()(Real u) const {
            const std::complex<Real> z(u, -0.5);

            const std::complex<Real> phiBS
                = std::exp(-0.5*sigmaBS_*sigmaBS_*term_
                           *(z*z + std::complex<Real>(-z.imag(), z.real())));

            return (std::exp(std::complex<Real>(0.0, u*(dd_-sx_)))
                * (phiBS - enginePtr_->chF(z, term_)) / (u*u + 0.25)).real();
        }

      private:
        const Time term_;
        const Volatility sigmaBS_;
        const Real x_, sx_, dd_;
        const AnalyticPTDHestonEngine* const enginePtr_;
    };


    std::complex<Real> AnalyticPTDHestonEngine::lnChF(
        const std::complex<Real>& z, Time T) const {

        const Real v0 = model_->v0();

        std::complex<Real> D = 0.0;
        std::complex<Real> C = 0.0;

        const TimeGrid& timeGrid = model_->timeGrid();
        const Time lastModelTime = timeGrid.back();

        QL_REQUIRE(T <= lastModelTime,
                   "maturity (" << T << ") is too large, "
                   "time grid is bounded by " << lastModelTime);

        const Size lastI = std::distance(timeGrid.begin(),
            std::lower_bound(timeGrid.begin(), timeGrid.end(), T));

        for (Integer i=lastI-1; i >= 0; --i) {
            const Time begin = timeGrid[i];
            const Time end = std::min(T, timeGrid[i+1]);
            const Time tau = end - begin;

            const Time t     = 0.5*(end+begin);
            const Real kappa = model_->kappa(t);
            const Real sigma = model_->sigma(t);
            const Real theta = model_->theta(t);
            const Real rho   = model_->rho(t);

            const Real sigma2 = sigma*sigma;

            const std::complex<Real> k
                = kappa + rho*sigma*std::complex<Real>(z.imag(), -z.real());

            const std::complex<Real> d = std::sqrt(
                k*k + (z*z + std::complex<Real>(-z.imag(), z.real()))*sigma2);

            const std::complex<Real> g = (k-d)/(k+d);

            const std::complex<Real> gt = (k-d-D*sigma2)/(k+d-D*sigma2);

            C += kappa*theta/sigma2*( (k-d)*tau
                   - 2.0*std::log((1.0-gt*std::exp(-d*tau))/(1.0-gt)));

            D = (k+d)/sigma2 * (g - gt*std::exp(-d*tau))
                    /(1.0 - gt*std::exp(-d*tau));
        }

        return D*v0 + C;
    }

    std::complex<Real> AnalyticPTDHestonEngine::chF(
        const std::complex<Real>& z, Time T) const {
        return std::exp(lnChF(z, T));
    }

    AnalyticPTDHestonEngine::AnalyticPTDHestonEngine(
        const ext::shared_ptr<PiecewiseTimeDependentHestonModel>& model,
        Size integrationOrder)
    : GenericModelEngine<PiecewiseTimeDependentHestonModel,
                         VanillaOption::arguments,
                         VanillaOption::results>(model),
      evaluations_(0),
      cpxLog_(Gatheral),
      integration_(new Integration(
          Integration::gaussLaguerre(integrationOrder))),
      andersenPiterbargEpsilon_(Null<Real>()) {
    }
                         
    AnalyticPTDHestonEngine::AnalyticPTDHestonEngine(
        const ext::shared_ptr<PiecewiseTimeDependentHestonModel>& model,
        Real relTolerance, Size maxEvaluations)
    : GenericModelEngine<PiecewiseTimeDependentHestonModel,
                         VanillaOption::arguments,
                         VanillaOption::results>(model),
      evaluations_(0),
      cpxLog_(Gatheral),
      integration_(new Integration(Integration::gaussLobatto(
            relTolerance, Null<Real>(), maxEvaluations))),
      andersenPiterbargEpsilon_(Null<Real>()) {
    }

    AnalyticPTDHestonEngine::AnalyticPTDHestonEngine(
        const ext::shared_ptr<PiecewiseTimeDependentHestonModel>& model,
        ComplexLogFormula cpxLog,
        const Integration& itg,
        Real andersenPiterbargEpsilon)
    : GenericModelEngine<PiecewiseTimeDependentHestonModel,
                         VanillaOption::arguments,
                         VanillaOption::results>(model),
      evaluations_(0),
      cpxLog_(cpxLog),
      integration_(new Integration(itg)),
      andersenPiterbargEpsilon_(andersenPiterbargEpsilon) {
    }


    void AnalyticPTDHestonEngine::calculate() const {
        // this is an european option pricer
        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                "not an European option");

        // plain vanilla
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");
        
        const Real v0 = model_->v0();
        const Real spotPrice = model_->s0();
        QL_REQUIRE(spotPrice > 0.0, "negative or null underlying given");
        
        const Real strike = payoff->strike();
        const Real term 
            = model_->riskFreeRate()->dayCounter().yearFraction(
                                     model_->riskFreeRate()->referenceDate(), 
                                     arguments_.exercise->lastDate());

        QL_REQUIRE(term < model_->timeGrid().back() ||
                       close_enough(term, model_->timeGrid().back()),
                   "maturity (" << term << ") is too large, time grid is bounded by "
                                << model_->timeGrid().back());

        const Real riskFreeDiscount = model_->riskFreeRate()->discount(
                                            arguments_.exercise->lastDate());
        const Real dividendDiscount = model_->dividendYield()->discount(
                                            arguments_.exercise->lastDate());

        //average values
        const TimeGrid& timeGrid = model_->timeGrid();
        QL_REQUIRE(timeGrid.size() > 1, "at least two model points needed");

        const Size n = timeGrid.size()-1;
        Real kappaAvg = 0.0, thetaAvg = 0.0,  sigmaAvg=0.0, rhoAvg = 0.0;

        for (Size i=1; i <= n; ++i) {
            const Time t = 0.5*(timeGrid[i-1] + timeGrid[i]);
            kappaAvg += model_->kappa(t);
            thetaAvg += model_->theta(t);
            sigmaAvg += model_->sigma(t);
            rhoAvg   += model_->rho(t);
        }
        kappaAvg/=n; thetaAvg/=n; sigmaAvg/=n; rhoAvg/=n;

        evaluations_ = 0;

        switch(cpxLog_) {
          case Gatheral: {
            const Real c_inf = std::min(0.2, std::max(0.0001,
                std::sqrt(1.0-squared(rhoAvg))/sigmaAvg))
                *(v0 + kappaAvg*thetaAvg*term);

            const Real p1 = integration_->calculate(c_inf,
                                    Fj_Helper(model_, term, strike, 1))/M_PI;
            evaluations_ += integration_->numberOfEvaluations();

            const Real p2 = integration_->calculate(c_inf,
                                    Fj_Helper(model_, term, strike, 2))/M_PI;
            evaluations_ += integration_->numberOfEvaluations();

            switch (payoff->optionType())
            {
              case Option::Call:
                results_.value = spotPrice*dividendDiscount*(p1+0.5)
                                - strike*riskFreeDiscount*(p2+0.5);
                break;
              case Option::Put:
                results_.value = spotPrice*dividendDiscount*(p1-0.5)
                                - strike*riskFreeDiscount*(p2-0.5);
                break;
              default:
                QL_FAIL("unknown option type");
            }
          }
          break;
          case AndersenPiterbarg: {
              QL_REQUIRE(term <= timeGrid.back(),
                         "maturity (" << term << ") is too large, "
                         "time grid is bounded by " << timeGrid.back());

              const Time t05 = 0.5*timeGrid.at(1);

              const std::complex<Real> D_u_inf =
                  -std::complex<Real>(
                      std::sqrt(1-squared(model_->rho(t05))),
                      model_->rho(t05)) / model_->sigma(t05);

              const Size lastI = std::distance(timeGrid.begin(),
                  std::lower_bound(timeGrid.begin(), timeGrid.end(), term));

              std::complex<Real> C_u_inf(0.0, 0.0);
              for (Size i=0; i < lastI; ++i) {
                  const Time begin = timeGrid[i];
                  const Time end   = std::min(term, timeGrid[i+1]);
                  const Time tau   = end - begin;
                  const Time t     = 0.5*(end+begin);

                  const Real kappa = model_->kappa(t);
                  const Real theta = model_->theta(t);
                  const Real sigma = model_->sigma(t);
                  const Real rho = model_->rho(t);

                  C_u_inf += -kappa*theta*tau / sigma
                      *std::complex<Real>(std::sqrt(1-rho*rho), rho);
              }

              const Real ratio = riskFreeDiscount/dividendDiscount;

              const Real fwdPrice = spotPrice / ratio;

              const Real epsilon = andersenPiterbargEpsilon_
                  *M_PI/(std::sqrt(strike*fwdPrice)*riskFreeDiscount);

              const Real c_inf = -(C_u_inf + D_u_inf*v0).real();

              const std::function<Real()> uM = [=](){
                  return Integration::andersenPiterbargIntegrationLimit(c_inf, epsilon, v0, term);
              };

              const Real vAvg
                  = (1-std::exp(-kappaAvg*term))*(v0-thetaAvg)
                    /(kappaAvg*term) + thetaAvg;

              const Real bsPrice
                  = BlackCalculator(Option::Call, strike,
                                    fwdPrice, std::sqrt(vAvg*term),
                                    riskFreeDiscount).value();

              const Real h_cv = integration_->calculate(c_inf,
                      AP_Helper(term, spotPrice, strike,
                                ratio, std::sqrt(vAvg), this),uM)
                  * std::sqrt(strike * fwdPrice)*riskFreeDiscount/M_PI;
              evaluations_ += integration_->numberOfEvaluations();

              switch (payoff->optionType())
              {
                case Option::Call:
                  results_.value = bsPrice + h_cv;
                  break;
                case Option::Put:
                  results_.value = bsPrice + h_cv
                      - riskFreeDiscount*(fwdPrice - strike);
                  break;
                default:
                  QL_FAIL("unknown option type");
              }
            }
            break;

            default:
              QL_FAIL("unknown complex log formula");
          }
    }
 
    Size AnalyticPTDHestonEngine::numberOfEvaluations() const {
        return evaluations_;
    }
}
]]></document_content>
  </document>
  <document index="109">
    <source>vanilla/baroneadesiwhaleyengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2006 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/math/comparison.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/pricingengines/vanilla/baroneadesiwhaleyengine.hpp>
#include <utility>

namespace QuantLib {

    BaroneAdesiWhaleyApproximationEngine::BaroneAdesiWhaleyApproximationEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }


    // critical commodity price
    Real BaroneAdesiWhaleyApproximationEngine::criticalPrice(
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        DiscountFactor riskFreeDiscount,
        DiscountFactor dividendDiscount,
        Real variance, Real tolerance) {

        // Calculation of seed value, Si
        Real n= 2.0*std::log(dividendDiscount/riskFreeDiscount)/(variance);
        Real m=-2.0*std::log(riskFreeDiscount)/(variance);
        Real bT = std::log(dividendDiscount/riskFreeDiscount);

        Real qu, Su, h, Si;
        switch (payoff->optionType()) {
          case Option::Call:
            qu = (-(n-1.0) + std::sqrt(((n-1.0)*(n-1.0)) + 4.0*m))/2.0;
            Su = payoff->strike() / (1.0 - 1.0/qu);
            h = -(bT + 2.0*std::sqrt(variance)) * payoff->strike() /
                (Su - payoff->strike());
            Si = payoff->strike() + (Su - payoff->strike()) *
                (1.0 - std::exp(h));
            break;
          case Option::Put:
            qu = (-(n-1.0) - std::sqrt(((n-1.0)*(n-1.0)) + 4.0*m))/2.0;
            Su = payoff->strike() / (1.0 - 1.0/qu);
            h = (bT - 2.0*std::sqrt(variance)) * payoff->strike() /
                (payoff->strike() - Su);
            Si = Su + (payoff->strike() - Su) * std::exp(h);
            break;
          default:
            QL_FAIL("unknown option type");
        }


        // Newton Raphson algorithm for finding critical price Si
        Real Q, LHS, RHS, bi;
        Real forwardSi = Si * dividendDiscount / riskFreeDiscount;
        Real d1 = (std::log(forwardSi/payoff->strike()) + 0.5*variance) /
            std::sqrt(variance);
        CumulativeNormalDistribution cumNormalDist;
        Real K = (!close(riskFreeDiscount, 1.0, 1000))
                ? Real(-2.0*std::log(riskFreeDiscount)
                   / (variance*(1.0-riskFreeDiscount)))
                 : 2.0/variance;
        Real temp = blackFormula(payoff->optionType(), payoff->strike(),
                forwardSi, std::sqrt(variance))*riskFreeDiscount;
        switch (payoff->optionType()) {
          case Option::Call:
            Q = (-(n-1.0) + std::sqrt(((n-1.0)*(n-1.0)) + 4 * K)) / 2;
            LHS = Si - payoff->strike();
            RHS = temp + (1 - dividendDiscount * cumNormalDist(d1)) * Si / Q;
            bi =  dividendDiscount * cumNormalDist(d1) * (1 - 1/Q) +
                (1 - dividendDiscount *
                 cumNormalDist.derivative(d1) / std::sqrt(variance)) / Q;
            while (std::fabs(LHS - RHS)/payoff->strike() > tolerance) {
                Si = (payoff->strike() + RHS - bi * Si) / (1 - bi);
                forwardSi = Si * dividendDiscount / riskFreeDiscount;
                d1 = (std::log(forwardSi/payoff->strike())+0.5*variance)
                    /std::sqrt(variance);
                LHS = Si - payoff->strike();
                Real temp2 = blackFormula(payoff->optionType(), payoff->strike(),
                    forwardSi, std::sqrt(variance))*riskFreeDiscount;
                RHS = temp2 + (1 - dividendDiscount * cumNormalDist(d1)) * Si / Q;
                bi = dividendDiscount * cumNormalDist(d1) * (1 - 1 / Q)
                    + (1 - dividendDiscount *
                       cumNormalDist.derivative(d1) / std::sqrt(variance))
                    / Q;
            }
            break;
          case Option::Put:
            Q = (-(n-1.0) - std::sqrt(((n-1.0)*(n-1.0)) + 4 * K)) / 2;
            LHS = payoff->strike() - Si;
            RHS = temp - (1 - dividendDiscount * cumNormalDist(-d1)) * Si / Q;
            bi = -dividendDiscount * cumNormalDist(-d1) * (1 - 1/Q)
                - (1 + dividendDiscount * cumNormalDist.derivative(-d1)
                   / std::sqrt(variance)) / Q;
            while (std::fabs(LHS - RHS)/payoff->strike() > tolerance) {
                Si = (payoff->strike() - RHS + bi * Si) / (1 + bi);
                forwardSi = Si * dividendDiscount / riskFreeDiscount;
                d1 = (std::log(forwardSi/payoff->strike())+0.5*variance)
                    /std::sqrt(variance);
                LHS = payoff->strike() - Si;
                Real temp2 = blackFormula(payoff->optionType(), payoff->strike(),
                    forwardSi, std::sqrt(variance))*riskFreeDiscount;
                RHS = temp2 - (1 - dividendDiscount * cumNormalDist(-d1)) * Si / Q;
                bi = -dividendDiscount * cumNormalDist(-d1) * (1 - 1 / Q)
                    - (1 + dividendDiscount * cumNormalDist.derivative(-d1)
                       / std::sqrt(variance)) / Q;
            }
            break;
          default:
            QL_FAIL("unknown option type");
        }

        return Si;
    }

    void BaroneAdesiWhaleyApproximationEngine::calculate() const {

        QL_REQUIRE(arguments_.exercise->type() == Exercise::American,
                   "not an American Option");

        ext::shared_ptr<AmericanExercise> ex =
            ext::dynamic_pointer_cast<AmericanExercise>(arguments_.exercise);
        QL_REQUIRE(ex, "non-American exercise given");
        QL_REQUIRE(!ex->payoffAtExpiry(),
                   "payoff at expiry not handled");

        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        Real variance = process_->blackVolatility()->blackVariance(
            ex->lastDate(), payoff->strike());
        DiscountFactor dividendDiscount = process_->dividendYield()->discount(
            ex->lastDate());
        DiscountFactor riskFreeDiscount = process_->riskFreeRate()->discount(
            ex->lastDate());
        Real spot = process_->stateVariable()->value();
        QL_REQUIRE(spot > 0.0, "negative or null underlying given");
        Real forwardPrice = spot * dividendDiscount / riskFreeDiscount;
        BlackCalculator black(payoff, forwardPrice, std::sqrt(variance),
                              riskFreeDiscount);

        if (dividendDiscount>=1.0 && payoff->optionType()==Option::Call) {
            // early exercise never optimal
            results_.value        = black.value();
            results_.delta        = black.delta(spot);
            results_.deltaForward = black.deltaForward();
            results_.elasticity   = black.elasticity(spot);
            results_.gamma        = black.gamma(spot);

            DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
            DayCounter divdc = process_->dividendYield()->dayCounter();
            DayCounter voldc = process_->blackVolatility()->dayCounter();
            Time t =
                rfdc.yearFraction(process_->riskFreeRate()->referenceDate(),
                                  arguments_.exercise->lastDate());
            results_.rho = black.rho(t);

            t = divdc.yearFraction(process_->dividendYield()->referenceDate(),
                                   arguments_.exercise->lastDate());
            results_.dividendRho = black.dividendRho(t);

            t = voldc.yearFraction(process_->blackVolatility()->referenceDate(),
                                   arguments_.exercise->lastDate());
            results_.vega        = black.vega(t);
            results_.theta       = black.theta(spot, t);
            results_.thetaPerDay = black.thetaPerDay(spot, t);

            results_.strikeSensitivity  = black.strikeSensitivity();
            results_.itmCashProbability = black.itmCashProbability();
        } else {
            // early exercise can be optimal
            CumulativeNormalDistribution cumNormalDist;
            Real tolerance = 1e-6;
            Real Sk = criticalPrice(payoff, riskFreeDiscount,
                dividendDiscount, variance, tolerance);
            Real forwardSk = Sk * dividendDiscount / riskFreeDiscount;
            Real d1 = (std::log(forwardSk/payoff->strike()) + 0.5*variance)
                /std::sqrt(variance);
            Real n = 2.0*std::log(dividendDiscount/riskFreeDiscount)/variance;
            Real K = (!close(riskFreeDiscount, 1.0, 1000))
                    ? Real(-2.0*std::log(riskFreeDiscount)
                       / (variance*(1.0-riskFreeDiscount)))
                     : 2.0/variance;
            Real Q, a;
            switch (payoff->optionType()) {
                case Option::Call:
                    Q = (-(n-1.0) + std::sqrt(((n-1.0)*(n-1.0))+4.0*K))/2.0;
                    a =  (Sk/Q) * (1.0 - dividendDiscount * cumNormalDist(d1));
                    if (spot<Sk) {
                        results_.value = black.value() +
                            a * std::pow((spot/Sk), Q);
                    } else {
                        results_.value = spot - payoff->strike();
                    }
                    break;
                case Option::Put:
                    Q = (-(n-1.0) - std::sqrt(((n-1.0)*(n-1.0))+4.0*K))/2.0;
                    a = -(Sk/Q) *
                        (1.0 - dividendDiscount * cumNormalDist(-d1));
                    if (spot>Sk) {
                        results_.value = black.value() +
                            a * std::pow((spot/Sk), Q);
                    } else {
                        results_.value = payoff->strike() - spot;
                    }
                    break;
                default:
                  QL_FAIL("unknown option type");
            }
        } // end of "early exercise can be optimal"
    }

}
]]></document_content>
  </document>
  <document index="110">
    <source>vanilla/batesengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Klaus Spanderen
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/vanilla/batesengine.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    BatesEngine::BatesEngine(const ext::shared_ptr<BatesModel> & model,
                             Size integrationOrder)
    : AnalyticHestonEngine(
        model, AnalyticHestonEngine::Gatheral,
        AnalyticHestonEngine::Integration::gaussLaguerre(integrationOrder)) { }

    BatesEngine::BatesEngine(const ext::shared_ptr<BatesModel>& model,
                             Real relTolerance, Size maxEvaluations)
    : AnalyticHestonEngine(
        model, AnalyticHestonEngine::Gatheral,
        AnalyticHestonEngine::Integration::gaussLobatto(
            relTolerance, Null<Real>(), maxEvaluations)) { }

    std::complex<Real> BatesEngine::addOnTerm(
                                            Real phi, Time t, Size j) const {
        
        ext::shared_ptr<BatesModel> batesModel =
                            ext::dynamic_pointer_cast<BatesModel>(*model_);

        const Real nu_     = batesModel->nu();
        const Real delta2_ = 0.5*batesModel->delta()*batesModel->delta();
        const Real lambda_ = batesModel->lambda();
        const Real i       = (j == 1)? 1.0 : 0.0;
        const std::complex<Real> g(i, phi);

        //it can throw: to be fixed
        return t*lambda_*(std::exp(nu_*g + delta2_*g*g) - 1.0
                          -g*(std::exp(nu_+delta2_) - 1.0));
    }


    BatesDetJumpEngine::BatesDetJumpEngine(
        const ext::shared_ptr<BatesDetJumpModel>& model,
        Size integrationOrder)
    : BatesEngine(model, integrationOrder) { }

    BatesDetJumpEngine::BatesDetJumpEngine(
        const ext::shared_ptr<BatesDetJumpModel>& model,
        Real relTolerance, Size maxEvaluations)
    : BatesEngine(model, relTolerance, maxEvaluations) { }

    std::complex<Real> BatesDetJumpEngine::addOnTerm(
        Real phi, Time t, Size j) const {

        const std::complex<Real> l =
            BatesEngine::addOnTerm(phi, t, j);

        ext::shared_ptr<BatesDetJumpModel> batesDetJumpModel =
            ext::dynamic_pointer_cast<BatesDetJumpModel>(*model_);

        const Real lambda      = batesDetJumpModel->lambda();
        const Real kappaLambda = batesDetJumpModel->kappaLambda();
        const Real thetaLambda = batesDetJumpModel->thetaLambda();

        return (kappaLambda*t - 1.0 + std::exp(-kappaLambda*t))
            * thetaLambda*l/(kappaLambda*t*lambda)
            + (1.0 - std::exp(-kappaLambda*t))*l/(kappaLambda*t);
    }


    BatesDoubleExpEngine::BatesDoubleExpEngine(
        const ext::shared_ptr<BatesDoubleExpModel> & model,
        Size integrationOrder)
    : AnalyticHestonEngine(
        model, AnalyticHestonEngine::Gatheral,
        AnalyticHestonEngine::Integration::gaussLaguerre(integrationOrder)) { }

    BatesDoubleExpEngine::BatesDoubleExpEngine(
        const ext::shared_ptr<BatesDoubleExpModel>& model,
        Real relTolerance, Size maxEvaluations)
    : AnalyticHestonEngine(
        model, AnalyticHestonEngine::Gatheral,
        AnalyticHestonEngine::Integration::gaussLobatto(
            relTolerance, Null<Real>(), maxEvaluations)) { }

    std::complex<Real> BatesDoubleExpEngine::addOnTerm(
        Real phi, Time t, Size j) const {
        ext::shared_ptr<BatesDoubleExpModel> batesDoubleExpModel =
            ext::dynamic_pointer_cast<BatesDoubleExpModel>(*model_);

        const Real p_     = batesDoubleExpModel->p();
        const Real q_     = 1.0-p_;
        const Real nuDown_= batesDoubleExpModel->nuDown();
        const Real nuUp_  = batesDoubleExpModel->nuUp();
        const Real lambda_= batesDoubleExpModel->lambda();
        const Real i      = (j == 1)? 1.0 : 0.0;
        const std::complex<Real> g(i, phi);

        return t*lambda_*(p_/(1.0-g*nuUp_) + q_/(1.0+g*nuDown_) - 1.0
                          - g*(p_/(1-nuUp_) + q_/(1+nuDown_)-1));
    }

    BatesDoubleExpDetJumpEngine::BatesDoubleExpDetJumpEngine(
        const ext::shared_ptr<BatesDoubleExpDetJumpModel> & model,
        Size integrationOrder)
    : BatesDoubleExpEngine(model, integrationOrder) { }

    BatesDoubleExpDetJumpEngine::BatesDoubleExpDetJumpEngine(
        const ext::shared_ptr<BatesDoubleExpDetJumpModel>& model,
        Real relTolerance, Size maxEvaluations)
    : BatesDoubleExpEngine(model, relTolerance, maxEvaluations) { }

    std::complex<Real> BatesDoubleExpDetJumpEngine::addOnTerm(
        Real phi, Time t, Size j) const {
        const std::complex<Real> l =
            BatesDoubleExpEngine::addOnTerm(phi, t, j);

        ext::shared_ptr<BatesDoubleExpDetJumpModel> doubleExpDetJumpModel
            = ext::dynamic_pointer_cast<BatesDoubleExpDetJumpModel>(*model_);

        const Real lambda      = doubleExpDetJumpModel->lambda();
        const Real kappaLambda = doubleExpDetJumpModel->kappaLambda();
        const Real thetaLambda = doubleExpDetJumpModel->thetaLambda();

        return (kappaLambda*t - 1.0 + std::exp(-kappaLambda*t))
            * thetaLambda*l/(kappaLambda*t*lambda)
            + (1.0 - std::exp(-kappaLambda*t))*l/(kappaLambda*t);
    }

}
]]></document_content>
  </document>
  <document index="111">
    <source>vanilla/bjerksundstenslandengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2023 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/any.hpp>
#include <ql/exercise.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/comparison.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/pricingengines/vanilla/bjerksundstenslandengine.hpp>
#include <utility>
#include <cmath>

namespace QuantLib {

    namespace {

        CumulativeNormalDistribution cumNormalDist;
        Real phi(Real S, Real gamma, Real H, Real I,
                 Real rT, Real bT, Real variance) {

            Real lambda = (-rT + gamma * bT + 0.5 * gamma * (gamma - 1.0)
                * variance);
            Real d = -(std::log(S / H) + (bT + (gamma - 0.5) * variance) )
                / std::sqrt(variance);
            Real kappa = 2.0 * bT / variance + (2.0 * gamma - 1.0);
            return std::exp(lambda) * (cumNormalDist(d)
                - std::pow((I / S), kappa) *
                cumNormalDist(d - 2.0 * std::log(I/S) / std::sqrt(variance)));
        }

        Real phi_S(Real S, Real gamma, Real H, Real I, Real rT, Real bT, Real v) {
            const Real lsh = std::log(S/H);
            const Real lis = std::log(I/S);
            const Real sv = std::sqrt(v);

            return std::exp(bT*gamma - rT + ((-1 +gamma)*gamma*v)/2.)*((-(std::pow(I/S,2*(gamma + bT/v))/(std::exp(squared(2*bT - v + 2*gamma*v + 4*lis + 2*lsh)/(8.*v))*I))- 1/(std::exp(squared(2*bT - v + 2*gamma*v + 2*lsh)/(8.*v))*S))/(M_SQRT2*M_SQRTPI*sv) +(std::pow(I/S,2*(gamma + bT/v))*(2*bT + (-1 + 2*gamma)*v)*std::erfc((2*bT- v + 2*gamma*v + 4*lis + 2*lsh)/(2.*M_SQRT2*sv)))/(2.*I*v));
        }

        Real phi_SS(Real S, Real gamma, Real H, Real I, Real rT, Real bT, Real v) {
            const Real lsh = std::log(S/H);
            const Real lis = std::log(I/S);
            const Real sv = std::sqrt(v);
            const Real ex = std::exp(squared(2*bT - v + 2*gamma*v + 4*lis + 2*lsh)/(8.*v));
            const Real ey = std::exp(squared(2*bT + (-1 + 2*gamma)*v + 2*lsh)/(8.*v));

            return (std::exp(bT*gamma - rT + ((-1 +gamma)*gamma*v)/2.)*((M_SQRT2*I*v*sv)/ey +(2*M_SQRT2*std::pow(I/S,2*(gamma + bT/v))*S*sv*(2*bT +(-1 + 2*gamma)*v))/ex -2*std::sqrt(M_PI)*std::pow(I/S,2*(gamma + bT/v))*S*(bT +gamma*v)*(2*bT + (-1 + 2*gamma)*v)*std::erfc((2*bT - v + 2*gamma*v +4*lis + 2*lsh)/(2.*M_SQRT2*sv)) +(M_SQRT2*I*sv*(bT + (-0.5 + gamma)*v +lsh))/ey - (std::pow(I/S,2*(gamma + bT/v))*S*sv*(2*bT - 3*v + 2*gamma*v + 4*lis +2*lsh))/(M_SQRT2*ex)))/(2.*I*M_SQRTPI*squared(S*v));
        }

        Real phi_gamma(Real S, Real gamma, Real H, Real I, Real rT, Real bT, Real v) {
            const Real lsh = std::log(S/H);
            const Real lis = std::log(I/S);
            const Real sv = std::sqrt(v);

            return std::exp(bT*gamma - rT + ((-1 + gamma)*gamma*v)/2)*(((-std::exp(-squared(2*bT - v + 2*gamma*v +2*lsh)/(8*v)) + std::pow(I/S,-1 + 2*gamma +(2*bT)/v)/std::exp(squared(2*bT - v + 2*gamma*v + 4*lis +2*lsh)/(8*v)))*sv)/(M_SQRT2*M_SQRTPI) + ((2*bT+ (-1 + 2*gamma)*v)*std::erfc((2*bT + (-1 + 2*gamma)*v +2*lsh)/(2.*M_SQRT2*sv)))/4. -(std::pow(I/S,-1 + 2*gamma + (2*bT)/v)*std::erfc((2*bT - v + 2*gamma*v + 4*lis +2*lsh)/(2.*M_SQRT2*sv))*(2*bT + (-1 + 2*gamma)*v + 4*lis))/4.);
        }

        Real phi_H(Real S, Real gamma, Real H, Real I, Real rT, Real bT, Real v) {
            const Real lsh = std::log(S/H);

            return (std::exp(bT*gamma - rT + ((-1 + gamma)*gamma*v)/2.)*(I/std::exp(squared(2*bT - v + 2*gamma*v + 2*lsh)/(8.*v))- (std::pow(I/S,2*(gamma + bT/v))*S)/std::exp(squared(2*bT - v + 2*gamma*v + 4*std::log(I/S) + 2*lsh)/(8.*v))))/(H*I*std::sqrt(2*M_PI)*std::sqrt(v));
        }

        Real phi_I(Real S, Real gamma, Real H, Real I, Real rT, Real bT, Real v) {
            const Real lsh = std::log(S/H);
            const Real lis = std::log(I/S);
            const Real sv = std::sqrt(v);

            return (std::exp(bT*gamma - rT + ((-1 + gamma)*gamma*v)/2.)*std::pow(I/S,2*(gamma + bT/v))*S*((2*std::sqrt(2/M_PI))/(std::exp(squared(2*bT - v + 2*gamma*v + 4*lis + 2*lsh)/(8.*v))*sv) + (1 - 2*gamma - (2*bT)/v)*std::erfc((2*bT - v + 2*gamma*v + 4*lis +2*lsh)/(2.*M_SQRT2*sv))))/(2.*I*I);
        }

        Real phi_rt(Real S, Real gamma, Real H, Real I, Real rT, Real bT, Real v) {
            const Real lsh = std::log(S/H);
            return (std::exp(bT*gamma - rT + ((-1 + gamma)*gamma*v)/2.)*(-(I*std::erfc((2*bT- v + 2*gamma*v + 2*lsh)/(2.*std::sqrt(2*v)))) +std::pow(I/S,2*(gamma + bT/v))*S*std::erfc((2*bT - v + 2*gamma*v + 4*std::log(I/S) +2*lsh)/(2.*std::sqrt(2*v)))))/(2.*I);
        }

        Real phi_bt(Real S, Real gamma, Real H, Real I, Real rT, Real bT, Real v) {
            const Real lsh = std::log(S/H);
            const Real lis = std::log(I/S);
            const Real sv = std::sqrt(v);

            return (std::exp(bT*gamma - rT + ((-1 + gamma)*gamma*v)/2.)*(M_SQRT2*(-(I/std::exp(squared(2*bT - v +2*gamma*v + 2*lsh)/(8.*v))) + (std::pow(I/S,2*(gamma +bT/v))*S)/std::exp(squared(2*bT - v + 2*gamma*v + 4*lis +2*lsh)/(8.*v)))*sv + gamma*I*std::sqrt(M_PI)*v*std::erfc((2*bT - v + 2*gamma*v +2*lsh)/(2.*M_SQRT2*sv)) - M_SQRTPI*std::pow(I/S,2*(gamma + bT/v))*S*std::erfc((2*bT - v +2*gamma*v + 4*lis + 2*lsh)/(2.*M_SQRT2*sv))*(gamma*v +2*lis)))/(2.*I*std::sqrt(M_PI)*v);
        }

        Real phi_v(Real S, Real gamma, Real H, Real I, Real rT, Real bT, Real v) {
            const Real lsh = std::log(S/H);
            const Real lis = std::log(I/S);
            const Real sv = std::sqrt(v);
            const Real er = std::erfc((2*bT - v + 2*gamma*v + 4*lis + 2*lsh)/(2.*M_SQRT2*sv));

            return (std::exp(bT*gamma - rT + ((-1 + gamma)*gamma*v)/2.)*(((-1 +gamma)*gamma*(I*std::erfc((2*bT - v + 2*gamma*v + 2*lsh)/(2.*M_SQRT2*sv)) -std::pow(I/S,2*(gamma + bT/v))*S*er))/(2.*I) +(2*bT*std::pow(I/S,-1 + 2*gamma + (2*bT)/v)*er*lis)/(v*v)+ (2*bT + v - 2*gamma*v + 2*lsh)/(2.*std::exp(std::pow(2*bT + (-1 + 2*gamma)*v +2*lsh,2)/(8.*v))*M_SQRT2*M_SQRTPI*v*sv) -(std::pow(I/S,-1 + 2*gamma + (2*bT)/v)*(2*bT + v - 2*gamma*v +4*lis + 2*lsh))/(2.*std::exp(squared(2*bT - v + 2*gamma*v + 4*lis + 2*lsh)/(8.*v))*M_SQRT2*M_SQRTPI*v*sv)))/2.;
        }
    }

    BjerksundStenslandApproximationEngine::BjerksundStenslandApproximationEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    OneAssetOption::results
    BjerksundStenslandApproximationEngine::europeanCallResults(
        Real S, Real X, Real rfD, Real dD, Real variance) const {

        OneAssetOption::results results;

        const Real forwardPrice = S * dD/rfD;
        const BlackCalculator black(
            Option::Call, X, forwardPrice, std::sqrt(variance), rfD);

        results.value        = black.value();
        results.delta        = black.delta(S);
        results.gamma        = black.gamma(S);

        const DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
        const DayCounter divdc = process_->dividendYield()->dayCounter();
        const DayCounter voldc = process_->blackVolatility()->dayCounter();
        Time t =
            rfdc.yearFraction(process_->riskFreeRate()->referenceDate(),
                              arguments_.exercise->lastDate());
        results.rho = black.rho(t);

        t = divdc.yearFraction(process_->dividendYield()->referenceDate(),
                               arguments_.exercise->lastDate());
        results.dividendRho = black.dividendRho(t);

        t = voldc.yearFraction(process_->blackVolatility()->referenceDate(),
                               arguments_.exercise->lastDate());
        results.vega        = black.vega(t);
        results.theta       = black.theta(S, t);
        results.thetaPerDay = black.thetaPerDay(S, t);

        results.strikeSensitivity  = black.strikeSensitivity();
        results.additionalResults["strikeGamma"] = Real(results.gamma*squared(S/X));
        results.additionalResults["exerciseType"] = std::string("European");

        return results;
    }

    OneAssetOption::results
    BjerksundStenslandApproximationEngine::immediateExercise(Real S, Real X) const {
        OneAssetOption::results results;
        results.value = std::max(0.0, S - X);
        results.delta = (S >= X)? 1.0 : 0.0;
        results.gamma = 0.0;
        results.rho = 0.0;
        results.dividendRho = 0.0;
        results.vega = 0.0;
        results.theta = 0.0;
        results.thetaPerDay = 0.0;

        results.strikeSensitivity = -results.delta;
        results.additionalResults["strikeGamma"] = Real(0.0);
        results.additionalResults["exerciseType"] = std::string("Immediate");

        return results;
    }

    OneAssetOption::results
    BjerksundStenslandApproximationEngine::americanCallApproximation(
        Real S, Real X, Real rfD, Real dD, Real variance) const {

        const OneAssetOption::results europeanResults
            = europeanCallResults(S, X, rfD, dD, variance);

        OneAssetOption::results results;

        const Real bT = std::log(dD/rfD);
        const Real rT = std::log(1.0/rfD);

        const Real beta = (0.5 - bT/variance) +
            std::sqrt(squared(bT/variance - 0.5) + 2.0 * rT/variance);

        const Real BInfinity = beta / (beta - 1.0) * X;
        const Real B0 = (bT == rT) ? X : std::max(X, rT / (rT - bT) * X);
        const Real ht = -(bT + 2.0*std::sqrt(variance)) * B0 / (BInfinity - B0);

        const Real I = B0 + (BInfinity - B0) * (1 - std::exp(ht));

        const Real fwd = S * dD/rfD;
        const Real q = std::log(I/fwd)/std::sqrt(variance);

        if (S >= I) {
            results = immediateExercise(S, X);
        }
        else if (q > 12.5) {
            // We have a run away exercise boundary. It is numerically
            // more accurate to use the Greeks of the European engine.
            results = europeanResults;
        }
        else {
            const Real phi_S_beta_I_I_rT_bT_v
                = phi(S, beta, I, I, rT, bT, variance);
            const Real phi_S_1_I_I_rT_bT_v
                = phi(S,  1.0, I, I, rT, bT, variance);
            const Real phi_S_1_X_I_rT_bT_V
                = phi(S, 1.0, X, I, rT, bT, variance);
            results.value = (I - X) * std::pow(S/I, beta)
                    *(1 - phi_S_beta_I_I_rT_bT_v)
                +    S * phi_S_1_I_I_rT_bT_v
                -    S * phi_S_1_X_I_rT_bT_V
                -    X * phi(S, 0.0, I, I, rT, bT, variance)
                +    X * phi(S, 0.0, X, I, rT, bT, variance);

            const Real phi_S_S_beta_I_I_rT_bT_v
                = phi_S(S, beta, I, I, rT, bT, variance);
            const Real phi_S_S_1_I_I_rT_bT_v
                = phi_S(S, 1.0, I, I, rT, bT, variance);
            const Real phi_S_S_1_X_I_rT_bT_v
                = phi_S(S, 1.0, X, I, rT, bT, variance);
            results.delta = (I - X) * std::pow(S/I, beta-1)*beta/I
                    * (1 - phi_S_beta_I_I_rT_bT_v)
                - (I - X) * std::pow(S/I, beta)
                    * phi_S_S_beta_I_I_rT_bT_v
                +   phi_S_1_I_I_rT_bT_v
                + S*phi_S_S_1_I_I_rT_bT_v
                -   phi_S_1_X_I_rT_bT_V
                - S*phi_S_S_1_X_I_rT_bT_v
                - X*phi_S(S, 0.0, I, I, rT, bT, variance)
                + X*phi_S(S, 0.0, X, I, rT, bT, variance);

            const Date refDate = process_->riskFreeRate()->referenceDate();
            const Date exerciseDate = arguments_.exercise->lastDate();
            const DayCounter qdc = process_->dividendYield()->dayCounter();
            const Time tq = qdc.yearFraction(refDate, exerciseDate);

            const Real betaDq = tq*(1/variance
                - 1/(2*std::sqrt(squared(bT/variance - 0.5) + 2.0 * rT/variance))
                  * 2*(bT/variance-0.5)/variance);
            const Real BInfinityDq = -X/squared(beta-1.0)*betaDq;
            const Real B0Dq = (dD <= rfD) ? Real(0.0)
                : Real(X*std::log(rfD)/squared(std::log(dD))*tq);

            const Real htDq = tq * B0 / (BInfinity - B0)
                - (bT + 2.0*std::sqrt(variance))
                    *(B0Dq*(BInfinity - B0) - B0*(BInfinityDq - B0Dq))
                        /squared(BInfinity - B0);
            const Real IDq = B0Dq + (BInfinityDq - B0Dq) * (1 - std::exp(ht))
                - (BInfinity - B0) * std::exp(ht)*htDq;

            const Real phi_H_S_beta_I_I_rT_bT_v
                = phi_H(S, beta, I, I, rT, bT, variance);
            const Real phi_I_S_beta_I_I_rT_bT_v
                = phi_I(S, beta, I, I, rT, bT, variance);
            const Real phi_gamma_S_beta_I_I_rT_bT_v
                = phi_gamma(S, beta, I, I, rT, bT, variance);
            const Real phi_bt_S_beta_I_I_rT_bT_v
                = phi_bt(S, beta, I, I, rT, bT, variance);
            const Real phi_H_S_1_I_I_rT_bT_v
                = phi_H(S, 1.0, I, I, rT, bT, variance);
            const Real phi_I_S_1_I_I_rT_bT_v
                = phi_I(S, 1.0, I, I, rT, bT, variance);
            const Real phi_bt_S_1_I_I_rT_bT_v
                = phi_bt(S, 1.0, I, I, rT, bT, variance);
            const Real phi_I_S_1_X_I_rT_bT_v
                = phi_I(S, 1.0, X, I, rT, bT, variance);
            const Real phi_bt_S_1_X_I_rT_bT_v
                = phi_bt(S, 1.0, X, I, rT, bT, variance);
            const Real phi_H_S_0_I_I_rT_bT_v
                = phi_H(S, 0.0, I, I, rT, bT, variance);
            const Real phi_I_S_0_I_I_rT_bT_v
                = phi_I(S, 0.0, I, I, rT, bT, variance);
            const Real phi_bt_S_0_I_I_rT_bT_v
                = phi_bt(S, 0.0, I, I, rT, bT, variance);
            const Real phi_I_S_0_X_I_rT_bT_v
                = phi_I(S, 0.0, X, I, rT, bT, variance);
            const Real phi_bt_S_0_X_I_rT_bT_v
                = phi_bt(S, 0.0, X, I, rT, bT, variance);

            results.dividendRho =
                (IDq*std::pow(S/I, beta)
                 + (I-X)*std::pow(S/I, beta)*(betaDq*std::log(S/I) - beta*1/I*IDq))
                 * (1 - phi_S_beta_I_I_rT_bT_v)
                - (I - X) * std::pow(S/I, beta)
                 *( phi_H_S_beta_I_I_rT_bT_v*IDq
                   +phi_I_S_beta_I_I_rT_bT_v*IDq
                   +phi_gamma_S_beta_I_I_rT_bT_v*betaDq
                   -phi_bt_S_beta_I_I_rT_bT_v*tq)
                + S*(  phi_H_S_1_I_I_rT_bT_v*IDq
                     + phi_I_S_1_I_I_rT_bT_v*IDq
                     - phi_bt_S_1_I_I_rT_bT_v*tq)
                - S*(  phi_I_S_1_X_I_rT_bT_v*IDq
                     - phi_bt_S_1_X_I_rT_bT_v*tq)
                - X*(  phi_H_S_0_I_I_rT_bT_v*IDq
                     + phi_I_S_0_I_I_rT_bT_v*IDq
                     - phi_bt_S_0_I_I_rT_bT_v*tq)
                + X*(  phi_I_S_0_X_I_rT_bT_v*IDq
                     - phi_bt_S_0_X_I_rT_bT_v*tq);

            const DayCounter rdc = process_->riskFreeRate()->dayCounter();
            const Time tr = rdc.yearFraction(refDate, exerciseDate);

            const Real betaDr = tr*(-1/variance
                + 1/(2*std::sqrt(squared(bT/variance - 0.5) + 2.0 * rT/variance))
                  * 2*((bT/variance-0.5)/variance + 1/variance));
            const Real BInfinityDr = -X/squared(beta-1.0)*betaDr;
            const Real B0Dr = (dD <= rfD) ? Real(0) : Real(-X*tr/std::log(dD));
            const Real htDr = -tr * B0 / (BInfinity - B0)
                - (bT + 2.0*std::sqrt(variance))
                    *(B0Dr*(BInfinity - B0) - B0*(BInfinityDr - B0Dr))
                        /squared(BInfinity - B0);
            const Real IDr = B0Dr + (BInfinityDr - B0Dr) * (1 - std::exp(ht))
                - (BInfinity - B0) * std::exp(ht)*htDr;

            results.rho =
                (IDr*std::pow(S/I, beta)
                 + (I-X)*std::pow(S/I, beta)*(betaDr*std::log(S/I) - beta/I*IDr))
                 * (1 - phi_S_beta_I_I_rT_bT_v)
                - (I - X) * std::pow(S/I, beta)
                 *(  phi_H_S_beta_I_I_rT_bT_v*IDr
                   + phi_I_S_beta_I_I_rT_bT_v*IDr
                   + phi_gamma_S_beta_I_I_rT_bT_v*betaDr
                   + phi_rt(S, beta, I, I, rT, bT, variance)*tr
                   + phi_bt_S_beta_I_I_rT_bT_v*tr)
                + S*(  phi_H_S_1_I_I_rT_bT_v*IDr
                     + phi_I_S_1_I_I_rT_bT_v*IDr
                     + phi_rt(S, 1.0, I, I, rT, bT, variance)*tr
                     + phi_bt_S_1_I_I_rT_bT_v*tr)
                - S*(  phi_I_S_1_X_I_rT_bT_v*IDr
                     + phi_rt(S, 1.0, X, I, rT, bT, variance)*tr
                     + phi_bt_S_1_X_I_rT_bT_v*tr)
                - X*(  phi_H_S_0_I_I_rT_bT_v*IDr
                     + phi_I_S_0_I_I_rT_bT_v*IDr
                     + phi_rt(S, 0.0, I, I, rT, bT, variance)*tr
                     + phi_bt_S_0_I_I_rT_bT_v*tr)
                + X*(  phi_I_S_0_X_I_rT_bT_v*IDr
                     + phi_rt(S, 0.0, X, I, rT, bT, variance)*tr
                     + phi_bt_S_0_X_I_rT_bT_v*tr);

            const Real beta = (0.5 - bT/variance) +
                std::sqrt(squared(bT/variance - 0.5) + 2.0 * rT/variance);

            const DayCounter vdc = process_->blackVolatility()->dayCounter();
            const Time tv = vdc.yearFraction(refDate, exerciseDate);
            const Real varianceDv = 2*std::sqrt(variance*tv);

            const Real betaDv = bT/squared(variance)*varianceDv +
                - 1/(2*std::sqrt(squared(bT/variance - 0.5) + 2.0 * rT/variance))
                  *( 2*(bT/variance - 0.5)*bT*varianceDv/squared(variance)
                    +2*rT/squared(variance)*varianceDv );
            const Real BInfinityDv = -X/squared(beta-1.0)*betaDv;
            const Real htDv = -1/std::sqrt(variance)*varianceDv*B0/(BInfinity-B0)
                    + (bT + 2*std::sqrt(variance))*B0/squared(BInfinity-B0)*BInfinityDv;

            const Real IDv = BInfinityDv*(1-std::exp(ht))
                - (BInfinity-B0)*std::exp(ht)*htDv;

            results.vega =
                (IDv*std::pow(S/I, beta)
                 + (I-X)*std::pow(S/I, beta)*(betaDv*std::log(S/I) - beta/I*IDv))
                 * (1 - phi_S_beta_I_I_rT_bT_v)
                - (I - X) * std::pow(S/I, beta)
                *(  phi_H_S_beta_I_I_rT_bT_v*IDv
                  + phi_I_S_beta_I_I_rT_bT_v*IDv
                  + phi_gamma_S_beta_I_I_rT_bT_v*betaDv
                  + phi_v(S, beta, I, I, rT, bT, variance)*varianceDv)
               + S*(  phi_H_S_1_I_I_rT_bT_v*IDv
                    + phi_I_S_1_I_I_rT_bT_v*IDv
                    + phi_v(S, 1.0, I, I, rT, bT, variance)*varianceDv)
               - S*(  phi_I_S_1_X_I_rT_bT_v*IDv
                    + phi_v(S, 1.0, X, I, rT, bT, variance)*varianceDv)
               - X*(  phi_H_S_0_I_I_rT_bT_v*IDv
                    + phi_I_S_0_I_I_rT_bT_v*IDv
                    + phi_v(S, 0.0, I, I, rT, bT, variance)*varianceDv)
               + X*(  phi_I_S_0_X_I_rT_bT_v*IDv
                    + phi_v(S, 0.0, X, I, rT, bT, variance)*varianceDv);

            results.gamma =
                  (I - X) * std::pow(S/I, beta-2)*beta*(beta-1)/squared(I)
                  * (1 - phi_S_beta_I_I_rT_bT_v)
                - 2*(I - X) * std::pow(S/I, beta-1)*beta/I
                  *phi_S_S_beta_I_I_rT_bT_v
                - (I - X) * std::pow(S/I, beta)
                  * phi_SS(S, beta, I, I, rT, bT, variance)

                + 2*phi_S_S_1_I_I_rT_bT_v
                + S*phi_SS(S, 1.0, I, I, rT, bT, variance)

                - 2*phi_S_S_1_X_I_rT_bT_v
                - S*phi_SS(S, 1.0, X, I, rT, bT, variance)

                - X*phi_SS(S, 0.0, I, I, rT, bT, variance)
                + X*phi_SS(S, 0.0, X, I, rT, bT, variance);

            const Volatility vol = std::sqrt(variance/tv);

            const Date tomorrow = refDate + Period(1, Days);
            const Time dtq = qdc.yearFraction(refDate, exerciseDate)
                    - qdc.yearFraction(tomorrow,  exerciseDate);
            const Time dtr = rdc.yearFraction(refDate, exerciseDate)
                    - rdc.yearFraction(tomorrow,  exerciseDate);
            const Time dtv = vdc.yearFraction(refDate, exerciseDate)
                    - vdc.yearFraction(tomorrow,  exerciseDate);

            results.thetaPerDay = -(0.5*results.vega*vol/tv*dtv
                + results.rho*rT/(tr*tr)*dtr + results.dividendRho*(rT-bT)/(tq*tq)*dtq);
            results.theta = 365*results.thetaPerDay;

            results.strikeSensitivity = results.value/X - S/X*results.delta;
            results.additionalResults["strikeGamma"] = Real(results.gamma*squared(S/X));

            results.additionalResults["exerciseType"] = std::string("American");
        }

        // check if European engine gives higher NPV
        if (results.value < europeanResults.value) {
            results = europeanResults;
        }

        return results;
    }


    void BjerksundStenslandApproximationEngine::calculate() const {

        QL_REQUIRE(arguments_.exercise->type() == Exercise::American,
                   "not an American Option");

        ext::shared_ptr<AmericanExercise> ex =
            ext::dynamic_pointer_cast<AmericanExercise>(arguments_.exercise);
        QL_REQUIRE(ex, "non-American exercise given");
        QL_REQUIRE(!ex->payoffAtExpiry(),
                   "payoff at expiry not handled");

        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        Real variance =
            process_->blackVolatility()->blackVariance(ex->lastDate(),
                                                       payoff->strike());
        DiscountFactor dividendDiscount =
            process_->dividendYield()->discount(ex->lastDate());
        DiscountFactor riskFreeDiscount =
            process_->riskFreeRate()->discount(ex->lastDate());
        Real spot = process_->stateVariable()->value();
        QL_REQUIRE(spot > 0.0, "negative or null underlying given");
        Real strike = payoff->strike();

        if (payoff->optionType()==Option::Put) {
            // use put-call symmetry
            std::swap(spot, strike);
            std::swap(riskFreeDiscount, dividendDiscount);
            payoff = ext::make_shared<PlainVanillaPayoff>(
                                Option::Call, strike);
        }

        if (dividendDiscount > 1.0 && riskFreeDiscount > dividendDiscount)
            QL_FAIL("double-boundary case r<q<0 for a call given");


        if (dividendDiscount >= 1.0 && dividendDiscount >= riskFreeDiscount) {
            results_ = europeanCallResults(
                spot, strike, riskFreeDiscount, dividendDiscount, variance);
        } else {
            // early exercise can be optimal - use approximation
            results_ = americanCallApproximation(
                spot, strike, riskFreeDiscount, dividendDiscount, variance);
        }

        // check if immediate exercise gives higher NPV
        if (results_.value < (spot - strike)*(1+10*QL_EPSILON) ) {
            results_ = immediateExercise(spot, strike);
        }

        if (ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff)
                ->optionType() == Option::Put) {

            std::swap(results_.delta, results_.strikeSensitivity);

            Real tmp = results_.gamma;
            results_.gamma =
                ext::any_cast<Real>(results_.additionalResults["strikeGamma"]);
            results_.additionalResults["strikeGamma"] = tmp;

            std::swap(results_.rho, results_.dividendRho);

            Time tr = process_->riskFreeRate()->dayCounter().yearFraction(
                process_->riskFreeRate()->referenceDate(),
                arguments_.exercise->lastDate());
            Time tq = process_->dividendYield()->dayCounter().yearFraction(
                process_->dividendYield()->referenceDate(),
                arguments_.exercise->lastDate());

            results_.rho *= tr/tq;
            results_.dividendRho *= tq/tr;
        }
    }
}
]]></document_content>
  </document>
  <document index="112">
    <source>vanilla/cashdividendeuropeanengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2025 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cashdividendeuropeanengine.cpp
*/

#include <ql/payoff.hpp>
#include <ql/exercise.hpp>
#include <ql/instruments/basketoption.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/pricingengines/vanilla/cashdividendeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/analyticdividendeuropeanengine.hpp>
#include <ql/pricingengines/basket/choibasketengine.hpp>

namespace QuantLib {
    CashDividendEuropeanEngine::CashDividendEuropeanEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        DividendSchedule dividends,
        CashDividendModel cashDividendModel)
    : process_(std::move(process)),
      dividends_(std::move(dividends)),
      cashDividendModel_(cashDividendModel) {

        registerWith(process_);
    }

    void CashDividendEuropeanEngine::calculate() const {

        const ext::shared_ptr<EuropeanExercise> exercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(arguments_.exercise);
        QL_REQUIRE(exercise, "not an European option");

        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        const Real strike = payoff->strike();

        const Handle<YieldTermStructure> rTS = process_->riskFreeRate();
        const Handle<YieldTermStructure> qTS = process_->dividendYield();

        const Date settlementDate = rTS->referenceDate();
        const Date maturityDate = exercise->lastDate();
        const Time maturity = process_->time(maturityDate);

        DividendSchedule dividends;
        std::copy_if(
            dividends_.begin(), dividends_.end(),
            std::back_inserter(dividends),
            [settlementDate, maturityDate](
                const ext::shared_ptr<Dividend>& div) -> bool {
                return (div->date() >= settlementDate
                        && div->date() <= maturityDate && div->amount() > 0.0);
            }
        );
        std::sort(
            dividends.begin(), dividends.end(),
            [](const ext::shared_ptr<Dividend>& d1, const ext::shared_ptr<Dividend>& d2) {
                return d1->date() < d2->date();
            }
        );

        if (cashDividendModel_ == Escrowed
            || (dividends.size() == 1 && dividends.back()->date() == settlementDate)) {
            VanillaOption option(payoff, exercise);
            option.setPricingEngine(
                ext::make_shared<AnalyticDividendEuropeanEngine>(process_, dividends_)
            );

            results_.value = option.NPV();
            return;
        }

        DividendSchedule underlyings(dividends);
        if (!underlyings.empty() && underlyings.back()->date() == maturityDate) {
            underlyings.back() = ext::make_shared<FixedDividend>(
                    underlyings.back()->amount() + strike, maturityDate
            );
        }
        else
            underlyings.emplace_back(ext::make_shared<FixedDividend>(strike, maturityDate));

        if (underlyings.size() == 1) {
            VanillaOption option(
                ext::make_shared<PlainVanillaPayoff>(
                    payoff->optionType(), underlyings.back()->amount()
                ),
                exercise
            );
            option.setPricingEngine(ext::make_shared<AnalyticEuropeanEngine>(process_));

            results_.value = option.NPV();
            return;
        }

        const Handle<BlackVolTermStructure> volTS = process_->blackVolatility();
        const Date volRefDate = volTS->referenceDate();
        const DayCounter volDc = volTS->dayCounter();

        const Handle<YieldTermStructure> zeroRateTS(
            ext::make_shared<FlatForward>(settlementDate, 0.0, rTS->dayCounter())
        );

        std::vector<ext::shared_ptr<GeneralizedBlackScholesProcess> > processes;
        for (const auto& div: underlyings) {
            const Rate r_mod = std::log(rTS->discount(div->date())) / maturity;
            const Rate q_mod = std::log(qTS->discount(div->date())) / maturity;

            processes.emplace_back(
                ext::make_shared<GeneralizedBlackScholesProcess>(
                    Handle<Quote>(ext::make_shared<SimpleQuote>(div->amount())),
                    Handle<YieldTermStructure>(
                        ext::make_shared<FlatForward>(
                            settlementDate, q_mod - r_mod, rTS->dayCounter()
                        )
                    ),
                    zeroRateTS,
                    Handle<BlackVolTermStructure>(ext::make_shared<BlackConstantVol>(
                        volRefDate, volTS->calendar(),
                        Handle<Quote>(ext::make_shared<SimpleQuote>(
                            std::sqrt(volTS->blackVariance(div->date(), strike) / maturity)
                        )),
                        volDc
                    ))
                )
            );
        }

        Array v(underlyings.size());
        for (Size i=0; i < underlyings.size(); ++i)
            v[i] = volTS->blackVariance(underlyings[i]->date(), strike);

        Matrix rho(underlyings.size(), underlyings.size());
        for (Size i=0; i < underlyings.size(); ++i) {
            rho[i][i] = 1.0;
            for (Size j=0; j < i; ++j)
                if (v[j] > QL_EPSILON)
                    rho[i][j] = rho[j][i] = v[j] / std::sqrt(v[i]*v[j]);
                else
                    rho[i][j] = rho[j][i] = QL_EPSILON;
        }

        BasketOption basketOption(
            ext::make_shared<AverageBasketPayoff>(
                ext::make_shared<PlainVanillaPayoff>(Option::Put, process_->x0()),
                Array(underlyings.size(), 1.0)
            ),
            ext::make_shared<EuropeanExercise>(maturityDate)
        );

        basketOption.setPricingEngine(
            ext::make_shared<ChoiBasketEngine>(processes, rho, 10, 2000, false, true)
        );

        if (payoff->optionType() == Option::Call)
            results_.value = basketOption.NPV() * qTS->discount(maturityDate);
        else {
            const Real divDiscounted = std::accumulate(
                dividends.begin(), dividends.end(), Real(0),
                [&rTS, &qTS](Real acc, const ext::shared_ptr<Dividend>& div) -> Real {
                    return acc + div->amount() * rTS->discount(div->date()) / qTS->discount(div->date());
                }
            );

            const Real fwd = (process_->x0() - divDiscounted)
                * qTS->discount(maturityDate) / rTS->discount(maturityDate);

            results_.value = basketOption.NPV() * qTS->discount(maturityDate)
                - (fwd - payoff->strike()) * rTS->discount(maturityDate);
        }
    }
}
]]></document_content>
  </document>
  <document index="113">
    <source>vanilla/coshestonengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2017 Klaus Spanderen
 Copyright (C) 2022 Ignacio Anguita

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/functional.hpp>
#include <ql/pricingengines/vanilla/coshestonengine.hpp>

namespace QuantLib {

    COSHestonEngine::COSHestonEngine(
       const ext::shared_ptr<HestonModel>& model, Real L, Size N)
    : GenericModelEngine<HestonModel,
                         VanillaOption::arguments,
                         VanillaOption::results>(model),
    L_(L), N_(N),
    kappa_(model_->kappa()),
    theta_(model_->theta()),
    sigma_(model_->sigma()),
    rho_  (model_->rho())  ,
    v0_   (model_->v0()) { }


    void COSHestonEngine::update() {
        kappa_ = model_->kappa();
        theta_ = model_->theta();
        sigma_ = model_->sigma();
        rho_   = model_->rho();
        v0_    = model_->v0();

        GenericModelEngine<HestonModel,
                           VanillaOption::arguments,
                           VanillaOption::results>::update();
    }


    void COSHestonEngine::calculate() const {

        // this is a european option pricer
        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European option");

        // plain vanilla
        const ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non plain vanilla payoff given");

        const ext::shared_ptr<HestonProcess> process = model_->process();

        const Date maturityDate = arguments_.exercise->lastDate();
        const Time maturity = process->time(maturityDate);

        const Real cum1 = c1(maturity);
        const Real w = std::sqrt(std::fabs(c2(maturity))
            // the 4th order doesn't necessarily improve the precision
            // + std::sqrt(std::fabs(c4(maturity)))
        );

        const Real k = payoff->strike();
        const Real spot = process->s0()->value();
        QL_REQUIRE(spot > 0.0, "negative or null underlying given");

        const DiscountFactor df
            = process->riskFreeRate()->discount(maturityDate);
        const DiscountFactor qf
            = process->dividendYield()->discount(maturityDate);
        const Real fwd = spot*qf/df;
        const Real x = std::log(fwd/k);

        const Real a = x + cum1 - L_*w;
        const Real b = x + cum1 + L_*w;
        
        // Check if it exceeds the truncation bound
        
        if (x >= b/2 || x <= a/2) {
            //returns lower/upper bounds
            if (payoff->optionType() == Option::Put)
                results_.value = std::max(-spot*qf+k*df,0.0);
            else if (payoff->optionType() == Option::Call)
           	    results_.value = std::max(spot*qf-k*df,0.0);
       	    else
                QL_FAIL("unknown payoff type");
            return;
        }
		

        const Real d = 1.0/(b-a);

        const Real expA = std::exp(a);
        Real s = chF(0, maturity).real()*(expA-1-a)*d;

        for (Size n=1; n < N_; ++n) {
            const Real r = n*M_PI*d;
            const Real U_n = 2.0*d*( 1.0/(1.0 + r*r)
                *(expA + r*std::sin(r*a) - std::cos(r*a)) - 1.0/r*std::sin(r*a));

            s += U_n*(chF(r, maturity)
                     *std::exp(std::complex<Real>(0, r*(x-a)))).real();
        }

        if (payoff->optionType() == Option::Put)
            results_.value = k*df*s;
        else if (payoff->optionType() == Option::Call) {
            const DiscountFactor qf
                = process->dividendYield()->discount(maturityDate);
            results_.value = spot*qf - k*df*(1-s);
        }
        else
            QL_FAIL("unknown payoff type");
    }

    Real COSHestonEngine::muT(Time t) const {
        return std::log(  model_->process()->dividendYield()->discount(t)
                        / model_->process()->riskFreeRate()->discount(t));
    }

    std::complex<Real> COSHestonEngine::chF(Real u, Real t)
    const {
        const Real sigma2 = sigma_*sigma_;

        const std::complex<Real> D = std::sqrt(
            squared(std::complex<Real>(kappa_, -rho_*sigma_*u))
            + std::complex<Real>(u*u, u)*sigma2);

        const std::complex<Real> g(kappa_, -rho_*sigma_*u);

        const std::complex<Real> G = (g-D)/(g+D);

        return std::exp(
              v0_/(sigma2)*(1.0-std::exp(-D*t))/(1.0-G*std::exp(-D*t))
             *(g-D) + kappa_*theta_/sigma2*((g-D)*t
                -2.0*std::log((1.0-G*std::exp(-D*t))/(1.0-G)))
            );
   }

   /*
    Mathematica program to calculate the n-th cumulant

    d[z_] := Sqrt[(kappa -i*rho*sigma*z)^2 + (z*z+i*z)*sigma^2]

    g[z_] := (kappa -i*rho*sigma*z - d[z])/(kappa -i*rho*sigma*z + d[z])

    phi[z_] := Exp[ v0/(sigma^2)*(1-Exp[-d[z]*t])/(1-g[z]*Exp[-d[z]*t])
        *(kappa -i*rho*sigma*z - d[z]) + kappa*theta/sigma^2
        *((kappa -i*rho*sigma*z-d[z])*t
          -2*Log[(1-g[z]*Exp[-d[z]*t])/(1-g[z]) ]) ]

    e[z_] := Log[phi[-i*z]]

    // for C++ formatting see
    // http://mathematica.stackexchange.com/questions/114175/cform-not-getting-exp-pow-log-functions
    cpp = RawBoxes[Replace[ToBoxes@#,
        InterpretationBox[a_, b_, c___] :>  With[{aa =
        StringReplace[ a, {"Sqrt" -> "std::sqrt", "Power(E," -> "std::exp(",
                           "Power" -> "std::pow"}]}, aa], {0, Infinity}]] &;

    c[n_] := cpp@CForm[FullSimplify[Derivative[n][e][0],
         kappa > 0 && theta > 0 && v0 > 0 && sigma > 0 &&
         rho [Element] {-1, 1} && i^2 == -1]]
    */

   Real COSHestonEngine::c1(Time t) const {
       return (-theta_ + std::exp(kappa_*t)
           *( theta_ - kappa_*t*theta_ -
               v0_) + v0_)/(2*std::exp(kappa_*t)*kappa_);
   }

   Real COSHestonEngine::c2(Time t) const {
       const Real sigma2 = sigma_*sigma_;
       const Real kappa2 = kappa_*kappa_;
       const Real kappa3 = kappa2*kappa_;

       return (sigma2*(theta_ - 2*v0_) +
           std::exp(2*kappa_*t)*(8*kappa3*t*theta_ -
           8*kappa2*(theta_ + rho_*sigma_*t*theta_ - v0_) +
           sigma2*(-5*theta_ + 2*v0_) + 2*kappa_*sigma_*(8*rho_*theta_ +
           sigma_*t*theta_ - 4*rho_*v0_)) +
           4*std::exp(kappa_*t)*(sigma2*theta_ -
           2*kappa2*(-1 + rho_*sigma_*t)*(theta_ - v0_) +
           kappa_*sigma_*(sigma_*t*(theta_ - v0_) + 2*rho_*(-2*theta_ +
           v0_))))/(8.*std::exp(2*kappa_*t)*kappa3);
   }

   Real COSHestonEngine::c3(Time t) const {
       const Real sigma2 = sigma_*sigma_;
       const Real sigma3 = sigma2*sigma_;
       const Real kappa2 = kappa_*kappa_;
       const Real kappa3 = kappa2*kappa_;
       const Real kappa4 = kappa3*kappa_;
       const Real rho2   = rho_*rho_;

       return
         -(sigma_*(sigma3*(theta_ - 3*v0_) +
           std::exp(3*kappa_*t)*(2*(-11*sigma3 -
           24*kappa4*rho_*t + 3*kappa_*sigma2*(20*rho_ +
           sigma_*t) - 6*kappa2*sigma_*(5 + 3*rho_*(4*rho_ + sigma_*t)) +
           12*kappa3*(sigma_*t + 2*rho_*(2 + rho_*sigma_*t)))*theta_ -
           6*(2*kappa_*rho_ - sigma_)*(4*kappa2 - 4*kappa_*rho_*sigma_ +
           sigma2)*v0_) + 6*std::exp(kappa_*t)*sigma_*(-2*kappa2*(-1 +
           rho_*sigma_*t)*(theta_ - 2*v0_) + sigma2*(theta_ - v0_) +
           kappa_*sigma_*(-4*rho_*theta_ + sigma_*t*theta_ + 6*rho_*v0_ - 2*sigma_*t*v0_)) +
           3*std::exp(2*kappa_*t)*(2*kappa_*sigma2*(-16*rho_*theta_ +
           sigma_*t*(3*theta_ - v0_)) + 8*kappa4*rho_*t*(-2 +
           rho_*sigma_*t)*(theta_ - v0_) + sigma3*(5*theta_ + v0_) +
           8*kappa3*(-(rho_*(4 + sigma2*t*t)*theta_) + 2*sigma_*t*(theta_ - v0_) +
           2*rho2*sigma_*t*(2*theta_ - v0_) + rho_*(2 +
           sigma2*t*t)*v0_) + 2*kappa2*sigma_*((8
           + 24*rho2 - 16*rho_*sigma_*t + sigma2*t*t)*theta_ - (8*rho2 -
           8*rho_*sigma_*t + sigma2*t*t)*v0_))))/(16.*std::exp(3*kappa_*t)*
           kappa_*kappa4);
   }

   Real COSHestonEngine::c4(Time t) const {
       const Real sigma2 = sigma_*sigma_;
       const Real sigma3 = sigma2*sigma_;
       const Real sigma4 = sigma2*sigma2;
       const Real kappa2 = kappa_*kappa_;
       const Real kappa3 = kappa2*kappa_;
       const Real kappa4 = kappa2*kappa2;
       const Real kappa5 = kappa2*kappa3;
       const Real kappa6 = kappa3*kappa3;
       const Real kappa7 = kappa4*kappa3;
       const Real rho2   = rho_*rho_;
       const Real rho3   = rho2*rho_;
       const Time t2     = t*t;
       const Time t3     = t2*t;

       return
           (sigma2*(3*sigma4*(theta_ - 4*v0_) +
           3*std::exp(4*kappa_*t)*((-93*sigma4 +
           64*kappa5*(t + 4*rho2*t) +
           4*kappa_*sigma3*(176*rho_ + 5*sigma_*t) -
           32*kappa2*sigma2*(11 + 50*rho2 +
           5*rho_*sigma_*t) + 32*kappa3*sigma_*(3*sigma_*t + 4*rho_*(10 +
           8*rho2 + 3*rho_*sigma_*t)) - 32*kappa4*(5 +
           4*rho_*(6*rho_ + (3 + 2*rho2)*sigma_*t)))*theta_ +
           4*(4*kappa2 - 4*kappa_*rho_*sigma_ +
           sigma2)*(4*kappa2*(1 + 4*rho2) -
           20*kappa_*rho_*sigma_ + 5*sigma2)*v0_) +
           24*std::exp(kappa_*t)*sigma2*(-2*kappa2*(-1 +
           rho_*sigma_*t)*(theta_ - 3*v0_) + sigma2*(theta_ - 2*v0_) +
           kappa_*sigma_*(-4*rho_*theta_ + sigma_*t*theta_ + 10*rho_*v0_ -
           3*sigma_*t*v0_)) + 12*std::exp(2*kappa_*t)*(sigma4*(7*theta_ -
           4*v0_) + 8*kappa4*(1 + 2*rho_*sigma_*t*(-2 +
           rho_*sigma_*t))*(theta_ - 2*v0_) +
           2*kappa_*sigma3*(-24*rho_*theta_ + 5*sigma_*t*theta_ +
           20*rho_*v0_ - 6*sigma_*t*v0_) + 4*kappa2*sigma2*((6
           + 20*rho2 - 14*rho_*sigma_*t +
           sigma2*t2)*theta_ - 2*(3 + 12*rho2 -
           10*rho_*sigma_*t + sigma2*t2)*v0_) +
           8*kappa3*sigma_*((3*sigma_*t + 2*rho_*(-4 + sigma_*t*(4*rho_ -
           sigma_*t)))*theta_ + 2*(-3*sigma_*t + 2*rho_*(3 + sigma_*t*(-3*rho_ +
           sigma_*t)))*v0_)) -
           8*std::exp(3*kappa_*t)*(16*kappa6*rho2*t2*(-3 + rho_*sigma_*t)*(theta_ - v0_) - 3*sigma4*(7*theta_ +
           2*v0_) + 2*kappa3*sigma_*((192*(rho_ + rho3) -
           6*(9 + 40*rho2)*sigma_*t + 42*rho_*sigma2*t2 -
           sigma3*t3)*theta_ + (-48*rho3 + 18*(1
           + 4*rho2)*sigma_*t - 24*rho_*sigma2*t2
           + sigma3*t3)*v0_) + 12*kappa4*((-4 -
           24*rho2 + 8*rho_*(4 + 3*rho2)*sigma_*t - (3 +
           14*rho2)*sigma2*t2 + rho_*sigma3*t3)*theta_ + (8*rho2 -
           8*rho_*(2 + rho2)*sigma_*t + (3 +
           8*rho2)*sigma2*t2 - rho_*sigma3*t3)*v0_) -
           6*kappa2*sigma2*((15 + 80*rho2 -
           35*rho_*sigma_*t + 2*sigma2*t2)*theta_ + (3 +
           sigma_*t*(7*rho_ - sigma_*t))*v0_) + 24*kappa5*t*((-2 +
           rho_*(4*sigma_*t + rho_*(-8 + sigma_*t*(4*rho_ - sigma_*t))))*theta_ + (2 +
           rho_*(-4*sigma_*t + rho_*(4 + sigma_*t*(-2*rho_ + sigma_*t))))*v0_) +
           3*kappa_*sigma3*(sigma_*t*(-9*theta_ + v0_) + 10*rho_*(6*theta_
           + v0_)))))/(64.*std::exp(4*kappa_*t)*kappa7);
   }

   Real COSHestonEngine::mu(Time t) const {
       return c1(t);
   }
   Real COSHestonEngine::var(Time t) const {
       return c2(t);
   }
   Real COSHestonEngine::skew(Time t) const {
       return c3(t)/std::pow(c2(t), 1.5);
   }
   Real COSHestonEngine::kurtosis(Time t) const {
       return c4(t)/squared(c2(t));
   }

}

]]></document_content>
  </document>
  <document index="114">
    <source>vanilla/discretizedvanillaoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/vanilla/discretizedvanillaoption.hpp>
#include <vector>

namespace QuantLib {

    DiscretizedVanillaOption::DiscretizedVanillaOption(
                                         const VanillaOption::arguments& args,
                                         const StochasticProcess& process,
                                         const TimeGrid& grid)
    : arguments_(args) {
        stoppingTimes_.resize(args.exercise->dates().size());
        for (Size i=0; i<stoppingTimes_.size(); ++i) {
            stoppingTimes_[i] =
                process.time(args.exercise->date(i));
            if (!grid.empty()) {
                // adjust to the given grid
                stoppingTimes_[i] = grid.closestTime(stoppingTimes_[i]);
            }
        }
    }

    void DiscretizedVanillaOption::reset(Size size) {
        values_ = Array(size, 0.0);
        adjustValues();
    }

    void DiscretizedVanillaOption::postAdjustValuesImpl() {

        Time now = time();
        switch (arguments_.exercise->type()) {
          case Exercise::American:
            if (now <= stoppingTimes_[1] &&
                now >= stoppingTimes_[0])
                applySpecificCondition();
            break;
          case Exercise::European:
            if (isOnTime(stoppingTimes_[0]))
                applySpecificCondition();
            break;
          case Exercise::Bermudan:
              for (Real stoppingTime : stoppingTimes_) {
                  if (isOnTime(stoppingTime))
                      applySpecificCondition();
              }
            break;
          default:
            QL_FAIL("invalid option type");
        }
    }

    void DiscretizedVanillaOption::applySpecificCondition() {
        Array grid = method()->grid(time());
        for (Size j=0; j<values_.size(); j++) {
            values_[j] = std::max(values_[j],
                                  (*arguments_.payoff)(grid[j]));
        }
    }

}

]]></document_content>
  </document>
  <document index="115">
    <source>vanilla/fdbatesvanillaengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdbatesvanillaengine.cpp
    \brief Partial Integro Finite-Differences Bates vanilla option engine
*/

#include <ql/processes/batesprocess.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbatessolver.hpp>
#include <ql/pricingengines/vanilla/fdbatesvanillaengine.hpp>
#include <ql/pricingengines/vanilla/fdhestonvanillaengine.hpp>

namespace QuantLib {

    FdBatesVanillaEngine::FdBatesVanillaEngine(
            const ext::shared_ptr<BatesModel>& model,
            Size tGrid, Size xGrid, 
            Size vGrid, Size dampingSteps,
            const FdmSchemeDesc& schemeDesc)
    : GenericModelEngine<BatesModel,
                         VanillaOption::arguments,
                         VanillaOption::results>(model),
      tGrid_(tGrid), xGrid_(xGrid),
      vGrid_(vGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc) {}

    FdBatesVanillaEngine::FdBatesVanillaEngine(
            const ext::shared_ptr<BatesModel>& model,
            DividendSchedule dividends,
            Size tGrid, Size xGrid, 
            Size vGrid, Size dampingSteps,
            const FdmSchemeDesc& schemeDesc)
    : GenericModelEngine<BatesModel,
                         VanillaOption::arguments,
                         VanillaOption::results>(model),
      dividends_(std::move(dividends)),
      tGrid_(tGrid), xGrid_(xGrid),
      vGrid_(vGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc) {}

    void FdBatesVanillaEngine::calculate() const {

        FdHestonVanillaEngine helperEngine(model_.currentLink(),
                                           dividends_,
                                           tGrid_, xGrid_, vGrid_,
                                           dampingSteps_, schemeDesc_);

        *dynamic_cast<VanillaOption::arguments*>(
                               helperEngine.getArguments()) = arguments_;

        FdmSolverDesc solverDesc = helperEngine.getSolverDesc(2.0);

        const ext::shared_ptr<BatesProcess> process =
                ext::dynamic_pointer_cast<BatesProcess>(model_->process());

        ext::shared_ptr<FdmBatesSolver> solver(
            new FdmBatesSolver(Handle<BatesProcess>(process),
                               solverDesc, schemeDesc_));

        const Real v0   = process->v0();
        const Real spot = process->s0()->value();

        results_.value = solver->valueAt(spot, v0);
        results_.delta = solver->deltaAt(spot, v0);
        results_.gamma = solver->gammaAt(spot, v0);
        results_.theta = solver->thetaAt(spot, v0);
    }
}
]]></document_content>
  </document>
  <document index="116">
    <source>vanilla/fdblackscholesshoutengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdblackscholesshoutengine.cpp
*/

#include <ql/exercise.hpp>
#include <ql/methods/finitedifferences/utilities/escroweddividendadjustment.hpp>
#include <ql/methods/finitedifferences/meshers/fdmblackscholesmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/solvers/fdmblackscholessolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmshoutloginnervaluecalculator.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesshoutengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    FdBlackScholesShoutEngine::FdBlackScholesShoutEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Size tGrid,
        Size xGrid,
        Size dampingSteps,
        const FdmSchemeDesc& schemeDesc)
    : process_(std::move(process)),
      tGrid_(tGrid), xGrid_(xGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc) {
        registerWith(process_);
    }

    FdBlackScholesShoutEngine::FdBlackScholesShoutEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        DividendSchedule dividends,
        Size tGrid,
        Size xGrid,
        Size dampingSteps,
        const FdmSchemeDesc& schemeDesc)
    : process_(std::move(process)), dividends_(std::move(dividends)),
      tGrid_(tGrid), xGrid_(xGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc) {
        registerWith(process_);
    }

    void FdBlackScholesShoutEngine::calculate() const {

        const Date exerciseDate = arguments_.exercise->lastDate();
        const Time maturity = process_->time(exerciseDate);
        const Date settlementDate = process_->riskFreeRate()->referenceDate();

        const auto escrowedDividendAdj =
            ext::make_shared<EscrowedDividendAdjustment>(
                dividends_,
                process_->riskFreeRate(),
                process_->dividendYield(),
                [&](Date d){ return process_->time(d); },
                maturity);

        const Real divAdj = escrowedDividendAdj
            ->dividendAdjustment(process_->time(settlementDate));

        QL_REQUIRE(process_->x0() + divAdj > 0.0,
                            "spot minus dividends becomes negative");

        const auto payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);

        QL_REQUIRE(payoff, "non plain vanilla payoff given");

        const DividendSchedule emptyDividendSchedule;

        const auto mesher = ext::make_shared<FdmMesherComposite>(
            ext::make_shared<FdmBlackScholesMesher>(
                xGrid_, process_, maturity, payoff->strike(),
                Null<Real>(), Null<Real>(), 0.0001, 1.5,
                std::pair<Real, Real>(payoff->strike(), 0.1),
                emptyDividendSchedule,
                ext::shared_ptr<FdmQuantoHelper>(),
                divAdj));

        const auto innerValuecalculator =
            ext::make_shared<FdmShoutLogInnerValueCalculator>(
                process_->blackVolatility(),
                escrowedDividendAdj, maturity, payoff, mesher, 0);

        DividendSchedule zeroDividendSchedule = DividendSchedule();
        for (const auto& cf: dividends_)
            zeroDividendSchedule.push_back(
                ext::make_shared<FixedDividend>(0.0, cf->date()));

        const auto conditions =
            FdmStepConditionComposite::vanillaComposite(
                zeroDividendSchedule,
                arguments_.exercise, mesher,
                innerValuecalculator,
                process_->riskFreeRate()->referenceDate(),
                process_->riskFreeRate()->dayCounter());

        const FdmSolverDesc solverDesc = {
            mesher, FdmBoundaryConditionSet(),
            conditions, innerValuecalculator,
            maturity, tGrid_, dampingSteps_ };

        const auto solver =
            ext::make_shared<FdmBlackScholesSolver>(
                Handle<GeneralizedBlackScholesProcess>(process_),
                payoff->strike(), solverDesc, schemeDesc_);

        const Real spot = process_->x0() + divAdj;

        results_.value = solver->valueAt(spot);
        results_.delta = solver->deltaAt(spot);
        results_.gamma = solver->gammaAt(spot);
        results_.theta = solver->thetaAt(spot);
    }
}
]]></document_content>
  </document>
  <document index="117">
    <source>vanilla/fdblackscholesvanillaengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/methods/finitedifferences/meshers/fdmblackscholesmesher.hpp>
#include <ql/methods/finitedifferences/utilities/escroweddividendadjustment.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/solvers/fdmblackscholessolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/methods/finitedifferences/utilities/fdmescrowedloginnervaluecalculator.hpp>
#include <ql/methods/finitedifferences/utilities/fdmquantohelper.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesvanillaengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    FdBlackScholesVanillaEngine::FdBlackScholesVanillaEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Size tGrid,
        Size xGrid,
        Size dampingSteps,
        const FdmSchemeDesc& schemeDesc,
        bool localVol,
        Real illegalLocalVolOverwrite,
        CashDividendModel cashDividendModel)
    : process_(std::move(process)), tGrid_(tGrid), xGrid_(xGrid),
      dampingSteps_(dampingSteps), schemeDesc_(schemeDesc), localVol_(localVol),
      illegalLocalVolOverwrite_(illegalLocalVolOverwrite), cashDividendModel_(cashDividendModel) {
        registerWith(process_);
    }

    FdBlackScholesVanillaEngine::FdBlackScholesVanillaEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        DividendSchedule dividends,
        Size tGrid,
        Size xGrid,
        Size dampingSteps,
        const FdmSchemeDesc& schemeDesc,
        bool localVol,
        Real illegalLocalVolOverwrite,
        CashDividendModel cashDividendModel)
    : process_(std::move(process)), dividends_(std::move(dividends)),
      tGrid_(tGrid), xGrid_(xGrid), dampingSteps_(dampingSteps), schemeDesc_(schemeDesc),
      localVol_(localVol), illegalLocalVolOverwrite_(illegalLocalVolOverwrite),
      cashDividendModel_(cashDividendModel) {
        registerWith(process_);
    }

    FdBlackScholesVanillaEngine::FdBlackScholesVanillaEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        ext::shared_ptr<FdmQuantoHelper> quantoHelper,
        Size tGrid,
        Size xGrid,
        Size dampingSteps,
        const FdmSchemeDesc& schemeDesc,
        bool localVol,
        Real illegalLocalVolOverwrite,
        CashDividendModel cashDividendModel)
    : process_(std::move(process)),
      tGrid_(tGrid), xGrid_(xGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), localVol_(localVol),
      illegalLocalVolOverwrite_(illegalLocalVolOverwrite), quantoHelper_(std::move(quantoHelper)),
      cashDividendModel_(cashDividendModel) {
        registerWith(process_);
        registerWith(quantoHelper_);
    }

    FdBlackScholesVanillaEngine::FdBlackScholesVanillaEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        DividendSchedule dividends,
        ext::shared_ptr<FdmQuantoHelper> quantoHelper,
        Size tGrid,
        Size xGrid,
        Size dampingSteps,
        const FdmSchemeDesc& schemeDesc,
        bool localVol,
        Real illegalLocalVolOverwrite,
        CashDividendModel cashDividendModel)
    : process_(std::move(process)), dividends_(std::move(dividends)),
      tGrid_(tGrid), xGrid_(xGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), localVol_(localVol),
      illegalLocalVolOverwrite_(illegalLocalVolOverwrite), quantoHelper_(std::move(quantoHelper)),
      cashDividendModel_(cashDividendModel) {
        registerWith(process_);
        registerWith(quantoHelper_);
    }


    void FdBlackScholesVanillaEngine::calculate() const {

        // 0. Cash dividend model
        const Date exerciseDate = arguments_.exercise->lastDate();
        const Time maturity = process_->time(exerciseDate);
        const Date settlementDate = process_->riskFreeRate()->referenceDate();

        Real spotAdjustment = 0.0;
        DividendSchedule dividendSchedule = DividendSchedule();

        ext::shared_ptr<EscrowedDividendAdjustment> escrowedDivAdj;

        switch (cashDividendModel_) {
          case Spot:
            dividendSchedule = dividends_;
            break;
          case Escrowed:
            if  (arguments_.exercise->type() != Exercise::European)
                // add dividend dates as stopping times
                for (const auto& cf: dividends_)
                    dividendSchedule.push_back(
                        ext::make_shared<FixedDividend>(0.0, cf->date()));

            QL_REQUIRE(quantoHelper_ == nullptr,
                "Escrowed dividend model is not supported for Quanto-Options");

            escrowedDivAdj = ext::make_shared<EscrowedDividendAdjustment>(
                dividends_,
                process_->riskFreeRate(),
                process_->dividendYield(),
                [&](Date d){ return process_->time(d); },
                maturity
            );

            spotAdjustment =
                escrowedDivAdj->dividendAdjustment(process_->time(settlementDate));

            QL_REQUIRE(process_->x0() + spotAdjustment > 0.0,
                    "spot minus dividends becomes negative");

            break;
          default:
              QL_FAIL("unknwon cash dividend model");
        }

        // 1. Mesher
        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);

        const ext::shared_ptr<Fdm1dMesher> equityMesher =
            ext::make_shared<FdmBlackScholesMesher>(
                    xGrid_, process_, maturity, payoff->strike(), 
                    Null<Real>(), Null<Real>(), 0.0001, 1.5,
                    std::pair<Real, Real>(payoff->strike(), 0.1),
                    dividendSchedule, quantoHelper_,
                    spotAdjustment);
        
        const ext::shared_ptr<FdmMesher> mesher =
            ext::make_shared<FdmMesherComposite>(equityMesher);
        
        // 2. Calculator
        const ext::shared_ptr<FdmInnerValueCalculator> calculator =
            ext::make_shared<FdmLogInnerValue>(payoff, mesher, 0);

        ext::shared_ptr<FdmInnerValueCalculator> earlyExerciseCalculator;
        switch (cashDividendModel_) {
          case Spot:
              earlyExerciseCalculator = calculator;
            break;
          case Escrowed:
              earlyExerciseCalculator = ext::make_shared<FdmEscrowedLogInnerValueCalculator>(
                  escrowedDivAdj, payoff, mesher, 0);
            break;
          default:
              QL_FAIL("unknwon cash dividend model");
        }

        // 3. Step conditions
        const ext::shared_ptr<FdmStepConditionComposite> conditions = 
            FdmStepConditionComposite::vanillaComposite(
                dividendSchedule, arguments_.exercise, mesher,
                earlyExerciseCalculator,
                process_->riskFreeRate()->referenceDate(),
                process_->riskFreeRate()->dayCounter());

        // 4. Boundary conditions
        const FdmBoundaryConditionSet boundaries;

        // 5. Solver
        FdmSolverDesc solverDesc = {
            mesher, boundaries, conditions, calculator, maturity, tGrid_, dampingSteps_
        };

        const ext::shared_ptr<FdmBlackScholesSolver> solver(
            ext::make_shared<FdmBlackScholesSolver>(
                Handle<GeneralizedBlackScholesProcess>(process_),
                payoff->strike(), solverDesc, schemeDesc_,
                localVol_, illegalLocalVolOverwrite_,
                Handle<FdmQuantoHelper>(quantoHelper_)));

        const Real spot = process_->x0() + spotAdjustment;

        results_.value = solver->valueAt(spot);
        results_.delta = solver->deltaAt(spot);
        results_.gamma = solver->gammaAt(spot);
        results_.theta = solver->thetaAt(spot);
    }

    MakeFdBlackScholesVanillaEngine::MakeFdBlackScholesVanillaEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)),
      schemeDesc_(ext::make_shared<FdmSchemeDesc>(FdmSchemeDesc::Douglas())),
      illegalLocalVolOverwrite_(-Null<Real>()) {}

    MakeFdBlackScholesVanillaEngine&
    MakeFdBlackScholesVanillaEngine::withQuantoHelper(
        const ext::shared_ptr<FdmQuantoHelper>& quantoHelper) {
        quantoHelper_ = quantoHelper;
        return *this;
    }

    MakeFdBlackScholesVanillaEngine&
    MakeFdBlackScholesVanillaEngine::withTGrid(Size tGrid) {
        tGrid_ = tGrid;
        return *this;
    }

    MakeFdBlackScholesVanillaEngine&
    MakeFdBlackScholesVanillaEngine::withXGrid(Size xGrid) {
        xGrid_ = xGrid;
        return *this;
    }

    MakeFdBlackScholesVanillaEngine&
    MakeFdBlackScholesVanillaEngine::withDampingSteps(Size dampingSteps) {
        dampingSteps_ = dampingSteps;
        return *this;
    }

    MakeFdBlackScholesVanillaEngine&
    MakeFdBlackScholesVanillaEngine::withFdmSchemeDesc(
        const FdmSchemeDesc& schemeDesc) {
        schemeDesc_ = ext::make_shared<FdmSchemeDesc>(schemeDesc);
        return *this;
    }

    MakeFdBlackScholesVanillaEngine&
    MakeFdBlackScholesVanillaEngine::withLocalVol(bool localVol) {
        localVol_ = localVol;
        return *this;
    }

    MakeFdBlackScholesVanillaEngine&
    MakeFdBlackScholesVanillaEngine::withIllegalLocalVolOverwrite(
        Real illegalLocalVolOverwrite) {
        illegalLocalVolOverwrite_ = illegalLocalVolOverwrite;
        return *this;
    }

    MakeFdBlackScholesVanillaEngine&
    MakeFdBlackScholesVanillaEngine::withCashDividends(
            const std::vector<Date>& dividendDates,
            const std::vector<Real>& dividendAmounts) {
        dividends_ = DividendVector(dividendDates, dividendAmounts);
        return *this;
    }

    MakeFdBlackScholesVanillaEngine&
    MakeFdBlackScholesVanillaEngine::withCashDividendModel(
        FdBlackScholesVanillaEngine::CashDividendModel cashDividendModel) {
        cashDividendModel_ = cashDividendModel;
        return *this;
    }

    MakeFdBlackScholesVanillaEngine::operator
    ext::shared_ptr<PricingEngine>() const {
        return ext::make_shared<FdBlackScholesVanillaEngine>(
                process_,
                dividends_,
                quantoHelper_,
                tGrid_, xGrid_, dampingSteps_,
                *schemeDesc_,
                localVol_,
                illegalLocalVolOverwrite_,
                cashDividendModel_);
    }

}
]]></document_content>
  </document>
  <document index="118">
    <source>vanilla/fdcevvanillaengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdcevvanillaengine.hpp
    \brief Finite-Differences pricing engine for the CEV model
*/

#include <ql/exercise.hpp>
#include <ql/methods/finitedifferences/meshers/concentrating1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmcev1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/operators/fdmcevop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/solvers/fdm1dimsolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdiscountdirichletboundary.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/methods/finitedifferences/utilities/fdmtimedepdirichletboundary.hpp>
#include <ql/pricingengines/vanilla/analyticcevengine.hpp>
#include <ql/pricingengines/vanilla/fdcevvanillaengine.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    namespace {
        class PriceAtBoundary {
          public:
            PriceAtBoundary(Time maturityTime,
                            ext::shared_ptr<StrikedTypePayoff> payoff,
                            ext::shared_ptr<YieldTermStructure> rTS,
                            ext::shared_ptr<CEVCalculator> calculator)
            : maturityTime_(maturityTime), payoff_(std::move(payoff)),
              calculator_(std::move(calculator)), rTS_(std::move(rTS)) {}

            Real operator()(Real t) const {
                const Time time2Expiry = std::max(1/365., maturityTime_ - t);
                const DiscountFactor df =
                    rTS_->discount(maturityTime_) / rTS_->discount(t);

                return  df * calculator_->value(
                    payoff_->optionType(), payoff_->strike(), time2Expiry);
            }

          private:
            const Time maturityTime_;
            const ext::shared_ptr<StrikedTypePayoff> payoff_;
            const ext::shared_ptr<CEVCalculator> calculator_;
            const ext::shared_ptr<YieldTermStructure> rTS_;
        };
    }

    FdCEVVanillaEngine::FdCEVVanillaEngine(Real f0,
                                           Real alpha,
                                           Real beta,
                                           Handle<YieldTermStructure> discountCurve,
                                           Size tGrid,
                                           Size xGrid,
                                           Size dampingSteps,
                                           Real scalingFactor,
                                           Real eps,
                                           const FdmSchemeDesc& schemeDesc)
    : f0_(f0), alpha_(alpha), beta_(beta), discountCurve_(std::move(discountCurve)), tGrid_(tGrid),
      xGrid_(xGrid), dampingSteps_(dampingSteps), scalingFactor_(scalingFactor), eps_(eps),
      schemeDesc_(schemeDesc) {
        registerWith(discountCurve_);
    }

    void FdCEVVanillaEngine::calculate() const {

        // 1. Mesher
        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        const ext::shared_ptr<YieldTermStructure> rTS =
            discountCurve_.currentLink();

        const DayCounter dc = rTS->dayCounter();

        const Date referenceDate = rTS->referenceDate();
        const Date maturityDate = arguments_.exercise->lastDate();
        const Time maturityTime = dc.yearFraction(referenceDate, maturityDate);

        const ext::shared_ptr<Fdm1dMesher> cevMesher =
            ext::make_shared<FdmCEV1dMesher>(
                xGrid_,
                f0_, alpha_, beta_,
                maturityTime, eps_, scalingFactor_,
                std::make_pair(payoff->strike(), 0.1));

        const Real lowerBound = cevMesher->locations().front();
        const Real upperBound = cevMesher->locations().back();

        const ext::shared_ptr<FdmMesher> mesher =
           ext::make_shared<FdmMesherComposite>(cevMesher);

        // 2. Calculator
        const ext::shared_ptr<FdmInnerValueCalculator> calculator =
            ext::make_shared<FdmCellAveragingInnerValue>(payoff, mesher, 0);

        // 3. Step conditions
        const ext::shared_ptr<FdmStepConditionComposite> conditions =
            FdmStepConditionComposite::vanillaComposite(
                DividendSchedule(), arguments_.exercise,
                mesher, calculator,
                referenceDate, dc);

        // 4. Boundary conditions
        FdmBoundaryConditionSet boundaries;

        const PriceAtBoundary upperBoundPrice(
            maturityTime, payoff, rTS,
            ext::make_shared<CEVCalculator>(upperBound, alpha_, beta_));

        boundaries.push_back(ext::make_shared<FdmTimeDepDirichletBoundary>(
            mesher, std::function<Real (Real)>(upperBoundPrice),
            0, FdmTimeDepDirichletBoundary::Upper));

        const Real delta = (1-2*beta_)/(1-beta_);
        if (delta < 2.0) {
            const Real terminalCashFlow = (*payoff)(lowerBound);

            boundaries.push_back(
                ext::make_shared<FdmDiscountDirichletBoundary>(
                    mesher, rTS, maturityTime, terminalCashFlow,
                    0, FdmTimeDepDirichletBoundary::Lower));
        }

        // 5. Solver
        const FdmSolverDesc solverDesc = {
            mesher, boundaries, conditions,
            calculator, maturityTime, tGrid_, dampingSteps_
        };

        const ext::shared_ptr<FdmLinearOpComposite> op =
            ext::make_shared<FdmCEVOp>(
               mesher, discountCurve_.currentLink(), f0_, alpha_, beta_, 0);

        const ext::shared_ptr<Fdm1DimSolver> solver =
            ext::make_shared<Fdm1DimSolver>(solverDesc, schemeDesc_, op);

        results_.value = solver->interpolateAt(f0_);
        results_.delta = solver->derivativeX(f0_);
        results_.gamma = solver->derivativeXX(f0_);
        results_.theta = solver->thetaAt(f0_);
    }
}
]]></document_content>
  </document>
  <document index="119">
    <source>vanilla/fdcirvanillaengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Lew Wei Hao

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include <ql/methods/finitedifferences/meshers/fdmblackscholesmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/meshers/fdmsimpleprocess1dmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/solvers/fdmcirsolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/pricingengines/vanilla/fdcirvanillaengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/coxingersollrossprocess.hpp>
#include <utility>

namespace QuantLib {

    FdCIRVanillaEngine::FdCIRVanillaEngine(
        ext::shared_ptr<CoxIngersollRossProcess> cirProcess,
        ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess,
        Size tGrid,
        Size xGrid,
        Size rGrid,
        Size dampingSteps,
        const Real rho,
        const FdmSchemeDesc& schemeDesc,
        ext::shared_ptr<FdmQuantoHelper> quantoHelper)
    :  bsProcess_(std::move(bsProcess)), cirProcess_(std::move(cirProcess)),
       quantoHelper_(std::move(quantoHelper)),
       tGrid_(tGrid), xGrid_(xGrid), rGrid_(rGrid), dampingSteps_(dampingSteps),
       rho_(rho), schemeDesc_(schemeDesc) {}

    FdCIRVanillaEngine::FdCIRVanillaEngine(
        ext::shared_ptr<CoxIngersollRossProcess> cirProcess,
        ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess,
        DividendSchedule dividends,
        Size tGrid,
        Size xGrid,
        Size rGrid,
        Size dampingSteps,
        const Real rho,
        const FdmSchemeDesc& schemeDesc,
        ext::shared_ptr<FdmQuantoHelper> quantoHelper)
    : bsProcess_(std::move(bsProcess)), cirProcess_(std::move(cirProcess)),
      quantoHelper_(std::move(quantoHelper)), dividends_(std::move(dividends)),
      tGrid_(tGrid), xGrid_(xGrid), rGrid_(rGrid), dampingSteps_(dampingSteps), rho_(rho),
      schemeDesc_(schemeDesc) {}

    FdmSolverDesc FdCIRVanillaEngine::getSolverDesc(Real) const {

        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        const Time maturity = bsProcess_->time(arguments_.exercise->lastDate());

        // The short rate mesher
        const ext::shared_ptr<Fdm1dMesher> shortRateMesher(
            new FdmSimpleProcess1dMesher(rGrid_, cirProcess_, maturity, tGrid_));

        // The equity mesher
        const ext::shared_ptr<Fdm1dMesher> equityMesher(
            new FdmBlackScholesMesher(
                xGrid_, bsProcess_, maturity, payoff->strike(),
                Null<Real>(), Null<Real>(), 0.0001, 1.5,
                std::pair<Real, Real>(payoff->strike(), 0.1),
                dividends_, quantoHelper_,
                0.0));
        
        const ext::shared_ptr<FdmMesher> mesher(
            new FdmMesherComposite(equityMesher, shortRateMesher));

        // Calculator
        const ext::shared_ptr<FdmInnerValueCalculator> calculator(
                          new FdmLogInnerValue(arguments_.payoff, mesher, 0));

        // Step conditions
        const ext::shared_ptr<FdmStepConditionComposite> conditions = 
             FdmStepConditionComposite::vanillaComposite(
                                 dividends_, arguments_.exercise, 
                                 mesher, calculator,
                                 bsProcess_->riskFreeRate()->referenceDate(),
                                 bsProcess_->riskFreeRate()->dayCounter());

        // Boundary conditions
        const FdmBoundaryConditionSet boundaries;

        // Solver
        FdmSolverDesc solverDesc = { mesher, boundaries, conditions,
                                     calculator, maturity,
                                     tGrid_, dampingSteps_ };

        return solverDesc;
    }

    void FdCIRVanillaEngine::calculate() const {
        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);

        ext::shared_ptr<FdmCIRSolver> solver(new FdmCIRSolver(
                    Handle<CoxIngersollRossProcess>(cirProcess_),
                    Handle<GeneralizedBlackScholesProcess>(bsProcess_),
                    getSolverDesc(1.5), schemeDesc_,
                    rho_, payoff->strike()));

        const Real r0   = cirProcess_->x0();
        const Real spot = bsProcess_->x0();

        results_.value = solver->valueAt(spot, r0);
        results_.delta = solver->deltaAt(spot, r0);
        results_.gamma = solver->gammaAt(spot, r0);
        results_.theta = solver->thetaAt(spot, r0);
    }

    MakeFdCIRVanillaEngine::MakeFdCIRVanillaEngine(
        ext::shared_ptr<CoxIngersollRossProcess> cirProcess,
        ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess,
        const Real rho)
    : cirProcess_(std::move(cirProcess)), bsProcess_(std::move(bsProcess)), rho_(rho),
      schemeDesc_(ext::make_shared<FdmSchemeDesc>(FdmSchemeDesc::ModifiedHundsdorfer())) {}

    MakeFdCIRVanillaEngine& MakeFdCIRVanillaEngine::withQuantoHelper(
        const ext::shared_ptr<FdmQuantoHelper>& quantoHelper) {
        quantoHelper_ = quantoHelper;
        return *this;
    }

    MakeFdCIRVanillaEngine&
    MakeFdCIRVanillaEngine::withTGrid(Size tGrid) {
        tGrid_ = tGrid;
        return *this;
    }

    MakeFdCIRVanillaEngine&
    MakeFdCIRVanillaEngine::withXGrid(Size xGrid) {
        xGrid_ = xGrid;
        return *this;
    }

    MakeFdCIRVanillaEngine&
    MakeFdCIRVanillaEngine::withRGrid(Size rGrid) {
        rGrid_ = rGrid;
        return *this;
    }

    MakeFdCIRVanillaEngine&
    MakeFdCIRVanillaEngine::withDampingSteps(Size dampingSteps) {
        dampingSteps_ = dampingSteps;
        return *this;
    }

    MakeFdCIRVanillaEngine&
    MakeFdCIRVanillaEngine::withFdmSchemeDesc(
        const FdmSchemeDesc& schemeDesc) {
        schemeDesc_ = ext::make_shared<FdmSchemeDesc>(schemeDesc);
        return *this;
    }

    MakeFdCIRVanillaEngine&
    MakeFdCIRVanillaEngine::withCashDividends(
            const std::vector<Date>& dividendDates,
            const std::vector<Real>& dividendAmounts) {
        dividends_ = DividendVector(dividendDates, dividendAmounts);
        return *this;
    }

    MakeFdCIRVanillaEngine::operator
    ext::shared_ptr<PricingEngine>() const {
        return ext::make_shared<FdCIRVanillaEngine>(
                cirProcess_,
                bsProcess_,
                dividends_,
                tGrid_, xGrid_, rGrid_, dampingSteps_,
                rho_,
                *schemeDesc_,
                quantoHelper_);
    }

}
]]></document_content>
  </document>
  <document index="120">
    <source>vanilla/fdhestonhullwhitevanillaengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/meshers/fdmblackscholesmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmblackscholesmultistrikemesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmhestonvariancemesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/meshers/fdmsimpleprocess1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/uniform1dmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/pricingengines/vanilla/analytichestonengine.hpp>
#include <ql/pricingengines/vanilla/fdhestonhullwhitevanillaengine.hpp>
#include <ql/pricingengines/vanilla/fdhestonvanillaengine.hpp>
#include <utility>

namespace QuantLib {

    FdHestonHullWhiteVanillaEngine::FdHestonHullWhiteVanillaEngine(
        const ext::shared_ptr<HestonModel>& hestonModel,
        ext::shared_ptr<HullWhiteProcess> hwProcess,
        Real corrEquityShortRate,
        Size tGrid,
        Size xGrid,
        Size vGrid,
        Size rGrid,
        Size dampingSteps,
        bool controlVariate,
        const FdmSchemeDesc& schemeDesc)
    : GenericModelEngine<HestonModel,
                         VanillaOption::arguments,
                         VanillaOption::results>(hestonModel),
      hwProcess_(std::move(hwProcess)),
      corrEquityShortRate_(corrEquityShortRate), tGrid_(tGrid),
      xGrid_(xGrid), vGrid_(vGrid), rGrid_(rGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), controlVariate_(controlVariate) {}

    FdHestonHullWhiteVanillaEngine::FdHestonHullWhiteVanillaEngine(
        const ext::shared_ptr<HestonModel>& hestonModel,
        ext::shared_ptr<HullWhiteProcess> hwProcess,
        DividendSchedule dividends,
        Real corrEquityShortRate,
        Size tGrid,
        Size xGrid,
        Size vGrid,
        Size rGrid,
        Size dampingSteps,
        bool controlVariate,
        const FdmSchemeDesc& schemeDesc)
    : GenericModelEngine<HestonModel,
                         VanillaOption::arguments,
                         VanillaOption::results>(hestonModel),
      hwProcess_(std::move(hwProcess)), dividends_(std::move(dividends)),
      corrEquityShortRate_(corrEquityShortRate), tGrid_(tGrid),
      xGrid_(xGrid), vGrid_(vGrid), rGrid_(rGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), controlVariate_(controlVariate) {}

    void FdHestonHullWhiteVanillaEngine::calculate() const {
  
        // 1. cache lookup for precalculated results
        for (auto& cachedArgs2result : cachedArgs2results_) {
            if (cachedArgs2result.first.exercise->type() == arguments_.exercise->type() &&
                cachedArgs2result.first.exercise->dates() == arguments_.exercise->dates()) {
                ext::shared_ptr<PlainVanillaPayoff> p1 =
                    ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                                                            arguments_.payoff);
                ext::shared_ptr<PlainVanillaPayoff> p2 =
                    ext::dynamic_pointer_cast<PlainVanillaPayoff>(cachedArgs2result.first.payoff);

                if ((p1 != nullptr) && p1->strike() == p2->strike() &&
                    p1->optionType() == p2->optionType()) {
                    QL_REQUIRE(dividends_.empty(),
                               "multiple strikes engine does not work with discrete dividends");
                    results_ = cachedArgs2result.second;
                    return;
                }
            }
        }

        // 2. Mesher
        const ext::shared_ptr<HestonProcess> hestonProcess=model_->process();
        const Time maturity=hestonProcess->time(arguments_.exercise->lastDate());

        // 2.1 The variance mesher
        const Size tGridMin = 5;
        const ext::shared_ptr<FdmHestonVarianceMesher> varianceMesher(
            new FdmHestonVarianceMesher(vGrid_, hestonProcess,
                                        maturity,std::max(tGridMin,tGrid_/50)));

        // 2.2 The equity mesher
        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "wrong payoff type given");

        ext::shared_ptr<Fdm1dMesher> equityMesher;
        if (strikes_.empty()) {
            equityMesher = ext::shared_ptr<Fdm1dMesher>(
                new FdmBlackScholesMesher(
                    xGrid_, 
                    FdmBlackScholesMesher::processHelper(
                      hestonProcess->s0(), hestonProcess->dividendYield(), 
                      hestonProcess->riskFreeRate(), 
                      varianceMesher->volaEstimate()),
                      maturity, payoff->strike(),
                      Null<Real>(), Null<Real>(), 0.0001, 1.5, 
                      std::pair<Real, Real>(payoff->strike(), 0.1),
                      dividends_));
        }
        else {
            QL_REQUIRE(dividends_.empty(),
                       "multiple strikes engine does not work with discrete dividends");
            equityMesher = ext::shared_ptr<Fdm1dMesher>(
                new FdmBlackScholesMultiStrikeMesher(
                    xGrid_,
                    FdmBlackScholesMesher::processHelper(
                      hestonProcess->s0(), hestonProcess->dividendYield(), 
                      hestonProcess->riskFreeRate(), 
                      varianceMesher->volaEstimate()),
                    maturity, strikes_, 0.0001, 1.5,
                    std::pair<Real, Real>(payoff->strike(), 0.075)));            
        }
       
        //2.3 The short rate mesher        
        const ext::shared_ptr<OrnsteinUhlenbeckProcess> ouProcess(
            new OrnsteinUhlenbeckProcess(hwProcess_->a(),hwProcess_->sigma()));
        const ext::shared_ptr<Fdm1dMesher> shortRateMesher(
                   new FdmSimpleProcess1dMesher(rGrid_, ouProcess, maturity));
        
        const ext::shared_ptr<FdmMesher> mesher(
            new FdmMesherComposite(equityMesher, varianceMesher,
                                   shortRateMesher));

        // 3. Calculator
        const ext::shared_ptr<FdmInnerValueCalculator> calculator(
                            new FdmLogInnerValue(arguments_.payoff, mesher, 0));

        // 4. Step conditions
        const ext::shared_ptr<FdmStepConditionComposite> conditions = 
            FdmStepConditionComposite::vanillaComposite(
                                dividends_, arguments_.exercise, 
                                mesher, calculator, 
                                hestonProcess->riskFreeRate()->referenceDate(),
                                hestonProcess->riskFreeRate()->dayCounter());

        // 5. Boundary conditions
        const FdmBoundaryConditionSet boundaries;

        // 6. Solver
        const FdmSolverDesc solverDesc = { mesher, boundaries, conditions,
                                           calculator, maturity,
                                           tGrid_, dampingSteps_ };

        const ext::shared_ptr<FdmHestonHullWhiteSolver> solver(
            new FdmHestonHullWhiteSolver(Handle<HestonProcess>(hestonProcess),
                                         Handle<HullWhiteProcess>(hwProcess_),
                                         corrEquityShortRate_,
                                         solverDesc, schemeDesc_));

        const Real spot = hestonProcess->s0()->value();
        const Real v0   = hestonProcess->v0();
        results_.value = solver->valueAt(spot, v0, 0);
        results_.delta = solver->deltaAt(spot, v0, 0, spot*0.01);
        results_.gamma = solver->gammaAt(spot, v0, 0, spot*0.01);
        results_.theta = solver->thetaAt(spot, v0, 0);

        cachedArgs2results_.resize(strikes_.size());        
        for (Size i=0; i < strikes_.size(); ++i) {
            cachedArgs2results_[i].first.exercise = arguments_.exercise;
            cachedArgs2results_[i].first.payoff = 
                ext::make_shared<PlainVanillaPayoff>(
                    payoff->optionType(), strikes_[i]);
            const Real d = payoff->strike()/strikes_[i];

            VanillaOption::results& results = cachedArgs2results_[i].second;
            results.value = solver->valueAt(spot*d, v0, 0)/d;
            results.delta = solver->deltaAt(spot*d, v0, 0, spot*d*0.01);
            results.gamma = solver->gammaAt(spot*d, v0, 0, spot*d*0.01)*d;
            results.theta = solver->thetaAt(spot*d, v0, 0)/d;
        }
     
        if (controlVariate_) {
            ext::shared_ptr<PricingEngine> analyticEngine(
                                       new AnalyticHestonEngine(*model_, 164));
            ext::shared_ptr<Exercise> exercise(
                        new EuropeanExercise(arguments_.exercise->lastDate()));
            
            VanillaOption option(payoff, exercise);
            option.setPricingEngine(analyticEngine);
            Real analyticNPV = option.NPV();

            ext::shared_ptr<FdHestonVanillaEngine> fdEngine(
                    new FdHestonVanillaEngine(*model_, tGrid_, xGrid_,
                                              vGrid_, dampingSteps_, 
                                              schemeDesc_));
            fdEngine->enableMultipleStrikesCaching(strikes_);
            option.setPricingEngine(fdEngine);
            
            Real fdNPV = option.NPV();
            results_.value += analyticNPV - fdNPV;
            for (Size i=0; i < strikes_.size(); ++i) {
                VanillaOption controlVariateOption(
                    ext::shared_ptr<StrikedTypePayoff>(
                        new PlainVanillaPayoff(payoff->optionType(), 
                                               strikes_[i])), exercise);
                controlVariateOption.setPricingEngine(analyticEngine);
                analyticNPV = controlVariateOption.NPV();
                
                controlVariateOption.setPricingEngine(fdEngine);
                fdNPV = controlVariateOption.NPV();
                cachedArgs2results_[i].second.value += analyticNPV - fdNPV;
            }
        }
    }
    
    void FdHestonHullWhiteVanillaEngine::update() {
        cachedArgs2results_.clear();
        GenericModelEngine<HestonModel,
                           VanillaOption::arguments,
                           VanillaOption::results>::update();
    }

    void FdHestonHullWhiteVanillaEngine::enableMultipleStrikesCaching(
                                        const std::vector<Real>& strikes) {
        strikes_ = strikes;
        update();
    }

}
]]></document_content>
  </document>
  <document index="121">
    <source>vanilla/fdhestonvanillaengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008, 2009, 2015 Klaus Spanderen
 Copyright (C) 2015 Johannes Göttker-Schnetmann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/meshers/fdmblackscholesmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmblackscholesmultistrikemesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmhestonvariancemesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/solvers/fdmhestonsolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/pricingengines/vanilla/fdhestonvanillaengine.hpp>
#include <ql/processes/batesprocess.hpp>
#include <utility>

namespace QuantLib {

    FdHestonVanillaEngine::FdHestonVanillaEngine(const ext::shared_ptr<HestonModel>& model,
                                                 Size tGrid,
                                                 Size xGrid,
                                                 Size vGrid,
                                                 Size dampingSteps,
                                                 const FdmSchemeDesc& schemeDesc,
                                                 ext::shared_ptr<LocalVolTermStructure> leverageFct,
                                                 const Real mixingFactor)
    : GenericModelEngine<HestonModel,
                         VanillaOption::arguments,
                         VanillaOption::results>(model),
      tGrid_(tGrid), xGrid_(xGrid), vGrid_(vGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), leverageFct_(std::move(leverageFct)),
      quantoHelper_(ext::shared_ptr<FdmQuantoHelper>()), mixingFactor_(mixingFactor) {}

    FdHestonVanillaEngine::FdHestonVanillaEngine(const ext::shared_ptr<HestonModel>& model,
                                                 DividendSchedule dividends,
                                                 Size tGrid,
                                                 Size xGrid,
                                                 Size vGrid,
                                                 Size dampingSteps,
                                                 const FdmSchemeDesc& schemeDesc,
                                                 ext::shared_ptr<LocalVolTermStructure> leverageFct,
                                                 const Real mixingFactor)
    : GenericModelEngine<HestonModel,
                         VanillaOption::arguments,
                         VanillaOption::results>(model),
      dividends_(std::move(dividends)),
      tGrid_(tGrid), xGrid_(xGrid), vGrid_(vGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), leverageFct_(std::move(leverageFct)),
      quantoHelper_(ext::shared_ptr<FdmQuantoHelper>()), mixingFactor_(mixingFactor) {}

    FdHestonVanillaEngine::FdHestonVanillaEngine(const ext::shared_ptr<HestonModel>& model,
                                                 ext::shared_ptr<FdmQuantoHelper> quantoHelper,
                                                 Size tGrid,
                                                 Size xGrid,
                                                 Size vGrid,
                                                 Size dampingSteps,
                                                 const FdmSchemeDesc& schemeDesc,
                                                 ext::shared_ptr<LocalVolTermStructure> leverageFct,
                                                 const Real mixingFactor)
    : GenericModelEngine<HestonModel,
                         VanillaOption::arguments,
                         VanillaOption::results>(model),
      tGrid_(tGrid), xGrid_(xGrid), vGrid_(vGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), leverageFct_(std::move(leverageFct)),
      quantoHelper_(std::move(quantoHelper)), mixingFactor_(mixingFactor) {}

    FdHestonVanillaEngine::FdHestonVanillaEngine(const ext::shared_ptr<HestonModel>& model,
                                                 DividendSchedule dividends,
                                                 ext::shared_ptr<FdmQuantoHelper> quantoHelper,
                                                 Size tGrid,
                                                 Size xGrid,
                                                 Size vGrid,
                                                 Size dampingSteps,
                                                 const FdmSchemeDesc& schemeDesc,
                                                 ext::shared_ptr<LocalVolTermStructure> leverageFct,
                                                 const Real mixingFactor)
    : GenericModelEngine<HestonModel,
                         VanillaOption::arguments,
                         VanillaOption::results>(model),
      dividends_(std::move(dividends)),
      tGrid_(tGrid), xGrid_(xGrid), vGrid_(vGrid), dampingSteps_(dampingSteps),
      schemeDesc_(schemeDesc), leverageFct_(std::move(leverageFct)),
      quantoHelper_(std::move(quantoHelper)), mixingFactor_(mixingFactor) {}

    FdmSolverDesc FdHestonVanillaEngine::getSolverDesc(Real) const {

        // 1. Mesher
        const ext::shared_ptr<HestonProcess> process = model_->process();
        const Time maturity = process->time(arguments_.exercise->lastDate());

        // 1.1 The variance mesher
        const Size tGridMin = 5;
        const Size tGridAvgSteps = std::max(tGridMin, tGrid_/50);
        const ext::shared_ptr<FdmHestonLocalVolatilityVarianceMesher> vMesher
            = ext::make_shared<FdmHestonLocalVolatilityVarianceMesher>(
                  vGrid_, process, leverageFct_, maturity, tGridAvgSteps, 0.0001, mixingFactor_);

        const Volatility avgVolaEstimate = vMesher->volaEstimate();

        // 1.2 The equity mesher
        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);

        ext::shared_ptr<Fdm1dMesher> equityMesher;
        if (strikes_.empty()) {
            equityMesher = ext::shared_ptr<Fdm1dMesher>(
                new FdmBlackScholesMesher(
                    xGrid_,
                    FdmBlackScholesMesher::processHelper(
                        process->s0(), process->dividendYield(),
                        process->riskFreeRate(), avgVolaEstimate),
                    maturity, payoff->strike(),
                    Null<Real>(), Null<Real>(), 0.0001, 2.0,
                    std::pair<Real, Real>(payoff->strike(), 0.1),
                    dividends_,
                    quantoHelper_));
        }
        else {
            QL_REQUIRE(dividends_.empty(),
                       "multiple strikes engine does not work with discrete dividends");
            equityMesher = ext::shared_ptr<Fdm1dMesher>(
                new FdmBlackScholesMultiStrikeMesher(
                    xGrid_,
                    FdmBlackScholesMesher::processHelper(
                      process->s0(), process->dividendYield(),
                      process->riskFreeRate(), avgVolaEstimate),
                    maturity, strikes_, 0.0001, 1.5,
                    std::pair<Real, Real>(payoff->strike(), 0.075)));
        }

        const ext::shared_ptr<FdmMesher> mesher(
            new FdmMesherComposite(equityMesher, vMesher));

        // 2. Calculator
        const ext::shared_ptr<FdmInnerValueCalculator> calculator(
                          new FdmLogInnerValue(arguments_.payoff, mesher, 0));

        // 3. Step conditions
        const ext::shared_ptr<FdmStepConditionComposite> conditions =
             FdmStepConditionComposite::vanillaComposite(
                                 dividends_, arguments_.exercise,
                                 mesher, calculator,
                                 process->riskFreeRate()->referenceDate(),
                                 process->riskFreeRate()->dayCounter());

        // 4. Boundary conditions
        const FdmBoundaryConditionSet boundaries;

        // 5. Solver
        FdmSolverDesc solverDesc = { mesher, boundaries, conditions,
                                     calculator, maturity,
                                     tGrid_, dampingSteps_ };

       return solverDesc;
    }

    void FdHestonVanillaEngine::calculate() const {

        // cache lookup for precalculated results
        for (auto& cachedArgs2result : cachedArgs2results_) {
            if (cachedArgs2result.first.exercise->type() == arguments_.exercise->type() &&
                cachedArgs2result.first.exercise->dates() == arguments_.exercise->dates()) {
                ext::shared_ptr<PlainVanillaPayoff> p1 =
                    ext::dynamic_pointer_cast<PlainVanillaPayoff>(
                                                            arguments_.payoff);
                ext::shared_ptr<PlainVanillaPayoff> p2 =
                    ext::dynamic_pointer_cast<PlainVanillaPayoff>(cachedArgs2result.first.payoff);

                if ((p1 != nullptr) && p1->strike() == p2->strike() &&
                    p1->optionType() == p2->optionType()) {
                    QL_REQUIRE(dividends_.empty(),
                               "multiple strikes engine does not work with discrete dividends");
                    results_ = cachedArgs2result.second;
                    return;
                }
            }
        }

        const ext::shared_ptr<HestonProcess> process = model_->process();

        ext::shared_ptr<FdmHestonSolver> solver(new FdmHestonSolver(
                    Handle<HestonProcess>(process),
                    getSolverDesc(1.5), schemeDesc_,
                    Handle<FdmQuantoHelper>(quantoHelper_), leverageFct_,
                    mixingFactor_));

        const Real v0   = process->v0();
        const Real spot = process->s0()->value();

        results_.value = solver->valueAt(spot, v0);
        results_.delta = solver->deltaAt(spot, v0);
        results_.gamma = solver->gammaAt(spot, v0);
        results_.theta = solver->thetaAt(spot, v0);

        cachedArgs2results_.resize(strikes_.size());
        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        for (Size i=0; i < strikes_.size(); ++i) {
            cachedArgs2results_[i].first.exercise = arguments_.exercise;
            cachedArgs2results_[i].first.payoff =
                ext::make_shared<PlainVanillaPayoff>(
                    payoff->optionType(), strikes_[i]);
            const Real d = payoff->strike()/strikes_[i];

            VanillaOption::results& results = cachedArgs2results_[i].second;
            results.value = solver->valueAt(spot*d, v0)/d;
            results.delta = solver->deltaAt(spot*d, v0);
            results.gamma = solver->gammaAt(spot*d, v0)*d;
            results.theta = solver->thetaAt(spot*d, v0)/d;
        }
    }

    void FdHestonVanillaEngine::update() {
        cachedArgs2results_.clear();
        GenericModelEngine<HestonModel,
                           VanillaOption::arguments,
                           VanillaOption::results>::update();
    }

    void FdHestonVanillaEngine::enableMultipleStrikesCaching(
                                        const std::vector<Real>& strikes) {
        strikes_ = strikes;
        cachedArgs2results_.clear();
    }


    MakeFdHestonVanillaEngine::MakeFdHestonVanillaEngine(ext::shared_ptr<HestonModel> hestonModel)
    : hestonModel_(std::move(hestonModel)),
      schemeDesc_(ext::make_shared<FdmSchemeDesc>(FdmSchemeDesc::Hundsdorfer())) {}

    MakeFdHestonVanillaEngine& MakeFdHestonVanillaEngine::withQuantoHelper(
        const ext::shared_ptr<FdmQuantoHelper>& quantoHelper) {
        quantoHelper_ = quantoHelper;
        return *this;
    }

    MakeFdHestonVanillaEngine&
    MakeFdHestonVanillaEngine::withTGrid(Size tGrid) {
        tGrid_ = tGrid;
        return *this;
    }

    MakeFdHestonVanillaEngine&
    MakeFdHestonVanillaEngine::withXGrid(Size xGrid) {
        xGrid_ = xGrid;
        return *this;
    }

    MakeFdHestonVanillaEngine&
    MakeFdHestonVanillaEngine::withVGrid(Size vGrid) {
        vGrid_ = vGrid;
        return *this;
    }

    MakeFdHestonVanillaEngine&
    MakeFdHestonVanillaEngine::withDampingSteps(Size dampingSteps) {
        dampingSteps_ = dampingSteps;
        return *this;
    }

    MakeFdHestonVanillaEngine&
    MakeFdHestonVanillaEngine::withFdmSchemeDesc(
        const FdmSchemeDesc& schemeDesc) {
        schemeDesc_ = ext::make_shared<FdmSchemeDesc>(schemeDesc);
        return *this;
    }

    MakeFdHestonVanillaEngine&
    MakeFdHestonVanillaEngine::withLeverageFunction(
        ext::shared_ptr<LocalVolTermStructure>& leverageFct) {
        leverageFct_ = leverageFct;
        return *this;
    }

    MakeFdHestonVanillaEngine&
    MakeFdHestonVanillaEngine::withCashDividends(
            const std::vector<Date>& dividendDates,
            const std::vector<Real>& dividendAmounts) {
        dividends_ = DividendVector(dividendDates, dividendAmounts);
        return *this;
    }

    MakeFdHestonVanillaEngine::operator
    ext::shared_ptr<PricingEngine>() const {
        return ext::make_shared<FdHestonVanillaEngine>(
                hestonModel_,
                dividends_,
                quantoHelper_,
                tGrid_, xGrid_, vGrid_, dampingSteps_,
                *schemeDesc_,
                leverageFct_);
    }

}
]]></document_content>
  </document>
  <document index="122">
    <source>vanilla/fdsabrvanillaengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2019 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdsabrvanillaengine.hpp */

#include <ql/exercise.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/methods/finitedifferences/meshers/concentrating1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmcev1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/operators/fdmsabrop.hpp>
#include <ql/methods/finitedifferences/solvers/fdm2dimsolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/cevrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdiscountdirichletboundary.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/pricingengines/vanilla/fdsabrvanillaengine.hpp>
#include <ql/termstructures/volatility/sabr.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    FdSabrVanillaEngine::FdSabrVanillaEngine(Real f0,
                                             Real alpha,
                                             Real beta,
                                             Real nu,
                                             Real rho,
                                             Handle<YieldTermStructure> rTS,
                                             Size tGrid,
                                             Size fGrid,
                                             Size xGrid,
                                             Size dampingSteps,
                                             Real scalingFactor,
                                             Real eps,
                                             const FdmSchemeDesc& schemeDesc)
    : f0_(f0), alpha_(alpha), beta_(beta), nu_(nu), rho_(rho), rTS_(std::move(rTS)), tGrid_(tGrid),
      fGrid_(fGrid), xGrid_(xGrid), dampingSteps_(dampingSteps), scalingFactor_(scalingFactor),
      eps_(eps), schemeDesc_(schemeDesc) {

        validateSabrParameters(alpha, 0.5, nu, rho);

        QL_REQUIRE(beta<1.0, "beta must be smaller than 1.0: "
                   << beta << " not allowed");

        registerWith(rTS_);
    }

    void FdSabrVanillaEngine::calculate() const {
        // 1. Mesher
        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        const DayCounter dc = rTS_->dayCounter();

        const Date referenceDate = rTS_->referenceDate();
        const Date maturityDate = arguments_.exercise->lastDate();
        const Time maturityTime = dc.yearFraction(referenceDate, maturityDate);

        const Real upperAlpha = alpha_*
            std::exp(nu_*std::sqrt(maturityTime)*InverseCumulativeNormal()(0.75));

        const ext::shared_ptr<Fdm1dMesher> cevMesher =
            ext::make_shared<FdmCEV1dMesher>(
                fGrid_, f0_, upperAlpha, beta_,
                maturityTime, eps_, scalingFactor_,
                std::make_pair(payoff->strike(), 0.025));

        const Real normInvEps = InverseCumulativeNormal()(1-eps_);
        const Real logDrift = -0.5*nu_*nu_*maturityTime;
        const Real volRange =
            nu_*std::sqrt(maturityTime)*normInvEps*scalingFactor_;

        const Real xMin = std::log(alpha_) + logDrift - volRange;
        const Real xMax = std::log(alpha_) + logDrift + volRange;

        const ext::shared_ptr<Fdm1dMesher> xMesher =
            ext::make_shared<Concentrating1dMesher>(
                xMin, xMax, xGrid_, std::make_pair(std::log(alpha_), 0.1));

        const ext::shared_ptr<FdmMesher> mesher =
           ext::make_shared<FdmMesherComposite>(cevMesher, xMesher);

        // 2. Calculator
        const ext::shared_ptr<FdmInnerValueCalculator> calculator =
            ext::make_shared<FdmCellAveragingInnerValue>(payoff, mesher, 0);

        // 3. Step conditions
        const ext::shared_ptr<FdmStepConditionComposite> conditions =
            FdmStepConditionComposite::vanillaComposite(
                DividendSchedule(), arguments_.exercise,
                mesher, calculator, referenceDate, dc);

        // 4. Boundary conditions
        FdmBoundaryConditionSet boundaries;

        const Real lowerBound = cevMesher->locations().front();
        const Real upperBound = cevMesher->locations().back();

        boundaries.push_back(
            ext::make_shared<FdmDiscountDirichletBoundary>(
                mesher, rTS_.currentLink(),
                maturityTime, (*payoff)(upperBound),
                0, FdmDiscountDirichletBoundary::Upper));

        boundaries.push_back(
            ext::make_shared<FdmDiscountDirichletBoundary>(
                mesher, rTS_.currentLink(),
                maturityTime, (*payoff)(lowerBound),
                0, FdmDiscountDirichletBoundary::Lower));

        // 5. Solver
        const FdmSolverDesc solverDesc = {
            mesher, boundaries, conditions,
            calculator, maturityTime, tGrid_, dampingSteps_
        };

        const ext::shared_ptr<FdmLinearOpComposite> op =
            ext::make_shared<FdmSabrOp>(
               mesher, rTS_.currentLink(),
               f0_, alpha_, beta_, nu_, rho_);

        const ext::shared_ptr<Fdm2DimSolver> solver =
            ext::make_shared<Fdm2DimSolver>(solverDesc, schemeDesc_, op);

        results_.value = solver->interpolateAt(f0_, std::log(alpha_));
    }
}

]]></document_content>
  </document>
  <document index="123">
    <source>vanilla/fdsimplebsswingengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdsimplebsswingengine.cpp
    \brief Finite Differences Black-Scholes engine for simple swing options
*/

#include <ql/methods/finitedifferences/meshers/fdmblackscholesmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/meshers/uniform1dmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsimple2dbssolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsimpleswingcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/pricingengines/vanilla/fdsimplebsswingengine.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    FdSimpleBSSwingEngine::FdSimpleBSSwingEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Size tGrid,
        Size xGrid,
        const FdmSchemeDesc& schemeDesc)
    : process_(std::move(process)), tGrid_(tGrid), xGrid_(xGrid), schemeDesc_(schemeDesc) {}

    void FdSimpleBSSwingEngine::calculate() const {
        QL_REQUIRE(arguments_.exercise->type() == Exercise::Bermudan,
                   "Bermudan exercise supported only");

        // 1. Mesher
        const ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "Strike type payoff expected");
            
        const Time maturity = process_->time(arguments_.exercise->lastDate());
        const ext::shared_ptr<Fdm1dMesher> equityMesher(
            new FdmBlackScholesMesher(xGrid_, process_,
                                      maturity, payoff->strike()));
        
        const ext::shared_ptr<Fdm1dMesher> exerciseMesher(
                 new Uniform1dMesher(
                           0, static_cast<Real>(arguments_.maxExerciseRights),
                           arguments_.maxExerciseRights+1));

        const ext::shared_ptr<FdmMesher> mesher (
            new FdmMesherComposite(equityMesher, exerciseMesher));
        
        // 2. Calculator
        ext::shared_ptr<FdmInnerValueCalculator> calculator(
                                                    new FdmZeroInnerValue());
        
        // 3. Step conditions
        std::list<ext::shared_ptr<StepCondition<Array> > > stepConditions;
        std::list<std::vector<Time> > stoppingTimes;
        
        // 3.1 Bermudan step conditions
        std::vector<Time> exerciseTimes;
        for (auto i : arguments_.exercise->dates()) {
            Time t = process_->time(i);
            QL_REQUIRE(t >= 0, "exercise dates must not contain past date");
            exerciseTimes.push_back(t);
        }
        stoppingTimes.push_back(exerciseTimes);
        
        ext::shared_ptr<FdmInnerValueCalculator> exerciseCalculator(
                                    new FdmLogInnerValue(payoff, mesher, 0));

        stepConditions.push_back(ext::shared_ptr<StepCondition<Array> >(
            new FdmSimpleSwingCondition(
                exerciseTimes, mesher, exerciseCalculator,
                1, arguments_.minExerciseRights)));
        
        ext::shared_ptr<FdmStepConditionComposite> conditions(
                new FdmStepConditionComposite(stoppingTimes, stepConditions));
        
        // 4. Boundary conditions
        const FdmBoundaryConditionSet boundaries;
        
        // 5. Solver
        FdmSolverDesc solverDesc = { mesher, boundaries, conditions,
                                     calculator, maturity, tGrid_, 0 };
        ext::shared_ptr<FdmSimple2dBSSolver> solver(
                new FdmSimple2dBSSolver(
                               Handle<GeneralizedBlackScholesProcess>(process_),
                               payoff->strike(), solverDesc, schemeDesc_));
    
        const Real spot = process_->x0();

        results_.value = solver->valueAt(spot, 1);
        results_.delta = solver->deltaAt(spot, 1, spot*0.01);
        results_.gamma = solver->gammaAt(spot, 1, spot*0.01);
        results_.theta = solver->thetaAt(spot, 1);
    }
}
]]></document_content>
  </document>
  <document index="124">
    <source>vanilla/integralengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/math/integrals/segmentintegral.hpp>
#include <ql/pricingengines/vanilla/integralengine.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        class Integrand {
          public:
            Integrand(ext::shared_ptr<Payoff> payoff, Real s0, Rate drift, Real variance)
            : payoff_(std::move(payoff)), s0_(s0), drift_(drift), variance_(variance) {}
            Real operator()(Real x) const {
                Real temp = s0_ * std::exp(x);
                Real result = (*payoff_)(temp);
                return result *
                    std::exp(-(x - drift_)*(x -drift_)/(2.0*variance_)) ;
            }
          private:
            ext::shared_ptr<Payoff> payoff_;
            Real s0_;
            Rate drift_;
            Real variance_;
        };
    }

    IntegralEngine::IntegralEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void IntegralEngine::calculate() const {

        QL_REQUIRE(arguments_.exercise->type() == Exercise::European,
                   "not an European Option");

        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        Real variance =
            process_->blackVolatility()->blackVariance(
                           arguments_.exercise->lastDate(), payoff->strike());

        DiscountFactor dividendDiscount =
            process_->dividendYield()->discount(
                                             arguments_.exercise->lastDate());
        DiscountFactor riskFreeDiscount =
            process_->riskFreeRate()->discount(arguments_.exercise->lastDate());
        Rate drift = std::log(dividendDiscount/riskFreeDiscount)-0.5*variance;

        Integrand f(arguments_.payoff,
                    process_->stateVariable()->value(),
                    drift, variance);
        SegmentIntegral integrator(5000);

        Real infinity = 10.0*std::sqrt(variance);
        results_.value =
            process_->riskFreeRate()->discount(
                                            arguments_.exercise->lastDate()) /
            std::sqrt(2.0*M_PI*variance) *
            integrator(f, drift-infinity, drift+infinity);
    }

}

]]></document_content>
  </document>
  <document index="125">
    <source>vanilla/jumpdiffusionengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/math/distributions/poissondistribution.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/jumpdiffusionengine.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <utility>

namespace QuantLib {

    JumpDiffusionEngine::JumpDiffusionEngine(ext::shared_ptr<Merton76Process> process,
                                             Real relativeAccuracy,
                                             Size maxIterations)
    : process_(std::move(process)), relativeAccuracy_(relativeAccuracy),
      maxIterations_(maxIterations) {
        registerWith(process_);
    }


    void JumpDiffusionEngine::calculate() const {

        Real jumpSquareVol = process_->logJumpVolatility()->value()
            * process_->logJumpVolatility()->value();
        Real muPlusHalfSquareVol = process_->logMeanJump()->value()
            + 0.5*jumpSquareVol;
        // mean jump size
        Real k = std::exp(muPlusHalfSquareVol) - 1.0;
        Real lambda = (k+1.0) * process_->jumpIntensity()->value();

        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        Real variance =
            process_->blackVolatility()->blackVariance(
                                              arguments_.exercise->lastDate(),
                                              payoff->strike());

        DayCounter voldc = process_->blackVolatility()->dayCounter();
        Calendar volcal = process_->blackVolatility()->calendar();
        Date volRefDate = process_->blackVolatility()->referenceDate();
        Time t = voldc.yearFraction(volRefDate,
                                    arguments_.exercise->lastDate());
        Rate riskFreeRate = -std::log(process_->riskFreeRate()->discount(
                                          arguments_.exercise->lastDate()))/t;
        Date rateRefDate = process_->riskFreeRate()->referenceDate();

        PoissonDistribution p(lambda*t);

        Handle<Quote> stateVariable = process_->stateVariable();
        Handle<YieldTermStructure> dividendTS = process_->dividendYield();
        RelinkableHandle<YieldTermStructure> riskFreeTS(
                                                   *process_->riskFreeRate());
        RelinkableHandle<BlackVolTermStructure> volTS(
                                                *process_->blackVolatility());

        ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess(
                 new GeneralizedBlackScholesProcess(stateVariable, dividendTS,
                                                    riskFreeTS, volTS));

        AnalyticEuropeanEngine baseEngine(bsProcess);

        auto* baseArguments = dynamic_cast<VanillaOption::arguments*>(baseEngine.getArguments());

        baseArguments->payoff   = arguments_.payoff;
        baseArguments->exercise = arguments_.exercise;

        baseArguments->validate();

        const auto* baseResults =
            dynamic_cast<const VanillaOption::results*>(baseEngine.getResults());

        results_.value       = 0.0;
        results_.delta       = 0.0;
        results_.gamma       = 0.0;
        results_.theta       = 0.0;
        results_.vega        = 0.0;
        results_.rho         = 0.0;
        results_.dividendRho = 0.0;

        Real r, v, weight, lastContribution = 1.0;
        Size i;
        Real theta_correction;
        // Haug arbitrary criterium is:
        //for (i=0; i<11; i++) {
        for (i=0;  (lastContribution>relativeAccuracy_ && i<maxIterations_) 
                 || i < Size(lambda*t); i++) {

            // constant vol/rate assumption. It should be relaxed
            v = std::sqrt((variance + i*jumpSquareVol)/t);
            r = riskFreeRate - process_->jumpIntensity()->value()*k
                + i*muPlusHalfSquareVol/t;
            riskFreeTS.linkTo(ext::shared_ptr<YieldTermStructure>(new
                FlatForward(rateRefDate, r, voldc)));
            volTS.linkTo(ext::shared_ptr<BlackVolTermStructure>(new
                BlackConstantVol(rateRefDate, volcal, v, voldc)));

            baseArguments->validate();
            baseEngine.calculate();

            weight = p(Size(i));
            results_.value       += weight * baseResults->value;
            results_.delta       += weight * baseResults->delta;
            results_.gamma       += weight * baseResults->gamma;
            results_.vega        += weight * (std::sqrt(variance/t)/v)*
                                                           baseResults->vega;
            // theta modified
            theta_correction = baseResults->vega*((i*jumpSquareVol)/
                                                  (2.0*v*t*t)) +
                baseResults->rho*i*muPlusHalfSquareVol/(t*t);
            results_.theta += weight *(baseResults->theta + theta_correction +
                                  lambda*baseResults->value);
            if(i != 0){
                 results_.theta -= (p(Size(i-1))*lambda* baseResults->value);
            }
            //end theta calculation
            results_.rho         += weight * baseResults->rho;
            results_.dividendRho += weight * baseResults->dividendRho;

            lastContribution = std::fabs(baseResults->value /
                (std::fabs(results_.value)>QL_EPSILON ? results_.value : 1.0));

            lastContribution = std::max<Real>(lastContribution,
                std::fabs(baseResults->delta /
               (std::fabs(results_.delta)>QL_EPSILON ? results_.delta : 1.0)));

            lastContribution = std::max<Real>(lastContribution,
                std::fabs(baseResults->gamma /
               (std::fabs(results_.gamma)>QL_EPSILON ? results_.gamma : 1.0)));

            lastContribution = std::max<Real>(lastContribution,
                std::fabs(baseResults->theta /
               (std::fabs(results_.theta)>QL_EPSILON ? results_.theta : 1.0)));

            lastContribution = std::max<Real>(lastContribution,
                std::fabs(baseResults->vega /
               (std::fabs(results_.vega)>QL_EPSILON ? results_.vega : 1.0)));

            lastContribution = std::max<Real>(lastContribution,
                std::fabs(baseResults->rho /
               (std::fabs(results_.rho)>QL_EPSILON ? results_.rho : 1.0)));

            lastContribution = std::max<Real>(lastContribution,
                std::fabs(baseResults->dividendRho /
               (std::fabs(results_.dividendRho)>QL_EPSILON ?
                                          results_.dividendRho : 1.0)));

            lastContribution *= weight;
        }
        QL_ENSURE(i<maxIterations_,
                  i << " iterations have been not enough to reach "
                  << "the required " << relativeAccuracy_
                  << " accuracy. The " << io::ordinal(i)
                  << " addendum was " << lastContribution
                  << " while the running sum was " << results_.value);
    }

}

]]></document_content>
  </document>
  <document index="126">
    <source>vanilla/juquadraticengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Neil Firth
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2013 Fabien Le Floc'h

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/pricingengines/vanilla/baroneadesiwhaleyengine.hpp>
#include <ql/pricingengines/vanilla/juquadraticengine.hpp>
#include <utility>

namespace QuantLib {

    /*  An Approximate Formula for Pricing American Options
        Journal of Derivatives Winter 1999
        Ju, N.
    */


    JuQuadraticApproximationEngine::JuQuadraticApproximationEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void JuQuadraticApproximationEngine::calculate() const {

        QL_REQUIRE(arguments_.exercise->type() == Exercise::American,
                   "not an American Option");

        ext::shared_ptr<AmericanExercise> ex =
            ext::dynamic_pointer_cast<AmericanExercise>(arguments_.exercise);
        QL_REQUIRE(ex, "non-American exercise given");
        QL_REQUIRE(!ex->payoffAtExpiry(),
                   "payoff at expiry not handled");

        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        Real variance = process_->blackVolatility()->blackVariance(
            ex->lastDate(), payoff->strike());
        DiscountFactor dividendDiscount = process_->dividendYield()->discount(
            ex->lastDate());
        DiscountFactor riskFreeDiscount = process_->riskFreeRate()->discount(
            ex->lastDate());
        Real spot = process_->stateVariable()->value();
        QL_REQUIRE(spot > 0.0, "negative or null underlying given");
        Real forwardPrice = spot * dividendDiscount / riskFreeDiscount;
        BlackCalculator black(payoff, forwardPrice,
                              std::sqrt(variance), riskFreeDiscount);

        if (dividendDiscount>=1.0 && payoff->optionType()==Option::Call) {
            // early exercise never optimal
            results_.value        = black.value();
            results_.delta        = black.delta(spot);
            results_.deltaForward = black.deltaForward();
            results_.elasticity   = black.elasticity(spot);
            results_.gamma        = black.gamma(spot);

            DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
            DayCounter divdc = process_->dividendYield()->dayCounter();
            DayCounter voldc = process_->blackVolatility()->dayCounter();
            Time t =
                rfdc.yearFraction(process_->riskFreeRate()->referenceDate(),
                                  arguments_.exercise->lastDate());
            results_.rho = black.rho(t);

            t = divdc.yearFraction(process_->dividendYield()->referenceDate(),
                                   arguments_.exercise->lastDate());
            results_.dividendRho = black.dividendRho(t);

            t = voldc.yearFraction(process_->blackVolatility()->referenceDate(),
                                   arguments_.exercise->lastDate());
            results_.vega        = black.vega(t);
            results_.theta       = black.theta(spot, t);
            results_.thetaPerDay = black.thetaPerDay(spot, t);

            results_.strikeSensitivity  = black.strikeSensitivity();
            results_.itmCashProbability = black.itmCashProbability();
        } else {
            // early exercise can be optimal
            CumulativeNormalDistribution cumNormalDist;
            NormalDistribution normalDist;

            Real tolerance = 1e-6;
            Real Sk = BaroneAdesiWhaleyApproximationEngine::criticalPrice(
                payoff, riskFreeDiscount, dividendDiscount, variance,
                tolerance);

            Real forwardSk = Sk * dividendDiscount / riskFreeDiscount;

            Real alpha = -2.0*std::log(riskFreeDiscount)/(variance);
            Real beta = 2.0*std::log(dividendDiscount/riskFreeDiscount)/
                                                (variance);
            Real h = 1 - riskFreeDiscount;
            Real phi;
            switch (payoff->optionType()) {
                case Option::Call:
                    phi = 1;
                    break;
                case Option::Put:
                    phi = -1;
                    break;
                default:
                  QL_FAIL("unknown option type");
            }
            //it can throw: to be fixed
            Real temp_root = std::sqrt ((beta-1)*(beta-1) + (4*alpha)/h);
            Real lambda = (-(beta-1) + phi * temp_root) / 2;
            Real lambda_prime = - phi * alpha / (h*h * temp_root);

            Real black_Sk = blackFormula(payoff->optionType(), payoff->strike(),
                                         forwardSk, std::sqrt(variance)) * riskFreeDiscount;
            Real hA = phi * (Sk - payoff->strike()) - black_Sk;

            Real d1_Sk = (std::log(forwardSk/payoff->strike()) + 0.5*variance)
                /std::sqrt(variance);
            Real d2_Sk = d1_Sk - std::sqrt(variance);
            Real part1 = forwardSk * normalDist(d1_Sk) /
                                        (alpha * std::sqrt(variance));
            Real part2 = - phi * forwardSk * cumNormalDist(phi * d1_Sk) *
                      std::log(dividendDiscount) / std::log(riskFreeDiscount);
            Real part3 = + phi * payoff->strike() * cumNormalDist(phi * d2_Sk);
            Real V_E_h = part1 + part2 + part3;

            Real b = (1-h) * alpha * lambda_prime / (2*(2*lambda + beta - 1));
            Real c = - ((1 - h) * alpha / (2 * lambda + beta - 1)) *
                (V_E_h / (hA) + 1 / h + lambda_prime / (2*lambda + beta - 1));
            Real temp_spot_ratio = std::log(spot / Sk);
            Real chi = temp_spot_ratio * (b * temp_spot_ratio + c);

            if (phi*(Sk-spot) > 0) {
                results_.value = black.value() +
                    hA * std::pow((spot/Sk), lambda) / (1 - chi);
                Real temp_chi_prime = (2 * b / spot) * std::log(spot/Sk);
                Real chi_prime = temp_chi_prime + c / spot;
                Real chi_double_prime = 2*b/(spot*spot)
                    - temp_chi_prime / spot - c / (spot*spot);
                Real d1_S = (std::log(forwardPrice/payoff->strike()) + 0.5*variance)
                    / std::sqrt(variance);
                //There is a typo in the original paper from Ju-Zhong
                //the first term is the Black-Scholes delta/gamma.    
                results_.delta = phi * dividendDiscount * cumNormalDist (phi * d1_S)
                    + (lambda / (spot * (1 - chi)) + chi_prime / ((1 - chi)*(1 - chi))) *
                    (phi * (Sk - payoff->strike()) - black_Sk) * std::pow((spot/Sk), lambda);

                results_.gamma = dividendDiscount * normalDist (phi*d1_S) 
                    / (spot * std::sqrt(variance))
                    + (2 * lambda * chi_prime / (spot * (1 - chi) * (1 - chi))
                        + 2 * chi_prime * chi_prime / ((1 - chi) * (1 - chi) * (1 - chi))
                        + chi_double_prime / ((1 - chi) * (1 - chi))
                        + lambda * (lambda - 1) / (spot * spot * (1 - chi)))
                    * (phi * (Sk - payoff->strike()) - black_Sk)
                    * std::pow((spot/Sk), lambda);
            } else {
                results_.value = phi * (spot - payoff->strike());
                results_.delta = phi;
                results_.gamma = 0;
            }

        } // end of "early exercise can be optimal"
    }

}
]]></document_content>
  </document>
  <document index="127">
    <source>vanilla/mcamericanengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mcamericanengine.cpp
    \brief Monte Carlo engine for vanilla american options
*/

#include <ql/errors.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/pricingengines/vanilla/mcamericanengine.hpp>
#include <utility>

namespace QuantLib {

    AmericanPathPricer::AmericanPathPricer(ext::shared_ptr<Payoff> payoff,
                                           Size polynomialOrder,
                                           LsmBasisSystem::PolynomialType polynomialType)
    : payoff_(std::move(payoff)),
      v_(LsmBasisSystem::pathBasisSystem(polynomialOrder, polynomialType)) {

        QL_REQUIRE(   polynomialType == LsmBasisSystem::Monomial
                   || polynomialType == LsmBasisSystem::Laguerre
                   || polynomialType == LsmBasisSystem::Hermite
                   || polynomialType == LsmBasisSystem::Hyperbolic
                   || polynomialType == LsmBasisSystem::Chebyshev2nd,
                   "insufficient polynomial type");

        // the payoff gives an additional value
        v_.emplace_back([&](Real state){ return this->payoff(state); });

        const ext::shared_ptr<StrikedTypePayoff> strikePayoff
            = ext::dynamic_pointer_cast<StrikedTypePayoff>(payoff_);

        if (strikePayoff != nullptr) {
            scalingValue_/=strikePayoff->strike();
        }
    }

    Real AmericanPathPricer::payoff(Real state) const {
        return (*payoff_)(state/scalingValue_);
    }

    Real AmericanPathPricer::operator()(const Path& path, Size t) const {
        return payoff(state(path, t));
    }

    Real AmericanPathPricer::state(const Path& path, Size t) const {
        // scale values of the underlying
        // to increase numerical stability
        return path[t]*scalingValue_;
    }

    std::vector<std::function<Real(Real)> >
    AmericanPathPricer::basisSystem() const {
        return v_;
    }

}
]]></document_content>
  </document>
  <document index="128">
    <source>vanilla/mcdigitalengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano
 Copyright (C) 2003 Neil Firth
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/pricingengines/vanilla/mcdigitalengine.hpp>
#include <utility>

namespace QuantLib {

    DigitalPathPricer::DigitalPathPricer(ext::shared_ptr<CashOrNothingPayoff> payoff,
                                         ext::shared_ptr<AmericanExercise> exercise,
                                         Handle<YieldTermStructure> discountTS,
                                         ext::shared_ptr<StochasticProcess1D> diffProcess,
                                         PseudoRandom::ursg_type sequenceGen)
    : payoff_(std::move(payoff)), exercise_(std::move(exercise)),
      diffProcess_(std::move(diffProcess)), sequenceGen_(std::move(sequenceGen)),
      discountTS_(std::move(discountTS)) {}

    Real DigitalPathPricer::operator()(const Path& path) const {
        Size n = path.length();
        QL_REQUIRE(n>1, "the path cannot be empty");

        Real log_asset_price = std::log(path.front());
        Real x, y;
        Volatility vol;
        const TimeGrid& timeGrid = path.timeGrid();
        Time dt;
        std::vector<Real> u = sequenceGen_.nextSequence().value;
        Real log_strike = std::log(payoff_->strike());

        Size i;
        switch (payoff_->optionType()) {
          case Option::Call:
            for (i=0; i<n-1; i++) {
                x = std::log(path[i+1]/path[i]);
                // terminal or initial vol?
                vol = diffProcess_->diffusion(timeGrid[i+1],
                                              std::exp(log_asset_price));
                // vol = diffProcess_->diffusion(timeGrid[i+2],
                //                               std::exp(log_asset_price+x));
                dt = timeGrid.dt(i);
                y = log_asset_price +
                    0.5*(x + std::sqrt(x*x-2*vol*vol*dt*std::log((1-u[i]))));
                // cross the strike
                if (y >= log_strike) {
                    if (exercise_->payoffAtExpiry()) {
                        return payoff_->cashPayoff() *
                            discountTS_->discount(path.timeGrid().back());
                    } else {
                        // the discount should be calculated at the exercise
                        // time between path.timeGrid()[i+1] and
                        // path.timeGrid()[i+2]
                        return payoff_->cashPayoff() *
                            discountTS_->discount(path.timeGrid()[i+1]);
                    }
                }
                log_asset_price += x;
            }
            break;
          case Option::Put:
            for (i=0; i<n-1; i++) {
                x = std::log(path[i+1]/path[i]);
                // terminal or initial vol?
                // initial (timeGrid[i+1]) for the time being
                vol = diffProcess_->diffusion(timeGrid[i+1],
                                              std::exp(log_asset_price));
                // vol = diffProcess_->diffusion(timeGrid[i+2],
                //                               std::exp(log_asset_price+x));
                dt = timeGrid.dt(i);
                y = log_asset_price +
                    0.5*(x - std::sqrt(x*x - 2*vol*vol*dt*std::log(u[i])));
                if (y <= log_strike) {
                    if (exercise_->payoffAtExpiry()) {
                        return payoff_->cashPayoff() *
                            discountTS_->discount(path.timeGrid().back());
                    } else {
                        // the discount should be calculated at the exercise
                        // time between path.timeGrid()[i+1] and
                        // path.timeGrid()[i+2]
                        return payoff_->cashPayoff() *
                            discountTS_->discount(path.timeGrid()[i+1]);
                    }
                }
                log_asset_price += x;
            }
            break;
          default:
            QL_FAIL("unknown option type");
        }

        return 0.0;
    }

}

]]></document_content>
  </document>
  <document index="129">
    <source>vanilla/mchestonhullwhiteengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mchestonhullwhiteengine.hpp
    \brief Monte Carlo vanilla option engine for stochastic interest rates
*/

#include <ql/pricingengines/vanilla/mchestonhullwhiteengine.hpp>
#include <utility>

namespace QuantLib {

    HestonHullWhitePathPricer::HestonHullWhitePathPricer(
        Time exerciseTime,
        ext::shared_ptr<Payoff> payoff,
        ext::shared_ptr<HybridHestonHullWhiteProcess> process)
    : exerciseTime_(exerciseTime), payoff_(std::move(payoff)), process_(std::move(process)) {}

    Real HestonHullWhitePathPricer::operator()(const MultiPath& path) const {
        QL_REQUIRE(path.pathSize() > 0, "the path cannot be empty");

        Array states(path.assetNumber());
        for (Size j=0; j < states.size(); ++j) {
            states[j] = path[j][path.pathSize()-1];
        }

        const DiscountFactor df(
                             1.0/process_->numeraire(exerciseTime_, states));
        return (*payoff_)(states[0])*df;
    }
}

]]></document_content>
  </document>
  <document index="130">
    <source>vanilla/qdfpamericanengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2022 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file qrfpamericanengine.cpp
*/

#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/math/integrals/tanhsinhintegral.hpp>
#include <ql/math/interpolations/chebyshevinterpolation.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/pricingengines/vanilla/qdfpamericanengine.hpp>
#include <utility>
#ifndef QL_BOOST_HAS_TANH_SINH
#    include <ql/math/integrals/gausslobattointegral.hpp>
#endif

namespace QuantLib {

    QdFpLegendreScheme::QdFpLegendreScheme(
        Size l, Size m, Size n, Size p):
        m_(m), n_(n),
        fpIntegrator_(ext::make_shared<GaussLegendreIntegrator>(l)),
        exerciseBoundaryIntegrator_(
            ext::make_shared<GaussLegendreIntegrator>(p)) {

        QL_REQUIRE(m_ > 0, "at least one fixed point iteration step is needed");
        QL_REQUIRE(n_ > 0, "at least one interpolation point is needed");
    }

    Size QdFpLegendreScheme::getNumberOfChebyshevInterpolationNodes()
        const {
        return n_;
    }
    Size QdFpLegendreScheme::getNumberOfNaiveFixedPointSteps() const {
        return m_-1;
    }
    Size QdFpLegendreScheme::getNumberOfJacobiNewtonFixedPointSteps()
        const {
        return Size(1);
    }

    ext::shared_ptr<Integrator>
        QdFpLegendreScheme::getFixedPointIntegrator() const {
        return fpIntegrator_;
    }
    ext::shared_ptr<Integrator>
        QdFpLegendreScheme::getExerciseBoundaryToPriceIntegrator()
        const {
        return exerciseBoundaryIntegrator_;
    }

    QdFpTanhSinhIterationScheme::QdFpTanhSinhIterationScheme(
        Size m, Size n, Real eps)
    : m_(m), n_(n),
#ifdef QL_BOOST_HAS_TANH_SINH
      integrator_(ext::make_shared<TanhSinhIntegral>(eps))
#else
      integrator_(ext::make_shared<GaussLobattoIntegral>(
          100000, QL_MAX_REAL, 0.1*eps))
#endif
    {}

    Size QdFpTanhSinhIterationScheme::getNumberOfChebyshevInterpolationNodes()
        const {
        return n_;
    }
    Size QdFpTanhSinhIterationScheme::getNumberOfNaiveFixedPointSteps() const {
        return m_-1;
    }
    Size QdFpTanhSinhIterationScheme::getNumberOfJacobiNewtonFixedPointSteps()
        const {
        return Size(1);
    }

    ext::shared_ptr<Integrator>
    QdFpTanhSinhIterationScheme::getFixedPointIntegrator() const {
        return integrator_;
    }
    ext::shared_ptr<Integrator>
    QdFpTanhSinhIterationScheme::getExerciseBoundaryToPriceIntegrator()
        const {
        return integrator_;
    }

    QdFpLegendreTanhSinhScheme::QdFpLegendreTanhSinhScheme(
        Size l, Size m, Size n, Real eps)
    : QdFpLegendreScheme(l, m, n, 1),
      eps_(eps) {}

    ext::shared_ptr<Integrator>
    QdFpLegendreTanhSinhScheme::getExerciseBoundaryToPriceIntegrator() const {
#ifdef QL_BOOST_HAS_TANH_SINH
            return ext::make_shared<TanhSinhIntegral>(eps_);
#else
            return ext::make_shared<GaussLobattoIntegral>(
                100000, QL_MAX_REAL, 0.1*eps_);
#endif
    }


    class DqFpEquation {
      public:
        DqFpEquation(Rate _r,
                     Rate _q,
                     Volatility _vol,
                     std::function<Real(Real)> B,
                     ext::shared_ptr<Integrator> _integrator)
        : r(_r), q(_q), vol(_vol), B(std::move(B)), integrator(std::move(_integrator)) {
            const auto legendreIntegrator =
                ext::dynamic_pointer_cast<GaussLegendreIntegrator>(integrator);

            if (legendreIntegrator != nullptr) {
                x_i = legendreIntegrator->getIntegration()->x();
                w_i = legendreIntegrator->getIntegration()->weights();
            }
        }

        virtual std::pair<Real, Real> NDd(Real tau, Real b) const = 0;
        virtual std::tuple<Real, Real, Real> f(Real tau, Real b) const = 0;

        virtual ~DqFpEquation() = default;

      protected:
        std::pair<Real, Real> d(Time t, Real z) const {
            const Real v = vol * std::sqrt(t);
            const Real m = (std::log(z) + (r-q)*t)/v + 0.5*v;

            return std::make_pair(m, m-v);
        }

        Array x_i, w_i;
        const Rate r, q;
        const Volatility vol;

        const std::function<Real(Real)> B;
        const ext::shared_ptr<Integrator> integrator;

        const NormalDistribution phi;
        const CumulativeNormalDistribution Phi;
    };

    class DqFpEquation_B: public DqFpEquation {
      public:
        DqFpEquation_B(Real K,
                       Rate _r,
                       Rate _q,
                       Volatility _vol,
                       std::function<Real(Real)> B,
                       ext::shared_ptr<Integrator> _integrator);

        std::pair<Real, Real> NDd(Real tau, Real b) const override;
        std::tuple<Real, Real, Real> f(Real tau, Real b) const override;

      private:
          const Real K;
    };

    class DqFpEquation_A: public DqFpEquation {
      public:
        DqFpEquation_A(Real K,
                       Rate _r,
                       Rate _q,
                       Volatility _vol,
                       std::function<Real(Real)> B,
                       ext::shared_ptr<Integrator> _integrator);

        std::pair<Real, Real> NDd(Real tau, Real b) const override;
        std::tuple<Real, Real, Real> f(Real tau, Real b) const override;

      private:
          const Real K;
    };

    DqFpEquation_A::DqFpEquation_A(Real K,
                                   Rate _r,
                                   Rate _q,
                                   Volatility _vol,
                                   std::function<Real(Real)> B,
                                   ext::shared_ptr<Integrator> _integrator)
    : DqFpEquation(_r, _q, _vol, std::move(B), std::move(_integrator)), K(K) {}

    std::tuple<Real, Real, Real> DqFpEquation_A::f(Real tau, Real b) const {
        const Real v = vol * std::sqrt(tau);

        Real N, D;
        if (tau < squared(QL_EPSILON)) {
            if (close_enough(b, K)) {
                N = 1/(M_SQRT2*M_SQRTPI * v);
                D = N + 0.5;
            }
            else {
                N = 0.0;
                D = (b > K)? 1.0: 0.0;
            }
        }
        else {
            const Real stv = std::sqrt(tau)/vol;

            Real K12, K3;
            if (!x_i.empty()) {
                K12 = K3 = 0.0;

                for (Integer i = x_i.size()-1; i >= 0; --i) {
                    const Real y = x_i[i];
                    const Real m = 0.25*tau*squared(1+y);
                    const std::pair<Real, Real> dpm = d(m, b/B(tau-m));

                    K12 += w_i[i] * std::exp(q*tau - q*m)
                        *(0.5*tau*(y+1)*Phi(dpm.first) + stv*phi(dpm.first));
                    K3 += w_i[i] * stv*std::exp(r*tau-r*m)*phi(dpm.second);
                }
            } else {
                K12 = (*integrator)([&, this](Real y) -> Real {
                    const Real m = 0.25*tau*squared(1+y);
                    const Real df = std::exp(q*tau - q*m);

                    if (y <= 5*QL_EPSILON - 1) {
                        if (close_enough(b, B(tau-m)))
                            return df*stv/(M_SQRT2*M_SQRTPI);
                        else
                            return 0.0;
                    }
                    else {
                        const Real dp = d(m, b/B(tau-m)).first;
                        return df*(0.5*tau*(y+1)*Phi(dp) + stv*phi(dp));
                    }
                }, -1, 1);

                K3 = (*integrator)([&, this](Real y) -> Real {
                    const Real m = 0.25*tau*squared(1+y);
                    const Real df = std::exp(r*tau-r*m);

                    if (y <= 5*QL_EPSILON - 1) {
                        if (close_enough(b, B(tau-m)))
                            return df*stv/(M_SQRT2*M_SQRTPI);
                        else
                            return 0.0;
                    }
                    else
                        return df*stv*phi(d(m, b/B(tau-m)).second);
                }, -1, 1);
            }
            const std::pair<Real, Real> dpm = d(tau, b/K);
            N = phi(dpm.second)/v + r*K3;
            D = phi(dpm.first)/v + Phi(dpm.first) + q*K12;
        }

        const Real alpha = K*std::exp(-(r-q)*tau);
        Real fv;
        if (tau < squared(QL_EPSILON)) {
            if (close_enough(b, K))
                fv = alpha;
            else if (b > K)
                fv = 0.0;
            else {
                if (close_enough(q, Real(0)))
                    fv = alpha*r*((q < 0)? -1.0 : 1.0)/QL_EPSILON;
                else
                    fv = alpha*r/q;
            }
        }
        else
            fv = alpha*N/D;

        return std::make_tuple(N, D, fv);
    }

    std::pair<Real, Real> DqFpEquation_A::NDd(Real tau, Real b) const {
        Real Dd, Nd;

        if (tau < squared(QL_EPSILON)) {
            if (close_enough(b, K)) {
                const Real sqTau = std::sqrt(tau);
                const Real vol2 = vol*vol;
                Dd = M_1_SQRTPI*M_SQRT_2*(
                    -(0.5*vol2 + r-q) / (b*vol*vol2*sqTau) + 1 / (b*vol*sqTau));
                Nd = M_1_SQRTPI*M_SQRT_2 * (-0.5*vol2 + r-q)  / (b*vol*vol2*sqTau);
            }
            else
                Dd = Nd = 0.0;
        }
        else {
            const std::pair<Real, Real> dpm = d(tau, b/K);

            Dd = -phi(dpm.first) * dpm.first / (b*vol*vol*tau) +
                    phi(dpm.first) / (b*vol * std::sqrt(tau));
            Nd = -phi(dpm.second) * dpm.second / (b*vol*vol*tau);
        }

        return std::make_pair(Nd, Dd);
    }


    DqFpEquation_B::DqFpEquation_B(Real K,
                                   Rate _r,
                                   Rate _q,
                                   Volatility _vol,
                                   std::function<Real(Real)> B,
                                   ext::shared_ptr<Integrator> _integrator)
    : DqFpEquation(_r, _q, _vol, std::move(B), std::move(_integrator)), K(K) {}


    std::tuple<Real, Real, Real> DqFpEquation_B::f(Real tau, Real b) const {
        Real N, D;
        if (tau < squared(QL_EPSILON)) {
            if (close_enough(b, K))
                N = D = 0.5;
            else if (b < K)
                N = D = 0.0;
            else
                N = D = 1.0;
        }
        else {
            Real ni, di;
            if (!x_i.empty()) {
                const Real c = 0.5*tau;

                ni = di = 0.0;
                for (Integer i = x_i.size()-1; i >= 0; --i) {
                    const Real u = c*x_i[i] + c;
                    const std::pair<Real, Real> dpm = d(tau - u, b/B(u));
                    ni += w_i[i] * std::exp(r*u)*Phi(dpm.second);
                    di += w_i[i] * std::exp(q*u)*Phi(dpm.first);
                }
                ni *= c;
                di *= c;
            } else {
                ni = (*integrator)([&, this](Real u) -> Real {
                	const Real df = std::exp(r*u);
                    if (u >= tau*(1 - 5*QL_EPSILON)) {
                        if (close_enough(b, B(u)))
                            return 0.5*df;
                        else
                            return df*((b < B(u)? 0.0: 1.0));
                    }
                    else
                        return df*Phi(d(tau - u, b/B(u)).second);
                }, 0, tau);
                di = (*integrator)([&, this](Real u) -> Real {
                	const Real df = std::exp(q*u);
                    if (u >= tau*(1 - 5*QL_EPSILON)) {
                        if (close_enough(b, B(u)))
                            return 0.5*df;
                        else
                            return df*((b < B(u)? 0.0: 1.0));
                    }
                    else
                        return df*Phi(d(tau - u, b/B(u)).first);
                    }, 0, tau);
            }

            const std::pair<Real, Real> dpm = d(tau, b/K);

            N = Phi(dpm.second) + r*ni;
            D = Phi(dpm.first) + q*di;
        }

        Real fv;
        const Real alpha = K*std::exp(-(r-q)*tau);
        if (tau < squared(QL_EPSILON)) {
            if (close_enough(b, K) || b > K)
                fv = alpha;
            else {
                if (close_enough(q, Real(0)))
                    fv = alpha*r*((q < 0)? -1.0 : 1.0)/QL_EPSILON;
                else
                    fv = alpha*r/q;
            }
        }
        else
            fv = alpha*N/D;

        return std::make_tuple(N, D, fv);
    }

    std::pair<Real, Real> DqFpEquation_B::NDd(Real tau, Real b) const {
        const std::pair<Real, Real> dpm = d(tau, b/K);
        return std::make_pair(
            phi(dpm.second) / (b*vol*std::sqrt(tau)),
            phi(dpm.first)  / (b*vol*std::sqrt(tau))
        );
    }

    QdFpAmericanEngine::QdFpAmericanEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> bsProcess,
        ext::shared_ptr<QdFpIterationScheme> iterationScheme,
        FixedPointEquation fpEquation)
    : detail::QdPutCallParityEngine(std::move(bsProcess)),
      iterationScheme_(std::move(iterationScheme)),
      fpEquation_(fpEquation) {
    }

    ext::shared_ptr<QdFpIterationScheme>
    QdFpAmericanEngine::fastScheme() {
        static auto scheme = ext::make_shared<QdFpLegendreScheme>(7, 2, 7, 27);
        return scheme;
    }

    ext::shared_ptr<QdFpIterationScheme>
    QdFpAmericanEngine::accurateScheme() {
        static auto scheme = ext::make_shared<QdFpLegendreTanhSinhScheme>(25, 5, 13, 1e-8);
        return scheme;
    }

    ext::shared_ptr<QdFpIterationScheme>
    QdFpAmericanEngine::highPrecisionScheme() {
        static auto scheme = ext::make_shared<QdFpTanhSinhIterationScheme>(10, 30, 1e-10);
        return scheme;
    }

    Real QdFpAmericanEngine::calculatePut(
            Real S, Real K, Rate r, Rate q, Volatility vol, Time T) const {

        if (r < 0.0 && q < r)
            QL_FAIL("double-boundary case q<r<0 for a put option is given");

        const Real xmax =  QdPlusAmericanEngine::xMax(K, r, q);
        const Size n = iterationScheme_->getNumberOfChebyshevInterpolationNodes();

        const ext::shared_ptr<ChebyshevInterpolation> interp =
            QdPlusAmericanEngine(
                    process_, n+1, QdPlusAmericanEngine::Halley, 1e-8)
                .getPutExerciseBoundary(S, K, r, q, vol, T);

        const Array z = interp->nodes();
        const Array x = 0.5*std::sqrt(T)*(1.0+z);

        const auto B = [xmax, T, &interp](Real tau) -> Real {
            const Real z = 2*std::sqrt(std::abs(tau)/T)-1;
            return xmax*std::exp(-std::sqrt(std::max(Real(0), (*interp)(z, true))));
        };

        const auto h = [=](Real fv) -> Real {
            return squared(std::log(fv/xmax));
        };

        const ext::shared_ptr<DqFpEquation> eqn
            = (fpEquation_ == FP_A
               || (fpEquation_ == Auto && std::abs(r-q) < 0.001))?
              ext::shared_ptr<DqFpEquation>(new DqFpEquation_A(
                  K, r, q, vol, B,
                  iterationScheme_->getFixedPointIntegrator()))
            : ext::shared_ptr<DqFpEquation>(new DqFpEquation_B(
                    K, r, q, vol, B,
                    iterationScheme_->getFixedPointIntegrator()));

        Array y(x.size());
        y[0] = 0.0;

        const Size n_newton
            = iterationScheme_->getNumberOfJacobiNewtonFixedPointSteps();
        for (Size k=0; k < n_newton; ++k) {
            for (Size i=1; i < x.size(); ++i) {
                const Real tau = squared(x[i]);
                const Real b = B(tau);

                const std::tuple<Real, Real, Real> results = eqn->f(tau, b);
                const Real N = std::get<0>(results);
                const Real D = std::get<1>(results);
                const Real fv = std::get<2>(results);

                if (tau < QL_EPSILON)
                    y[i] = h(fv);
                else {
                    const std::pair<Real, Real> ndd = eqn->NDd(tau, b);
                    const Real Nd = std::get<0>(ndd);
                    const Real Dd = std::get<1>(ndd);

                    const Real fd = K*std::exp(-(r-q)*tau) * (Nd/D - Dd*N/(D*D));

                    y[i] = h(b - (fv - b)/ (fd-1));
                }
            }
            interp->updateY(y);
        }

        const Size n_fp = iterationScheme_->getNumberOfNaiveFixedPointSteps();
        for (Size k=0; k < n_fp; ++k) {
            for (Size i=1; i < x.size(); ++i) {
                const Real tau = squared(x[i]);
                const Real fv = std::get<2>(eqn->f(tau, B(tau)));

                y[i] = h(fv);
            }
            interp->updateY(y);
        }

        const detail::QdPlusAddOnValue aov(T, S, K, r, q, vol, xmax, interp);
        const Real addOn =
           (*iterationScheme_->getExerciseBoundaryToPriceIntegrator())(
               aov, 0.0, std::sqrt(T));

        const Real europeanValue = BlackCalculator(
            Option::Put, K, S*std::exp((r-q)*T),
            vol*std::sqrt(T), std::exp(-r*T)).value();

        return std::max(europeanValue, 0.0) + std::max(0.0, addOn);
    }

}




]]></document_content>
  </document>
  <document index="131">
    <source>vanilla/qdplusamericanengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2022 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file qrplusamericanengine.cpp
*/

#include <algorithm>
#include <ql/exercise.hpp>
#include <ql/utilities/null.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/comparison.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/math/solvers1d/ridder.hpp>
#include <ql/math/solvers1d/newton.hpp>
#include <ql/math/interpolations/chebyshevinterpolation.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/pricingengines/vanilla/qdplusamericanengine.hpp>
#include <ql/math/integrals/tanhsinhintegral.hpp>
#ifndef QL_BOOST_HAS_TANH_SINH
#include <ql/math/integrals/gausslobattointegral.hpp>
#endif

namespace QuantLib {

    class QdPlusBoundaryEvaluator {
      public:
        QdPlusBoundaryEvaluator(
            Real S, Real strike, Rate rf, Rate dy, Volatility vol, Time t, Time T)
        : tau(t), K(strike), sigma(vol), sigma2(sigma * sigma), v(sigma * std::sqrt(tau)), r(rf),
          q(dy), dr(std::exp(-r * tau)), dq(std::exp(-q * tau)),
          ddr((std::abs(r*tau) > 1e-5)? Real(r/(1-dr)) : Real(1/(tau*(1-0.5*r*tau*(1-r*tau/3))))),
          omega(2 * (r - q) / sigma2),
          lambda(0.5 *
                 (-(omega - 1) - std::sqrt(squared(omega - 1) + 8 * ddr / sigma2))),
          lambdaPrime(2 * ddr*ddr /
                      (sigma2 * std::sqrt(squared(omega - 1) + 8 * ddr / sigma2))),
          alpha(2 * dr / (sigma2 * (2 * lambda + omega - 1))),
          beta(alpha * (ddr + lambdaPrime / (2 * lambda + omega - 1)) - lambda),
          xMax(QdPlusAmericanEngine::xMax(strike, r, q)),
          xMin(QL_EPSILON * 1e4 * std::min(0.5 * (strike + S), xMax)),

          sc(Null<Real>()) {}

        Real operator()(Real S) const {
            ++nrEvaluations;

            if (S != sc)
                preCalculate(S);

            if (close_enough(K-S, npv)) {
                return (1-dq*Phi_dp)*S + alpha*theta/dr;
            }
            else {
                const Real c0 = -beta - lambda + alpha*theta/(dr*(K-S-npv));
                return (1-dq*Phi_dp)*S + (lambda+c0)*(K-S-npv);
            }
        }
        Real derivative(Real S) const {
            if (S != sc)
                preCalculate(S);

            return 1 - dq*Phi_dp + dq/v*phi_dp + beta*(1-dq*Phi_dp)
                    + alpha/dr*charm;
        }
        Real fprime2(Real S) const {
            if (S != sc)
                preCalculate(S);

            const Real gamma = phi_dp*dq/(v*S);
            const Real colour = gamma*(q + (r-q)*dp/v + (1-dp*dm)/(2*tau));

            return dq*(phi_dp/(S*v) - phi_dp*dp/(S*v*v))
                    + beta*gamma + alpha/dr*colour;
        }

        Real xmin() const { return xMin; }
        Real xmax() const { return xMax; }
        Size evaluations() const { return nrEvaluations; }

      private:
        void preCalculate(Real S) const {
            S = std::max(QL_EPSILON, S);
            sc = S;
            dp = std::log(S*dq/(K*dr))/v + 0.5*v;
            dm = dp - v;
            Phi_dp = Phi(-dp);
            Phi_dm = Phi(-dm);
            phi_dp = phi(dp);

            npv = dr*K*Phi_dm - S*dq*Phi_dp;
            theta = r*K*dr*Phi_dm - q*S*dq*Phi_dp - sigma2*S/(2*v)*dq*phi_dp;
            charm = -dq*(phi_dp*((r-q)/v - dm/(2*tau)) +q*Phi_dp);
        }

        const CumulativeNormalDistribution Phi;
        const NormalDistribution phi;
        const Time tau;
        const Real K;
        const Volatility sigma, sigma2, v;
        const Rate r, q;
        const DiscountFactor dr, dq, ddr;
        const Real omega, lambda, lambdaPrime, alpha, beta, xMax, xMin;
        mutable Size nrEvaluations = 0;
        mutable Real sc, dp, dm, Phi_dp, Phi_dm, phi_dp;
        mutable Real npv, theta, charm;
    };


    detail::QdPlusAddOnValue::QdPlusAddOnValue(
        Time T, Real S, Real K, Rate r, Rate q, Volatility vol,
        const Real xmax, ext::shared_ptr<Interpolation> q_z)
    : T_(T), S_(S), K_(K), xmax_(xmax),
      r_(r), q_(q), vol_(vol), q_z_(std::move(q_z)) {}


    Real detail::QdPlusAddOnValue::operator()(Real z) const {
        const Real t = z*z;
        const Real q = (*q_z_)(2*std::sqrt(std::max(0.0, T_-t)/T_) - 1, true);
        const Real b_t = xmax_*std::exp(-std::sqrt(std::max(0.0, q)));

        const Real dr = std::exp(-r_*t);
        const Real dq = std::exp(-q_*t);
        const Real v = vol_*std::sqrt(t);

        Real r;
        if (v >= QL_EPSILON) {
            if (b_t > QL_EPSILON) {
                const Real dp = std::log(S_*dq/(b_t*dr))/v + 0.5*v;
                r = 2*z*(r_*K_*dr*Phi_(-dp+v) - q_*S_*dq*Phi_(-dp));
            }
            else
                r = 0.0;
        }
        else if (close_enough(S_*dq, b_t*dr))
            r = z*(r_*K_*dr - q_*S_*dq);
        else if (b_t*dr > S_*dq)
            r = 2*z*(r_*K_*dr - q_*S_*dq);
        else
            r = 0.0;

        return r;
    }


    detail::QdPutCallParityEngine::QdPutCallParityEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {
        registerWith(process_);
    }

    void detail::QdPutCallParityEngine::calculate() const {
        QL_REQUIRE(arguments_.exercise->type() == Exercise::American,
                   "not an American option");

        const auto payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        const Real spot = process_->x0();
        QL_REQUIRE(spot >= 0.0, "negative underlying given");

        const auto maturity = arguments_.exercise->lastDate();
        const Time T = process_->time(maturity);
        const Real S = process_->x0();
        const Real K = payoff->strike();
        const Rate r = -std::log(process_->riskFreeRate()->discount(maturity))/T;
        const Rate q = -std::log(process_->dividendYield()->discount(maturity))/T;
        const Volatility vol = process_->blackVolatility()->blackVol(T, K);

        QL_REQUIRE(S >= 0, "zero or positive underlying value is required");
        QL_REQUIRE(K >= 0, "zero or positive strike is required");
        QL_REQUIRE(vol >= 0, "zero or positive volatility is required");

        if (payoff->optionType() == Option::Put)
            results_.value = calculatePutWithEdgeCases(S, K, r, q, vol, T);
        else if (payoff->optionType() == Option::Call)
            results_.value = calculatePutWithEdgeCases(K, S, q, r, vol, T);
        else
            QL_FAIL("unknown option type");
    }

    Real detail::QdPutCallParityEngine::calculatePutWithEdgeCases(
        Real S, Real K, Rate r, Rate q, Volatility vol, Time T) const {

        if (close(K, 0.0))
            return 0.0;

        if (close(S, 0.0))
            return std::max(K, K*std::exp(-r*T));

        if (r <= 0.0 && r <= q)
            return std::max(0.0,
                BlackCalculator(Option::Put, K, S*std::exp((r-q)*T),
                                vol*std::sqrt(T), std::exp(-r*T)).value());

        if (close(vol, 0.0)) {
            const auto intrinsic = [&](Real t)  -> Real {
                return std::max(0.0, K*std::exp(-r*t)-S*std::exp(-q*t));
            };
            const Real npv0 = intrinsic(0.0);
            const Real npvT = intrinsic(T);
            const Real extremT
                = close_enough(r, q)? QL_MAX_REAL : Real(std::log(r*K/(q*S))/(r-q));

            if (extremT > 0.0 && extremT < T)
                return std::max({npv0, npvT, intrinsic(extremT)});
            else
                return std::max(npv0, npvT);
        }

        return calculatePut(S, K, r, q, vol, T);
    }


    Real QdPlusAmericanEngine::xMax(Real K, Rate r, Rate q) {
        //Table 2 from Leif Andersen, Mark Lake (2021)
        //"Fast American Option Pricing: The Double-Boundary Case"

        if (r > 0.0 && q > 0.0)
            return K*std::min(1.0, r/q);
        else if (r > 0.0 && q <= 0.0)
            return K;
        else if (r == 0.0 && q < 0.0)
            return K;
        else if (r == 0.0 && q >= 0.0)
            return 0.0; // Eurpoean case
        else if (r < 0.0 && q >= 0.0)
            return 0.0; // European case
        else if (r < 0.0 && q < r)
            return K; // double boundary case
        else if (r < 0.0 && r <= q && q < 0.0)
            return 0; // European case
        else
            QL_FAIL("internal error");
    }

    QdPlusAmericanEngine::QdPlusAmericanEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Size interpolationPoints,
        QdPlusAmericanEngine::SolverType solverType,
        Real eps, Size maxIter)
    : detail::QdPutCallParityEngine(std::move(process)),
      interpolationPoints_(interpolationPoints),
      solverType_(solverType),
      eps_(eps),
      maxIter_((maxIter == Null<Size>()) ? (
          (solverType == Newton
           || solverType == Brent || solverType== Ridder)? 100 : 10)
          : maxIter ) { }

    template <class Solver>
    Real QdPlusAmericanEngine::buildInSolver(
        const QdPlusBoundaryEvaluator& eval,
        Solver solver, Real S, Real strike, Size maxIter, Real guess) const {

        solver.setMaxEvaluations(maxIter);
        solver.setLowerBound(eval.xmin());

        const Real fxmin = eval(eval.xmin());
        Real xmax = std::max(0.5*(eval.xmax() + S), eval.xmax());
        while (eval(xmax)*fxmin > 0.0 && eval.evaluations() < maxIter_)
            xmax*=2;

        if (guess == Null<Real>())
            guess = 0.5*(xmax + S);

        if (guess >= xmax)
            guess = std::nextafter(xmax, Real(-1));
        else if (guess <= eval.xmin())
            guess = std::nextafter(eval.xmin(), QL_MAX_REAL);

        return solver.solve(eval, eps_, guess, eval.xmin(), xmax);
    }

    std::pair<Size, Real> QdPlusAmericanEngine::putExerciseBoundaryAtTau(
            Real S, Real K, Rate r, Rate q,
            Volatility vol, Time T, Time tau) const {

        if (tau < QL_EPSILON)
            return std::pair<Size, Real>(
                Size(0), xMax(K, r, q));

        const QdPlusBoundaryEvaluator eval(S, K, r, q, vol, tau, T);

        Real x;
        switch (solverType_) {
          case Brent:
            x = buildInSolver(eval, QuantLib::Brent(), S, K, maxIter_);
            break;
          case Newton:
            x = buildInSolver(eval, QuantLib::Newton(), S, K, maxIter_);
            break;
          case Ridder:
            x = buildInSolver(eval, QuantLib::Ridder(), S, K, maxIter_);
            break;
          case Halley:
          case SuperHalley:
            {
                bool resultCloseEnough;
                x = eval.xmax();
                Real xOld, fx;
                const Real xmin = eval.xmin();

                do {
                    xOld = x;
                    fx = eval(x);
                    const Real fPrime = eval.derivative(x);
                    const Real lf = fx*eval.fprime2(x)/(fPrime*fPrime);
                    const Real step = (solverType_ == Halley)
                        ? Real(1/(1 - 0.5*lf)*fx/fPrime)
                        : Real((1 + 0.5*lf/(1-lf))*fx/fPrime);

                    x = std::max(xmin, x - step);
                    resultCloseEnough = std::fabs(x-xOld) < 0.5*eps_;
                }
                while (!resultCloseEnough && eval.evaluations() < maxIter_);

                if (!resultCloseEnough && !close(std::fabs(fx), 0.0)) {
                    x = buildInSolver(eval, QuantLib::Brent(), S, K, 10*maxIter_, x);
                }
            }
            break;
          default:
            QL_FAIL("unknown solver type");
        }

        return std::pair<Size, Real>(eval.evaluations(), x);
    }

    ext::shared_ptr<ChebyshevInterpolation>
        QdPlusAmericanEngine::getPutExerciseBoundary(
        Real S, Real K, Rate r, Rate q, Volatility vol, Time T) const {

        const Real xmax = xMax(K, r, q);

        return ext::make_shared<ChebyshevInterpolation>(
            interpolationPoints_,
            [&, this](Real z) {
                const Real x_sq = 0.25*T*squared(1+z);
                return squared(std::log(
                    this->putExerciseBoundaryAtTau(S, K, r, q, vol, T, x_sq)
                        .second/xmax));
            },
            ChebyshevInterpolation::SecondKind
        );
    }

    Real QdPlusAmericanEngine::calculatePut(
        Real S, Real K, Rate r, Rate q, Volatility vol, Time T) const {

        if (r < 0.0 && q < r)
            QL_FAIL("double-boundary case q<r<0 for a put option is given");

        const ext::shared_ptr<Interpolation> q_z
            = getPutExerciseBoundary(S, K, r, q, vol, T);

        const Real xmax = xMax(K, r, q);
        const detail::QdPlusAddOnValue aov(T, S, K, r, q, vol, xmax, q_z);

#ifdef QL_BOOST_HAS_TANH_SINH
        const Real addOn = TanhSinhIntegral(eps_)(aov, 0.0, std::sqrt(T));
#else
        const Real addOn = GaussLobattoIntegral(100000, QL_MAX_REAL, 0.1*eps_)
                (aov, 0.0, std::sqrt(T));
#endif

        QL_REQUIRE(addOn > -10*eps_,
            "negative early exercise value " << addOn);

        const Real europeanValue = std::max(
            0.0,
            BlackCalculator(
                Option::Put, K,
                S*std::exp((r-q)*T),
                vol*std::sqrt(T), std::exp(-r*T)).value()
        );

        return europeanValue + std::max(0.0, addOn);
    }
}
]]></document_content>
  </document>
</documents>