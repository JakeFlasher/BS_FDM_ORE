<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>asianoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2025 Kareem Fareed

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/asianoption.hpp>
#include <ql/time/date.hpp>
#include <ql/settings.hpp>
#include <algorithm>
#include <utility>

namespace QuantLib {

    DiscreteAveragingAsianOption::DiscreteAveragingAsianOption(
        Average::Type averageType,
        Real runningAccumulator,
        Size pastFixings,
        std::vector<Date> fixingDates,
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise), averageType_(averageType),
      runningAccumulator_(runningAccumulator), pastFixings_(pastFixings),
      fixingDates_(std::move(fixingDates)), allPastFixingsProvided_(false) {
        std::sort(fixingDates_.begin(), fixingDates_.end());

        // Add a hard override to the runningAccumulator if pastFixings is 0
        // (ie. the option is unseasoned)
        if (pastFixings_ == 0) {
            if (averageType == Average::Geometric) {
                runningAccumulator_ = 1.0;
            } else if (averageType == Average::Arithmetic) {
                runningAccumulator_ = 0.0;
            } else {
                QL_FAIL("Unrecognised average type, must be Average::Arithmetic or Average::Geometric");
            }
        }
    }

    DiscreteAveragingAsianOption::DiscreteAveragingAsianOption(
        Average::Type averageType,
        std::vector<Date> fixingDates,
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise,
        std::vector<Real> allPastFixings)
    : OneAssetOption(payoff, exercise), averageType_(averageType), runningAccumulator_(0.0),
      pastFixings_(0), fixingDates_(std::move(fixingDates)),
      allPastFixingsProvided_(true), allPastFixings_(std::move(allPastFixings)) {}

    void DiscreteAveragingAsianOption::setupArguments(
                                       PricingEngine::arguments* args) const {

        Real runningAccumulator = runningAccumulator_;
        Size pastFixings = pastFixings_;
        std::vector<Date> fixingDates = fixingDates_;

        // If the option was initialised with a list of fixings, before pricing we
        // compare the evaluation date to the fixing dates, and set up the pastFixings,
        // fixingDates, and runningAccumulator accordingly
        if (allPastFixingsProvided_) {
            std::vector<Date> futureFixingDates = std::vector<Date>();
            Date today = Settings::instance().evaluationDate();

            pastFixings = 0;
            for (auto fixingDate : fixingDates_) {
                if (fixingDate < today) {
                    pastFixings += 1;
                } else {
                    futureFixingDates.push_back(fixingDate);
                }
            }
            fixingDates = futureFixingDates;

            if (pastFixings > allPastFixings_.size())
                QL_FAIL("Not enough past fixings have been provided for the required historical fixing dates");

            if (averageType_ == Average::Geometric) {
                runningAccumulator = 1.0;
                for (Size i=0; i<pastFixings; i++)
                    runningAccumulator *= allPastFixings_[i];

            } else if (averageType_ == Average::Arithmetic) {
                runningAccumulator = 0.0;
                for (Size i=0; i<pastFixings; i++)
                    runningAccumulator += allPastFixings_[i];

            } else {
                QL_FAIL("Unrecognised average type, must be Average::Arithmetic or Average::Geometric");
            }

        }

        OneAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<DiscreteAveragingAsianOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->averageType = averageType_;
        moreArgs->runningAccumulator = runningAccumulator;
        moreArgs->pastFixings = pastFixings;
        moreArgs->fixingDates = fixingDates;
    }

    void DiscreteAveragingAsianOption::arguments::validate() const {

        OneAssetOption::arguments::validate();

        QL_REQUIRE(Integer(averageType) != -1, "unspecified average type");
        QL_REQUIRE(pastFixings != Null<Size>(), "null past-fixing number");
        QL_REQUIRE(runningAccumulator != Null<Real>(), "null running product");
        switch (averageType) {
            case Average::Arithmetic:
                QL_REQUIRE(runningAccumulator >= 0.0,
                           "non negative running sum required: "
                           << runningAccumulator << " not allowed");
                break;
            case Average::Geometric:
                QL_REQUIRE(runningAccumulator > 0.0,
                           "positive running product required: "
                           << runningAccumulator << " not allowed");
                break;
            default:
                QL_FAIL("invalid average type");
        }

        // check fixingTimes_ here
    }




    ContinuousAveragingAsianOption::ContinuousAveragingAsianOption(
        Average::Type averageType,
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise),
      averageType_(averageType)
      {}

    ContinuousAveragingAsianOption::ContinuousAveragingAsianOption(
        Average::Type averageType,
        Date startDate,
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise),
      averageType_(averageType),
      startDate_(startDate) {}

    void ContinuousAveragingAsianOption::setupArguments(
                                       PricingEngine::arguments* args) const {

        OneAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<ContinuousAveragingAsianOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->averageType = averageType_;
        moreArgs->startDate = startDate_;
    }

    void ContinuousAveragingAsianOption::arguments::validate() const {

        OneAssetOption::arguments::validate();

        QL_REQUIRE(Integer(averageType) != -1, "unspecified average type");
    }

}

]]></document_content>
  </document>
  <document index="2">
    <source>assetswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Chiara Fornarola
 Copyright (C) 2007, 2009, 2011 Ferdinando Ametrano
 Copyright (C) 2007, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/overnightindexedcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/instruments/assetswap.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <utility>

using std::vector;

namespace QuantLib {

    AssetSwap::AssetSwap(bool payBondCoupon,
                         ext::shared_ptr<Bond> bond,
                         Real bondCleanPrice,
                         const ext::shared_ptr<IborIndex>& iborIndex,
                         Spread spread,
                         Schedule floatSchedule,
                         const DayCounter& floatingDayCounter,
                         bool parSwap,
                         Real gearing,
                         Real nonParRepayment,
                         Date dealMaturity)
    : Swap(2), bond_(std::move(bond)), bondCleanPrice_(bondCleanPrice),
      nonParRepayment_(nonParRepayment), spread_(spread), parSwap_(parSwap) {

        auto overnight = ext::dynamic_pointer_cast<OvernightIndex>(iborIndex);
        if (overnight) {
            QL_REQUIRE(!floatSchedule.empty(),
                       "floating schedule is needed when using an overnight index");
        }

        Schedule schedule = floatSchedule.empty()
            ? Schedule(bond_->settlementDate(),
                       bond_->maturityDate(),
                       iborIndex->tenor(),
                       iborIndex->fixingCalendar(),
                       iborIndex->businessDayConvention(),
                       iborIndex->businessDayConvention(),
                       DateGeneration::Backward,
                       false) // endOfMonth
            : std::move(floatSchedule);

        if (dealMaturity == Date())
            dealMaturity = schedule.back();
        QL_REQUIRE(dealMaturity <= schedule.back(),
                   "deal maturity " << dealMaturity <<
                   " cannot be later than (adjusted) bond maturity " <<
                   schedule.back());
        QL_REQUIRE(dealMaturity > schedule.front(),
                   "deal maturity " << dealMaturity <<
                   " must be later than swap start date " <<
                   schedule.front());

        // the following might become an input parameter
        BusinessDayConvention paymentAdjustment = Following;

        Date finalDate = schedule.calendar().adjust(
            dealMaturity, paymentAdjustment);
        schedule = schedule.until(finalDate);

        // bondCleanPrice must be the (forward) clean price
        // at the floating schedule start date
        upfrontDate_ = schedule.startDate();
        Real dirtyPrice = bondCleanPrice_ + bond_->accruedAmount(upfrontDate_);

        Real notional = bond_->notional(upfrontDate_);
        /* In the market asset swap, the bond is purchased in return for
           payment of the full price. The notional of the floating leg is
           then scaled by the full price. */
        if (!parSwap_)
            notional *= dirtyPrice/100.0;

        /******** Bond leg ********/

        const Leg& bondLeg = bond_->cashflows();
        QL_REQUIRE(!bondLeg.empty(), "no cashflows from bond");

        bool includeOnUpfrontDate = false; // a cash flow on the upfront
                                           // date must be discarded

        // add coupons for the time being, not the redemption
        Leg::const_iterator i;
        for (i = bondLeg.begin(); i < bondLeg.end()-1 && (*i)->date()<=dealMaturity; ++i) {
            if (!(*i)->hasOccurred(upfrontDate_, includeOnUpfrontDate))
                legs_[0].push_back(*i);
        }

        // if we're skipping a cashflow before the redemption
        // and it's a coupon, then add the accrued coupon.
        if (i < bondLeg.end()-1) {
            auto c = ext::dynamic_pointer_cast<Coupon>(*i);
            if (c != nullptr) {
                Real accruedAmount = c->accruedAmount(dealMaturity);
                auto accruedCoupon =
                    ext::make_shared<SimpleCashFlow>(accruedAmount, finalDate);
                legs_[0].push_back(accruedCoupon);
            }
        }

        // add the redemption, or whatever the final payment is
        if (nonParRepayment_ == Null<Real>()) {
            auto redemption = bondLeg.back();
            auto finalFlow =
                ext::make_shared<SimpleCashFlow>(redemption->amount(), finalDate);
            legs_[0].push_back(finalFlow);
            nonParRepayment_ = 100.0;
        } else {
            auto finalFlow =
                ext::make_shared<SimpleCashFlow>(nonParRepayment_, finalDate);
            legs_[0].push_back(finalFlow);
        }

        /******** Floating leg ********/

        if (overnight) {
            legs_[1] =
                OvernightLeg(schedule, overnight)
                .withNotionals(notional)
                .withPaymentAdjustment(paymentAdjustment)
                .withGearings(gearing)
                .withSpreads(spread)
                .withPaymentDayCounter(floatingDayCounter);
        } else {
            legs_[1] =
                IborLeg(std::move(schedule), iborIndex)
                .withNotionals(notional)
                .withPaymentAdjustment(paymentAdjustment)
                .withGearings(gearing)
                .withSpreads(spread)
                .withPaymentDayCounter(floatingDayCounter);
        }

        if (parSwap_) {
            // upfront
            Real upfront = (dirtyPrice-100.0)/100.0 * notional;
            auto upfrontCashFlow =
                ext::make_shared<SimpleCashFlow>(upfront, upfrontDate_);
            legs_[1].insert(legs_[1].begin(), upfrontCashFlow);
            // backpayment (accounts for non-par redemption, if any)
            Real backPayment = notional;
            auto backPaymentCashFlow =
                ext::make_shared<SimpleCashFlow>(backPayment, finalDate);
            legs_[1].push_back(backPaymentCashFlow);
        } else {
            // final notional exchange
            auto finalCashFlow =
                ext::make_shared<SimpleCashFlow>(notional, finalDate);
            legs_[1].push_back(finalCashFlow);
        }

        /******** registration and sides ********/

        for (const auto& leg: legs_)
            for (const auto& c: leg)
                registerWith(c);

        if (payBondCoupon) {
            payer_[0]=-1.0;
            payer_[1]=+1.0;
        } else {
            payer_[0]=+1.0;
            payer_[1]=-1.0;
        }
    }

    void AssetSwap::setupArguments(PricingEngine::arguments* args) const {

        Swap::setupArguments(args);

        auto* arguments = dynamic_cast<AssetSwap::arguments*>(args);

        if (arguments == nullptr) // it's a swap engine...
            return;

        const Leg& fixedCoupons = bondLeg();

        arguments->fixedResetDates = arguments->fixedPayDates =
            vector<Date>(fixedCoupons.size());
        arguments->fixedCoupons = vector<Real>(fixedCoupons.size());

        for (Size i=0; i<fixedCoupons.size(); ++i) {
            ext::shared_ptr<FixedRateCoupon> coupon =
                ext::dynamic_pointer_cast<FixedRateCoupon>(fixedCoupons[i]);

            arguments->fixedPayDates[i] = coupon->date();
            arguments->fixedResetDates[i] = coupon->accrualStartDate();
            arguments->fixedCoupons[i] = coupon->amount();
        }

        const Leg& floatingCoupons = floatingLeg();

        arguments->floatingResetDates = arguments->floatingPayDates =
            arguments->floatingFixingDates =
            vector<Date>(floatingCoupons.size());
        arguments->floatingAccrualTimes =
            vector<Time>(floatingCoupons.size());
        arguments->floatingSpreads =
            vector<Spread>(floatingCoupons.size());

        for (Size i=0; i<floatingCoupons.size(); ++i) {
            ext::shared_ptr<FloatingRateCoupon> coupon =
                ext::dynamic_pointer_cast<FloatingRateCoupon>(floatingCoupons[i]);

            arguments->floatingResetDates[i] = coupon->accrualStartDate();
            arguments->floatingPayDates[i] = coupon->date();
            arguments->floatingFixingDates[i] = coupon->fixingDate();
            arguments->floatingAccrualTimes[i] = coupon->accrualPeriod();
            arguments->floatingSpreads[i] = coupon->spread();
        }
    }

    Spread AssetSwap::fairSpread() const {
        static const Spread basisPoint = 1.0e-4;
        calculate();
        if (fairSpread_ != Null<Spread>()) {
            return fairSpread_;
        } else if (legBPS_.size() > 1 && legBPS_[1] != Null<Spread>()) {
            fairSpread_ = spread_ - NPV_/legBPS_[1]*basisPoint;
            return fairSpread_;
        } else {
            QL_FAIL("fair spread not available");
        }
    }

    Real AssetSwap::floatingLegBPS() const {
        calculate();
        QL_REQUIRE(legBPS_.size() > 1 && legBPS_[1] != Null<Real>(),
                   "floating-leg BPS not available");
        return legBPS_[1];
    }

    Real AssetSwap::floatingLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_.size() > 1 && legNPV_[1] != Null<Real>(),
                   "floating-leg NPV not available");
        return legNPV_[1];
    }

    Real AssetSwap::fairCleanPrice() const {
        calculate();
        if (fairCleanPrice_ != Null<Real>()) {
            return fairCleanPrice_;
        } else {
            QL_REQUIRE(startDiscounts_[1]!=Null<DiscountFactor>(),
                       "fair clean price not available for seasoned deal");
            Real notional = bond_->notional(upfrontDate_);
            if (parSwap_) {
                fairCleanPrice_ = bondCleanPrice_ - payer_[1] *
                    NPV_*npvDateDiscount_/startDiscounts_[1]/(notional/100.0);
            } else {
                Real accruedAmount = bond_->accruedAmount(upfrontDate_);
                Real dirtyPrice = bondCleanPrice_ + accruedAmount;
                Real fairDirtyPrice = - legNPV_[0]/legNPV_[1] * dirtyPrice;
                fairCleanPrice_ = fairDirtyPrice - accruedAmount;
            }

            return fairCleanPrice_;
        }
    }

    Real AssetSwap::fairNonParRepayment() const {
        calculate();
        if (fairNonParRepayment_ != Null<Real>()) {
            return fairNonParRepayment_;
        } else {
            QL_REQUIRE(endDiscounts_[1]!=Null<DiscountFactor>(),
                       "fair non par repayment not available for expired leg");
            Real notional = bond_->notional(upfrontDate_);
            fairNonParRepayment_ = nonParRepayment_ - payer_[0] *
                NPV_*npvDateDiscount_/endDiscounts_[1]/(notional/100.0);
            return fairNonParRepayment_;
        }
    }

    void AssetSwap::setupExpired() const {
        Swap::setupExpired();
        fairSpread_ = Null<Spread>();
        fairCleanPrice_ = Null<Real>();
        fairNonParRepayment_ = Null<Real>();
    }

    void AssetSwap::fetchResults(const PricingEngine::results* r) const {
        Swap::fetchResults(r);
        const auto* results = dynamic_cast<const AssetSwap::results*>(r);
        if (results != nullptr) {
            fairSpread_ = results->fairSpread;
            fairCleanPrice_= results->fairCleanPrice;
            fairNonParRepayment_= results->fairNonParRepayment;
        } else {
            fairSpread_ = Null<Spread>();
            fairCleanPrice_ = Null<Real>();
            fairNonParRepayment_ = Null<Real>();
        }
    }

    void AssetSwap::arguments::validate() const {
        QL_REQUIRE(fixedResetDates.size() == fixedPayDates.size(),
                   "number of fixed start dates different from "
                   "number of fixed payment dates");
        QL_REQUIRE(fixedPayDates.size() == fixedCoupons.size(),
                   "number of fixed payment dates different from "
                   "number of fixed coupon amounts");
        QL_REQUIRE(floatingResetDates.size() == floatingPayDates.size(),
                   "number of floating start dates different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingFixingDates.size() == floatingPayDates.size(),
                   "number of floating fixing dates different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingAccrualTimes.size() == floatingPayDates.size(),
                   "number of floating accrual times different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingSpreads.size() == floatingPayDates.size(),
                   "number of floating spreads different from "
                   "number of floating payment dates");
    }

    void AssetSwap::results::reset() {
        Swap::results::reset();
        fairSpread = Null<Spread>();
        fairCleanPrice = Null<Real>();
        fairNonParRepayment = Null<Real>();
    }

}
]]></document_content>
  </document>
  <document index="3">
    <source>averagetype.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Neil Firth
 Copyright (C) 2003, 2004, 2007 Ferdinando Ametrano
 Copyright (C) 2003, 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/averagetype.hpp>
#include <ql/types.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    std::ostream& operator<<(std::ostream& out,
                             Average::Type type) {
        switch (type) {
          case Average::Arithmetic:
            return out << "Arithmetic";
          case Average::Geometric:
            return out << "Geometric";
          default:
            QL_FAIL("unknown Average::Type (" << Integer(type) << ")");
        }
    }

}
]]></document_content>
  </document>
  <document index="4">
    <source>barrieroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Neil Firth
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/instruments/barrieroption.hpp>
#include <ql/instruments/impliedvolatility.hpp>
#include <ql/pricingengines/barrier/analyticbarrierengine.hpp>
#include <ql/pricingengines/barrier/fdblackscholesbarrierengine.hpp>
#include <memory>

namespace QuantLib {

    BarrierOption::BarrierOption(
        Barrier::Type barrierType,
        Real barrier,
        Real rebate,
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise),
      barrierType_(barrierType), barrier_(barrier), rebate_(rebate) {}

    void BarrierOption::setupArguments(PricingEngine::arguments* args) const {

        OneAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<BarrierOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->barrierType = barrierType_;
        moreArgs->barrier = barrier_;
        moreArgs->rebate = rebate_;
    }


    Volatility BarrierOption::impliedVolatility(
             Real targetValue,
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             Real accuracy,
             Size maxEvaluations,
             Volatility minVol,
             Volatility maxVol) const {
        return impliedVolatility(targetValue, process, DividendSchedule(),
                                 accuracy, maxEvaluations, minVol, maxVol);
    }

    Volatility BarrierOption::impliedVolatility(
             Real targetValue,
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             const DividendSchedule& dividends,
             Real accuracy,
             Size maxEvaluations,
             Volatility minVol,
             Volatility maxVol) const {
        QL_REQUIRE(!isExpired(), "option expired");

        ext::shared_ptr<SimpleQuote> volQuote(new SimpleQuote);

        ext::shared_ptr<GeneralizedBlackScholesProcess> newProcess =
            detail::ImpliedVolatilityHelper::clone(process, volQuote);

        // engines are built-in for the time being
        std::unique_ptr<PricingEngine> engine;
        switch (exercise_->type()) {
          case Exercise::European:
            if (dividends.empty())
                engine = std::make_unique<AnalyticBarrierEngine>(newProcess);
            else
                engine = std::make_unique<FdBlackScholesBarrierEngine>(newProcess, dividends);
            break;
          case Exercise::American:
          case Exercise::Bermudan:
            QL_FAIL("engine not available for non-European barrier option");
            break;
          default:
            QL_FAIL("unknown exercise type");
        }

        return detail::ImpliedVolatilityHelper::calculate(*this,
                                                          *engine,
                                                          *volQuote,
                                                          targetValue,
                                                          accuracy,
                                                          maxEvaluations,
                                                          minVol, maxVol);
    }


    BarrierOption::arguments::arguments()
    : barrierType(Barrier::Type(-1)), barrier(Null<Real>()),
      rebate(Null<Real>()) {}

    void BarrierOption::arguments::validate() const {
        OneAssetOption::arguments::validate();

        switch (barrierType) {
          case Barrier::DownIn:
          case Barrier::UpIn:
          case Barrier::DownOut:
          case Barrier::UpOut:
            break;
          default:
            QL_FAIL("unknown type");
        }

        QL_REQUIRE(barrier != Null<Real>(), "no barrier given");
        QL_REQUIRE(rebate != Null<Real>(), "no rebate given");
    }

    bool BarrierOption::engine::triggered(Real underlying) const {
        switch (arguments_.barrierType) {
          case Barrier::DownIn:
          case Barrier::DownOut:
            return underlying < arguments_.barrier;
          case Barrier::UpIn:
          case Barrier::UpOut:
            return underlying > arguments_.barrier;
          default:
            QL_FAIL("unknown type");
        }
    }

}

]]></document_content>
  </document>
  <document index="5">
    <source>barriertype.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Neil Firth
 Copyright (C) 2003, 2004, 2007 Ferdinando Ametrano
 Copyright (C) 2003, 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/barriertype.hpp>
#include <ql/types.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    std::ostream& operator<<(std::ostream& out,
                             Barrier::Type type) {
        switch (type) {
          case Barrier::DownIn:
            return out << "Down&In";
          case Barrier::UpIn:
            return out << "Up&In";
          case Barrier::DownOut:
            return out << "Down&Out";
          case Barrier::UpOut:
            return out << "Up&Out";
          default:
            QL_FAIL("unknown Barrier::Type (" << Integer(type) << ")");
        }
    }

}
]]></document_content>
  </document>
  <document index="6">
    <source>basketoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Neil Firth
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2007 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/basketoption.hpp>

namespace QuantLib {

    BasketOption::BasketOption(
        const ext::shared_ptr<BasketPayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : MultiAssetOption(payoff, exercise) {}

}

]]></document_content>
  </document>
  <document index="7">
    <source>bmaswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Roland Lichters
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/bmaswap.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/averagebmacoupon.hpp>

namespace QuantLib {

    BMASwap::BMASwap(Type type,
                     Real nominal,
                     // Libor leg
                     Schedule liborSchedule,
                     Real liborFraction,
                     Spread liborSpread,
                     const ext::shared_ptr<IborIndex>& liborIndex,
                     const DayCounter& liborDayCount,
                     // BMA leg
                     Schedule bmaSchedule,
                     const ext::shared_ptr<BMAIndex>& bmaIndex,
                     const DayCounter& bmaDayCount)
    : Swap(2), type_(type), nominal_(nominal),
      liborFraction_(liborFraction), liborSpread_(liborSpread)  {

        BusinessDayConvention convention =
            liborSchedule.businessDayConvention();

        legs_[0] = IborLeg(std::move(liborSchedule), liborIndex)
            .withNotionals(nominal)
            .withPaymentDayCounter(liborDayCount)
            .withPaymentAdjustment(convention)
            .withFixingDays(liborIndex->fixingDays())
            .withGearings(liborFraction)
            .withSpreads(liborSpread);

        auto bmaConvention = bmaSchedule.businessDayConvention();

        legs_[1] = AverageBMALeg(std::move(bmaSchedule), bmaIndex)
            .withNotionals(nominal)
            .withPaymentDayCounter(bmaDayCount)
            .withPaymentAdjustment(bmaConvention);

        for (Size j=0; j<2; ++j) {
            for (auto& i : legs_[j])
                registerWith(i);
        }

        switch (type_) {
          case Payer:
            payer_[0] = +1.0;
            payer_[1] = -1.0;
            break;
          case Receiver:
            payer_[0] = -1.0;
            payer_[1] = +1.0;
            break;
          default:
            QL_FAIL("Unknown BMA-swap type");
        }
    }

    Real BMASwap::liborFraction() const {
        return liborFraction_;
    }

    Spread BMASwap::liborSpread() const {
        return liborSpread_;
    }

    Real BMASwap::nominal() const {
        return nominal_;
    }

    Swap::Type BMASwap::type() const {
        return type_;
    }

    const Leg& BMASwap::liborLeg() const {
        return legs_[0];
    }

    const Leg& BMASwap::bmaLeg() const {
        return legs_[1];
    }


    Real BMASwap::liborLegBPS() const {
        calculate();
        QL_REQUIRE(legBPS_[0] != Null<Real>(), "result not available");
        return legBPS_[0];
    }

    Real BMASwap::liborLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[0] != Null<Real>(), "result not available");
        return legNPV_[0];
    }

    Real BMASwap::fairLiborFraction() const {
        static Spread basisPoint = 1.0e-4;

        Real spreadNPV = (liborSpread_/basisPoint)*liborLegBPS();
        Real pureLiborNPV = liborLegNPV() - spreadNPV;
        QL_REQUIRE(pureLiborNPV != 0.0,
                   "result not available (null libor NPV)");
        return -liborFraction_ * (bmaLegNPV() + spreadNPV) / pureLiborNPV;
    }

    Spread BMASwap::fairLiborSpread() const {
        static Spread basisPoint = 1.0e-4;

        return liborSpread_ - NPV()/(liborLegBPS()/basisPoint);
    }

    Real BMASwap::bmaLegBPS() const {
        calculate();
        QL_REQUIRE(legBPS_[1] != Null<Real>(), "result not available");
        return legBPS_[1];
    }

    Real BMASwap::bmaLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[1] != Null<Real>(), "result not available");
        return legNPV_[1];
    }

}
]]></document_content>
  </document>
  <document index="8">
    <source>bond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Jeff Yu
 Copyright (C) 2004 M-Dimension Consulting Inc.
 Copyright (C) 2005, 2006, 2007, 2008, 2010 StatPro Italia srl
 Copyright (C) 2007, 2008, 2009 Ferdinando Ametrano
 Copyright (C) 2007 Chiara Fornarola
 Copyright (C) 2008 Simon Ibbotson
 Copyright (C) 2022 Oleg Kulkov

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/floatingratecoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/instruments/bond.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/pricingengines/bond/bondfunctions.hpp>
#include <ql/pricingengines/bond/discountingbondengine.hpp>
#include <ql/shared_ptr.hpp>
#include <utility>

namespace QuantLib {

    Bond::Bond(Natural settlementDays, Calendar calendar, const Date& issueDate, const Leg& coupons)
    : settlementDays_(settlementDays), calendar_(std::move(calendar)), cashflows_(coupons),
      issueDate_(issueDate) {

        if (!coupons.empty()) {
            std::sort(cashflows_.begin(), cashflows_.end(),
                      earlier_than<ext::shared_ptr<CashFlow> >());

            if (issueDate_ != Date()) {
                QL_REQUIRE(issueDate_<cashflows_[0]->date(),
                           "issue date (" << issueDate_ <<
                           ") must be earlier than first payment date (" <<
                           cashflows_[0]->date() << ")");
            }

            maturityDate_ = coupons.back()->date();

            addRedemptionsToCashflows();
        }

        registerWith(Settings::instance().evaluationDate());
        for (const auto& cashflow : cashflows_)
            registerWith(cashflow);
    }

    Bond::Bond(Natural settlementDays,
               Calendar calendar,
               Real faceAmount,
               const Date& maturityDate,
               const Date& issueDate,
               const Leg& cashflows)
    : settlementDays_(settlementDays), calendar_(std::move(calendar)), cashflows_(cashflows),
      maturityDate_(maturityDate), issueDate_(issueDate) {

        if (!cashflows.empty()) {

            std::sort(cashflows_.begin(), cashflows_.end()-1,
                      earlier_than<ext::shared_ptr<CashFlow> >());

            if (maturityDate_ == Date())
                maturityDate_ = CashFlows::maturityDate(cashflows);

            if (issueDate_ != Date()) {
                QL_REQUIRE(issueDate_<cashflows_[0]->date(),
                           "issue date (" << issueDate_ <<
                           ") must be earlier than first payment date (" <<
                           cashflows_[0]->date() << ")");
            }

            notionals_.resize(2);
            notionalSchedule_.resize(2);

            notionalSchedule_[0] = Date();
            notionals_[0] = faceAmount;

            notionalSchedule_[1] = maturityDate_;
            notionals_[1] = 0.0;

            redemptions_.push_back(cashflows.back());
        }

        registerWith(Settings::instance().evaluationDate());
        for (const auto& cashflow : cashflows_)
            registerWith(cashflow);
    }

    bool Bond::isExpired() const {
        // this is the Instrument interface, so it doesn't use
        // BondFunctions.  We pass nullopt as includeSettlementDateFlows
        // so that CashFlows::isExpired uses the default setting.
        return CashFlows::isExpired(cashflows_,
                                    ext::nullopt,
                                    Settings::instance().evaluationDate());
    }

    Real Bond::notional(Date d) const {
        if (d == Date())
            d = settlementDate();

        if (d > notionalSchedule_.back()) {
            // after maturity
            return 0.0;
        }

        // After the check above, d is between the schedule
        // boundaries.  We search starting from the second notional
        // date, since the first is null.  After the call to
        // lower_bound, *i is the earliest date which is greater or
        // equal than d.  Its index is greater or equal to 1.
        auto i = std::lower_bound(notionalSchedule_.begin() + 1, notionalSchedule_.end(), d);
        Size index = std::distance(notionalSchedule_.begin(), i);

        if (d < notionalSchedule_[index]) {
            // no doubt about what to return
            return notionals_[index-1];
        } else {
            // d is equal to a redemption date.
            // As per bond conventions, the payment has occurred;
            // the bond already changed notional.
            return notionals_[index];
        }
    }

    const ext::shared_ptr<CashFlow>& Bond::redemption() const {
        QL_REQUIRE(redemptions_.size() == 1,
                   "multiple redemption cash flows given");
        return redemptions_.back();
    }

    Date Bond::startDate() const {
        return BondFunctions::startDate(*this);
    }

    Date Bond::maturityDate() const {
        if (maturityDate_ != Date())
            return maturityDate_;
        else
            return BondFunctions::maturityDate(*this);
    }

    bool Bond::isTradable(Date d) const {
        return BondFunctions::isTradable(*this, d);
    }

    Date Bond::settlementDate(Date d) const {
        if (d==Date())
            d = Settings::instance().evaluationDate();

        // usually, the settlement is at T+n...
        Date settlement = calendar_.advance(d, settlementDays_, Days);
        // ...but the bond won't be traded until the issue date (if given.)
        if (issueDate_ == Date())
            return settlement;
        else
            return std::max(settlement, issueDate_);
    }

    Real Bond::cleanPrice() const {
        return dirtyPrice() - accruedAmount(settlementDate());
    }

    Real Bond::dirtyPrice() const {
        Real currentNotional = notional(settlementDate());
        if (currentNotional == 0.0)
            return 0.0;
        else
            return settlementValue()*100.0/currentNotional;
    }

    Real Bond::settlementValue() const {
        calculate();
        QL_REQUIRE(settlementValue_ != Null<Real>(),
                   "settlement value not provided");
        return settlementValue_;
    }

    Real Bond::settlementValue(Real cleanPrice) const {
        Real dirtyPrice = cleanPrice + accruedAmount(settlementDate());
        return dirtyPrice / 100.0 * notional(settlementDate());
    }

    Rate Bond::yield(const DayCounter& dc,
                     Compounding comp,
                     Frequency freq,
                     Real accuracy,
                     Size maxEvaluations,
                     Real guess,
                     Bond::Price::Type priceType) const {
        Real currentNotional = notional(settlementDate());
        if (currentNotional == 0.0)
            return 0.0;

        Bond::Price price(priceType == Bond::Price::Clean ? cleanPrice() : dirtyPrice(), priceType);

        return BondFunctions::yield(*this, price, dc, comp, freq,
                                    settlementDate(),
                                    accuracy, maxEvaluations,
                                    guess);
    }

    Real Bond::cleanPrice(Rate y,
                          const DayCounter& dc,
                          Compounding comp,
                          Frequency freq,
                          Date settlement) const {
        return BondFunctions::cleanPrice(*this, y, dc, comp, freq, settlement);
    }

    Real Bond::dirtyPrice(Rate y,
                          const DayCounter& dc,
                          Compounding comp,
                          Frequency freq,
                          Date settlement) const {
        Real currentNotional = notional(settlement);
        if (currentNotional == 0.0)
            return 0.0;

        return BondFunctions::cleanPrice(*this, y, dc, comp, freq, settlement)
            + accruedAmount(settlement);
    }

    Rate Bond::yield(Bond::Price price,
                     const DayCounter& dc,
                     Compounding comp,
                     Frequency freq,
                     Date settlement,
                     Real accuracy,
                     Size maxEvaluations,
                     Real guess) const {
        Real currentNotional = notional(settlement);
        if (currentNotional == 0.0)
            return 0.0;

        return BondFunctions::yield(*this, price, dc, comp, freq,
                                    settlement, accuracy, maxEvaluations,
                                    guess);
    }

    Real Bond::accruedAmount(Date settlement) const {
        Real currentNotional = notional(settlement);
        if (currentNotional == 0.0)
            return 0.0;

        return BondFunctions::accruedAmount(*this, settlement);
    }

    Rate Bond::nextCouponRate(Date settlement) const {
        return BondFunctions::nextCouponRate(*this, settlement);
    }

    Rate Bond::previousCouponRate(Date settlement) const {
        return BondFunctions::previousCouponRate(*this, settlement);
    }

    Date Bond::nextCashFlowDate(Date settlement) const {
        return BondFunctions::nextCashFlowDate(*this, settlement);
    }

    Date Bond::previousCashFlowDate(Date settlement) const {
        return BondFunctions::previousCashFlowDate(*this, settlement);
    }

    void Bond::setupExpired() const {
        Instrument::setupExpired();
        settlementValue_ = 0.0;
    }

    void Bond::setupArguments(PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<Bond::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->settlementDate = settlementDate();
        arguments->cashflows = cashflows_;
        arguments->calendar = calendar_;
    }

    void Bond::fetchResults(const PricingEngine::results* r) const {

        Instrument::fetchResults(r);

        const auto* results = dynamic_cast<const Bond::results*>(r);
        QL_ENSURE(results != nullptr, "wrong result type");

        settlementValue_ = results->settlementValue;
    }

    void Bond::addRedemptionsToCashflows(const std::vector<Real>& redemptions) {
        // First, we gather the notional information from the cashflows
        calculateNotionalsFromCashflows();
        // Then, we create the redemptions based on the notional
        // information and we add them to the cashflows vector after
        // the coupons.
        redemptions_.clear();
        for (Size i=1; i<notionalSchedule_.size(); ++i) {
            Real R = i < redemptions.size() ? redemptions[i] :
                     !redemptions.empty()   ? redemptions.back() :
                                              100.0;
            Real amount = (R/100.0)*(notionals_[i-1]-notionals_[i]);
            ext::shared_ptr<CashFlow> payment;
            if (i < notionalSchedule_.size()-1)
                payment = ext::make_shared<AmortizingPayment>(amount,
                                                    notionalSchedule_[i]);
            else
                payment = ext::make_shared<Redemption>(amount, notionalSchedule_[i]);
            cashflows_.push_back(payment);
            redemptions_.push_back(payment);
        }
        // stable_sort now moves the redemptions to the right places
        // while ensuring that they follow coupons with the same date.
        std::stable_sort(cashflows_.begin(), cashflows_.end(),
                         earlier_than<ext::shared_ptr<CashFlow> >());
    }

    void Bond::setSingleRedemption(Real notional,
                                   Real redemption,
                                   const Date& date) {

        ext::shared_ptr<CashFlow> redemptionCashflow(
                         new Redemption(notional*redemption/100.0, date));
        setSingleRedemption(notional, redemptionCashflow);
    }

    void Bond::setSingleRedemption(Real notional,
                                   const ext::shared_ptr<CashFlow>& redemption) {
        notionals_.resize(2);
        notionalSchedule_.resize(2);
        redemptions_.clear();

        notionalSchedule_[0] = Date();
        notionals_[0] = notional;

        notionalSchedule_[1] = redemption->date();
        notionals_[1] = 0.0;

        cashflows_.push_back(redemption);
        redemptions_.push_back(redemption);
    }

    void Bond::deepUpdate() {
        for (auto& cashflow : cashflows_) {
            cashflow->deepUpdate();
        }
        update();
    }

    void Bond::calculateNotionalsFromCashflows() {
        notionalSchedule_.clear();
        notionals_.clear();

        Date lastPaymentDate = Date();
        notionalSchedule_.emplace_back();
        for (auto& cashflow : cashflows_) {
            ext::shared_ptr<Coupon> coupon = ext::dynamic_pointer_cast<Coupon>(cashflow);
            if (!coupon)
                continue;

            Real notional = coupon->nominal();
            // we add the notional only if it is the first one...
            if (notionals_.empty()) {
                notionals_.push_back(coupon->nominal());
                lastPaymentDate = coupon->date();
            } else if (!close(notional, notionals_.back())) {
                // ...or if it has changed.
                notionals_.push_back(coupon->nominal());
                // in this case, we also add the last valid date for
                // the previous one...
                notionalSchedule_.push_back(lastPaymentDate);
                // ...and store the candidate for this one.
                lastPaymentDate = coupon->date();
            } else {
                // otherwise, we just extend the valid range of dates
                // for the current notional.
                lastPaymentDate = coupon->date();
            }
        }
        QL_REQUIRE(!notionals_.empty(), "no coupons provided");
        notionals_.push_back(0.0);
        notionalSchedule_.push_back(lastPaymentDate);
    }


    void Bond::arguments::validate() const {
        QL_REQUIRE(settlementDate != Date(), "no settlement date provided");
        QL_REQUIRE(!cashflows.empty(), "no cash flow provided");
        for (const auto & cf: cashflows)
            QL_REQUIRE(cf, "null cash flow provided");
    }

}
]]></document_content>
  </document>
  <document index="9">
    <source>bondforward.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Allen Kuo
 Copyright (C) 2022 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/bondforward.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/cashflow.hpp>

namespace QuantLib {

    BondForward::BondForward(
                    const Date& valueDate,
                    const Date& maturityDate,
                    Position::Type type,
                    Real strike,
                    Natural settlementDays,
                    const DayCounter& dayCounter,
                    const Calendar& calendar,
                    BusinessDayConvention businessDayConvention,
                    const ext::shared_ptr<Bond>& bond,
                    const Handle<YieldTermStructure>& discountCurve,
                    const Handle<YieldTermStructure>& incomeDiscountCurve)
    : Forward(dayCounter, calendar, businessDayConvention, settlementDays,
              ext::shared_ptr<Payoff>(new ForwardTypePayoff(type,strike)),
              valueDate, maturityDate, discountCurve), bond_(bond) {

        incomeDiscountCurve_ = incomeDiscountCurve;
        registerWith(incomeDiscountCurve_);
        registerWith(bond);
    }


    Real BondForward::cleanForwardPrice() const {
        return forwardValue() - bond_->accruedAmount(maturityDate_);
    }


    Real BondForward::forwardPrice() const {
        return forwardValue();
    }


    Real BondForward::spotIncome(
        const Handle<YieldTermStructure>& incomeDiscountCurve) const {

        Real income = 0.0;
        Date settlement = settlementDate();
        Leg cf = bond_->cashflows();

        /*
          the following assumes
          1. cashflows are in ascending order !
          2. considers as income: all coupons paid between settlementDate()
          and contract delivery/maturity date
        */
        for (auto& i : cf) {
            if (!i->hasOccurred(settlement, false)) {
                if (i->hasOccurred(maturityDate_, false)) {
                    income += i->amount() * incomeDiscountCurve->discount(i->date());
                } else {
                    break;
                }
            }
        }

        return income;
    }


    Real BondForward::spotValue() const { 
        return bond_->dirtyPrice();
    }


    void BondForward::performCalculations() const {

        underlyingSpotValue_ = spotValue();
        underlyingIncome_    = spotIncome(incomeDiscountCurve_);

        Forward::performCalculations();
    }

}

]]></document_content>
  </document>
  <document index="10">
    <source>bonds/amortizingcmsratebond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Simon Ibbotson

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/bonds/amortizingcmsratebond.hpp>
#include <ql/cashflows/cmscoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/time/schedule.hpp>

namespace QuantLib {

    AmortizingCmsRateBond::AmortizingCmsRateBond(
                                    Natural settlementDays,
                                    const std::vector<Real>& notionals,
                                    Schedule schedule,
                                    const ext::shared_ptr<SwapIndex>& index,
                                    const DayCounter& paymentDayCounter,
                                    BusinessDayConvention paymentConvention,
                                    Natural fixingDays,
                                    const std::vector<Real>& gearings,
                                    const std::vector<Spread>& spreads,
                                    const std::vector<Rate>& caps,
                                    const std::vector<Rate>& floors,
                                    bool inArrears,
                                    const Date& issueDate,
                                    const std::vector<Real>& redemptions)
    : Bond(settlementDays, schedule.calendar(), issueDate) {

        maturityDate_ = schedule.endDate();

        cashflows_ = CmsLeg(std::move(schedule), index)
            .withNotionals(notionals)
            .withPaymentDayCounter(paymentDayCounter)
            .withPaymentAdjustment(paymentConvention)
            .withFixingDays(fixingDays)
            .withGearings(gearings)
            .withSpreads(spreads)
            .withCaps(caps)
            .withFloors(floors)
            .inArrears(inArrears);

        addRedemptionsToCashflows(redemptions);

        QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");

        registerWith(index);
    }

}
]]></document_content>
  </document>
  <document index="11">
    <source>bonds/amortizingfixedratebond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Simon Ibbotson

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/bonds/amortizingfixedratebond.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/time/schedule.hpp>

namespace QuantLib {

    AmortizingFixedRateBond::AmortizingFixedRateBond(
                                      Natural settlementDays,
                                      const std::vector<Real>& notionals,
                                      Schedule schedule,
                                      const std::vector<Rate>& coupons,
                                      const DayCounter& accrualDayCounter,
                                      BusinessDayConvention paymentConvention,
                                      const Date& issueDate,
                                      const Period& exCouponPeriod,
                                      const Calendar& exCouponCalendar,
                                      const BusinessDayConvention exCouponConvention,
                                      bool exCouponEndOfMonth,
                                      const std::vector<Real>& redemptions,
                                      Integer paymentLag)
    : Bond(settlementDays, schedule.calendar(), issueDate),
      frequency_(schedule.tenor().frequency()),
      dayCounter_(accrualDayCounter) {

        maturityDate_ = schedule.endDate();

        cashflows_ = FixedRateLeg(std::move(schedule))
            .withNotionals(notionals)
            .withCouponRates(coupons, accrualDayCounter)
            .withPaymentAdjustment(paymentConvention)
            .withExCouponPeriod(exCouponPeriod,
                                exCouponCalendar,
                                exCouponConvention,
                                exCouponEndOfMonth)
            .withPaymentLag(paymentLag);

        addRedemptionsToCashflows(redemptions);

        QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");
    }


    Schedule sinkingSchedule(const Date& startDate,
                             const Period& bondLength,
                             const Frequency& frequency,
                             const Calendar& paymentCalendar) {
        Date maturityDate = startDate + bondLength;
        Schedule retVal(startDate, maturityDate, Period(frequency),
                        paymentCalendar, Unadjusted, Unadjusted,
                        DateGeneration::Backward, false);
        return retVal;
    }

    namespace  {

        std::pair<Integer,Integer> daysMinMax(const Period& p) {
            switch (p.units()) {
              case Days:
                return std::make_pair(p.length(), p.length());
              case Weeks:
                return std::make_pair(7*p.length(), 7*p.length());
              case Months:
                return std::make_pair(28*p.length(), 31*p.length());
              case Years:
                return std::make_pair(365*p.length(), 366*p.length());
              default:
                QL_FAIL("unknown time unit (" << Integer(p.units()) << ")");
            }
        }

        bool isSubPeriod(const Period& subPeriod,
                         const Period& superPeriod,
                         Integer& numSubPeriods) {

            std::pair<Integer, Integer> superDays(daysMinMax(superPeriod));
            std::pair<Integer, Integer> subDays(daysMinMax(subPeriod));

            //obtain the approximate time ratio
            Real minPeriodRatio =
                ((Real)superDays.first)/((Real)subDays.second);
            Real maxPeriodRatio =
                ((Real)superDays.second)/((Real)subDays.first);
            auto lowRatio = static_cast<Integer>(std::floor(minPeriodRatio));
            auto highRatio = static_cast<Integer>(std::ceil(maxPeriodRatio));

            try {
                for(Integer i=lowRatio; i <= highRatio; ++i) {
                    Period testPeriod = subPeriod * i;
                    if(testPeriod == superPeriod) {
                        numSubPeriods = i;
                        return true;
                    }
                }
            } catch(Error&) {
                return false;
            }

            return false;
        }

    }

    std::vector<Real> sinkingNotionals(const Period& bondLength,
                                       const Frequency& sinkingFrequency,
                                       Rate couponRate,
                                       Real initialNotional) {
        Integer nPeriods;
        QL_REQUIRE(isSubPeriod(Period(sinkingFrequency), bondLength, nPeriods),
                   "Bond frequency is incompatible with the maturity tenor");

        std::vector<Real> notionals(nPeriods+1);
        notionals.front() = initialNotional;
        Real coupon = couponRate / static_cast<Real>(sinkingFrequency);
        Real compoundedInterest = 1.0;
        Real totalValue = std::pow(1.0+coupon, nPeriods);
        for (Size i = 0; i < (Size)nPeriods-1; ++i) {
            compoundedInterest *= (1.0 + coupon);
            Real currentNotional = 0.0;
            if(coupon < 1.0e-12) {
                currentNotional = initialNotional*(1.0 - (i+1.0)/nPeriods);
            } else {
                currentNotional =
                    initialNotional*(compoundedInterest - (compoundedInterest-1.0)/(1.0 - 1.0/totalValue));
            }
            notionals[i+1] = currentNotional;
        }
        notionals.back() = 0.0;

        return notionals;
    }

}
]]></document_content>
  </document>
  <document index="12">
    <source>bonds/amortizingfloatingratebond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Simon Ibbotson

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/bonds/amortizingfloatingratebond.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/time/schedule.hpp>
#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    AmortizingFloatingRateBond::AmortizingFloatingRateBond(
                                    Natural settlementDays,
                                    const std::vector<Real>& notionals,
                                    Schedule schedule,
                                    const ext::shared_ptr<IborIndex>& index,
                                    const DayCounter& paymentDayCounter,
                                    BusinessDayConvention paymentConvention,
                                    Natural fixingDays,
                                    const std::vector<Real>& gearings,
                                    const std::vector<Spread>& spreads,
                                    const std::vector<Rate>& caps,
                                    const std::vector<Rate>& floors,
                                    bool inArrears,
                                    const Date& issueDate,
                                    const Period& exCouponPeriod,
                                    const Calendar& exCouponCalendar,
                                    const BusinessDayConvention exCouponConvention,
                                    bool exCouponEndOfMonth,
                                    const std::vector<Real>& redemptions,
                                    Integer paymentLag)
    : Bond(settlementDays, schedule.calendar(), issueDate) {

        maturityDate_ = schedule.endDate();

        cashflows_ = IborLeg(std::move(schedule), index)
            .withNotionals(notionals)
            .withPaymentDayCounter(paymentDayCounter)
            .withPaymentAdjustment(paymentConvention)
            .withFixingDays(fixingDays)
            .withPaymentLag(paymentLag)
            .withGearings(gearings)
            .withSpreads(spreads)
            .withCaps(caps)
            .withFloors(floors)
            .withExCouponPeriod(exCouponPeriod,
                                exCouponCalendar,
                                exCouponConvention,
                                exCouponEndOfMonth)
            .inArrears(inArrears);

        addRedemptionsToCashflows(redemptions);

        QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");

        registerWith(index);
    }

}
]]></document_content>
  </document>
  <document index="13">
    <source>bonds/btp.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/bonds/btp.hpp>
#include <ql/instruments/makevanillaswap.hpp>
#include <ql/pricingengines/bond/bondfunctions.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/time/schedule.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <utility>

namespace QuantLib {

    CCTEU::CCTEU(const Date& maturityDate,
                 Spread spread,
                 const Handle<YieldTermStructure>& fwdCurve,
                 const Date& startDate,
                 const Date& issueDate)
    : FloatingRateBond(2, 100.0,
                       Schedule(startDate,
                                maturityDate, 6*Months,
                                NullCalendar(), Unadjusted, Unadjusted,
                                DateGeneration::Backward, true),
                       ext::make_shared<Euribor6M>(fwdCurve),
                       Actual360(),
                       Following,
                       Euribor6M().fixingDays(),
                       std::vector<Real>(1, 1.0), // gearing
                       std::vector<Spread>(1, spread),
                       std::vector<Rate>(), // caps
                       std::vector<Rate>(), // floors
                       false, // in arrears
                       100.0, // redemption
                       issueDate) {}

    BTP::BTP(const Date& maturityDate,
             Rate fixedRate,
             const Date& startDate,
             const Date& issueDate)
    : FixedRateBond(2, 100.0,
                    Schedule(startDate,
                             maturityDate, 6*Months,
                             NullCalendar(), Unadjusted, Unadjusted,
                             DateGeneration::Backward, true),
                    std::vector<Rate>(1, fixedRate),
                    ActualActual(ActualActual::ISMA),
                    ModifiedFollowing, 100.0, issueDate, TARGET()) {}

    BTP::BTP(const Date& maturityDate,
             Rate fixedRate,
             Real redemption,
             const Date& startDate,
             const Date& issueDate)
    : FixedRateBond(2, 100.0,
                    Schedule(startDate,
                             maturityDate, 6*Months,
                             NullCalendar(), Unadjusted, Unadjusted,
                             DateGeneration::Backward, true),
                    std::vector<Rate>(1, fixedRate),
                    ActualActual(ActualActual::ISMA),
                    ModifiedFollowing, redemption, issueDate, TARGET()) {}

    Rate BTP::yield(Real cleanPrice,
                    Date settlementDate,
                    Real accuracy,
                    Size maxEvaluations) const {
        return Bond::yield({cleanPrice, Bond::Price::Clean},
                           ActualActual(ActualActual::ISMA), Compounded, Annual, settlementDate,
                           accuracy, maxEvaluations);
    }


    RendistatoBasket::RendistatoBasket(const std::vector<ext::shared_ptr<BTP> >& btps,
                                       const std::vector<Real>& outstandings,
                                       std::vector<Handle<Quote> > cleanPriceQuotes)
    : btps_(btps), outstandings_(outstandings), quotes_(std::move(cleanPriceQuotes)) {

        QL_REQUIRE(!btps_.empty(), "empty RendistatoCalculator Basket");
        Size k = btps_.size();

        QL_REQUIRE(outstandings_.size()==k,
                   "mismatch between number of BTPs (" << k <<
                   ") and number of outstandings (" <<
                   outstandings_.size() << ")");
        QL_REQUIRE(quotes_.size()==k,
                   "mismatch between number of BTPs (" << k <<
                   ") and number of clean prices quotes (" <<
                   quotes_.size() << ")");

        // require non-negative outstanding
        for (Size i=0; i<k; ++i) {
            QL_REQUIRE(outstandings[i]>=0,
                       "negative outstanding for " << io::ordinal(i) <<
                       " bond, maturity " << btps[i]->maturityDate());
            // add check for prices ??
        }

        // TODO: filter out expired bonds, zero outstanding bond, etc

        QL_REQUIRE(!btps_.empty(), "invalid bonds only in RendistatoCalculator Basket");
        n_ = btps_.size();

        outstanding_ = 0.0;
        for (Size i=0; i<n_; ++i)
            outstanding_ += outstandings[i];

        weights_.resize(n_);
        for (Size i=0; i<n_; ++i) {
            weights_[i] = outstandings[i]/outstanding_;
            registerWith(quotes_[i]);
        }
    }


    RendistatoCalculator::RendistatoCalculator(ext::shared_ptr<RendistatoBasket> basket,
                                               ext::shared_ptr<Euribor> euriborIndex,
                                               Handle<YieldTermStructure> discountCurve)
    : basket_(std::move(basket)), euriborIndex_(std::move(euriborIndex)),
      discountCurve_(std::move(discountCurve)), yields_(basket_->size(), 0.05),
      durations_(basket_->size()),
      // TODO: generalize number of swaps and their lengths
      swaps_(nSwaps_), swapLengths_(nSwaps_), swapBondDurations_(nSwaps_, Null<Time>()),
      swapBondYields_(nSwaps_, 0.05), swapRates_(nSwaps_, Null<Rate>()) {
        registerWith(basket_);
        registerWith(euriborIndex_);
        registerWith(discountCurve_);

        Rate dummyRate = 0.05;
        for (Size i=0; i<nSwaps_; ++i) {
            swapLengths_[i] = static_cast<Real>(i+1);
            swaps_[i] = MakeVanillaSwap(
                swapLengths_[i]*Years, euriborIndex_, dummyRate, 1*Days)
                                .withDiscountingTermStructure(discountCurve_);
        }
    }

    void RendistatoCalculator::performCalculations() const {

        const std::vector<ext::shared_ptr<BTP> >& btps = basket_->btps();
        const std::vector<Handle<Quote> >& quotes = basket_->cleanPriceQuotes();
        Date bondSettlementDate = btps[0]->settlementDate();
        for (Size i=0; i<basket_->size(); ++i) {
            yields_[i] = BondFunctions::yield(
                *btps[i], {quotes[i]->value(), Bond::Price::Clean},
                ActualActual(ActualActual::ISMA), Compounded, Annual, bondSettlementDate,
                // accuracy, maxIterations, guess
                1.0e-10, 100, yields_[i]);
            durations_[i] = BondFunctions::duration(
                *btps[i], yields_[i],
                ActualActual(ActualActual::ISMA), Compounded, Annual,
                Duration::Modified, bondSettlementDate);
        }
        duration_ = std::inner_product(basket_->weights().begin(),
                                       basket_->weights().end(),
                                       durations_.begin(), Real(0.0));

        Natural settlDays = 2;
        DayCounter fixedDayCount = swaps_[0]->fixedDayCount();
        equivalentSwapIndex_ = nSwaps_-1;
        swapRates_[0]= swaps_[0]->fairRate();
        FixedRateBond swapBond(settlDays,
                               100.0,      // faceAmount
                               swaps_[0]->fixedSchedule(),
                               std::vector<Rate>(1, swapRates_[0]),
                               fixedDayCount,
                               Following, // paymentConvention
                               100.0);    // redemption
        swapBondYields_[0] = BondFunctions::yield(swapBond,
            {100.0, Bond::Price::Clean}, // floating leg NPV including end payment
            ActualActual(ActualActual::ISMA), Compounded, Annual,
            bondSettlementDate,
            // accuracy, maxIterations, guess
            1.0e-10, 100, swapBondYields_[0]);
        swapBondDurations_[0] = BondFunctions::duration(
            swapBond, swapBondYields_[0],
            ActualActual(ActualActual::ISMA), Compounded, Annual,
            Duration::Modified, bondSettlementDate);
        for (Size i=1; i<nSwaps_; ++i) {
            swapRates_[i]= swaps_[i]->fairRate();
            FixedRateBond swapBond(settlDays,
                                   100.0,      // faceAmount
                                   swaps_[i]->fixedSchedule(),
                                   std::vector<Rate>(1, swapRates_[i]),
                                   fixedDayCount,
                                   Following, // paymentConvention
                                   100.0);    // redemption
            swapBondYields_[i] = BondFunctions::yield(swapBond,
                {100.0, Bond::Price::Clean}, // floating leg NPV including end payment
                ActualActual(ActualActual::ISMA), Compounded, Annual,
                bondSettlementDate,
                // accuracy, maxIterations, guess
                1.0e-10, 100, swapBondYields_[i]);
            swapBondDurations_[i] = BondFunctions::duration(
                swapBond, swapBondYields_[i],
                ActualActual(ActualActual::ISMA), Compounded, Annual,
                Duration::Modified, bondSettlementDate);
            if (swapBondDurations_[i] > duration_) {
                equivalentSwapIndex_ = i-1;
                break; // exit the loop
            }
        }
    }

    RendistatoEquivalentSwapLengthQuote::RendistatoEquivalentSwapLengthQuote(
        ext::shared_ptr<RendistatoCalculator> r)
    : r_(std::move(r)) {}

    bool RendistatoEquivalentSwapLengthQuote::isValid() const {
        try {
            value();
            return true;
        } catch (...) {
            return false;
        }
    }

    RendistatoEquivalentSwapSpreadQuote::RendistatoEquivalentSwapSpreadQuote(
        ext::shared_ptr<RendistatoCalculator> r)
    : r_(std::move(r)) {}

    bool RendistatoEquivalentSwapSpreadQuote::isValid() const {
        try {
            value();
            return true;
        } catch (...) {
            return false;
        }
    }
}
]]></document_content>
  </document>
  <document index="14">
    <source>bonds/cmsratebond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2006, 2007 Chiara Fornarola
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/bonds/cmsratebond.hpp>
#include <ql/cashflows/cmscoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/time/schedule.hpp>

namespace QuantLib {

    CmsRateBond::CmsRateBond(
                           Natural settlementDays,
                           Real faceAmount,
                           Schedule schedule,
                           const ext::shared_ptr<SwapIndex>& index,
                           const DayCounter& paymentDayCounter,
                           BusinessDayConvention paymentConvention,
                           Natural fixingDays,
                           const std::vector<Real>& gearings,
                           const std::vector<Spread>& spreads,
                           const std::vector<Rate>& caps,
                           const std::vector<Rate>& floors,
                           bool inArrears,
                           Real redemption,
                           const Date& issueDate)
    : Bond(settlementDays, schedule.calendar(), issueDate) {

        maturityDate_ = schedule.endDate();

        cashflows_ = CmsLeg(std::move(schedule), index)
            .withNotionals(faceAmount)
            .withPaymentDayCounter(paymentDayCounter)
            .withPaymentAdjustment(paymentConvention)
            .withFixingDays(fixingDays)
            .withGearings(gearings)
            .withSpreads(spreads)
            .withCaps(caps)
            .withFloors(floors)
            .inArrears(inArrears);

        addRedemptionsToCashflows(std::vector<Real>(1, redemption));

        QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");
        QL_ENSURE(redemptions_.size() == 1, "multiple redemptions created");

        registerWith(index);
    }

}
]]></document_content>
  </document>
  <document index="15">
    <source>bonds/convertiblebonds.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2006 Theo Boafo
 Copyright (C) 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/exercise.hpp>
#include <ql/instruments/bonds/convertiblebonds.hpp>
#include <ql/utilities/null_deleter.hpp>
#include <utility>

namespace QuantLib {

    ConvertibleBond::ConvertibleBond(ext::shared_ptr<Exercise> exercise,
                                     Real conversionRatio,
                                     const CallabilitySchedule& callability,
                                     const Date& issueDate,
                                     Natural settlementDays,
                                     const Schedule& schedule,
                                     Real redemption)
    : Bond(settlementDays, schedule.calendar(), issueDate), exercise_(std::move(exercise)),
      conversionRatio_(conversionRatio), callability_(callability), redemption_(redemption) {

        maturityDate_ = schedule.endDate();

        if (!callability.empty()) {
            QL_REQUIRE(callability.back()->date() <= maturityDate_,
                       "last callability date (" << callability.back()->date()
                                                 << ") later than maturity (" << maturityDate_
                                                 << ")");
        }
    }


    ConvertibleZeroCouponBond::ConvertibleZeroCouponBond(const ext::shared_ptr<Exercise>& exercise,
                                                         Real conversionRatio,
                                                         const CallabilitySchedule& callability,
                                                         const Date& issueDate,
                                                         Natural settlementDays,
                                                         const DayCounter& dayCounter,
                                                         const Schedule& schedule,
                                                         Real redemption)
    : ConvertibleBond(exercise,
                      conversionRatio,
                      callability,
                      issueDate,
                      settlementDays,
                      schedule,
                      redemption) {

        cashflows_ = Leg();

        // !!! notional forcibly set to 100
        setSingleRedemption(100.0, redemption, maturityDate_);
    }


    ConvertibleFixedCouponBond::ConvertibleFixedCouponBond(
        const ext::shared_ptr<Exercise>& exercise,
        Real conversionRatio,
        const CallabilitySchedule& callability,
        const Date& issueDate,
        Natural settlementDays,
        const std::vector<Rate>& coupons,
        const DayCounter& dayCounter,
        const Schedule& schedule,
        Real redemption,
        const Period& exCouponPeriod,
        const Calendar& exCouponCalendar,
        const BusinessDayConvention exCouponConvention,
        bool exCouponEndOfMonth)
    : ConvertibleBond(exercise,
                      conversionRatio,
                      callability,
                      issueDate,
                      settlementDays,
                      schedule,
                      redemption) {

        // !!! notional forcibly set to 100
        cashflows_ = FixedRateLeg(schedule)
                         .withNotionals(100.0)
                         .withCouponRates(coupons, dayCounter)
                         .withPaymentAdjustment(schedule.businessDayConvention())
                         .withExCouponPeriod(exCouponPeriod, exCouponCalendar, exCouponConvention,
                                             exCouponEndOfMonth);

        addRedemptionsToCashflows(std::vector<Real>(1, redemption));

        QL_ENSURE(redemptions_.size() == 1, "multiple redemptions created");
    }


    ConvertibleFloatingRateBond::ConvertibleFloatingRateBond(
        const ext::shared_ptr<Exercise>& exercise,
        Real conversionRatio,
        const CallabilitySchedule& callability,
        const Date& issueDate,
        Natural settlementDays,
        const ext::shared_ptr<IborIndex>& index,
        Natural fixingDays,
        const std::vector<Spread>& spreads,
        const DayCounter& dayCounter,
        const Schedule& schedule,
        Real redemption,
        const Period& exCouponPeriod,
        const Calendar& exCouponCalendar,
        const BusinessDayConvention exCouponConvention,
        bool exCouponEndOfMonth)
    : ConvertibleBond(exercise,
                      conversionRatio,
                      callability,
                      issueDate,
                      settlementDays,
                      schedule,
                      redemption) {

        // !!! notional forcibly set to 100
        cashflows_ = IborLeg(schedule, index)
                         .withPaymentDayCounter(dayCounter)
                         .withNotionals(100.0)
                         .withPaymentAdjustment(schedule.businessDayConvention())
                         .withFixingDays(fixingDays)
                         .withSpreads(spreads)
                         .withExCouponPeriod(exCouponPeriod, exCouponCalendar, exCouponConvention,
                                             exCouponEndOfMonth);

        addRedemptionsToCashflows(std::vector<Real>(1, redemption));

        QL_ENSURE(redemptions_.size() == 1, "multiple redemptions created");

        registerWith(index);
    }

    void ConvertibleBond::setupArguments(PricingEngine::arguments* arguments) const {
        auto* args = dynamic_cast<ConvertibleBond::arguments*>(arguments);
        QL_REQUIRE(args != nullptr, "wrong argument type");

        args->exercise = exercise_;
        args->conversionRatio = conversionRatio_;

        Date settlement = settlementDate();

        Size n = callability_.size();
        args->callabilityDates.clear();
        args->callabilityTypes.clear();
        args->callabilityPrices.clear();
        args->callabilityTriggers.clear();
        args->callabilityDates.reserve(n);
        args->callabilityTypes.reserve(n);
        args->callabilityPrices.reserve(n);
        args->callabilityTriggers.reserve(n);
        for (Size i = 0; i < n; i++) {
            if (!callability_[i]->hasOccurred(settlement, false)) {
                args->callabilityTypes.push_back(callability_[i]->type());
                args->callabilityDates.push_back(callability_[i]->date());
                args->callabilityPrices.push_back(callability_[i]->price().amount());
                if (callability_[i]->price().type() == Bond::Price::Clean)
                    args->callabilityPrices.back() +=
                        accruedAmount(callability_[i]->date());
                ext::shared_ptr<SoftCallability> softCall =
                    ext::dynamic_pointer_cast<SoftCallability>(callability_[i]);
                if (softCall != nullptr)
                    args->callabilityTriggers.push_back(softCall->trigger());
                else
                    args->callabilityTriggers.push_back(Null<Real>());
            }
        }

        args->cashflows = cashflows();

        args->issueDate = issueDate_;
        args->settlementDate = settlement;
        args->settlementDays = settlementDays_;
        args->redemption = redemption_;
    }


    void ConvertibleBond::arguments::validate() const {

        QL_REQUIRE(exercise, "no exercise given");
        QL_REQUIRE(conversionRatio != Null<Real>(), "null conversion ratio");
        QL_REQUIRE(conversionRatio > 0.0,
                   "positive conversion ratio required: " << conversionRatio << " not allowed");

        QL_REQUIRE(redemption != Null<Real>(), "null redemption");
        QL_REQUIRE(redemption >= 0.0,
                   "positive redemption required: " << redemption << " not allowed");

        QL_REQUIRE(settlementDate != Date(), "null settlement date");

        QL_REQUIRE(settlementDays != Null<Natural>(), "null settlement days");

        QL_REQUIRE(callabilityDates.size() == callabilityTypes.size(),
                   "different number of callability dates and types");
        QL_REQUIRE(callabilityDates.size() == callabilityPrices.size(),
                   "different number of callability dates and prices");
        QL_REQUIRE(callabilityDates.size() == callabilityTriggers.size(),
                   "different number of callability dates and triggers");

        QL_REQUIRE(!cashflows.empty(), "no cashflows given");
    }

}
]]></document_content>
  </document>
  <document index="16">
    <source>bonds/cpibond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2011 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/cpicoupon.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/indexes/inflationindex.hpp>
#include <ql/instruments/bonds/cpibond.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/time/schedule.hpp>
#include <utility>


namespace QuantLib {

    QL_DEPRECATED_DISABLE_WARNING

    CPIBond::CPIBond(Natural settlementDays,
                     Real faceAmount,
                     Real baseCPI,
                     const Period& observationLag,
                     ext::shared_ptr<ZeroInflationIndex> cpiIndex,
                     CPI::InterpolationType observationInterpolation,
                     Schedule schedule,
                     const std::vector<Rate>& fixedRate,
                     const DayCounter& accrualDayCounter,
                     BusinessDayConvention paymentConvention,
                     const Date& issueDate,
                     const Calendar& paymentCalendar,
                     const Period& exCouponPeriod,
                     const Calendar& exCouponCalendar,
                     const BusinessDayConvention exCouponConvention,
                     bool exCouponEndOfMonth)
    : CPIBond(settlementDays, faceAmount, false, baseCPI, observationLag, std::move(cpiIndex),
              observationInterpolation, std::move(schedule), fixedRate, accrualDayCounter,
              paymentConvention, issueDate, paymentCalendar, exCouponPeriod,
              exCouponCalendar, exCouponConvention, exCouponEndOfMonth) {}

    CPIBond::CPIBond(Natural settlementDays,
                     Real faceAmount,
                     bool growthOnly,
                     Real baseCPI,
                     const Period& observationLag,
                     ext::shared_ptr<ZeroInflationIndex> cpiIndex,
                     CPI::InterpolationType observationInterpolation,
                     Schedule schedule,
                     const std::vector<Rate>& fixedRate,
                     const DayCounter& accrualDayCounter,
                     BusinessDayConvention paymentConvention,
                     const Date& issueDate,
                     const Calendar& paymentCalendar,
                     const Period& exCouponPeriod,
                     const Calendar& exCouponCalendar,
                     const BusinessDayConvention exCouponConvention,
                     bool exCouponEndOfMonth)
    : Bond(settlementDays,
           paymentCalendar == Calendar() ? schedule.calendar() : paymentCalendar,
           issueDate),
      frequency_(schedule.tenor().frequency()), dayCounter_(accrualDayCounter),
      growthOnly_(growthOnly), baseCPI_(baseCPI), observationLag_(observationLag),
      cpiIndex_(std::move(cpiIndex)), observationInterpolation_(observationInterpolation) {

        maturityDate_ = schedule.endDate();

        cashflows_ = CPILeg(std::move(schedule), cpiIndex_,
                            baseCPI_, observationLag_)
            .withNotionals(faceAmount)
            .withFixedRates(fixedRate)
            .withPaymentDayCounter(accrualDayCounter)
            .withPaymentAdjustment(paymentConvention)
            .withPaymentCalendar(calendar_)
            .withObservationInterpolation(observationInterpolation_)
            .withSubtractInflationNominal(growthOnly_)
            .withExCouponPeriod(exCouponPeriod,
                                exCouponCalendar,
                                exCouponConvention,
                                exCouponEndOfMonth);


        calculateNotionalsFromCashflows();

        redemptions_.push_back(cashflows_.back());

        registerWith(cpiIndex_);
        Leg::const_iterator i;
        for (i = cashflows_.begin(); i < cashflows_.end(); ++i) {
            registerWith(*i);
        }
    }

    QL_DEPRECATED_ENABLE_WARNING

}
]]></document_content>
  </document>
  <document index="17">
    <source>bonds/fixedratebond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Jeff Yu
 Copyright (C) 2004 M-Dimension Consulting Inc.
 Copyright (C) 2005, 2006, 2007 StatPro Italia srl
 Copyright (C) 2007, 2008, 2010 Ferdinando Ametrano
 Copyright (C) 2009 Piter Dias

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/bonds/fixedratebond.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/time/schedule.hpp>

namespace QuantLib {

    FixedRateBond::FixedRateBond(Natural settlementDays,
                                 Real faceAmount,
                                 Schedule schedule,
                                 const std::vector<Rate>& coupons,
                                 const DayCounter& accrualDayCounter,
                                 BusinessDayConvention paymentConvention,
                                 Real redemption,
                                 const Date& issueDate,
                                 const Calendar& paymentCalendar,
                                 const Period& exCouponPeriod,
                                 const Calendar& exCouponCalendar,
                                 const BusinessDayConvention exCouponConvention,
                                 bool exCouponEndOfMonth,
                                 const DayCounter& firstPeriodDayCounter)
     : Bond(settlementDays,
            paymentCalendar==Calendar() ? schedule.calendar() : paymentCalendar,
            issueDate),
       frequency_(schedule.hasTenor() ? schedule.tenor().frequency() : NoFrequency),
       dayCounter_(accrualDayCounter),
       firstPeriodDayCounter_(firstPeriodDayCounter) {

        maturityDate_ = schedule.endDate();

        cashflows_ = FixedRateLeg(std::move(schedule))
            .withNotionals(faceAmount)
            .withCouponRates(coupons, accrualDayCounter)
            .withFirstPeriodDayCounter(firstPeriodDayCounter)
            .withPaymentCalendar(calendar_)
            .withPaymentAdjustment(paymentConvention)
            .withExCouponPeriod(exCouponPeriod,
                                exCouponCalendar,
                                exCouponConvention,
                                exCouponEndOfMonth);

        addRedemptionsToCashflows(std::vector<Real>(1, redemption));

        QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");
        QL_ENSURE(redemptions_.size() == 1, "multiple redemptions created");
    }

}
]]></document_content>
  </document>
  <document index="18">
    <source>bonds/floatingratebond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Chiara Fornarola

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/bonds/floatingratebond.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/time/schedule.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    FloatingRateBond::FloatingRateBond(
                           Natural settlementDays,
                           Real faceAmount,
                           Schedule schedule,
                           const ext::shared_ptr<IborIndex>& iborIndex,
                           const DayCounter& paymentDayCounter,
                           BusinessDayConvention paymentConvention,
                           Natural fixingDays,
                           const std::vector<Real>& gearings,
                           const std::vector<Spread>& spreads,
                           const std::vector<Rate>& caps,
                           const std::vector<Rate>& floors,
                           bool inArrears,
                           Real redemption,
                           const Date& issueDate,
                           const Period& exCouponPeriod,
                           const Calendar& exCouponCalendar,
                           const BusinessDayConvention exCouponConvention,
                           bool exCouponEndOfMonth)
    : Bond(settlementDays, schedule.calendar(), issueDate) {

        maturityDate_ = schedule.endDate();

        cashflows_ = IborLeg(std::move(schedule), iborIndex)
            .withNotionals(faceAmount)
            .withPaymentDayCounter(paymentDayCounter)
            .withPaymentAdjustment(paymentConvention)
            .withFixingDays(fixingDays)
            .withGearings(gearings)
            .withSpreads(spreads)
            .withCaps(caps)
            .withFloors(floors)
            .inArrears(inArrears)
            .withExCouponPeriod(exCouponPeriod, exCouponCalendar, exCouponConvention, exCouponEndOfMonth);

        addRedemptionsToCashflows(std::vector<Real>(1, redemption));

        QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");
        QL_ENSURE(redemptions_.size() == 1, "multiple redemptions created");

        registerWith(iborIndex);
    }

}
]]></document_content>
  </document>
  <document index="19">
    <source>bonds/zerocouponbond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2008 StatPro Italia srl
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/bonds/zerocouponbond.hpp>
#include <ql/cashflows/simplecashflow.hpp>

namespace QuantLib {

    ZeroCouponBond::ZeroCouponBond(Natural settlementDays,
                                   const Calendar& calendar,
                                   Real faceAmount,
                                   const Date& maturityDate,
                                   BusinessDayConvention paymentConvention,
                                   Real redemption,
                                   const Date& issueDate)
    : Bond(settlementDays, calendar, issueDate) {

        maturityDate_ = maturityDate;
        Date redemptionDate = calendar_.adjust(maturityDate,
                                               paymentConvention);
        setSingleRedemption(faceAmount, redemption, redemptionDate);
    }

}
]]></document_content>
  </document>
  <document index="20">
    <source>capfloor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2014 Ferdinando Ametrano
 Copyright (C) 2006 Franois du Vignaud
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2006, 2007 StatPro Italia srl
 Copyright (C) 2016 Paolo Mazzocchi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/any.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/instruments/capfloor.hpp>
#include <ql/math/solvers1d/newtonsafe.hpp>
#include <ql/pricingengines/capfloor/bacheliercapfloorengine.hpp>
#include <ql/pricingengines/capfloor/blackcapfloorengine.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        class ImpliedCapVolHelper {
          public:
            ImpliedCapVolHelper(const CapFloor&,
                                Handle<YieldTermStructure> discountCurve,
                                Real targetValue,
                                Real displacement,
                                VolatilityType type);
            Real operator()(Volatility x) const;
            Real derivative(Volatility x) const;
          private:
            ext::shared_ptr<PricingEngine> engine_;
            Handle<YieldTermStructure> discountCurve_;
            Real targetValue_;
            ext::shared_ptr<SimpleQuote> vol_;
            const Instrument::results* results_;
        };

        ImpliedCapVolHelper::ImpliedCapVolHelper(const CapFloor& cap,
                                                 Handle<YieldTermStructure> discountCurve,
                                                 Real targetValue,
                                                 Real displacement,
                                                 VolatilityType type)
        : discountCurve_(std::move(discountCurve)), targetValue_(targetValue),
          vol_(ext::make_shared<SimpleQuote>(-1.0)) {

            // vol_ is set an implausible value, so that calculation is forced
            // at first ImpliedCapVolHelper::operator()(Volatility x) call
            Handle<Quote> h(vol_);

            switch (type) {
            case ShiftedLognormal:
                engine_ = ext::shared_ptr<PricingEngine>(new
                    BlackCapFloorEngine(discountCurve_, h, Actual365Fixed(),
                                                                displacement));
                break;
            case Normal:
                engine_ = ext::shared_ptr<PricingEngine>(new
                    BachelierCapFloorEngine(discountCurve_, h, 
                                                            Actual365Fixed()));
                break;
            default:
                QL_FAIL("unknown VolatilityType (" << type << ")");
                break;
            }

            cap.setupArguments(engine_->getArguments());

            results_ =
                dynamic_cast<const Instrument::results*>(engine_->getResults());
        }

        Real ImpliedCapVolHelper::operator()(Volatility x) const {
            if (x!=vol_->value()) {
                vol_->setValue(x);
                engine_->calculate();
            }
            return results_->value-targetValue_;
        }

        Real ImpliedCapVolHelper::derivative(Volatility x) const {
            if (x!=vol_->value()) {
                vol_->setValue(x);
                engine_->calculate();
            }
            auto vega_ = results_->additionalResults.find("vega");
            QL_REQUIRE(vega_ != results_->additionalResults.end(),
                       "vega not provided");
            return ext::any_cast<Real>(vega_->second);
        }
    }

    std::ostream& operator<<(std::ostream& out,
                             CapFloor::Type t) {
        switch (t) {
          case CapFloor::Cap:
            return out << "Cap";
          case CapFloor::Floor:
            return out << "Floor";
          case CapFloor::Collar:
            return out << "Collar";
          default:
            QL_FAIL("unknown CapFloor::Type (" << Integer(t) << ")");
        }
    }

    CapFloor::CapFloor(CapFloor::Type type,
                       Leg floatingLeg,
                       std::vector<Rate> capRates,
                       std::vector<Rate> floorRates)
    : type_(type), floatingLeg_(std::move(floatingLeg)), capRates_(std::move(capRates)),
      floorRates_(std::move(floorRates)) {
        if (type_ == Cap || type_ == Collar) {
            QL_REQUIRE(!capRates_.empty(), "no cap rates given");
            capRates_.reserve(floatingLeg_.size());
            while (capRates_.size() < floatingLeg_.size())
                capRates_.push_back(capRates_.back());
        }
        if (type_ == Floor || type_ == Collar) {
            QL_REQUIRE(!floorRates_.empty(), "no floor rates given");
            floorRates_.reserve(floatingLeg_.size());
            while (floorRates_.size() < floatingLeg_.size())
                floorRates_.push_back(floorRates_.back());
        }
        Leg::const_iterator i;
        for (i = floatingLeg_.begin(); i != floatingLeg_.end(); ++i)
            registerWith(*i);

        registerWith(Settings::instance().evaluationDate());
    }

    CapFloor::CapFloor(CapFloor::Type type, Leg floatingLeg, const std::vector<Rate>& strikes)
    : type_(type), floatingLeg_(std::move(floatingLeg)) {
        QL_REQUIRE(!strikes.empty(), "no strikes given");
        if (type_ == Cap) {
            capRates_ = strikes;
            capRates_.reserve(floatingLeg_.size());
            while (capRates_.size() < floatingLeg_.size())
                capRates_.push_back(capRates_.back());
        } else if (type_ == Floor) {
            floorRates_ = strikes;
            floorRates_.reserve(floatingLeg_.size());
            while (floorRates_.size() < floatingLeg_.size())
                floorRates_.push_back(floorRates_.back());
        } else
            QL_FAIL("only Cap/Floor types allowed in this constructor");

        Leg::const_iterator i;
        for (i = floatingLeg_.begin(); i != floatingLeg_.end(); ++i)
            registerWith(*i);

        registerWith(Settings::instance().evaluationDate());
    }

    bool CapFloor::isExpired() const {
        for (Size i=floatingLeg_.size(); i>0; --i)
            if (!floatingLeg_[i-1]->hasOccurred())
                return false;
        return true;
    }

    Date CapFloor::startDate() const {
        return CashFlows::startDate(floatingLeg_);
    }

    Date CapFloor::maturityDate() const {
        return CashFlows::maturityDate(floatingLeg_);
    }

    ext::shared_ptr<FloatingRateCoupon>
    CapFloor::lastFloatingRateCoupon() const {
        ext::shared_ptr<CashFlow> lastCF(floatingLeg_.back());
        ext::shared_ptr<FloatingRateCoupon> lastFloatingCoupon =
            ext::dynamic_pointer_cast<FloatingRateCoupon>(lastCF);
        return lastFloatingCoupon;
    }

    ext::shared_ptr<CapFloor> CapFloor::optionlet(const Size i) const {
        QL_REQUIRE(i < floatingLeg().size(),
                   io::ordinal(i+1) << " optionlet does not exist, only " <<
                   floatingLeg().size());
        Leg cf(1, floatingLeg()[i]);

        std::vector<Rate> cap, floor;
        if (type() == Cap || type() == Collar)
            cap.push_back(capRates()[i]);
        if (type() == Floor || type() == Collar)
            floor.push_back(floorRates()[i]);

        return ext::make_shared<CapFloor>(type(), cf, cap, floor);
    }

    void CapFloor::setupArguments(PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<CapFloor::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        Size n = floatingLeg_.size();

        arguments->startDates.resize(n);
        arguments->fixingDates.resize(n);
        arguments->endDates.resize(n);
        arguments->accrualTimes.resize(n);
        arguments->forwards.resize(n);
        arguments->nominals.resize(n);
        arguments->gearings.resize(n);
        arguments->capRates.resize(n);
        arguments->floorRates.resize(n);
        arguments->spreads.resize(n);
        arguments->indexes.resize(n);

        arguments->type = type_;

        Date today = Settings::instance().evaluationDate();

        for (Size i=0; i<n; ++i) {
            ext::shared_ptr<FloatingRateCoupon> coupon =
                ext::dynamic_pointer_cast<FloatingRateCoupon>(
                                                             floatingLeg_[i]);
            QL_REQUIRE(coupon, "non-FloatingRateCoupon given");
            arguments->startDates[i] = coupon->accrualStartDate();
            arguments->fixingDates[i] = coupon->fixingDate();
            arguments->endDates[i] = coupon->date();

            // this is passed explicitly for precision
            arguments->accrualTimes[i] = coupon->accrualPeriod();

            // this is passed explicitly for precision...
            if (arguments->endDates[i] >= today) { // ...but only if needed
                arguments->forwards[i] = coupon->adjustedFixing();
            } else {
                arguments->forwards[i] = Null<Rate>();
            }

            arguments->nominals[i] = coupon->nominal();
            Spread spread = coupon->spread();
            Real gearing = coupon->gearing();
            arguments->gearings[i] = gearing;
            arguments->spreads[i] = spread;

            if (type_ == Cap || type_ == Collar)
                arguments->capRates[i] = (capRates_[i]-spread)/gearing;
            else
                arguments->capRates[i] = Null<Rate>();

            if (type_ == Floor || type_ == Collar)
                arguments->floorRates[i] = (floorRates_[i]-spread)/gearing;
            else
                arguments->floorRates[i] = Null<Rate>();

            arguments->indexes[i] = coupon->index();
        }
    }

    void CapFloor::deepUpdate() {
        for (auto& i : floatingLeg_) {
            i->deepUpdate();
        }
        update();
    }

    void CapFloor::arguments::validate() const {
        QL_REQUIRE(endDates.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of end dates ("
                   << endDates.size() << ")");
        QL_REQUIRE(accrualTimes.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of accrual times ("
                   << accrualTimes.size() << ")");
        QL_REQUIRE(type == CapFloor::Floor ||
                   capRates.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of cap rates ("
                   << capRates.size() << ")");
        QL_REQUIRE(type == CapFloor::Cap ||
                   floorRates.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of floor rates ("
                   << floorRates.size() << ")");
        QL_REQUIRE(gearings.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of gearings ("
                   << gearings.size() << ")");
        QL_REQUIRE(spreads.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of spreads ("
                   << spreads.size() << ")");
        QL_REQUIRE(nominals.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of nominals ("
                   << nominals.size() << ")");
        QL_REQUIRE(forwards.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of forwards ("
                   << forwards.size() << ")");
    }

    Rate CapFloor::atmRate(const YieldTermStructure& discountCurve) const {
        bool includeSettlementDateFlows = false;
        Date settlementDate = discountCurve.referenceDate();
        return CashFlows::atmRate(floatingLeg_, discountCurve,
                                  includeSettlementDateFlows,
                                  settlementDate);
    }

    Volatility CapFloor::impliedVolatility(Real targetValue,
                                           const Handle<YieldTermStructure>& d,
                                           Volatility guess,
                                           Real accuracy,
                                           Natural maxEvaluations,
                                           Volatility minVol,
                                           Volatility maxVol,
                                           VolatilityType type,
                                           Real displacement) const {
        //calculate();
        QL_REQUIRE(!isExpired(), "instrument expired");

        ImpliedCapVolHelper f(*this, d, targetValue, displacement, type);
        //Brent solver;
        NewtonSafe solver;
        solver.setMaxEvaluations(maxEvaluations);
        return solver.solve(f, accuracy, guess, minVol, maxVol);
    }

}
]]></document_content>
  </document>
  <document index="21">
    <source>claim.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/claim.hpp>

namespace QuantLib {

    Real FaceValueClaim::amount(const Date&,
                                Real notional,
                                Real recoveryRate) const {
        return notional * (1.0-recoveryRate);
    }



    FaceValueAccrualClaim::FaceValueAccrualClaim(
                          const ext::shared_ptr<Bond>& referenceSecurity)
    : referenceSecurity_(referenceSecurity) {
        registerWith(referenceSecurity);
    }

    Real FaceValueAccrualClaim::amount(const Date& d,
                                       Real notional,
                                       Real recoveryRate) const {
        Real accrual = referenceSecurity_->accruedAmount(d)
                     / referenceSecurity_->notional(d);
        return notional * (1.0-recoveryRate-accrual);
    }

}

]]></document_content>
  </document>
  <document index="22">
    <source>cliquetoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/instruments/cliquetoption.hpp>
#include <utility>

namespace QuantLib {

    CliquetOption::CliquetOption(const ext::shared_ptr<PercentageStrikePayoff>& payoff,
                                 const ext::shared_ptr<EuropeanExercise>& maturity,
                                 std::vector<Date> resetDates)
    : OneAssetOption(payoff, maturity), resetDates_(std::move(resetDates)) {}

    void CliquetOption::setupArguments(PricingEngine::arguments* args) const {
        OneAssetOption::setupArguments(args);
        // set accrued coupon, last fixing, caps, floors
        auto* moreArgs = dynamic_cast<CliquetOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong engine type");
        moreArgs->resetDates = resetDates_;
    }

    void CliquetOption::arguments::validate() const {
        OneAssetOption::arguments::validate();

        ext::shared_ptr<PercentageStrikePayoff> moneyness =
            ext::dynamic_pointer_cast<PercentageStrikePayoff>(payoff);
        QL_REQUIRE(moneyness,
                   "wrong payoff type");
        QL_REQUIRE(moneyness->strike() > 0.0,
                   "negative or zero moneyness given");
        QL_REQUIRE(accruedCoupon == Null<Real>() || accruedCoupon >= 0.0,
                   "negative accrued coupon");
        QL_REQUIRE(localCap == Null<Real>() || localCap >= 0.0,
                   "negative local cap");
        QL_REQUIRE(localFloor == Null<Real>() || localFloor >= 0.0,
                   "negative local floor");
        QL_REQUIRE(globalCap == Null<Real>() || globalCap >= 0.0,
                   "negative global cap");
        QL_REQUIRE(globalFloor == Null<Real>() || globalFloor >= 0.0,
                   "negative global floor");
        QL_REQUIRE(!resetDates.empty(),
                   "no reset dates given");
        for (Size i=0; i<resetDates.size(); ++i) {
            QL_REQUIRE(exercise->lastDate() > resetDates[i],
                       "reset date greater or equal to maturity");
            QL_REQUIRE(i == 0 || resetDates[i] > resetDates[i-1],
                       "unsorted reset dates");
        }
    }

}
]]></document_content>
  </document>
  <document index="23">
    <source>complexchooseroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/complexchooseroption.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/exercise.hpp>
#include <utility>

namespace QuantLib {

    ComplexChooserOption::ComplexChooserOption(
        Date choosingDate,
        Real strikeCall,
        Real strikePut,
        const ext::shared_ptr<Exercise>& exerciseCall,
        ext::shared_ptr<Exercise>  exercisePut)
    : OneAssetOption(ext::make_shared<PlainVanillaPayoff>(Option::Call, strikeCall),
                     exerciseCall),
      choosingDate_(choosingDate),
      strikeCall_(strikeCall),
      strikePut_(strikePut),
      exerciseCall_(exerciseCall),
      exercisePut_(std::move(exercisePut)) {}

    void ComplexChooserOption::setupArguments(PricingEngine::arguments* args) const {
        OneAssetOption::setupArguments(args);
        auto* moreArgs = dynamic_cast<ComplexChooserOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->choosingDate=choosingDate_;
        moreArgs->strikeCall=strikeCall_;
        moreArgs->strikePut=strikePut_;
        moreArgs->exerciseCall = exerciseCall_;
        moreArgs->exercisePut = exercisePut_;
    }

    void ComplexChooserOption::arguments::validate() const {
        OneAssetOption::arguments::validate();
        QL_REQUIRE(choosingDate != Date() , " no choosing date given");
        QL_REQUIRE(choosingDate < exerciseCall->lastDate(),
                   "choosing date later than or equal to Call maturity date");
        QL_REQUIRE(choosingDate < exercisePut->lastDate(),
                   "choosing date later than or equal to Put maturity date");
    }

}
]]></document_content>
  </document>
  <document index="24">
    <source>compositeinstrument.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/compositeinstrument.hpp>

namespace QuantLib {

    void CompositeInstrument::add(const ext::shared_ptr<Instrument>& instrument, Real multiplier) {
        QL_REQUIRE(instrument, "null instrument provided");
        components_.emplace_back(instrument, multiplier);
        registerWith(instrument);
        update();
        // When we ask for the NPV of an expired composite, the
        // components are not recalculated and thus wouldn't forward
        // later notifications according to the default behavior of
        // LazyObject instances.  This means that even if the
        // evaluation date changes so that the composite is no longer
        // expired, the instrument wouldn't be notified and thus it
        // wouldn't recalculate.  To avoid this, we override the
        // default behavior of the components.
        instrument->alwaysForwardNotifications();
    }

    void CompositeInstrument::subtract(
           const ext::shared_ptr<Instrument>& instrument, Real multiplier) {
        add(instrument, -multiplier);
    }

    bool CompositeInstrument::isExpired() const {
        for (const auto& component : components_) {
            if (!component.first->isExpired())
                return false;
        }
        return true;
    }

    void CompositeInstrument::performCalculations() const {
        NPV_ = 0.0;
        for (const auto& component : components_) {
            NPV_ += component.second * component.first->NPV();
        }
    }

    void CompositeInstrument::deepUpdate() {
        for (auto & component : components_) {
            component.first->deepUpdate();
        }
        update();
    }

}

]]></document_content>
  </document>
  <document index="25">
    <source>compoundoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/compoundoption.hpp>
#include <utility>

namespace QuantLib {

    CompoundOption::CompoundOption(const ext::shared_ptr<StrikedTypePayoff>& motherPayoff,
                                   const ext::shared_ptr<Exercise>& motherExercise,
                                   ext::shared_ptr<StrikedTypePayoff> daughterPayoff,
                                   ext::shared_ptr<Exercise> daughterExercise)
    : OneAssetOption(motherPayoff, motherExercise), daughterPayoff_(std::move(daughterPayoff)),
      daughterExercise_(std::move(daughterExercise)) {}

    void CompoundOption::setupArguments(PricingEngine::arguments* args) const {
        OneAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<CompoundOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->daughterPayoff = daughterPayoff_;
        moreArgs->daughterExercise = daughterExercise_;
    }

    void CompoundOption::arguments::validate() const {
        OneAssetOption::arguments::validate();
        QL_REQUIRE(daughterPayoff,
                   "no payoff given for underlying option");
        QL_REQUIRE(daughterExercise,
                   "no exercise given for underlying option");
        QL_REQUIRE(exercise->lastDate() <= daughterExercise->lastDate(),
                   "maturity of compound option exceeds "
                   "maturity of underlying option");
    }

}
]]></document_content>
  </document>
  <document index="26">
    <source>cpicapfloor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2011 Chris Kenyon
 Copyright (C) 2021 Ralf Konrad Eckel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */


#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/indexes/inflationindex.hpp>
#include <ql/instruments/cpicapfloor.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/time/schedule.hpp>
#include <utility>


namespace QuantLib {

    CPICapFloor::CPICapFloor(Option::Type type,
                             Real nominal,
                             const Date& startDate, // start date of contract (only)
                             Real baseCPI,
                             const Date& maturity, // this is pre-adjustment!
                             Calendar fixCalendar,
                             BusinessDayConvention fixConvention,
                             Calendar payCalendar,
                             BusinessDayConvention payConvention,
                             Rate strike,
                             ext::shared_ptr<ZeroInflationIndex>  index,
                             const Period& observationLag,
                             CPI::InterpolationType observationInterpolation)
    : type_(type), nominal_(nominal), startDate_(startDate), baseCPI_(baseCPI), maturity_(maturity),
      fixCalendar_(std::move(fixCalendar)), fixConvention_(fixConvention),
      payCalendar_(std::move(payCalendar)), payConvention_(payConvention), strike_(strike),
      index_(std::move(index)), observationLag_(observationLag),
      observationInterpolation_(observationInterpolation) {
        QL_REQUIRE(index_, "no inflation index passed");
        QL_REQUIRE(fixCalendar_ != Calendar(), "no fixing calendar passed");
        QL_REQUIRE(payCalendar_ != Calendar(), "no payment calendar passed");

        if (!detail::CPI::isInterpolated(observationInterpolation_)) {
            QL_REQUIRE(observationLag_ >= index_->availabilityLag(),
                       "CPIcapfloor's observationLag must be at least availabilityLag of inflation index: "
                       <<"when the observation is effectively flat"
                       << observationLag_ << " vs " << index_->availabilityLag());
        } else {
            QL_REQUIRE(observationLag_ > index_->availabilityLag(),
                       "CPIcapfloor's observationLag must be greater than availabilityLag of inflation index: "
                       <<"when the observation is effectively linear"
                       << observationLag_ << " vs " << index_->availabilityLag());
        }
    }


    // when you fix - but remember that there is an observation interpolation factor as well
    Date CPICapFloor::fixingDate() const {
        return fixCalendar_.adjust(maturity_ - observationLag_, fixConvention_);
    }


    Date CPICapFloor::payDate() const {
        return payCalendar_.adjust(maturity_, payConvention_);
    }


    bool CPICapFloor::isExpired() const {
        return (Settings::instance().evaluationDate() > maturity_);
    }


    void CPICapFloor::arguments::validate() const {
        // nothing yet
    }


    void CPICapFloor::setupArguments(PricingEngine::arguments* args) const {

        // correct PricingEngine?
        auto* arguments = dynamic_cast<CPICapFloor::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type, not CPICapFloor::arguments*");

        // data move
        arguments->type = type_;
        arguments->nominal = nominal_;
        arguments->startDate = startDate_;
        arguments->baseCPI = baseCPI_;
        arguments->maturity = maturity_;
        arguments->fixCalendar = fixCalendar_;
        arguments->fixConvention = fixConvention_;
        arguments->payCalendar = payCalendar_;
        arguments->payConvention = payConvention_;
        arguments->fixDate = fixingDate();
        arguments->payDate = payDate();
        arguments->strike = strike_;
        arguments->index = index_;
        arguments->observationLag = observationLag_;
        arguments->observationInterpolation = observationInterpolation_;
    }

}
]]></document_content>
  </document>
  <document index="27">
    <source>cpiswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009, 2011 Chris Kenyon
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/cpicoupon.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/indexes/inflationindex.hpp>
#include <ql/instruments/cpiswap.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/time/schedule.hpp>
#include <utility>

namespace QuantLib {

    // accrual adjustment is already in the schedules, as are calendars
    CPISwap::CPISwap(Type type,
                     Real nominal,
                     bool subtractInflationNominal,
                     // float + spread leg
                     Spread spread,
                     DayCounter floatDayCount,
                     Schedule floatSchedule,
                     const BusinessDayConvention& floatPaymentRoll,
                     Natural fixingDays,
                     ext::shared_ptr<IborIndex> floatIndex,
                     // fixed x inflation leg
                     Rate fixedRate,
                     Real baseCPI,
                     DayCounter fixedDayCount,
                     Schedule fixedSchedule,
                     const BusinessDayConvention& fixedPaymentRoll,
                     const Period& observationLag,
                     ext::shared_ptr<ZeroInflationIndex> fixedIndex,
                     CPI::InterpolationType observationInterpolation,
                     Real inflationNominal)
    : Swap(2), type_(type), nominal_(nominal), subtractInflationNominal_(subtractInflationNominal),
      spread_(spread), floatDayCount_(std::move(floatDayCount)),
      floatSchedule_(std::move(floatSchedule)), floatPaymentRoll_(floatPaymentRoll),
      fixingDays_(fixingDays), floatIndex_(std::move(floatIndex)), fixedRate_(fixedRate),
      baseCPI_(baseCPI), fixedDayCount_(std::move(fixedDayCount)),
      fixedSchedule_(std::move(fixedSchedule)), fixedPaymentRoll_(fixedPaymentRoll),
      fixedIndex_(std::move(fixedIndex)), observationLag_(observationLag),
      observationInterpolation_(observationInterpolation) {
        QL_REQUIRE(!floatSchedule_.empty(), "empty float schedule");
        QL_REQUIRE(!fixedSchedule_.empty(), "empty fixed schedule");
        // \todo if roll!=unadjusted then need calendars ...

        if (inflationNominal==Null<Real>()) inflationNominal_ = nominal_;
        else inflationNominal_ = inflationNominal;

        Leg floatingLeg;
        if (floatSchedule_.size() > 1) {
            floatingLeg = IborLeg(floatSchedule_, floatIndex_)
            .withNotionals(nominal_)
            .withSpreads(spread_)
            .withPaymentDayCounter(floatDayCount_)
            .withPaymentAdjustment(floatPaymentRoll_)
            .withFixingDays(fixingDays_);
        }

        if (floatSchedule_.size()==1 ||
            !subtractInflationNominal_ ||
            (subtractInflationNominal && std::fabs(nominal_-inflationNominal_)>0.00001)
            )
        {
            Date payNotional;
            if (floatSchedule_.size()==1) { // no coupons
                payNotional = floatSchedule_[0];
                payNotional = floatSchedule_.calendar().adjust(payNotional, floatPaymentRoll_);
            } else { // use the pay date of the last coupon
                payNotional = floatingLeg.back()->date();
            }

            Real floatAmount = subtractInflationNominal_ ? nominal_ - inflationNominal_ : nominal_;
            ext::shared_ptr<CashFlow> nf(new SimpleCashFlow(floatAmount, payNotional));
            floatingLeg.push_back(nf);
        }

        // a CPIleg know about zero legs and inclusion of base inflation notional
        Leg cpiLeg = CPILeg(fixedSchedule_, fixedIndex_,
                            baseCPI_, observationLag_)
        .withNotionals(inflationNominal_)
        .withFixedRates(fixedRate_)
        .withPaymentDayCounter(fixedDayCount_)
        .withPaymentAdjustment(fixedPaymentRoll_)
        .withObservationInterpolation(observationInterpolation_)
        .withSubtractInflationNominal(subtractInflationNominal_);


        Leg::const_iterator i;
        for (i = cpiLeg.begin(); i < cpiLeg.end(); ++i) {
            registerWith(*i);
        }

        for (i = floatingLeg.begin(); i < floatingLeg.end(); ++i) {
            registerWith(*i);
        }

        legs_[0] = cpiLeg;
        legs_[1] = floatingLeg;

        if (type_==Payer) {
            payer_[0] = 1.0;
            payer_[1] = -1.0;
        } else {
            payer_[0] = -1.0;
            payer_[1] = 1.0;
        }
    }


    //! for simple case sufficient to copy base class
    void CPISwap::setupArguments(PricingEngine::arguments* args) const {

        Swap::setupArguments(args);

        auto* arguments = dynamic_cast<CPISwap::arguments*>(args);

        if (arguments == nullptr)
            return; // it's a swap engine...
    }


    Rate CPISwap::fairRate() const {
        calculate();
        QL_REQUIRE(fairRate_ != Null<Rate>(), "result not available");
        return fairRate_;
    }

    Spread CPISwap::fairSpread() const {
        calculate();
        QL_REQUIRE(fairSpread_ != Null<Spread>(), "result not available");
        return fairSpread_;
    }


    Real CPISwap::fixedLegNPV() const {//FIXME
        calculate();
        QL_REQUIRE(legNPV_[0] != Null<Real>(), "result not available");
        return legNPV_[0];
    }

    Real CPISwap::floatLegNPV() const {//FIXME
        calculate();
        QL_REQUIRE(legNPV_[1] != Null<Real>(), "result not available");
        return legNPV_[1];
    }

    void CPISwap::setupExpired() const {
        Swap::setupExpired();
        legBPS_[0] = legBPS_[1] = 0.0;
        fairRate_ = Null<Rate>();
        fairSpread_ = Null<Spread>();
    }

    void CPISwap::fetchResults(const PricingEngine::results* r) const {
        static const Spread basisPoint = 1.0e-4;

        // copy from VanillaSwap
        // works because similarly simple instrument
        // that we always expect to be priced with a swap engine

        Swap::fetchResults(r);

        const auto* results = dynamic_cast<const CPISwap::results*>(r);
        if (results != nullptr) { // might be a swap engine, so no error is thrown
            fairRate_ = results->fairRate;
            fairSpread_ = results->fairSpread;
        } else {
            fairRate_ = Null<Rate>();
            fairSpread_ = Null<Spread>();
        }

        if (fairRate_ == Null<Rate>()) {
            // calculate it from other results
            if (legBPS_[0] != Null<Real>())
                fairRate_ = fixedRate_ - NPV_/(legBPS_[0]/basisPoint);
        }
        if (fairSpread_ == Null<Spread>()) {
            // ditto
            if (legBPS_[1] != Null<Real>())
                fairSpread_ = spread_ - NPV_/(legBPS_[1]/basisPoint);
        }

    }

    void CPISwap::arguments::validate() const {
        Swap::arguments::validate();
    }

    void CPISwap::results::reset() {
        Swap::results::reset();
        fairRate = Null<Rate>();
        fairSpread = Null<Spread>();
    }

}

]]></document_content>
  </document>
  <document index="28">
    <source>creditdefaultswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 Jose Aparicio
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/instruments/claim.hpp>
#include <ql/instruments/creditdefaultswap.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/pricingengines/credit/isdacdsengine.hpp>
#include <ql/pricingengines/credit/midpointcdsengine.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/credit/flathazardrate.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/time/calendars/weekendsonly.hpp>
#include <ql/time/schedule.hpp>
#include <ql/optional.hpp>
#include <utility>

namespace QuantLib {

    CreditDefaultSwap::CreditDefaultSwap(Protection::Side side,
                                         Real notional,
                                         Rate spread,
                                         const Schedule& schedule,
                                         BusinessDayConvention convention,
                                         const DayCounter& dayCounter,
                                         bool settlesAccrual,
                                         bool paysAtDefaultTime,
                                         const Date& protectionStart,
                                         ext::shared_ptr<Claim> claim,
                                         const DayCounter& lastPeriodDayCounter,
                                         const bool rebatesAccrual,
                                         const Date& tradeDate,
                                         Natural cashSettlementDays)
    : side_(side), notional_(notional), upfront_(ext::nullopt), runningSpread_(spread),
      settlesAccrual_(settlesAccrual), paysAtDefaultTime_(paysAtDefaultTime),
      claim_(std::move(claim)),
      protectionStart_(protectionStart == Date() ? schedule[0] : protectionStart),
      tradeDate_(tradeDate), cashSettlementDays_(cashSettlementDays) {

        init(schedule, convention, dayCounter, lastPeriodDayCounter, rebatesAccrual);
    }

    CreditDefaultSwap::CreditDefaultSwap(Protection::Side side,
                                         Real notional,
                                         Rate upfront,
                                         Rate runningSpread,
                                         const Schedule& schedule,
                                         BusinessDayConvention convention,
                                         const DayCounter& dayCounter,
                                         bool settlesAccrual,
                                         bool paysAtDefaultTime,
                                         const Date& protectionStart,
                                         const Date& upfrontDate,
                                         ext::shared_ptr<Claim> claim,
                                         const DayCounter& lastPeriodDayCounter,
                                         const bool rebatesAccrual,
                                         const Date& tradeDate,
                                         Natural cashSettlementDays)
    : side_(side), notional_(notional), upfront_(upfront), runningSpread_(runningSpread),
      settlesAccrual_(settlesAccrual), paysAtDefaultTime_(paysAtDefaultTime),
      claim_(std::move(claim)),
      protectionStart_(protectionStart == Date() ? schedule[0] : protectionStart),
      tradeDate_(tradeDate), cashSettlementDays_(cashSettlementDays) {

        init(schedule, convention, dayCounter, lastPeriodDayCounter, rebatesAccrual, upfrontDate);
    }

    void CreditDefaultSwap::init(const Schedule& schedule, BusinessDayConvention paymentConvention,
                                 const DayCounter& dayCounter, const DayCounter& lastPeriodDayCounter,
                                 bool rebatesAccrual, const Date& upfrontDate) {

        QL_REQUIRE(!schedule.empty(), "CreditDefaultSwap needs a non-empty schedule.");

        bool postBigBang = false;
        if (schedule.hasRule()) {
            DateGeneration::Rule rule = schedule.rule();
            postBigBang = rule == DateGeneration::CDS || rule == DateGeneration::CDS2015;
        }

        if (!postBigBang) {
            QL_REQUIRE(protectionStart_ <= schedule[0], "protection can not start after accrual");
        }

        leg_ = FixedRateLeg(schedule)
            .withNotionals(notional_)
            .withCouponRates(runningSpread_, dayCounter)
            .withPaymentAdjustment(paymentConvention)
            .withLastPeriodDayCounter(lastPeriodDayCounter);

        // Deduce the trade date if not given.
        if (tradeDate_ == Date()) {
            if (postBigBang) {
                tradeDate_ = protectionStart_;
            } else {
                tradeDate_ = protectionStart_ - 1;
            }
        }

        // Deduce the cash settlement date if not given.
        Date effectiveUpfrontDate = upfrontDate;
        if (effectiveUpfrontDate == Date()) {
            effectiveUpfrontDate = schedule.calendar().advance(tradeDate_,
                cashSettlementDays_, Days, paymentConvention);
        }
        QL_REQUIRE(effectiveUpfrontDate >= protectionStart_,
                   "The cash settlement date must not be before the protection start date.");

        // Create the upfront payment, if one is provided.
        Real upfrontAmount = 0.0;
        if (upfront_) // NOLINT(readability-implicit-bool-conversion)
            upfrontAmount = *upfront_ * notional_;
        upfrontPayment_ = ext::make_shared<SimpleCashFlow>(upfrontAmount, effectiveUpfrontDate);

        // Set the maturity date.
        maturity_ = schedule.dates().back();

        // Deal with the accrual rebate. We use the standard conventions for accrual calculation introduced with the 
        // CDS Big Bang in 2009.
        if (rebatesAccrual) {

            Real rebateAmount = 0.0;
            Date refDate = tradeDate_ + 1;

            if (tradeDate_ >= schedule.dates().front()) {
                for (Size i = 0; i < leg_.size(); ++i) {
                    const ext::shared_ptr<CashFlow>& cf = leg_[i];
                    if (refDate > cf->date()) {
                        // This coupon is in the past; check the next one
                        continue;
                    } else if (refDate == cf->date()) {
                        // This coupon pays at the reference date.
                        // If it's not the last coupon, the accrual is 0 so do nothing.
                        if (i < leg_.size() - 1)
                            rebateAmount = 0.0;
                        else {
                            // On last coupon
                            ext::shared_ptr<FixedRateCoupon> frc = ext::dynamic_pointer_cast<FixedRateCoupon>(cf);
                            rebateAmount = frc->amount();
                        }
                        break;
                    } else {
                        // This coupon pays in the future, and is the first coupon to do so (since they're sorted).
                        // Calculate the accrual and skip further coupons
                        ext::shared_ptr<FixedRateCoupon> frc = ext::dynamic_pointer_cast<FixedRateCoupon>(cf);
                        rebateAmount = frc->accruedAmount(refDate);
                        break;
                    }
                }
            }

            accrualRebate_ = ext::make_shared<SimpleCashFlow>(rebateAmount, effectiveUpfrontDate);
        }

        if (!claim_)
            claim_ = ext::make_shared<FaceValueClaim>();
        registerWith(claim_);
    }

    Protection::Side CreditDefaultSwap::side() const {
        return side_;
    }

    Real CreditDefaultSwap::notional() const {
        return notional_;
    }

    Rate CreditDefaultSwap::runningSpread() const {
        return runningSpread_;
    }

    ext::optional<Rate> CreditDefaultSwap::upfront() const {
        return upfront_;
    }

    bool CreditDefaultSwap::settlesAccrual() const {
        return settlesAccrual_;
    }

    bool CreditDefaultSwap::paysAtDefaultTime() const {
        return paysAtDefaultTime_;
    }

    const Leg& CreditDefaultSwap::coupons() const {
        return leg_;
    }


    bool CreditDefaultSwap::isExpired() const {
        for (auto i = leg_.rbegin(); i != leg_.rend(); ++i) {
            if (!(*i)->hasOccurred())
                return false;
        }
        return true;
    }

    void CreditDefaultSwap::setupExpired() const {
        Instrument::setupExpired();
        fairSpread_ = fairUpfront_ = 0.0;
        couponLegBPS_ = upfrontBPS_ = 0.0;
        couponLegNPV_ = defaultLegNPV_ = upfrontNPV_ = 0.0;
    }

    void CreditDefaultSwap::setupArguments(
                                       PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<CreditDefaultSwap::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->side = side_;
        arguments->notional = notional_;
        arguments->leg = leg_;
        arguments->upfrontPayment = upfrontPayment_;
        arguments->accrualRebate = accrualRebate_;
        arguments->settlesAccrual = settlesAccrual_;
        arguments->paysAtDefaultTime = paysAtDefaultTime_;
        arguments->claim = claim_;
        arguments->upfront = upfront_;
        arguments->spread = runningSpread_;
        arguments->protectionStart = protectionStart_;
        arguments->maturity = maturity_;
    }


    void CreditDefaultSwap::fetchResults(
                                      const PricingEngine::results* r) const {
        Instrument::fetchResults(r);

        const auto* results = dynamic_cast<const CreditDefaultSwap::results*>(r);
        QL_REQUIRE(results != nullptr, "wrong result type");

        fairSpread_ = results->fairSpread;
        fairUpfront_ = results->fairUpfront;
        couponLegBPS_ = results->couponLegBPS;
        couponLegNPV_ = results->couponLegNPV;
        defaultLegNPV_ = results->defaultLegNPV;
        upfrontNPV_ = results->upfrontNPV;
        upfrontBPS_ = results->upfrontBPS;
        accrualRebateNPV_ = results->accrualRebateNPV;
    }

    Rate CreditDefaultSwap::fairUpfront() const {
        calculate();
        QL_REQUIRE(fairUpfront_ != Null<Rate>(),
                   "fair upfront not available");
        return fairUpfront_;
    }

    Rate CreditDefaultSwap::fairSpread() const {
        calculate();
        QL_REQUIRE(fairSpread_ != Null<Rate>(),
                   "fair spread not available");
        return fairSpread_;
    }

    Real CreditDefaultSwap::couponLegBPS() const {
        calculate();
        QL_REQUIRE(couponLegBPS_ != Null<Rate>(),
                   "coupon-leg BPS not available");
        return couponLegBPS_;
    }

    Real CreditDefaultSwap::couponLegNPV() const {
        calculate();
        QL_REQUIRE(couponLegNPV_ != Null<Rate>(),
                   "coupon-leg NPV not available");
        return couponLegNPV_;
    }

    Real CreditDefaultSwap::defaultLegNPV() const {
        calculate();
        QL_REQUIRE(defaultLegNPV_ != Null<Rate>(),
                   "default-leg NPV not available");
        return defaultLegNPV_;
    }

    Real CreditDefaultSwap::upfrontNPV() const {
        calculate();
        QL_REQUIRE(upfrontNPV_ != Null<Real>(),
                   "upfront NPV not available");
        return upfrontNPV_;
    }

    Real CreditDefaultSwap::upfrontBPS() const {
        calculate();
        QL_REQUIRE(upfrontBPS_ != Null<Real>(),
                   "upfront BPS not available");
        return upfrontBPS_;
    }

    Real CreditDefaultSwap::accrualRebateNPV() const {
        calculate();
        QL_REQUIRE(accrualRebateNPV_ != Null<Real>(),
                   "accrual Rebate NPV not available");
        return accrualRebateNPV_;
    }

    namespace {

        class ObjectiveFunction {
          public:
            ObjectiveFunction(Real target,
                              SimpleQuote& quote,
                              PricingEngine& engine,
                              const CreditDefaultSwap::results* results)
            : target_(target), quote_(quote),
              engine_(engine), results_(results) {}

            Real operator()(Real guess) const {
                quote_.setValue(guess);
                engine_.calculate();
                return results_->value - target_;
            }
          private:
            Real target_;
            SimpleQuote& quote_;
            PricingEngine& engine_;
            const CreditDefaultSwap::results* results_;
        };

    }

    Rate CreditDefaultSwap::impliedHazardRate(
                               Real targetNPV,
                               const Handle<YieldTermStructure>& discountCurve,
                               const DayCounter& dayCounter,
                               Real recoveryRate,
                               Real accuracy,
                               PricingModel model) const {

        ext::shared_ptr<SimpleQuote> flatRate = ext::make_shared<SimpleQuote>(0.0);

        Handle<DefaultProbabilityTermStructure> probability =
            Handle<DefaultProbabilityTermStructure>(
                ext::make_shared<FlatHazardRate>(0, WeekendsOnly(),
                                                   Handle<Quote>(flatRate), dayCounter));

        ext::shared_ptr<PricingEngine> engine;
        switch (model) {
          case Midpoint:
            engine = ext::make_shared<MidPointCdsEngine>(
                probability, recoveryRate, discountCurve);
            break;
          case ISDA:
            engine = ext::make_shared<IsdaCdsEngine>(
                probability, recoveryRate, discountCurve,
                ext::nullopt,
                IsdaCdsEngine::Taylor,
                IsdaCdsEngine::HalfDayBias,
                IsdaCdsEngine::Piecewise);
            break;
          default:
            QL_FAIL("unknown CDS pricing model: " << model);
        }

        setupArguments(engine->getArguments());
        const auto* results = dynamic_cast<const CreditDefaultSwap::results*>(engine->getResults());

        ObjectiveFunction f(targetNPV, *flatRate, *engine, results);
        //very close guess if targetNPV = 0.
        Rate guess = runningSpread_ / (1 - recoveryRate) * 365./360.;
        Real step = 0.1 * guess;
        return Brent().solve(f, accuracy, guess, step);
    }

    Rate CreditDefaultSwap::conventionalSpread(
                              Real conventionalRecovery,
                              const Handle<YieldTermStructure>& discountCurve,
                              const DayCounter& dayCounter,
                              PricingModel model) const {

        ext::shared_ptr<SimpleQuote> flatRate = ext::make_shared<SimpleQuote>(0.0);

        Handle<DefaultProbabilityTermStructure> probability =
            Handle<DefaultProbabilityTermStructure>(
                ext::make_shared<FlatHazardRate>(0, WeekendsOnly(),
                                                   Handle<Quote>(flatRate), dayCounter));

        ext::shared_ptr<PricingEngine> engine;
        switch (model) {
          case Midpoint:
            engine = ext::make_shared<MidPointCdsEngine>(
                probability, conventionalRecovery, discountCurve);
            break;
          case ISDA:
            engine = ext::make_shared<IsdaCdsEngine>(
                probability, conventionalRecovery, discountCurve,
                ext::nullopt,
                IsdaCdsEngine::Taylor,
                IsdaCdsEngine::HalfDayBias,
                IsdaCdsEngine::Piecewise);
            break;
          default:
            QL_FAIL("unknown CDS pricing model: " << model);
        }

        setupArguments(engine->getArguments());
        const auto* results = dynamic_cast<const CreditDefaultSwap::results*>(engine->getResults());

        ObjectiveFunction f(0., *flatRate, *engine, results);
        Rate guess = runningSpread_ / (1 - conventionalRecovery) * 365./360.;
        Real step = guess * 0.1;

        Brent().solve(f, 1e-9, guess, step);
        return results->fairSpread;
    }


    const Date& CreditDefaultSwap::protectionStartDate() const {
        return protectionStart_;
    }

    const Date& CreditDefaultSwap::protectionEndDate() const {
        return ext::dynamic_pointer_cast<Coupon>(leg_.back())
            ->accrualEndDate();
    }

    const ext::shared_ptr<SimpleCashFlow>& CreditDefaultSwap::upfrontPayment() const {
        return upfrontPayment_;
    }

    const ext::shared_ptr<SimpleCashFlow>& CreditDefaultSwap::accrualRebate() const {
        return accrualRebate_;
    }

    const Date& CreditDefaultSwap::tradeDate() const {
        return tradeDate_;
    }

    Natural CreditDefaultSwap::cashSettlementDays() const {
        return cashSettlementDays_;
    }

    CreditDefaultSwap::arguments::arguments()
    : side(Protection::Side(-1)), notional(Null<Real>()),
      spread(Null<Rate>()) {}

    void CreditDefaultSwap::arguments::validate() const {
        QL_REQUIRE(side != Protection::Side(-1), "side not set");
        QL_REQUIRE(notional != Null<Real>(), "notional not set");
        QL_REQUIRE(notional != 0.0, "null notional set");
        QL_REQUIRE(spread != Null<Rate>(), "spread not set");
        QL_REQUIRE(!leg.empty(), "coupons not set");
        QL_REQUIRE(upfrontPayment, "upfront payment not set");
        QL_REQUIRE(claim, "claim not set");
        QL_REQUIRE(protectionStart != Date(), "protection start date not set");
        QL_REQUIRE(maturity != Date(), "maturity date not set");
    }

    void CreditDefaultSwap::results::reset() {
        Instrument::results::reset();
        fairSpread = Null<Rate>();
        fairUpfront = Null<Rate>();
        couponLegBPS = Null<Real>();
        couponLegNPV = Null<Real>();
        defaultLegNPV = Null<Real>();
        upfrontBPS = Null<Real>();
        upfrontNPV = Null<Real>();
        accrualRebateNPV = Null<Real>();
    }

    Date cdsMaturity(const Date& tradeDate, const Period& tenor, DateGeneration::Rule rule) {

        QL_REQUIRE(rule == DateGeneration::CDS2015 || rule == DateGeneration::CDS || rule == DateGeneration::OldCDS,
            "cdsMaturity should only be used with date generation rule CDS2015, CDS or OldCDS");

        QL_REQUIRE(tenor.units() == Years || (tenor.units() == Months && tenor.length() % 3 == 0),
            "cdsMaturity expects a tenor that is a multiple of 3 months.");

        if (rule == DateGeneration::OldCDS) {
            QL_REQUIRE(tenor != 0 * Months, "A tenor of 0M is not supported for OldCDS.");
        }

        Date anchorDate = previousTwentieth(tradeDate, rule);
        if (rule == DateGeneration::CDS2015 && (anchorDate == Date(20, Dec, anchorDate.year()) ||
            anchorDate == Date(20, Jun, anchorDate.year()))) {
            if (tenor.length() == 0) {
                return Date();
            } else {
                anchorDate -= 3 * Months;
            }
        }

        Date maturity = anchorDate + tenor + 3 * Months;
        QL_REQUIRE(maturity > tradeDate, "error calculating CDS maturity. Tenor is " << tenor << ", trade date is " <<
            io::iso_date(tradeDate) << " generating a maturity of " << io::iso_date(maturity) << " <= trade date.");

        return maturity;
    }

}
]]></document_content>
  </document>
  <document index="29">
    <source>doublebarrieroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/instruments/doublebarrieroption.hpp>
#include <ql/instruments/impliedvolatility.hpp>
#include <ql/pricingengines/barrier/analyticdoublebarrierengine.hpp>
#include <memory>

namespace QuantLib {

    DoubleBarrierOption::DoubleBarrierOption(
        DoubleBarrier::Type barrierType,
        Real barrier_lo,
        Real barrier_hi,
        Real rebate,
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise),
      barrierType_(barrierType), barrier_lo_(barrier_lo), 
      barrier_hi_(barrier_hi), rebate_(rebate) {}

    void DoubleBarrierOption::setupArguments(PricingEngine::arguments* args) const {

        OneAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<DoubleBarrierOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->barrierType = barrierType_;
        moreArgs->barrier_lo = barrier_lo_;
        moreArgs->barrier_hi = barrier_hi_;
        moreArgs->rebate = rebate_;
    }


    Volatility DoubleBarrierOption::impliedVolatility(
             Real targetValue,
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             Real accuracy,
             Size maxEvaluations,
             Volatility minVol,
             Volatility maxVol) const {

        QL_REQUIRE(!isExpired(), "option expired");

        ext::shared_ptr<SimpleQuote> volQuote(new SimpleQuote);

        ext::shared_ptr<GeneralizedBlackScholesProcess> newProcess =
            detail::ImpliedVolatilityHelper::clone(process, volQuote);

        // engines are built-in for the time being
        std::unique_ptr<PricingEngine> engine;
        switch (exercise_->type()) {
          case Exercise::European:
              engine = std::make_unique<AnalyticDoubleBarrierEngine>(newProcess);
              break;
          case Exercise::American:
          case Exercise::Bermudan:
            QL_FAIL("engine not available for non-European barrier option");
            break;
          default:
            QL_FAIL("unknown exercise type");
        }

        return detail::ImpliedVolatilityHelper::calculate(*this,
                                                          *engine,
                                                          *volQuote,
                                                          targetValue,
                                                          accuracy,
                                                          maxEvaluations,
                                                          minVol, maxVol);
    }


    DoubleBarrierOption::arguments::arguments()
    : barrierType(DoubleBarrier::Type(-1)), barrier_lo(Null<Real>()),
      barrier_hi(Null<Real>()), rebate(Null<Real>()) {}

    void DoubleBarrierOption::arguments::validate() const {
        OneAssetOption::arguments::validate();

        QL_REQUIRE(barrierType == DoubleBarrier::KnockIn ||
                   barrierType == DoubleBarrier::KnockOut ||
                   barrierType == DoubleBarrier::KIKO ||
                   barrierType == DoubleBarrier::KOKI,
                   "Invalid barrier type");

        QL_REQUIRE(barrier_lo != Null<Real>(), "no low barrier given");
        QL_REQUIRE(barrier_hi != Null<Real>(), "no high barrier given");
        QL_REQUIRE(rebate != Null<Real>(), "no rebate given");
    }

    bool DoubleBarrierOption::engine::triggered(Real underlying) const {
        return underlying <= arguments_.barrier_lo || underlying >= arguments_.barrier_hi;
    }

}

]]></document_content>
  </document>
  <document index="30">
    <source>doublebarriertype.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/doublebarriertype.hpp>
#include <ql/types.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    std::ostream& operator<<(std::ostream& out,
                             DoubleBarrier::Type type) {
        switch (type) {
          case DoubleBarrier::KnockIn:
            return out << "KnockIn";
          case DoubleBarrier::KnockOut:
            return out << "KnockOut";
          case DoubleBarrier::KIKO:
            return out << "KI lo+KO up";
          case DoubleBarrier::KOKI:
            return out << "KO lo+KI up";
          default:
            QL_FAIL("unknown DoubleBarrier::Type (" << Integer(type) << ")");
        }
    }

}
]]></document_content>
  </document>
  <document index="31">
    <source>equitytotalreturnswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2023 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/equitycashflow.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/overnightindexedcoupon.hpp>
#include <ql/indexes/equityindex.hpp>
#include <ql/instruments/equitytotalreturnswap.hpp>
#include <utility>

namespace QuantLib {

    namespace {
        ext::shared_ptr<CashFlow>
        createEquityCashFlow(const Schedule& schedule,
                             const ext::shared_ptr<EquityIndex>& equityIndex,
                             Real nominal,
                             const Calendar& paymentCalendar,
                             BusinessDayConvention paymentConvention,
                             Natural paymentDelay) {
            Date startDate = schedule.startDate();
            Date endDate = schedule.endDate();

            Calendar cal = paymentCalendar;
            if (cal.empty()) {
                QL_REQUIRE(!schedule.calendar().empty(), "Calendar in schedule cannot be empty");
                cal = schedule.calendar();
            }
            Date paymentDate =
                cal.advance(endDate, paymentDelay, Days, paymentConvention, schedule.endOfMonth());
            return ext::make_shared<EquityCashFlow>(nominal, equityIndex, startDate, endDate,
                                                    paymentDate);
        }

        template <typename IndexType, typename LegType>
        Leg createInterestLeg(const Schedule& schedule,
                              const ext::shared_ptr<IndexType>& interestRateIndex,
                              Real nominal,
                              const DayCounter& dayCounter,
                              Rate margin,
                              Real gearing,
                              const Calendar& paymentCalendar,
                              BusinessDayConvention paymentConvention,
                              Natural paymentDelay) {
            return LegType(std::move(schedule), interestRateIndex)
                .withNotionals(nominal)
                .withPaymentDayCounter(dayCounter)
                .withSpreads(margin)
                .withGearings(gearing)
                .withPaymentCalendar(paymentCalendar)
                .withPaymentAdjustment(paymentConvention)
                .withPaymentLag(paymentDelay);
        }
    }

    EquityTotalReturnSwap::EquityTotalReturnSwap(
        ext::shared_ptr<EquityIndex> equityIndex,
        ext::shared_ptr<InterestRateIndex> interestRateIndex,
        Type type,
        Real nominal,
        Schedule schedule,
        DayCounter dayCounter,
        Rate margin,
        Real gearing,
        Calendar paymentCalendar,
        BusinessDayConvention paymentConvention,
        Natural paymentDelay)
    : Swap(2), equityIndex_(std::move(equityIndex)),
      interestRateIndex_(std::move(interestRateIndex)), type_(type), nominal_(nominal),
      schedule_(std::move(schedule)), dayCounter_(std::move(dayCounter)), margin_(margin),
      gearing_(gearing), paymentCalendar_(std::move(paymentCalendar)),
      paymentConvention_(paymentConvention), paymentDelay_(paymentDelay) {

        QL_REQUIRE(!(nominal_ < 0.0), "Nominal cannot be negative");

        legs_[0].push_back(createEquityCashFlow(schedule_, equityIndex_, nominal_, paymentCalendar_,
                                                paymentConvention_, paymentDelay_));
        for (auto i = legs_[0].begin(); i < legs_[0].end(); ++i)
            registerWith(*i);

        switch (type_) {
            case Payer:
                payer_[0] = -1.0;
                payer_[1] = +1.0;
                break;
            case Receiver:
                payer_[0] = +1.0;
                payer_[1] = -1.0;
                break;
            default:
                QL_FAIL("unknown equity total return swap type");
        }
    }

    EquityTotalReturnSwap::EquityTotalReturnSwap(Type type,
                                                 Real nominal,
                                                 Schedule schedule,
                                                 ext::shared_ptr<EquityIndex> equityIndex,
                                                 const ext::shared_ptr<IborIndex>& interestRateIndex,
                                                 DayCounter dayCounter,
                                                 Rate margin,
                                                 Real gearing,
                                                 Calendar paymentCalendar,
                                                 BusinessDayConvention paymentConvention,
                                                 Natural paymentDelay)
    : EquityTotalReturnSwap(std::move(equityIndex),
                            interestRateIndex,
                            type,
                            nominal,
                            std::move(schedule),
                            std::move(dayCounter),
                            margin,
                            gearing,
                            std::move(paymentCalendar),
                            paymentConvention,
                            paymentDelay) {
        legs_[1] = createInterestLeg<IborIndex, IborLeg>(
            schedule_, interestRateIndex, nominal_, dayCounter_, margin_, gearing_,
            paymentCalendar_, paymentConvention_, paymentDelay_);
        for (auto i = legs_[1].begin(); i < legs_[1].end(); ++i)
            registerWith(*i);
    }

    EquityTotalReturnSwap::EquityTotalReturnSwap(Type type,
                                                 Real nominal,
                                                 Schedule schedule,
                                                 ext::shared_ptr<EquityIndex> equityIndex,
                                                 const ext::shared_ptr<OvernightIndex>& interestRateIndex,
                                                 DayCounter dayCounter,
                                                 Rate margin,
                                                 Real gearing,
                                                 Calendar paymentCalendar,
                                                 BusinessDayConvention paymentConvention,
                                                 Natural paymentDelay)
    : EquityTotalReturnSwap(std::move(equityIndex),
                            interestRateIndex,
                            type,
                            nominal,
                            std::move(schedule),
                            std::move(dayCounter),
                            margin,
                            gearing,
                            std::move(paymentCalendar),
                            paymentConvention,
                            paymentDelay) {
        legs_[1] = createInterestLeg<OvernightIndex, OvernightLeg>(
            schedule_, interestRateIndex, nominal_, dayCounter_, margin_, gearing_,
            paymentCalendar_, paymentConvention_, paymentDelay_);
        for (auto i = legs_[1].begin(); i < legs_[1].end(); ++i)
            registerWith(*i);
    }

    const Leg& EquityTotalReturnSwap::equityLeg() const {
        return leg(0);
    }

    const Leg& EquityTotalReturnSwap::interestRateLeg() const {
        return leg(1);
    }

    Real EquityTotalReturnSwap::equityLegNPV() const {
        return legNPV(0);
    }

    Real EquityTotalReturnSwap::interestRateLegNPV() const {
        return legNPV(1);
    }

    Real EquityTotalReturnSwap::fairMargin() const {
        // Knowing that for the fair margin NPV = 0.0, where:
        // NPV = NPV Equity Leg + [NPV Floating Leg + margin * BPS / 10000]
        // hence,
        // fair margin = - [NPV Equity Leg + NPV Floating Leg] / BPS * 10000
        const Spread basisPoint = 1.0e-4;
        Real interestLegBps = legBPS(1) / basisPoint;
        Real exMarginInterestLegNpv = interestRateLegNPV() - margin() * interestLegBps;
        return -(equityLegNPV() + exMarginInterestLegNpv) / interestLegBps;
    }
}
]]></document_content>
  </document>
  <document index="32">
    <source>europeanoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/europeanoption.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>

namespace QuantLib {

    EuropeanOption::EuropeanOption(
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : VanillaOption(payoff, exercise) {}

}

]]></document_content>
  </document>
  <document index="33">
    <source>fixedvsfloatingswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007 StatPro Italia srl
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/instruments/fixedvsfloatingswap.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    FixedVsFloatingSwap::FixedVsFloatingSwap(Type type,
                                             std::vector<Real> fixedNominals,
                                             Schedule fixedSchedule,
                                             Rate fixedRate,
                                             DayCounter fixedDayCount,
                                             std::vector<Real> floatingNominals,
                                             Schedule floatingSchedule,
                                             ext::shared_ptr<IborIndex> iborIndex,
                                             Spread spread,
                                             DayCounter floatingDayCount,
                                             ext::optional<BusinessDayConvention> paymentConvention,
                                             Integer paymentLag,
                                             const Calendar& paymentCalendar)
    : Swap(2), type_(type), fixedNominals_(std::move(fixedNominals)), fixedSchedule_(std::move(fixedSchedule)),
      fixedRate_(fixedRate), fixedDayCount_(std::move(fixedDayCount)),
      floatingNominals_(std::move(floatingNominals)), floatingSchedule_(std::move(floatingSchedule)),
      iborIndex_(std::move(iborIndex)), spread_(spread), floatingDayCount_(std::move(floatingDayCount)) {

        QL_REQUIRE(iborIndex_, "null floating index provided");

        if (fixedDayCount_ == DayCounter())
            fixedDayCount_ = iborIndex_->dayCounter();

        if (paymentConvention) // NOLINT(readability-implicit-bool-conversion)
            paymentConvention_ = *paymentConvention;
        else
            paymentConvention_ = floatingSchedule_.businessDayConvention();

        legs_[0] = FixedRateLeg(fixedSchedule_)
            .withNotionals(fixedNominals_)
            .withCouponRates(fixedRate_, fixedDayCount_)
            .withPaymentAdjustment(paymentConvention_)
            .withPaymentLag(paymentLag)
            .withPaymentCalendar(paymentCalendar.empty() ?
                                 fixedSchedule_.calendar() :
                                 paymentCalendar);

        // legs_[1] to be built by derived class constructor

        switch (type_) {
          case Payer:
            payer_[0] = -1.0;
            payer_[1] = +1.0;
            break;
          case Receiver:
            payer_[0] = +1.0;
            payer_[1] = -1.0;
            break;
          default:
            QL_FAIL("Unknown vanilla-swap type");
        }


        // These bools tell us if we can support the old methods nominal() and nominals().
        // There might be false negatives (i.e., if we pass constant vectors of different lengths
        // as fixedNominals and floatingNominals) but we're going to assume that whoever uses the
        // constructor with two vectors is mostly going to use the new methods instead.
        sameNominals_ = std::equal(fixedNominals_.begin(), fixedNominals_.end(),
                                   floatingNominals_.begin(), floatingNominals_.end());
        if (!sameNominals_) {
            constantNominals_ = false;
        } else {
            constantNominals_ = true;
            Real front = fixedNominals_[0];
            for (auto x : fixedNominals_) {
                if (x != front) {
                    constantNominals_ = false;
                    break;
                }
            }
        }
    }

    void FixedVsFloatingSwap::setupArguments(PricingEngine::arguments* args) const {

        Swap::setupArguments(args);

        auto* arguments = dynamic_cast<FixedVsFloatingSwap::arguments*>(args);

        if (arguments == nullptr) // it's a swap engine...
            return;

        arguments->type = type_;

        if (constantNominals_)
            arguments->nominal = nominal();
        else
            arguments->nominal = Null<Real>();

        const Leg& fixedCoupons = fixedLeg();
        Size n = fixedCoupons.size();

        arguments->fixedResetDates = arguments->fixedPayDates = std::vector<Date>(n);
        arguments->fixedNominals = arguments->fixedCoupons = std::vector<Real>(n);

        for (Size i=0; i<n; ++i) {
            auto coupon = ext::dynamic_pointer_cast<FixedRateCoupon>(fixedCoupons[i]);

            arguments->fixedPayDates[i] = coupon->date();
            arguments->fixedResetDates[i] = coupon->accrualStartDate();
            arguments->fixedCoupons[i] = coupon->amount();
            arguments->fixedNominals[i] = coupon->nominal();
        }

        setupFloatingArguments(arguments);
    }

    Rate FixedVsFloatingSwap::fairRate() const {
        calculate();
        QL_REQUIRE(fairRate_ != Null<Rate>(), "result not available");
        return fairRate_;
    }

    Spread FixedVsFloatingSwap::fairSpread() const {
        calculate();
        QL_REQUIRE(fairSpread_ != Null<Spread>(), "result not available");
        return fairSpread_;
    }

    Real FixedVsFloatingSwap::fixedLegBPS() const {
        calculate();
        QL_REQUIRE(legBPS_[0] != Null<Real>(), "result not available");
        return legBPS_[0];
    }

    Real FixedVsFloatingSwap::floatingLegBPS() const {
        calculate();
        QL_REQUIRE(legBPS_[1] != Null<Real>(), "result not available");
        return legBPS_[1];
    }

    Real FixedVsFloatingSwap::fixedLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[0] != Null<Real>(), "result not available");
        return legNPV_[0];
    }

    Real FixedVsFloatingSwap::floatingLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[1] != Null<Real>(), "result not available");
        return legNPV_[1];
    }

    void FixedVsFloatingSwap::setupExpired() const {
        Swap::setupExpired();
        legBPS_[0] = legBPS_[1] = 0.0;
        fairRate_ = Null<Rate>();
        fairSpread_ = Null<Spread>();
    }

    void FixedVsFloatingSwap::fetchResults(const PricingEngine::results* r) const {
        static const Spread basisPoint = 1.0e-4;

        Swap::fetchResults(r);

        const auto* results = dynamic_cast<const FixedVsFloatingSwap::results*>(r);
        if (results != nullptr) { // might be a swap engine, so no error is thrown
            fairRate_ = results->fairRate;
            fairSpread_ = results->fairSpread;
        } else {
            fairRate_ = Null<Rate>();
            fairSpread_ = Null<Spread>();
        }

        if (fairRate_ == Null<Rate>()) {
            // calculate it from other results
            if (legBPS_[0] != Null<Real>())
                fairRate_ = fixedRate_ - NPV_/(legBPS_[0]/basisPoint);
        }
        if (fairSpread_ == Null<Spread>()) {
            // ditto
            if (legBPS_[1] != Null<Real>())
                fairSpread_ = spread_ - NPV_/(legBPS_[1]/basisPoint);
        }
    }

    void FixedVsFloatingSwap::arguments::validate() const {
        Swap::arguments::validate();
        QL_REQUIRE(fixedNominals.size() == fixedPayDates.size(),
                   "number of fixed nominals different from "
                   "number of fixed payment dates");
        QL_REQUIRE(fixedResetDates.size() == fixedPayDates.size(),
                   "number of fixed start dates different from "
                   "number of fixed payment dates");
        QL_REQUIRE(fixedPayDates.size() == fixedCoupons.size(),
                   "number of fixed payment dates different from "
                   "number of fixed coupon amounts");
        QL_REQUIRE(floatingNominals.size() == floatingPayDates.size(),
                   "number of floating nominals different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingResetDates.size() == floatingPayDates.size(),
                   "number of floating start dates different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingFixingDates.size() == floatingPayDates.size(),
                   "number of floating fixing dates different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingAccrualTimes.size() == floatingPayDates.size(),
                   "number of floating accrual Times different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingSpreads.size() == floatingPayDates.size(),
                   "number of floating spreads different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingPayDates.size() == floatingCoupons.size(),
                   "number of floating payment dates different from "
                   "number of floating coupon amounts");
    }

    void FixedVsFloatingSwap::results::reset() {
        Swap::results::reset();
        fairRate = Null<Rate>();
        fairSpread = Null<Spread>();
    }

}
]]></document_content>
  </document>
  <document index="34">
    <source>floatfloatswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/capflooredcoupon.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/cmscoupon.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/experimental/coupons/cmsspreadcoupon.hpp> // internal
#include <ql/indexes/iborindex.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/instruments/floatfloatswap.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/optional.hpp>
#include <utility>

namespace QuantLib {

    FloatFloatSwap::FloatFloatSwap(const Swap::Type type,
                                   const Real nominal1,
                                   const Real nominal2,
                                   Schedule schedule1,
                                   ext::shared_ptr<InterestRateIndex> index1,
                                   DayCounter dayCount1,
                                   Schedule schedule2,
                                   ext::shared_ptr<InterestRateIndex> index2,
                                   DayCounter dayCount2,
                                   const bool intermediateCapitalExchange,
                                   const bool finalCapitalExchange,
                                   const Real gearing1,
                                   const Real spread1,
                                   const Real cappedRate1,
                                   const Real flooredRate1,
                                   const Real gearing2,
                                   const Real spread2,
                                   const Real cappedRate2,
                                   const Real flooredRate2,
                                   const ext::optional<BusinessDayConvention>& paymentConvention1,
                                   const ext::optional<BusinessDayConvention>& paymentConvention2)
    : Swap(2), type_(type), nominal1_(std::vector<Real>(schedule1.size() - 1, nominal1)),
      nominal2_(std::vector<Real>(schedule2.size() - 1, nominal2)),
      schedule1_(std::move(schedule1)), schedule2_(std::move(schedule2)),
      index1_(std::move(index1)), index2_(std::move(index2)),
      gearing1_(std::vector<Real>(schedule1_.size() - 1, gearing1)),
      gearing2_(std::vector<Real>(schedule2_.size() - 1, gearing2)),
      spread1_(std::vector<Real>(schedule1_.size() - 1, spread1)),
      spread2_(std::vector<Real>(schedule2_.size() - 1, spread2)),
      cappedRate1_(std::vector<Real>(schedule1_.size() - 1, cappedRate1)),
      flooredRate1_(std::vector<Real>(schedule1_.size() - 1, flooredRate1)),
      cappedRate2_(std::vector<Real>(schedule2_.size() - 1, cappedRate2)),
      flooredRate2_(std::vector<Real>(schedule2_.size() - 1, flooredRate2)),
      dayCount1_(std::move(dayCount1)), dayCount2_(std::move(dayCount2)),
      intermediateCapitalExchange_(intermediateCapitalExchange),
      finalCapitalExchange_(finalCapitalExchange) {

        init(paymentConvention1, paymentConvention2);
    }

    FloatFloatSwap::FloatFloatSwap(const Swap::Type type,
                                   std::vector<Real> nominal1,
                                   std::vector<Real> nominal2,
                                   Schedule schedule1,
                                   ext::shared_ptr<InterestRateIndex> index1,
                                   DayCounter dayCount1,
                                   Schedule schedule2,
                                   ext::shared_ptr<InterestRateIndex> index2,
                                   DayCounter dayCount2,
                                   const bool intermediateCapitalExchange,
                                   const bool finalCapitalExchange,
                                   std::vector<Real> gearing1,
                                   std::vector<Real> spread1,
                                   std::vector<Real> cappedRate1,
                                   std::vector<Real> flooredRate1,
                                   std::vector<Real> gearing2,
                                   std::vector<Real> spread2,
                                   std::vector<Real> cappedRate2,
                                   std::vector<Real> flooredRate2,
                                   const ext::optional<BusinessDayConvention>& paymentConvention1,
                                   const ext::optional<BusinessDayConvention>& paymentConvention2)
    : Swap(2), type_(type), nominal1_(std::move(nominal1)), nominal2_(std::move(nominal2)),
      schedule1_(std::move(schedule1)), schedule2_(std::move(schedule2)),
      index1_(std::move(index1)), index2_(std::move(index2)), gearing1_(std::move(gearing1)),
      gearing2_(std::move(gearing2)), spread1_(std::move(spread1)), spread2_(std::move(spread2)),
      cappedRate1_(std::move(cappedRate1)), flooredRate1_(std::move(flooredRate1)),
      cappedRate2_(std::move(cappedRate2)), flooredRate2_(std::move(flooredRate2)),
      dayCount1_(std::move(dayCount1)), dayCount2_(std::move(dayCount2)),
      intermediateCapitalExchange_(intermediateCapitalExchange),
      finalCapitalExchange_(finalCapitalExchange) {

        init(paymentConvention1, paymentConvention2);
    }

    void FloatFloatSwap::init(
        ext::optional<BusinessDayConvention> paymentConvention1,
        ext::optional<BusinessDayConvention> paymentConvention2) {

        QL_REQUIRE(nominal1_.size() == schedule1_.size() - 1,
                   "nominal1 size (" << nominal1_.size()
                                     << ") does not match schedule1 size ("
                                     << schedule1_.size() << ")");
        QL_REQUIRE(nominal2_.size() == schedule2_.size() - 1,
                   "nominal2 size (" << nominal2_.size()
                                     << ") does not match schedule2 size ("
                                     << nominal2_.size() << ")");
        QL_REQUIRE(gearing1_.empty() || gearing1_.size() == nominal1_.size(),
                   "nominal1 size (" << nominal1_.size() << ") does not match gearing1 size ("
                                     << gearing1_.size() << ")");
        QL_REQUIRE(gearing2_.empty() || gearing2_.size() == nominal2_.size(),
                   "nominal2 size (" << nominal2_.size() << ") does not match gearing2 size ("
                                     << gearing2_.size() << ")");
        QL_REQUIRE(cappedRate1_.empty() || cappedRate1_.size() == nominal1_.size(),
                   "nominal1 size (" << nominal1_.size() << ") does not match cappedRate1 size ("
                                     << cappedRate1_.size() << ")");
        QL_REQUIRE(cappedRate2_.empty() || cappedRate2_.size() == nominal2_.size(),
                   "nominal2 size (" << nominal2_.size() << ") does not match cappedRate2 size ("
                                     << cappedRate2_.size() << ")");
        QL_REQUIRE(flooredRate1_.empty() || flooredRate1_.size() == nominal1_.size(),
                   "nominal1 size (" << nominal1_.size() << ") does not match flooredRate1 size ("
                                     << flooredRate1_.size() << ")");
        QL_REQUIRE(flooredRate2_.empty() || flooredRate2_.size() == nominal2_.size(),
                   "nominal2 size (" << nominal2_.size() << ") does not match flooredRate2 size ("
                                     << flooredRate2_.size() << ")");

        if (paymentConvention1) // NOLINT(readability-implicit-bool-conversion)
            paymentConvention1_ = *paymentConvention1;
        else
            paymentConvention1_ = schedule1_.businessDayConvention();

        if (paymentConvention2) // NOLINT(readability-implicit-bool-conversion)
            paymentConvention2_ = *paymentConvention2;
        else
            paymentConvention2_ = schedule2_.businessDayConvention();

        if (gearing1_.empty())
            gearing1_ = std::vector<Real>(nominal1_.size(), 1.0);
        if (gearing2_.empty())
            gearing2_ = std::vector<Real>(nominal2_.size(), 1.0);
        if (spread1_.empty())
            spread1_ = std::vector<Real>(nominal1_.size(), 0.0);
        if (spread2_.empty())
            spread2_ = std::vector<Real>(nominal2_.size(), 0.0);
        if (cappedRate1_.empty())
            cappedRate1_ = std::vector<Real>(nominal1_.size(), Null<Real>());
        if (cappedRate2_.empty())
            cappedRate2_ = std::vector<Real>(nominal2_.size(), Null<Real>());
        if (flooredRate1_.empty())
            flooredRate1_ = std::vector<Real>(nominal1_.size(), Null<Real>());
        if (flooredRate2_.empty())
            flooredRate2_ = std::vector<Real>(nominal2_.size(), Null<Real>());

        bool isNull;
        isNull = cappedRate1_[0] == Null<Real>();
        for (Size i = 0; i < cappedRate1_.size(); i++) {
            if (isNull)
                QL_REQUIRE(cappedRate1_[i] == Null<Real>(),
                           "cappedRate1 must be null for all or none entry ("
                               << (i + 1) << "th is " << cappedRate1_[i]
                               << ")");
            else
                QL_REQUIRE(cappedRate1_[i] != Null<Real>(),
                           "cappedRate 1 must be null for all or none entry ("
                               << "1st is " << cappedRate1_[0] << ")");
        }
        isNull = cappedRate2_[0] == Null<Real>();
        for (Size i = 0; i < cappedRate2_.size(); i++) {
            if (isNull)
                QL_REQUIRE(cappedRate2_[i] == Null<Real>(),
                           "cappedRate2 must be null for all or none entry ("
                               << (i + 1) << "th is " << cappedRate2_[i]
                               << ")");
            else
                QL_REQUIRE(cappedRate2_[i] != Null<Real>(),
                           "cappedRate2 must be null for all or none entry ("
                               << "1st is " << cappedRate2_[0] << ")");
        }
        isNull = flooredRate1_[0] == Null<Real>();
        for (Size i = 0; i < flooredRate1_.size(); i++) {
            if (isNull)
                QL_REQUIRE(flooredRate1_[i] == Null<Real>(),
                           "flooredRate1 must be null for all or none entry ("
                               << (i + 1) << "th is " << flooredRate1_[i]
                               << ")");
            else
                QL_REQUIRE(flooredRate1_[i] != Null<Real>(),
                           "flooredRate 1 must be null for all or none entry ("
                               << "1st is " << flooredRate1_[0] << ")");
        }
        isNull = flooredRate2_[0] == Null<Real>();
        for (Size i = 0; i < flooredRate2_.size(); i++) {
            if (isNull)
                QL_REQUIRE(flooredRate2_[i] == Null<Real>(),
                           "flooredRate2 must be null for all or none entry ("
                               << (i + 1) << "th is " << flooredRate2_[i]
                               << ")");
            else
                QL_REQUIRE(flooredRate2_[i] != Null<Real>(),
                           "flooredRate2 must be null for all or none entry ("
                               << "1st is " << flooredRate2_[0] << ")");
        }

        // if the gearing is zero then the ibor / cms leg will be set up with
        // fixed coupons which makes trouble here in this context. We therefore
        // use a dirty trick and enforce the gearing to be non zero.
        for (Real& i : gearing1_)
            if (close(i, 0.0))
                i = QL_EPSILON;
        for (Real& i : gearing2_)
            if (close(i, 0.0))
                i = QL_EPSILON;

        ext::shared_ptr<IborIndex> ibor1 =
            ext::dynamic_pointer_cast<IborIndex>(index1_);
        ext::shared_ptr<IborIndex> ibor2 =
            ext::dynamic_pointer_cast<IborIndex>(index2_);
        ext::shared_ptr<SwapIndex> cms1 =
            ext::dynamic_pointer_cast<SwapIndex>(index1_);
        ext::shared_ptr<SwapIndex> cms2 =
            ext::dynamic_pointer_cast<SwapIndex>(index2_);
        ext::shared_ptr<SwapSpreadIndex> cmsspread1 =
            ext::dynamic_pointer_cast<SwapSpreadIndex>(index1_);
        ext::shared_ptr<SwapSpreadIndex> cmsspread2 =
            ext::dynamic_pointer_cast<SwapSpreadIndex>(index2_);

        QL_REQUIRE(ibor1 != nullptr || cms1 != nullptr || cmsspread1 != nullptr,
                   "index1 must be ibor or cms or cms spread");
        QL_REQUIRE(ibor2 != nullptr || cms2 != nullptr || cmsspread2 != nullptr,
                   "index2 must be ibor or cms");

        if (ibor1 != nullptr) {
            IborLeg leg(schedule1_, ibor1);
            leg = leg.withNotionals(nominal1_)
                      .withPaymentDayCounter(dayCount1_)
                      .withPaymentAdjustment(paymentConvention1_)
                      .withSpreads(spread1_)
                      .withGearings(gearing1_);
            if (cappedRate1_[0] != Null<Real>())
                leg = leg.withCaps(cappedRate1_);
            if (flooredRate1_[0] != Null<Real>())
                leg = leg.withFloors(flooredRate1_);
            legs_[0] = leg;
        }

        if (ibor2 != nullptr) {
            IborLeg leg(schedule2_, ibor2);
            leg = leg.withNotionals(nominal2_)
                      .withPaymentDayCounter(dayCount2_)
                      .withPaymentAdjustment(paymentConvention2_)
                      .withSpreads(spread2_)
                      .withGearings(gearing2_);
            if (cappedRate2_[0] != Null<Real>())
                leg = leg.withCaps(cappedRate2_);
            if (flooredRate2_[0] != Null<Real>())
                leg = leg.withFloors(flooredRate2_);
            legs_[1] = leg;
        }

        if (cms1 != nullptr) {
            CmsLeg leg(schedule1_, cms1);
            leg = leg.withNotionals(nominal1_)
                      .withPaymentDayCounter(dayCount1_)
                      .withPaymentAdjustment(paymentConvention1_)
                      .withSpreads(spread1_)
                      .withGearings(gearing1_);
            if (cappedRate1_[0] != Null<Real>())
                leg = leg.withCaps(cappedRate1_);
            if (flooredRate1_[0] != Null<Real>())
                leg = leg.withFloors(flooredRate1_);
            legs_[0] = leg;
        }

        if (cms2 != nullptr) {
            CmsLeg leg(schedule2_, cms2);
            leg = leg.withNotionals(nominal2_)
                      .withPaymentDayCounter(dayCount2_)
                      .withPaymentAdjustment(paymentConvention2_)
                      .withSpreads(spread2_)
                      .withGearings(gearing2_);
            if (cappedRate2_[0] != Null<Real>())
                leg = leg.withCaps(cappedRate2_);
            if (flooredRate2_[0] != Null<Real>())
                leg = leg.withFloors(flooredRate2_);
            legs_[1] = leg;
        }

        if (cmsspread1 != nullptr) {
            CmsSpreadLeg leg(schedule1_, cmsspread1);
            leg = leg.withNotionals(nominal1_)
                      .withPaymentDayCounter(dayCount1_)
                      .withPaymentAdjustment(paymentConvention1_)
                      .withSpreads(spread1_)
                      .withGearings(gearing1_);
            if (cappedRate1_[0] != Null<Real>())
                leg = leg.withCaps(cappedRate1_);
            if (flooredRate1_[0] != Null<Real>())
                leg = leg.withFloors(flooredRate1_);
            legs_[0] = leg;
        }

        if (cmsspread2 != nullptr) {
            CmsSpreadLeg leg(schedule2_, cmsspread2);
            leg = leg.withNotionals(nominal2_)
                      .withPaymentDayCounter(dayCount2_)
                      .withPaymentAdjustment(paymentConvention2_)
                      .withSpreads(spread2_)
                      .withGearings(gearing2_);
            if (cappedRate2_[0] != Null<Real>())
                leg = leg.withCaps(cappedRate2_);
            if (flooredRate2_[0] != Null<Real>())
                leg = leg.withFloors(flooredRate2_);
            legs_[1] = leg;
        }

        if (intermediateCapitalExchange_) {
            for (Size i = 0; i < legs_[0].size() - 1; i++) {
                Real cap = nominal1_[i] - nominal1_[i + 1];
                if (!close(cap, 0.0)) {
                    auto it1 = legs_[0].begin();
                    std::advance(it1, i + 1);
                    legs_[0].insert(
                        it1, ext::shared_ptr<CashFlow>(
                                 new Redemption(cap, legs_[0][i]->date())));
                    auto it2 = nominal1_.begin();
                    std::advance(it2, i + 1);
                    nominal1_.insert(it2, nominal1_[i]);
                    i++;
                }
            }
            for (Size i = 0; i < legs_[1].size() - 1; i++) {
                Real cap = nominal2_[i] - nominal2_[i + 1];
                if (!close(cap, 0.0)) {
                    auto it1 = legs_[1].begin();
                    std::advance(it1, i + 1);
                    legs_[1].insert(
                        it1, ext::shared_ptr<CashFlow>(
                                 new Redemption(cap, legs_[1][i]->date())));
                    auto it2 = nominal2_.begin();
                    std::advance(it2, i + 1);
                    nominal2_.insert(it2, nominal2_[i]);
                    i++;
                }
            }
        }

        if (finalCapitalExchange_) {
            legs_[0].push_back(ext::shared_ptr<CashFlow>(
                new Redemption(nominal1_.back(), legs_[0].back()->date())));
            nominal1_.push_back(nominal1_.back());
            legs_[1].push_back(ext::shared_ptr<CashFlow>(
                new Redemption(nominal2_.back(), legs_[1].back()->date())));
            nominal2_.push_back(nominal2_.back());
        }

        for (auto i = legs_[0].begin(); i < legs_[0].end(); ++i)
            registerWith(*i);

        for (auto i = legs_[1].begin(); i < legs_[1].end(); ++i)
            registerWith(*i);

        switch (type_) {
        case Swap::Payer:
            payer_[0] = -1.0;
            payer_[1] = +1.0;
            break;
        case Swap::Receiver:
            payer_[0] = +1.0;
            payer_[1] = -1.0;
            break;
        default:
            QL_FAIL("Unknown float float - swap type");
        }
    }

    void FloatFloatSwap::setupArguments(PricingEngine::arguments *args) const {

        Swap::setupArguments(args);

        auto* arguments = dynamic_cast<FloatFloatSwap::arguments*>(args);

        if (arguments == nullptr)
            return; // swap engine ... // QL_REQUIRE(arguments != 0, "argument type does not match");

        arguments->type = type_;
        arguments->nominal1 = nominal1_;
        arguments->nominal2 = nominal2_;
        arguments->index1 = index1_;
        arguments->index2 = index2_;

        const Leg &leg1Coupons = leg1();
        const Leg &leg2Coupons = leg2();

        arguments->leg1ResetDates = arguments->leg1PayDates =
            arguments->leg1FixingDates = std::vector<Date>(leg1Coupons.size());
        arguments->leg2ResetDates = arguments->leg2PayDates =
            arguments->leg2FixingDates = std::vector<Date>(leg2Coupons.size());

        arguments->leg1Spreads = arguments->leg1AccrualTimes =
            arguments->leg1Gearings = std::vector<Real>(leg1Coupons.size());
        arguments->leg2Spreads = arguments->leg2AccrualTimes =
            arguments->leg2Gearings = std::vector<Real>(leg2Coupons.size());

        arguments->leg1Coupons =
            std::vector<Real>(leg1Coupons.size(), Null<Real>());
        arguments->leg2Coupons =
            std::vector<Real>(leg2Coupons.size(), Null<Real>());

        arguments->leg1IsRedemptionFlow =
            std::vector<bool>(leg1Coupons.size(), false);
        arguments->leg2IsRedemptionFlow =
            std::vector<bool>(leg2Coupons.size(), false);

        arguments->leg1CappedRates = arguments->leg1FlooredRates =
            std::vector<Real>(leg1Coupons.size(), Null<Real>());
        arguments->leg2CappedRates = arguments->leg2FlooredRates =
            std::vector<Real>(leg2Coupons.size(), Null<Real>());

        for (Size i = 0; i < leg1Coupons.size(); ++i) {
            ext::shared_ptr<FloatingRateCoupon> coupon =
                ext::dynamic_pointer_cast<FloatingRateCoupon>(leg1Coupons[i]);
            if (coupon != nullptr) {
                arguments->leg1AccrualTimes[i] = coupon->accrualPeriod();
                arguments->leg1PayDates[i] = coupon->date();
                arguments->leg1ResetDates[i] = coupon->accrualStartDate();
                arguments->leg1FixingDates[i] = coupon->fixingDate();
                arguments->leg1Spreads[i] = coupon->spread();
                arguments->leg1Gearings[i] = coupon->gearing();
                try {
                    arguments->leg1Coupons[i] = coupon->amount();
                }
                catch (Error &) {
                    arguments->leg1Coupons[i] = Null<Real>();
                }
                ext::shared_ptr<CappedFlooredCoupon> cfcoupon =
                    ext::dynamic_pointer_cast<CappedFlooredCoupon>(
                        leg1Coupons[i]);
                if (cfcoupon != nullptr) {
                    arguments->leg1CappedRates[i] = cfcoupon->cap();
                    arguments->leg1FlooredRates[i] = cfcoupon->floor();
                }
            } else {
                ext::shared_ptr<CashFlow> cashflow =
                    ext::dynamic_pointer_cast<CashFlow>(leg1Coupons[i]);
                auto j =
                    std::find(arguments->leg1PayDates.begin(),
                              arguments->leg1PayDates.end(), cashflow->date());
                QL_REQUIRE(j != arguments->leg1PayDates.end(),
                           "nominal redemption on "
                               << cashflow->date()
                               << "has no corresponding coupon");
                Size jIdx = j - arguments->leg1PayDates.begin();
                arguments->leg1IsRedemptionFlow[i] = true;
                arguments->leg1Coupons[i] = cashflow->amount();
                arguments->leg1ResetDates[i] = arguments->leg1ResetDates[jIdx];
                arguments->leg1FixingDates[i] =
                    arguments->leg1FixingDates[jIdx];
                arguments->leg1AccrualTimes[i] = 0.0;
                arguments->leg1Spreads[i] = 0.0;
                arguments->leg1Gearings[i] = 1.0;
                arguments->leg1PayDates[i] = cashflow->date();
            }
        }

        for (Size i = 0; i < leg2Coupons.size(); ++i) {
            ext::shared_ptr<FloatingRateCoupon> coupon =
                ext::dynamic_pointer_cast<FloatingRateCoupon>(leg2Coupons[i]);
            if (coupon != nullptr) {
                arguments->leg2AccrualTimes[i] = coupon->accrualPeriod();
                arguments->leg2PayDates[i] = coupon->date();
                arguments->leg2ResetDates[i] = coupon->accrualStartDate();
                arguments->leg2FixingDates[i] = coupon->fixingDate();
                arguments->leg2Spreads[i] = coupon->spread();
                arguments->leg2Gearings[i] = coupon->gearing();
                try {
                    arguments->leg2Coupons[i] = coupon->amount();
                }
                catch (Error &) {
                    arguments->leg2Coupons[i] = Null<Real>();
                }
                ext::shared_ptr<CappedFlooredCoupon> cfcoupon =
                    ext::dynamic_pointer_cast<CappedFlooredCoupon>(
                        leg2Coupons[i]);
                if (cfcoupon != nullptr) {
                    arguments->leg2CappedRates[i] = cfcoupon->cap();
                    arguments->leg2FlooredRates[i] = cfcoupon->floor();
                }
            } else {
                ext::shared_ptr<CashFlow> cashflow =
                    ext::dynamic_pointer_cast<CashFlow>(leg2Coupons[i]);
                auto j =
                    std::find(arguments->leg2PayDates.begin(),
                              arguments->leg2PayDates.end(), cashflow->date());
                QL_REQUIRE(j != arguments->leg2PayDates.end(),
                           "nominal redemption on "
                               << cashflow->date()
                               << "has no corresponding coupon");
                Size jIdx = j - arguments->leg2PayDates.begin();
                arguments->leg2IsRedemptionFlow[i] = true;
                arguments->leg2Coupons[i] = cashflow->amount();
                arguments->leg2ResetDates[i] = arguments->leg2ResetDates[jIdx];
                arguments->leg2FixingDates[i] =
                    arguments->leg2FixingDates[jIdx];
                arguments->leg2AccrualTimes[i] = 0.0;
                arguments->leg2Spreads[i] = 0.0;
                arguments->leg2Gearings[i] = 1.0;
                arguments->leg2PayDates[i] = cashflow->date();
            }
        }
    }

    void FloatFloatSwap::setupExpired() const { Swap::setupExpired(); }

    void FloatFloatSwap::fetchResults(const PricingEngine::results *r) const {
        Swap::fetchResults(r);
    }

    void FloatFloatSwap::arguments::validate() const {

        Swap::arguments::validate();

        QL_REQUIRE(nominal1.size() == leg1ResetDates.size(),
                   "nominal1 size is different from resetDates1 size");
        QL_REQUIRE(nominal1.size() == leg1FixingDates.size(),
                   "nominal1 size is different from fixingDates1 size");
        QL_REQUIRE(nominal1.size() == leg1PayDates.size(),
                   "nominal1 size is different from payDates1 size");
        QL_REQUIRE(nominal1.size() == leg1Spreads.size(),
                   "nominal1 size is different from spreads1 size");
        QL_REQUIRE(nominal1.size() == leg1Gearings.size(),
                   "nominal1 size is different from gearings1 size");
        QL_REQUIRE(nominal1.size() == leg1CappedRates.size(),
                   "nominal1 size is different from cappedRates1 size");
        QL_REQUIRE(nominal1.size() == leg1FlooredRates.size(),
                   "nominal1 size is different from flooredRates1 size");
        QL_REQUIRE(nominal1.size() == leg1Coupons.size(),
                   "nominal1 size is different from coupons1 size");
        QL_REQUIRE(nominal1.size() == leg1AccrualTimes.size(),
                   "nominal1 size is different from accrualTimes1 size");
        QL_REQUIRE(nominal1.size() == leg1IsRedemptionFlow.size(),
                   "nominal1 size is different from redemption1 size");

        QL_REQUIRE(nominal2.size() == leg2ResetDates.size(),
                   "nominal2 size is different from resetDates2 size");
        QL_REQUIRE(nominal2.size() == leg2FixingDates.size(),
                   "nominal2 size is different from fixingDates2 size");
        QL_REQUIRE(nominal2.size() == leg2PayDates.size(),
                   "nominal2 size is different from payDates2 size");
        QL_REQUIRE(nominal2.size() == leg2Spreads.size(),
                   "nominal2 size is different from spreads2 size");
        QL_REQUIRE(nominal2.size() == leg2Gearings.size(),
                   "nominal2 size is different from gearings2 size");
        QL_REQUIRE(nominal2.size() == leg2CappedRates.size(),
                   "nominal2 size is different from cappedRates2 size");
        QL_REQUIRE(nominal2.size() == leg2FlooredRates.size(),
                   "nominal2 size is different from flooredRates2 size");
        QL_REQUIRE(nominal2.size() == leg2Coupons.size(),
                   "nominal2 size is different from coupons2 size");
        QL_REQUIRE(nominal2.size() == leg2AccrualTimes.size(),
                   "nominal2 size is different from accrualTimes2 size");
        QL_REQUIRE(nominal2.size() == leg2IsRedemptionFlow.size(),
                   "nominal2 size is different from redemption2 size");

        QL_REQUIRE(index1 != nullptr, "index1 is null");
        QL_REQUIRE(index2 != nullptr, "index2 is null");
    }

    void FloatFloatSwap::results::reset() { Swap::results::reset(); }
}
]]></document_content>
  </document>
  <document index="35">
    <source>floatfloatswaption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2018 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/instruments/floatfloatswaption.hpp>
#include <utility>

namespace QuantLib {

    FloatFloatSwaption::FloatFloatSwaption(ext::shared_ptr<FloatFloatSwap> swap,
                                           const ext::shared_ptr<Exercise>& exercise,
                                           Settlement::Type delivery,
                                           Settlement::Method settlementMethod)
    : Option(ext::shared_ptr<Payoff>(), exercise), swap_(std::move(swap)),
      settlementType_(delivery), settlementMethod_(settlementMethod) {
        registerWith(swap_);
        // When we ask for the NPV of an expired swaption, the
        // swap is not recalculated and thus wouldn't forward
        // later notifications according to the default behavior of
        // LazyObject instances.  This means that even if the
        // evaluation date changes so that the swaption is no longer
        // expired, the instrument wouldn't be notified and thus it
        // wouldn't recalculate.  To avoid this, we override the
        // default behavior of the underlying swap.
        swap_->alwaysForwardNotifications();
    }

    bool FloatFloatSwaption::isExpired() const {
        return detail::simple_event(exercise_->dates().back()).hasOccurred();
    }

    void
    FloatFloatSwaption::setupArguments(PricingEngine::arguments *args) const {

        swap_->setupArguments(args);

        auto* arguments = dynamic_cast<FloatFloatSwaption::arguments*>(args);

        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->swap = swap_;
        arguments->exercise = exercise_;
        arguments->settlementType = settlementType_;
        arguments->settlementMethod = settlementMethod_;
    }

    void FloatFloatSwaption::arguments::validate() const {
        FloatFloatSwap::arguments::validate();
        QL_REQUIRE(swap, "underlying cms swap not set");
        QL_REQUIRE(exercise, "exercise not set");
        Settlement::checkTypeAndMethodConsistency(settlementType,
                                                  settlementMethod);
    }

    std::vector<ext::shared_ptr<BlackCalibrationHelper>>
    FloatFloatSwaption::calibrationBasket(
        const ext::shared_ptr<SwapIndex>& standardSwapBase,
        const ext::shared_ptr<SwaptionVolatilityStructure>& swaptionVolatility,
        const BasketGeneratingEngine::CalibrationBasketType basketType) const {

        ext::shared_ptr<BasketGeneratingEngine> engine =
            ext::dynamic_pointer_cast<BasketGeneratingEngine>(engine_);
        QL_REQUIRE(engine, "engine is not a basket generating engine");
        engine_->reset();
        setupArguments(engine_->getArguments());
        engine_->getArguments()->validate();
        return engine->calibrationBasket(exercise_, standardSwapBase,
                                         swaptionVolatility, basketType);
    }

}
]]></document_content>
  </document>
  <document index="36">
    <source>forward.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/event.hpp>
#include <ql/instruments/forward.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    Forward::Forward(DayCounter dayCounter,
                     Calendar calendar,
                     BusinessDayConvention businessDayConvention,
                     Natural settlementDays,
                     ext::shared_ptr<Payoff> payoff,
                     const Date& valueDate,
                     const Date& maturityDate,
                     Handle<YieldTermStructure> discountCurve)
    : dayCounter_(std::move(dayCounter)), calendar_(std::move(calendar)),
      businessDayConvention_(businessDayConvention), settlementDays_(settlementDays),
      payoff_(std::move(payoff)), valueDate_(valueDate), maturityDate_(maturityDate),
      discountCurve_(std::move(discountCurve)) {

        maturityDate_ = calendar_.adjust(maturityDate_,
                                         businessDayConvention_);

        registerWith(Settings::instance().evaluationDate());
        registerWith(discountCurve_);
    }


    Date Forward::settlementDate() const {
        Date d = calendar_.advance(Settings::instance().evaluationDate(),
                                   settlementDays_, Days);
        return std::max(d,valueDate_);
    }


    bool Forward::isExpired() const {
        return detail::simple_event(maturityDate_)
               .hasOccurred(settlementDate());
    }


    Real Forward::forwardValue() const {
        calculate();
        return (underlyingSpotValue_ - underlyingIncome_ )/
               discountCurve_->discount(maturityDate_);
    }


    InterestRate Forward::impliedYield(Real underlyingSpotValue,
                                       Real forwardValue,
                                       Date settlementDate,
                                       Compounding comp,
                                       const DayCounter& dayCounter) {

        Time t = dayCounter.yearFraction(settlementDate,maturityDate_) ;
        Real compoundingFactor = forwardValue/
            (underlyingSpotValue-spotIncome(incomeDiscountCurve_)) ;
        return InterestRate::impliedRate(compoundingFactor,
                                         dayCounter, comp, Annual,
                                         t);
    }


    void Forward::performCalculations() const {

        QL_REQUIRE(!discountCurve_.empty(),
                   "null term structure set to Forward");

        ext::shared_ptr<ForwardTypePayoff> ftpayoff =
            ext::dynamic_pointer_cast<ForwardTypePayoff>(payoff_);
        Real fwdValue = forwardValue();
        NPV_ = (*ftpayoff)(fwdValue) * discountCurve_->discount(maturityDate_);
    }

}
]]></document_content>
  </document>
  <document index="37">
    <source>forwardrateagreement.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license. You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/event.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/instruments/forwardrateagreement.hpp>
#include <utility>
#include <iostream>

namespace QuantLib {

    ForwardRateAgreement::ForwardRateAgreement(const ext::shared_ptr<IborIndex>& index,
                                               const Date& valueDate,
                                               Position::Type type,
                                               Rate strikeForwardRate,
                                               Real notionalAmount,
                                               Handle<YieldTermStructure> discountCurve)
    : ForwardRateAgreement(index, valueDate, index->maturityDate(valueDate), type,
                           strikeForwardRate, notionalAmount, std::move(discountCurve)) {
        useIndexedCoupon_ = true;
    }

    ForwardRateAgreement::ForwardRateAgreement(const ext::shared_ptr<IborIndex>& index,
                                               const Date& valueDate,
                                               const Date& maturityDate,
                                               Position::Type type,
                                               Rate strikeForwardRate,
                                               Real notionalAmount,
                                               Handle<YieldTermStructure> discountCurve)
    : fraType_(type), notionalAmount_(notionalAmount), index_(index),
      useIndexedCoupon_(false), dayCounter_(index->dayCounter()),
      calendar_(index->fixingCalendar()), businessDayConvention_(index->businessDayConvention()),
      valueDate_(valueDate), maturityDate_(maturityDate),
      discountCurve_(std::move(discountCurve)) {

        maturityDate_ = calendar_.adjust(maturityDate_, businessDayConvention_);

        registerWith(Settings::instance().evaluationDate());
        registerWith(discountCurve_);

        QL_REQUIRE(notionalAmount > 0.0, "notionalAmount must be positive");
        QL_REQUIRE(valueDate_ < maturityDate_, "valueDate must be earlier than maturityDate");

        strikeForwardRate_ = InterestRate(strikeForwardRate,
                                          index->dayCounter(),
                                          Simple, Once);
        registerWith(index_);
    }

    Date ForwardRateAgreement::fixingDate() const {
        return index_->fixingDate(valueDate_);
    }

    bool ForwardRateAgreement::isExpired() const {
        return detail::simple_event(valueDate_).hasOccurred();
    }

    Real ForwardRateAgreement::amount() const {
        calculate();
        return amount_;
    }

    InterestRate ForwardRateAgreement::forwardRate() const {
        calculate();
        return forwardRate_;
    }

    void ForwardRateAgreement::setupExpired() const {
        Instrument::setupExpired();
        calculateForwardRate();
    }

    void ForwardRateAgreement::performCalculations() const {
        calculateAmount();
        Handle<YieldTermStructure> discount =
            discountCurve_.empty() ? index_->forwardingTermStructure() : discountCurve_;
        NPV_ = amount_ * discount->discount(valueDate_);
    }

    void ForwardRateAgreement::calculateForwardRate() const {
        if (useIndexedCoupon_)
            forwardRate_ =
                InterestRate(index_->fixing(fixingDate()), index_->dayCounter(), Simple, Once);
        else
            // par coupon approximation
            forwardRate_ =
                InterestRate((index_->forwardingTermStructure()->discount(valueDate_) /
                                  index_->forwardingTermStructure()->discount(maturityDate_) -
                              1.0) /
                                 index_->dayCounter().yearFraction(valueDate_, maturityDate_),
                             index_->dayCounter(), Simple, Once);
    }

    void ForwardRateAgreement::calculateAmount() const {
        calculateForwardRate();
        Integer sign = fraType_ == Position::Long? 1 : -1;
        Rate F = forwardRate_.rate();
        Rate K = strikeForwardRate_.rate();
        Time T = forwardRate_.dayCounter().yearFraction(valueDate_, maturityDate_);
        amount_ = notionalAmount_ * sign * (F - K) * T / (1.0 + F * T);
    }

}
]]></document_content>
  </document>
  <document index="38">
    <source>forwardvanillaoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/forwardvanillaoption.hpp>

namespace QuantLib {

    ForwardVanillaOption::ForwardVanillaOption(
                           Real moneyness,
                           const Date& resetDate,
                           const ext::shared_ptr<StrikedTypePayoff>& payoff,
                           const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise),
      moneyness_(moneyness), resetDate_(resetDate) {}

    void ForwardVanillaOption::setupArguments(
                                       PricingEngine::arguments* args) const {
        OneAssetOption::setupArguments(args);
        auto* arguments = dynamic_cast<ForwardVanillaOption::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->moneyness = moneyness_;
        arguments->resetDate = resetDate_;

    }

    void ForwardVanillaOption::fetchResults(
                                      const PricingEngine::results* r) const {
        OneAssetOption::fetchResults(r);
        const auto* results = dynamic_cast<const ForwardVanillaOption::results*>(r);
        QL_ENSURE(results != nullptr, "no results returned from pricing engine");
        delta_       = results->delta;
        gamma_       = results->gamma;
        theta_       = results->theta;
        vega_        = results->vega;
        rho_         = results->rho;
        dividendRho_ = results->dividendRho;
    }

}

]]></document_content>
  </document>
  <document index="39">
    <source>futures.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2015 Ferdinando Ametrano
Copyright (C) 2015 Maddalena Zanzi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/futures.hpp>
#include <ql/types.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    std::ostream& operator<<(std::ostream& out, Futures::Type f) {
        switch (f) {
          case Futures::IMM:
            return out << "IMM";
          case Futures::ASX:
            return out << "ASX";
          case Futures::Custom:
            return out << "Custom";
          default:
            return out << "Unknown(" << Integer(f) << ')';
        }
    }

}
]]></document_content>
  </document>
  <document index="40">
    <source>holderextensibleoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/holderextensibleoption.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    HolderExtensibleOption::HolderExtensibleOption(
                           Option::Type type,
                           Real premium,
                           Date secondExpiryDate,
                           Real secondStrike,
                           const ext::shared_ptr<StrikedTypePayoff>& payoff,
                           const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff,exercise),
      premium_(premium),
      secondExpiryDate_(secondExpiryDate),
      secondStrike_(secondStrike) {}

    void HolderExtensibleOption::setupArguments(
                                       PricingEngine::arguments* args) const {
        OneAssetOption::setupArguments(args);
        auto* moreArgs = dynamic_cast<HolderExtensibleOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->premium = premium_;
        moreArgs->secondExpiryDate = secondExpiryDate_;
        moreArgs->secondStrike = secondStrike_;
    }

    void HolderExtensibleOption:: arguments::validate() const {
        OneAssetOption::arguments::validate();
        QL_REQUIRE(premium > 0,"negative premium not allowed");
        QL_REQUIRE(secondExpiryDate != Date() , "no extending date given");
        QL_REQUIRE(secondExpiryDate >= exercise->lastDate(),
                   "extended date is earlier than or equal to first maturity date");
    }

}
]]></document_content>
  </document>
  <document index="41">
    <source>impliedvolatility.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/impliedvolatility.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/math/solvers1d/brent.hpp>

namespace QuantLib {

    namespace {

        class PriceError {
          public:
            PriceError(const PricingEngine& engine,
                       SimpleQuote& vol,
                       Real targetValue);
            Real operator()(Volatility x) const;
          private:
            const PricingEngine& engine_;
            SimpleQuote& vol_;
            Real targetValue_;
            const Instrument::results* results_;
        };

        PriceError::PriceError(const PricingEngine& engine,
                               SimpleQuote& vol,
                               Real targetValue)
        : engine_(engine), vol_(vol), targetValue_(targetValue) {
            results_ =
                dynamic_cast<const Instrument::results*>(engine_.getResults());
            QL_REQUIRE(results_ != nullptr, "pricing engine does not supply needed results");
        }

        Real PriceError::operator()(Volatility x) const {
            vol_.setValue(x);
            engine_.calculate();
            return results_->value-targetValue_;
        }

    }


    namespace detail {

        Volatility ImpliedVolatilityHelper::calculate(
                                                 const Instrument& instrument,
                                                 const PricingEngine& engine,
                                                 SimpleQuote& volQuote,
                                                 Real targetValue,
                                                 Real accuracy,
                                                 Natural maxEvaluations,
                                                 Volatility minVol,
                                                 Volatility maxVol) {

            instrument.setupArguments(engine.getArguments());
            engine.getArguments()->validate();

            PriceError f(engine, volQuote, targetValue);
            Brent solver;
            solver.setMaxEvaluations(maxEvaluations);
            Volatility guess = (minVol+maxVol)/2.0;
            Volatility result = solver.solve(f, accuracy, guess,
                                             minVol, maxVol);
            return result;
        }

        ext::shared_ptr<GeneralizedBlackScholesProcess>
        ImpliedVolatilityHelper::clone(
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             const ext::shared_ptr<SimpleQuote>& volQuote) {

            Handle<Quote> stateVariable = process->stateVariable();
            Handle<YieldTermStructure> dividendYield = process->dividendYield();
            Handle<YieldTermStructure> riskFreeRate = process->riskFreeRate();

            Handle<BlackVolTermStructure> blackVol = process->blackVolatility();
            Handle<BlackVolTermStructure> volatility(
                ext::shared_ptr<BlackVolTermStructure>(
                               new BlackConstantVol(blackVol->referenceDate(),
                                                    blackVol->calendar(),
                                                    Handle<Quote>(volQuote),
                                                    blackVol->dayCounter())));

            return ext::make_shared<GeneralizedBlackScholesProcess>(
                stateVariable, dividendYield,
                                                   riskFreeRate, volatility);
        }

    }

}
]]></document_content>
  </document>
  <document index="42">
    <source>inflationcapfloor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/cashflows/cashflows.hpp>
#include <ql/instruments/inflationcapfloor.hpp>
#include <ql/math/solvers1d/newtonsafe.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <utility>

namespace QuantLib {


    std::ostream& operator<<(std::ostream& out,
                             YoYInflationCapFloor::Type t) {
        switch (t) {
            case YoYInflationCapFloor::Cap:
                return out << "YoYInflationCap";
            case YoYInflationCapFloor::Floor:
                return out << "YoYInflationFloor";
            case YoYInflationCapFloor::Collar:
                return out << "YoYInflationCollar";
            default:
                QL_FAIL("unknown YoYInflationCapFloor::Type (" << Integer(t) << ")");
        }
    }

    YoYInflationCapFloor::YoYInflationCapFloor(YoYInflationCapFloor::Type type,
                                               Leg yoyLeg,
                                               std::vector<Rate> capRates,
                                               std::vector<Rate> floorRates)
    : type_(type), yoyLeg_(std::move(yoyLeg)), capRates_(std::move(capRates)),
      floorRates_(std::move(floorRates)) {
        if (type_ == Cap || type_ == Collar) {
            QL_REQUIRE(!capRates_.empty(), "no cap rates given");
            capRates_.reserve(yoyLeg_.size());
            while (capRates_.size() < yoyLeg_.size())
                capRates_.push_back(capRates_.back());
        }
        if (type_ == Floor || type_ == Collar) {
            QL_REQUIRE(!floorRates_.empty(), "no floor rates given");
            floorRates_.reserve(yoyLeg_.size());
            while (floorRates_.size() < yoyLeg_.size())
                floorRates_.push_back(floorRates_.back());
        }
        Leg::const_iterator i;
        for (i = yoyLeg_.begin(); i != yoyLeg_.end(); ++i)
            registerWith(*i);

        registerWith(Settings::instance().evaluationDate());
    }

    YoYInflationCapFloor::YoYInflationCapFloor(YoYInflationCapFloor::Type type,
                                               Leg yoyLeg,
                                               const std::vector<Rate>& strikes)
    : type_(type), yoyLeg_(std::move(yoyLeg)) {
        QL_REQUIRE(!strikes.empty(), "no strikes given");
        if (type_ == Cap) {
            capRates_ = strikes;
            capRates_.reserve(yoyLeg_.size());
            while (capRates_.size() < yoyLeg_.size())
                capRates_.push_back(capRates_.back());
        } else if (type_ == Floor) {
            floorRates_ = strikes;
            floorRates_.reserve(yoyLeg_.size());
            while (floorRates_.size() < yoyLeg_.size())
                floorRates_.push_back(floorRates_.back());
        } else
            QL_FAIL("only Cap/Floor types allowed in this constructor");

        Leg::const_iterator i;
        for (i = yoyLeg_.begin(); i != yoyLeg_.end(); ++i)
            registerWith(*i);

        registerWith(Settings::instance().evaluationDate());
    }

    bool YoYInflationCapFloor::isExpired() const {
        for (Size i=yoyLeg_.size(); i>0; --i)
            if (!yoyLeg_[i-1]->hasOccurred())
                return false;
        return true;
    }

    Date YoYInflationCapFloor::startDate() const {
        return CashFlows::startDate(yoyLeg_);
    }

    Date YoYInflationCapFloor::maturityDate() const {
        return CashFlows::maturityDate(yoyLeg_);
    }

    ext::shared_ptr<YoYInflationCoupon>
    YoYInflationCapFloor::lastYoYInflationCoupon() const {
        ext::shared_ptr<CashFlow> lastCF(yoyLeg_.back());
        ext::shared_ptr<YoYInflationCoupon> lastYoYInflationCoupon =
        ext::dynamic_pointer_cast<YoYInflationCoupon>(lastCF);
        return lastYoYInflationCoupon;
    }

    ext::shared_ptr<YoYInflationCapFloor> YoYInflationCapFloor::optionlet(const Size i) const {
        QL_REQUIRE(i < yoyLeg().size(),
                   io::ordinal(i+1) << " optionlet does not exist, only " <<
                   yoyLeg().size());
        Leg cf(1, yoyLeg()[i]);

        std::vector<Rate> cap, floor;
        if (type() == Cap || type() == Collar)
            cap.push_back(capRates()[i]);
        if (type() == Floor || type() == Collar)
            floor.push_back(floorRates()[i]);

        return ext::make_shared<YoYInflationCapFloor>(type(),
                                                    cf, cap, floor);
    }

    void YoYInflationCapFloor::setupArguments(PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<YoYInflationCapFloor::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        Size n = yoyLeg_.size();

        arguments->startDates.resize(n);
        arguments->fixingDates.resize(n);
        arguments->payDates.resize(n);
        arguments->accrualTimes.resize(n);
        arguments->nominals.resize(n);
        arguments->gearings.resize(n);
        arguments->capRates.resize(n);
        arguments->floorRates.resize(n);
        arguments->spreads.resize(n);

        arguments->type = type_;

        for (Size i=0; i<n; ++i) {
            ext::shared_ptr<YoYInflationCoupon> coupon =
            ext::dynamic_pointer_cast<YoYInflationCoupon>(
                                                            yoyLeg_[i]);
            QL_REQUIRE(coupon, "non-YoYInflationCoupon given");
            arguments->startDates[i] = coupon->accrualStartDate();
            arguments->fixingDates[i] = coupon->fixingDate();
            arguments->payDates[i] = coupon->date();

            // this is passed explicitly for precision
            arguments->accrualTimes[i] = coupon->accrualPeriod();

            arguments->nominals[i] = coupon->nominal();
            Spread spread = coupon->spread();
            Real gearing = coupon->gearing();
            arguments->gearings[i] = gearing;
            arguments->spreads[i] = spread;

            if (type_ == Cap || type_ == Collar)
                arguments->capRates[i] = (capRates_[i]-spread)/gearing;
            else
                arguments->capRates[i] = Null<Rate>();

            if (type_ == Floor || type_ == Collar)
                arguments->floorRates[i] = (floorRates_[i]-spread)/gearing;
            else
                arguments->floorRates[i] = Null<Rate>();
        }
    }

    void YoYInflationCapFloor::arguments::validate() const {
        QL_REQUIRE(payDates.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of pay dates ("
                   << payDates.size() << ")");
        QL_REQUIRE(accrualTimes.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of accrual times ("
                   << accrualTimes.size() << ")");
        QL_REQUIRE(type == YoYInflationCapFloor::Floor ||
                   capRates.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of cap rates ("
                   << capRates.size() << ")");
        QL_REQUIRE(type == YoYInflationCapFloor::Cap ||
                   floorRates.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of floor rates ("
                   << floorRates.size() << ")");
        QL_REQUIRE(gearings.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of gearings ("
                   << gearings.size() << ")");
        QL_REQUIRE(spreads.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of spreads ("
                   << spreads.size() << ")");
        QL_REQUIRE(nominals.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of nominals ("
                   << nominals.size() << ")");
    }

    Rate YoYInflationCapFloor::atmRate(const YieldTermStructure& discountCurve) const {
        return CashFlows::atmRate(yoyLeg_, discountCurve,
                                  false, discountCurve.referenceDate());
    }


}
]]></document_content>
  </document>
  <document index="43">
    <source>lookbackoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/lookbackoption.hpp>

namespace QuantLib {

    ContinuousFloatingLookbackOption::ContinuousFloatingLookbackOption(
        Real minmax,
        const ext::shared_ptr<TypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise),
      minmax_(minmax) {}

    void ContinuousFloatingLookbackOption::setupArguments(
                                       PricingEngine::arguments* args) const {

        OneAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<ContinuousFloatingLookbackOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->minmax = minmax_;
    }

    void ContinuousFloatingLookbackOption::arguments::validate() const {

        OneAssetOption::arguments::validate();

        QL_REQUIRE(minmax != Null<Real>(), "null prior extremum");
        QL_REQUIRE(minmax >= 0.0, "nonnegative prior extremum required: "
                   << minmax << " not allowed");
    }


    ContinuousFixedLookbackOption::ContinuousFixedLookbackOption(
        Real minmax,
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise),
      minmax_(minmax) {}

    void ContinuousFixedLookbackOption::setupArguments(
                                       PricingEngine::arguments* args) const {

        OneAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<ContinuousFixedLookbackOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->minmax = minmax_;
    }

    void ContinuousFixedLookbackOption::arguments::validate() const {

        OneAssetOption::arguments::validate();

        QL_REQUIRE(minmax != Null<Real>(), "null prior extremum");
        QL_REQUIRE(minmax >= 0.0, "nonnegative prior extremum required: "
                   << minmax << " not allowed");
    }

    ContinuousPartialFloatingLookbackOption::ContinuousPartialFloatingLookbackOption(
        Real minmax,
        Real lambda,
        Date lookbackPeriodEnd,
        const ext::shared_ptr<TypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : ContinuousFloatingLookbackOption(minmax, payoff, exercise),
      lambda_(lambda),
      lookbackPeriodEnd_(lookbackPeriodEnd) {}

    void ContinuousPartialFloatingLookbackOption::setupArguments(
                                       PricingEngine::arguments* args) const {

        ContinuousFloatingLookbackOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<ContinuousPartialFloatingLookbackOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->lambda = lambda_;
        moreArgs->lookbackPeriodEnd = lookbackPeriodEnd_;
    }

    void ContinuousPartialFloatingLookbackOption::arguments::validate() const {

        ContinuousFloatingLookbackOption::arguments::validate();

        ext::shared_ptr<EuropeanExercise> europeanExercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(exercise);
        QL_REQUIRE(lookbackPeriodEnd <= europeanExercise->lastDate(), 
            "lookback start date must be earlier than exercise date");
        
        ext::shared_ptr<FloatingTypePayoff> floatingTypePayoff =
            ext::dynamic_pointer_cast<FloatingTypePayoff>(payoff);
        
        if (floatingTypePayoff->optionType() == Option::Call) {
            QL_REQUIRE(lambda >= 1.0,
                       "lambda should be greater than or equal to 1 for calls");
        }
        if (floatingTypePayoff->optionType() == Option::Put) {
            QL_REQUIRE(lambda <= 1.0,
                       "lambda should be smaller than or equal to 1 for puts");
        }
    }

    ContinuousPartialFixedLookbackOption::ContinuousPartialFixedLookbackOption(
        Date lookbackPeriodStart,
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : ContinuousFixedLookbackOption(0, payoff, exercise),
      lookbackPeriodStart_(lookbackPeriodStart) {}

    void ContinuousPartialFixedLookbackOption::setupArguments(
                                       PricingEngine::arguments* args) const {

        ContinuousFixedLookbackOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<ContinuousPartialFixedLookbackOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->lookbackPeriodStart = lookbackPeriodStart_;
    }

    void ContinuousPartialFixedLookbackOption::arguments::validate() const {

        ContinuousFixedLookbackOption::arguments::validate();

        ext::shared_ptr<EuropeanExercise> europeanExercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(exercise);
        QL_REQUIRE(lookbackPeriodStart <= europeanExercise->lastDate(), 
            "lookback start date must be earlier than exercise date");
    }
}

]]></document_content>
  </document>
  <document index="44">
    <source>makecapfloor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/makecapfloor.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/pricingengines/capfloor/blackcapfloorengine.hpp>

namespace QuantLib {

    MakeCapFloor::MakeCapFloor(CapFloor::Type capFloorType,
                               const Period& tenor,
                               const ext::shared_ptr<IborIndex>& iborIndex,
                               Rate strike,
                               const Period& forwardStart)
    : capFloorType_(capFloorType), strike_(strike), firstCapletExcluded_(forwardStart == 0 * Days),
      // setting the fixed leg tenor avoids that MakeVanillaSwap throws
      // because of an unknown fixed leg default tenor for a currency,
      // notice that only the floating leg of the swap is used anyway
      makeVanillaSwap_(MakeVanillaSwap(tenor, iborIndex, 0.0, forwardStart)
                           .withFixedLegTenor(1 * Years)
                           .withFixedLegDayCount(Actual365Fixed())) {}

    MakeCapFloor::operator CapFloor() const {
        ext::shared_ptr<CapFloor> capfloor = *this;
        return *capfloor;
    }

    MakeCapFloor::operator ext::shared_ptr<CapFloor>() const {

        VanillaSwap swap = makeVanillaSwap_;

        Leg leg = swap.floatingLeg();
        if (firstCapletExcluded_)
            leg.erase(leg.begin());

        // only leaves the last coupon
        if (asOptionlet_ && leg.size() > 1) {
            auto end = leg.end(); // Sun Studio needs an lvalue
            leg.erase(leg.begin(), --end);
        }

        std::vector<Rate> strikeVector(1, strike_);
        if (strike_ == Null<Rate>()) {

            // temporary patch...
            // should be fixed for every CapFloor::Engine
            ext::shared_ptr<BlackCapFloorEngine> temp = 
                ext::dynamic_pointer_cast<BlackCapFloorEngine>(engine_);
            QL_REQUIRE(temp,
                       "cannot calculate ATM without a BlackCapFloorEngine");
            Handle<YieldTermStructure> discountCurve = temp->termStructure();
            strikeVector[0] = CashFlows::atmRate(leg,
                                                 **discountCurve,
                                                 false,
                                                 discountCurve->referenceDate());
        }

        ext::shared_ptr<CapFloor> capFloor(new
            CapFloor(capFloorType_, leg, strikeVector));
        capFloor->setPricingEngine(engine_);
        return capFloor;
    }

    MakeCapFloor& MakeCapFloor::withNominal(Real n) {
        makeVanillaSwap_.withNominal(n);
        return *this;
    }

    MakeCapFloor& MakeCapFloor::withEffectiveDate(const Date& effectiveDate,
                                                  bool firstCapletExcluded) {
        makeVanillaSwap_.withEffectiveDate(effectiveDate);
        firstCapletExcluded_ = firstCapletExcluded;
        return *this;
    }

    MakeCapFloor& MakeCapFloor::withTenor(const Period& t) {
        makeVanillaSwap_.withFloatingLegTenor(t);
        return *this;
    }


    MakeCapFloor& MakeCapFloor::withCalendar(const Calendar& cal) {
        makeVanillaSwap_.withFloatingLegCalendar(cal);
        return *this;
    }


    MakeCapFloor& MakeCapFloor::withConvention(BusinessDayConvention bdc) {
        makeVanillaSwap_.withFloatingLegConvention(bdc);
        return *this;
    }


    MakeCapFloor&
    MakeCapFloor::withTerminationDateConvention(BusinessDayConvention bdc) {
        makeVanillaSwap_.withFloatingLegTerminationDateConvention(bdc);
        return *this;
    }


    MakeCapFloor& MakeCapFloor::withRule(DateGeneration::Rule r) {
        makeVanillaSwap_.withFloatingLegRule(r);
        return *this;
    }

    MakeCapFloor& MakeCapFloor::withEndOfMonth(bool flag) {
        makeVanillaSwap_.withFloatingLegEndOfMonth(flag);
        return *this;
    }


    MakeCapFloor& MakeCapFloor::withFirstDate(const Date& d) {
        makeVanillaSwap_.withFloatingLegFirstDate(d);
        return *this;
    }

    MakeCapFloor& MakeCapFloor::withNextToLastDate(const Date& d) {
        makeVanillaSwap_.withFloatingLegNextToLastDate(d);
        return *this;
    }

    MakeCapFloor& MakeCapFloor::withDayCount(const DayCounter& dc) {
        makeVanillaSwap_.withFloatingLegDayCount(dc);
        return *this;
    }

    MakeCapFloor& MakeCapFloor::asOptionlet(bool b) {
        asOptionlet_ = b;
        return *this;
    }

    MakeCapFloor& MakeCapFloor::withPricingEngine(
                             const ext::shared_ptr<PricingEngine>& engine) {
        engine_ = engine;
        return *this;
    }

}

]]></document_content>
  </document>
  <document index="45">
    <source>makecds.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/makecds.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/calendars/weekendsonly.hpp>


namespace QuantLib {

    MakeCreditDefaultSwap::MakeCreditDefaultSwap(const Period &tenor,
                                                 const Real couponRate)
        : side_(Protection::Buyer), nominal_(1.0), tenor_(tenor),
          couponTenor_(3 * Months), couponRate_(couponRate), upfrontRate_(0.0),
          dayCounter_(Actual360()), lastPeriodDayCounter_(Actual360(true)),
          rule_(DateGeneration::CDS), cashSettlementDays_(3) {}

    MakeCreditDefaultSwap::MakeCreditDefaultSwap(const Date &termDate,
                                                 const Real couponRate)
        : side_(Protection::Buyer), nominal_(1.0), termDate_(termDate),
          couponTenor_(3 * Months), couponRate_(couponRate), upfrontRate_(0.0),
          dayCounter_(Actual360()), lastPeriodDayCounter_(Actual360(true)),
          rule_(DateGeneration::CDS), cashSettlementDays_(3) {}

    MakeCreditDefaultSwap::operator CreditDefaultSwap() const {
        ext::shared_ptr<CreditDefaultSwap> swap = *this;
        return *swap;
    }

    MakeCreditDefaultSwap::operator ext::shared_ptr<CreditDefaultSwap>() const {

        Date tradeDate = (tradeDate_ != Date()) ? tradeDate_ : Settings::instance().evaluationDate();
        Date upfrontDate = WeekendsOnly().advance(tradeDate, cashSettlementDays_, Days);

        Date protectionStart;
        if (rule_ == DateGeneration::CDS2015 || rule_ == DateGeneration::CDS) {
            protectionStart = tradeDate;
        } else {
            protectionStart = tradeDate + 1;
        }

        Date end;
        if (tenor_) { // NOLINT(readability-implicit-bool-conversion)
            if (rule_ == DateGeneration::CDS2015 || rule_ == DateGeneration::CDS || rule_ == DateGeneration::OldCDS) {
                end = cdsMaturity(tradeDate, *tenor_, rule_);
            } else {
                end = tradeDate + *tenor_;
            }
        } else {
            // we have two exclusive constructors; if we don't have a tenor, we have a term date
            end = *termDate_; // NOLINT(bugprone-unchecked-optional-access)
        }

        Schedule schedule(protectionStart, end, couponTenor_, WeekendsOnly(), Following,
                          Unadjusted, rule_, false);

        ext::shared_ptr<CreditDefaultSwap> cds =
            ext::make_shared<CreditDefaultSwap>(
                side_, nominal_, upfrontRate_, couponRate_, schedule, Following,
                dayCounter_, true, true, protectionStart, upfrontDate,
                ext::shared_ptr<Claim>(), lastPeriodDayCounter_, true, tradeDate, cashSettlementDays_);

        cds->setPricingEngine(engine_);
        return cds;

    }

    MakeCreditDefaultSwap &
    MakeCreditDefaultSwap::withUpfrontRate(Real upfrontRate) {
        upfrontRate_ = upfrontRate;
        return *this;
    }

    MakeCreditDefaultSwap &
    MakeCreditDefaultSwap::withSide(Protection::Side side) {
        side_ = side;
        return *this;
    }

    MakeCreditDefaultSwap &MakeCreditDefaultSwap::withNominal(Real nominal) {
        nominal_ = nominal;
        return *this;
    }

    MakeCreditDefaultSwap &
    MakeCreditDefaultSwap::withCouponTenor(Period couponTenor) {
        couponTenor_ = couponTenor;
        return *this;
    }

    MakeCreditDefaultSwap &
    MakeCreditDefaultSwap::withDayCounter(DayCounter &dayCounter) {
        dayCounter_ = dayCounter;
        return *this;
    }

    MakeCreditDefaultSwap &MakeCreditDefaultSwap::withLastPeriodDayCounter(
        DayCounter &lastPeriodDayCounter) {
        lastPeriodDayCounter_ = lastPeriodDayCounter;
        return *this;
    }

    MakeCreditDefaultSwap& MakeCreditDefaultSwap::withDateGenerationRule(DateGeneration::Rule rule) {
        rule_ = rule;
        return *this;
    }

    MakeCreditDefaultSwap& MakeCreditDefaultSwap::withCashSettlementDays(Natural cashSettlementDays) {
        cashSettlementDays_ = cashSettlementDays;
        return *this;
    }

    MakeCreditDefaultSwap &MakeCreditDefaultSwap::withPricingEngine(
        const ext::shared_ptr<PricingEngine> &engine) {
        engine_ = engine;
        return *this;
    }

    MakeCreditDefaultSwap& MakeCreditDefaultSwap::withTradeDate(const Date& tradeDate) {
        tradeDate_ = tradeDate;
        return *this;
    }

}
]]></document_content>
  </document>
  <document index="46">
    <source>makecms.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007, 2014 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/makecms.hpp>
#include <ql/instruments/swap.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/time/schedule.hpp>
#include <ql/time/daycounters/actual360.hpp>

namespace QuantLib {

    MakeCms::MakeCms(const Period& swapTenor,
                     const ext::shared_ptr<SwapIndex>& swapIndex,
                     const ext::shared_ptr<IborIndex>& iborIndex,
                     Spread iborSpread,
                     const Period& forwardStart)
    : swapTenor_(swapTenor), swapIndex_(swapIndex), iborIndex_(iborIndex), iborSpread_(iborSpread),
      useAtmSpread_(false), forwardStart_(forwardStart),

      cmsSpread_(0.0), cmsGearing_(1.0), cmsCap_(Null<Real>()), cmsFloor_(Null<Real>()),


      cmsCalendar_(swapIndex->fixingCalendar()), floatCalendar_(iborIndex->fixingCalendar()),
      payCms_(true), nominal_(1.0), cmsTenor_(3 * Months), floatTenor_(iborIndex->tenor()),
      cmsConvention_(ModifiedFollowing), cmsTerminationDateConvention_(ModifiedFollowing),
      floatConvention_(iborIndex->businessDayConvention()),
      floatTerminationDateConvention_(iborIndex->businessDayConvention()),
      cmsRule_(DateGeneration::Backward), floatRule_(DateGeneration::Backward),
      cmsEndOfMonth_(false), floatEndOfMonth_(false),

      cmsDayCount_(Actual360()), floatDayCount_(iborIndex->dayCounter()),
      // arbitrary choice:
      // engine_(new DiscountingSwapEngine(iborIndex->termStructure())),
      engine_(new DiscountingSwapEngine(swapIndex->forwardingTermStructure())) {}


    MakeCms::MakeCms(const Period& swapTenor,
                     const ext::shared_ptr<SwapIndex>& swapIndex,
                     Spread iborSpread,
                     const Period& forwardStart)
    : swapTenor_(swapTenor), swapIndex_(swapIndex), iborIndex_(swapIndex->iborIndex()),
      iborSpread_(iborSpread), useAtmSpread_(false), forwardStart_(forwardStart),

      cmsSpread_(0.0), cmsGearing_(1.0), cmsCap_(Null<Real>()), cmsFloor_(Null<Real>()),


      cmsCalendar_(swapIndex->fixingCalendar()), floatCalendar_(iborIndex_->fixingCalendar()),
      payCms_(true), nominal_(1.0), cmsTenor_(3 * Months), floatTenor_(iborIndex_->tenor()),
      cmsConvention_(ModifiedFollowing), cmsTerminationDateConvention_(ModifiedFollowing),
      floatConvention_(iborIndex_->businessDayConvention()),
      floatTerminationDateConvention_(iborIndex_->businessDayConvention()),
      cmsRule_(DateGeneration::Backward), floatRule_(DateGeneration::Backward),
      cmsEndOfMonth_(false), floatEndOfMonth_(false),

      cmsDayCount_(Actual360()), floatDayCount_(iborIndex_->dayCounter()),
      engine_(new DiscountingSwapEngine(swapIndex->forwardingTermStructure())) {}


    MakeCms::operator Swap() const {
        ext::shared_ptr<Swap> swap = *this;
        return *swap;
    }

    MakeCms::operator ext::shared_ptr<Swap>() const {

        Date startDate;
        if (effectiveDate_ != Date())
            startDate = effectiveDate_;
        else {
            Natural fixingDays = iborIndex_->fixingDays();
            Date refDate = Settings::instance().evaluationDate();
            // if the evaluation date is not a business day
            // then move to the next business day
            refDate = floatCalendar_.adjust(refDate);
            Date spotDate = floatCalendar_.advance(refDate,
                                                   fixingDays*Days);
            startDate = spotDate+forwardStart_;
        }

        Date terminationDate = startDate+swapTenor_;

        Schedule cmsSchedule(startDate, terminationDate,
                             cmsTenor_, cmsCalendar_,
                             cmsConvention_,
                             cmsTerminationDateConvention_,
                             cmsRule_, cmsEndOfMonth_,
                             cmsFirstDate_, cmsNextToLastDate_);

        Schedule floatSchedule(startDate, terminationDate,
                               floatTenor_, floatCalendar_,
                               floatConvention_,
                               floatTerminationDateConvention_,
                               floatRule_ , floatEndOfMonth_,
                               floatFirstDate_, floatNextToLastDate_);

        Leg cmsLeg = CmsLeg(cmsSchedule, swapIndex_)
            .withNotionals(nominal_)
            .withPaymentDayCounter(cmsDayCount_)
            .withPaymentAdjustment(cmsConvention_)
            .withFixingDays(swapIndex_->fixingDays())
            .withGearings(cmsGearing_)
            .withSpreads(cmsSpread_)
            .withCaps(cmsCap_)
            .withFloors(cmsFloor_);
        if (couponPricer_ != nullptr)
            setCouponPricer(cmsLeg, couponPricer_);

        Rate usedSpread = iborSpread_;
        if (useAtmSpread_) {
            QL_REQUIRE(!iborIndex_->forwardingTermStructure().empty(),
                       "null term structure set to this instance of " <<
                       iborIndex_->name());
            QL_REQUIRE(!swapIndex_->forwardingTermStructure().empty(),
                       "null term structure set to this instance of " <<
                       swapIndex_->name());
            QL_REQUIRE(couponPricer_,
                       "no CmsCouponPricer set (yet)");
            Leg floatLeg = IborLeg(floatSchedule, iborIndex_)
                .withNotionals(nominal_)
                .withPaymentDayCounter(floatDayCount_)
                .withPaymentAdjustment(floatConvention_)
                .withFixingDays(iborIndex_->fixingDays());

            Swap temp(cmsLeg, floatLeg);
            temp.setPricingEngine(engine_);

            Real npv = temp.legNPV(0)+temp.legNPV(1);

            usedSpread = -npv/temp.legBPS(1)*1e-4;
        } else {
            QL_REQUIRE(usedSpread != Null<Spread>(),
                       "null spread set");
        }

        Leg floatLeg = IborLeg(floatSchedule, iborIndex_)
            .withNotionals(nominal_)
            .withPaymentDayCounter(floatDayCount_)
            .withPaymentAdjustment(floatConvention_)
            .withFixingDays(iborIndex_->fixingDays())
            .withSpreads(usedSpread);

        ext::shared_ptr<Swap> swap;
        if (payCms_)
            swap = ext::make_shared<Swap>(cmsLeg, floatLeg);
        else
            swap = ext::make_shared<Swap>(floatLeg, cmsLeg);
        swap->setPricingEngine(engine_);
        return swap;
    }

    MakeCms& MakeCms::receiveCms(bool flag) {
        payCms_ = !flag;
        return *this;
    }

    MakeCms& MakeCms::withNominal(Real n) {
        nominal_ = n;
        return *this;
    }

    MakeCms&
    MakeCms::withEffectiveDate(const Date& effectiveDate) {
        effectiveDate_ = effectiveDate;
        return *this;
    }

    MakeCms& MakeCms::withDiscountingTermStructure(
                const Handle<YieldTermStructure>& discountingTermStructure) {
        engine_ = ext::make_shared<DiscountingSwapEngine>(discountingTermStructure);
        return *this;
    }

    MakeCms& MakeCms::withCmsCouponPricer(
                    const ext::shared_ptr<CmsCouponPricer>& couponPricer) {
        couponPricer_ = couponPricer;
        return *this;
    }

    MakeCms& MakeCms::withCmsLegTenor(const Period& t) {
        cmsTenor_ = t;
        return *this;
    }

    MakeCms&
    MakeCms::withCmsLegCalendar(const Calendar& cal) {
        cmsCalendar_ = cal;
        return *this;
    }

    MakeCms&
    MakeCms::withCmsLegConvention(BusinessDayConvention bdc) {
        cmsConvention_ = bdc;
        return *this;
    }

    MakeCms&
    MakeCms::withCmsLegTerminationDateConvention(BusinessDayConvention bdc) {
        cmsTerminationDateConvention_ = bdc;
        return *this;
    }

    MakeCms& MakeCms::withCmsLegRule(DateGeneration::Rule r) {
        cmsRule_ = r;
        return *this;
    }

    MakeCms& MakeCms::withCmsLegEndOfMonth(bool flag) {
        cmsEndOfMonth_ = flag;
        return *this;
    }

    MakeCms& MakeCms::withCmsLegFirstDate(const Date& d) {
        cmsFirstDate_ = d;
        return *this;
    }

    MakeCms&
    MakeCms::withCmsLegNextToLastDate(const Date& d) {
        cmsNextToLastDate_ = d;
        return *this;
    }

    MakeCms&
    MakeCms::withCmsLegDayCount(const DayCounter& dc) {
        cmsDayCount_ = dc;
        return *this;
    }

    MakeCms& MakeCms::withFloatingLegTenor(const Period& t) {
        floatTenor_ = t;
        return *this;
    }

    MakeCms&
    MakeCms::withFloatingLegCalendar(const Calendar& cal) {
        floatCalendar_ = cal;
        return *this;
    }

    MakeCms&
    MakeCms::withFloatingLegConvention(BusinessDayConvention bdc) {
        floatConvention_ = bdc;
        return *this;
    }

    MakeCms&
    MakeCms::withFloatingLegTerminationDateConvention(BusinessDayConvention bdc) {
        floatTerminationDateConvention_ = bdc;
        return *this;
    }

    MakeCms& MakeCms::withFloatingLegRule(DateGeneration::Rule r) {
        floatRule_ = r;
        return *this;
    }

    MakeCms& MakeCms::withFloatingLegEndOfMonth(bool flag) {
        floatEndOfMonth_ = flag;
        return *this;
    }

    MakeCms&
    MakeCms::withFloatingLegFirstDate(const Date& d) {
        floatFirstDate_ = d;
        return *this;
    }

    MakeCms&
    MakeCms::withFloatingLegNextToLastDate(const Date& d) {
        floatNextToLastDate_ = d;
        return *this;
    }

    MakeCms&
    MakeCms::withFloatingLegDayCount(const DayCounter& dc) {
        floatDayCount_ = dc;
        return *this;
    }

    MakeCms& MakeCms::withAtmSpread(bool flag) {
        useAtmSpread_ = flag;
        return *this;
    }

}
]]></document_content>
  </document>
  <document index="47">
    <source>makeois.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009, 2014, 2015 Ferdinando Ametrano
 Copyright (C) 2015 Paolo Mazzocchi
 Copyright (C) 2017 Joseph Jeisman
 Copyright (C) 2017 Fabrice Lecuyer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/makeois.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/time/schedule.hpp>
#include <ql/indexes/ibor/sonia.hpp>
#include <ql/indexes/ibor/corra.hpp>

namespace QuantLib {

    MakeOIS::MakeOIS(const Period& swapTenor,
                     const ext::shared_ptr<OvernightIndex>& overnightIndex,
                     Rate fixedRate,
                     const Period& forwardStart)
    : swapTenor_(swapTenor), overnightIndex_(overnightIndex), fixedRate_(fixedRate),
      forwardStart_(forwardStart),
      fixedCalendar_(overnightIndex->fixingCalendar()),
      overnightCalendar_(overnightIndex->fixingCalendar()),
      fixedDayCount_(overnightIndex->dayCounter()) {}

    MakeOIS::operator OvernightIndexedSwap() const {
        ext::shared_ptr<OvernightIndexedSwap> ois = *this;
        return *ois;
    }

    MakeOIS::operator ext::shared_ptr<OvernightIndexedSwap>() const {

        Date startDate;
        if (effectiveDate_ != Date())
            startDate = effectiveDate_;
        else {
            // settlement days: override if set, else fallback to default by index name
            Natural settlementDays = settlementDays_;
            if (settlementDays == Null<Natural>()) {
                if (ext::dynamic_pointer_cast<Sonia>(overnightIndex_)) {
                    settlementDays = 0; 
                }
                else if (ext::dynamic_pointer_cast<Corra>(overnightIndex_)) {
                    settlementDays = 1;
                }
                else {
                    settlementDays = 2;
                }
            }            

            Date refDate = Settings::instance().evaluationDate();
            // if the evaluation date is not a business day
            // then move to the next business day
            refDate = overnightCalendar_.adjust(refDate);
            Date spotDate = overnightCalendar_.advance(refDate,
                                                       settlementDays*Days);
            startDate = spotDate+forwardStart_;
            if (forwardStart_.length()<0)
                startDate = overnightCalendar_.adjust(startDate, Preceding);
            else
                startDate = overnightCalendar_.adjust(startDate, Following);
        }

        // OIS end of month default
        bool fixedEndOfMonth, overnightEndOfMonth;
        if (isDefaultEOM_)
            fixedEndOfMonth = overnightEndOfMonth = overnightCalendar_.isEndOfMonth(startDate);
        else {
            fixedEndOfMonth = fixedEndOfMonth_;
            overnightEndOfMonth = overnightEndOfMonth_;
        }

        Date endDate = terminationDate_;
        if (endDate == Date()) {
            if (overnightEndOfMonth)
                endDate = overnightCalendar_.advance(startDate,
                                                     swapTenor_,
                                                     ModifiedFollowing,
                                                     overnightEndOfMonth);
            else
                endDate = startDate + swapTenor_;
        }

        Frequency fixedPaymentFrequency, overnightPaymentFrequency;
        DateGeneration::Rule fixedRule, overnightRule;
        if (fixedPaymentFrequency_ == Once || fixedRule_ == DateGeneration::Zero) {
            fixedPaymentFrequency = Once;
            fixedRule = DateGeneration::Zero;
        } else {
            fixedPaymentFrequency = fixedPaymentFrequency_;
            fixedRule = fixedRule_;
        }
        if (overnightPaymentFrequency_ == Once || overnightRule_ == DateGeneration::Zero) {
            overnightPaymentFrequency = Once;
            overnightRule = DateGeneration::Zero;
        } else {
            overnightPaymentFrequency = overnightPaymentFrequency_;
            overnightRule = overnightRule_;
        }

        Schedule fixedSchedule(startDate, endDate,
                               Period(fixedPaymentFrequency),
                               fixedCalendar_,
                               fixedConvention_,
                               fixedTerminationDateConvention_,
                               fixedRule,
                               fixedEndOfMonth);

        Schedule overnightSchedule(startDate, endDate,
                                   Period(overnightPaymentFrequency),
                                   overnightCalendar_,
                                   overnightConvention_,
                                   overnightTerminationDateConvention_,
                                   overnightRule,
                                   overnightEndOfMonth);

        Rate usedFixedRate = fixedRate_;
        if (fixedRate_ == Null<Rate>()) {
            OvernightIndexedSwap temp(type_, nominal_,
                                      fixedSchedule,
                                      0.0, // fixed rate
                                      fixedDayCount_,
                                      overnightSchedule,
                                      overnightIndex_, overnightSpread_,
                                      paymentLag_, paymentAdjustment_,
                                      paymentCalendar_, telescopicValueDates_);
            if (engine_ == nullptr) {
                Handle<YieldTermStructure> disc =
                                    overnightIndex_->forwardingTermStructure();
                QL_REQUIRE(!disc.empty(),
                           "null term structure set to this instance of " <<
                           overnightIndex_->name());
                bool includeSettlementDateFlows = false;
                ext::shared_ptr<PricingEngine> engine(new
                    DiscountingSwapEngine(disc, includeSettlementDateFlows));
                temp.setPricingEngine(engine);
            } else
                temp.setPricingEngine(engine_);

            usedFixedRate = temp.fairRate();
        }

        ext::shared_ptr<OvernightIndexedSwap> ois(new
            OvernightIndexedSwap(type_, nominal_,
                                 fixedSchedule,
                                 usedFixedRate, fixedDayCount_,
                                 overnightSchedule,
                                 overnightIndex_, overnightSpread_,
                                 paymentLag_, paymentAdjustment_,
                                 paymentCalendar_, telescopicValueDates_, 
                                 averagingMethod_, lookbackDays_,
                                 lockoutDays_, applyObservationShift_));

        if (engine_ == nullptr) {
            Handle<YieldTermStructure> disc =
                                overnightIndex_->forwardingTermStructure();
            bool includeSettlementDateFlows = false;
            ext::shared_ptr<PricingEngine> engine(new
                DiscountingSwapEngine(disc, includeSettlementDateFlows));
            ois->setPricingEngine(engine);
        } else
            ois->setPricingEngine(engine_);

        return ois;
    }

    MakeOIS& MakeOIS::receiveFixed(bool flag) {
        type_ = flag ? Swap::Receiver : Swap::Payer ;
        return *this;
    }

    MakeOIS& MakeOIS::withType(Swap::Type type) {
        type_ = type;
        return *this;
    }

    MakeOIS& MakeOIS::withNominal(Real n) {
        nominal_ = n;
        return *this;
    }

    MakeOIS& MakeOIS::withSettlementDays(Natural settlementDays) {
        settlementDays_ = settlementDays;
        effectiveDate_ = Date();
        return *this;
    }

    MakeOIS& MakeOIS::withEffectiveDate(const Date& effectiveDate) {
        effectiveDate_ = effectiveDate;
        return *this;
    }

    MakeOIS& MakeOIS::withTerminationDate(const Date& terminationDate) {
        terminationDate_ = terminationDate;
        if (terminationDate != Date())
            swapTenor_ = Period();
        return *this;
    }

    MakeOIS& MakeOIS::withPaymentFrequency(Frequency f) {
        return withFixedLegPaymentFrequency(f).withOvernightLegPaymentFrequency(f);
    }

    MakeOIS& MakeOIS::withFixedLegPaymentFrequency(Frequency f) {
        fixedPaymentFrequency_ = f;
        return *this;
    }

    MakeOIS& MakeOIS::withOvernightLegPaymentFrequency(Frequency f) {
        overnightPaymentFrequency_ = f;
        return *this;
    }

    MakeOIS& MakeOIS::withPaymentAdjustment(BusinessDayConvention convention) {
        paymentAdjustment_ = convention;
        return *this;
    }

    MakeOIS& MakeOIS::withPaymentLag(Integer lag) {
        paymentLag_ = lag;
        return *this;
    }

    MakeOIS& MakeOIS::withPaymentCalendar(const Calendar& cal) {
        paymentCalendar_ = cal;
        return *this;
    }

    MakeOIS& MakeOIS::withCalendar(const Calendar& cal) {
        return withFixedLegCalendar(cal).withOvernightLegCalendar(cal);
    }

    MakeOIS& MakeOIS::withFixedLegCalendar(const Calendar& cal) {
        fixedCalendar_ = cal;
        return *this;
    }

    MakeOIS& MakeOIS::withOvernightLegCalendar(const Calendar& cal) {
        overnightCalendar_ = cal;
        return *this;
    }

    MakeOIS& MakeOIS::withRule(DateGeneration::Rule r) {
        return withFixedLegRule(r).withOvernightLegRule(r);
    }

    MakeOIS& MakeOIS::withFixedLegRule(DateGeneration::Rule r) {
        fixedRule_ = r;
        return *this;
    }

    MakeOIS& MakeOIS::withOvernightLegRule(DateGeneration::Rule r) {
        overnightRule_ = r;
        return *this;
    }

    MakeOIS& MakeOIS::withDiscountingTermStructure(
                                        const Handle<YieldTermStructure>& d) {
        bool includeSettlementDateFlows = false;
        engine_ = ext::shared_ptr<PricingEngine>(new
            DiscountingSwapEngine(d, includeSettlementDateFlows));
        return *this;
    }

    MakeOIS& MakeOIS::withPricingEngine(
                             const ext::shared_ptr<PricingEngine>& engine) {
        engine_ = engine;
        return *this;
    }

    MakeOIS& MakeOIS::withFixedLegDayCount(const DayCounter& dc) {
        fixedDayCount_ = dc;
        return *this;
    }

    MakeOIS& MakeOIS::withConvention(BusinessDayConvention bdc) {
        return withFixedLegConvention(bdc).withOvernightLegConvention(bdc);
    }

    MakeOIS& MakeOIS::withFixedLegConvention(BusinessDayConvention bdc) {
        fixedConvention_ = bdc;
        return *this;
    }

    MakeOIS& MakeOIS::withOvernightLegConvention(BusinessDayConvention bdc) {
        overnightConvention_ = bdc;
        return *this;
    }

    MakeOIS& MakeOIS::withTerminationDateConvention(BusinessDayConvention bdc) {
        withFixedLegTerminationDateConvention(bdc);
        return withOvernightLegTerminationDateConvention(bdc);
    }

    MakeOIS& MakeOIS::withFixedLegTerminationDateConvention(BusinessDayConvention bdc) {
        fixedTerminationDateConvention_ = bdc;
        return *this;
    }

    MakeOIS& MakeOIS::withOvernightLegTerminationDateConvention(BusinessDayConvention bdc) {
        overnightTerminationDateConvention_ = bdc;
        return *this;
    }

    MakeOIS& MakeOIS::withEndOfMonth(bool flag) {
        return withFixedLegEndOfMonth(flag).withOvernightLegEndOfMonth(flag);
    }

    MakeOIS& MakeOIS::withFixedLegEndOfMonth(bool flag) {
        fixedEndOfMonth_ = flag;
        isDefaultEOM_ = false;
        return *this;
    }

    MakeOIS& MakeOIS::withOvernightLegEndOfMonth(bool flag) {
        overnightEndOfMonth_ = flag;
        isDefaultEOM_ = false;
        return *this;
    }

    MakeOIS& MakeOIS::withOvernightLegSpread(Spread sp) {
        overnightSpread_ = sp;
        return *this;
    }

    MakeOIS& MakeOIS::withTelescopicValueDates(bool telescopicValueDates) {
        telescopicValueDates_ = telescopicValueDates;
        return *this;
    }

    MakeOIS& MakeOIS::withAveragingMethod(RateAveraging::Type averagingMethod) {
        averagingMethod_ = averagingMethod;
        return *this;
    }

    MakeOIS& MakeOIS::withLookbackDays(Natural lookbackDays) {
        lookbackDays_ = lookbackDays;
        return *this;
    }

    MakeOIS& MakeOIS::withLockoutDays(Natural lockoutDays) {
        lockoutDays_ = lockoutDays;
        return *this;
    }

    MakeOIS& MakeOIS::withObservationShift(bool applyObservationShift) {
        applyObservationShift_ = applyObservationShift;
        return *this;
    }

}
]]></document_content>
  </document>
  <document index="48">
    <source>makeswaption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2008, 2014 Ferdinando Ametrano
 Copyright (C) 2007 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflows.hpp>
#include <ql/exercise.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/instruments/makeois.hpp>
#include <ql/instruments/makeswaption.hpp>
#include <ql/instruments/makevanillaswap.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/optional.hpp>
#include <ql/settings.hpp>
#include <utility>

namespace QuantLib {

    MakeSwaption::MakeSwaption(ext::shared_ptr<SwapIndex> swapIndex,
                               const Period& optionTenor,
                               Rate strike)
    : swapIndex_(std::move(swapIndex)), delivery_(Settlement::Physical),
      settlementMethod_(Settlement::PhysicalOTC), optionTenor_(optionTenor),
      optionConvention_(ModifiedFollowing), strike_(strike),
      underlyingType_(Swap::Payer), nominal_(1.0) {}

    MakeSwaption::MakeSwaption(ext::shared_ptr<SwapIndex> swapIndex,
                               const Date& fixingDate,
                               Rate strike)
    : swapIndex_(std::move(swapIndex)), delivery_(Settlement::Physical),
      settlementMethod_(Settlement::PhysicalOTC), optionConvention_(ModifiedFollowing),
      fixingDate_(fixingDate), strike_(strike), underlyingType_(Swap::Payer) {}

    MakeSwaption::operator Swaption() const {
        ext::shared_ptr<Swaption> swaption = *this;
        return *swaption;
    }

    MakeSwaption::operator ext::shared_ptr<Swaption>() const {

        const Calendar& fixingCalendar = swapIndex_->fixingCalendar();
        Date refDate = Settings::instance().evaluationDate();
        // if the evaluation date is not a business day
        // then move to the next business day
        refDate = fixingCalendar.adjust(refDate);
        if (fixingDate_ == Date())
            fixingDate_ = fixingCalendar.advance(refDate, optionTenor_,
                                                 optionConvention_);
        if (exerciseDate_ == Date()) {
            exercise_ = ext::shared_ptr<Exercise>(new
                EuropeanExercise(fixingDate_));
        } else {
            QL_REQUIRE(exerciseDate_ <= fixingDate_,
                       "exercise date (" << exerciseDate_ << ") must be less "
                       "than or equal to fixing date (" << fixingDate_ << ")");
            exercise_ = ext::shared_ptr<Exercise>(new
                EuropeanExercise(exerciseDate_));
        }

        Rate usedStrike;
        ext::shared_ptr<OvernightIndexedSwapIndex> OIswap_index = ext::dynamic_pointer_cast<OvernightIndexedSwapIndex>(swapIndex_);
        if (strike_ == Null<Rate>()) {
            // ATM on curve(s) attached to index
            QL_REQUIRE(!swapIndex_->forwardingTermStructure().empty(),
                       "null term structure set to this instance of " <<
                       swapIndex_->name());
            if (OIswap_index) {
                auto temp = OIswap_index->underlyingSwap(fixingDate_);
                temp->setPricingEngine(
                    ext::make_shared<DiscountingSwapEngine>(
                        swapIndex_->exogenousDiscount()
                        ? swapIndex_->discountingTermStructure()
                        : swapIndex_->forwardingTermStructure(),
                        false
                    )
                );
                usedStrike = temp->fairRate();
            } else {
                auto temp = swapIndex_->underlyingSwap(fixingDate_);
                temp->setPricingEngine(
                    ext::make_shared<DiscountingSwapEngine>(
                        swapIndex_->exogenousDiscount()
                        ? swapIndex_->discountingTermStructure()
                        : swapIndex_->forwardingTermStructure(),
                        false
                    )
                );
                usedStrike = temp->fairRate();
            }
        } else {
            usedStrike = strike_;
        }

        BusinessDayConvention bdc = swapIndex_->fixedLegConvention();
        if (OIswap_index) {
            underlyingSwap_ =
                (ext::shared_ptr<OvernightIndexedSwap>)(
                    MakeOIS(swapIndex_->tenor(),
                            OIswap_index->overnightIndex(), usedStrike)
                    .withEffectiveDate(swapIndex_->valueDate(fixingDate_))
                    .withPaymentCalendar(swapIndex_->fixingCalendar())
                    .withFixedLegDayCount(swapIndex_->dayCounter())
                    .withPaymentAdjustment(bdc)
                    .withFixedLegConvention(bdc)
                    .withFixedLegTerminationDateConvention(bdc)
                    .withType(underlyingType_)
                    .withNominal(nominal_)
                    );
        } else {
            underlyingSwap_ =
                (ext::shared_ptr<VanillaSwap>)(
                    MakeVanillaSwap(swapIndex_->tenor(),
                                    swapIndex_->iborIndex(), usedStrike)
                    .withEffectiveDate(swapIndex_->valueDate(fixingDate_))
                    .withFixedLegCalendar(swapIndex_->fixingCalendar())
                    .withFixedLegDayCount(swapIndex_->dayCounter())
                    .withFixedLegTenor(swapIndex_->fixedLegTenor())
                    .withFixedLegConvention(bdc)
                    .withFixedLegTerminationDateConvention(bdc)
                    .withType(underlyingType_)
                    .withNominal(nominal_)
                    .withIndexedCoupons(useIndexedCoupons_)
                    );
        }
        ext::shared_ptr<Swaption> swaption = ext::make_shared<Swaption>(
            underlyingSwap_, exercise_, delivery_, settlementMethod_);
        swaption->setPricingEngine(engine_);
        return swaption;
    }

    MakeSwaption& MakeSwaption::withSettlementType(Settlement::Type delivery) {
        delivery_ = delivery;
        return *this;
    }

    MakeSwaption& MakeSwaption::withSettlementMethod(
        Settlement::Method settlementMethod) {
        settlementMethod_ = settlementMethod;
        return *this;
    }

    MakeSwaption&
    MakeSwaption::withOptionConvention(BusinessDayConvention bdc) {
        optionConvention_ = bdc;
        return *this;
    }

    MakeSwaption& MakeSwaption::withExerciseDate(const Date& date) {
        exerciseDate_ = date;
        return *this;
    }

    MakeSwaption& MakeSwaption::withUnderlyingType(const Swap::Type type) {
        underlyingType_ = type;
        return *this;
    }

    MakeSwaption& MakeSwaption::withPricingEngine(
                             const ext::shared_ptr<PricingEngine>& engine) {
        engine_ = engine;
        return *this;
    }

    MakeSwaption& MakeSwaption::withNominal(Real n) {
        nominal_ = n;
        return *this;
    }

    MakeSwaption& MakeSwaption::withIndexedCoupons(const ext::optional<bool>& b) {
        useIndexedCoupons_ = b;
        return *this;
    }

    MakeSwaption& MakeSwaption::withAtParCoupons(bool b) {
        useIndexedCoupons_ = !b;
        return *this;
    }

}
]]></document_content>
  </document>
  <document index="49">
    <source>makevanillaswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007, 2010, 2014, 2015 Ferdinando Ametrano
 Copyright (C) 2006 Katiuscia Manzoni
 Copyright (C) 2006 StatPro Italia srl
 Copyright (C) 2015 Paolo Mazzocchi
 Copyright (C) 2018 Matthias Groncki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/makevanillaswap.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/time/schedule.hpp>
#include <ql/currencies/america.hpp>
#include <ql/currencies/asia.hpp>
#include <ql/currencies/europe.hpp>
#include <ql/currencies/oceania.hpp>
#include <ql/utilities/null.hpp>
#include <ql/optional.hpp>

namespace QuantLib {

    MakeVanillaSwap::MakeVanillaSwap(const Period& swapTenor,
                                     const ext::shared_ptr<IborIndex>& index,
                                     Rate fixedRate,
                                     const Period& forwardStart)
    : swapTenor_(swapTenor), iborIndex_(index), fixedRate_(fixedRate), forwardStart_(forwardStart),
      fixedCalendar_(index->fixingCalendar()), floatCalendar_(index->fixingCalendar()),
      floatTenor_(index->tenor()),
      floatConvention_(index->businessDayConvention()),
      floatTerminationDateConvention_(index->businessDayConvention()),

      floatDayCount_(index->dayCounter()) {}

    MakeVanillaSwap::operator VanillaSwap() const {
        ext::shared_ptr<VanillaSwap> swap = *this;
        return *swap;
    }

    MakeVanillaSwap::operator ext::shared_ptr<VanillaSwap>() const {

        Date startDate;
        if (effectiveDate_ != Date())
            startDate = effectiveDate_;
        else {
            Date refDate = Settings::instance().evaluationDate();
            // if the evaluation date is not a business day
            // then move to the next business day
            refDate = floatCalendar_.adjust(refDate);
            // use index valueDate interface wherever possible to estimate spot date.
            // Unless we pass an explicit settlementDays_ which does not match the index-defined number of fixing days.
            Date spotDate;
            if (settlementDays_ == Null<Natural>())
                spotDate = iborIndex_->valueDate(refDate);
            else
                spotDate = floatCalendar_.advance(refDate, settlementDays_ * Days);
            startDate = spotDate+forwardStart_;
            if (forwardStart_.length()<0)
                startDate = floatCalendar_.adjust(startDate,
                                                  Preceding);
            else if (forwardStart_.length()>0)
                startDate = floatCalendar_.adjust(startDate,
                                                  Following);
            // no explicit date adjustment needed for forwardStart_.length()==0 (already handled by spotDate arithmetic above)
        }

        Date endDate = terminationDate_;
        if (endDate == Date()) {
            if (floatEndOfMonth_)
                endDate = floatCalendar_.advance(startDate,
                                                 swapTenor_,
                                                 ModifiedFollowing,
                                                 floatEndOfMonth_);
            else
                endDate = startDate + swapTenor_;
        }

        const Currency& curr = iborIndex_->currency();
        Period fixedTenor;
        if (fixedTenor_ != Period())
            fixedTenor = fixedTenor_;
        else {
            if ((curr == EURCurrency()) ||
                (curr == USDCurrency()) ||
                (curr == CHFCurrency()) ||
                (curr == SEKCurrency()) ||
                (curr == GBPCurrency() && swapTenor_ <= 1 * Years))
                fixedTenor = Period(1, Years);
            else if ((curr == GBPCurrency() && swapTenor_ > 1 * Years) ||
                (curr == JPYCurrency()) ||
                (curr == AUDCurrency() && swapTenor_ >= 4 * Years))
                fixedTenor = Period(6, Months);
            else if ((curr == HKDCurrency() ||
                     (curr == AUDCurrency() && swapTenor_ < 4 * Years)))
                fixedTenor = Period(3, Months);
            else
                QL_FAIL("unknown fixed leg default tenor for " << curr);
        }

        Schedule fixedSchedule(startDate, endDate,
                               fixedTenor, fixedCalendar_,
                               fixedConvention_,
                               fixedTerminationDateConvention_,
                               fixedRule_, fixedEndOfMonth_,
                               fixedFirstDate_, fixedNextToLastDate_);

        Schedule floatSchedule(startDate, endDate,
                               floatTenor_, floatCalendar_,
                               floatConvention_,
                               floatTerminationDateConvention_,
                               floatRule_, floatEndOfMonth_,
                               floatFirstDate_, floatNextToLastDate_);

        DayCounter fixedDayCount;
        if (fixedDayCount_ != DayCounter())
            fixedDayCount = fixedDayCount_;
        else {
            if (curr == USDCurrency())
                fixedDayCount = Actual360();
            else if (curr == EURCurrency() || curr == CHFCurrency() ||
                     curr == SEKCurrency())
                fixedDayCount = Thirty360(Thirty360::BondBasis);
            else if (curr == GBPCurrency() || curr == JPYCurrency() ||
                     curr == AUDCurrency() || curr == HKDCurrency() ||
                     curr == THBCurrency())
                fixedDayCount = Actual365Fixed();
            else
                QL_FAIL("unknown fixed leg day counter for " << curr);
        }

        Rate usedFixedRate = fixedRate_;
        if (fixedRate_ == Null<Rate>()) {
            VanillaSwap temp(type_, 100.00, fixedSchedule,
                             0.0, // fixed rate
                             fixedDayCount, floatSchedule, iborIndex_, floatSpread_, floatDayCount_,
                             paymentConvention_, useIndexedCoupons_);
            if (engine_ == nullptr) {
                Handle<YieldTermStructure> disc =
                                        iborIndex_->forwardingTermStructure();
                QL_REQUIRE(!disc.empty(),
                           "null term structure set to this instance of " <<
                           iborIndex_->name());
                bool includeSettlementDateFlows = false;
                ext::shared_ptr<PricingEngine> engine(new
                    DiscountingSwapEngine(disc, includeSettlementDateFlows));
                temp.setPricingEngine(engine);
            } else
                temp.setPricingEngine(engine_);

            usedFixedRate = temp.fairRate();
        }

        ext::shared_ptr<VanillaSwap> swap(new VanillaSwap(
            type_, nominal_, fixedSchedule, usedFixedRate, fixedDayCount, floatSchedule, iborIndex_,
            floatSpread_, floatDayCount_, paymentConvention_, useIndexedCoupons_));

        if (engine_ == nullptr) {
            Handle<YieldTermStructure> disc =
                                    iborIndex_->forwardingTermStructure();
            bool includeSettlementDateFlows = false;
            ext::shared_ptr<PricingEngine> engine(new
                DiscountingSwapEngine(disc, includeSettlementDateFlows));
            swap->setPricingEngine(engine);
        } else
            swap->setPricingEngine(engine_);

        return swap;
    }

    MakeVanillaSwap& MakeVanillaSwap::receiveFixed(bool flag) {
        type_ = flag ? Swap::Receiver : Swap::Payer ;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withType(Swap::Type type) {
        type_ = type;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withNominal(Real n) {
        nominal_ = n;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withSettlementDays(Natural settlementDays) {
        settlementDays_ = settlementDays;
        effectiveDate_ = Date();
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withEffectiveDate(const Date& effectiveDate) {
        effectiveDate_ = effectiveDate;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withTerminationDate(const Date& terminationDate) {
        terminationDate_ = terminationDate;
        if (terminationDate != Date())
            swapTenor_ = Period();
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withRule(DateGeneration::Rule r) {
        fixedRule_ = r;
        floatRule_ = r;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withPaymentConvention(BusinessDayConvention bdc) {
        paymentConvention_ = bdc;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withDiscountingTermStructure(
                                        const Handle<YieldTermStructure>& d) {
        bool includeSettlementDateFlows = false;
        engine_ = ext::shared_ptr<PricingEngine>(new
            DiscountingSwapEngine(d, includeSettlementDateFlows));
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withPricingEngine(
                             const ext::shared_ptr<PricingEngine>& engine) {
        engine_ = engine;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withFixedLegTenor(const Period& t) {
        fixedTenor_ = t;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFixedLegCalendar(const Calendar& cal) {
        fixedCalendar_ = cal;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFixedLegConvention(BusinessDayConvention bdc) {
        fixedConvention_ = bdc;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFixedLegTerminationDateConvention(BusinessDayConvention bdc) {
        fixedTerminationDateConvention_ = bdc;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withFixedLegRule(DateGeneration::Rule r) {
        fixedRule_ = r;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withFixedLegEndOfMonth(bool flag) {
        fixedEndOfMonth_ = flag;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withFixedLegFirstDate(const Date& d) {
        fixedFirstDate_ = d;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFixedLegNextToLastDate(const Date& d) {
        fixedNextToLastDate_ = d;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFixedLegDayCount(const DayCounter& dc) {
        fixedDayCount_ = dc;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withFloatingLegTenor(const Period& t) {
        floatTenor_ = t;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFloatingLegCalendar(const Calendar& cal) {
        floatCalendar_ = cal;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFloatingLegConvention(BusinessDayConvention bdc) {
        floatConvention_ = bdc;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFloatingLegTerminationDateConvention(BusinessDayConvention bdc) {
        floatTerminationDateConvention_ = bdc;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withFloatingLegRule(DateGeneration::Rule r) {
        floatRule_ = r;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withFloatingLegEndOfMonth(bool flag) {
        floatEndOfMonth_ = flag;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFloatingLegFirstDate(const Date& d) {
        floatFirstDate_ = d;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFloatingLegNextToLastDate(const Date& d) {
        floatNextToLastDate_ = d;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFloatingLegDayCount(const DayCounter& dc) {
        floatDayCount_ = dc;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withFloatingLegSpread(Spread sp) {
        floatSpread_ = sp;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withIndexedCoupons(const ext::optional<bool>& b) {
        useIndexedCoupons_ = b;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withAtParCoupons(bool b) {
        useIndexedCoupons_ = !b;
        return *this;
    }

}
]]></document_content>
  </document>
  <document index="50">
    <source>makeyoyinflationcapfloor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/cashflows/cashflows.hpp>
#include <ql/instruments/makeyoyinflationcapfloor.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <utility>

namespace QuantLib {

    MakeYoYInflationCapFloor::MakeYoYInflationCapFloor(YoYInflationCapFloor::Type capFloorType,
                                                       ext::shared_ptr<YoYInflationIndex> index,
                                                       const Size& length,
                                                       Calendar cal,
                                                       const Period& observationLag,
                                                       CPI::InterpolationType interpolation)
    : capFloorType_(capFloorType), length_(length), calendar_(std::move(cal)),
      index_(std::move(index)), observationLag_(observationLag),
      interpolation_(interpolation), strike_(Null<Rate>()),

      dayCounter_(Thirty360(Thirty360::BondBasis)) {}

    MakeYoYInflationCapFloor::operator YoYInflationCapFloor() const {
        ext::shared_ptr<YoYInflationCapFloor> capfloor = *this;
        return *capfloor;
    }

    MakeYoYInflationCapFloor::operator ext::shared_ptr<YoYInflationCapFloor>() const {

        Date startDate;
        if (effectiveDate_ != Date()) {
            startDate = effectiveDate_;
        } else {
            Date referenceDate = Settings::instance().evaluationDate();
            Date spotDate = calendar_.advance(referenceDate,
                                              fixingDays_*Days);
            startDate = spotDate+forwardStart_;
        }

        Date endDate = calendar_.advance(startDate,length_*Years,Unadjusted);
        Schedule schedule(startDate, endDate, Period(Annual), calendar_,
                          Unadjusted, Unadjusted, // ref periods & acc periods
                          DateGeneration::Forward, false);
        Leg leg = yoyInflationLeg(schedule, calendar_, index_,
                                  observationLag_, interpolation_)
        .withPaymentAdjustment(roll_)
        .withPaymentDayCounter(dayCounter_)
        .withNotionals(nominal_)
        ;

        if (firstCapletExcluded_)
            leg.erase(leg.begin());

        // only leaves the last coupon
        if (asOptionlet_ && leg.size() > 1) {
            auto end = leg.end(); // Sun Studio needs an lvalue
            leg.erase(leg.begin(), --end);
        }

        std::vector<Rate> strikeVector(1, strike_);
        if (strike_ == Null<Rate>()) {
            // ATM on the forecasting curve
            strikeVector[0] = CashFlows::atmRate(leg, **nominalTermStructure_,
                                                 false, nominalTermStructure_->referenceDate());
        }

        ext::shared_ptr<YoYInflationCapFloor> capFloor(new
                    YoYInflationCapFloor(capFloorType_, leg, strikeVector));
        capFloor->setPricingEngine(engine_);
        return capFloor;
    }

    MakeYoYInflationCapFloor& MakeYoYInflationCapFloor::withNominal(Real n) {
        nominal_ = n;
        return *this;
    }

    MakeYoYInflationCapFloor& MakeYoYInflationCapFloor::withEffectiveDate(
                                            const Date& effectiveDate) {
        effectiveDate_ = effectiveDate;
        return *this;
    }

    MakeYoYInflationCapFloor&
    MakeYoYInflationCapFloor::withPaymentAdjustment(BusinessDayConvention bdc) {
        roll_ = bdc;
        return *this;
    }

    MakeYoYInflationCapFloor&
    MakeYoYInflationCapFloor::withPaymentDayCounter(const DayCounter& dc) {
        dayCounter_ = dc;
        return *this;
    }

    MakeYoYInflationCapFloor&
    MakeYoYInflationCapFloor::withFixingDays(Natural n) {
        fixingDays_ = n;
        return *this;
    }

    MakeYoYInflationCapFloor& MakeYoYInflationCapFloor::asOptionlet(bool b) {
        asOptionlet_ = b;
        return *this;
    }

    MakeYoYInflationCapFloor& MakeYoYInflationCapFloor::withPricingEngine(
        const ext::shared_ptr<PricingEngine>& engine) {
        engine_ = engine;
        return *this;
    }

    MakeYoYInflationCapFloor&
    MakeYoYInflationCapFloor::withStrike(Rate strike) {
        QL_REQUIRE(nominalTermStructure_.empty(), "ATM strike already given");
        strike_ = strike;
        return *this;
    }

    MakeYoYInflationCapFloor&
    MakeYoYInflationCapFloor::withAtmStrike(
                      const Handle<YieldTermStructure>& nominalTermStructure) {
        QL_REQUIRE(strike_ == Null<Rate>(), "explicit strike already given");
        nominalTermStructure_ = nominalTermStructure;
        return *this;
    }

    MakeYoYInflationCapFloor&
    MakeYoYInflationCapFloor::withForwardStart(Period forwardStart) {
        forwardStart_ = forwardStart;
        return *this;
    }

}

]]></document_content>
  </document>
  <document index="51">
    <source>margrabeoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/margrabeoption.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    MargrabeOption::MargrabeOption(Integer Q1,
                                   Integer Q2,
                                   const ext::shared_ptr<Exercise>& exercise)
    : MultiAssetOption(ext::shared_ptr<Payoff>(new NullPayoff), exercise),
      Q1_(Q1),
      Q2_(Q2) {}

    Real MargrabeOption::delta1() const {
        calculate();
        QL_REQUIRE(delta1_ != Null<Real>(), "delta1 not provided");
        return delta1_;
    }

    Real MargrabeOption::delta2() const {
        calculate();
        QL_REQUIRE(delta2_ != Null<Real>(), "delta2 not provided");
        return delta2_;
    }

    Real MargrabeOption::gamma1() const {
        calculate();
        QL_REQUIRE(gamma1_ != Null<Real>(), "gamma1 not provided");
        return gamma1_;
    }

    Real MargrabeOption::gamma2() const {
        calculate();
        QL_REQUIRE(gamma2_ != Null<Real>(), "gamma2 not provided");
        return gamma2_;
    }

    void MargrabeOption::setupArguments(PricingEngine::arguments* args) const {
        MultiAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<MargrabeOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");

        moreArgs->Q1 = Q1_;
        moreArgs->Q2 = Q2_;
    }

    void MargrabeOption::arguments::validate() const {
        MultiAssetOption::arguments::validate();

        QL_REQUIRE(Q1 != Null<Integer>(), "unspecified quantity for asset 1");
        QL_REQUIRE(Q2 != Null<Integer>(), "unspecified quantity for asset 2");
        QL_REQUIRE(Q1 > 0, "quantity of asset 1 must be positive");
        QL_REQUIRE(Q2 > 0, "quantity of asset 2 must be positive");
    }

    void MargrabeOption::fetchResults(const PricingEngine::results* r) const {
        MultiAssetOption::fetchResults(r);
        const auto* results = dynamic_cast<const MargrabeOption::results*>(r);
        QL_REQUIRE(results != nullptr, "wrong result type");
        delta1_          = results->delta1;
        delta2_          = results->delta2;
        gamma1_          = results->gamma1;
        gamma2_          = results->gamma2;
    }

}
]]></document_content>
  </document>
  <document index="52">
    <source>multiassetoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Neil Firth
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/multiassetoption.hpp>
#include <ql/stochasticprocess.hpp>
#include <ql/exercise.hpp>
#include <ql/event.hpp>

namespace QuantLib {

    MultiAssetOption::MultiAssetOption(
        const ext::shared_ptr<Payoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : Option(payoff, exercise) {}

    bool MultiAssetOption::isExpired() const {
        return detail::simple_event(exercise_->lastDate()).hasOccurred();
    }

    Real MultiAssetOption::delta() const {
        calculate();
        QL_REQUIRE(delta_ != Null<Real>(), "delta not provided");
        return delta_;
    }

    Real MultiAssetOption::gamma() const {
        calculate();
        QL_REQUIRE(gamma_ != Null<Real>(), "gamma not provided");
        return gamma_;
    }

    Real MultiAssetOption::theta() const {
        calculate();
        QL_REQUIRE(theta_ != Null<Real>(), "theta not provided");
        return theta_;
    }

    Real MultiAssetOption::vega() const {
        calculate();
        QL_REQUIRE(vega_ != Null<Real>(), "vega not provided");
        return vega_;
    }

    Real MultiAssetOption::rho() const {
        calculate();
        QL_REQUIRE(rho_ != Null<Real>(), "rho not provided");
        return rho_;
    }

    Real MultiAssetOption::dividendRho() const {
        calculate();
        QL_REQUIRE(dividendRho_ != Null<Real>(), "dividend rho not provided");
        return dividendRho_;
    }

    void MultiAssetOption::setupExpired() const {
        NPV_ = delta_ = gamma_ = theta_ =
            vega_ = rho_ = dividendRho_ =  0.0;
    }

    void MultiAssetOption::setupArguments(
                                       PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<MultiAssetOption::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->payoff = payoff_;
        arguments->exercise = exercise_;
    }

    void MultiAssetOption::fetchResults(const PricingEngine::results* r) const {
        Option::fetchResults(r);
        const auto* results = dynamic_cast<const Greeks*>(r);
        QL_ENSURE(results != nullptr, "no greeks returned from pricing engine");
        delta_          = results->delta;
        gamma_          = results->gamma;
        theta_          = results->theta;
        vega_           = results->vega;
        rho_            = results->rho;
        dividendRho_    = results->dividendRho;
    }

}
]]></document_content>
  </document>
  <document index="53">
    <source>nonstandardswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2016 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/capflooredcoupon.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/cmscoupon.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/instruments/nonstandardswap.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/optional.hpp>
#include <utility>

namespace QuantLib {

    NonstandardSwap::NonstandardSwap(const FixedVsFloatingSwap &fromVanilla)
        : Swap(2), type_(fromVanilla.type()),
          fixedNominal_(std::vector<Real>(fromVanilla.fixedLeg().size(),
                                          fromVanilla.nominal())),
          floatingNominal_(std::vector<Real>(fromVanilla.floatingLeg().size(),
                                             fromVanilla.nominal())),
          fixedSchedule_(fromVanilla.fixedSchedule()),
          fixedRate_(std::vector<Real>(fromVanilla.fixedLeg().size(),
                                       fromVanilla.fixedRate())),
          fixedDayCount_(fromVanilla.fixedDayCount()),
          floatingSchedule_(fromVanilla.floatingSchedule()),
          iborIndex_(fromVanilla.iborIndex()),
          spread_(std::vector<Real>(fromVanilla.floatingLeg().size(), fromVanilla.spread())),
          gearing_(std::vector<Real>(fromVanilla.floatingLeg().size(), 1.0)),
          singleSpreadAndGearing_(true),
          floatingDayCount_(fromVanilla.floatingDayCount()),
          paymentConvention_(fromVanilla.paymentConvention()),
          intermediateCapitalExchange_(false), finalCapitalExchange_(false) {

        init();
    }

    NonstandardSwap::NonstandardSwap(const Swap::Type type,
                                     std::vector<Real> fixedNominal,
                                     const std::vector<Real>& floatingNominal,
                                     Schedule fixedSchedule,
                                     std::vector<Real> fixedRate,
                                     DayCounter fixedDayCount,
                                     Schedule floatingSchedule,
                                     ext::shared_ptr<IborIndex> iborIndex,
                                     const Real gearing,
                                     const Spread spread,
                                     DayCounter floatingDayCount,
                                     const bool intermediateCapitalExchange,
                                     const bool finalCapitalExchange,
                                     ext::optional<BusinessDayConvention> paymentConvention)
    : Swap(2), type_(type), fixedNominal_(std::move(fixedNominal)),
      floatingNominal_(floatingNominal), fixedSchedule_(std::move(fixedSchedule)),
      fixedRate_(std::move(fixedRate)), fixedDayCount_(std::move(fixedDayCount)),
      floatingSchedule_(std::move(floatingSchedule)), iborIndex_(std::move(iborIndex)),
      spread_(std::vector<Real>(floatingNominal.size(), spread)),
      gearing_(std::vector<Real>(floatingNominal.size(), gearing)), singleSpreadAndGearing_(true),
      floatingDayCount_(std::move(floatingDayCount)),
      intermediateCapitalExchange_(intermediateCapitalExchange),
      finalCapitalExchange_(finalCapitalExchange) {

        if (paymentConvention) // NOLINT(readability-implicit-bool-conversion)
            paymentConvention_ = *paymentConvention;
        else
            paymentConvention_ = floatingSchedule_.businessDayConvention();
        init();
    }

    NonstandardSwap::NonstandardSwap(const Swap::Type type,
                                     std::vector<Real> fixedNominal,
                                     std::vector<Real> floatingNominal,
                                     Schedule fixedSchedule,
                                     std::vector<Real> fixedRate,
                                     DayCounter fixedDayCount,
                                     Schedule floatingSchedule,
                                     ext::shared_ptr<IborIndex> iborIndex,
                                     std::vector<Real> gearing,
                                     std::vector<Spread> spread,
                                     DayCounter floatingDayCount,
                                     const bool intermediateCapitalExchange,
                                     const bool finalCapitalExchange,
                                     ext::optional<BusinessDayConvention> paymentConvention)
    : Swap(2), type_(type), fixedNominal_(std::move(fixedNominal)),
      floatingNominal_(std::move(floatingNominal)), fixedSchedule_(std::move(fixedSchedule)),
      fixedRate_(std::move(fixedRate)), fixedDayCount_(std::move(fixedDayCount)),
      floatingSchedule_(std::move(floatingSchedule)), iborIndex_(std::move(iborIndex)),
      spread_(std::move(spread)), gearing_(std::move(gearing)), singleSpreadAndGearing_(false),
      floatingDayCount_(std::move(floatingDayCount)),
      intermediateCapitalExchange_(intermediateCapitalExchange),
      finalCapitalExchange_(finalCapitalExchange) {

        if (paymentConvention) // NOLINT(readability-implicit-bool-conversion)
            paymentConvention_ = *paymentConvention;
        else
            paymentConvention_ = floatingSchedule_.businessDayConvention();
        init();
    }

    void NonstandardSwap::init() {

        QL_REQUIRE(fixedNominal_.size() == fixedRate_.size(),
                   "Fixed nominal size ("
                       << fixedNominal_.size()
                       << ") does not match fixed rate size ("
                       << fixedRate_.size() << ")");

        QL_REQUIRE(fixedNominal_.size() == fixedSchedule_.size() - 1,
                   "Fixed nominal size (" << fixedNominal_.size()
                                          << ") does not match schedule size ("
                                          << fixedSchedule_.size() << ") - 1");

        QL_REQUIRE(floatingNominal_.size() == floatingSchedule_.size() - 1,
                   "Floating nominal size ("
                       << floatingNominal_.size()
                       << ") does not match schedule size ("
                       << floatingSchedule_.size() << ") - 1");

        QL_REQUIRE(floatingNominal_.size() == spread_.size(),
                   "Floating nominal size (" << floatingNominal_.size()
                                             << ") does not match spread size ("
                                             << spread_.size() << ")");

        QL_REQUIRE(floatingNominal_.size() == gearing_.size(),
                   "Floating nominal size ("
                       << floatingNominal_.size()
                       << ") does not match gearing size (" << gearing_.size()
                       << ")");

        // if the gearing is zero then the ibor leg will be set up with fixed
        // coupons which makes trouble here in this context. We therefore use
        // a dirty trick and enforce the gearing to be non zero.
        for (Real& i : gearing_) {
            if (close(i, 0.0))
                i = QL_EPSILON;
        }

        legs_[0] = FixedRateLeg(fixedSchedule_)
                       .withNotionals(fixedNominal_)
                       .withCouponRates(fixedRate_, fixedDayCount_)
                       .withPaymentAdjustment(paymentConvention_);

        legs_[1] = IborLeg(floatingSchedule_, iborIndex_)
                       .withNotionals(floatingNominal_)
                       .withPaymentDayCounter(floatingDayCount_)
                       .withPaymentAdjustment(paymentConvention_)
                       .withSpreads(spread_)
                       .withGearings(gearing_);

        if (intermediateCapitalExchange_) {
            for (Size i = 0; i < legs_[0].size() - 1; i++) {
                Real cap = fixedNominal_[i] - fixedNominal_[i + 1];
                if (!close(cap, 0.0)) {
                    auto it1 = legs_[0].begin();
                    std::advance(it1, i + 1);
                    legs_[0].insert(
                        it1, ext::shared_ptr<CashFlow>(
                                 new Redemption(cap, legs_[0][i]->date())));
                    auto it2 = fixedNominal_.begin();
                    std::advance(it2, i + 1);
                    fixedNominal_.insert(it2, fixedNominal_[i]);
                    auto it3 = fixedRate_.begin();
                    std::advance(it3, i + 1);
                    fixedRate_.insert(it3, 0.0);
                    i++;
                }
            }
            for (Size i = 0; i < legs_[1].size() - 1; i++) {
                Real cap = floatingNominal_[i] - floatingNominal_[i + 1];
                if (!close(cap, 0.0)) {
                    auto it1 = legs_[1].begin();
                    std::advance(it1, i + 1);
                    legs_[1].insert(
                        it1, ext::shared_ptr<CashFlow>(
                                 new Redemption(cap, legs_[1][i]->date())));
                    auto it2 = floatingNominal_.begin();
                    std::advance(it2, i + 1);
                    floatingNominal_.insert(it2, floatingNominal_[i]);
                    i++;
                }
            }
        }

        if (finalCapitalExchange_) {
            legs_[0].push_back(ext::shared_ptr<CashFlow>(
                new Redemption(fixedNominal_.back(), legs_[0].back()->date())));
            fixedNominal_.push_back(fixedNominal_.back());
            fixedRate_.push_back(0.0);
            legs_[1].push_back(ext::shared_ptr<CashFlow>(new Redemption(
                floatingNominal_.back(), legs_[1].back()->date())));
            floatingNominal_.push_back(floatingNominal_.back());
        }

        for (auto i = legs_[1].begin(); i < legs_[1].end(); ++i)
            registerWith(*i);

        switch (type_) {
        case Swap::Payer:
            payer_[0] = -1.0;
            payer_[1] = +1.0;
            break;
        case Swap::Receiver:
            payer_[0] = +1.0;
            payer_[1] = -1.0;
            break;
        default:
            QL_FAIL("Unknown nonstandard-swap type");
        }
    }

    void NonstandardSwap::setupArguments(PricingEngine::arguments *args) const {

        Swap::setupArguments(args);

        auto* arguments = dynamic_cast<NonstandardSwap::arguments*>(args);

        if (arguments == nullptr)
            return; // swap engine ...

        arguments->type = type_;
        arguments->fixedNominal = fixedNominal_;
        arguments->floatingNominal = floatingNominal_;
        arguments->fixedRate = fixedRate_;

        const Leg &fixedCoupons = fixedLeg();

        arguments->fixedResetDates = arguments->fixedPayDates =
            std::vector<Date>(fixedCoupons.size());
        arguments->fixedCoupons = std::vector<Real>(fixedCoupons.size());
        arguments->fixedIsRedemptionFlow =
            std::vector<bool>(fixedCoupons.size(), false);

        for (Size i = 0; i < fixedCoupons.size(); ++i) {
            ext::shared_ptr<FixedRateCoupon> coupon =
                ext::dynamic_pointer_cast<FixedRateCoupon>(fixedCoupons[i]);
            if (coupon != nullptr) {
                arguments->fixedPayDates[i] = coupon->date();
                arguments->fixedResetDates[i] = coupon->accrualStartDate();
                arguments->fixedCoupons[i] = coupon->amount();
            } else {
                ext::shared_ptr<CashFlow> cashflow =
                    ext::dynamic_pointer_cast<CashFlow>(fixedCoupons[i]);
                auto j =
                    std::find(arguments->fixedPayDates.begin(),
                              arguments->fixedPayDates.end(), cashflow->date());
                QL_REQUIRE(j != arguments->fixedPayDates.end(),
                           "nominal redemption on "
                               << cashflow->date()
                               << "has no corresponding coupon");
                Size jIdx = j - arguments->fixedPayDates.begin();
                arguments->fixedIsRedemptionFlow[i] = true;
                arguments->fixedCoupons[i] = cashflow->amount();
                arguments->fixedResetDates[i] =
                    arguments->fixedResetDates[jIdx];
                arguments->fixedPayDates[i] = cashflow->date();
            }
        }

        const Leg &floatingCoupons = floatingLeg();

        arguments->floatingResetDates = arguments->floatingPayDates =
            arguments->floatingFixingDates =
                std::vector<Date>(floatingCoupons.size());
        arguments->floatingAccrualTimes =
            std::vector<Time>(floatingCoupons.size());
        arguments->floatingSpreads =
            std::vector<Spread>(floatingCoupons.size());
        arguments->floatingGearings = std::vector<Real>(floatingCoupons.size());
        arguments->floatingCoupons = std::vector<Real>(floatingCoupons.size());
        arguments->floatingIsRedemptionFlow =
            std::vector<bool>(floatingCoupons.size(), false);

        for (Size i = 0; i < floatingCoupons.size(); ++i) {
            ext::shared_ptr<IborCoupon> coupon =
                ext::dynamic_pointer_cast<IborCoupon>(floatingCoupons[i]);
            if (coupon != nullptr) {
                arguments->floatingResetDates[i] = coupon->accrualStartDate();
                arguments->floatingPayDates[i] = coupon->date();
                arguments->floatingFixingDates[i] = coupon->fixingDate();
                arguments->floatingAccrualTimes[i] = coupon->accrualPeriod();
                arguments->floatingSpreads[i] = coupon->spread();
                arguments->floatingGearings[i] = coupon->gearing();
                try {
                    arguments->floatingCoupons[i] = coupon->amount();
                }
                catch (Error &) {
                    arguments->floatingCoupons[i] = Null<Real>();
                }
            } else {
                ext::shared_ptr<CashFlow> cashflow =
                    ext::dynamic_pointer_cast<CashFlow>(floatingCoupons[i]);
                auto j = std::find(
                    arguments->floatingPayDates.begin(),
                    arguments->floatingPayDates.end(), cashflow->date());
                QL_REQUIRE(j != arguments->floatingPayDates.end(),
                           "nominal redemption on "
                               << cashflow->date()
                               << "has no corresponding coupon");
                Size jIdx = j - arguments->floatingPayDates.begin();
                arguments->floatingIsRedemptionFlow[i] = true;
                arguments->floatingCoupons[i] = cashflow->amount();
                arguments->floatingResetDates[i] =
                    arguments->floatingResetDates[jIdx];
                arguments->floatingFixingDates[i] =
                    arguments->floatingFixingDates[jIdx];
                arguments->floatingAccrualTimes[i] = 0.0;
                arguments->floatingSpreads[i] = 0.0;
                arguments->floatingGearings[i] = 1.0;
                arguments->floatingPayDates[i] = cashflow->date();
            }
        }

        arguments->iborIndex = iborIndex();
    }

    void NonstandardSwap::setupExpired() const { Swap::setupExpired(); }

    void NonstandardSwap::fetchResults(const PricingEngine::results *r) const {

        Swap::fetchResults(r);
    }

    void NonstandardSwap::arguments::validate() const {
        Swap::arguments::validate();
        QL_REQUIRE(fixedNominal.size() == fixedPayDates.size(),
                   "number of fixed leg nominals plus redemption flows "
                   "different from number of payment dates");
        QL_REQUIRE(fixedRate.size() == fixedPayDates.size(),
                   "number of fixed rates plus redemption flows different from "
                   "number of payment dates");
        QL_REQUIRE(floatingNominal.size() == floatingPayDates.size(),
                   "number of float leg nominals different from number of "
                   "payment dates");
        QL_REQUIRE(fixedResetDates.size() == fixedPayDates.size(),
                   "number of fixed start dates different from "
                   "number of fixed payment dates");
        QL_REQUIRE(fixedPayDates.size() == fixedCoupons.size(),
                   "number of fixed payment dates different from "
                   "number of fixed coupon amounts");
        QL_REQUIRE(floatingResetDates.size() == floatingPayDates.size(),
                   "number of floating start dates different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingFixingDates.size() == floatingPayDates.size(),
                   "number of floating fixing dates different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingAccrualTimes.size() == floatingPayDates.size(),
                   "number of floating accrual Times different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingSpreads.size() == floatingPayDates.size(),
                   "number of floating spreads different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingPayDates.size() == floatingCoupons.size(),
                   "number of floating payment dates different from "
                   "number of floating coupon amounts");
    }

    void NonstandardSwap::results::reset() { Swap::results::reset(); }
}
]]></document_content>
  </document>
  <document index="54">
    <source>nonstandardswaption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2018 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/instruments/nonstandardswaption.hpp>
#include <utility>

namespace QuantLib {

    NonstandardSwaption::NonstandardSwaption(const Swaption &fromSwaption)
        : Option(ext::shared_ptr<Payoff>(),
                 const_cast<Swaption &>(fromSwaption).exercise()),
          swap_(ext::make_shared<NonstandardSwap>(
              *fromSwaption.underlying())),
          settlementType_(fromSwaption.settlementType()),
          settlementMethod_(fromSwaption.settlementMethod()) {

        registerWith(swap_);
        // When we ask for the NPV of an expired swaption, the
        // swap is not recalculated and thus wouldn't forward
        // later notifications according to the default behavior of
        // LazyObject instances.  This means that even if the
        // evaluation date changes so that the swaption is no longer
        // expired, the instrument wouldn't be notified and thus it
        // wouldn't recalculate.  To avoid this, we override the
        // default behavior of the underlying swap.
        swap_->alwaysForwardNotifications();
    }

    NonstandardSwaption::NonstandardSwaption(ext::shared_ptr<NonstandardSwap> swap,
                                             const ext::shared_ptr<Exercise>& exercise,
                                             Settlement::Type delivery,
                                             Settlement::Method settlementMethod)
    : Option(ext::shared_ptr<Payoff>(), exercise), swap_(std::move(swap)),
      settlementType_(delivery), settlementMethod_(settlementMethod) {
        registerWith(swap_);
        swap_->alwaysForwardNotifications();
    }

    bool NonstandardSwaption::isExpired() const {

        return detail::simple_event(exercise_->dates().back()).hasOccurred();
    }

    void
    NonstandardSwaption::setupArguments(PricingEngine::arguments *args) const {

        swap_->setupArguments(args);

        auto* arguments = dynamic_cast<NonstandardSwaption::arguments*>(args);

        QL_REQUIRE(arguments != nullptr, "argument types do not match");

        arguments->swap = swap_;
        arguments->exercise = exercise_;
        arguments->settlementType = settlementType_;
        arguments->settlementMethod = settlementMethod_;
    }

    void NonstandardSwaption::arguments::validate() const {

        NonstandardSwap::arguments::validate();
        QL_REQUIRE(swap, "underlying non standard swap not set");
        QL_REQUIRE(exercise, "exercise not set");
        Settlement::checkTypeAndMethodConsistency(settlementType,
                                                  settlementMethod);
    }

    std::vector<ext::shared_ptr<BlackCalibrationHelper>>
    NonstandardSwaption::calibrationBasket(
        const ext::shared_ptr<SwapIndex>& standardSwapBase,
        const ext::shared_ptr<SwaptionVolatilityStructure>& swaptionVolatility,
        const BasketGeneratingEngine::CalibrationBasketType basketType) const {

        ext::shared_ptr<BasketGeneratingEngine> engine =
            ext::dynamic_pointer_cast<BasketGeneratingEngine>(engine_);
        QL_REQUIRE(engine, "engine is not a basket generating engine");
        engine_->reset();
        setupArguments(engine_->getArguments());
        engine_->getArguments()->validate();
        return engine->calibrationBasket(exercise_, standardSwapBase,
                                         swaptionVolatility, basketType);
    }
}
]]></document_content>
  </document>
  <document index="55">
    <source>oneassetoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/oneassetoption.hpp>
#include <ql/exercise.hpp>
#include <ql/event.hpp>

namespace QuantLib {

    OneAssetOption::OneAssetOption(
        const ext::shared_ptr<Payoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : Option(payoff, exercise) {}

    bool OneAssetOption::isExpired() const {
        return detail::simple_event(exercise_->lastDate()).hasOccurred();
    }

    Real OneAssetOption::delta() const {
        calculate();
        QL_REQUIRE(delta_ != Null<Real>(), "delta not provided");
        return delta_;
    }

    Real OneAssetOption::deltaForward() const {
        calculate();
        QL_REQUIRE(deltaForward_ != Null<Real>(),
                   "forward delta not provided");
        return deltaForward_;
    }

    Real OneAssetOption::elasticity() const {
        calculate();
        QL_REQUIRE(elasticity_ != Null<Real>(), "elasticity not provided");
        return elasticity_;
    }

    Real OneAssetOption::gamma() const {
        calculate();
        QL_REQUIRE(gamma_ != Null<Real>(), "gamma not provided");
        return gamma_;
    }

    Real OneAssetOption::theta() const {
        calculate();
        QL_REQUIRE(theta_ != Null<Real>(), "theta not provided");
        return theta_;
    }

    Real OneAssetOption::thetaPerDay() const {
        calculate();
        QL_REQUIRE(thetaPerDay_ != Null<Real>(), "theta per-day not provided");
        return thetaPerDay_;
    }

    Real OneAssetOption::vega() const {
        calculate();
        QL_REQUIRE(vega_ != Null<Real>(), "vega not provided");
        return vega_;
    }

    Real OneAssetOption::rho() const {
        calculate();
        QL_REQUIRE(rho_ != Null<Real>(), "rho not provided");
        return rho_;
    }

    Real OneAssetOption::dividendRho() const {
        calculate();
        QL_REQUIRE(dividendRho_ != Null<Real>(), "dividend rho not provided");
        return dividendRho_;
    }

    Real OneAssetOption::strikeSensitivity() const {
        calculate();
        QL_REQUIRE(strikeSensitivity_ != Null<Real>(),
                   "strike sensitivity not provided");
        return strikeSensitivity_;
    }

    Real OneAssetOption::itmCashProbability() const {
        calculate();
        QL_REQUIRE(itmCashProbability_ != Null<Real>(),
                   "in-the-money cash probability not provided");
        return itmCashProbability_;
    }

    void OneAssetOption::setupExpired() const {
        Option::setupExpired();
        delta_ = deltaForward_ = elasticity_ = gamma_ = theta_ =
            thetaPerDay_ = vega_ = rho_ = dividendRho_ =
            strikeSensitivity_ = itmCashProbability_ = 0.0;
    }

    void OneAssetOption::fetchResults(const PricingEngine::results* r) const {
        Option::fetchResults(r);
        const auto* results = dynamic_cast<const Greeks*>(r);
        QL_ENSURE(results != nullptr, "no greeks returned from pricing engine");
        /* no check on null values - just copy.
           this allows:
           a) to decide in derived options what to do when null
           results are returned (throw? numerical calculation?)
           b) to implement slim engines which only calculate the
           value---of course care must be taken not to call
           the greeks methods when using these.
        */
        delta_          = results->delta;
        gamma_          = results->gamma;
        theta_          = results->theta;
        vega_           = results->vega;
        rho_            = results->rho;
        dividendRho_    = results->dividendRho;

        const auto* moreResults = dynamic_cast<const MoreGreeks*>(r);
        QL_ENSURE(moreResults != nullptr, "no more greeks returned from pricing engine");
        /* no check on null values - just copy.
           this allows:
           a) to decide in derived options what to do when null
           results are returned (throw? numerical calculation?)
           b) to implement slim engines which only calculate the
           value---of course care must be taken not to call
           the greeks methods when using these.
        */
        deltaForward_       = moreResults->deltaForward;
        elasticity_         = moreResults->elasticity;
        thetaPerDay_        = moreResults->thetaPerDay;
        strikeSensitivity_  = moreResults->strikeSensitivity;
        itmCashProbability_ = moreResults->itmCashProbability;
    }

}

]]></document_content>
  </document>
  <document index="56">
    <source>overnightindexedswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Roland Lichters
 Copyright (C) 2009 Ferdinando Ametrano
 Copyright (C) 2017 Joseph Jeisman
 Copyright (C) 2017 Fabrice Lecuyer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/overnightindexedcoupon.hpp>
#include <ql/instruments/overnightindexedswap.hpp>
#include <utility>

namespace QuantLib {

    OvernightIndexedSwap::OvernightIndexedSwap(Type type,
                                               Real nominal,
                                               const Schedule& schedule,
                                               Rate fixedRate,
                                               DayCounter fixedDC,
                                               const ext::shared_ptr<OvernightIndex>& overnightIndex,
                                               Spread spread,
                                               Integer paymentLag,
                                               BusinessDayConvention paymentAdjustment,
                                               const Calendar& paymentCalendar,
                                               bool telescopicValueDates,
                                               RateAveraging::Type averagingMethod,
                                               Natural lookbackDays,
                                               Natural lockoutDays,
                                               bool applyObservationShift)
    : OvernightIndexedSwap(type,
                           std::vector<Real>(1, nominal),
                           schedule,
                           fixedRate,
                           std::move(fixedDC),
                           overnightIndex,
                           spread,
                           paymentLag,
                           paymentAdjustment,
                           paymentCalendar,
                           telescopicValueDates,
                           averagingMethod,
                           lookbackDays,
                           lockoutDays,
                           applyObservationShift) {}

    OvernightIndexedSwap::OvernightIndexedSwap(Type type,
                                               const std::vector<Real>& nominals,
                                               const Schedule& schedule,
                                               Rate fixedRate,
                                               DayCounter fixedDC,
                                               const ext::shared_ptr<OvernightIndex>& overnightIndex,
                                               Spread spread,
                                               Integer paymentLag,
                                               BusinessDayConvention paymentAdjustment,
                                               const Calendar& paymentCalendar,
                                               bool telescopicValueDates,
                                               RateAveraging::Type averagingMethod,
                                               Natural lookbackDays,
                                               Natural lockoutDays,
                                               bool applyObservationShift)
    : OvernightIndexedSwap(type,
                           nominals,
                           schedule,
                           fixedRate,
                           std::move(fixedDC),
                           nominals,
                           schedule,
                           overnightIndex,
                           spread,
                           paymentLag,
                           paymentAdjustment,
                           paymentCalendar,
                           telescopicValueDates,
                           averagingMethod, 
                           lookbackDays, 
                           lockoutDays, 
                           applyObservationShift) {}

    OvernightIndexedSwap::OvernightIndexedSwap(Type type,
                                               Real nominal,
                                               Schedule fixedSchedule,
                                               Rate fixedRate,
                                               DayCounter fixedDC,
                                               Schedule overnightSchedule,
                                               const ext::shared_ptr<OvernightIndex>& overnightIndex,
                                               Spread spread,
                                               Integer paymentLag,
                                               BusinessDayConvention paymentAdjustment,
                                               const Calendar& paymentCalendar,
                                               bool telescopicValueDates,
                                               RateAveraging::Type averagingMethod,
                                               Natural lookbackDays,
                                               Natural lockoutDays,
                                               bool applyObservationShift)
    : OvernightIndexedSwap(type,
                           std::vector<Real>(1, nominal),
                           std::move(fixedSchedule),
                           fixedRate,
                           std::move(fixedDC),
                           std::vector<Real>(1, nominal),
                           std::move(overnightSchedule),
                           overnightIndex,
                           spread,
                           paymentLag,
                           paymentAdjustment,
                           paymentCalendar,
                           telescopicValueDates,
                           averagingMethod,
                           lookbackDays,
                           lockoutDays,
                           applyObservationShift) {}

    OvernightIndexedSwap::OvernightIndexedSwap(Type type,
                                               std::vector<Real> fixedNominals,
                                               Schedule fixedSchedule,
                                               Rate fixedRate,
                                               DayCounter fixedDC,
                                               const std::vector<Real>& overnightNominals,
                                               Schedule overnightSchedule,
                                               const ext::shared_ptr<OvernightIndex>& overnightIndex,
                                               Spread spread,
                                               Integer paymentLag,
                                               BusinessDayConvention paymentAdjustment,
                                               const Calendar& paymentCalendar,
                                               bool telescopicValueDates,
                                               RateAveraging::Type averagingMethod,
                                               Natural lookbackDays,
                                               Natural lockoutDays,
                                               bool applyObservationShift)
    : FixedVsFloatingSwap(type, std::move(fixedNominals), std::move(fixedSchedule), fixedRate, std::move(fixedDC),
                          overnightNominals, std::move(overnightSchedule), overnightIndex,
                          spread, DayCounter(), ext::nullopt, paymentLag, paymentCalendar),
                          overnightIndex_(overnightIndex), averagingMethod_(averagingMethod),
                          lookbackDays_(lookbackDays), lockoutDays_(lockoutDays),
                          applyObservationShift_(applyObservationShift) {
        legs_[1] =
            OvernightLeg(floatingSchedule(), overnightIndex_)
                .withNotionals(overnightNominals)
                .withSpreads(spread)
                .withTelescopicValueDates(telescopicValueDates)
                .withPaymentLag(paymentLag)
                .withPaymentAdjustment(paymentAdjustment)
                .withPaymentCalendar(paymentCalendar.empty() ?
                                     floatingSchedule().calendar() :
                                     paymentCalendar)
                .withAveragingMethod(averagingMethod_)
                .withLookbackDays(lookbackDays_)
                .withLockoutDays(lockoutDays_)
                .withObservationShift(applyObservationShift_);
        for (const auto& c : legs_[1])
            registerWith(c);
    }

    void OvernightIndexedSwap::setupFloatingArguments(arguments* args) const {
        const Leg& floatingCoupons = floatingLeg();
        Size n = floatingCoupons.size();

        args->floatingResetDates = args->floatingPayDates = args->floatingFixingDates = std::vector<Date>(n);
        args->floatingAccrualTimes = std::vector<Time>(n);
        args->floatingSpreads = std::vector<Spread>(n);
        args->floatingCoupons = args->floatingNominals = std::vector<Real>(n);

        for (Size i=0; i<n; ++i) {
            auto coupon = ext::dynamic_pointer_cast<OvernightIndexedCoupon>(floatingCoupons[i]);

            args->floatingResetDates[i] = coupon->accrualStartDate();
            args->floatingPayDates[i] = coupon->date();
            args->floatingNominals[i] = coupon->nominal();

            args->floatingFixingDates[i] = coupon->fixingDate();
            args->floatingAccrualTimes[i] = coupon->accrualPeriod();
            args->floatingSpreads[i] = coupon->spread();
            try {
                args->floatingCoupons[i] = coupon->amount();
            } catch (Error&) {
                args->floatingCoupons[i] = Null<Real>();
            }
        }
    }

}
]]></document_content>
  </document>
  <document index="57">
    <source>overnightindexfuture.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Roy Zywina
 Copyright (C) 2019 Eisuke Tani

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/overnightindexfuture.hpp>
#include <ql/indexes/indexmanager.hpp>
#include <ql/event.hpp>
#include <utility>

namespace QuantLib {

    OvernightIndexFuture::OvernightIndexFuture(ext::shared_ptr<OvernightIndex> overnightIndex,
                                               const Date& valueDate,
                                               const Date& maturityDate,
                                               Handle<Quote> convexityAdjustment,
                                               RateAveraging::Type averagingMethod)
    : overnightIndex_(std::move(overnightIndex)), valueDate_(valueDate),
      maturityDate_(maturityDate), convexityAdjustment_(std::move(convexityAdjustment)),
      averagingMethod_(averagingMethod) {
        QL_REQUIRE(overnightIndex_, "null overnight index");
        registerWith(overnightIndex_);
        registerWith(convexityAdjustment_);
        registerWith(Settings::instance().evaluationDate());
    }

    Real OvernightIndexFuture::averagedRate() const {
        Date today = Settings::instance().evaluationDate();
        Calendar calendar = overnightIndex_->fixingCalendar();
        DayCounter dayCounter = overnightIndex_->dayCounter();
        Handle<YieldTermStructure> forwardCurve = overnightIndex_->forwardingTermStructure();
        Real avg = 0;
        Date d1 = valueDate_;
        // d1 could be a holiday
        Date fixingDate = calendar.adjust(d1, Preceding);
        const auto& history = overnightIndex_->timeSeries();
        Real fwd;
        while (d1 < maturityDate_) {
            Date d2 = calendar.advance(d1, 1, Days);
            if (fixingDate < today) {
                fwd = history[fixingDate];
                QL_REQUIRE(fwd != Null<Real>(),
                           "missing rate on " << fixingDate << " for index " << overnightIndex_->name());
            } else if (fixingDate == today) {
                fwd = history[fixingDate];
                if (fwd == Null<Real>())
                    fwd = forwardCurve->forwardRate(fixingDate, d2, dayCounter, Simple).rate();
            } else {
                fwd = forwardCurve->forwardRate(fixingDate, d2, dayCounter, Simple).rate();
            }
            // The rate is accrued starting from d1 even when the fixing date is earlier.
            // d2 might be beyond the maturity date if the latter is a holiday.
            avg += fwd * dayCounter.yearFraction(d1, std::min(d2, maturityDate_));
            fixingDate = d1 = d2;
        }

        return avg / dayCounter.yearFraction(valueDate_, maturityDate_);
    }

    Real OvernightIndexFuture::compoundedRate() const {
        Date today = Settings::instance().evaluationDate();
        Calendar calendar = overnightIndex_->fixingCalendar();
        DayCounter dayCounter = overnightIndex_->dayCounter();
        Handle<YieldTermStructure> forwardCurve = overnightIndex_->forwardingTermStructure();
        Real prod = 1;
        Date forwardDiscountStart = valueDate_;
        if (today > valueDate_) {
            // can't value on a weekend inside reference period because we
            // won't know the reset rate until start of next business day.
            // user can supply an estimate if they really want to do this
            today = calendar.adjust(today);
            forwardDiscountStart = today;
            // for valuations inside the reference period, index quotes
            // must have been populated in the history
            const auto& history = overnightIndex_->timeSeries();
            Date d1 = valueDate_;
            // d1 could be a holiday
            Date fixingDate = calendar.adjust(d1, Preceding);
            while (d1 < today) {
                Real r = history[fixingDate];
                QL_REQUIRE(r != Null<Real>(),
                           "missing rate on " << fixingDate << " for index " << overnightIndex_->name());
                Date d2 = calendar.advance(d1, 1, Days);
                // The rate is accrued starting from d1 even when the fixing date is earlier.
                // We can't get to the maturity date inside this loop,
                // so we don't need to cap d2 like we do in averagedRate above.
                prod *= 1 + r * dayCounter.yearFraction(d1, d2);
                fixingDate = d1 = d2;
            }
            // here d1 == today, and we might have today's fixing already
            if (today < maturityDate_) {
                Real r = history[today];
                if (r != Null<Real>()) {
                    Date tomorrow = calendar.advance(today, 1, Days);
                    prod *= 1 + r * dayCounter.yearFraction(today, tomorrow);
                    forwardDiscountStart = tomorrow;
                }
            }
        }
        // the telescopic part goes from the end of the last known fixing to the maturity
        DiscountFactor forwardDiscount =
            forwardCurve->discount(maturityDate_) / forwardCurve->discount(forwardDiscountStart);
        prod /= forwardDiscount;

        return (prod - 1) / dayCounter.yearFraction(valueDate_, maturityDate_);
    }

    Real OvernightIndexFuture::rate() const {
        switch (averagingMethod_) {
          case RateAveraging::Simple:
            return averagedRate();
          case RateAveraging::Compound:
            return compoundedRate();
          default:
              QL_FAIL("unknown compounding convention (" << Integer(averagingMethod_) << ")");
        }
    }

    bool OvernightIndexFuture::isExpired() const {
        return detail::simple_event(maturityDate_).hasOccurred();
    }

    Real OvernightIndexFuture::convexityAdjustment() const {
        return convexityAdjustment_.empty() ? 0.0 : convexityAdjustment_->value();
    }

    void OvernightIndexFuture::performCalculations() const {
        Rate R = convexityAdjustment() + rate();
        NPV_ = 100.0 * (1.0 - R);
    }

}
]]></document_content>
  </document>
  <document index="58">
    <source>partialtimebarrieroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/partialtimebarrieroption.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    PartialTimeBarrierOption::PartialTimeBarrierOption(
                           Barrier::Type barrierType,
                           PartialBarrier::Range barrierRange,
                           Real barrier,
                           Real rebate,
                           Date coverEventDate,
                           const ext::shared_ptr<StrikedTypePayoff>& payoff,
                           const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise),
      barrierType_(barrierType), barrierRange_(barrierRange),
      barrier_(barrier), rebate_(rebate),
      coverEventDate_(coverEventDate) {}

    void PartialTimeBarrierOption::setupArguments(
                                       PricingEngine::arguments* args) const {
        OneAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<PartialTimeBarrierOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->barrierType = barrierType_;
        moreArgs->barrierRange = barrierRange_;
        moreArgs->barrier = barrier_;
        moreArgs->rebate = rebate_;
        moreArgs->coverEventDate = coverEventDate_;
    }

    PartialTimeBarrierOption::arguments::arguments()
    : barrierType(Barrier::Type(-1)),
      barrierRange(PartialBarrier::Range(-1)),
      barrier(Null<Real>()), rebate(Null<Real>()) {}

    void PartialTimeBarrierOption::arguments::validate() const {
        OneAssetOption::arguments::validate();

        QL_REQUIRE(barrier != Null<Real>(), "no barrier given");
        QL_REQUIRE(rebate != Null<Real>(), "no rebate given");
        QL_REQUIRE(coverEventDate != Date(), "no cover event date given");
        QL_REQUIRE(coverEventDate < exercise->lastDate(),
                   "cover event date equal or later than exercise date");
    }

}
]]></document_content>
  </document>
  <document index="59">
    <source>payoffs.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2006 Ferdinando Ametrano
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2006, 2008 StatPro Italia srl
 Copyright (C) 2006 Chiara Fornarola

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    std::string NullPayoff::name() const {
        return "Null";
    }

    std::string NullPayoff::description() const {
        return name();
    }

    Real NullPayoff::operator()(Real) const {
        QL_FAIL("dummy payoff given");
    }

    void NullPayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<NullPayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }



    std::string TypePayoff::description() const {
        std::ostringstream result;
        result << name() << " " << optionType();
        return result.str();
    }

    //std::string StrikedPayoff::description() const {
    //    std::ostringstream result;
    //    result << ", " << strike() << " strike";
    //    return result.str();
    //}

    Real FloatingTypePayoff::operator()(Real) const {
        QL_FAIL("floating payoff not handled");
    }

    Real FloatingTypePayoff::operator()(Real price, Real strike) const {
        switch (type_) {
            case Option::Call:
                return std::max<Real>(price - strike,0.0);
            case Option::Put:
                return std::max<Real>(strike - price,0.0);
            default:
                QL_FAIL("unknown/illegal option type");
        }
    }

    std::string StrikedTypePayoff::description() const {
        std::ostringstream result;
        result << TypePayoff::description() << ", " <<
                  strike() << " strike";
        return result.str();
    }

    void FloatingTypePayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<FloatingTypePayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }

    Real PlainVanillaPayoff::operator()(Real price) const {
        switch (type_) {
          case Option::Call:
            return std::max<Real>(price-strike_,0.0);
          case Option::Put:
            return std::max<Real>(strike_-price,0.0);
          default:
            QL_FAIL("unknown/illegal option type");
        }
    }

    void PlainVanillaPayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<PlainVanillaPayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }

    Real PercentageStrikePayoff::operator()(Real price) const {
        switch (type_) {
          case Option::Call:
            return price*std::max<Real>(Real(1.0)-strike_,0.0);
          case Option::Put:
            return price*std::max<Real>(strike_-Real(1.0),0.0);
          default:
            QL_FAIL("unknown/illegal option type");
        }
    }

    void PercentageStrikePayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<PercentageStrikePayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }

    Real AssetOrNothingPayoff::operator()(Real price) const {
        switch (type_) {
          case Option::Call:
            return (price-strike_ > 0.0 ? price : 0.0);
          case Option::Put:
            return (strike_-price > 0.0 ? price : 0.0);
          default:
            QL_FAIL("unknown/illegal option type");
        }
    }

    void AssetOrNothingPayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<AssetOrNothingPayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }

    std::string CashOrNothingPayoff::description() const {
        std::ostringstream result;
        result << StrikedTypePayoff::description() << ", " << cashPayoff() << " cash payoff";
        return result.str();
    }

    Real CashOrNothingPayoff::operator()(Real price) const {
        switch (type_) {
          case Option::Call:
            return (price-strike_ > 0.0 ? cashPayoff_ : 0.0);
          case Option::Put:
            return (strike_-price > 0.0 ? cashPayoff_ : 0.0);
          default:
            QL_FAIL("unknown/illegal option type");
        }
    }

    void CashOrNothingPayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<CashOrNothingPayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);}

    std::string GapPayoff::description() const {
        std::ostringstream result;
        result << StrikedTypePayoff::description() << ", " << secondStrike() << " strike payoff";
        return result.str();
    }

    Real GapPayoff::operator()(Real price) const {
        switch (type_) {
          case Option::Call:
            return (price-strike_ >= 0.0 ? Real(price-secondStrike_) : 0.0);
          case Option::Put:
              return (strike_ - price >= 0.0 ? Real(secondStrike_ - price) : 0.0);
          default:
            QL_FAIL("unknown/illegal option type");
        }
    }

    void GapPayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<GapPayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }

    Real SuperFundPayoff::operator()(Real price) const {
        return (price>=strike_ && price<secondStrike_) ? Real(price/strike_) : 0.0;
    }

    void SuperFundPayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<SuperFundPayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }
    std::string SuperSharePayoff::description() const {
        std::ostringstream result;
        result << StrikedTypePayoff::description() << ", " << secondStrike() << " second strike"<< ", " << cashPayoff() << " amount";
        return result.str();
    }

    Real SuperSharePayoff::operator()(Real price) const {
        return (price>=strike_ && price<secondStrike_) ? cashPayoff_ : 0.0;
    }

    void SuperSharePayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<SuperSharePayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }

}
]]></document_content>
  </document>
  <document index="60">
    <source>perpetualfutures.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2025 Hiroto Ogawa

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/perpetualfutures.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <utility>

namespace QuantLib {

    PerpetualFutures::PerpetualFutures(
        PerpetualFutures::PayoffType payoffType,
        PerpetualFutures::FundingType fundingType,
        Period fundingFrequency,
        Calendar cal,
        DayCounter dc) : payoffType_(payoffType), fundingType_(fundingType), fundingFrequency_(fundingFrequency),
        cal_(std::move(cal)), dc_(std::move(dc)) {
    }

    void PerpetualFutures::setupArguments(PricingEngine::arguments* args) const {
        auto* moreArgs = dynamic_cast<PerpetualFutures::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->payoffType = payoffType_;
        moreArgs->fundingType = fundingType_;
        moreArgs->fundingFrequency = fundingFrequency_;
        moreArgs->cal = cal_;
        moreArgs->dc = dc_;
    }

    PerpetualFutures::arguments::arguments()
    : payoffType(PerpetualFutures::PayoffType(-1)), fundingType(PerpetualFutures::FundingType(-1)),
      fundingFrequency(Period(8, Hours)), cal(NullCalendar()),
      dc(ActualActual(ActualActual::ISDA)) {}

    void PerpetualFutures::arguments::validate() const {
        switch (payoffType) {
            case PerpetualFutures::Linear:
            case PerpetualFutures::Inverse:
            case PerpetualFutures::Quanto:
                break;
            default:
                QL_FAIL("unknown payoff type");
        }
        switch (fundingType) {
            case PerpetualFutures::FundingWithPreviousSpot:
                break;
            case PerpetualFutures::FundingWithCurrentSpot:
                break;
            default:
                QL_FAIL("unknown funding type");
        }
    }

    std::ostream& operator<<(std::ostream& out, PerpetualFutures::PayoffType type) {
        switch (type) {
            case PerpetualFutures::Linear:
                return out << "Linear";
            case PerpetualFutures::Inverse:
                return out << "Inverse";
            case PerpetualFutures::Quanto:
                return out << "Quanto";
            default:
                QL_FAIL("unknown PerpetualFutures::PayoffType(" << int(type) << ")");
        }
    }

    std::ostream& operator<<(std::ostream& out, PerpetualFutures::FundingType type) {
        switch (type) {
            case PerpetualFutures::FundingWithPreviousSpot:
                return out << "FundingWithPreviousSpot";
            case PerpetualFutures::FundingWithCurrentSpot:
                return out << "FundingWithCurrentSpot";
            default:
                QL_FAIL("unknown PerpetualFutures::FundingType(" << int(type) << ")");
        }
    }

}

]]></document_content>
  </document>
  <document index="61">
    <source>quantobarrieroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Paul Farrington

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/quantobarrieroption.hpp>

namespace QuantLib {

    QuantoBarrierOption::QuantoBarrierOption(
                        Barrier::Type barrierType,
                        Real barrier,
                        Real rebate,
                        const ext::shared_ptr<StrikedTypePayoff>& payoff,
                        const ext::shared_ptr<Exercise>& exercise)
    : BarrierOption(barrierType, barrier, rebate, payoff, exercise) {}

    Real QuantoBarrierOption::qvega() const {
        calculate();
        QL_REQUIRE(qvega_ != Null<Real>(),
                   "exchange rate vega calculation failed");
        return qvega_;
    }

    Real QuantoBarrierOption::qrho() const {
        calculate();
        QL_REQUIRE(qrho_ != Null<Real>(),
                   "foreign interest rate rho calculation failed");
        return qrho_;
    }

    Real QuantoBarrierOption::qlambda() const {
        calculate();
        QL_REQUIRE(qlambda_ != Null<Real>(),
                   "quanto correlation sensitivity calculation failed");
        return qlambda_;
    }

    void QuantoBarrierOption::setupExpired() const {
        BarrierOption::setupExpired();
        qvega_ = qrho_ = qlambda_ = 0.0;
    }

    void QuantoBarrierOption::fetchResults(
                                      const PricingEngine::results* r) const {
        BarrierOption::fetchResults(r);
        const auto* quantoResults = dynamic_cast<const QuantoBarrierOption::results*>(r);
        QL_ENSURE(quantoResults != nullptr, "no quanto results returned from pricing engine");
        qrho_    = quantoResults->qrho;
        qvega_   = quantoResults->qvega;
        qlambda_ = quantoResults->qlambda;
    }

}

]]></document_content>
  </document>
  <document index="62">
    <source>quantoforwardvanillaoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/quantoforwardvanillaoption.hpp>

namespace QuantLib {

    QuantoForwardVanillaOption::QuantoForwardVanillaOption(
                           Real moneyness,
                           const Date& resetDate,
                           const ext::shared_ptr<StrikedTypePayoff>& payoff,
                           const ext::shared_ptr<Exercise>& exercise)
    : ForwardVanillaOption(moneyness, resetDate, payoff, exercise) {}

    Real QuantoForwardVanillaOption::qvega() const {
        calculate();
        QL_REQUIRE(qvega_ != Null<Real>(),
                   "exchange rate vega calculation failed");
        return qvega_;
    }

    Real QuantoForwardVanillaOption::qrho() const {
        calculate();
        QL_REQUIRE(qrho_ != Null<Real>(),
                   "foreign interest rate rho calculation failed");
        return qrho_;
    }

    Real QuantoForwardVanillaOption::qlambda() const {
        calculate();
        QL_REQUIRE(qlambda_ != Null<Real>(),
                   "quanto correlation sensitivity calculation failed");
        return qlambda_;
    }

    void QuantoForwardVanillaOption::setupExpired() const {
        ForwardVanillaOption::setupExpired();
        qvega_ = qrho_ = qlambda_ = 0.0;
    }

    void QuantoForwardVanillaOption::fetchResults(
                                      const PricingEngine::results* r) const {
        ForwardVanillaOption::fetchResults(r);
        const auto* quantoResults = dynamic_cast<const QuantoForwardVanillaOption::results*>(r);
        QL_ENSURE(quantoResults != nullptr, "no quanto results returned from pricing engine");
        qrho_    = quantoResults->qrho;
        qvega_   = quantoResults->qvega;
        qlambda_ = quantoResults->qlambda;
    }

}

]]></document_content>
  </document>
  <document index="63">
    <source>quantovanillaoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/quantovanillaoption.hpp>

namespace QuantLib {

    QuantoVanillaOption::QuantoVanillaOption(
                   const ext::shared_ptr<StrikedTypePayoff>& payoff,
                   const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise) {}

    Real QuantoVanillaOption::qvega() const {
        calculate();
        QL_REQUIRE(qvega_ != Null<Real>(),
                   "exchange rate vega calculation failed");
        return qvega_;
    }

    Real QuantoVanillaOption::qrho() const {
        calculate();
        QL_REQUIRE(qrho_ != Null<Real>(),
                   "foreign interest rate rho calculation failed");
        return qrho_;
    }

    Real QuantoVanillaOption::qlambda() const {
        calculate();
        QL_REQUIRE(qlambda_ != Null<Real>(),
                   "quanto correlation sensitivity calculation failed");
        return qlambda_;
    }

    void QuantoVanillaOption::setupExpired() const {
        OneAssetOption::setupExpired();
        qvega_ = qrho_ = qlambda_ = 0.0;
    }

    void QuantoVanillaOption::fetchResults(
                                      const PricingEngine::results* r) const {
        OneAssetOption::fetchResults(r);
        const auto* quantoResults = dynamic_cast<const QuantoVanillaOption::results*>(r);
        QL_ENSURE(quantoResults != nullptr, "no quanto results returned from pricing engine");
        qrho_    = quantoResults->qrho;
        qvega_   = quantoResults->qvega;
        qlambda_ = quantoResults->qlambda;
    }

}

]]></document_content>
  </document>
  <document index="64">
    <source>simplechooseroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/simplechooseroption.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    SimpleChooserOption::SimpleChooserOption(Date choosingDate,
                                             Real strike,
                                             const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(ext::make_shared<PlainVanillaPayoff>(Option::Call, strike),
                     exercise),
      choosingDate_(choosingDate) {}

    void SimpleChooserOption::setupArguments(PricingEngine::arguments* args) const {
        OneAssetOption::setupArguments(args);
        auto* moreArgs = dynamic_cast<SimpleChooserOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->choosingDate=choosingDate_;
    }

    void SimpleChooserOption::arguments::validate() const {
        OneAssetOption::arguments::validate();
        QL_REQUIRE(choosingDate != Date(), " no choosing date given");
        QL_REQUIRE(choosingDate < exercise->lastDate(),
                   "choosing date later than or equal to maturity date");
    }

}
]]></document_content>
  </document>
  <document index="65">
    <source>simplifynotificationgraph.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2023 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/simplifynotificationgraph.hpp>

namespace QuantLib {


    void simplifyNotificationGraph(Instrument& instrument, const Leg& leg, bool unregisterCoupons) {
        for (auto const& coupon : leg) {
            instrument.unregisterWith(coupon);
            instrument.registerWithObservables(coupon);
            if (unregisterCoupons) {
                coupon->unregisterWithAll();
            }
        }
    }

    void simplifyNotificationGraph(Swap& swap, const bool unregisterCoupons) {
        for (auto const& leg : swap.legs())
            simplifyNotificationGraph(swap, leg, unregisterCoupons);
    }

    void simplifyNotificationGraph(Bond& bond, const bool unregisterCoupons) {
        simplifyNotificationGraph(bond, bond.cashflows(), unregisterCoupons);
    }


}
]]></document_content>
  </document>
  <document index="66">
    <source>softbarrieroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2025 William Day

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license. You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE. See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/instruments/softbarrieroption.hpp>
#include <ql/instruments/impliedvolatility.hpp>
#include <ql/pricingengines/barrier/analyticsoftbarrierengine.hpp>

namespace QuantLib {

    SoftBarrierOption::SoftBarrierOption(
        Barrier::Type barrierType,
        Real barrier_lo,
        Real barrier_hi,
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise),
      barrierType_(barrierType), barrier_lo_(barrier_lo),
      barrier_hi_(barrier_hi) {}

    void SoftBarrierOption::setupArguments(PricingEngine::arguments* args) const {
        OneAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<SoftBarrierOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->barrierType = barrierType_;
        moreArgs->barrier_lo = barrier_lo_;
        moreArgs->barrier_hi = barrier_hi_;
    }

    Volatility SoftBarrierOption::impliedVolatility(      
             Real targetValue,
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             Real accuracy,
             Size maxEvaluations,
             Volatility minVol,
             Volatility maxVol) const {

        QL_REQUIRE(!isExpired(), "option expired");

        ext::shared_ptr<SimpleQuote> volQuote(new SimpleQuote);

        ext::shared_ptr<GeneralizedBlackScholesProcess> newProcess =
            detail::ImpliedVolatilityHelper::clone(process, volQuote);

        std::unique_ptr<PricingEngine> engine;
        switch (exercise_->type()) {
            case Exercise::European:
              engine = std::make_unique<AnalyticSoftBarrierEngine>(newProcess);
              break;
          case Exercise::American:
          case Exercise::Bermudan:
            QL_FAIL("engine not available for non-European soft barrier option");
          default:
            QL_FAIL("unknown exercise type");
        }

        return detail::ImpliedVolatilityHelper::calculate(*this,
                                                          *engine,
                                                          *volQuote,
                                                          targetValue,
                                                          accuracy,
                                                          maxEvaluations,
                                                          minVol, maxVol);
    }

    SoftBarrierOption::arguments::arguments()
    : barrierType(Barrier::Type(-1)),
      barrier_lo(Null<Real>()), barrier_hi(Null<Real>()) {}

}]]></document_content>
  </document>
  <document index="67">
    <source>stickyratchet.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2007 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/stickyratchet.hpp>

namespace QuantLib {

    // Double Sticky/Ratchet payoffs
    Real DoubleStickyRatchetPayoff::operator()(Real forward) const {
        QL_REQUIRE((std::fabs(type1_)==1.0 || type1_==0.0),
            "unknown/illegal type1 value (only 0.0 and +/-1,0 are allowed))");
        QL_REQUIRE((std::fabs(type2_)==1.0 || type2_==0.0),
            "unknown/illegal type2 value(only 0.0 and +/-1,0 are allowed)");
        Real swaplet = gearing3_ * forward + spread3_;
        Real effStrike1 = gearing1_ * initialValue1_ + spread1_;
        Real effStrike2 = gearing2_ * initialValue2_ + spread2_;
        Real effStrike3 = type1_*type2_*std::max<Real>(type2_*(swaplet-effStrike2),0.0);
        Real price = accrualFactor_ * (swaplet -
                    type1_*std::max<Real>(type1_*(swaplet-effStrike1),effStrike3));
        return price;
    }

    std::string DoubleStickyRatchetPayoff::name() const {
        return "DoubleStickyRatchetPayoff";
    }

    std::string DoubleStickyRatchetPayoff::description() const {
        std::ostringstream result;
        result << name();
        return result.str();
    }

    void DoubleStickyRatchetPayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<DoubleStickyRatchetPayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }

/*---------------------------------------------------------------------------

    // Old code for single sticky/ratchet payoffs,
    // superated by DoubleStickyRatchetPayoff class above

    // Single Sticky/Ratchet payoffs
    Real StickyRatchetPayoff::operator()(Real forward) const {
        QL_REQUIRE(abs(type_)==1.0, "unknown/illegal option type");
        Real swaplet = gearing2_ * forward + spread2_;
        Real effStrike = gearing2_ * initialValue_ + spread2_;
        Real price = accrualFactor_ * (swaplet -
                    type_*std::max<Real>(type_*(swaplet-effStrike),0.0));
        return price;
    }

    std::string StickyRatchetPayoff::description() const {
        std::ostringstream result;
        result << name();
        return result.str();
    }

    void StickyRatchetPayoff::accept(AcyclicVisitor& v) {
        Visitor<StickyRatchetPayoff>* v1 =
            dynamic_cast<Visitor<StickyRatchetPayoff>*>(&v);
        if (v1 != 0)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }
-----------------------------------------------------------------------------*/

}
]]></document_content>
  </document>
  <document index="68">
    <source>stock.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/stock.hpp>
#include <utility>

namespace QuantLib {

    Stock::Stock(Handle<Quote> quote) : quote_(std::move(quote)) { registerWith(quote_); }

    void Stock::performCalculations() const {
        QL_REQUIRE(!quote_.empty(), "null quote set");
        NPV_ = quote_->value();
    }

}

]]></document_content>
  </document>
  <document index="69">
    <source>swap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2011 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2007, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/swap.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/floatingratecoupon.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ostream>

namespace QuantLib {

    Swap::Swap(const Leg& firstLeg,
               const Leg& secondLeg)
    : legs_(2), payer_(2),
      legNPV_(2, 0.0), legBPS_(2, 0.0),
      startDiscounts_(2, 0.0), endDiscounts_(2, 0.0),
      npvDateDiscount_(0.0) {
        legs_[0] = firstLeg;
        legs_[1] = secondLeg;
        payer_[0] = -1.0;
        payer_[1] =  1.0;
        for (auto& i : legs_[0])
            registerWith(i);
        for (auto& i : legs_[1])
            registerWith(i);
    }

    Swap::Swap(const std::vector<Leg>& legs,
               const std::vector<bool>& payer)
    : legs_(legs), payer_(legs.size(), 1.0),
      legNPV_(legs.size(), 0.0), legBPS_(legs.size(), 0.0),
      startDiscounts_(legs.size(), 0.0), endDiscounts_(legs.size(), 0.0),
      npvDateDiscount_(0.0) {
        QL_REQUIRE(payer.size()==legs_.size(),
                   "size mismatch between payer (" << payer.size() <<
                   ") and legs (" << legs_.size() << ")");
        for (Size j=0; j<legs_.size(); ++j) {
            if (payer[j]) payer_[j]=-1.0;
            for (auto& i : legs_[j])
                registerWith(i);
        }
    }

    Swap::Swap(Size legs)
    : legs_(legs), payer_(legs),
      legNPV_(legs, 0.0), legBPS_(legs, 0.0),
      startDiscounts_(legs, 0.0), endDiscounts_(legs, 0.0),
      npvDateDiscount_(0.0) {}

    bool Swap::isExpired() const {
        for (const auto& leg : legs_) {
            Leg::const_iterator i;
            for (i = leg.begin(); i != leg.end(); ++i)
                if (!(*i)->hasOccurred())
                    return false;
        }
        return true;
    }

    void Swap::setupExpired() const {
        Instrument::setupExpired();
        std::fill(legBPS_.begin(), legBPS_.end(), 0.0);
        std::fill(legNPV_.begin(), legNPV_.end(), 0.0);
        std::fill(startDiscounts_.begin(), startDiscounts_.end(), 0.0);
        std::fill(endDiscounts_.begin(), endDiscounts_.end(), 0.0);
        npvDateDiscount_ = 0.0;
    }

    void Swap::setupArguments(PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<Swap::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->legs = legs_;
        arguments->payer = payer_;
    }

    void Swap::fetchResults(const PricingEngine::results* r) const {
        Instrument::fetchResults(r);

        const auto* results = dynamic_cast<const Swap::results*>(r);
        QL_REQUIRE(results != nullptr, "wrong result type");

        if (!results->legNPV.empty()) {
            QL_REQUIRE(results->legNPV.size() == legNPV_.size(),
                       "wrong number of leg NPV returned");
            legNPV_ = results->legNPV;
        } else {
            std::fill(legNPV_.begin(), legNPV_.end(), Null<Real>());
        }

        if (!results->legBPS.empty()) {
            QL_REQUIRE(results->legBPS.size() == legBPS_.size(),
                       "wrong number of leg BPS returned");
            legBPS_ = results->legBPS;
        } else {
            std::fill(legBPS_.begin(), legBPS_.end(), Null<Real>());
        }

        if (!results->startDiscounts.empty()) {
            QL_REQUIRE(results->startDiscounts.size() == startDiscounts_.size(),
                       "wrong number of leg start discounts returned");
            startDiscounts_ = results->startDiscounts;
        } else {
            std::fill(startDiscounts_.begin(), startDiscounts_.end(),
                                                    Null<DiscountFactor>());
        }

        if (!results->endDiscounts.empty()) {
            QL_REQUIRE(results->endDiscounts.size() == endDiscounts_.size(),
                       "wrong number of leg end discounts returned");
            endDiscounts_ = results->endDiscounts;
        } else {
            std::fill(endDiscounts_.begin(), endDiscounts_.end(),
                                                    Null<DiscountFactor>());
        }

        if (results->npvDateDiscount != Null<DiscountFactor>()) {
            npvDateDiscount_ = results->npvDateDiscount;
        } else {
            npvDateDiscount_ = Null<DiscountFactor>();
        }
    }

    Size Swap::numberOfLegs() const { return legs_.size(); }

    const std::vector<Leg>& Swap::legs() const { return legs_; }

    Date Swap::startDate() const {
        QL_REQUIRE(!legs_.empty(), "no legs given");
        Date d = CashFlows::startDate(legs_[0]);
        for (Size j=1; j<legs_.size(); ++j)
            d = std::min(d, CashFlows::startDate(legs_[j]));
        return d;
    }

    Date Swap::maturityDate() const {
        QL_REQUIRE(!legs_.empty(), "no legs given");
        Date d = CashFlows::maturityDate(legs_[0]);
        for (Size j=1; j<legs_.size(); ++j)
            d = std::max(d, CashFlows::maturityDate(legs_[j]));
        return d;
    }

    void Swap::deepUpdate() {
        for (auto& leg : legs_) {
            for (auto& k : leg) {
                k->deepUpdate();
            }
        }
        update();
    }

    void Swap::arguments::validate() const {
        QL_REQUIRE(legs.size() == payer.size(),
                   "number of legs and multipliers differ");
    }

    void Swap::results::reset() {
        Instrument::results::reset();
        legNPV.clear();
        legBPS.clear();
        startDiscounts.clear();
        endDiscounts.clear();
        npvDateDiscount = Null<DiscountFactor>();
    }

    std::ostream& operator<<(std::ostream& out, Swap::Type t) {
        switch (t) {
          case Swap::Payer:
            return out << "Payer";
          case Swap::Receiver:
            return out << "Receiver";
          default:
            QL_FAIL("unknown Swap::Type(" << Integer(t) << ")");
        }
    }

}
]]></document_content>
  </document>
  <document index="70">
    <source>swaption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2006 Cristina Duminuco
 Copyright (C) 2006 Marco Bianchetti
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2014 Ferdinando Ametrano
 Copyright (C) 2016, 2018 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/any.hpp>
#include <ql/exercise.hpp>
#include <ql/instruments/swaption.hpp>
#include <ql/math/solvers1d/newtonsafe.hpp>
#include <ql/pricingengines/swaption/blackswaptionengine.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/shared_ptr.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        class ImpliedSwaptionVolHelper {
          public:
            ImpliedSwaptionVolHelper(const Swaption&,
                                     Handle<YieldTermStructure> discountCurve,
                                     Real targetValue,
                                     Real displacement,
                                     VolatilityType type);
            Real operator()(Volatility x) const;
            Real derivative(Volatility x) const;
          private:
            ext::shared_ptr<PricingEngine> engine_;
            Handle<YieldTermStructure> discountCurve_;
            Real targetValue_;
            ext::shared_ptr<SimpleQuote> vol_;
            const Instrument::results* results_;
        };

        ImpliedSwaptionVolHelper::ImpliedSwaptionVolHelper(const Swaption& swaption,
                                                           Handle<YieldTermStructure> discountCurve,
                                                           Real targetValue,
                                                           Real displacement,
                                                           VolatilityType type)
        : discountCurve_(std::move(discountCurve)), targetValue_(targetValue),
          vol_(ext::make_shared<SimpleQuote>(-1.0)) {

            // vol_ is set an implausible value, so that calculation is forced
            // at first ImpliedSwaptionVolHelper::operator()(Volatility x) call

            Handle<Quote> h(vol_);

            switch (type) {
            case ShiftedLognormal:
                engine_ = ext::make_shared<BlackSwaptionEngine>(
                    discountCurve_, h, Actual365Fixed(), displacement);
                break;
            case Normal:
                engine_ = ext::make_shared<BachelierSwaptionEngine>(
                    discountCurve_, h, Actual365Fixed());
                break;
            default:
                QL_FAIL("unknown VolatilityType (" << type << ")");
                break;
            }
            swaption.setupArguments(engine_->getArguments());
            results_ = dynamic_cast<const Instrument::results *>(
                engine_->getResults());
        }

        Real ImpliedSwaptionVolHelper::operator()(Volatility x) const {
            if (x!=vol_->value()) {
                vol_->setValue(x);
                engine_->calculate();
            }
            return results_->value-targetValue_;
        }

        Real ImpliedSwaptionVolHelper::derivative(Volatility x) const {
            if (x!=vol_->value()) {
                vol_->setValue(x);
                engine_->calculate();
            }
            auto vega_ = results_->additionalResults.find("vega");
            QL_REQUIRE(vega_ != results_->additionalResults.end(),
                       "vega not provided");
            return ext::any_cast<Real>(vega_->second);
        }
    }

    std::ostream& operator<<(std::ostream& out,
                             Settlement::Type t) {
        switch (t) {
          case Settlement::Physical:
            return out << "Delivery";
          case Settlement::Cash:
            return out << "Cash";
          default:
            QL_FAIL("unknown Settlement::Type(" << Integer(t) << ")");
        }
    }

    std::ostream& operator<<(std::ostream& out, Settlement::Method m) {
        switch (m) {
        case Settlement::PhysicalOTC:
            return out << "PhysicalOTC";
        case Settlement::PhysicalCleared:
            return out << "PhysicalCleared";
        case Settlement::CollateralizedCashPrice:
            return out << "CollateralizedCashPrice";
        case Settlement::ParYieldCurve:
            return out << "ParYieldCurve";
        default:
            QL_FAIL("unknown Settlement::Method(" << Integer(m) << ")");
        }
    }

    Swaption::Swaption(ext::shared_ptr<FixedVsFloatingSwap> swap,
                       const ext::shared_ptr<Exercise>& exercise,
                       Settlement::Type delivery,
                       Settlement::Method settlementMethod)
    : Option(ext::shared_ptr<Payoff>(), exercise), swap_(std::move(swap)),
      settlementType_(delivery), settlementMethod_(settlementMethod) {
        registerWith(swap_);
        // When we ask for the NPV of an expired swaption, the
        // swap is not recalculated and thus wouldn't forward
        // later notifications according to the default behavior of
        // LazyObject instances.  This means that even if the
        // evaluation date changes so that the swaption is no longer
        // expired, the instrument wouldn't be notified and thus it
        // wouldn't recalculate.  To avoid this, we override the
        // default behavior of the underlying swap.
        swap_->alwaysForwardNotifications();

        vanilla_ = ext::dynamic_pointer_cast<VanillaSwap>(swap_);
    }

    void Swaption::deepUpdate() {
        swap_->deepUpdate();
        update();
    }

    bool Swaption::isExpired() const {
        return detail::simple_event(exercise_->dates().back()).hasOccurred();
    }

    void Swaption::setupArguments(PricingEngine::arguments* args) const {

        swap_->setupArguments(args);
        auto* arguments = dynamic_cast<Swaption::arguments*>(args);

        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->swap = swap_;
        arguments->settlementType = settlementType_;
        arguments->settlementMethod = settlementMethod_;
        arguments->exercise = exercise_;
    }

    void Swaption::arguments::validate() const {
        FixedVsFloatingSwap::arguments::validate();
        QL_REQUIRE(swap, "swap not set");
        QL_REQUIRE(exercise, "exercise not set");
        Settlement::checkTypeAndMethodConsistency(settlementType, settlementMethod);
    }

    Volatility Swaption::impliedVolatility(Real targetValue,
                                           const Handle<YieldTermStructure>& discountCurve,
                                           Volatility guess,
                                           Real accuracy,
                                           Natural maxEvaluations,
                                           Volatility minVol,
                                           Volatility maxVol,
                                           VolatilityType type,
                                           Real displacement,
                                           PriceType priceType) const {

        QL_REQUIRE(!isExpired(), "instrument expired");
        QL_REQUIRE(exercise_->type() == Exercise::European, "not a European option");

        if (priceType == Forward) {
            // convert to spot
            targetValue *= discountCurve->discount(exercise_->date(0));
        }

        ImpliedSwaptionVolHelper f(*this, discountCurve, targetValue, displacement, type);
        NewtonSafe solver;
        solver.setMaxEvaluations(maxEvaluations);
        return solver.solve(f, accuracy, guess, minVol, maxVol);
    }

    void Settlement::checkTypeAndMethodConsistency(
                                        Settlement::Type settlementType,
                                        Settlement::Method settlementMethod) {
        if (settlementType == Physical) {
            QL_REQUIRE(settlementMethod == PhysicalOTC ||
                       settlementMethod == PhysicalCleared,
                       "invalid settlement method for physical settlement");
        }
        if (settlementType == Cash) {
            QL_REQUIRE(settlementMethod == CollateralizedCashPrice ||
                       settlementMethod == ParYieldCurve,
                       "invalid settlement method for cash settlement");
        }
    }

}
]]></document_content>
  </document>
  <document index="71">
    <source>twoassetbarrieroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/twoassetbarrieroption.hpp>
#include <ql/exercise.hpp>
#include <ql/event.hpp>

namespace QuantLib {

    TwoAssetBarrierOption::TwoAssetBarrierOption(
                           Barrier::Type barrierType,
                           Real barrier,
                           const ext::shared_ptr<StrikedTypePayoff>& payoff,
                           const ext::shared_ptr<Exercise>& exercise)
    : Option(payoff, exercise), barrierType_(barrierType), barrier_(barrier) {}

    void TwoAssetBarrierOption::setupArguments(
                                       PricingEngine::arguments* args) const {
        Option::setupArguments(args);
        auto* moreArgs = dynamic_cast<TwoAssetBarrierOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->barrierType = barrierType_;
        moreArgs->barrier = barrier_;
    }
    
    bool TwoAssetBarrierOption::isExpired() const {
        return detail::simple_event(exercise_->lastDate()).hasOccurred();
    }

    TwoAssetBarrierOption::arguments::arguments()
    : barrierType(Barrier::Type(-1)), barrier(Null<Real>()) {}

    void TwoAssetBarrierOption::arguments::validate() const {
        Option::arguments::validate();

        switch (barrierType) {
          case Barrier::DownIn:
          case Barrier::UpIn:
          case Barrier::DownOut:
          case Barrier::UpOut:
            break;
          default:
            QL_FAIL("unknown type");
        }

        QL_REQUIRE(barrier != Null<Real>(), "no barrier given");
    }

    bool TwoAssetBarrierOption::engine::triggered(Real underlying) const {
        switch (arguments_.barrierType) {
          case Barrier::DownIn:
          case Barrier::DownOut:
            return underlying < arguments_.barrier;
          case Barrier::UpIn:
          case Barrier::UpOut:
            return underlying > arguments_.barrier;
          default:
            QL_FAIL("unknown type");
        }
    }

}

]]></document_content>
  </document>
  <document index="72">
    <source>twoassetcorrelationoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/twoassetcorrelationoption.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    TwoAssetCorrelationOption::TwoAssetCorrelationOption(
                           Option::Type type,
                           Real strike1,
                           Real strike2,
                           const ext::shared_ptr<Exercise>& exercise)
    : MultiAssetOption(ext::make_shared<PlainVanillaPayoff>(type, strike1),
                       exercise), X2_(strike2) {}

    void TwoAssetCorrelationOption::setupArguments(
                                       PricingEngine::arguments* args) const {
        MultiAssetOption::setupArguments(args);
        auto* moreArgs = dynamic_cast<TwoAssetCorrelationOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");

        moreArgs->X2 = X2_;
    }

}

]]></document_content>
  </document>
  <document index="73">
    <source>vanillaoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/instruments/impliedvolatility.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/analyticdividendeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesvanillaengine.hpp>
#include <memory>

namespace QuantLib {

    VanillaOption::VanillaOption(
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise) {}


    Volatility VanillaOption::impliedVolatility(
             Real targetValue,
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             Real accuracy,
             Size maxEvaluations,
             Volatility minVol,
             Volatility maxVol) const {
        return impliedVolatility(targetValue, process, DividendSchedule(),
                                 accuracy, maxEvaluations, minVol, maxVol);
    }

    Volatility VanillaOption::impliedVolatility(
             Real targetValue,
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             const DividendSchedule& dividends,
             Real accuracy,
             Size maxEvaluations,
             Volatility minVol,
             Volatility maxVol) const {

        QL_REQUIRE(!isExpired(), "option expired");

        ext::shared_ptr<SimpleQuote> volQuote(new SimpleQuote);

        ext::shared_ptr<GeneralizedBlackScholesProcess> newProcess =
            detail::ImpliedVolatilityHelper::clone(process, volQuote);

        // engines are built-in for the time being
        std::unique_ptr<PricingEngine> engine;
        switch (exercise_->type()) {
          case Exercise::European:
            if (dividends.empty())
                engine = std::make_unique<AnalyticEuropeanEngine>(newProcess);
            else
                engine = std::make_unique<AnalyticDividendEuropeanEngine>(newProcess, dividends);
            break;
          case Exercise::American:
          case Exercise::Bermudan:
            if (dividends.empty())
                engine = std::make_unique<FdBlackScholesVanillaEngine>(newProcess);
            else
                engine = std::make_unique<FdBlackScholesVanillaEngine>(newProcess, dividends);
            break;
          default:
            QL_FAIL("unknown exercise type");
        }

        return detail::ImpliedVolatilityHelper::calculate(*this,
                                                          *engine,
                                                          *volQuote,
                                                          targetValue,
                                                          accuracy,
                                                          maxEvaluations,
                                                          minVol, maxVol);
    }
    
}

]]></document_content>
  </document>
  <document index="74">
    <source>vanillaswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007 StatPro Italia srl
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/iborcoupon.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/instruments/vanillaswap.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    VanillaSwap::VanillaSwap(Type type,
                             Real nominal,
                             Schedule fixedSchedule,
                             Rate fixedRate,
                             DayCounter fixedDayCount,
                             Schedule floatSchedule,
                             ext::shared_ptr<IborIndex> index,
                             Spread spread,
                             DayCounter floatingDayCount,
                             ext::optional<BusinessDayConvention> paymentConvention,
                             ext::optional<bool> useIndexedCoupons)
    : FixedVsFloatingSwap(type, {nominal}, std::move(fixedSchedule), fixedRate, std::move(fixedDayCount),
                          {nominal}, std::move(floatSchedule), std::move(index), spread, std::move(floatingDayCount),
                          paymentConvention) {

        legs_[1] = IborLeg(floatingSchedule(), iborIndex())
            .withNotionals(this->floatingNominals())
            .withPaymentDayCounter(this->floatingDayCount())
            .withPaymentAdjustment(this->paymentConvention())
            .withSpreads(this->spread())
            .withIndexedCoupons(useIndexedCoupons);
        for (const auto& c : legs_[1])
            registerWith(c);
    }

    void VanillaSwap::setupFloatingArguments(arguments* args) const {
        const Leg& floatingCoupons = floatingLeg();
        Size n = floatingCoupons.size();

        args->floatingResetDates = args->floatingPayDates = args->floatingFixingDates = std::vector<Date>(n);
        args->floatingAccrualTimes = std::vector<Time>(n);
        args->floatingSpreads = std::vector<Spread>(n);
        args->floatingCoupons = args->floatingNominals = std::vector<Real>(n);

        for (Size i=0; i<n; ++i) {
            auto coupon = ext::dynamic_pointer_cast<IborCoupon>(floatingCoupons[i]);

            args->floatingResetDates[i] = coupon->accrualStartDate();
            args->floatingPayDates[i] = coupon->date();
            args->floatingNominals[i] = coupon->nominal();

            args->floatingFixingDates[i] = coupon->fixingDate();
            args->floatingAccrualTimes[i] = coupon->accrualPeriod();
            args->floatingSpreads[i] = coupon->spread();
            try {
                args->floatingCoupons[i] = coupon->amount();
            } catch (Error&) {
                args->floatingCoupons[i] = Null<Real>();
            }
        }
    }

}
]]></document_content>
  </document>
  <document index="75">
    <source>vanillaswingoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vanillaswingoption.cpp
    \brief vanilla swing option class
*/


#include <ql/event.hpp>
#include <ql/instruments/vanillaswingoption.hpp>

namespace QuantLib {

    namespace {
        const Size secPerDay = 24U * 3600U;

        std::pair<std::vector<Date>, std::vector<Size> >
            createDateTimes(const Date& from, const Date& to, Size stepSize) {

            std::vector<Size> secs;
            std::vector<Date> dates;

            Date iterDate = from;
            Size iterStepSize = 0U;

            while (iterDate <= to) {
                dates.push_back(iterDate);
                secs.push_back(iterStepSize);

                iterStepSize+=stepSize;
                if (iterStepSize >= secPerDay) {
                    iterDate+=1L;
                    iterStepSize%=secPerDay;
                }
            }

            return std::pair<std::vector<Date>,std::vector<Size> >(dates, secs);
        }
    }

    SwingExercise::SwingExercise(const std::vector<Date>& dates, const std::vector<Size>& seconds)
    : BermudanExercise(dates),
      seconds_(seconds.empty() ? std::vector<Size>(dates.size(), 0U) : seconds) {
        QL_REQUIRE(dates_.size() == seconds_.size(),
                   "dates and seconds must have the same size");
        for (Size i=0; i < dates_.size(); ++i) {
            QL_REQUIRE(seconds_[i] < secPerDay,
                       "a date can not have more than 24*3600 seconds");
            if (i > 0) {
                QL_REQUIRE(dates_[i-1] < dates_[i]
                           || (dates_[i-1] == dates_[i]
                               && seconds_[i-1] < seconds_[i]),
                           "date times must be sorted");
            }
        }
    }


    SwingExercise::SwingExercise(const Date& from,
                                 const Date& to, Size stepSizeSecs)
    : BermudanExercise(createDateTimes(from, to, stepSizeSecs).first),
      seconds_(createDateTimes(from, to, stepSizeSecs).second) {
    }

    const std::vector<Size>& SwingExercise::seconds() const { return seconds_; }

    std::vector<Time> SwingExercise::exerciseTimes(const DayCounter& dc,
                                                   const Date& refDate) const {
        std::vector<Time> exerciseTimes;
        exerciseTimes.reserve(dates().size());
        for (Size i=0; i<dates().size(); ++i) {
            Time t = dc.yearFraction(refDate, dates()[i]);

            const Time dt = dc.yearFraction(refDate, dates()[i] + Period(1U, Days)) - t;

            t += dt*seconds()[i]/(24*3600.);

            QL_REQUIRE(t >= 0, "exercise dates must not contain past date");
            exerciseTimes.push_back(t);
        }

        return exerciseTimes;
    }

    Real VanillaForwardPayoff::operator()(Real price) const {
        switch (type_) {
          case Option::Call:
            return price-strike_;
          case Option::Put:
            return strike_-price;
          default:
            QL_FAIL("unknown/illegal option type");
        }
    }

    void VanillaForwardPayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<VanillaForwardPayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            StrikedTypePayoff::accept(v);
    }


    void VanillaSwingOption::arguments::validate() const {
        QL_REQUIRE(payoff, "no payoff given");
        QL_REQUIRE(exercise, "no exercise given");

        QL_REQUIRE(minExerciseRights <= maxExerciseRights,
                   "minExerciseRights <= maxExerciseRights");
        QL_REQUIRE(exercise->dates().size() >= maxExerciseRights,
                   "number of exercise rights exceeds "
                   "number of exercise dates");
    }

    void VanillaSwingOption::setupArguments(
                            PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<VanillaSwingOption::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->payoff
            = ext::dynamic_pointer_cast<StrikedTypePayoff>(payoff_);
        arguments->exercise
            = ext::dynamic_pointer_cast<SwingExercise>(exercise_);
        arguments->minExerciseRights = minExerciseRights_;
        arguments->maxExerciseRights = maxExerciseRights_;
    }

    bool VanillaSwingOption::isExpired() const {
        return detail::simple_event(exercise_->lastDate()).hasOccurred();
    }
}
]]></document_content>
  </document>
  <document index="76">
    <source>varianceswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2007, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/varianceswap.hpp>
#include <ql/event.hpp>

namespace QuantLib {

    VarianceSwap::VarianceSwap(
                          Position::Type position,
                          Real strike,
                          Real notional,
                          const Date& startDate,
                          const Date& maturityDate)
    : position_(position), strike_(strike), notional_(notional),
      startDate_(startDate), maturityDate_(maturityDate) {}

    Real VarianceSwap::variance() const {
        calculate();
        QL_REQUIRE(variance_ != Null<Real>(), "result not available");
        return variance_;
    }

    void VarianceSwap::setupExpired() const {
        Instrument::setupExpired();
        variance_ = Null<Real>();
    }

    void VarianceSwap::setupArguments(PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<VarianceSwap::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->position = position_;
        arguments->strike = strike_;
        arguments->notional = notional_;
        arguments->startDate = startDate_;
        arguments->maturityDate = maturityDate_;
    }

    void VarianceSwap::fetchResults(const PricingEngine::results* r) const {
        Instrument::fetchResults(r);
        const auto* results = dynamic_cast<const VarianceSwap::results*>(r);
        variance_ = results->variance;
    }

    void VarianceSwap::arguments::validate() const {
        QL_REQUIRE(strike != Null<Real>(), "no strike given");
        QL_REQUIRE(strike > 0.0, "negative or null strike given");
        QL_REQUIRE(notional != Null<Real>(), "no notional given");
        QL_REQUIRE(notional > 0.0, "negative or null notional given");
        QL_REQUIRE(startDate != Date(), "null start date given");
        QL_REQUIRE(maturityDate != Date(), "null maturity date given");
    }

    bool VarianceSwap::isExpired() const {
        return detail::simple_event(maturityDate_).hasOccurred();
    }

}
]]></document_content>
  </document>
  <document index="77">
    <source>writerextensibleoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Universit de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/event.hpp>
#include <ql/instruments/writerextensibleoption.hpp>
#include <utility>

namespace QuantLib {

    WriterExtensibleOption::WriterExtensibleOption(
        const ext::shared_ptr<PlainVanillaPayoff>& payoff1,
        const ext::shared_ptr<Exercise>& exercise1,
        const ext::shared_ptr<PlainVanillaPayoff>& payoff2,
        ext::shared_ptr<Exercise> exercise2)
    : OneAssetOption(payoff1, exercise1), payoff2_(payoff2), exercise2_(std::move(exercise2)) {}

    void WriterExtensibleOption::setupArguments(
                                       PricingEngine::arguments* args) const {
        OneAssetOption::setupArguments(args);

        auto* otherArguments = dynamic_cast<WriterExtensibleOption::arguments*>(args);
        QL_REQUIRE(otherArguments != nullptr, "wrong arguments type");

        otherArguments->payoff2 = payoff2_;
        otherArguments->exercise2 = exercise2_;
    }

    bool WriterExtensibleOption::isExpired() const {
        return detail::simple_event(exercise2_->lastDate()).hasOccurred();
    }

    void WriterExtensibleOption::arguments::validate() const {
        OneAssetOption::arguments::validate();
        QL_REQUIRE(payoff2, "no second payoff given");
        QL_REQUIRE(exercise2, "no second exercise given");
        QL_REQUIRE(exercise2->lastDate() > exercise->lastDate(),
                   "second exercise date is not later than the first");
    }

}
]]></document_content>
  </document>
  <document index="78">
    <source>yearonyearinflationswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 Chris Kenyon
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/yoyinflationcoupon.hpp>
#include <ql/indexes/inflationindex.hpp>
#include <ql/instruments/yearonyearinflationswap.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/time/schedule.hpp>
#include <utility>

namespace QuantLib {

    YearOnYearInflationSwap::YearOnYearInflationSwap(Type type,
                                                     Real nominal,
                                                     Schedule fixedSchedule,
                                                     Rate fixedRate,
                                                     DayCounter fixedDayCount,
                                                     Schedule yoySchedule,
                                                     ext::shared_ptr<YoYInflationIndex> yoyIndex,
                                                     const Period& observationLag,
                                                     CPI::InterpolationType interpolation,
                                                     Spread spread,
                                                     DayCounter yoyDayCount,
                                                     Calendar paymentCalendar,
                                                     BusinessDayConvention paymentConvention)
    : Swap(2), type_(type), nominal_(nominal), fixedSchedule_(std::move(fixedSchedule)),
      fixedRate_(fixedRate), fixedDayCount_(std::move(fixedDayCount)),
      yoySchedule_(std::move(yoySchedule)), yoyIndex_(std::move(yoyIndex)),
      observationLag_(observationLag), spread_(spread), yoyDayCount_(std::move(yoyDayCount)),
      paymentCalendar_(std::move(paymentCalendar)), paymentConvention_(paymentConvention) {
        // N.B. fixed leg gets its calendar from the schedule!
        Leg fixedLeg = FixedRateLeg(fixedSchedule_)
        .withNotionals(nominal_)
        .withCouponRates(fixedRate_, fixedDayCount_) // Simple compounding by default
        .withPaymentAdjustment(paymentConvention_);

        Leg yoyLeg = yoyInflationLeg(yoySchedule_, paymentCalendar_, yoyIndex_,
                                     observationLag_, interpolation)
        .withNotionals(nominal_)
        .withPaymentDayCounter(yoyDayCount_)
        .withPaymentAdjustment(paymentConvention_)
        .withSpreads(spread_);

        Leg::const_iterator i;
        for (i = yoyLeg.begin(); i < yoyLeg.end(); ++i)
            registerWith(*i);

        legs_[0] = fixedLeg;
        legs_[1] = yoyLeg;
        if (type_==Payer) {
            payer_[0] = -1.0;
            payer_[1] = +1.0;
        } else {
            payer_[0] = +1.0;
            payer_[1] = -1.0;
        }
    }

     void YearOnYearInflationSwap::setupArguments(PricingEngine::arguments* args) const {

        Swap::setupArguments(args);

        auto* arguments = dynamic_cast<YearOnYearInflationSwap::arguments*>(args);

        if (arguments == nullptr) // it's a swap engine...
            return;

        arguments->type = type_;
        arguments->nominal = nominal_;

        const Leg& fixedCoupons = fixedLeg();

        arguments->fixedResetDates = arguments->fixedPayDates =
        std::vector<Date>(fixedCoupons.size());
        arguments->fixedCoupons = std::vector<Real>(fixedCoupons.size());

        for (Size i=0; i<fixedCoupons.size(); ++i) {
            ext::shared_ptr<FixedRateCoupon> coupon =
            ext::dynamic_pointer_cast<FixedRateCoupon>(fixedCoupons[i]);

            arguments->fixedPayDates[i] = coupon->date();
            arguments->fixedResetDates[i] = coupon->accrualStartDate();
            arguments->fixedCoupons[i] = coupon->amount();
        }

        const Leg& yoyCoupons = yoyLeg();

        arguments->yoyResetDates = arguments->yoyPayDates =
        arguments->yoyFixingDates =
        std::vector<Date>(yoyCoupons.size());
        arguments->yoyAccrualTimes =
        std::vector<Time>(yoyCoupons.size());
        arguments->yoySpreads =
        std::vector<Spread>(yoyCoupons.size());
        arguments->yoyCoupons = std::vector<Real>(yoyCoupons.size());
        for (Size i=0; i<yoyCoupons.size(); ++i) {
            ext::shared_ptr<YoYInflationCoupon> coupon =
            ext::dynamic_pointer_cast<YoYInflationCoupon>(yoyCoupons[i]);

            arguments->yoyResetDates[i] = coupon->accrualStartDate();
            arguments->yoyPayDates[i] = coupon->date();

            arguments->yoyFixingDates[i] = coupon->fixingDate();
            arguments->yoyAccrualTimes[i] = coupon->accrualPeriod();
            arguments->yoySpreads[i] = coupon->spread();
            try {
                arguments->yoyCoupons[i] = coupon->amount();
            } catch (Error&) {
                arguments->yoyCoupons[i] = Null<Real>();
            }
        }
    }


    Rate YearOnYearInflationSwap::fairRate() const {
        calculate();
        QL_REQUIRE(fairRate_ != Null<Rate>(), "result not available");
        return fairRate_;
    }

    Spread YearOnYearInflationSwap::fairSpread() const {
        calculate();
        QL_REQUIRE(fairSpread_ != Null<Spread>(), "result not available");
        return fairSpread_;
    }


    Real YearOnYearInflationSwap::fixedLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[0] != Null<Real>(), "result not available");
        return legNPV_[0];
    }

    Real YearOnYearInflationSwap::yoyLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[1] != Null<Real>(), "result not available");
        return legNPV_[1];
    }

    void YearOnYearInflationSwap::setupExpired() const {
        Swap::setupExpired();
        legBPS_[0] = legBPS_[1] = 0.0;
        fairRate_ = Null<Rate>();
        fairSpread_ = Null<Spread>();
    }

    void YearOnYearInflationSwap::fetchResults(const PricingEngine::results* r) const {
        static const Spread basisPoint = 1.0e-4;

        // copy from VanillaSwap
        // works because similarly simple instrument
        // that we always expect to be priced with a swap engine

        Swap::fetchResults(r);

        const auto* results = dynamic_cast<const YearOnYearInflationSwap::results*>(r);
        if (results != nullptr) { // might be a swap engine, so no error is thrown
            fairRate_ = results->fairRate;
            fairSpread_ = results->fairSpread;
        } else {
            fairRate_ = Null<Rate>();
            fairSpread_ = Null<Spread>();
        }

        if (fairRate_ == Null<Rate>()) {
            // calculate it from other results
            if (legBPS_[0] != Null<Real>())
                fairRate_ = fixedRate_ - NPV_/(legBPS_[0]/basisPoint);
        }
        if (fairSpread_ == Null<Spread>()) {
            // ditto
            if (legBPS_[1] != Null<Real>())
                fairSpread_ = spread_ - NPV_/(legBPS_[1]/basisPoint);
        }

    }

    void YearOnYearInflationSwap::arguments::validate() const {
        Swap::arguments::validate();
        QL_REQUIRE(nominal != Null<Real>(), "nominal null or not set");
        QL_REQUIRE(fixedResetDates.size() == fixedPayDates.size(),
                   "number of fixed start dates different from "
                   "number of fixed payment dates");
        QL_REQUIRE(fixedPayDates.size() == fixedCoupons.size(),
                   "number of fixed payment dates different from "
                   "number of fixed coupon amounts");
        QL_REQUIRE(yoyResetDates.size() == yoyPayDates.size(),
                   "number of yoy start dates different from "
                   "number of yoy payment dates");
        QL_REQUIRE(yoyFixingDates.size() == yoyPayDates.size(),
                   "number of yoy fixing dates different from "
                   "number of yoy payment dates");
        QL_REQUIRE(yoyAccrualTimes.size() == yoyPayDates.size(),
                   "number of yoy accrual Times different from "
                   "number of yoy payment dates");
        QL_REQUIRE(yoySpreads.size() == yoyPayDates.size(),
                   "number of yoy spreads different from "
                   "number of yoy payment dates");
        QL_REQUIRE(yoyPayDates.size() == yoyCoupons.size(),
                   "number of yoy payment dates different from "
                   "number of yoy coupon amounts");
    }

    void YearOnYearInflationSwap::results::reset() {
        Swap::results::reset();
        fairRate = Null<Rate>();
        fairSpread = Null<Spread>();
    }

}

]]></document_content>
  </document>
  <document index="79">
    <source>zerocouponinflationswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 Chris Kenyon
 Copyright (C) 2009 StatPro Italia srl
 Copyright (C) 2021 Ralf Konrad Eckel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/cashflows/zeroinflationcashflow.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/instruments/zerocouponinflationswap.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <utility>

namespace QuantLib {

    /* Generally inflation indices are available with a lag of 1month
       and then observed with a lag of 2-3 months depending whether
       they use an interpolated fixing or not.  Here, we make the
       swap use the interpolation of the index to avoid incompatibilities.
    */
    ZeroCouponInflationSwap::ZeroCouponInflationSwap(
        Type type,
        Real nominal,
        const Date& startDate, // start date of contract (only)
        const Date& maturity,  // this is pre-adjustment!
        Calendar fixCalendar,
        BusinessDayConvention fixConvention,
        DayCounter dayCounter,
        Rate fixedRate,
        const ext::shared_ptr<ZeroInflationIndex>& infIndex,
        const Period& observationLag,
        CPI::InterpolationType observationInterpolation,
        bool adjustInfObsDates,
        Calendar infCalendar,
        BusinessDayConvention infConvention)
    : Swap(2), type_(type), nominal_(nominal), startDate_(startDate), maturityDate_(maturity),
      fixCalendar_(std::move(fixCalendar)), fixConvention_(fixConvention), fixedRate_(fixedRate),
      infIndex_(infIndex), observationLag_(observationLag),
      observationInterpolation_(observationInterpolation), adjustInfObsDates_(adjustInfObsDates),
      infCalendar_(std::move(infCalendar)), infConvention_(infConvention),
      dayCounter_(std::move(dayCounter)) {
        // first check compatibility of index and swap definitions
        if (detail::CPI::effectiveInterpolationType(observationInterpolation_) == CPI::Linear) {
            Period pShift(infIndex_->frequency());
            QL_REQUIRE(observationLag_ - pShift >= infIndex_->availabilityLag(),
                       "inconsistency between swap observation lag "
                           << observationLag_ << ", interpolated index period "
                           << pShift << " and index availability " << infIndex_->availabilityLag()
                           << ": need (obsLag-index period) >= availLag");
        } else {
            QL_REQUIRE(infIndex_->availabilityLag() <= observationLag_,
                       "index tries to observe inflation fixings that do not yet exist: "
                           << " availability lag " << infIndex_->availabilityLag()
                           << " versus obs lag = " << observationLag_);
        }

        if (infCalendar_ == Calendar())
            infCalendar_ = fixCalendar_;
        if (infConvention_ == BusinessDayConvention())
            infConvention_ = fixConvention_;

        Date infPayDate = infCalendar_.adjust(maturity, infConvention_);
        Date fixedPayDate = fixCalendar_.adjust(maturity, fixConvention_);

        bool growthOnly = true;

        auto inflationCashFlow =
            ext::make_shared<ZeroInflationCashFlow>(nominal, infIndex, observationInterpolation_,
                                                    startDate, maturity, observationLag_,
                                                    infPayDate, growthOnly);

        baseDate_ = inflationCashFlow->baseDate();
        obsDate_ = inflationCashFlow->fixingDate();

        // At this point the index may not be able to forecast
        // i.e. do not want to force the existence of an inflation
        // term structure before allowing users to create instruments.
        Real T =
            inflationYearFraction(infIndex_->frequency(),
                                  detail::CPI::isInterpolated(observationInterpolation_),
                                  dayCounter_, baseDate_, obsDate_);
        // N.B. the -1.0 is because swaps only exchange growth, not notionals as well
        Real fixedAmount = nominal * (std::pow(1.0 + fixedRate, T) - 1.0);

        auto fixedCashFlow = ext::make_shared<SimpleCashFlow>(fixedAmount, fixedPayDate);

        legs_[0].push_back(fixedCashFlow);
        legs_[1].push_back(inflationCashFlow);

        registerWith(inflationCashFlow);

        switch (type_) {
            case Payer:
                payer_[0] = +1.0;
                payer_[1] = -1.0;
                break;
            case Receiver:
                payer_[0] = -1.0;
                payer_[1] = +1.0;
                break;
            default:
                QL_FAIL("Unknown zero-inflation-swap type");
        }
    }


    Real ZeroCouponInflationSwap::fairRate() const {
        // What does this mean before or after trade date?
        // Always means that NPV is zero for _this_ instrument
        // if it was created with _this_ rate
        // _knowing_ the time from base to obs (etc).

        ext::shared_ptr<IndexedCashFlow> icf =
        ext::dynamic_pointer_cast<IndexedCashFlow>(legs_[1].at(0));
        QL_REQUIRE(icf,"failed to downcast to IndexedCashFlow in ::fairRate()");

        // +1 because the IndexedCashFlow has growthOnly=true
        Real growth = icf->amount() / icf->notional() + 1.0;
        Real T =
            inflationYearFraction(infIndex_->frequency(),
                                  detail::CPI::isInterpolated(observationInterpolation_),
                                  dayCounter_, baseDate_, obsDate_);

        return std::pow(growth,1.0/T) - 1.0;

        // we cannot use this simple definition because
        // it does not work for already-issued instruments
        // return infIndex_->zeroInflationTermStructure()->zeroRate(
        //      maturityDate(), observationLag(), infIndex_->interpolated());
    }

    Real ZeroCouponInflationSwap::fixedLegBPS() const {
        // legBPS_[0] is 0, because fixed leg uses a SimpleCashFlow. BPSCalculator assumes
        // that simple cashflows are not sensitive to fixedRate. We could change that to a
        // FixedRateCoupon, however BPSCalculator also assumes that all coupons are linear
        // in fixedRate. Our fixed leg uses annual compounding, so it does not compute the
        // right number.
        calculate();
        QL_REQUIRE(endDiscounts_[0] != Null<DiscountFactor>(),
                   "cannot calculate fixedLegBPS because end discount is not populated");

        const Spread basisPoint = 1.0e-4;
        DiscountFactor df = payer_[0] * endDiscounts_[0];
        Real T =
            inflationYearFraction(infIndex_->frequency(),
                                  detail::CPI::isInterpolated(observationInterpolation_),
                                  dayCounter_, baseDate_, obsDate_);

        return df * nominal_ * (pow(1.0 + fixedRate_ + basisPoint, T) - pow(1.0 + fixedRate_, T));
    }

    Real ZeroCouponInflationSwap::fixedLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[0] != Null<Real>(), "result not available");
        return legNPV_[0];
    }

    Real ZeroCouponInflationSwap::inflationLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[1] != Null<Real>(), "result not available");
        return legNPV_[1];
    }

    const Leg& ZeroCouponInflationSwap::fixedLeg() const {
        return legs_[0];
    }

    const Leg& ZeroCouponInflationSwap::inflationLeg() const {
        return legs_[1];
    }

}
]]></document_content>
  </document>
  <document index="80">
    <source>zerocouponswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/cashflows/multipleresetscoupon.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/instruments/zerocouponswap.hpp>
#include <utility>

namespace QuantLib {

    namespace {       

        ext::shared_ptr<CashFlow>
        compoundedSubPeriodicCoupon(const Date& paymentDate,
                                    const Date& startDate,
                                    const Date& maturityDate,
                                    Real nominal,
                                    const ext::shared_ptr<IborIndex>& index) {
            Schedule schedule = MakeSchedule()
                           .from(startDate)
                           .to(maturityDate)
                           .withTenor(index->tenor())
                           .withCalendar(index->fixingCalendar())
                           .withConvention(index->businessDayConvention())
                           .backwards()
                           .endOfMonth(index->endOfMonth());
            auto floatCpn = ext::make_shared<MultipleResetsCoupon>(
                paymentDate, nominal, schedule, index->fixingDays(), index);
            floatCpn->setPricer(ext::make_shared<CompoundingMultipleResetsPricer>());
            return floatCpn;
        }

    }

    ZeroCouponSwap::ZeroCouponSwap(Type type,
                                   Real baseNominal,
                                   const Date& startDate,
                                   const Date& maturityDate,
                                   ext::shared_ptr<IborIndex> iborIndex,
                                   const Calendar& paymentCalendar,
                                   BusinessDayConvention paymentConvention,
                                   Natural paymentDelay)
    : Swap(2), type_(type), baseNominal_(baseNominal), iborIndex_(std::move(iborIndex)), 
      startDate_(startDate), maturityDate_(maturityDate) {

        QL_REQUIRE(!(baseNominal < 0.0), "base nominal cannot be negative");
        QL_REQUIRE(startDate < maturityDate,
                   "start date (" << startDate 
                   << ") later than or equal to maturity date ("
                   << maturityDate << ")");

        paymentDate_ = paymentCalendar.advance(maturityDate, paymentDelay, Days, paymentConvention);

        legs_[1].push_back(compoundedSubPeriodicCoupon(paymentDate_, startDate, maturityDate,
                                                       baseNominal_, iborIndex_));
        for (auto i = legs_[1].begin(); i < legs_[1].end(); ++i)
            registerWith(*i);

        switch (type_) {
            case Payer:
                payer_[0] = -1.0;
                payer_[1] = +1.0;
                break;
            case Receiver:
                payer_[0] = +1.0;
                payer_[1] = -1.0;
                break;
            default:
                QL_FAIL("unknown zero coupon swap type");
        }
    }

    ZeroCouponSwap::ZeroCouponSwap(Type type,
                                   Real baseNominal,
                                   const Date& startDate,
                                   const Date& maturityDate,
                                   Real fixedPayment,
                                   ext::shared_ptr<IborIndex> iborIndex,
                                   const Calendar& paymentCalendar,
                                   BusinessDayConvention paymentConvention,
                                   Natural paymentDelay)
    : ZeroCouponSwap(type,
                     baseNominal,
                     startDate,
                     maturityDate,
                     std::move(iborIndex),
                     paymentCalendar,
                     paymentConvention,
                     paymentDelay) {

        legs_[0].push_back(
            ext::make_shared<SimpleCashFlow>(fixedPayment, paymentDate_));
    }

    ZeroCouponSwap::ZeroCouponSwap(Type type,
                                   Real baseNominal,
                                   const Date& startDate,
                                   const Date& maturityDate,
                                   Rate fixedRate,
                                   const DayCounter& fixedDayCounter,
                                   ext::shared_ptr<IborIndex> iborIndex,
                                   const Calendar& paymentCalendar,
                                   BusinessDayConvention paymentConvention,
                                   Natural paymentDelay)
    : ZeroCouponSwap(type,
                     baseNominal,
                     startDate,
                     maturityDate,
                     std::move(iborIndex),
                     paymentCalendar,
                     paymentConvention,
                     paymentDelay) {

        InterestRate interest(fixedRate, fixedDayCounter, Compounded, Annual);
        legs_[0].push_back(ext::make_shared<FixedRateCoupon>(
            paymentDate_, baseNominal_, std::move(interest), startDate, maturityDate));
    }

    Real ZeroCouponSwap::fixedLegNPV() const {
        return legNPV(0);
    }

    Real ZeroCouponSwap::floatingLegNPV() const {
        return legNPV(1);
    }

    Real ZeroCouponSwap::fairFixedPayment() const {
        // Knowing that for the fair payment NPV = 0.0, where:
        // NPV = (discount at fixed amount pay date) * (payer\receiver * fixed amount)
        //     + (discount at float amount pay date) * (-payer\receiver * float amount)
        // we have:
        // fair amount = NPV float / discount at fixed amount pay date
        // with NPV float corrected for the payer sign.
        Real scaling = payer(1) ? -1.0 : 1.0;
        return floatingLegNPV() / (endDiscounts(0) * scaling);
    }

    Rate ZeroCouponSwap::fairFixedRate(const DayCounter& dayCounter) const {
        // Given the relation between the fixed payment (N^FIX) and the fixed rate (R),
        // N^FIX = N * [(1 + R)^T - 1],
        // the compound factor C = (1 + R)^T
        // can be equivalently expressed as:
        // C = N^FIX / N + 1
        Real compound = fairFixedPayment() / baseNominal_ + 1.0;
        return InterestRate::impliedRate(compound, dayCounter, Compounded, Annual, startDate_,
                                         maturityDate_);
    }

    const Leg& ZeroCouponSwap::fixedLeg() const { return leg(0); }

    const Leg& ZeroCouponSwap::floatingLeg() const { return leg(1); }

    Real ZeroCouponSwap::fixedPayment() const { return fixedLeg()[0]->amount(); }
}
]]></document_content>
  </document>
</documents>