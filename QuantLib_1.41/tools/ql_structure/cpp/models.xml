<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>calibrationhelper.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/calibrationhelper.hpp>
#include <ql/math/solvers1d/brent.hpp>

namespace QuantLib {

    Volatility BlackCalibrationHelper::impliedVolatility(Real targetValue,
                                                         Real accuracy,
                                                         Size maxEvaluations,
                                                         Volatility minVol,
                                                         Volatility maxVol) const {

        auto error = [&](Volatility x) { return targetValue - blackPrice(x); };
        Brent solver;
        solver.setMaxEvaluations(maxEvaluations);
        return solver.solve(error, accuracy, volatility_->value(), minVol, maxVol);
    }

    Real BlackCalibrationHelper::calibrationError() {
        Real error;
        
        switch (calibrationErrorType_) {
          case RelativePriceError:
            error = std::fabs(marketValue() - modelValue())/marketValue();
            break;
          case PriceError:
            error = marketValue() - modelValue();
            break;
          case ImpliedVolError: 
            {
              Real minVol = volatilityType_ == ShiftedLognormal ? 0.0010 : 0.00005;
              Real maxVol = volatilityType_ == ShiftedLognormal ? 10.0 : 0.50;
              const Real lowerPrice = blackPrice(minVol);
              const Real upperPrice = blackPrice(maxVol);
              const Real modelPrice = modelValue();

              Volatility implied;
              if (modelPrice <= lowerPrice)
                  implied = minVol;
              else if (modelPrice >= upperPrice)
                  implied = maxVol;
              else
                  implied = this->impliedVolatility(
                                          modelPrice, 1e-12, 5000, minVol, maxVol);
              error = implied - volatility_->value();
            }
            break;
          default:
            QL_FAIL("unknown Calibration Error Type");
        }
        
        return error;
    }
}
]]></document_content>
  </document>
  <document index="2">
    <source>equity/batesmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/equity/batesmodel.hpp>
#include <ql/shared_ptr.hpp>

namespace QuantLib {

    BatesModel::BatesModel(const ext::shared_ptr<BatesProcess> & process)
    : HestonModel(process) {
        arguments_.resize(8);

        arguments_[5] 
                = ConstantParameter(process->nu(),     NoConstraint());
        arguments_[6] 
                = ConstantParameter(process->delta(),  PositiveConstraint());
        arguments_[7] 
                = ConstantParameter(process->lambda(), PositiveConstraint());
        
        BatesModel::generateArguments();
    }

    void BatesModel::generateArguments() {
        process_ = ext::make_shared<BatesProcess>(
             process_->riskFreeRate(), process_->dividendYield(),
             process_->s0(), v0(), 
             kappa(), theta(), sigma(), rho(),
             lambda(), nu(), delta());
    }

    BatesDetJumpModel::BatesDetJumpModel(
            const ext::shared_ptr<BatesProcess> & process,
            Real kappaLambda, Real thetaLambda)
    : BatesModel(process) {
        arguments_.resize(10);

        arguments_[8] =
            ConstantParameter(kappaLambda, PositiveConstraint());
        arguments_[9] =
            ConstantParameter(thetaLambda, PositiveConstraint());
    }


    BatesDoubleExpModel::BatesDoubleExpModel(
        const ext::shared_ptr<HestonProcess> & process,
        Real lambda, Real nuUp, Real nuDown, Real p)
    : HestonModel(process) {
        arguments_.resize(9);

        arguments_[5] = ConstantParameter(p,
                                          BoundaryConstraint(0.0, 1.0));
        arguments_[6] = ConstantParameter(nuDown, PositiveConstraint());
        arguments_[7] = ConstantParameter(nuUp,   PositiveConstraint());
        arguments_[8] = ConstantParameter(lambda, PositiveConstraint());
    }


    BatesDoubleExpDetJumpModel::BatesDoubleExpDetJumpModel(
        const ext::shared_ptr<HestonProcess> & process,
        Real lambda, Real nuUp, Real nuDown,
        Real p, Real kappaLambda, Real thetaLambda)
    : BatesDoubleExpModel(process, lambda, nuUp, nuDown, p) {
        arguments_.resize(11);

        arguments_[9]  =
            ConstantParameter(kappaLambda, PositiveConstraint());
        arguments_[10] =
            ConstantParameter(thetaLambda, PositiveConstraint());
    }
}

]]></document_content>
  </document>
  <document index="3">
    <source>equity/gjrgarchmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Yee Man Chan

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/equity/gjrgarchmodel.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/shared_ptr.hpp>

namespace QuantLib {

    class GJRGARCHModel::VolatilityConstraint : public Constraint {
      private:
        class Impl final : public Constraint::Impl {
          public:
            bool test(const Array& params) const override {
                const Real beta  = params[2];
                const Real gamma = params[3];

                return (beta+gamma >= 0.0);
            }
        };
      public:
        VolatilityConstraint()
        : Constraint(ext::shared_ptr<Constraint::Impl>(
                                           new VolatilityConstraint::Impl)) {}
    };

    GJRGARCHModel::GJRGARCHModel(
                           const ext::shared_ptr<GJRGARCHProcess> & process)
    : CalibratedModel(6), process_(process) {
        arguments_[0] = ConstantParameter(process->omega(),
                                          PositiveConstraint());
        arguments_[1] = ConstantParameter(process->alpha(),
                                          BoundaryConstraint( 0.0, 1.0));
        arguments_[2] = ConstantParameter(process->beta(),
                                          BoundaryConstraint( 0.0, 1.0));
        arguments_[3] = ConstantParameter(process->gamma(),
                                          BoundaryConstraint(-1.0, 1.0));
        arguments_[4] = ConstantParameter(process->lambda(), NoConstraint());
        arguments_[5] = ConstantParameter(process->v0(),
                                          PositiveConstraint());

        constraint_ = ext::shared_ptr<Constraint>(
            new CompositeConstraint(*constraint_, VolatilityConstraint()));

        GJRGARCHModel::generateArguments();

        registerWith(process_->riskFreeRate());
        registerWith(process_->dividendYield());
        registerWith(process_->s0());
    }

    void GJRGARCHModel::generateArguments() {
        process_ = ext::make_shared<GJRGARCHProcess>(process_->riskFreeRate(),
                                           process_->dividendYield(),
                                           process_->s0(),
                                           v0(), omega(),
                                           alpha(), beta(),
                                           gamma(), lambda(),
                                           process_->daysPerYear());
    }
}

]]></document_content>
  </document>
  <document index="4">
    <source>equity/hestonmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/equity/hestonmodel.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/shared_ptr.hpp>

namespace QuantLib {

    HestonModel::HestonModel(const ext::shared_ptr<HestonProcess> & process)
    : CalibratedModel(5), process_(process) {
        arguments_[0] = ConstantParameter(process->theta(),
                                          PositiveConstraint());
        arguments_[1] = ConstantParameter(process->kappa(),
                                          PositiveConstraint());
        arguments_[2] = ConstantParameter(process->sigma(),
                                          PositiveConstraint());
        arguments_[3] = ConstantParameter(process->rho(),
                                          BoundaryConstraint(-1.0, 1.0));
        arguments_[4] = ConstantParameter(process->v0(),
                                          PositiveConstraint());
        HestonModel::generateArguments();

        registerWith(process_->riskFreeRate());
        registerWith(process_->dividendYield());
        registerWith(process_->s0());
    }

    void HestonModel::generateArguments() {
        process_ = ext::make_shared<HestonProcess>(process_->riskFreeRate(),
                                         process_->dividendYield(),
                                         process_->s0(),
                                         v0(), kappa(), theta(),
                                         sigma(), rho());
    }

}

]]></document_content>
  </document>
  <document index="5">
    <source>equity/hestonmodelhelper.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Klaus Spanderen
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/models/equity/hestonmodelhelper.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <ql/quotes/simplequote.hpp>
#include <utility>


namespace QuantLib {

    HestonModelHelper::HestonModelHelper(const Period& maturity,
                                         Calendar calendar,
                                         const Real s0,
                                         const Real strikePrice,
                                         const Handle<Quote>& volatility,
                                         const Handle<YieldTermStructure>& riskFreeRate,
                                         const Handle<YieldTermStructure>& dividendYield,
                                         BlackCalibrationHelper::CalibrationErrorType errorType)
    : BlackCalibrationHelper(volatility, errorType), maturity_(maturity),
      calendar_(std::move(calendar)), s0_(Handle<Quote>(ext::make_shared<SimpleQuote>(s0))),
      strikePrice_(strikePrice), riskFreeRate_(riskFreeRate), dividendYield_(dividendYield) {
        registerWith(riskFreeRate);
        registerWith(dividendYield);
    }

    HestonModelHelper::HestonModelHelper(const Period& maturity,
                                         Calendar calendar,
                                         const Handle<Quote>& s0,
                                         const Real strikePrice,
                                         const Handle<Quote>& volatility,
                                         const Handle<YieldTermStructure>& riskFreeRate,
                                         const Handle<YieldTermStructure>& dividendYield,
                                         BlackCalibrationHelper::CalibrationErrorType errorType)
    : BlackCalibrationHelper(volatility, errorType), maturity_(maturity),
      calendar_(std::move(calendar)), s0_(s0), strikePrice_(strikePrice),
      riskFreeRate_(riskFreeRate), dividendYield_(dividendYield) {
        registerWith(s0);
        registerWith(riskFreeRate);
        registerWith(dividendYield);
    }

    void HestonModelHelper::performCalculations() const {
        exerciseDate_ =
            calendar_.advance(riskFreeRate_->referenceDate(), maturity_);
        tau_ = riskFreeRate_->timeFromReference(exerciseDate_);
        type_ = strikePrice_ * riskFreeRate_->discount(tau_) >=
                        s0_->value() * dividendYield_->discount(tau_)
                    ? Option::Call
                    : Option::Put;
        ext::shared_ptr<StrikedTypePayoff> payoff(
            new PlainVanillaPayoff(type_, strikePrice_));
        ext::shared_ptr<Exercise> exercise =
            ext::make_shared<EuropeanExercise>(exerciseDate_);
        option_ = ext::make_shared<VanillaOption>(payoff, exercise);
        BlackCalibrationHelper::performCalculations();
    }

    Real HestonModelHelper::modelValue() const {
        calculate();
        option_->setPricingEngine(engine_);
        return option_->NPV();
    }

    Real HestonModelHelper::blackPrice(Real volatility) const {
        calculate();
        const Real stdDev = volatility * std::sqrt(maturity());
        return blackFormula(
            type_, strikePrice_ * riskFreeRate_->discount(tau_),
            s0_->value() * dividendYield_->discount(tau_), stdDev);
    }
}

]]></document_content>
  </document>
  <document index="6">
    <source>equity/hestonslvfdmmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes Göttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include <ql/models/equity/hestonslvfdmmodel.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/integrals/discreteintegrals.hpp>
#include <ql/math/interpolations/bilinearinterpolation.hpp>
#include <ql/methods/finitedifferences/meshers/concentrating1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/meshers/predefined1dmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/fdmhestonfwdop.hpp>
#include <ql/methods/finitedifferences/schemes/craigsneydscheme.hpp>
#include <ql/methods/finitedifferences/schemes/douglasscheme.hpp>
#include <ql/methods/finitedifferences/schemes/expliciteulerscheme.hpp>
#include <ql/methods/finitedifferences/schemes/hundsdorferscheme.hpp>
#include <ql/methods/finitedifferences/schemes/impliciteulerscheme.hpp>
#include <ql/methods/finitedifferences/schemes/modifiedcraigsneydscheme.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/utilities/fdmmesherintegral.hpp>
#include <ql/methods/finitedifferences/utilities/localvolrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/squarerootprocessrndcalculator.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/equityfx/fixedlocalvolsurface.hpp>
#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>
#include <ql/timegrid.hpp>
#include <functional>
#include <memory>
#include <utility>

namespace QuantLib {

    namespace {
        ext::shared_ptr<Fdm1dMesher> varianceMesher(
            const SquareRootProcessRNDCalculator& rnd,
            Time t0, Time t1, Size vGrid,
            Real v0, const HestonSLVFokkerPlanckFdmParams& params) {

            std::vector<std::tuple<Real, Real, bool> > cPoints;

            const Real v0Density = params.v0Density;
            const Real upperBoundDensity = params.vUpperBoundDensity;
            const Real lowerBoundDensity = params.vLowerBoundDensity;

            Real lowerBound = Null<Real>(), upperBound = -Null<Real>();

            for (Size i=0; i <= 10; ++i) {
                const Time t = t0 + i/10.0*(t1-t0);
                lowerBound = std::min(
                    lowerBound, rnd.invcdf(params.vLowerEps, t));
                upperBound = std::max(
                    upperBound, rnd.invcdf(1.0-params.vUpperEps, t));
            }

            lowerBound = std::max(lowerBound, params.vMin);
            switch (params.trafoType) {
                case FdmSquareRootFwdOp::Log:
                  {
                    lowerBound = std::log(lowerBound);
                    upperBound = std::log(upperBound);

                    const Real v0Center = std::log(v0);

                    cPoints = {
                        std::make_tuple(lowerBound, lowerBoundDensity, false),
                        std::make_tuple(v0Center, v0Density, true),
                        std::make_tuple(upperBound, upperBoundDensity, false)
                    };

                    return ext::make_shared<Concentrating1dMesher>(
                        lowerBound, upperBound, vGrid, cPoints, 1e-8);
                  }
                case FdmSquareRootFwdOp::Plain:
                  {
                      const Real v0Center = v0;

                      cPoints = {
                          std::make_tuple(lowerBound, lowerBoundDensity, false),
                          std::make_tuple(v0Center, v0Density, true),
                          std::make_tuple(upperBound, upperBoundDensity, false)
                      };

                      return ext::make_shared<Concentrating1dMesher>(
                          lowerBound, upperBound, vGrid, cPoints, 1e-8);
                  }
                case FdmSquareRootFwdOp::Power:
                {
                    const Real v0Center = v0;

                    cPoints = {
                        std::make_tuple(lowerBound, lowerBoundDensity, false),
                        std::make_tuple(v0Center, v0Density, true),
                        std::make_tuple(upperBound, upperBoundDensity, false)
                    };

                    return ext::make_shared<Concentrating1dMesher>(
                        lowerBound, upperBound, vGrid, cPoints, 1e-8);
                }
                default:
                    QL_FAIL("transformation type is not implemented");
            }
        }

        Real integratePDF(const Array& p,
                          const ext::shared_ptr<FdmMesherComposite>& mesher,
                          FdmSquareRootFwdOp::TransformationType trafoType,
                          Real alpha) {

            if (trafoType != FdmSquareRootFwdOp::Power) {
                return FdmMesherIntegral(
                        mesher, DiscreteSimpsonIntegral()).integrate(p);
            }
            else {
                Array tp(p.size());
                for (const auto& iter : *mesher->layout()) {
                    const Size idx = iter.index();
                    const Real nu = mesher->location(iter, 1);

                    tp[idx] = p[idx]*std::pow(nu, alpha-1);
                }

                return FdmMesherIntegral(
                        mesher, DiscreteSimpsonIntegral()).integrate(tp);
            }
        }


        Array rescalePDF(
            const Array& p,
            const ext::shared_ptr<FdmMesherComposite>& mesher,
            FdmSquareRootFwdOp::TransformationType trafoType, Real alpha) {

            return p/integratePDF(p, mesher, trafoType, alpha);
        }


        template <class Interpolator>
        Array reshapePDF(
            const Array& p,
            const ext::shared_ptr<FdmMesherComposite>& oldMesher,
            const ext::shared_ptr<FdmMesherComposite>& newMesher,
            const Interpolator& interp = Interpolator()) {

            QL_REQUIRE(   oldMesher->layout()->size() == newMesher->layout()->size()
                       && oldMesher->layout()->size() == p.size(),
                       "inconsistent mesher or vector size given");

            Matrix m(oldMesher->layout()->dim()[1], oldMesher->layout()->dim()[0]);
            for (Size i=0; i < m.rows(); ++i) {
                std::copy(p.begin() + i*m.columns(),
                          p.begin() + (i+1)*m.columns(), m.row_begin(i));
            }
            const Interpolation2D interpol = interp.interpolate(
                oldMesher->getFdm1dMeshers()[0]->locations().begin(),
                oldMesher->getFdm1dMeshers()[0]->locations().end(),
                oldMesher->getFdm1dMeshers()[1]->locations().begin(),
                oldMesher->getFdm1dMeshers()[1]->locations().end(), m);

            Array pNew(p.size());
            for (const auto& iter : *newMesher->layout()) {
                const Real x = newMesher->location(iter, 0);
                const Real v = newMesher->location(iter, 1);

                if (   x > interpol.xMax() || x < interpol.xMin()
                    || v > interpol.yMax() || v < interpol.yMin() ) {
                    pNew[iter.index()] = 0;
                }
                else {
                    pNew[iter.index()] = interpol(x, v);
                }
            }

            return pNew;
        }

        class FdmScheme {
          public:
            virtual ~FdmScheme() = default;
            virtual void step(Array& a, Time t) = 0;
            virtual void setStep(Time dt) = 0;
        };

        template <class T>
        class FdmSchemeWrapper : public FdmScheme {
          public:
            explicit FdmSchemeWrapper(T* scheme)
            : scheme_(scheme) { }

            void step(Array& a, Time t) override { scheme_->step(a, t); }
            void setStep(Time dt) override { scheme_->setStep(dt); }

          private:
            const std::unique_ptr<T> scheme_;
        };

        ext::shared_ptr<FdmScheme> fdmSchemeFactory(
            const FdmSchemeDesc desc,
            const ext::shared_ptr<FdmLinearOpComposite>& op) {

            switch (desc.type) {
              case FdmSchemeDesc::HundsdorferType:
                  return ext::shared_ptr<FdmScheme>(
                      new FdmSchemeWrapper<HundsdorferScheme>(
                          new HundsdorferScheme(desc.theta, desc.mu, op)));
              case FdmSchemeDesc::DouglasType:
                  return ext::shared_ptr<FdmScheme>(
                      new FdmSchemeWrapper<DouglasScheme>(
                          new DouglasScheme(desc.theta, op)));
              case FdmSchemeDesc::CraigSneydType:
                  return ext::shared_ptr<FdmScheme>(
                      new FdmSchemeWrapper<CraigSneydScheme>(
                          new CraigSneydScheme(desc.theta, desc.mu, op)));
              case FdmSchemeDesc::ModifiedCraigSneydType:
                  return ext::shared_ptr<FdmScheme>(
                     new FdmSchemeWrapper<ModifiedCraigSneydScheme>(
                          new ModifiedCraigSneydScheme(
                              desc.theta, desc.mu, op)));
              case FdmSchemeDesc::ImplicitEulerType:
                  return ext::shared_ptr<FdmScheme>(
                      new FdmSchemeWrapper<ImplicitEulerScheme>(
                          new ImplicitEulerScheme(op)));
              case FdmSchemeDesc::ExplicitEulerType:
                  return ext::shared_ptr<FdmScheme>(
                      new FdmSchemeWrapper<ExplicitEulerScheme>(
                          new ExplicitEulerScheme(op)));
              default:
                  QL_FAIL("Unknown scheme type");
            }
        }
    }

    HestonSLVFDMModel::HestonSLVFDMModel(Handle<LocalVolTermStructure> localVol,
                                         Handle<HestonModel> hestonModel,
                                         const Date& endDate,
                                         HestonSLVFokkerPlanckFdmParams params,
                                         const bool logging,
                                         std::vector<Date> mandatoryDates,
                                         const Real mixingFactor)
    : localVol_(std::move(localVol)), hestonModel_(std::move(hestonModel)), endDate_(endDate),
      params_(params), mandatoryDates_(std::move(mandatoryDates)),
      mixingFactor_(mixingFactor), logging_(logging) {

        registerWith(localVol_);
        registerWith(hestonModel_);
    }

    ext::shared_ptr<HestonProcess> HestonSLVFDMModel::hestonProcess() const {
        return hestonModel_->process();
    }

    ext::shared_ptr<LocalVolTermStructure> HestonSLVFDMModel::localVol() const {
        return localVol_.currentLink();
    }

    ext::shared_ptr<LocalVolTermStructure>
    HestonSLVFDMModel::leverageFunction() const {
        calculate();

        return leverageFunction_;
    }

    void HestonSLVFDMModel::performCalculations() const {
        logEntries_.clear();

        const ext::shared_ptr<HestonProcess> hestonProcess
            = hestonModel_->process();
        const ext::shared_ptr<Quote> spot
            = hestonProcess->s0().currentLink();
        const ext::shared_ptr<YieldTermStructure> rTS
            = hestonProcess->riskFreeRate().currentLink();
        const ext::shared_ptr<YieldTermStructure> qTS
            = hestonProcess->dividendYield().currentLink();

        const Real v0    = hestonProcess->v0();
        const Real kappa = hestonProcess->kappa();
        const Real theta = hestonProcess->theta();
        const Real sigma = hestonProcess->sigma();
        const Real mixedSigma = mixingFactor_ * sigma;
        const Real alpha = 2*kappa*theta/(mixedSigma*mixedSigma);

        const Size xGrid = params_.xGrid;
        const Size vGrid = params_.vGrid;

        const DayCounter dc = rTS->dayCounter();
        const Date referenceDate = rTS->referenceDate();

        const Time T = dc.yearFraction(referenceDate, endDate_);

        QL_REQUIRE(referenceDate < endDate_,
            "reference date must be smaller than final calibration date");

        QL_REQUIRE(localVol_->maxTime() >= T,
            "final calibration maturity exceeds local volatility surface");

        // set-up exponential time step scheme
        const Time maxDt = 1.0/params_.tMaxStepsPerYear;
        const Time minDt = 1.0/params_.tMinStepsPerYear;

        Time tIdx=0.0;
        std::vector<Time> times(1, tIdx);
        times.reserve(Size(T*params_.tMinStepsPerYear));
        while (tIdx < T) {
            const Real decayFactor = std::exp(-params_.tStepNumberDecay*tIdx);
            const Time dt = maxDt*decayFactor + minDt*(1.0-decayFactor);

            times.push_back(std::min(T, tIdx+=dt));
        }

        for (auto mandatoryDate : mandatoryDates_) {
            times.push_back(dc.yearFraction(referenceDate, mandatoryDate));
        }

        const ext::shared_ptr<TimeGrid> timeGrid(
            new TimeGrid(times.begin(), times.end()));

        // build 1d meshers
        const LocalVolRNDCalculator localVolRND(
            spot, rTS, qTS, localVol_.currentLink(),
            timeGrid, xGrid,
            params_.x0Density,
            params_.localVolEpsProb,
            params_.maxIntegrationIterations);

        const std::vector<Size> rescaleSteps
            = localVolRND.rescaleTimeSteps();

        const SquareRootProcessRNDCalculator squareRootRnd(
            v0, kappa, theta, mixedSigma);

        const FdmSquareRootFwdOp::TransformationType trafoType
          = params_.trafoType;

        std::vector<ext::shared_ptr<Fdm1dMesher> > xMesher, vMesher;
        xMesher.reserve(timeGrid->size());
        vMesher.reserve(timeGrid->size());

        xMesher.push_back(localVolRND.mesher(0.0));
        vMesher.push_back(ext::make_shared<Predefined1dMesher>(
            std::vector<Real>(vGrid, v0)));

        Size rescaleIdx = 0;
        for (Size i=1; i < timeGrid->size(); ++i) {
            xMesher.push_back(localVolRND.mesher(timeGrid->at(i)));

            if ((rescaleIdx < rescaleSteps.size())
                && (i == rescaleSteps[rescaleIdx])) {
                ++rescaleIdx;
                vMesher.push_back(varianceMesher(squareRootRnd,
                    timeGrid->at(rescaleSteps[rescaleIdx-1]),
                    (rescaleIdx < rescaleSteps.size())
                        ? timeGrid->at(rescaleSteps[rescaleIdx])
                        : timeGrid->back(),
                    vGrid, v0, params_));
            }
            else
                vMesher.push_back(vMesher.back());
        }

        // start probability distribution
        ext::shared_ptr<FdmMesherComposite> mesher
            = ext::make_shared<FdmMesherComposite>(
                xMesher.at(1), vMesher.at(1));

        const Volatility lv0
            = localVol_->localVol(0.0, spot->value())/std::sqrt(v0);

        ext::shared_ptr<Matrix> L(new Matrix(xGrid, timeGrid->size()));

        const Real l0 = lv0;
        std::fill(L->column_begin(0),L->column_end(0), l0);
        std::fill(L->column_begin(1),L->column_end(1), l0);

        // create strikes from meshers
        std::vector<ext::shared_ptr<std::vector<Real> > > vStrikes(
            timeGrid->size());

        for (Size i=0; i < timeGrid->size(); ++i) {
            vStrikes[i] = ext::make_shared<std::vector<Real> >(xGrid);
            if (xMesher[i]->locations().front()
                  == xMesher[i]->locations().back()) {
                std::fill(vStrikes[i]->begin(), vStrikes[i]->end(),
                    std::exp(xMesher[i]->locations().front()));
            }
            else {
                std::transform(xMesher[i]->locations().begin(),
                               xMesher[i]->locations().end(),
                               vStrikes[i]->begin(),
                               [](Real x) -> Real { return std::exp(x); });
            }
        }

        const ext::shared_ptr<FixedLocalVolSurface> leverageFct(
            new FixedLocalVolSurface(referenceDate, times, vStrikes, L, dc));

        ext::shared_ptr<FdmLinearOpComposite> hestonFwdOp(
            new FdmHestonFwdOp(mesher, hestonProcess, trafoType, leverageFct, mixingFactor_));

        Array p = FdmHestonGreensFct(mesher, hestonProcess, trafoType, lv0)
            .get(timeGrid->at(1), params_.greensAlgorithm);

        if (logging_) {
            const LogEntry entry = { timeGrid->at(1),
                ext::make_shared<Array>(p), mesher };
            logEntries_.push_back(entry);
        }

        for (Size i=2; i < times.size(); ++i) {
            const Time t = timeGrid->at(i);
            const Time dt = t - timeGrid->at(i-1);

            if (   mesher->getFdm1dMeshers()[0] != xMesher[i]
                || mesher->getFdm1dMeshers()[1] != vMesher[i]) {
                const ext::shared_ptr<FdmMesherComposite> newMesher(
                    new FdmMesherComposite(xMesher[i], vMesher[i]));

                p = reshapePDF<Bilinear>(p, mesher, newMesher);
                mesher = newMesher;

                p = rescalePDF(p, mesher, trafoType, alpha);

                hestonFwdOp = ext::shared_ptr<FdmLinearOpComposite>(
                                new FdmHestonFwdOp(mesher, hestonProcess,
                                               trafoType, leverageFct, mixingFactor_));
            }

            Array pn = p;
            const Array x(Exp(
                Array(mesher->getFdm1dMeshers()[0]->locations().begin(),
                      mesher->getFdm1dMeshers()[0]->locations().end())));
            const Array v(
                    mesher->getFdm1dMeshers()[1]->locations().begin(),
                    mesher->getFdm1dMeshers()[1]->locations().end());

            // predictor corrector steps
            for (Size r=0; r < params_.predictionCorretionSteps; ++r) {
                const FdmSchemeDesc fdmSchemeDesc
                    = (i < params_.nRannacherTimeSteps + 2)
                        ? FdmSchemeDesc::ImplicitEuler()
                        : params_.schemeDesc;

                const ext::shared_ptr<FdmScheme> fdmScheme(
                    fdmSchemeFactory(fdmSchemeDesc, hestonFwdOp));

                for (Size j=0; j < x.size(); ++j) {
                    Array pSlice(vGrid);
                    for (Size k=0; k < vGrid; ++k)
                        pSlice[k] = pn[j + k*xGrid];

                    const Real pInt = (trafoType == FdmSquareRootFwdOp::Power)
                       ? DiscreteSimpsonIntegral()(v, Pow(v, alpha-1)*pSlice)
                       : DiscreteSimpsonIntegral()(v, pSlice);

                    const Real vpInt = (trafoType == FdmSquareRootFwdOp::Log)
                      ? DiscreteSimpsonIntegral()(v, Exp(v)*pSlice)
                      : (trafoType == FdmSquareRootFwdOp::Power)
                      ? DiscreteSimpsonIntegral()(v, Pow(v, alpha)*pSlice)
                      : DiscreteSimpsonIntegral()(v, v*pSlice);

                    const Real scale = pInt/vpInt;
                    const Volatility localVol = localVol_->localVol(t, x[j]);

                    const Real l = (scale >= 0.0)
                      ? localVol*std::sqrt(scale) : Real(1.0);

                    (*L)[j][i] = std::min(50.0, std::max(0.001, l));

                    leverageFct->setInterpolation(Linear());
                }

                const Real sLowerBound = std::max(x.front(),
                    std::exp(localVolRND.invcdf(
                        params_.leverageFctPropEps, t)));
                const Real sUpperBound = std::min(x.back(),
                    std::exp(localVolRND.invcdf(
                        1.0-params_.leverageFctPropEps, t)));

                const Real lowerL = leverageFct->localVol(t, sLowerBound);
                const Real upperL = leverageFct->localVol(t, sUpperBound);

                for (Size j=0; j < x.size(); ++j) {
                    if (x[j] < sLowerBound)
                        std::fill(L->row_begin(j)+i,
                          std::min(L->row_begin(j)+i+1, L->row_end(j)),
                          lowerL);
                    else if (x[j] > sUpperBound)
                        std::fill(L->row_begin(j)+i,
                          std::min(L->row_begin(j)+i+1, L->row_end(j)),
                          upperL);
                    else if ((*L)[j][i] == Null<Real>())
                        QL_FAIL("internal error");
                }
                leverageFct->setInterpolation(Linear());

                pn = p;

                fdmScheme->setStep(dt);
                fdmScheme->step(pn, t);
            }
            p = pn;
            p = rescalePDF(p, mesher, trafoType, alpha);

            if (logging_) {
                const LogEntry entry
                    = { t, ext::make_shared<Array>(p), mesher };
                logEntries_.push_back(entry);
            }
        }

        leverageFunction_ = leverageFct;
    }

    const std::list<HestonSLVFDMModel::LogEntry>& HestonSLVFDMModel::logEntries()
    const {
        performCalculations();
        return logEntries_;
    }
}

]]></document_content>
  </document>
  <document index="7">
    <source>equity/hestonslvmcmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes Göttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hestonslvmcmodel.cpp
*/

#include <ql/math/functional.hpp>
#include <ql/termstructures/volatility/equityfx/fixedlocalvolsurface.hpp>
#include <ql/models/equity/hestonslvmcmodel.hpp>
#include <ql/processes/hestonslvprocess.hpp>

#pragma push_macro("BOOST_DISABLE_ASSERTS")
#ifndef BOOST_DISABLE_ASSERTS
#define BOOST_DISABLE_ASSERTS
#endif
#include <boost/multi_array.hpp>
#pragma pop_macro("BOOST_DISABLE_ASSERTS")

#include <utility>

namespace QuantLib {
    HestonSLVMCModel::HestonSLVMCModel(
        Handle<LocalVolTermStructure> localVol,
        Handle<HestonModel> hestonModel,
        ext::shared_ptr<BrownianGeneratorFactory> brownianGeneratorFactory,
        const Date& endDate,
        Size timeStepsPerYear,
        Size nBins,
        Size calibrationPaths,
        const std::vector<Date>& mandatoryDates,
        const Real mixingFactor)
    : localVol_(std::move(localVol)), hestonModel_(std::move(hestonModel)),
      brownianGeneratorFactory_(std::move(brownianGeneratorFactory)), endDate_(endDate),
      nBins_(nBins), calibrationPaths_(calibrationPaths), mixingFactor_(mixingFactor) {

        registerWith(localVol_);
        registerWith(hestonModel_);

        const DayCounter dc = hestonModel_->process()->riskFreeRate()->dayCounter();
        const Date refDate = hestonModel_->process()->riskFreeRate()->referenceDate();

        std::vector<Time> gridTimes;
        gridTimes.reserve(mandatoryDates.size()+1);
        for (auto mandatoryDate : mandatoryDates) {
            gridTimes.push_back(dc.yearFraction(refDate, mandatoryDate));
        }
        gridTimes.push_back(dc.yearFraction(refDate, endDate));

        timeGrid_ = ext::make_shared<TimeGrid>(gridTimes.begin(), gridTimes.end(),
                std::max(Size(2), Size(gridTimes.back()*timeStepsPerYear)));
    }

    ext::shared_ptr<HestonProcess> HestonSLVMCModel::hestonProcess() const {
        return hestonModel_->process();
    }

    ext::shared_ptr<LocalVolTermStructure> HestonSLVMCModel::localVol() const {
        return localVol_.currentLink();
    }

    ext::shared_ptr<LocalVolTermStructure>
    HestonSLVMCModel::leverageFunction() const {
        calculate();

        return leverageFunction_;
    }

    void HestonSLVMCModel::performCalculations() const {
        const ext::shared_ptr<HestonProcess> hestonProcess
            = hestonModel_->process();
        const ext::shared_ptr<Quote> spot
            = hestonProcess->s0().currentLink();

        const Real v0            = hestonProcess->v0();
        const DayCounter dc      = hestonProcess->riskFreeRate()->dayCounter();
        const Date referenceDate = hestonProcess->riskFreeRate()->referenceDate();

        const Volatility lv0
            = localVol_->localVol(0.0, spot->value())/std::sqrt(v0);

        const ext::shared_ptr<Matrix> L(new Matrix(nBins_, timeGrid_->size()));

        std::vector<ext::shared_ptr<std::vector<Real> > >
            vStrikes(timeGrid_->size());
        for (Size i=0; i < timeGrid_->size(); ++i) {
            const Integer u = nBins_/2;
            const Real dx = spot->value()*std::sqrt(QL_EPSILON);

            vStrikes[i] = ext::make_shared<std::vector<Real> >(nBins_);

            for (Integer j=0; j < Integer(nBins_); ++j)
                vStrikes[i]->at(j) = spot->value() + (j - u)*dx;
        }

        std::fill(L->column_begin(0),L->column_end(0), lv0);

        leverageFunction_ = ext::make_shared<FixedLocalVolSurface>(
            referenceDate,
            std::vector<Time>(timeGrid_->begin(), timeGrid_->end()),
            vStrikes, L, dc);

        const ext::shared_ptr<HestonSLVProcess> slvProcess
            = ext::make_shared<HestonSLVProcess>(hestonProcess, leverageFunction_, mixingFactor_);

        std::vector<std::pair<Real, Real> > pairs(
                calibrationPaths_, std::make_pair(spot->value(), v0));

        const Size k = calibrationPaths_ / nBins_;
        const Size m = calibrationPaths_ % nBins_;

        const Size timeSteps = timeGrid_->size()-1;

        QL_DEPRECATED_DISABLE_WARNING
        typedef boost::multi_array<Real, 3> path_type;
        path_type paths(boost::extents[calibrationPaths_][timeSteps][2]);
        QL_DEPRECATED_ENABLE_WARNING

        const ext::shared_ptr<BrownianGenerator> brownianGenerator =
            brownianGeneratorFactory_->create(2, timeSteps);

        for (Size i=0; i < calibrationPaths_; ++i) {
            brownianGenerator->nextPath();
            std::vector<Real> tmp(2);
            for (Size j=0; j < timeSteps; ++j) {
                brownianGenerator->nextStep(tmp);
                paths[i][j][0] = tmp[0];
                paths[i][j][1] = tmp[1];
            }
        }

        for (Size n=1; n < timeGrid_->size(); ++n) {
            const Time t = timeGrid_->at(n-1);
            const Time dt = timeGrid_->dt(n-1);

            Array x0(2), dw(2);

            for (Size i=0; i < calibrationPaths_; ++i) {
                x0[0] = pairs[i].first;
                x0[1] = pairs[i].second;

                dw[0] = paths[i][n-1][0];
                dw[1] = paths[i][n-1][1];

                x0 = slvProcess->evolve(t, x0, dt, dw);

                pairs[i].first = x0[0];
                pairs[i].second = x0[1];
            }

            std::sort(pairs.begin(), pairs.end());

            Size s = 0U, e = 0U;
            for (Size i=0; i < nBins_; ++i) {
                const Size inc = k + static_cast<unsigned long>(i < m);
                e = s + inc;

                Real sum=0.0;
                for (Size j=s; j < e; ++j) {
                    sum+=pairs[j].second;
                }
                sum/=inc;

                vStrikes[n]->at(i) = 0.5*(pairs[e-1].first + pairs[s].first);
                (*L)[i][n] = std::sqrt(squared(localVol_->localVol(t, vStrikes[n]->at(i), true))/sum);

                s = e;
            }

            leverageFunction_->setInterpolation<Linear>();
        }
    }
}
]]></document_content>
  </document>
  <document index="8">
    <source>equity/piecewisetimedependenthestonmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/equity/piecewisetimedependenthestonmodel.hpp>
#include <ql/quotes/simplequote.hpp>
#include <utility>

namespace QuantLib {

    PiecewiseTimeDependentHestonModel::PiecewiseTimeDependentHestonModel(
        const Handle<YieldTermStructure>& riskFreeRate,
        const Handle<YieldTermStructure>& dividendYield,
        const Handle<Quote>& s0,
        Real v0,
        const Parameter& theta,
        const Parameter& kappa,
        const Parameter& sigma,
        const Parameter& rho,
        TimeGrid timeGrid)
    : CalibratedModel(5), s0_(s0), riskFreeRate_(riskFreeRate), dividendYield_(dividendYield),
      timeGrid_(std::move(timeGrid)) {

        arguments_[0] = theta;
        arguments_[1] = kappa;
        arguments_[2] = sigma;
        arguments_[3] = rho;
        arguments_[4] = ConstantParameter(v0, PositiveConstraint());

        registerWith(s0);
        registerWith(riskFreeRate);
        registerWith(dividendYield);
    }

    const TimeGrid& PiecewiseTimeDependentHestonModel::timeGrid() const {
        return timeGrid_;
    }
    
    const Handle<YieldTermStructure>& 
    PiecewiseTimeDependentHestonModel::dividendYield() const {
        return dividendYield_;
    }

    const Handle<YieldTermStructure>& 
    PiecewiseTimeDependentHestonModel::riskFreeRate() const {
        return riskFreeRate_;
    }
}

]]></document_content>
  </document>
  <document index="9">
    <source>marketmodels/accountingengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/accountingengine.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/discounter.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/evolver.hpp>
#include <algorithm>
#include <utility>

namespace QuantLib {

    AccountingEngine::AccountingEngine(ext::shared_ptr<MarketModelEvolver> evolver,
                                       const Clone<MarketModelMultiProduct>& product,
                                       Real initialNumeraireValue)
    : evolver_(std::move(evolver)), product_(product),
      initialNumeraireValue_(initialNumeraireValue), numberProducts_(product->numberOfProducts()),
      numerairesHeld_(product->numberOfProducts()),
      numberCashFlowsThisStep_(product->numberOfProducts()),
      cashFlowsGenerated_(product->numberOfProducts()) {
        for (Size i=0; i<numberProducts_; ++i)
            cashFlowsGenerated_[i].resize(
                       product_->maxNumberOfCashFlowsPerProductPerStep());

        const std::vector<Time>& cashFlowTimes =
            product_->possibleCashFlowTimes();
        const std::vector<Rate>& rateTimes = product_->evolution().rateTimes();
        discounters_.reserve(cashFlowTimes.size());
        for (Real cashFlowTime : cashFlowTimes)
            discounters_.emplace_back(cashFlowTime, rateTimes);
    }

    Real AccountingEngine::singlePathValues(std::vector<Real>& values) {
        std::fill(numerairesHeld_.begin(), numerairesHeld_.end(), 0.0);
        Real weight = evolver_->startNewPath();
        product_->reset();
        Real principalInNumerairePortfolio = 1.0;

        bool done = false;
        do {
            Size thisStep = evolver_->currentStep();
            weight *= evolver_->advanceStep();
            done = product_->nextTimeStep(evolver_->currentState(),
                                          numberCashFlowsThisStep_,
                                          cashFlowsGenerated_);
            Size numeraire =
                evolver_->numeraires()[thisStep];

            // for each product...
            for (Size i=0; i<numberProducts_; ++i) {
                // ...and each cash flow...
                const std::vector<MarketModelMultiProduct::CashFlow>& cashflows =
                    cashFlowsGenerated_[i];
                for (Size j=0; j<numberCashFlowsThisStep_[i]; ++j) {
                    // ...convert the cash flow to numeraires.
                    // This is done by calculating the number of
                    // numeraire bonds corresponding to such cash flow...
                    const MarketModelDiscounter& discounter =
                        discounters_[cashflows[j].timeIndex];

                    Real bonds = cashflows[j].amount *
                        discounter.numeraireBonds(evolver_->currentState(),
                                                  numeraire);

                    // ...and adding the newly bought bonds to the number
                    // of numeraires held.
                    numerairesHeld_[i] += bonds/principalInNumerairePortfolio;
                }
            }

            if (!done) {

                // The numeraire might change between steps. This implies
                // that we might have to convert the numeraire bonds for
                // this step into a corresponding amount of numeraire
                // bonds for the next step. This can be done by changing
                // the principal of the numeraire and updating the number
                // of bonds in the numeraire portfolio accordingly.

                Size nextNumeraire = evolver_->numeraires()[thisStep+1];

                principalInNumerairePortfolio *=
                    evolver_->currentState().discountRatio(numeraire,
                                                           nextNumeraire);
            }

        } while (!done);

        for (Size i=0; i<numerairesHeld_.size(); ++i)
            values[i] = numerairesHeld_[i] * initialNumeraireValue_;

        return weight;
    }

    void AccountingEngine::multiplePathValues(SequenceStatisticsInc& stats,
                                              Size numberOfPaths)
    {
        std::vector<Real> values(product_->numberOfProducts());
        for (Size i=0; i<numberOfPaths; ++i) {
            Real weight = singlePathValues(values);
            stats.add(values,weight);
        }
    }

}
]]></document_content>
  </document>
  <document index="10">
    <source>marketmodels/browniangenerators/mtbrowniangenerator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/browniangenerators/mtbrowniangenerator.hpp>
#include <algorithm>

namespace QuantLib {

    MTBrownianGenerator::MTBrownianGenerator(Size factors, Size steps, unsigned long seed)
    : factors_(factors), steps_(steps),
      generator_(factors * steps, MersenneTwisterUniformRng(seed)) {}

    Real MTBrownianGenerator::nextStep(std::vector<Real>& output) {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(output.size() == factors_, "size mismatch");
        QL_REQUIRE(lastStep_<steps_, "uniform sequence exhausted");
        #endif
        // no copying, just fetching a reference
        const std::vector<Real>& currentSequence = generator_.lastSequence().value;
        Size start = lastStep_*factors_, end = (lastStep_+1)*factors_;
        std::transform(currentSequence.begin()+start,
                       currentSequence.begin()+end,
                       output.begin(),
                       inverseCumulative_);
        ++lastStep_;
        return 1.0;
    }

    Real MTBrownianGenerator::nextPath() {
        typedef RandomSequenceGenerator<MersenneTwisterUniformRng>::sample_type
            sample_type;

        const sample_type& sample = generator_.nextSequence();
        lastStep_ = 0;
        return sample.weight;
    }

    Size MTBrownianGenerator::numberOfFactors() const { return factors_; }

    Size MTBrownianGenerator::numberOfSteps() const { return steps_; }


    MTBrownianGeneratorFactory::MTBrownianGeneratorFactory(unsigned long seed)
    : seed_(seed) {}

    ext::shared_ptr<BrownianGenerator>
    MTBrownianGeneratorFactory::create(Size factors, Size steps) const {
        return ext::shared_ptr<BrownianGenerator>(
                              new MTBrownianGenerator(factors, steps, seed_));
    }

}

]]></document_content>
  </document>
  <document index="11">
    <source>marketmodels/browniangenerators/sobolbrowniangenerator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/browniangenerators/sobolbrowniangenerator.hpp>
#include <boost/iterator/permutation_iterator.hpp>

namespace QuantLib {

    namespace {

        void fillByFactor(std::vector<std::vector<Size> >& M,
                          Size factors, Size steps) {
            Size counter = 0;
            for (Size i=0; i<factors; ++i)
                for (Size j=0; j<steps; ++j)
                    M[i][j] = counter++;
        }

        void fillByStep(std::vector<std::vector<Size> >& M,
                        Size factors, Size steps) {
            Size counter = 0;
            for (Size j=0; j<steps; ++j)
                for (Size i=0; i<factors; ++i)
                    M[i][j] = counter++;
        }

        // variate 2 is used for the second factor's full path
        void fillByDiagonal(std::vector<std::vector<Size> >& M,
                            Size factors, Size steps) {
            // starting position of the current diagonal
            Size i0 = 0, j0 = 0;
            // current position
            Size i=0, j=0;
            Size counter = 0;
            while (counter < factors*steps) {
                M[i][j] = counter++;
                if (i == 0 || j == steps-1) {
                    // we completed a diagonal and have to start a new one
                    if (i0 < factors-1) {
                        // we start the path of the next factor
                        i0 = i0+1;
                        j0 = 0;
                    } else {
                        // we move along the path of the last factor
                        i0 = factors-1;
                        j0 = j0+1;
                    }
                    i = i0;
                    j = j0;
                } else {
                    // we move along the diagonal
                    i = i-1;
                    j = j+1;
                }
            }
        }

        /*
        // variate 2 is used for the first factor's half path
        void fillByDiagonal(std::vector<std::vector<Size> >& M,
                            Size factors, Size steps) {
            // starting position of the current diagonal
            Size i0 = 0, j0 = 0;
            // current position
            Size i=0, j=0;
            Size counter = 0;
            while (counter < factors*steps) {
                M[i][j] = counter++;
                if (j == 0 || i == factors-1) {
                    // we completed a diagonal and have to start a new one
                    if (j0 < steps-1) {
                        // we move along the path of the first factor
                        i0 = 0;
                        j0 = j0+1;
                    } else {
                        // we complete the next path
                        i0 = i0+1;
                        j0 = steps-1;
                    }
                    i = i0;
                    j = j0;
                } else {
                    // we move along the diagonal
                    i = i+1;
                    j = j-1;
                }
            }
        }
        */

    }


    SobolBrownianGeneratorBase::SobolBrownianGeneratorBase(Size factors,
                                                   Size steps,
                                                   Ordering ordering)
    : factors_(factors), steps_(steps), ordering_(ordering),
      bridge_(steps), orderedIndices_(factors, std::vector<Size>(steps)),
      bridgedVariates_(factors, std::vector<Real>(steps)) {

        switch (ordering_) {
          case Factors:
            fillByFactor(orderedIndices_, factors_, steps_);
            break;
          case Steps:
            fillByStep(orderedIndices_, factors_, steps_);
            break;
          case Diagonal:
            fillByDiagonal(orderedIndices_, factors_, steps_);
            break;
          default:
            QL_FAIL("unknown ordering");
        }
    }


    Real SobolBrownianGeneratorBase::nextPath() {
        const auto& sample = nextSequence();
        // Brownian-bridge the variates according to the ordered indices
        for (Size i=0; i<factors_; ++i) {
            bridge_.transform(boost::make_permutation_iterator(
                                                  sample.value.begin(),
                                                  orderedIndices_[i].begin()),
                              boost::make_permutation_iterator(
                                                  sample.value.begin(),
                                                  orderedIndices_[i].end()),
                              bridgedVariates_[i].begin());
        }
        lastStep_ = 0;
        return sample.weight;
    }
    
    
    const std::vector<std::vector<Size> >& 
    SobolBrownianGeneratorBase::orderedIndices() const {
        return orderedIndices_;
    }

    std::vector<std::vector<Real> > SobolBrownianGeneratorBase::transform(
                            const std::vector<std::vector<Real> >& variates) {
        
        QL_REQUIRE(   (variates.size() == factors_*steps_),
                   "inconsistent variate vector");

        const Size dim    = factors_*steps_;
        const Size nPaths = variates.front().size();
        
        std::vector<std::vector<Real> > 
                       retVal(factors_, std::vector<Real>(nPaths*steps_));
        
        for (Size j=0; j < nPaths; ++j) {
            std::vector<Real> sample(steps_*factors_);
            for (Size k=0; k < dim; ++k) {
                sample[k] = variates[k][j];
            }
            for (Size i=0; i<factors_; ++i) {
                bridge_.transform(boost::make_permutation_iterator(
                                                  sample.begin(),
                                                  orderedIndices_[i].begin()),
                          boost::make_permutation_iterator(
                                                  sample.begin(),
                                                  orderedIndices_[i].end()),
                          retVal[i].begin()+j*steps_);
            }
        }
        
        return retVal;
    }

    Real SobolBrownianGeneratorBase::nextStep(std::vector<Real>& output) {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(output.size() == factors_, "size mismatch");
        QL_REQUIRE(lastStep_<steps_, "sequence exhausted");
        #endif
        for (Size i=0; i<factors_; ++i)
            output[i] = bridgedVariates_[i][lastStep_];
        ++lastStep_;
        return 1.0;
    }

    Size SobolBrownianGeneratorBase::numberOfFactors() const { return factors_; }

    Size SobolBrownianGeneratorBase::numberOfSteps() const { return steps_; }

    SobolBrownianGenerator::SobolBrownianGenerator(Size factors,
                                                   Size steps,
                                                   Ordering ordering,
                                                   unsigned long seed,
                                                   SobolRsg::DirectionIntegers integers)
    : SobolBrownianGeneratorBase(factors, steps, ordering),
      generator_(SobolRsg(factors * steps, seed, integers), InverseCumulativeNormal()) {}

    const SobolRsg::sample_type& SobolBrownianGenerator::nextSequence() {
        return generator_.nextSequence();
    }

    SobolBrownianGeneratorFactory::SobolBrownianGeneratorFactory(
                                    SobolBrownianGenerator::Ordering ordering,
                                    unsigned long seed,
                                    SobolRsg::DirectionIntegers integers)
    : ordering_(ordering), seed_(seed), integers_(integers) {}

    ext::shared_ptr<BrownianGenerator>
    SobolBrownianGeneratorFactory::create(Size factors, Size steps) const {
        return ext::shared_ptr<BrownianGenerator>(
                         new SobolBrownianGenerator(factors, steps, ordering_,
                                                    seed_, integers_));
    }

    Burley2020SobolBrownianGenerator::Burley2020SobolBrownianGenerator(
        Size factors,
        Size steps,
        Ordering ordering,
        unsigned long seed,
        SobolRsg::DirectionIntegers integers,
        unsigned long scrambleSeed)
    : SobolBrownianGeneratorBase(factors, steps, ordering),
      generator_(Burley2020SobolRsg(factors * steps, seed, integers, scrambleSeed),
                 InverseCumulativeNormal()) {}

    const Burley2020SobolRsg::sample_type& Burley2020SobolBrownianGenerator::nextSequence() {
        return generator_.nextSequence();
    }

    Burley2020SobolBrownianGeneratorFactory::Burley2020SobolBrownianGeneratorFactory(
        SobolBrownianGenerator::Ordering ordering,
        unsigned long seed,
        SobolRsg::DirectionIntegers integers,
        unsigned long scrambleSeed)
    : ordering_(ordering), seed_(seed), integers_(integers), scrambleSeed_(scrambleSeed) {}

    ext::shared_ptr<BrownianGenerator>
    Burley2020SobolBrownianGeneratorFactory::create(Size factors, Size steps) const {
        return ext::shared_ptr<BrownianGenerator>(new Burley2020SobolBrownianGenerator(
            factors, steps, ordering_, seed_, integers_, scrambleSeed_));
    }
}

]]></document_content>
  </document>
  <document index="12">
    <source>marketmodels/callability/bermudanswaptionexercisevalue.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/callability/bermudanswaptionexercisevalue.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <ql/payoff.hpp>
#include <utility>

namespace QuantLib {

    BermudanSwaptionExerciseValue::BermudanSwaptionExerciseValue(
        const std::vector<Time>& rateTimes, std::vector<ext::shared_ptr<Payoff> > payoffs)
    : numberOfExercises_(rateTimes.empty() ? 0 : rateTimes.size() - 1), rateTimes_(rateTimes),
      payoffs_(std::move(payoffs)) {

        checkIncreasingTimes(rateTimes);
        QL_REQUIRE(numberOfExercises_>0,
                   "Rate times must contain at least two values");
        std::vector<Time> evolveTimes(rateTimes_);
        evolveTimes.pop_back();
        evolution_ = EvolutionDescription(rateTimes_,evolveTimes);
    }

    Size BermudanSwaptionExerciseValue::numberOfExercises() const {
        return numberOfExercises_;
    }

    const EvolutionDescription&
    BermudanSwaptionExerciseValue::evolution() const {
        return evolution_;
    }

    std::vector<Time>
    BermudanSwaptionExerciseValue::possibleCashFlowTimes() const {
        return rateTimes_;
    }

    void BermudanSwaptionExerciseValue::reset() {
        currentIndex_=0;
    }

    void BermudanSwaptionExerciseValue::nextStep(const CurveState& state) {
        const Payoff& p = (*payoffs_[currentIndex_]);
        Real value = state.coterminalSwapAnnuity(currentIndex_, currentIndex_) *
            p(state.coterminalSwapRate(currentIndex_));

     //   value /= state.discountRatios()[currentIndex_];
        value =  std::max(value, 0.0);
        cf_.timeIndex = currentIndex_;
        cf_.amount = value;
        ++currentIndex_;
    }


    std::valarray<bool> BermudanSwaptionExerciseValue::isExerciseTime() const {
        return std::valarray<bool>(true,numberOfExercises_);
    }

    MarketModelMultiProduct::CashFlow
    BermudanSwaptionExerciseValue::value(const CurveState& ) const {
         return cf_;
    }

    std::unique_ptr<MarketModelExerciseValue>
    BermudanSwaptionExerciseValue::clone() const {
        return std::unique_ptr<MarketModelExerciseValue>(new BermudanSwaptionExerciseValue(*this));
    }

}
]]></document_content>
  </document>
  <document index="13">
    <source>marketmodels/callability/collectnodedata.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/callability/collectnodedata.hpp>
#include <ql/models/marketmodels/discounter.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <ql/models/marketmodels/multiproduct.hpp>
#include <ql/models/marketmodels/evolver.hpp>
#include <ql/models/marketmodels/callability/nodedataprovider.hpp>
#include <ql/models/marketmodels/callability/exercisevalue.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/methods/montecarlo/nodedata.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    typedef MarketModelMultiProduct::CashFlow CashFlow;

    void collectNodeData(MarketModelEvolver& evolver,
                         MarketModelMultiProduct& product,
                         MarketModelNodeDataProvider& dataProvider,
                         MarketModelExerciseValue& rebate,
                         MarketModelExerciseValue& control,
                         Size numberOfPaths,
                         std::vector<std::vector<NodeData> >& collectedData) {

        std::vector<Real> numerairesHeld;

        QL_REQUIRE(product.numberOfProducts() == 1,
                   "a single product is required");

        // TODO: check that all objects have compatible evolutions
        // (same rate times; evolution times for product, basis
        // system, rebate and control must be subsets of the passed
        // evolution times; rebate, control and basis system must have
        // the same exercise---not evolution---times)

        std::vector<Size> numberCashFlowsThisStep(1);
        std::vector<std::vector<CashFlow> > cashFlowsGenerated(1);
        cashFlowsGenerated[0].resize(
                           product.maxNumberOfCashFlowsPerProductPerStep());


        std::vector<Time> rateTimes = product.evolution().rateTimes();

        std::vector<Time> cashFlowTimes = product.possibleCashFlowTimes();
        std::vector<Time> rebateTimes = rebate.possibleCashFlowTimes();
        std::vector<Time> controlTimes = control.possibleCashFlowTimes();

        Size i, n;

        n = cashFlowTimes.size();
        std::vector<MarketModelDiscounter> productDiscounters;
        productDiscounters.reserve(n);
        for (i=0; i<n; ++i)
            productDiscounters.emplace_back(cashFlowTimes[i], rateTimes);

        n = rebateTimes.size();
        std::vector<MarketModelDiscounter> rebateDiscounters;
        rebateDiscounters.reserve(n);
        for (i=0; i<n; ++i)
            rebateDiscounters.emplace_back(rebateTimes[i], rateTimes);
        n = controlTimes.size();
        std::vector<MarketModelDiscounter> controlDiscounters;
        controlDiscounters.reserve(n);
        for (i=0; i<n; ++i)
            controlDiscounters.emplace_back(controlTimes[i], rateTimes);

        EvolutionDescription evolution = product.evolution();
        const std::vector<Size>& numeraires = evolver.numeraires();

        const std::vector<Time>& evolutionTimes = evolution.evolutionTimes();

        std::valarray<bool> isProductTime =
            isInSubset(evolutionTimes,
                       product.evolution().evolutionTimes());
        std::valarray<bool> isRebateTime =
            isInSubset(evolutionTimes,
                       rebate.evolution().evolutionTimes());
        std::valarray<bool> isControlTime =
            isInSubset(evolutionTimes,
                       control.evolution().evolutionTimes());
        std::valarray<bool> isBasisTime =
            isInSubset(evolutionTimes,
                       dataProvider.evolution().evolutionTimes());
        std::valarray<bool> isExerciseTime(false,evolutionTimes.size());
        std::valarray<bool> v = rebate.isExerciseTime();
        Size exercises = 0, idx = 0;
        for (i=0; i<evolutionTimes.size(); ++i) {
            if (isRebateTime[i]) {
                if(v[idx++]) {
                    isExerciseTime[i] = true;
                    exercises++;
                }
            }
        }

        collectedData.resize(exercises+1);
        for (i=0; i<collectedData.size(); ++i)
            collectedData[i].resize(numberOfPaths);


        for (i=0; i<numberOfPaths; ++i) {
            evolver.startNewPath();
            product.reset();
            rebate.reset();
            control.reset();
            dataProvider.reset();
            Real principalInNumerairePortfolio = 1.0;

            bool done = false;
            Size nextExercise = 0;
            collectedData[0][i].cumulatedCashFlows = 0.0;
            do {
                Size currentStep = evolver.currentStep();
                evolver.advanceStep();
                const CurveState& currentState = evolver.currentState();
                Size numeraire = numeraires[currentStep];

                if (isRebateTime[currentStep])
                    rebate.nextStep(currentState);
                if (isControlTime[currentStep])
                    control.nextStep(currentState);
                if (isBasisTime[currentStep])
                    dataProvider.nextStep(currentState);

                if (isExerciseTime[currentStep]) {
                    NodeData& data = collectedData[nextExercise+1][i];

                    CashFlow exerciseValue = rebate.value(currentState);
                    data.exerciseValue =
                        exerciseValue.amount *
                        rebateDiscounters[exerciseValue.timeIndex]
                           .numeraireBonds(currentState, numeraire) /
                        principalInNumerairePortfolio;

                    dataProvider.values(currentState,
                                        data.values);

                    CashFlow controlValue = control.value(currentState);
                    data.controlValue =
                        controlValue.amount *
                        controlDiscounters[controlValue.timeIndex]
                           .numeraireBonds(currentState, numeraire) /
                        principalInNumerairePortfolio;

                    data.cumulatedCashFlows = 0.0;

                    data.isValid = true;

                    ++nextExercise;
                }

                if (isProductTime[currentStep]) {
                    done = product.nextTimeStep(currentState,
                                                numberCashFlowsThisStep,
                                                cashFlowsGenerated);

                    for (Size j=0; j<numberCashFlowsThisStep[0]; ++j) {
                        const CashFlow& cf = cashFlowsGenerated[0][j];
                        collectedData[nextExercise][i].cumulatedCashFlows +=
                            cf.amount *
                            productDiscounters[cf.timeIndex]
                                .numeraireBonds(currentState, numeraire) /
                            principalInNumerairePortfolio;
                    }
                }

                if (!done) {
                    Size nextNumeraire = numeraires[currentStep+1];
                    principalInNumerairePortfolio *=
                        currentState.discountRatio(numeraire,
                                                   nextNumeraire);
                }
            }
            while (!done);

            // fill the remaining (un)collected data with nulls
            for (Size j = nextExercise; j < exercises; ++j) {
                NodeData& data = collectedData[j+1][i];
                data.exerciseValue = data.controlValue = 0.0;
                data.cumulatedCashFlows = 0.0;
                data.isValid = false;
            }
        }
    }

}
]]></document_content>
  </document>
  <document index="14">
    <source>marketmodels/callability/lsstrategy.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/callability/lsstrategy.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/discounter.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {

    typedef MarketModelMultiProduct::CashFlow CashFlow;

    LongstaffSchwartzExerciseStrategy::LongstaffSchwartzExerciseStrategy(
        Clone<MarketModelBasisSystem> basisSystem,
        std::vector<std::vector<Real> > basisCoefficients,
        const EvolutionDescription& evolution,
        const std::vector<Size>& numeraires,
        Clone<MarketModelExerciseValue> exercise,
        Clone<MarketModelExerciseValue> control)
    : basisSystem_(std::move(basisSystem)), basisCoefficients_(std::move(basisCoefficients)),
      exercise_(std::move(exercise)), control_(std::move(control)), numeraires_(numeraires) {

        checkCompatibility(evolution, numeraires);
        relevantTimes_ = evolution.evolutionTimes();

        isBasisTime_.resize(relevantTimes_.size());
        isBasisTime_ = isInSubset(relevantTimes_,
                                  basisSystem_->evolution().evolutionTimes());
        isRebateTime_.resize(relevantTimes_.size());
        isRebateTime_ = isInSubset(relevantTimes_,
                                   exercise_->evolution().evolutionTimes());
        isControlTime_.resize(relevantTimes_.size());
        isControlTime_ = isInSubset(relevantTimes_,
                                    control_->evolution().evolutionTimes());

        exerciseIndex_ = std::vector<Size>(relevantTimes_.size());
        isExerciseTime_.resize(relevantTimes_.size(), false);
        std::valarray<bool> v = exercise_->isExerciseTime();
        Size exercises = 0, idx = 0;
        Size i;
        for (i=0; i<relevantTimes_.size(); ++i) {
            exerciseIndex_[i] = exercises;
            if (isRebateTime_[i]) {
                isExerciseTime_[i] = v[idx++];
                if (isExerciseTime_[i]) {
                    exerciseTimes_.push_back(relevantTimes_[i]);
                    ++exercises;
                }
            }
        }

        const std::vector<Time>& rateTimes = evolution.rateTimes();
        std::vector<Time> rebateTimes = exercise_->possibleCashFlowTimes();
        rebateDiscounters_.reserve(rebateTimes.size());
        for (i=0; i<rebateTimes.size(); ++i)
            rebateDiscounters_.emplace_back(rebateTimes[i], rateTimes);

        std::vector<Time> controlTimes = control_->possibleCashFlowTimes();
        controlDiscounters_.reserve(controlTimes.size());
        for (i=0; i<controlTimes.size(); ++i)
            controlDiscounters_.emplace_back(controlTimes[i], rateTimes);

        std::vector<Size> basisSizes = basisSystem_->numberOfFunctions();
        basisValues_.resize(basisSystem_->numberOfExercises());
        for (i=0; i<basisValues_.size(); ++i)
            basisValues_[i].resize(basisSizes[i]);
    }

    std::vector<Time>
    LongstaffSchwartzExerciseStrategy::exerciseTimes() const {
        return exerciseTimes_;
    }

    std::vector<Time>
    LongstaffSchwartzExerciseStrategy::relevantTimes() const {
        return relevantTimes_;
    }

    void LongstaffSchwartzExerciseStrategy::reset() {
        exercise_->reset();
        control_->reset();
        basisSystem_->reset();
        currentIndex_ = 0;
        principalInNumerairePortfolio_ = newPrincipal_ = 1.0;
    }

    bool LongstaffSchwartzExerciseStrategy::exercise(
                                      const CurveState& currentState) const {

        Size exerciseIndex = exerciseIndex_[currentIndex_-1];

        CashFlow exerciseCF = exercise_->value(currentState);
        Real exerciseValue = exerciseCF.amount *
            rebateDiscounters_[exerciseCF.timeIndex]
                .numeraireBonds(currentState,
                                numeraires_[currentIndex_-1]) /
            principalInNumerairePortfolio_;

        CashFlow controlCF = control_->value(currentState);
        Real controlValue = controlCF.amount *
            controlDiscounters_[controlCF.timeIndex]
                .numeraireBonds(currentState,
                                numeraires_[currentIndex_-1]) /
            principalInNumerairePortfolio_;

        basisSystem_->values(currentState,
                             basisValues_[exerciseIndex]);

        const std::vector<Real>& alphas = basisCoefficients_[exerciseIndex];
        Real continuationValue =
            std::inner_product(alphas.begin(), alphas.end(),
                               basisValues_[exerciseIndex].begin(),
                               controlValue);

        return exerciseValue >= continuationValue;
    }

    void LongstaffSchwartzExerciseStrategy::nextStep(
                                            const CurveState& currentState) {
        principalInNumerairePortfolio_ = newPrincipal_;

        if (isRebateTime_[currentIndex_])
            exercise_->nextStep(currentState);
        if (isControlTime_[currentIndex_])
            control_->nextStep(currentState);
        if (isBasisTime_[currentIndex_])
            basisSystem_->nextStep(currentState);

        if (currentIndex_ < numeraires_.size()-1) {
            Size numeraire = numeraires_[currentIndex_];
            Size nextNumeraire = numeraires_[currentIndex_+1];
            newPrincipal_ *=
                currentState.discountRatio(numeraire, nextNumeraire);
        }

        ++currentIndex_;
    }

    std::unique_ptr<ExerciseStrategy<CurveState>>
    LongstaffSchwartzExerciseStrategy::clone() const {
        return std::unique_ptr<ExerciseStrategy<CurveState>>(new LongstaffSchwartzExerciseStrategy(*this));
    }

}

]]></document_content>
  </document>
  <document index="15">
    <source>marketmodels/callability/nothingexercisevalue.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/errors.hpp>
#include <ql/models/marketmodels/callability/nothingexercisevalue.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {

    NothingExerciseValue::NothingExerciseValue(const std::vector<Time>& rateTimes,
                                               std::valarray<bool> isExerciseTime)
    : rateTimes_(rateTimes), isExerciseTime_(std::move(isExerciseTime)) {

        checkIncreasingTimes(rateTimes);
        QL_REQUIRE(rateTimes.size() >= 2,
                   "Rate times must contain at least two values");
        cf_.amount = 0.0;
        std::vector<Time> evolutionTimes(rateTimes_);
        evolutionTimes.pop_back();
        evolution_= EvolutionDescription(rateTimes_, evolutionTimes);
        if(isExerciseTime_.size()==0) {
            isExerciseTime_ = std::valarray<bool>(true,rateTimes.empty() ? 0 : rateTimes.size()-1);
        }
        else {
            QL_REQUIRE(isExerciseTime_.size() ==
                           (rateTimes.empty() ? 0 : rateTimes.size() - 1),
                       "isExerciseTime ("
                           << isExerciseTime_.size() << ") must "
                           << "have same size as rateTimes minus 1 ("
                           << (rateTimes.empty() ? 0 : rateTimes.size() - 1)
                           << ")");
        }
        numberOfExercises_ = 0;
        for(Size i=0;i<isExerciseTime_.size();i++)
            if(isExerciseTime_[i])
                ++numberOfExercises_;
    }

    Size NothingExerciseValue::numberOfExercises() const {
        return numberOfExercises_;
    }

    const EvolutionDescription& NothingExerciseValue::evolution() const {
        return evolution_;
    }

    std::vector<Time> NothingExerciseValue::possibleCashFlowTimes() const {
        return rateTimes_;
    }

    void NothingExerciseValue::reset() {
        currentIndex_=0;
    }

    void NothingExerciseValue::nextStep(const CurveState&) {
        cf_.timeIndex = currentIndex_;
        ++currentIndex_;
    }


    std::valarray<bool> NothingExerciseValue::isExerciseTime() const {
        return isExerciseTime_;
    }

    MarketModelMultiProduct::CashFlow
    NothingExerciseValue::value(const CurveState&) const {
         return cf_;
    }

    std::unique_ptr<MarketModelExerciseValue>
    NothingExerciseValue::clone() const {
        return std::unique_ptr<MarketModelExerciseValue>(new NothingExerciseValue(*this));
    }

}
]]></document_content>
  </document>
  <document index="16">
    <source>marketmodels/callability/parametricexerciseadapter.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/callability/marketmodelparametricexercise.hpp>
#include <ql/models/marketmodels/callability/parametricexerciseadapter.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <utility>

namespace QuantLib {

    ParametricExerciseAdapter::ParametricExerciseAdapter(
        const MarketModelParametricExercise& exercise, std::vector<std::vector<Real> > parameters)
    : exercise_(exercise), parameters_(std::move(parameters)),
      isExerciseTime_(exercise.isExerciseTime()), numberOfVariables_(exercise.numberOfVariables()) {
        std::vector<Time> evolutionTimes =
            exercise_->evolution().evolutionTimes();
        for (Size i=0; i<evolutionTimes.size(); ++i) {
            if (isExerciseTime_[i])
                exerciseTimes_.push_back(evolutionTimes[i]);
        }
    }

    std::vector<Time> ParametricExerciseAdapter::exerciseTimes() const {
        return exerciseTimes_;
    }

    std::vector<Time> ParametricExerciseAdapter::relevantTimes() const {
        return exercise_->evolution().evolutionTimes();
    }

    void ParametricExerciseAdapter::reset() {
        exercise_->reset();
        currentStep_ = currentExercise_ = 0;
    }

    void ParametricExerciseAdapter::nextStep(const CurveState& currentState) {
        exercise_->nextStep(currentState);
        if (isExerciseTime_[currentStep_])
            ++currentExercise_;
        ++currentStep_;
    }

    bool ParametricExerciseAdapter::exercise(const CurveState& currentState) const {
        variables_.resize(numberOfVariables_[currentExercise_-1]);
        exercise_->values(currentState, variables_);
        return exercise_->exercise(currentExercise_-1,
                                   parameters_[currentExercise_-1],
                                   variables_);
    }

    std::unique_ptr<ExerciseStrategy<CurveState>> ParametricExerciseAdapter::clone() const {
        return std::unique_ptr<ExerciseStrategy<CurveState>>(new ParametricExerciseAdapter(*this));
    }

}
]]></document_content>
  </document>
  <document index="17">
    <source>marketmodels/callability/swapbasissystem.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/callability/swapbasissystem.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/utilities.hpp>

namespace QuantLib {

    SwapBasisSystem::SwapBasisSystem(const std::vector<Time>& rateTimes,
                                     const std::vector<Time>& exerciseTimes)
    : rateTimes_(rateTimes), exerciseTimes_(exerciseTimes),
      rateIndex_(exerciseTimes.size()),
      evolution_(rateTimes, exerciseTimes) {
        Size j = 0;
        for (Size i=0; i<exerciseTimes.size(); ++i) {
            while (j < rateTimes.size() && rateTimes[j] < exerciseTimes[i])
                ++j;
            rateIndex_[i] = j;
        }
    }

    Size SwapBasisSystem::numberOfExercises() const {
        return exerciseTimes_.size();
    }

    std::vector<Size> SwapBasisSystem::numberOfFunctions() const {
        std::vector<Size> sizes(exerciseTimes_.size(), 3);
        if (rateIndex_[exerciseTimes_.size()-1] == rateTimes_.size()-2)
            sizes.back() = 2;
        return sizes;
    }

    const EvolutionDescription& SwapBasisSystem::evolution() const {
        return evolution_;
    }

    void SwapBasisSystem::nextStep(const CurveState&) {
        ++currentIndex_;
    }

    void SwapBasisSystem::reset() {
        currentIndex_ = 0;
    }

    std::valarray<bool> SwapBasisSystem::isExerciseTime() const {
        return std::valarray<bool>(true, exerciseTimes_.size());
    }

    void SwapBasisSystem::values(const CurveState& currentState,
                                 std::vector<Real>& results) const {
        Size rateIndex = rateIndex_[currentIndex_-1];

        results.reserve(3);
        results.resize(2);
        results[0] = 1.0;
        results[1] = currentState.forwardRate(rateIndex);
        if (rateIndex < rateTimes_.size()-2)
            results.push_back(currentState.coterminalSwapRate(rateIndex+1));
    }

    std::unique_ptr<MarketModelBasisSystem>
    SwapBasisSystem::clone() const {
        return std::unique_ptr<MarketModelBasisSystem>(new SwapBasisSystem(*this));
    }

}

]]></document_content>
  </document>
  <document index="18">
    <source>marketmodels/callability/swapforwardbasissystem.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/callability/swapforwardbasissystem.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/utilities.hpp>

namespace QuantLib
{

    SwapForwardBasisSystem::SwapForwardBasisSystem(const std::vector<Time>& rateTimes,
                                     const std::vector<Time>& exerciseTimes)
                                     : 
                                    rateTimes_(rateTimes), exerciseTimes_(exerciseTimes),
                                    rateIndex_(exerciseTimes.size()),
                                    evolution_(rateTimes, exerciseTimes) 
     {
        Size j = 0;
        for (Size i=0; i<exerciseTimes.size(); ++i) 
        {
            while (j < rateTimes.size() && rateTimes[j] < exerciseTimes[i])
                ++j;
            rateIndex_[i] = j;
        }
    }

    Size SwapForwardBasisSystem::numberOfExercises() const 
    {
        return exerciseTimes_.size();
    }

    std::vector<Size> SwapForwardBasisSystem::numberOfFunctions() const 
    {
        std::vector<Size> sizes(exerciseTimes_.size(), 10);
        
        if (rateIndex_[exerciseTimes_.size()-1] == rateTimes_.size()-3)
            sizes.back() = 6;

        if (rateIndex_[exerciseTimes_.size()-1] == rateTimes_.size()-2)
            sizes.back() = 3;

        return sizes;
    }

    const EvolutionDescription& SwapForwardBasisSystem::evolution() const 
    {
        return evolution_;
    }

    void SwapForwardBasisSystem::nextStep(const CurveState&) 
    {
        ++currentIndex_;
    }

    void SwapForwardBasisSystem::reset() 
    {
        currentIndex_ = 0;
    }

    std::valarray<bool> SwapForwardBasisSystem::isExerciseTime() const 
    {
        return std::valarray<bool>(true, exerciseTimes_.size());
    }

    void SwapForwardBasisSystem::values(const CurveState& currentState,
                                 std::vector<Real>& results) const 
    {
        Size rateIndex = rateIndex_[currentIndex_-1];

        if (rateIndex < rateTimes_.size() -3)
        {
            results.resize(10);

            Real x= currentState.forwardRate(rateIndex);
            Real y = currentState.coterminalSwapRate(rateIndex+1);
            Real z = currentState.discountRatio(rateIndex,rateTimes_.size()-1);

            results[0] = 1.0;
            results[1] = x;
            results[2] = y;
            results[3] = z;
            results[4] = x*y;
            results[5] = y*z;
            results[6] = z*x;
            results[7] = x*x;
            results[8] = y*y;
            results[9] = z*z;
        }
        else
            if ( rateIndex == rateTimes_.size() -3)
            {
                 Real x= currentState.forwardRate(rateIndex);
                  Real y = currentState.forwardRate(rateIndex+1);
                  results.resize(6);
                 results[0] = 1.0;
                 results[1] = x;
                 results[2] = y;
                 results[3] = x*x;
                 results[4] = x*y;
                 results[5] = y*y;
     
            }
            else
            {
                 Real x= currentState.forwardRate(rateIndex);
                 results.resize(3);
                 results[0] =1.0;
                 results[1] = x;
                 results[2] = x*x;

            }
    }

    std::unique_ptr<MarketModelBasisSystem>
    SwapForwardBasisSystem::clone() const {
        return std::unique_ptr<MarketModelBasisSystem>(new SwapForwardBasisSystem(*this));
    }

}

]]></document_content>
  </document>
  <document index="19">
    <source>marketmodels/callability/swapratetrigger.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/callability/swapratetrigger.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {

    SwapRateTrigger::SwapRateTrigger(const std::vector<Time>& rateTimes,
                                     std::vector<Rate> swapTriggers,
                                     const std::vector<Time>& exerciseTimes)
    : rateTimes_(rateTimes), swapTriggers_(std::move(swapTriggers)), exerciseTimes_(exerciseTimes),
      rateIndex_(exerciseTimes.size()) {

        checkIncreasingTimes(rateTimes);
        QL_REQUIRE(rateTimes.size()>1,
                   "Rate times must contain at least two values");

        checkIncreasingTimes(exerciseTimes);

        QL_REQUIRE(swapTriggers_.size()==exerciseTimes_.size(),
                   "swapTriggers/exerciseTimes mismatch");
        Size j = 0;
        for (Size i=0; i<exerciseTimes.size(); ++i) {
            while (j < rateTimes.size() && rateTimes[j] < exerciseTimes[i])
                ++j;
            rateIndex_[i] = j;
        }
    }

    std::vector<Time> SwapRateTrigger::exerciseTimes() const {
        return exerciseTimes_;
    }

    std::vector<Time> SwapRateTrigger::relevantTimes() const {
        return exerciseTimes_;
    }

    void SwapRateTrigger::reset() {
        currentIndex_=0;
    }

    bool SwapRateTrigger::exercise(const CurveState& currentState) const {
        Size rateIndex = rateIndex_[currentIndex_-1];
        Rate currentSwapRate =
            currentState.coterminalSwapRate(rateIndex);
        return swapTriggers_[currentIndex_-1]<currentSwapRate;
    }

    void SwapRateTrigger::nextStep(const CurveState&) {
        ++currentIndex_;
    }

    std::unique_ptr<ExerciseStrategy<CurveState>>
    SwapRateTrigger::clone() const {
        return std::unique_ptr<ExerciseStrategy<CurveState>>(new SwapRateTrigger(*this));
    }

}
]]></document_content>
  </document>
  <document index="20">
    <source>marketmodels/callability/triggeredswapexercise.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/callability/triggeredswapexercise.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {

    TriggeredSwapExercise::TriggeredSwapExercise(const std::vector<Time>& rateTimes,
                                                 const std::vector<Time>& exerciseTimes,
                                                 std::vector<Rate> strikes)
    : rateTimes_(rateTimes), exerciseTimes_(exerciseTimes), strikes_(std::move(strikes)),
      rateIndex_(exerciseTimes.size()), evolution_(rateTimes, exerciseTimes) {
        Size j = 0;
        for (Size i=0; i<exerciseTimes.size(); ++i) {
            while (j < rateTimes.size() && rateTimes[j] < exerciseTimes[i])
                ++j;
            rateIndex_[i] = j;
        }
    }

    Size TriggeredSwapExercise::numberOfExercises() const {
        return exerciseTimes_.size();
    }

    const EvolutionDescription& TriggeredSwapExercise::evolution() const {
        return evolution_;
    }

    void TriggeredSwapExercise::nextStep(const CurveState&) {
        ++currentStep_;
    }

    void TriggeredSwapExercise::reset() {
        currentStep_ = 0;
    }

    std::valarray<bool> TriggeredSwapExercise::isExerciseTime() const {
        return std::valarray<bool>(true,numberOfExercises());
    }

    void TriggeredSwapExercise::values(const CurveState& state,
                                       std::vector<Real>& results) const {
        Size swapIndex = rateIndex_[currentStep_-1];
        results.resize(1);
        results[0] = state.coterminalSwapRate(swapIndex);
    }

    std::vector<Size> TriggeredSwapExercise::numberOfVariables() const {
        return std::vector<Size>(numberOfExercises(), 1);
    }

    std::vector<Size> TriggeredSwapExercise::numberOfParameters() const {
        return std::vector<Size>(numberOfExercises(), 1);
    }

    bool TriggeredSwapExercise::exercise(
                                   Size,
                                   const std::vector<Real>& parameters,
                                   const std::vector<Real>& variables) const {
        return variables[0] >= parameters[0];
    }

    void TriggeredSwapExercise::guess(Size exerciseIndex,
                                      std::vector<Real>& parameters) const {
        parameters.resize(1);
        parameters[0] = strikes_.at(exerciseIndex);
    }

    std::unique_ptr<MarketModelParametricExercise>
    TriggeredSwapExercise::clone() const {
        return std::unique_ptr<MarketModelParametricExercise>(new TriggeredSwapExercise(*this));
    }

}

]]></document_content>
  </document>
  <document index="21">
    <source>marketmodels/callability/upperboundengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/accountingengine.hpp>
#include <ql/models/marketmodels/callability/exercisevalue.hpp>
#include <ql/models/marketmodels/callability/upperboundengine.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/discounter.hpp>
#include <ql/models/marketmodels/evolver.hpp>
#include <ql/models/marketmodels/multiproduct.hpp>
#include <ql/models/marketmodels/products/multistep/callspecifiedmultiproduct.hpp>
#include <ql/models/marketmodels/products/multistep/exerciseadapter.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <algorithm>
#include <utility>

namespace QuantLib {

    namespace {

        class DecoratedHedge : public CallSpecifiedMultiProduct {
          public:
            explicit DecoratedHedge(const CallSpecifiedMultiProduct& product)
            : CallSpecifiedMultiProduct(product) {
                savedStates_.reserve(product.evolution().numberOfSteps());

                Size N = product.numberOfProducts();
                numberCashFlowsThisStep_.resize(N);
                cashFlowsGenerated_.resize(N);
                for (Size i=0; i<N; ++i)
                    cashFlowsGenerated_[i].resize(
                            product.maxNumberOfCashFlowsPerProductPerStep());

                clear();
            }

            void reset() override {
                CallSpecifiedMultiProduct::reset();
                disableCallability();
                for (Size i=0; i<lastSavedStep_; ++i)
                    CallSpecifiedMultiProduct::nextTimeStep(
                                                     *savedStates_[i],
                                                     numberCashFlowsThisStep_,
                                                     cashFlowsGenerated_);
                enableCallability();
            }

            bool nextTimeStep(const CurveState& currentState,
                              std::vector<Size>& numberCashFlowsThisStep,
                              std::vector<std::vector<CashFlow> >& cashFlowsGenerated) override {
                if (recording_)
                    savedStates_.emplace_back(currentState);
                return CallSpecifiedMultiProduct::nextTimeStep(
                                                     currentState,
                                                     numberCashFlowsThisStep,
                                                     cashFlowsGenerated);
            }

            std::unique_ptr<MarketModelMultiProduct> clone() const override {
                return std::unique_ptr<MarketModelMultiProduct>(new DecoratedHedge(*this));
            }

            void save() {
                lastSavedStep_ = savedStates_.size();
            }

            void clear() {
                lastSavedStep_ = 0;
                savedStates_.clear();
                recording_ = true;
            }

            void startRecording() {
                recording_ = true;
            }

            void stopRecording() {
                recording_ = false;
            }
          private:
            std::vector<Clone<CurveState> > savedStates_;
            Size lastSavedStep_;
            bool recording_;
            std::vector<Size> numberCashFlowsThisStep_;
            std::vector<std::vector<CashFlow> > cashFlowsGenerated_;
        };

    }


    UpperBoundEngine::UpperBoundEngine(
        ext::shared_ptr<MarketModelEvolver> evolver,
        std::vector<ext::shared_ptr<MarketModelEvolver> > innerEvolvers,
        const MarketModelMultiProduct& underlying,
        const MarketModelExerciseValue& rebate,
        const MarketModelMultiProduct& hedge,
        const MarketModelExerciseValue& hedgeRebate,
        const ExerciseStrategy<CurveState>& hedgeStrategy,
        Real initialNumeraireValue)
    : evolver_(std::move(evolver)), innerEvolvers_(std::move(innerEvolvers)),
      composite_(MultiProductComposite()), initialNumeraireValue_(initialNumeraireValue) {

        composite_.add(underlying);
        composite_.add(ExerciseAdapter(rebate));
        composite_.add(hedge);
        composite_.add(ExerciseAdapter(hedgeRebate));
        composite_.add(DecoratedHedge(CallSpecifiedMultiProduct(
                           hedge,hedgeStrategy,ExerciseAdapter(hedgeRebate))));
        composite_.finalize();

        underlyingOffset_ = 0;
        underlyingSize_ = underlying.numberOfProducts();
        rebateOffset_ = underlyingSize_;
        rebateSize_ = 1;
        hedgeOffset_ = underlyingSize_+rebateSize_;
        hedgeSize_ = hedge.numberOfProducts();
        hedgeRebateOffset_ = underlyingSize_+rebateSize_+hedgeSize_;
        hedgeRebateSize_ = 1;


        numberOfProducts_ = composite_.numberOfProducts();

        const std::vector<Time>& evolutionTimes =
            composite_.evolution().evolutionTimes();
        numberOfSteps_ = evolutionTimes.size();

        isExerciseTime_.resize(evolutionTimes.size());
        isExerciseTime_ = isInSubset(evolutionTimes,
                                     hedgeStrategy.exerciseTimes());

        numberCashFlowsThisStep_.resize(numberOfProducts_);
        cashFlowsGenerated_.resize(numberOfProducts_);
        for (Size i=0; i<numberOfProducts_; ++i)
            cashFlowsGenerated_[i].resize(
                          composite_.maxNumberOfCashFlowsPerProductPerStep());

        const std::vector<Time>& cashFlowTimes =
            composite_.possibleCashFlowTimes();
        const std::vector<Rate>& rateTimes =
            composite_.evolution().rateTimes();
        Size n =cashFlowTimes.size();
        discounters_.reserve(n);
        for (Size j=0; j<n; ++j)
            discounters_.emplace_back(cashFlowTimes[j], rateTimes);
    }


    void UpperBoundEngine::multiplePathValues(Statistics& stats,
                                              Size outerPaths,
                                              Size innerPaths) {
        for (Size i=0; i<outerPaths; ++i) {
            std::pair<Real,Real> result = singlePathValue(innerPaths);
            stats.add(result.first, result.second);
        }
    }


    std::pair<Real,Real> UpperBoundEngine::singlePathValue(Size innerPaths) {

        auto& callable = dynamic_cast<DecoratedHedge&>(composite_.item(4));
        const ExerciseStrategy<CurveState>& strategy = callable.strategy();


        Real maximumValue = QL_MIN_REAL;
        Real numerairesHeld = 0.0;
        Real weight = evolver_->startNewPath();
        callable.clear();
        composite_.reset();
        callable.disableCallability();
        Real principalInNumerairePortfolio = 1.0;
        Size exercise = 0;

        for (Size k=0; k<numberOfSteps_; ++k) {
            weight *= evolver_->advanceStep();

            composite_.nextTimeStep(evolver_->currentState(),
                                    numberCashFlowsThisStep_,
                                    cashFlowsGenerated_);

            // First, we accumulate cash flows from both the
            // underlying...
            Real underlyingCashFlows =
                collectCashFlows(k,
                                 principalInNumerairePortfolio,
                                 underlyingOffset_,
                                 underlyingOffset_+underlyingSize_);

            // ...and the hedge
            Real hedgeCashFlows =
                collectCashFlows(k,
                                 principalInNumerairePortfolio,
                                 hedgeOffset_,
                                 hedgeOffset_+hedgeSize_);

            // we do the same for the rebates. Warning: this relies on
            // the fact that on each exercise date an ExerciseAdapter
            // generates a cash-flow equal to the exercise value
            Real rebateCashFlow =
                collectCashFlows(k,
                                 principalInNumerairePortfolio,
                                 rebateOffset_,
                                 rebateOffset_+rebateSize_);

            Real hedgeRebateCashFlow =
                collectCashFlows(k,
                                 principalInNumerairePortfolio,
                                  hedgeRebateOffset_,
                                 hedgeRebateOffset_+hedgeRebateSize_);


            numerairesHeld += underlyingCashFlows - hedgeCashFlows;

            // Second, we do the upper-bound thing
            if (isExerciseTime_[k]) {

                Real unexercisedHedgeValue = 0.0;

                if (k != numberOfSteps_-1) {

                    // Here, we setup the relevant inner evolver and
                    // the decorated callable hedge such that their
                    // reset() method brings them to the current point
                    // rather than the beginning of the path.

                    ext::shared_ptr<MarketModelEvolver> currentEvolver =
                        innerEvolvers_[exercise++];
                    currentEvolver->setInitialState(evolver_->currentState());

                    callable.stopRecording();
                    callable.enableCallability();
                    callable.save();

                    // This allows us to write:
                    AccountingEngine engine(currentEvolver, callable,
                                            1.0); // this causes the result
                                                  // to be in numeraire units
                    SequenceStatisticsInc innerStats(callable.numberOfProducts());
                    engine.multiplePathValues(innerStats, innerPaths);

                    const std::vector<Real>& values = innerStats.mean();
                    unexercisedHedgeValue =
                        std::accumulate(values.begin(), values.end(), Real(0.0))
                        / principalInNumerairePortfolio;

                    callable.disableCallability();
                    callable.startRecording();

                }

                // Now, we can calculate the total value of our hedged
                // portfolio...
                Real portfolioValue = numerairesHeld;
                if (strategy.exercise(evolver_->currentState())) {
                    // get the rebates...
                    portfolioValue +=
                        rebateCashFlow - hedgeRebateCashFlow;
                    // ...and reinvest to rehedge
                    numerairesHeld +=
                        unexercisedHedgeValue - hedgeRebateCashFlow;
                } else {
                    portfolioValue +=
                        rebateCashFlow - unexercisedHedgeValue;
                }

                // ...and use it to update the maximum value
                maximumValue = std::max(maximumValue, portfolioValue);
            }


            // Lastly, we do the homework for next step (if any)
            if (k<numberOfSteps_-1) {

                // The numeraire might change between steps. This implies
                // that we might have to convert the numeraire bonds for
                // this step into a corresponding amount of numeraire
                // bonds for the next step. This can be done by changing
                // the principal of the numeraire and updating the number
                // of bonds in the numeraire portfolio accordingly.

                Size numeraire = evolver_->numeraires()[k];
                Size nextNumeraire = evolver_->numeraires()[k+1];

                principalInNumerairePortfolio *=
                    evolver_->currentState().discountRatio(numeraire,
                                                           nextNumeraire);
            }

        }

        // finally, we update the maximum with the total accumulated
        // cash flows (in case we never exercised)
        maximumValue = std::max(maximumValue, numerairesHeld);


        // all done; we just convert the result back to cash
        maximumValue *= initialNumeraireValue_;

        return std::make_pair(maximumValue, weight);
    }


    Real UpperBoundEngine::collectCashFlows(Size currentStep,
                                            Real principalInNumerairePortfolio,
                                            Size beginProduct,
                                            Size endProduct) const {
        Size numeraire = evolver_->numeraires()[currentStep];

        Real numeraireUnits = 0.0;
        // For each product in range...
        for (Size i=beginProduct; i<endProduct; ++i) {
            // ...and for each cash flow...
            const std::vector<MarketModelMultiProduct::CashFlow>& cashflows =
                cashFlowsGenerated_[i];
            for (Size j=0; j<numberCashFlowsThisStep_[i]; ++j) {
                // ...convert the cash flow to numeraires.  This is
                // done by calculating the number of numeraire bonds
                // corresponding to such cash flow...
                const MarketModelDiscounter& discounter =
                    discounters_[cashflows[j].timeIndex];
                // ...and adding the newly bought bonds to the total
                numeraireUnits += cashflows[j].amount *
                    discounter.numeraireBonds(evolver_->currentState(),
                                              numeraire);
            }
        }
        return numeraireUnits/principalInNumerairePortfolio;
    }

}

]]></document_content>
  </document>
  <document index="22">
    <source>marketmodels/correlations/cotswapfromfwdcorrelation.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 François du Vignaud
 Copyright (C) 2007 Chiara Fornarola
 Copyright (C) 2007 Katiuscia Manzoni

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/correlations/cotswapfromfwdcorrelation.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/swapforwardmappings.hpp>
#include <ql/math/matrixutilities/getcovariance.hpp>

namespace QuantLib {

    CotSwapFromFwdCorrelation::CotSwapFromFwdCorrelation(
            const ext::shared_ptr<PiecewiseConstantCorrelation>& fwdCorr,
            const CurveState& curveState,
            Spread displacement)
    : fwdCorr_(fwdCorr),
      numberOfRates_(fwdCorr->numberOfRates()),
      swapCorrMatrices_(fwdCorr->correlations().size())
    {
        QL_REQUIRE(numberOfRates_==curveState.numberOfRates(),
                   "mismatch between number of rates in fwdCorr (" <<
                   numberOfRates_ << ") and curveState (" <<
                   curveState.numberOfRates() << ")");

        Matrix zed = SwapForwardMappings::coterminalSwapZedMatrix(
                                                curveState, displacement);
        Matrix zedT = transpose(zed);
        const std::vector<Matrix>& fwdCorrMatrices = fwdCorr->correlations();
        for (Size k = 0; k<fwdCorrMatrices.size(); ++k) {
            swapCorrMatrices_[k] = CovarianceDecomposition(
                zed * fwdCorrMatrices[k] * zedT).correlationMatrix();
            // zero expired rates' correlation coefficients
            const std::vector<Time>& rateTimes = curveState.rateTimes();
            const std::vector<Time>& corrTimes = fwdCorr_->times();
            for (Size i=0; i<numberOfRates_; ++i)
                for (Size j=0; j<=i; ++j)
                    if (corrTimes[k]>rateTimes[j])
                        swapCorrMatrices_[k][i][j] =
                            swapCorrMatrices_[k][j][i] = 0.0;
        }
    }

    const std::vector<Time>& CotSwapFromFwdCorrelation::times() const {
        return fwdCorr_->times();
    }

    const std::vector<Time>& CotSwapFromFwdCorrelation::rateTimes() const {
        return fwdCorr_->rateTimes();
    }

    Size CotSwapFromFwdCorrelation::numberOfRates() const {
        return numberOfRates_;
    }

    const std::vector<Matrix>&
    CotSwapFromFwdCorrelation::correlations() const {
        return swapCorrMatrices_;
    }

}
]]></document_content>
  </document>
  <document index="23">
    <source>marketmodels/correlations/expcorrelations.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2007 François du Vignaud

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/comparison.hpp>
#include <ql/models/marketmodels/correlations/expcorrelations.hpp>
#include <ql/models/marketmodels/correlations/timehomogeneousforwardcorrelation.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <utility>

namespace QuantLib {

    Matrix exponentialCorrelations(const std::vector<Time>& rateTimes,
                                   Real longTermCorr,
                                   Real beta,
                                   Real gamma,
                                   Time time) {
        // preliminary checks
        checkIncreasingTimes(rateTimes);
        QL_REQUIRE(longTermCorr<=1.0 && longTermCorr>=0.0,
                   "Long term correlation (" << longTermCorr <<
                   ") outside [0;1] interval");
        QL_REQUIRE(beta>=0.0,
                   "beta (" << beta <<
                   ") must be greater than zero");
        QL_REQUIRE(gamma<=1.0 && gamma>=0.0,
                   "gamma (" << gamma <<
                   ") outside [0;1] interval");

        // Calculate correlation matrix
        Size nbRows = rateTimes.size()-1;
        Matrix correlations(nbRows, nbRows, 0.0);
        for (Size i=0; i<nbRows; ++i) {
            // correlation is defined only between
            // (alive) stochastic rates...
            if (time<=rateTimes[i]) {
                correlations[i][i] = 1.0;
                for (Size j=0; j<i; ++j) {
                    if (time<=rateTimes[j]) {
                        correlations[i][j] = correlations[j][i] =
                            longTermCorr + (1.0-longTermCorr) *
                            std::exp(-beta*std::fabs(
                                std::pow(rateTimes[i]-time, gamma) -
                                std::pow(rateTimes[j]-time, gamma)
                                )
                            );
                    }
                }
            }
        }
        return correlations;
    }


    ExponentialForwardCorrelation::ExponentialForwardCorrelation(const std::vector<Time>& rateTimes,
                                                                 Real longTermCorr,
                                                                 Real beta,
                                                                 Real gamma,
                                                                 std::vector<Time> times)
    : numberOfRates_(rateTimes.empty() ? 0 : rateTimes.size() - 1), longTermCorr_(longTermCorr),
      beta_(beta), gamma_(gamma), rateTimes_(rateTimes), times_(std::move(times)) {

        QL_REQUIRE(numberOfRates_>1,
                   "Rate times must contain at least two values");

        checkIncreasingTimes(rateTimes_);

        // corrTimes must include all rateTimes but the last
        if (times_.empty())
            times_ = std::vector<Time>(rateTimes_.begin(),
                                       rateTimes_.end()-1);
        else
            checkIncreasingTimes(times_);

        if (close(gamma,1.0)) {
            std::vector<Time> temp(rateTimes_.begin(), rateTimes_.end()-1);
            QL_REQUIRE(times_==temp,
                       "corr times " << io::sequence(times_)
                       << " must be equal to (all) rate times (but the last) "
                       << io::sequence(temp));
            Matrix c = exponentialCorrelations(
                rateTimes_, longTermCorr_, beta_, 1.0, 0.0);
            correlations_ =
                TimeHomogeneousForwardCorrelation::evolvedMatrices(c);
        } else {
            // FIXME should check here that all rateTimes but the last
            // are included in rateTimes
            QL_REQUIRE(times_.back()<=rateTimes_[numberOfRates_],
                       "last corr time " << times_.back() <<
                       "is after next-to-last rate time " <<
                       rateTimes_[numberOfRates_]);
            correlations_.resize(times_.size());
            Time time = times_[0]/2.0;
            correlations_[0] = exponentialCorrelations(
                rateTimes_, longTermCorr_, beta_, gamma_, time);
            for (Size k=1; k<times_.size(); ++k) {
                time = (times_[k]+times_[k-1])/2.0;
                correlations_[k] = exponentialCorrelations(
                    rateTimes_, longTermCorr_, beta_, gamma_, time);
            }
        }
    }

    const std::vector<Time>&
    ExponentialForwardCorrelation::times() const {
        return times_;
    }

    const std::vector<Time>&
    ExponentialForwardCorrelation::rateTimes() const {
        return rateTimes_;
    }

    const std::vector<Matrix>&
    ExponentialForwardCorrelation::correlations() const {
        return correlations_;
    }

    Size ExponentialForwardCorrelation::numberOfRates() const {
        return numberOfRates_;
    }

}
]]></document_content>
  </document>
  <document index="24">
    <source>marketmodels/correlations/timehomogeneousforwardcorrelation.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 François du Vignaud
 Copyright (C) 2007 Chiara Fornarola
 Copyright (C) 2007 Katiuscia Manzoni

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/correlations/timehomogeneousforwardcorrelation.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <ql/math/matrixutilities/pseudosqrt.hpp>

namespace QuantLib {

    TimeHomogeneousForwardCorrelation::TimeHomogeneousForwardCorrelation(
                        const Matrix& fwdCorrelation,
                        const std::vector<Time>& rateTimes)
    : numberOfRates_(rateTimes.empty() ? 0 : rateTimes.size()-1),
      fwdCorrelation_(fwdCorrelation),
      rateTimes_(rateTimes),
      times_(numberOfRates_) {

        checkIncreasingTimes(rateTimes);
        QL_REQUIRE(numberOfRates_>=1,
                   "Rate times must contain at least two values");
        QL_REQUIRE(numberOfRates_==fwdCorrelation.rows(),
                   "mismatch between number of rates (" << numberOfRates_ <<
                   ") and fwdCorrelation rows (" << fwdCorrelation.rows() << ")");
        QL_REQUIRE(numberOfRates_==fwdCorrelation.columns(),
                   "mismatch between number of rates (" << numberOfRates_ <<
                   ") and fwdCorrelation columns (" << fwdCorrelation.columns() << ")");

        std::copy(rateTimes.begin(), rateTimes.end()-1, times_.begin());
        correlations_ = evolvedMatrices(fwdCorrelation_);
    }

    std::vector<Matrix> TimeHomogeneousForwardCorrelation::evolvedMatrices(
                                    const Matrix& fwdCorrelation) {
        Size numberOfRates = fwdCorrelation.rows();
        std::vector<Matrix> correlations(numberOfRates, Matrix(numberOfRates,
                                                               numberOfRates,
                                                               0.0));
        for (Size k=0; k<correlations.size(); ++k) {
            // proper diagonal values
            for (Size i=k; i<numberOfRates; ++i)
                correlations[k][i][i] = 1.0;
            // copy only time homogeneous values
            for (Size i=k; i<numberOfRates; ++i) {
                for (Size j=k; j<i; ++j) {
                    correlations[k][i][j] = correlations[k][j][i] =
                        fwdCorrelation[i-k][j-k];
                }
            }
        }
        return correlations;
    }

    const std::vector<Time>&
    TimeHomogeneousForwardCorrelation::times() const {
        return times_;
    }

    const std::vector<Time>&
    TimeHomogeneousForwardCorrelation::rateTimes() const {
        return rateTimes_;
    }

    const std::vector<Matrix>&
    TimeHomogeneousForwardCorrelation::correlations() const {
        return correlations_;
    }

    Size TimeHomogeneousForwardCorrelation::numberOfRates() const {
        return numberOfRates_;
    }

}
]]></document_content>
  </document>
  <document index="25">
    <source>marketmodels/curvestate.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006, 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/utilities.hpp>

namespace QuantLib {

    CurveState::CurveState(const std::vector<Time>& rateTimes)
    : numberOfRates_(rateTimes.empty() ? 0 : rateTimes.size()-1),
      rateTimes_(rateTimes), rateTaus_(numberOfRates_) {
        checkIncreasingTimesAndCalculateTaus(rateTimes_, rateTaus_);
    }

    Rate CurveState::swapRate(Size begin,
                              Size end) const {

        QL_REQUIRE(end > begin, "empty range specified");
        QL_REQUIRE(end <= numberOfRates_, "taus/end mismatch");

        Real sum = 0.0;
        for (Size i=begin; i<end; ++i)
            sum += rateTaus_[i]*discountRatio(i+1, numberOfRates_);

        return (discountRatio(begin, numberOfRates_)-discountRatio(end, numberOfRates_))/sum;
    }

    void forwardsFromDiscountRatios(const Size firstValidIndex,
                                    const std::vector<DiscountFactor>& ds,
                                    const std::vector<Time>& taus,
                                    std::vector<Rate>& fwds) {
        QL_REQUIRE(taus.size()==fwds.size(),
                   "taus.size()!=fwds.size()");
        QL_REQUIRE(ds.size()==fwds.size()+1,
                   "ds.size()!=fwds.size()+1");

        for (Size i=firstValidIndex; i<fwds.size(); ++i)
            fwds[i] = (ds[i]-ds[i+1])/(ds[i+1]*taus[i]);
    }

    void coterminalFromDiscountRatios(
                    const Size firstValidIndex,
                    const std::vector<DiscountFactor>& discountFactors,
                    const std::vector<Time>& taus,
                    std::vector<Rate>& cotSwapRates,
                    std::vector<Real>& cotSwapAnnuities) 
    {
        Size nCotSwapRates = cotSwapRates.size();
        QL_REQUIRE(taus.size()==nCotSwapRates,
                   "taus.size()!=cotSwapRates.size()");
        QL_REQUIRE(cotSwapAnnuities.size()==nCotSwapRates,
                   "cotSwapAnnuities.size()!=cotSwapRates.size()");
        QL_REQUIRE(discountFactors.size()==nCotSwapRates+1,
                   "discountFactors.size()!=cotSwapRates.size()+1");

        cotSwapAnnuities[nCotSwapRates-1] = 
            taus[nCotSwapRates-1]*discountFactors[nCotSwapRates];
        cotSwapRates[nCotSwapRates-1] = 
            (discountFactors[nCotSwapRates-1]-discountFactors[nCotSwapRates])
                /cotSwapAnnuities[nCotSwapRates-1];

        for (Size i=nCotSwapRates-1; i>firstValidIndex; --i) {
            cotSwapAnnuities[i-1] = cotSwapAnnuities[i] + taus[i-1] * discountFactors[i];
            cotSwapRates[i-1] = 
                (discountFactors[i-1]-discountFactors[nCotSwapRates])
                /cotSwapAnnuities[i-1];
        }
    }


    void constantMaturityFromDiscountRatios(// Size i, // to be added later
                                            const Size spanningForwards,
                                            const Size firstValidIndex,
                                            const std::vector<DiscountFactor>& ds,
                                            const std::vector<Time>& taus,
                                            std::vector<Rate>& constMatSwapRates,
                                            std::vector<Real>& constMatSwapAnnuities) {
        Size nConstMatSwapRates = constMatSwapRates.size();
        QL_REQUIRE(taus.size()==nConstMatSwapRates,
                   "taus.size()!=nConstMatSwapRates");
        QL_REQUIRE(constMatSwapAnnuities.size()==nConstMatSwapRates,
                   "constMatSwapAnnuities.size()!=nConstMatSwapRates");
        QL_REQUIRE(ds.size()==nConstMatSwapRates+1,
                   "ds.size()!=nConstMatSwapRates+1");
        // compute the first cmsrate and cmsannuity
        constMatSwapAnnuities[firstValidIndex]=0.;
        Size lastIndex = std::min(firstValidIndex+spanningForwards,nConstMatSwapRates);
        for (Size i=firstValidIndex; i<lastIndex; ++i) {
            constMatSwapAnnuities[firstValidIndex]+= taus[i] * ds[i+1];
        }
        constMatSwapRates[firstValidIndex] =
            (ds[firstValidIndex]-ds[lastIndex])/
                constMatSwapAnnuities[firstValidIndex];
        Size oldLastIndex = lastIndex;

        // compute all the other cmas rates and cms annuities
        for (Size i=firstValidIndex+1; i<nConstMatSwapRates; ++i) {
            Size lastIndex = std::min(i+spanningForwards,nConstMatSwapRates);
            constMatSwapAnnuities[i] = constMatSwapAnnuities[i-1]
                                       - taus[i-1] * ds[i];
            if (lastIndex!=oldLastIndex)
               constMatSwapAnnuities[i] += taus[lastIndex-1] * ds[lastIndex];
            constMatSwapRates[i] = (ds[i]-ds[lastIndex])
                /constMatSwapAnnuities[i];
            oldLastIndex = lastIndex;
        }
    }

}
]]></document_content>
  </document>
  <document index="26">
    <source>marketmodels/curvestates/cmswapcurvestate.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2006, 2007 Ferdinando Ametrano
Copyright (C) 2007 François du Vignaud
Copyright (C) 2006, 2007 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestates/cmswapcurvestate.hpp>

namespace QuantLib {

    CMSwapCurveState::CMSwapCurveState(const std::vector<Time>& rateTimes,
                                       Size spanningForwards)
    : CurveState(rateTimes),
      spanningFwds_(spanningForwards),
      first_(numberOfRates_),
      discRatios_(numberOfRates_+1, 1.0),
      forwardRates_(numberOfRates_),
      cmSwapRates_(numberOfRates_),
      cmSwapAnnuities_(numberOfRates_, rateTaus_[numberOfRates_-1]),
      irrCMSwapRates_(numberOfRates_),
      irrCMSwapAnnuities_(numberOfRates_, rateTaus_[numberOfRates_-1]),
      cotSwapRates_(numberOfRates_),
      cotAnnuities_(numberOfRates_, rateTaus_[numberOfRates_-1]) {}

    void CMSwapCurveState::setOnCMSwapRates(const std::vector<Rate>& rates,
                                            Size firstValidIndex) {
        QL_REQUIRE(rates.size()==numberOfRates_,
                   "rates mismatch: " <<
                   numberOfRates_ << " required, " <<
                   rates.size() << " provided");
        QL_REQUIRE(firstValidIndex<numberOfRates_,
                   "first valid index must be less than " <<
                   numberOfRates_ << ": " <<
                   firstValidIndex << " not allowed");

        // first copy input...
        first_ = firstValidIndex;
        std::copy(rates.begin()+first_, rates.end(),
                  cmSwapRates_.begin()+first_);
        // ...then calculate discount ratios and annuities

        // taken care at constructor time
        //discRatios_[numberOfRates_] = 1.0;
        //cmSwapAnnuities_[numberOfRates_-1] = rateTaus_[numberOfRates_-1];

        // assume i+1 and do i
        Integer oldAnnuityEndIndex = numberOfRates_;
        for (Size i=numberOfRates_-1; i>first_; --i)
        {
            // formula 6.1 Joshi Liesch
            Integer endIndex = std::min(i + spanningFwds_,numberOfRates_);
            Integer annuityEndIndex = std::min(i + spanningFwds_-1,numberOfRates_);

            discRatios_[i] = discRatios_[endIndex] +
            cmSwapRates_[i]*cmSwapAnnuities_[i];
            cmSwapAnnuities_[i-1]= cmSwapAnnuities_[i]
            +discRatios_[i] * rateTaus_[i-1];

            if (annuityEndIndex < oldAnnuityEndIndex)
              cmSwapAnnuities_[i-1]-=discRatios_[oldAnnuityEndIndex] * rateTaus_[oldAnnuityEndIndex-1 ];

            oldAnnuityEndIndex = annuityEndIndex;
        }
        Integer endIndex = std::min(first_ + spanningFwds_,numberOfRates_);

        discRatios_[first_]= discRatios_[endIndex] +
        cmSwapRates_[first_]*cmSwapAnnuities_[first_];

        // lazy evaluation of forward and coterminal swap rates&annuities
    }

    Real CMSwapCurveState::discountRatio(Size i, Size j) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        QL_REQUIRE(std::min(i, j)>=first_, "invalid index");
        QL_REQUIRE(std::max(i, j)<=numberOfRates_, "invalid index");
        return discRatios_[i]/discRatios_[j];
    }

    Rate CMSwapCurveState::forwardRate(Size i) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        QL_REQUIRE(i>=first_ && i<=numberOfRates_, "invalid index");
        forwardsFromDiscountRatios(first_, discRatios_, rateTaus_, forwardRates_);
        return forwardRates_[i];
    }

    Rate CMSwapCurveState::coterminalSwapAnnuity(Size numeraire,
                                                 Size i) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        QL_REQUIRE(numeraire>=first_ && numeraire<=numberOfRates_,
                   "invalid numeraire");
        QL_REQUIRE(i>=first_ && i<=numberOfRates_, "invalid index");
        coterminalFromDiscountRatios(first_,
                                     discRatios_, rateTaus_,
                                     cotSwapRates_, cotAnnuities_);
        return cotAnnuities_[i]/discRatios_[numeraire];
    }

    Rate CMSwapCurveState::coterminalSwapRate(Size i) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        QL_REQUIRE(i>=first_ && i<=numberOfRates_, "invalid index");
        coterminalFromDiscountRatios(first_,
                                     discRatios_, rateTaus_,
                                     cotSwapRates_, cotAnnuities_);
        return cotSwapRates_[i];
    }

    Rate CMSwapCurveState::cmSwapAnnuity(Size numeraire,
                                         Size i,
                                         Size spanningForwards) const{
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        QL_REQUIRE(numeraire>=first_ && numeraire<=numberOfRates_,
                   "invalid numeraire");
        QL_REQUIRE(i>=first_ && i<=numberOfRates_, "invalid index");
        if (spanningForwards==spanningFwds_)
            return cmSwapAnnuities_[i]/discRatios_[numeraire];
        else {
            constantMaturityFromDiscountRatios(spanningForwards, first_,
                                               discRatios_, rateTaus_,
                                               irrCMSwapRates_,
                                               irrCMSwapAnnuities_);
            return irrCMSwapAnnuities_[i]/discRatios_[numeraire];
        }
    }

    Rate CMSwapCurveState::cmSwapRate(Size i,
                                      Size spanningForwards) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        QL_REQUIRE(i>=first_ && i<=numberOfRates_, "invalid index");
        if (spanningForwards==spanningFwds_)
            return cmSwapRates_[i];
        else {
            constantMaturityFromDiscountRatios(spanningForwards, first_,
                                               discRatios_, rateTaus_,
                                               irrCMSwapRates_,
                                               irrCMSwapAnnuities_);
            return irrCMSwapRates_[i];
        }
    }

    const std::vector<Rate>& CMSwapCurveState::forwardRates() const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        forwardsFromDiscountRatios(first_, discRatios_, rateTaus_, forwardRates_);
        return forwardRates_;
    }

    const std::vector<Rate>& CMSwapCurveState::coterminalSwapRates() const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        coterminalFromDiscountRatios(first_,
                                     discRatios_, rateTaus_,
                                     cotSwapRates_, cotAnnuities_);
        return cotSwapRates_;
    }

    const std::vector<Rate>& CMSwapCurveState::cmSwapRates(Size spanningForwards) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        if (spanningForwards==spanningFwds_)
            return cmSwapRates_;
        else {
            constantMaturityFromDiscountRatios(spanningForwards, first_,
                                               discRatios_, rateTaus_,
                                               irrCMSwapRates_, irrCMSwapAnnuities_);
            return irrCMSwapRates_;
        }
    }

    std::unique_ptr<CurveState> CMSwapCurveState::clone() const {
        return std::unique_ptr<CurveState>(new CMSwapCurveState(*this));
    }

}
]]></document_content>
  </document>
  <document index="27">
    <source>marketmodels/curvestates/coterminalswapcurvestate.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2007 Cristina Duminuco

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestates/coterminalswapcurvestate.hpp>

namespace QuantLib {

    CoterminalSwapCurveState::CoterminalSwapCurveState(
                                        const std::vector<Time>& rateTimes)
    : CurveState(rateTimes),
      first_(numberOfRates_),
      discRatios_(numberOfRates_+1, 1.0),
      forwardRates_(numberOfRates_),
      cmSwapRates_(numberOfRates_),
      cmSwapAnnuities_(numberOfRates_, rateTaus_[numberOfRates_-1]),
      cotSwapRates_(numberOfRates_),
      cotAnnuities_(numberOfRates_, rateTaus_[numberOfRates_-1]) {}

      void CoterminalSwapCurveState::setOnCoterminalSwapRates(
                                        const std::vector<Rate>& rates,
                                        Size firstValidIndex) {
            QL_REQUIRE(rates.size()==numberOfRates_,
                       "rates mismatch: " <<
                       numberOfRates_ << " required, " <<
                       rates.size() << " provided");
            QL_REQUIRE(firstValidIndex<numberOfRates_,
                       "first valid index must be less than " <<
                       numberOfRates_ << ": " <<
                       firstValidIndex << " not allowed");
        // first copy input...
        first_ = firstValidIndex;
        std::copy(rates.begin()+first_, rates.end(),
                  cotSwapRates_.begin()+first_);
        // ...then calculate discount ratios and coterminal annuities:
        // reference discount bond =  P(n) (the last one)
        // discRatios_[numberOfRates_] = P(n)/P(n) = 1.0 by construction/definition
        cotAnnuities_[numberOfRates_-1] = rateTaus_[numberOfRates_-1];
        // j < n
        for (Size i=numberOfRates_-1; i>first_; --i) {
            discRatios_[i] = 1.0 + cotSwapRates_[i] * cotAnnuities_[i];
            cotAnnuities_[i-1] = cotAnnuities_[i] + rateTaus_[i-1] * discRatios_[i];
        }
        discRatios_[first_] = 1.0 + cotSwapRates_[first_] * cotAnnuities_[first_];

        // Insert here lazy evaluation of:
        // - forward rates
        // - constant maturity swap rates/annuities
    }

    Real CoterminalSwapCurveState::discountRatio(Size i, Size j) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        QL_REQUIRE(std::min(i, j)>=first_, "invalid index");
        QL_REQUIRE(std::max(i, j)<=numberOfRates_, "invalid index");
        return discRatios_[i]/discRatios_[j];
    }

    Rate CoterminalSwapCurveState::forwardRate(Size i) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        QL_REQUIRE(i>=first_ && i<=numberOfRates_, "invalid index");
        forwardsFromDiscountRatios(first_, discRatios_, rateTaus_, forwardRates_);
        return forwardRates_[i];
    }

    Rate CoterminalSwapCurveState::coterminalSwapAnnuity(Size numeraire,
                                                         Size i) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        QL_REQUIRE(numeraire>=first_ && numeraire<=numberOfRates_,
                  "invalid numeraire");
        QL_REQUIRE(i>=first_ && i<=numberOfRates_, "invalid index");
        return cotAnnuities_[i]/discRatios_[numeraire];
    }

    Rate CoterminalSwapCurveState::coterminalSwapRate(Size i) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        QL_REQUIRE(i>=first_ && i<=numberOfRates_, "invalid index");
        return cotSwapRates_[i];
    }

    Rate CoterminalSwapCurveState::cmSwapAnnuity(Size numeraire,
                                                 Size i,
                                                 Size spanningForwards) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        QL_REQUIRE(numeraire>=first_ && numeraire<=numberOfRates_,
                   "invalid numeraire");
        QL_REQUIRE(i>=first_ && i<=numberOfRates_, "invalid index");

        // consider lazy evaluation here
        constantMaturityFromDiscountRatios(spanningForwards, first_,
                                           discRatios_, rateTaus_,
                                           cmSwapRates_, cmSwapAnnuities_);
        return cmSwapAnnuities_[i]/discRatios_[numeraire];
    }

    Rate CoterminalSwapCurveState::cmSwapRate(Size i,
                                              Size spanningForwards) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        QL_REQUIRE(i>=first_ && i<=numberOfRates_, "invalid index");

        // consider lazy evaluation here
        constantMaturityFromDiscountRatios(spanningForwards, first_,
                                           discRatios_, rateTaus_,
                                           cmSwapRates_, cmSwapAnnuities_);
        return cmSwapRates_[i];
    }

    const std::vector<Rate>& CoterminalSwapCurveState::forwardRates() const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        forwardsFromDiscountRatios(first_, discRatios_, rateTaus_, forwardRates_);
        return forwardRates_;
    }

    const std::vector<Rate>& CoterminalSwapCurveState::coterminalSwapRates() const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        return cotSwapRates_;
    }

    const std::vector<Rate>& CoterminalSwapCurveState::cmSwapRates(Size spanningForwards) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        constantMaturityFromDiscountRatios(spanningForwards, first_,
                                           discRatios_, rateTaus_,
                                           cmSwapRates_, cmSwapAnnuities_);
        return cmSwapRates_;
    }

    std::unique_ptr<CurveState>
    CoterminalSwapCurveState::clone() const {
        return std::unique_ptr<CurveState>(new CoterminalSwapCurveState(*this));
    }

}
]]></document_content>
  </document>
  <document index="28">
    <source>marketmodels/curvestates/lmmcurvestate.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006 Marco Bianchetti
 Copyright (C) 2006 Cristina Duminuco
 Copyright (C) 2006 Giorgio Facchinetti
 Copyright (C) 2006, 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>

namespace QuantLib {

    LMMCurveState::LMMCurveState(const std::vector<Time>& rateTimes)
    : CurveState(rateTimes),
      first_(numberOfRates_),
      discRatios_(numberOfRates_+1, 1.0),
      forwardRates_(numberOfRates_),
      cmSwapRates_(numberOfRates_),
      cmSwapAnnuities_(numberOfRates_,rateTaus_[numberOfRates_-1]),
      cotSwapRates_(numberOfRates_),
      cotAnnuities_(numberOfRates_,
      rateTaus_[numberOfRates_-1]),
      firstCotAnnuityComped_(numberOfRates_)
    {}

    void LMMCurveState::setOnForwardRates(const std::vector<Rate>& rates,
                                          Size firstValidIndex) {
            QL_REQUIRE(rates.size()==numberOfRates_,
                       "rates mismatch: " <<
                       numberOfRates_ << " required, " <<
                       rates.size() << " provided");
            QL_REQUIRE(firstValidIndex<numberOfRates_,
                       "first valid index must be less than " <<
                       numberOfRates_ << ": " <<
                       firstValidIndex << " not allowed");

        // first copy input...
        first_ = firstValidIndex;
        std::copy(rates.begin()+first_, rates.end(),
                  forwardRates_.begin()+first_);
        // ...then calculate discount ratios

        // taken care at constructor time
        //discRatios_[numberOfRates_] = 1.0;
        for (Size i=first_; i<numberOfRates_; ++i)
            discRatios_[i+1]=discRatios_[i]/(1.0+forwardRates_[i]*rateTaus_[i]);

        // lazy evaluation of:
        // - coterminal swap rates/annuities
        // - constant maturity swap rates/annuities

        firstCotAnnuityComped_ = numberOfRates_;
    }

    void LMMCurveState::setOnDiscountRatios(const std::vector<DiscountFactor>& discRatios,
                                            Size firstValidIndex) {
        QL_REQUIRE(discRatios.size()==numberOfRates_+1,
                   "too many discount ratios: " <<
                   numberOfRates_+1 << " required, " <<
                   discRatios.size() << " provided");
        QL_REQUIRE(firstValidIndex<numberOfRates_,
                   "first valid index must be less than " <<
                   numberOfRates_+1 << ": " <<
                   firstValidIndex << " not allowed");

        // first copy input...
        first_ = firstValidIndex;
        std::copy(discRatios.begin()+first_, discRatios.end(),
                  discRatios_.begin()+first_);
        // ...then calculate forwards

        for (Size i=first_; i<numberOfRates_; ++i)
            forwardRates_[i] = (discRatios_[i]/discRatios_[i+1]-1.0) /
                                                                rateTaus_[i];

        // lazy evaluation of:
        // - coterminal swap rates/annuities
        // - constant maturity swap rates/annuities

        firstCotAnnuityComped_ = numberOfRates_;
    }

    Real LMMCurveState::discountRatio(Size i, Size j) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        QL_REQUIRE(std::min(i, j)>=first_, "invalid index");
        QL_REQUIRE(std::max(i, j)<=numberOfRates_, "invalid index");
        return discRatios_[i]/discRatios_[j];
    }

    Rate LMMCurveState::forwardRate(Size i) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        QL_REQUIRE(i>=first_ && i<=numberOfRates_, "invalid index");
        return forwardRates_[i];
    }

    Rate LMMCurveState::coterminalSwapAnnuity(Size numeraire,
                                              Size i) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        QL_REQUIRE(numeraire>=first_ && numeraire<=numberOfRates_,
                   "invalid numeraire");
        QL_REQUIRE(i>=first_ && i<=numberOfRates_, "invalid index");
        //        coterminalFromDiscountRatios(first_,
        //                                   discRatios_, rateTaus_,
        //                                 cotSwapRates_, cotAnnuities_);

        if (firstCotAnnuityComped_ <=i)
            return  cotAnnuities_[i]/discRatios_[numeraire];

        if (firstCotAnnuityComped_ == numberOfRates_)
        {
            cotAnnuities_[numberOfRates_-1] = rateTaus_[numberOfRates_-1]*discRatios_[numberOfRates_];
            --firstCotAnnuityComped_;
        }

        for (int j= static_cast<int>(firstCotAnnuityComped_)-1; j >=static_cast<int>(i); --j)
            cotAnnuities_[j] = cotAnnuities_[j+1]+rateTaus_[j]*discRatios_[j+1];

        firstCotAnnuityComped_ = i;

        return cotAnnuities_[i]/discRatios_[numeraire];
    }

    Rate LMMCurveState::coterminalSwapRate(Size i) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        QL_REQUIRE(i>=first_ && i<=numberOfRates_, "invalid index");
        //    coterminalFromDiscountRatios(first_,
        //                               discRatios_, rateTaus_,
        //                             cotSwapRates_, cotAnnuities_);
        //      return cotSwapRates_[i];

        Real res = (discRatios_[i]/ discRatios_[numberOfRates_] -1.0)/coterminalSwapAnnuity(numberOfRates_,i);
        return res;
    }

    Rate LMMCurveState::cmSwapAnnuity(Size numeraire,
                                      Size i,
                                      Size spanningForwards) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        QL_REQUIRE(numeraire>=first_ && numeraire<=numberOfRates_,
                   "invalid numeraire");
        QL_REQUIRE(i>=first_ && i<=numberOfRates_, "invalid index");

        // consider lazy evaluation here
        constantMaturityFromDiscountRatios(spanningForwards, first_,
                                           discRatios_, rateTaus_,
                                           cmSwapRates_, cmSwapAnnuities_);
        return cmSwapAnnuities_[i]/discRatios_[numeraire];
    }

    Rate LMMCurveState::cmSwapRate(Size i,
                                   Size spanningForwards) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        QL_REQUIRE(i>=first_ && i<=numberOfRates_, "invalid index");

        // consider lazy evaluation here
        constantMaturityFromDiscountRatios(spanningForwards, first_,
                                           discRatios_, rateTaus_,
                                           cmSwapRates_, cmSwapAnnuities_);
        return cmSwapRates_[i];
    }

    const std::vector<Rate>& LMMCurveState::forwardRates() const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        return forwardRates_;
    }

    const std::vector<Rate>& LMMCurveState::coterminalSwapRates() const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        coterminalFromDiscountRatios(first_,
                                     discRatios_, rateTaus_,
                                     cotSwapRates_, cotAnnuities_);
        return cotSwapRates_;
    }

    const std::vector<Rate>& LMMCurveState::cmSwapRates(Size spanningForwards) const {
        QL_REQUIRE(first_<numberOfRates_, "curve state not initialized yet");
        constantMaturityFromDiscountRatios(spanningForwards, first_,
                                           discRatios_, rateTaus_,
                                           cmSwapRates_, cmSwapAnnuities_);
        return cmSwapRates_;
    }

    std::unique_ptr<CurveState> LMMCurveState::clone() const {
        return std::unique_ptr<CurveState>(new LMMCurveState(*this));
    }

}
]]></document_content>
  </document>
  <document index="29">
    <source>marketmodels/discounter.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/discounter.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <algorithm>

namespace QuantLib {

    MarketModelDiscounter::MarketModelDiscounter(
                                        Time paymentTime,
                                        const std::vector<Time>& rateTimes) {
        checkIncreasingTimes(rateTimes);
        before_ = std::lower_bound(rateTimes.begin(), rateTimes.end(),
                                   paymentTime) - rateTimes.begin();

        // handle the case where the payment is in the last
        // period or after the last period
        if (before_ > rateTimes.size()-2)
            before_ =  rateTimes.size()-2;

        beforeWeight_=1.0-(paymentTime-rateTimes[before_])/
            (rateTimes[before_+1]-rateTimes[before_]);
    }

    Real MarketModelDiscounter::numeraireBonds(const CurveState& curveState,
                                               Size numeraire) const {
        Real preDF = curveState.discountRatio(before_,numeraire);
        if (beforeWeight_==1.0)
            return preDF;

        Real postDF = curveState.discountRatio(before_+1,numeraire);
        if (beforeWeight_==0.0)
            return postDF;

        return std::pow(preDF,beforeWeight_)*std::pow(postDF,1.-beforeWeight_);
    }

}
]]></document_content>
  </document>
  <document index="30">
    <source>marketmodels/driftcomputation/cmsmmdriftcalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 François du Vignaud
 Copyright (C) 2007 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/driftcomputation/cmsmmdriftcalculator.hpp>
#include <ql/models/marketmodels/curvestates/cmswapcurvestate.hpp>

namespace QuantLib {

    CMSMMDriftCalculator::CMSMMDriftCalculator(
                                const Matrix& pseudo,
                                const std::vector<Spread>& displacements,
                                const std::vector<Time>& taus,
                                Size numeraire,
                                Size alive,
                                Size spanningFwds)
    : numberOfRates_(taus.size()), numberOfFactors_(pseudo.columns()),
      numeraire_(numeraire), alive_(alive),
      displacements_(displacements), oneOverTaus_(taus.size()),
      pseudo_(pseudo), tmp_(taus.size(), 0.0),
      PjPnWk_(numberOfFactors_,1+taus.size()),
      wkaj_(numberOfFactors_, taus.size()),
      wkajN_(numberOfFactors_, taus.size()),
      downs_(taus.size()), ups_(taus.size()),
      spanningFwds_(spanningFwds) {

        // Check requirements
        QL_REQUIRE(numberOfRates_>0, "Dim out of range");
        QL_REQUIRE(displacements.size() == numberOfRates_,
                   "Displacements out of range");
        QL_REQUIRE(pseudo.rows()==numberOfRates_,
                   "pseudo.rows() not consistent with dim");
        QL_REQUIRE(pseudo.columns()>0 && pseudo.columns()<=numberOfRates_,
                   "pseudo.rows() not consistent with pseudo.columns()");
        QL_REQUIRE(alive<numberOfRates_,
                   "Alive out of bounds");
        QL_REQUIRE(numeraire_<=numberOfRates_,
                   "Numeraire larger than dim");
        QL_REQUIRE(numeraire_>=alive,
                   "Numeraire smaller than alive");

        // Precompute 1/taus
        for (Size i=0; i<taus.size(); ++i)
            oneOverTaus_[i] = 1.0/taus[i];

        // Compute covariance matrix from pseudoroot
        Matrix pT = transpose(pseudo_);
        C_ = pseudo_*pT;

        // Compute lower and upper extrema for (non reduced) drift calculation
        for (Size i=alive_; i<numberOfRates_; ++i) {
            downs_[i] = std::min(i+1, numeraire_);
            ups_[i]   = std::max(i+1, numeraire_);
        }
    }

    void CMSMMDriftCalculator::compute(const CMSwapCurveState& cs,
                                       std::vector<Real>& drifts) const {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(drifts.size()==cs.numberOfRates(),
                   "drifts.size() <> numberOfRates");
        #endif

        const std::vector<Time>& taus = cs.rateTaus();
        // final bond is numeraire

        // Compute cross variations
        for (Size k=0; k<PjPnWk_.rows(); ++k) {
            PjPnWk_[k][numberOfRates_]=0.0;
            wkaj_[k][numberOfRates_-1]=0.0;

            for (Integer j=static_cast<Integer>(numberOfRates_)-2;
                 j>=static_cast<Integer>(alive_)-1; --j)
            {
                Real sr = cs.cmSwapRate(j+1,spanningFwds_);
                Integer endIndex =
                    std::min<Integer>(j + static_cast<Integer>(spanningFwds_) + 1,
                             static_cast<Integer>(numberOfRates_));
                Real first = sr * wkaj_[k][j+1];
                Real second = cs.cmSwapAnnuity(numberOfRates_,j+1,spanningFwds_)
                * (sr+displacements_[j+1])
                *pseudo_[j+1][k];
                Real third = PjPnWk_[k][endIndex];
                PjPnWk_[k][j+1] = first
                + second
                + third;

                if (j>=static_cast<Integer>(alive_))
                {
                    wkaj_[k][j] = wkaj_[k][j+1] + PjPnWk_[k][j+1]*taus[j];

                    if (j+spanningFwds_+1 <= numberOfRates_)
                        wkaj_[k][j] -= PjPnWk_[k][endIndex]*taus[endIndex-1];
                }

            }
        }

        Real PnOverPN = cs.discountRatio(numberOfRates_, numeraire_);
        //Real PnOverPN = 1.0;

        for (Size j=alive_; j<numberOfRates_; ++j)
            for (Size k=0; k<numberOfFactors_; ++k)
                wkajN_[k][j] =  wkaj_[k][j]*PnOverPN
                    -PjPnWk_[k][numeraire_]*PnOverPN*cs.cmSwapAnnuity(numeraire_,j,spanningFwds_);



        for (Size j=alive_; j<numberOfRates_; ++j)
        {
            drifts[j]=0.0;
            for (Size k=0; k<numberOfFactors_; ++k)
            {
                drifts[j] += pseudo_[j][k]*wkajN_[k][j];
            }
            drifts[j] /= -cs.cmSwapAnnuity(numeraire_,j,spanningFwds_);
        }
    }

}
]]></document_content>
  </document>
  <document index="31">
    <source>marketmodels/driftcomputation/lmmdriftcalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2006 Marco Bianchetti
 Copyright (C) 2006 Silvia Frasson
 Copyright (C) 2006 Mario Pucci
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/driftcomputation/lmmdriftcalculator.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>

namespace QuantLib {

    LMMDriftCalculator::LMMDriftCalculator(const Matrix& pseudo,
                                           const std::vector<Spread>& displacements,
                                           const std::vector<Time>& taus,
                                           Size numeraire,
                                           Size alive)
    : numberOfRates_(taus.size()), numberOfFactors_(pseudo.columns()),
      isFullFactor_(numberOfFactors_ == numberOfRates_), numeraire_(numeraire), alive_(alive),
      displacements_(displacements), oneOverTaus_(taus.size()), pseudo_(pseudo),
      tmp_(taus.size(), 0.0), e_(pseudo_.columns(), pseudo_.rows(), 0.0), downs_(taus.size()),
      ups_(taus.size()) {

        // Check requirements
        QL_REQUIRE(numberOfRates_>0, "Dim out of range");
        QL_REQUIRE(displacements.size() == numberOfRates_,
            "Displacements out of range");
        QL_REQUIRE(pseudo.rows()==numberOfRates_,
            "pseudo.rows() not consistent with dim");
        QL_REQUIRE(pseudo.columns()>0 && pseudo.columns()<=numberOfRates_,
            "pseudo.rows() not consistent with pseudo.columns()");
        QL_REQUIRE(alive<numberOfRates_, "Alive out of bounds");
        QL_REQUIRE(numeraire_<=numberOfRates_, "Numeraire larger than dim");
        QL_REQUIRE(numeraire_>=alive, "Numeraire smaller than alive");

        // Precompute 1/taus
        for (Size i=0; i<taus.size(); ++i)
            oneOverTaus_[i] = 1.0/taus[i];

        // Compute covariance matrix from pseudoroot
        Matrix pT = transpose(pseudo_);
        C_ = pseudo_*pT;

        // Compute lower and upper extrema for (non reduced) drift calculation
        for (Size i=alive_; i<numberOfRates_; ++i) {
            downs_[i] = std::min(i+1, numeraire_);
            ups_[i]   = std::max(i+1, numeraire_);
        }
    }

    void LMMDriftCalculator::compute(const LMMCurveState& cs,
                                     std::vector<Real>& drifts) const {
        compute(cs.forwardRates(), drifts);
    }

    void LMMDriftCalculator::compute(const std::vector<Rate>& fwds,
                                     std::vector<Real>& drifts) const {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
            QL_REQUIRE(fwds.size()==numberOfRates_, "numberOfRates <> dim");
            QL_REQUIRE(drifts.size()==numberOfRates_, "drifts.size() <> dim");
        #endif

        if (isFullFactor_)
            computePlain(fwds, drifts);
        else
            computeReduced(fwds, drifts);
    }

    void LMMDriftCalculator::computePlain(const LMMCurveState& cs,
                                          std::vector<Real>& drifts) const {
        computePlain(cs.forwardRates(), drifts);
    }

    void LMMDriftCalculator::computePlain(const std::vector<Rate>& forwards,
                                          std::vector<Real>& drifts) const {

        // Compute drifts without factor reduction,
        // using directly the covariance matrix.

        // Precompute forwards factor
        Size i;
        for(i=alive_; i<numberOfRates_; ++i)
            tmp_[i] = (forwards[i]+displacements_[i]) /
                      (oneOverTaus_[i]+forwards[i]);

        // Compute drifts
        for (i=alive_; i<numberOfRates_; ++i) {
            drifts[i] = std::inner_product(tmp_.begin()+downs_[i],
                                           tmp_.begin()+ups_[i],
                                           C_.row_begin(i)+downs_[i], Real(0.0));
            if (numeraire_>i+1)
                drifts[i] = -drifts[i];
        }
    }

    void LMMDriftCalculator::computeReduced(const LMMCurveState& cs,
                                            std::vector<Real>& drifts) const {
        computeReduced(cs.forwardRates(), drifts);
    }

    void LMMDriftCalculator::computeReduced(const std::vector<Rate>& forwards,
                                            std::vector<Real>& drifts) const {

        // Compute drifts with factor reduction,
        // using the pseudo square root of the covariance matrix.

        // Precompute forwards factor
        for (Size i=alive_; i<numberOfRates_; ++i)
            tmp_[i] = (forwards[i]+displacements_[i]) /
                (oneOverTaus_[i]+forwards[i]);

        // Enforce initialization
        for (Size r=0; r<numberOfFactors_; ++r)
            e_[r][std::max(0,static_cast<Integer>(numeraire_)-1)] = 0.0;

        // Now compute drifts: take the numeraire P_N (numeraire_=N)
        // as the reference point, divide the summation into 3 steps,
        // et impera:

        // 1st step: the drift corresponding to the numeraire P_N is zero.
        // (if N=0 no drift is null, if N=numberOfRates_ the last drift is null).
        if (numeraire_>0) drifts[numeraire_-1] = 0.0;

        // 2nd step: then, move backward from N-2 (included) back to
        // alive (included) (if N=0 jumps to 3rd step, if N=numberOfRates_ the
        // e_[r][N-1] are correctly initialized):

        for (Integer i=static_cast<Integer>(numeraire_)-2;
             i>=static_cast<Integer>(alive_); --i) {
            drifts[i] = 0.0;
            for (Size r=0; r<numberOfFactors_; ++r) {
                e_[r][i] = e_[r][i+1] + tmp_[i+1] * pseudo_[i+1][r];
                drifts[i] -= e_[r][i]*pseudo_[i][r];
            }

            /*
            Matrix::column_iterator p1 = e_.column_begin(i);
            Matrix::column_iterator end = e_.column_end(i);
            Matrix::const_column_iterator p2 = e_.column_begin(i+1);
            Matrix::const_row_iterator q1 = pseudo_.row_begin(i);
            Matrix::const_row_iterator q2 = pseudo_.row_begin(i+1);
            Real x = tmp_[i+1];
            while (p1 != end) {
                *p1 = *p2 + x*(*q2);
                drifts[i] -= *p1*(*q1);
                ++p1; ++p2; ++q1; ++q2;
            }
            */
        }

        // 3rd step: now, move forward from N (included) up to n (excluded)
        // (if N=0 this is the only relevant computation):
        for (Size i=numeraire_; i<numberOfRates_; ++i) {
            drifts[i] = 0.0;
            for (Size r=0; r<numberOfFactors_; ++r) {
                if (i==0)
                    e_[r][i] = tmp_[i] * pseudo_[i][r];
                else
                    e_[r][i] = e_[r][i-1] + tmp_[i] * pseudo_[i][r];
                drifts[i] += e_[r][i]*pseudo_[i][r];
            }
        }
    }

}
]]></document_content>
  </document>
  <document index="32">
    <source>marketmodels/driftcomputation/lmmnormaldriftcalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
  Copyright (C) 2007 Giorgio Facchinetti
  Copyright (C) 2007 Chiara Fornarola

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/driftcomputation/lmmnormaldriftcalculator.hpp>

namespace QuantLib {

    LMMNormalDriftCalculator::LMMNormalDriftCalculator(const Matrix& pseudo,
                                                       const std::vector<Time>& taus,
                                                       Size numeraire,
                                                       Size alive)
    : numberOfRates_(taus.size()), numberOfFactors_(pseudo.columns()),
      isFullFactor_(numberOfFactors_ == numberOfRates_), numeraire_(numeraire), alive_(alive),
      oneOverTaus_(taus.size()), pseudo_(pseudo), tmp_(taus.size(), 0.0),
      e_(pseudo_.columns(), pseudo_.rows(), 0.0), downs_(taus.size()), ups_(taus.size()) {

        // Check requirements
        QL_REQUIRE(numberOfRates_>0, "Dim out of range");
        QL_REQUIRE(pseudo.rows()==numberOfRates_,
            "pseudo.rows() not consistent with dim");
        QL_REQUIRE(pseudo.columns()>0 && pseudo.columns()<=numberOfRates_,
            "pseudo.rows() not consistent with pseudo.columns()");
        QL_REQUIRE(alive<numberOfRates_, "Alive out of bounds");
        QL_REQUIRE(numeraire_<=numberOfRates_, "Numeraire larger than dim");
        QL_REQUIRE(numeraire_>=alive, "Numeraire smaller than alive");

        // Precompute 1/taus
        for (Size i=0; i<taus.size(); ++i)
            oneOverTaus_[i] = 1.0/taus[i];

        // Compute covariance matrix from pseudoroot
        Matrix pT = transpose(pseudo_);
        C_ = pseudo_*pT;

        // Compute lower and upper extrema for (non reduced) drift calculation
        for (Size i=alive_; i<numberOfRates_; ++i) {
            downs_[i] = std::min(i+1, numeraire_);
            ups_[i]   = std::max(i+1, numeraire_);
        }
    }

    void LMMNormalDriftCalculator::compute(const LMMCurveState& cs,
                                           std::vector<Real>& drifts) const {
        compute(cs.forwardRates(), drifts);
    }

    void LMMNormalDriftCalculator::compute(const std::vector<Rate>& fwds,
                                           std::vector<Real>& drifts) const {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
            QL_REQUIRE(fwds.size()==numberOfRates_, "numberOfRates <> dim");
            QL_REQUIRE(drifts.size()==numberOfRates_, "drifts.size() <> dim");
        #endif

        if (isFullFactor_)
            computePlain(fwds, drifts);
        else
            computeReduced(fwds, drifts);
    }

    void LMMNormalDriftCalculator::computePlain(const LMMCurveState& cs,
                                                std::vector<Real>& drifts) const {
        computePlain(cs.forwardRates(), drifts);
    }

    void LMMNormalDriftCalculator::computePlain(const std::vector<Rate>& forwards,
                                                std::vector<Real>& drifts) const {

        // Compute drifts without factor reduction,
        // using directly the covariance matrix.

        // Precompute forwards factor
        Size i;
        for(i=alive_; i<numberOfRates_; ++i)
            tmp_[i] = 1.0/(oneOverTaus_[i]+forwards[i]);

        // Compute drifts
        for (i=alive_; i<numberOfRates_; ++i) {
            drifts[i] = std::inner_product(tmp_.begin()+downs_[i],
                                           tmp_.begin()+ups_[i],
                                           C_.row_begin(i)+downs_[i], Real(0.0));
            if (numeraire_>i+1)
                drifts[i] = -drifts[i];
        }
    }

    void LMMNormalDriftCalculator::computeReduced(const LMMCurveState& cs,
                                                std::vector<Real>& drifts) const {
        computeReduced(cs.forwardRates(), drifts);
    }

    void LMMNormalDriftCalculator::computeReduced(const std::vector<Rate>& forwards,
                                                  std::vector<Real>& drifts) const {

        // Compute drifts with factor reduction,
        // using the pseudo square root of the covariance matrix.

        // Precompute forwards factor
        for (Size i=alive_; i<numberOfRates_; ++i)
            tmp_[i] = 1.0/(oneOverTaus_[i]+forwards[i]);

        // Enforce initialization
        for (Size r=0; r<numberOfFactors_; ++r)
            e_[r][std::max(0,static_cast<Integer>(numeraire_)-1)] = 0.0;

        // Now compute drifts: take the numeraire P_N (numeraire_=N)
        // as the reference point, divide the summation into 3 steps,
        // et impera:

        // 1st step: the drift corresponding to the numeraire P_N is zero.
        // (if N=0 no drift is null, if N=numberOfRates_ the last drift is null).
        if (numeraire_>0) drifts[numeraire_-1] = 0.0;

        // 2nd step: then, move backward from N-2 (included) back to
        // alive (included) (if N=0 jumps to 3rd step, if N=numberOfRates_ the
        // e_[r][N-1] are correctly initialized):

        for (Integer i=static_cast<Integer>(numeraire_)-2;
             i>=static_cast<Integer>(alive_); --i) {
            drifts[i] = 0.0;
            for (Size r=0; r<numberOfFactors_; ++r) {
                e_[r][i] = e_[r][i+1] + tmp_[i+1] * pseudo_[i+1][r];
                drifts[i] -= e_[r][i]*pseudo_[i][r];
            }

        }

        // 3rd step: now, move forward from N (included) up to n (excluded)
        // (if N=0 this is the only relevant computation):
        for (Size i=numeraire_; i<numberOfRates_; ++i) {
            drifts[i] = 0.0;
            for (Size r=0; r<numberOfFactors_; ++r) {
                if (i==0)
                    e_[r][i] = tmp_[i] * pseudo_[i][r];
                else
                    e_[r][i] = e_[r][i-1] + tmp_[i] * pseudo_[i][r];
                drifts[i] += e_[r][i]*pseudo_[i][r];
            }
        }
    }

}
]]></document_content>
  </document>
  <document index="33">
    <source>marketmodels/driftcomputation/smmdriftcalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/driftcomputation/smmdriftcalculator.hpp>
#include <ql/models/marketmodels/curvestates/coterminalswapcurvestate.hpp>

namespace QuantLib {

    SMMDriftCalculator::SMMDriftCalculator(
                                    const Matrix& pseudo,
                                    const std::vector<Spread>& displacements,
                                    const std::vector<Time>& taus,
                                    Size numeraire,
                                    Size alive)
    : numberOfRates_(taus.size()), numberOfFactors_(pseudo.columns()),
      numeraire_(numeraire), alive_(alive),
      displacements_(displacements), oneOverTaus_(taus.size()),
      pseudo_(pseudo),
      tmp_(taus.size(), 0.0),
      // zero initialization required for (used by) the last element
      wkaj_(pseudo_.columns(), pseudo_.rows(), 0.0),
      wkpj_(pseudo_.columns(), pseudo_.rows()+1, 0.0),
      wkajshifted_(pseudo_.columns(), pseudo_.rows(), 0.0)
      /*,
      downs_(taus.size()), ups_(taus.size())*/ {

        // Check requirements
        QL_REQUIRE(numberOfRates_>0, "Dim out of range");
        QL_REQUIRE(displacements.size() == numberOfRates_,
            "Displacements out of range");
        QL_REQUIRE(pseudo.rows()==numberOfRates_,
            "pseudo.rows() not consistent with dim");
        QL_REQUIRE(pseudo.columns()>0 && pseudo.columns()<=numberOfRates_,
            "pseudo.rows() not consistent with pseudo.columns()");
        QL_REQUIRE(alive<numberOfRates_, "Alive out of bounds");
        QL_REQUIRE(numeraire_<=numberOfRates_, "Numeraire larger than dim");
        QL_REQUIRE(numeraire_>=alive, "Numeraire smaller than alive");

        // Precompute 1/taus
        for (Size i=0; i<taus.size(); ++i)
            oneOverTaus_[i] = 1.0/taus[i];

        // Compute covariance matrix from pseudoroot
        Matrix pT = transpose(pseudo_);
        C_ = pseudo_*pT;

        // Compute lower and upper extrema for (non reduced) drift calculation
        //for (Size i=alive_; i<numberOfRates_; ++i) {
        //    downs_[i] = std::min(i+1, numeraire_);
        //    ups_[i]   = std::max(i+1, numeraire_);
        //}
    }

    void SMMDriftCalculator::compute(const CoterminalSwapCurveState& cs,
                                     std::vector<Real>& drifts) const {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(drifts.size()==cs.numberOfRates(),
                   "drifts.size() <> numberOfRates");
        #endif

        // Compute drifts with factor reduction,
        // using the pseudo square root of the covariance matrix.

        const std::vector<Rate>& SR=cs.coterminalSwapRates();
        // calculates and stores wkaj_, wkpj1_
        // assuming terminal bond measure
        // eq 5.4-5.7
        const std::vector<Time>& taus=cs.rateTaus();
        std::vector<Real> annuities(numberOfRates_);

        for (Size j=0; j<numberOfRates_; ++j) {
            annuities[j] = cs.coterminalSwapAnnuity(numberOfRates_, j);
        }
        for (Size k=0; k<numberOfFactors_; ++k) {
                // taken care in the constructor
                // wkpj1_[k][numberOfRates_-1]= 0.0;
                // wkaj_[k][numberOfRates_-1] = 0.0;
            for (Integer j=numberOfRates_-2; j>=static_cast<Integer>(alive_)-1; --j) {
                 // < W(k) | P(j+1)/P(n) > =
                 // = SR(j+1) a(j+1,k) A(j+1) / P(n) + SR(j+1) < W(k) | A(j+1)/P(n) >
                Real annuity = annuities[j+1];
                wkpj_[k][j+1]= SR[j+1] *
                            ( pseudo_[j+1][k] * annuity +  wkaj_[k][j+1] )+
                            pseudo_[j+1][k]*displacements_[j+1]* annuity;

                if (j >=static_cast<Integer>(alive_))
                    wkaj_[k][j] = wkpj_[k][j+1]*taus[j ]+wkaj_[k][j+1];
            }
          }


        Real numeraireRatio = cs.discountRatio(numberOfRates_, numeraire_);

// change to work for general numeraire
        for (Size k=0; k<numberOfFactors_; ++k) {
            // compute < Wk, PN/pn>
            for (Size j=alive_; j<numberOfRates_; ++j)
            {
                wkajshifted_[k][j] = -wkaj_[k][j]/annuities[j]
                                    + wkpj_[k][numeraire_]
                                                *numeraireRatio;
            }
        }

        // eq 5.3 (in log coordinates)
        for (Size j=alive_; j<numberOfRates_; ++j) {
            drifts[j] = 0.0;
            for (Size k=0; k<numberOfFactors_; ++k) {
                drifts[j] += wkajshifted_[k][j]*pseudo_[j][k];
            }
        }

    }

}
]]></document_content>
  </document>
  <document index="34">
    <source>marketmodels/evolutiondescription.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006 Marco Bianchetti
 Copyright (C) 2006 Cristina Duminuco
 Copyright (C) 2006 Giorgio Facchinetti
 Copyright (C) 2006, 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <ql/math/matrix.hpp>
#include <ql/utilities/dataformatters.hpp>

namespace QuantLib {

    EvolutionDescription::EvolutionDescription(
                     const std::vector<Time>& rateTimes,
                     const std::vector<Time>& evolutionTimes,
                     const std::vector<std::pair<Size,Size> >& relevanceRates)
    : numberOfRates_(rateTimes.empty() ? 0 : rateTimes.size()-1),
      rateTimes_(rateTimes),
      evolutionTimes_(evolutionTimes.empty() && !rateTimes.empty() ?
                      std::vector<Time>(rateTimes.begin(), rateTimes.end()-1) :
                      evolutionTimes),
      relevanceRates_(relevanceRates),
      rateTaus_(numberOfRates_),
      //effStopTime_(evolutionTimes_.size(), rateTimes_.size()-1),
      firstAliveRate_(evolutionTimes_.size())
    {

        checkIncreasingTimesAndCalculateTaus(rateTimes_, rateTaus_);

        checkIncreasingTimes(evolutionTimes_);
        Size numberOfSteps = evolutionTimes_.size();

        QL_REQUIRE(evolutionTimes_.back()<=rateTimes[rateTimes.size()-2],
                   "The last evolution time (" << evolutionTimes_.back() <<
                   ") is past the last fixing time (" <<
                   rateTimes[numberOfRates_-2] << ")");

        if (relevanceRates.empty())
            relevanceRates_ = std::vector<std::pair<Size,Size> >(
                                numberOfSteps, std::make_pair(0,numberOfRates_));
        else
            QL_REQUIRE(relevanceRates.size() == numberOfSteps,
                       "relevanceRates / evolutionTimes mismatch");

        //for (Size j=0; j<numberOfSteps; ++j) {
        //    for (Size i=0; i<numberOfRates_; ++i)
        //        effStopTime_[j][i] =
        //            std::min(evolutionTimes_[j], rateTimes_[i]);
        //}

        Time currentEvolutionTime = 0.0;
        Size firstAliveRate = 0;
        for (Size j=0; j<numberOfSteps; ++j) {
            while (rateTimes_[firstAliveRate] <= currentEvolutionTime)
                ++firstAliveRate;
            firstAliveRate_[j] = firstAliveRate;
            currentEvolutionTime = evolutionTimes_[j];
        }
    }

    const std::vector<Time>& EvolutionDescription::rateTimes() const {
        return rateTimes_;
    }

    const std::vector<Time>& EvolutionDescription::rateTaus() const {
        return rateTaus_;
    }

    const std::vector<Time>& EvolutionDescription::evolutionTimes() const {
        return evolutionTimes_;
    }

    //const Matrix& EvolutionDescription::effectiveStopTimes() const {
    //    return effStopTime_;
    //}

    const std::vector<Size>& EvolutionDescription::firstAliveRate() const {
        return firstAliveRate_;
    }

    const std::vector<std::pair<Size,Size> >& EvolutionDescription::relevanceRates() const {
        return relevanceRates_;
    }

    Size EvolutionDescription::numberOfRates() const {
        return numberOfRates_;
    }

    Size EvolutionDescription::numberOfSteps() const {
        return evolutionTimes_.size();
    }

    void checkCompatibility(const EvolutionDescription& evolution,
                            const std::vector<Size>& numeraires)
    {
        const std::vector<Time>& evolutionTimes = evolution.evolutionTimes();
        Size n = evolutionTimes.size();
        QL_REQUIRE(numeraires.size() == n,
                   "Size mismatch between numeraires (" << numeraires.size()
                   << ") and evolution times (" << n << ")");

        const std::vector<Time>& rateTimes = evolution.rateTimes();
        for (Size i=0; i<n-1; i++)
            QL_REQUIRE(rateTimes[numeraires[i]] >= evolutionTimes[i],
                       io::ordinal(i+1) << " step, evolution time " <<
                       evolutionTimes[i] << ": the numeraire (" << numeraires[i] <<
                       "), corresponding to rate time " <<
                       rateTimes[numeraires[i]] << ", is expired");
    }

    bool isInTerminalMeasure(const EvolutionDescription& evolution,
                             const std::vector<Size>& numeraires) {
        const std::vector<Time>& rateTimes = evolution.rateTimes();
        return *std::min_element(numeraires.begin(), numeraires.end()) ==
                                                          rateTimes.size()-1;
    }

    bool isInMoneyMarketPlusMeasure(const EvolutionDescription& evolution,
                                    const std::vector<Size>& numeraires,
                                    Size offset) {
        bool res = true;
        const std::vector<Time>& rateTimes = evolution.rateTimes();
        Size maxNumeraire=rateTimes.size()-1;
        QL_REQUIRE(offset<=maxNumeraire,
                   "offset (" << offset <<
                   ") is greater than the max allowed value for numeraire ("
                   << maxNumeraire << ")");
        const std::vector<Time>& evolutionTimes = evolution.evolutionTimes();
        for (Size i=0, j=0; i<evolutionTimes.size(); ++i) {
            while (rateTimes[j] < evolutionTimes[i])
                j++;
            res = (numeraires[i] == std::min(j+offset, maxNumeraire)) && res;
        }
        return res;
    }

    bool isInMoneyMarketMeasure(const EvolutionDescription& evolution,
                                const std::vector<Size>& numeraires) {
        return isInMoneyMarketPlusMeasure(evolution, numeraires, 0);
    }

    std::vector<Size> terminalMeasure(const EvolutionDescription& evolution)
    {
        return std::vector<Size>(evolution.evolutionTimes().size(),
                                 evolution.rateTimes().size()-1);
    }

    std::vector<Size> moneyMarketPlusMeasure(const EvolutionDescription& ev,
                                             Size offset) {
        const std::vector<Time>& rateTimes = ev.rateTimes();
        Size maxNumeraire = rateTimes.size()-1;
        QL_REQUIRE(offset<=maxNumeraire,
                   "offset (" << offset <<
                   ") is greater than the max allowed value for numeraire ("
                   << maxNumeraire << ")");

        const std::vector<Time>& evolutionTimes = ev.evolutionTimes();
        Size n = evolutionTimes.size();
        std::vector<Size> numeraires(n);
        for (Size i=0, j=0; i<n; ++i) {
            while (rateTimes[j] < evolutionTimes[i])
                j++;
            numeraires[i] = std::min(j+offset, maxNumeraire);
        }
        return numeraires;
    }

    std::vector<Size> moneyMarketMeasure(const EvolutionDescription& evol) {
        return moneyMarketPlusMeasure(evol, 0);
    }

}
]]></document_content>
  </document>
  <document index="35">
    <source>marketmodels/evolvers/lognormalcmswapratepc.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006, 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/evolvers/lognormalcmswapratepc.hpp>
#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/browniangenerator.hpp>
#include <ql/models/marketmodels/driftcomputation/cmsmmdriftcalculator.hpp>

namespace QuantLib {

    LogNormalCmSwapRatePc::LogNormalCmSwapRatePc(
                           const Size spanningForwards,
                           const ext::shared_ptr<MarketModel>& marketModel,
                           const BrownianGeneratorFactory& factory,
                           const std::vector<Size>& numeraires,
                           Size initialStep)
    : spanningForwards_(spanningForwards),
      marketModel_(marketModel),
      numeraires_(numeraires),
      initialStep_(initialStep),
      numberOfRates_(marketModel->numberOfRates()),
      numberOfFactors_(marketModel_->numberOfFactors()),
      curveState_(marketModel->evolution().rateTimes(), spanningForwards),
      swapRates_(marketModel->initialRates()),
      displacements_(marketModel->displacements()),
      logSwapRates_(numberOfRates_), initialLogSwapRates_(numberOfRates_),
      drifts1_(numberOfRates_), drifts2_(numberOfRates_),
      initialDrifts_(numberOfRates_), brownians_(numberOfFactors_),
      correlatedBrownians_(numberOfRates_),
      alive_(marketModel->evolution().firstAliveRate())
    {
        checkCompatibility(marketModel->evolution(), numeraires);

        Size steps = marketModel->evolution().numberOfSteps();

        generator_ = factory.create(numberOfFactors_, steps-initialStep_);

        currentStep_ = initialStep_;

        calculators_.reserve(steps);
        fixedDrifts_.reserve(steps);
        for (Size j=0; j<steps; ++j) {
            const Matrix& A = marketModel_->pseudoRoot(j);
            calculators_.emplace_back(A, displacements_, marketModel->evolution().rateTaus(),
                                      numeraires[j], alive_[j], spanningForwards);
            std::vector<Real> fixed(numberOfRates_);
            for (Size k=0; k<numberOfRates_; ++k) {
                Real variance =
                    std::inner_product(A.row_begin(k), A.row_end(k),
                                       A.row_begin(k), Real(0.0));
                fixed[k] = -0.5*variance;
            }
            fixedDrifts_.push_back(fixed);
        }

        setCMSwapRates(marketModel_->initialRates());
    }

    const std::vector<Size>& LogNormalCmSwapRatePc::numeraires() const {
        return numeraires_;
    }

    void LogNormalCmSwapRatePc::setCMSwapRates(const std::vector<Real>& swapRates)
    {
        QL_REQUIRE(swapRates.size()==numberOfRates_,
                   "mismatch between swapRates and rateTimes");
        for (Size i=0; i<numberOfRates_; ++i)
            initialLogSwapRates_[i] = std::log(swapRates[i] +
                                               displacements_[i]);
        curveState_.setOnCMSwapRates(swapRates);
        calculators_[initialStep_].compute(curveState_, initialDrifts_);
    }

    void LogNormalCmSwapRatePc::setInitialState(const CurveState& cs) {
        const auto* cotcs = dynamic_cast<const CMSwapCurveState*>(&cs);
        const std::vector<Real>& swapRates = cotcs->cmSwapRates(spanningForwards_);
        setCMSwapRates(swapRates);
    }

    Real LogNormalCmSwapRatePc::startNewPath() {
        currentStep_ = initialStep_;
        std::copy(initialLogSwapRates_.begin(), initialLogSwapRates_.end(),
                  logSwapRates_.begin());
        return generator_->nextPath();
    }

    Real LogNormalCmSwapRatePc::advanceStep()
    {
        // we're going from T1 to T2

        // a) compute drifts D1 at T1;
        if (currentStep_ > initialStep_)
            calculators_[currentStep_].compute(curveState_, drifts1_);
        else
            std::copy(initialDrifts_.begin(), initialDrifts_.end(),
                      drifts1_.begin());

        // b) evolve forwards up to T2 using D1;
        Real weight = generator_->nextStep(brownians_);
        const Matrix& A = marketModel_->pseudoRoot(currentStep_);
        const std::vector<Real>& fixedDrift = fixedDrifts_[currentStep_];

        Size i, alive = alive_[currentStep_];
        for (i=alive; i<numberOfRates_; ++i) {
            logSwapRates_[i] += drifts1_[i] + fixedDrift[i];
            logSwapRates_[i] +=
                std::inner_product(A.row_begin(i), A.row_end(i),
                                   brownians_.begin(), Real(0.0));
            swapRates_[i] = std::exp(logSwapRates_[i]) - displacements_[i];
        }

        // intermediate curve state update
        curveState_.setOnCMSwapRates(swapRates_);

        // c) recompute drifts D2 using the predicted forwards;
        calculators_[currentStep_].compute(curveState_, drifts2_);

        // d) correct forwards using both drifts
        for (i=alive; i<numberOfRates_; ++i) {
            logSwapRates_[i] += (drifts2_[i]-drifts1_[i])/2.0;
            swapRates_[i] = std::exp(logSwapRates_[i]) - displacements_[i];
        }

        // e) update curve state
        //curveState_.setOnCMSwapRates(swapRates_, alive);
        curveState_.setOnCMSwapRates(swapRates_);

        ++currentStep_;

        return weight;
    }

    Size LogNormalCmSwapRatePc::currentStep() const {
        return currentStep_;
    }

    const CurveState& LogNormalCmSwapRatePc::currentState() const {
        return curveState_;
    }

}
]]></document_content>
  </document>
  <document index="36">
    <source>marketmodels/evolvers/lognormalcotswapratepc.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006, 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/evolvers/lognormalcotswapratepc.hpp>
#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/browniangenerator.hpp>
#include <ql/models/marketmodels/driftcomputation/smmdriftcalculator.hpp>

namespace QuantLib {

    LogNormalCotSwapRatePc::LogNormalCotSwapRatePc(
                           const ext::shared_ptr<MarketModel>& marketModel,
                           const BrownianGeneratorFactory& factory,
                           const std::vector<Size>& numeraires,
                           Size initialStep)
    : marketModel_(marketModel),
      numeraires_(numeraires),
      initialStep_(initialStep),
      numberOfRates_(marketModel->numberOfRates()),
      numberOfFactors_(marketModel_->numberOfFactors()),
      curveState_(marketModel->evolution().rateTimes()),
      swapRates_(marketModel->initialRates()),
      displacements_(marketModel->displacements()),
      logSwapRates_(numberOfRates_), initialLogSwapRates_(numberOfRates_),
      drifts1_(numberOfRates_), drifts2_(numberOfRates_),
      initialDrifts_(numberOfRates_),
      brownians_(numberOfFactors_), correlatedBrownians_(numberOfRates_),
      alive_(marketModel->evolution().firstAliveRate())
    {
        checkCompatibility(marketModel->evolution(), numeraires);

        Size steps = marketModel->evolution().numberOfSteps();

        generator_ = factory.create(numberOfFactors_, steps-initialStep_);

        currentStep_ = initialStep_;

        calculators_.reserve(steps);
        fixedDrifts_.reserve(steps);
        for (Size j=0; j<steps; ++j) {
            const Matrix& A = marketModel_->pseudoRoot(j);
            calculators_.emplace_back(A, displacements_, marketModel->evolution().rateTaus(),
                                      numeraires[j], alive_[j]);
            std::vector<Real> fixed(numberOfRates_);
            for (Size k=0; k<numberOfRates_; ++k) {
                Real variance =
                    std::inner_product(A.row_begin(k), A.row_end(k),
                                       A.row_begin(k), Real(0.0));
                fixed[k] = -0.5*variance;
            }
            fixedDrifts_.push_back(fixed);
        }

        setCoterminalSwapRates(marketModel_->initialRates());
    }

    const std::vector<Size>& LogNormalCotSwapRatePc::numeraires() const {
        return numeraires_;
    }

    void LogNormalCotSwapRatePc::setCoterminalSwapRates(const std::vector<Real>& swapRates)
    {
        QL_REQUIRE(swapRates.size()==numberOfRates_,
                   "mismatch between swapRates and rateTimes");
        for (Size i=0; i<numberOfRates_; ++i)
            initialLogSwapRates_[i] = std::log(swapRates[i] +
                                               displacements_[i]);
        curveState_.setOnCoterminalSwapRates(swapRates);
        calculators_[initialStep_].compute(curveState_, initialDrifts_);
    }

    void LogNormalCotSwapRatePc::setInitialState(const CurveState& cs) {
        // why??
        const auto* cotcs = dynamic_cast<const CoterminalSwapCurveState*>(&cs);
        const std::vector<Real>& swapRates = cotcs->coterminalSwapRates();
        setCoterminalSwapRates(swapRates);
    }

    Real LogNormalCotSwapRatePc::startNewPath() {
        currentStep_ = initialStep_;
        std::copy(initialLogSwapRates_.begin(), initialLogSwapRates_.end(),
                  logSwapRates_.begin());
        return generator_->nextPath();
    }

    Real LogNormalCotSwapRatePc::advanceStep()
    {
         //we're going from T1 to T2

        //a) compute drifts D1 at T1;
        if (currentStep_ > initialStep_)
            calculators_[currentStep_].compute(curveState_, drifts1_);
        else
            std::copy(initialDrifts_.begin(), initialDrifts_.end(),
                      drifts1_.begin());

        //b) evolve forwards up to T2 using D1;
        Real weight = generator_->nextStep(brownians_);
        const Matrix& A = marketModel_->pseudoRoot(currentStep_);
        const std::vector<Real>& fixedDrift = fixedDrifts_[currentStep_];

        Size i, alive = alive_[currentStep_];
        for (i=alive; i<numberOfRates_; ++i) {
            logSwapRates_[i] += drifts1_[i] + fixedDrift[i];
            logSwapRates_[i] +=
                std::inner_product(A.row_begin(i), A.row_end(i),
                                   brownians_.begin(), Real(0.0));
            swapRates_[i] = std::exp(logSwapRates_[i]) - displacements_[i];
        }

        // intermediate curve state update
        curveState_.setOnCoterminalSwapRates(swapRates_);

        //c) recompute drifts D2 using the predicted forwards;
        calculators_[currentStep_].compute(curveState_, drifts2_);

        //d) correct forwards using both drifts
        for (i=alive; i<numberOfRates_; ++i) {
            logSwapRates_[i] += (drifts2_[i]-drifts1_[i])/2.0;
            swapRates_[i] = std::exp(logSwapRates_[i]) - displacements_[i];
        }

        //e) update curve state
        curveState_.setOnCoterminalSwapRates(swapRates_);

        ++currentStep_;

        return weight;
    }

    Size LogNormalCotSwapRatePc::currentStep() const {
        return currentStep_;
    }

    const CurveState& LogNormalCotSwapRatePc::currentState() const {
        return curveState_;
    }

}
]]></document_content>
  </document>
  <document index="37">
    <source>marketmodels/evolvers/lognormalfwdrateballand.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Sun Xiuxin

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/evolvers/lognormalfwdrateballand.hpp>
#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/browniangenerator.hpp>
#include <ql/models/marketmodels/driftcomputation/lmmdriftcalculator.hpp>

namespace QuantLib {

    LogNormalFwdRateBalland::LogNormalFwdRateBalland(
                           const ext::shared_ptr<MarketModel>& marketModel,
                           const BrownianGeneratorFactory& factory,
                           const std::vector<Size>& numeraires,
                           Size initialStep)
    : marketModel_(marketModel),
      numeraires_(numeraires),
      initialStep_(initialStep),
      numberOfRates_(marketModel->numberOfRates()),
      numberOfFactors_(marketModel->numberOfFactors()),
      curveState_(marketModel->evolution().rateTimes()),
      forwards_(marketModel->initialRates()),
      displacements_(marketModel->displacements()),
      logForwards_(numberOfRates_), initialLogForwards_(numberOfRates_),
      drifts1_(numberOfRates_), drifts2_(numberOfRates_),
      initialDrifts_(numberOfRates_), brownians_(numberOfFactors_),
      correlatedBrownians_(numberOfRates_),
      rateTaus_(marketModel->evolution().rateTaus()),
      alive_(marketModel->evolution().firstAliveRate())
    {
        checkCompatibility(marketModel->evolution(), numeraires);

        Size steps = marketModel->evolution().numberOfSteps();

        generator_ = factory.create(numberOfFactors_, steps-initialStep_);

        currentStep_ = initialStep_;

        calculators_.reserve(steps);
        fixedDrifts_.reserve(steps);
        for (Size j=0; j<steps; ++j) {
            const Matrix& A = marketModel->pseudoRoot(j);
            calculators_.emplace_back(A, displacements_, marketModel->evolution().rateTaus(),
                                      numeraires[j], alive_[j]);
            const Matrix& C = marketModel->covariance(j);
            std::vector<Real> fixed(numberOfRates_);
            for (Size k=0; k<numberOfRates_; ++k) {
                Real variance = C[k][k];
                fixed[k] = -0.5*variance;
            }
            fixedDrifts_.push_back(fixed);
        }

        setForwards(marketModel_->initialRates());
    }

    const std::vector<Size>& LogNormalFwdRateBalland::numeraires() const {
        return numeraires_;
    }

    void LogNormalFwdRateBalland::setForwards(const std::vector<Real>& forwards)
    {
        QL_REQUIRE(forwards.size()==numberOfRates_,
                   "mismatch between forwards and rateTimes");
        for (Size i=0; i<numberOfRates_; ++i)
            initialLogForwards_[i] = std::log(forwards[i] +
                                              displacements_[i]);
        calculators_[initialStep_].compute(forwards, initialDrifts_);
    }

    void LogNormalFwdRateBalland::setInitialState(const CurveState& cs) {
        setForwards(cs.forwardRates());
    }

    Real LogNormalFwdRateBalland::startNewPath() {
        currentStep_ = initialStep_;
        std::copy(initialLogForwards_.begin(), initialLogForwards_.end(),
                  logForwards_.begin());
        return generator_->nextPath();
    }

    Real LogNormalFwdRateBalland::advanceStep()
    {
        // we're going from T1 to T2:

        // a) compute drifts D1 at T1;
        if (currentStep_ > initialStep_) {
            calculators_[currentStep_].compute(forwards_, drifts1_);
        } else {
            std::copy(initialDrifts_.begin(), initialDrifts_.end(),
                      drifts1_.begin());
        }

        Real weight = generator_->nextStep(brownians_);
        const Matrix& A = marketModel_->pseudoRoot(currentStep_);
        const std::vector<Real>& fixedDrift = fixedDrifts_[currentStep_];

        Integer alive = alive_[currentStep_];
        Size i;
        for ( i = alive; i < numberOfRates_ ; ++i )
        {
            logForwards_[i] += drifts1_[i] + fixedDrift[i];
            logForwards_[i] += std::inner_product(A.row_begin(i), A.row_end(i),
                                                  brownians_.begin(), Real(0.0));
            forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];
        }

        for ( i = alive; i < numberOfRates_ ; ++i )
        {
            forwards_[i] = std::sqrt( forwards_[i]*(marketModel_->initialRates()[i]) );
        }

        calculators_[currentStep_].compute(forwards_, drifts2_);

        for ( i = alive; i < numberOfRates_ ; ++i )
        {
            logForwards_[i] += drifts2_[i] - drifts1_[i];
            forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];
        }

        // update curve state
        curveState_.setOnForwardRates(forwards_);

        ++currentStep_;

        return weight;
    }

    Size LogNormalFwdRateBalland::currentStep() const {
        return currentStep_;
    }

    const CurveState& LogNormalFwdRateBalland::currentState() const {
        return curveState_;
    }

}
]]></document_content>
  </document>
  <document index="38">
    <source>marketmodels/evolvers/lognormalfwdrateeuler.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/evolvers/lognormalfwdrateeuler.hpp>
#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/browniangenerator.hpp>
#include <ql/models/marketmodels/driftcomputation/lmmdriftcalculator.hpp>

namespace QuantLib {

    LogNormalFwdRateEuler::LogNormalFwdRateEuler(
                           const ext::shared_ptr<MarketModel>& marketModel,
                           const BrownianGeneratorFactory& factory,
                           const std::vector<Size>& numeraires,
                           Size initialStep)
    : marketModel_(marketModel),
      numeraires_(numeraires),
      initialStep_(initialStep),
      numberOfRates_(marketModel->numberOfRates()),
      numberOfFactors_(marketModel_->numberOfFactors()),
      curveState_(marketModel->evolution().rateTimes()),
      forwards_(marketModel->initialRates()),
      displacements_(marketModel->displacements()),
      logForwards_(numberOfRates_), initialLogForwards_(numberOfRates_),
      drifts1_(numberOfRates_), initialDrifts_(numberOfRates_),
      brownians_(numberOfFactors_), correlatedBrownians_(numberOfRates_),
      alive_(marketModel->evolution().firstAliveRate())
    {
        checkCompatibility(marketModel->evolution(), numeraires);

        Size steps = marketModel->evolution().numberOfSteps();

        generator_ = factory.create(numberOfFactors_, steps-initialStep_);

        currentStep_ = initialStep_;

        calculators_.reserve(steps);
        fixedDrifts_.reserve(steps);
        for (Size j=0; j<steps; ++j) {
            const Matrix& A = marketModel_->pseudoRoot(j);
            calculators_.emplace_back(A, displacements_, marketModel->evolution().rateTaus(),
                                      numeraires[j], alive_[j]);
            std::vector<Real> fixed(numberOfRates_);
            for (Size k=0; k<numberOfRates_; ++k) {
                Real variance =
                    std::inner_product(A.row_begin(k), A.row_end(k),
                                       A.row_begin(k), Real(0.0));
                fixed[k] = -0.5*variance;
            }
            fixedDrifts_.push_back(fixed);
        }

        setForwards(marketModel_->initialRates());
    }

    const std::vector<Size>& LogNormalFwdRateEuler::numeraires() const {
        return numeraires_;
    }

    void LogNormalFwdRateEuler::setForwards(const std::vector<Real>& forwards)
    {
        QL_REQUIRE(forwards.size()==numberOfRates_,
                   "mismatch between forwards and rateTimes");
        for (Size i=0; i<numberOfRates_; ++i)
            initialLogForwards_[i] = std::log(forwards[i] +
                                              displacements_[i]);
        calculators_[initialStep_].compute(forwards, initialDrifts_);
    }

    void LogNormalFwdRateEuler::setInitialState(const CurveState& cs) {
        setForwards(cs.forwardRates());
    }

    Real LogNormalFwdRateEuler::startNewPath() {
        currentStep_ = initialStep_;
        std::copy(initialLogForwards_.begin(), initialLogForwards_.end(),
                  logForwards_.begin());
        return generator_->nextPath();
    }

    Real LogNormalFwdRateEuler::advanceStep()
    {
        // we're going from T1 to T2

        // a) compute drifts D1 at T1;
        if (currentStep_ > initialStep_) {
            calculators_[currentStep_].compute(forwards_, drifts1_);
        } else {
            std::copy(initialDrifts_.begin(), initialDrifts_.end(),
                      drifts1_.begin());
        }

        // b) evolve forwards up to T2 using D1;
        Real weight = generator_->nextStep(brownians_);
        const Matrix& A = marketModel_->pseudoRoot(currentStep_);
        const std::vector<Real>& fixedDrift = fixedDrifts_[currentStep_];

        Size alive = alive_[currentStep_];
        for (Size i=alive; i<numberOfRates_; i++) {
            logForwards_[i] += drifts1_[i] + fixedDrift[i];
            logForwards_[i] +=
                std::inner_product(A.row_begin(i), A.row_end(i),
                                   brownians_.begin(), Real(0.0));
            forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];
        }

        // same as PC evolver with two steps dropped

        // c) update curve state
        curveState_.setOnForwardRates(forwards_);

        ++currentStep_;

        return weight;
    }

    Size LogNormalFwdRateEuler::currentStep() const {
        return currentStep_;
    }

    const CurveState& LogNormalFwdRateEuler::currentState() const {
        return curveState_;
    }

}
]]></document_content>
  </document>
  <document index="39">
    <source>marketmodels/evolvers/lognormalfwdrateeulerconstrained.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2006 Ferdinando Ametrano
Copyright (C) 2006 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/evolvers/lognormalfwdrateeulerconstrained.hpp>
#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/browniangenerator.hpp>
#include <ql/models/marketmodels/driftcomputation/lmmdriftcalculator.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {


    LogNormalFwdRateEulerConstrained::LogNormalFwdRateEulerConstrained(
                        const ext::shared_ptr<MarketModel>& marketModel,
                        const BrownianGeneratorFactory& factory,
                        const std::vector<Size>& numeraires,
                        Size initialStep)
    : marketModel_(marketModel),
      numeraires_(numeraires),
      initialStep_(initialStep),
      numberOfRates_(marketModel->numberOfRates()),
      numberOfFactors_(marketModel_->numberOfFactors()),
      curveState_(marketModel->evolution().rateTimes()),
      forwards_(marketModel->initialRates()),
      displacements_(marketModel->displacements()),
      logForwards_(numberOfRates_), initialLogForwards_(numberOfRates_),
      drifts1_(numberOfRates_), initialDrifts_(numberOfRates_),
      brownians_(numberOfFactors_), correlatedBrownians_(numberOfRates_),
      alive_(marketModel->evolution().firstAliveRate())
    {
        checkCompatibility(marketModel->evolution(), numeraires);

        Size steps = marketModel->evolution().numberOfSteps();

        generator_ = factory.create(numberOfFactors_, steps-initialStep_);
        currentStep_ = initialStep_;

        calculators_.reserve(steps);
        variances_.reserve(steps);
        fixedDrifts_.reserve(steps);
        for (Size j=0; j<steps; ++j) {
            const Matrix& A = marketModel_->pseudoRoot(j);
            calculators_.emplace_back(A, displacements_, marketModel->evolution().rateTaus(),
                                      numeraires[j], alive_[j]);
            std::vector<Real> fixed(numberOfRates_);
            std::vector<Real> variances(numberOfRates_);
            for (Size k=0; k<numberOfRates_; ++k) {
                Real variance =
                    std::inner_product(A.row_begin(k), A.row_end(k),
                    A.row_begin(k), Real(0.0));
                variances[k] = variance;
                fixed[k] = -0.5*variance;
            }
            variances_.push_back(variances);
            fixedDrifts_.push_back(fixed);
        }

        setForwards(marketModel_->initialRates());
    }

    const std::vector<Size>& LogNormalFwdRateEulerConstrained::numeraires() const {
        return numeraires_;
    }

    void LogNormalFwdRateEulerConstrained::setForwards(const std::vector<Real>& forwards)
    {
        QL_REQUIRE(forwards.size()==numberOfRates_,
                   "mismatch between forwards and rateTimes");
        for (Size i=0; i<numberOfRates_; ++i)
            initialLogForwards_[i] = std::log(forwards[i] +
                                              displacements_[i]);
        calculators_[initialStep_].compute(forwards, initialDrifts_);
    }

    void LogNormalFwdRateEulerConstrained::setInitialState(const CurveState& cs) {
        setForwards(cs.forwardRates());
    }

    void LogNormalFwdRateEulerConstrained::setConstraintType(
        const std::vector<Size>& startIndexOfSwapRate,
        const std::vector<Size>& endIndexOfSwapRate)
    {
        QL_REQUIRE(startIndexOfSwapRate.size() == numeraires_.size(),
            "Size mismatch in constraint specification.");
        QL_REQUIRE(endIndexOfSwapRate.size() == numeraires_.size(), "Size mismatch in constraint specification.");

        startIndexOfSwapRate_=startIndexOfSwapRate;
        endIndexOfSwapRate_ = endIndexOfSwapRate;

        covariances_.clear();
        covariances_.reserve(startIndexOfSwapRate_.size());

        std::vector<Real> covariances(numberOfRates_);

        for (Size i=0; i < startIndexOfSwapRate_.size(); ++i) {
            QL_REQUIRE(startIndexOfSwapRate_[i]+1 == endIndexOfSwapRate_[i],
                "constrained euler currently only implemented for forward rates");

            const Matrix& A = marketModel_->pseudoRoot(currentStep_);

            for (Size j=0; j < numberOfRates_; ++j) {
                Real cov=0.0;
                for (Size k=0; k < numberOfFactors_; ++k)
                    cov += A[startIndexOfSwapRate_[i]][k]*A[j][k];
                covariances[j] = cov;

            }
            covariances_.push_back(covariances);
        }

    }

    void LogNormalFwdRateEulerConstrained::setThisConstraint(
                                const std::vector<Rate>& rateConstraints,
                                const std::valarray<bool>& isConstraintActive)
    {
        QL_REQUIRE(rateConstraints.size() == numeraires_.size(),
                   "wrong number of constraints specified");

        QL_REQUIRE(isConstraintActive.size() == numeraires_.size(),
                   "wrong number of isConstraintActive specified");

        rateConstraints_=rateConstraints;
        isConstraintActive_.resize(isConstraintActive.size());
        isConstraintActive_ = isConstraintActive;

        for (unsigned long i=0; i < rateConstraints_.size(); i++)
            rateConstraints_[i] = std::log(rateConstraints_[i]+displacements_[i]);
    }


    Real LogNormalFwdRateEulerConstrained::startNewPath() {
        currentStep_ = initialStep_;
        std::copy(initialLogForwards_.begin(), initialLogForwards_.end(),
                  logForwards_.begin());
        return generator_->nextPath();
    }

    Real LogNormalFwdRateEulerConstrained::advanceStep()
    {
        // we're going from T1 to T2

        // a) compute drifts D1 at T1;
        if (currentStep_ > initialStep_) {
            calculators_[currentStep_].compute(forwards_, drifts1_);
        } else {
            std::copy(initialDrifts_.begin(), initialDrifts_.end(),
                      drifts1_.begin());
        }

        // b) evolve forwards up to T2 using D1;
        Real weight = generator_->nextStep(brownians_);
        const Matrix& A = marketModel_->pseudoRoot(currentStep_);
        const std::vector<Real>& fixedDrift = fixedDrifts_[currentStep_];

        Size alive = alive_[currentStep_];
        for (Size i=alive; i<numberOfRates_; i++) {
            logForwards_[i] += drifts1_[i] + fixedDrift[i];
            logForwards_[i] +=
                std::inner_product(A.row_begin(i), A.row_end(i),
                brownians_.begin(), Real(0.0));
        }

        // check constraint active
        if (isConstraintActive_[currentStep_]) {
            Size index = startIndexOfSwapRate_[currentStep_];

            // compute error
            Real requiredShift =  rateConstraints_[currentStep_] - logForwards_[index];

            Real multiplier = requiredShift/variances_[currentStep_][index];

            // now shift each rate by multiplier * weighting of index rate
            // across the step
            for (Size i=alive; i<numberOfRates_; i++) {
                // we only need a small part of cov matrix
                logForwards_[i] += multiplier*covariances_[currentStep_][i];
            }

            // now we need to calculate the LR shift, we have moved Gaussian Z_k by multiplier * a_{index,k}
            // divide original density by density of shifted normal
            Real weightsEffect = 1.0;

            CumulativeNormalDistribution phi;
            for (Size k=0; k < numberOfFactors_; k++) {
                Real shift = multiplier * A[index][k];
                Real originalDensity = phi.derivative(brownians_[k]+shift);
                // the density of the draw after changes in original measure
                Real newDensity = phi.derivative(brownians_[k]);
                // the density of the draw after changes in new measure, shifts cancel
                weightsEffect*= originalDensity/newDensity;
            }

            weight *= weightsEffect;
        }

        for (Size i=alive; i<numberOfRates_; i++)
            forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];

        // c) update curve state
        curveState_.setOnForwardRates(forwards_);

        ++currentStep_;

        return weight;
    }

    Size LogNormalFwdRateEulerConstrained::currentStep() const {
        return currentStep_;
    }

    const CurveState& LogNormalFwdRateEulerConstrained::currentState() const {
        return curveState_;
    }

}
]]></document_content>
  </document>
  <document index="40">
    <source>marketmodels/evolvers/lognormalfwdrateiballand.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Sun Xiuxin

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/evolvers/lognormalfwdrateiballand.hpp>
#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/browniangenerator.hpp>
#include <ql/models/marketmodels/driftcomputation/lmmdriftcalculator.hpp>

namespace QuantLib {

    LogNormalFwdRateiBalland::LogNormalFwdRateiBalland(
                           const ext::shared_ptr<MarketModel>& marketModel,
                           const BrownianGeneratorFactory& factory,
                           const std::vector<Size>& numeraires,
                           Size initialStep)
    : marketModel_(marketModel),
      numeraires_(numeraires),
      initialStep_(initialStep),
      numberOfRates_(marketModel->numberOfRates()),
      numberOfFactors_(marketModel->numberOfFactors()),
      curveState_(marketModel->evolution().rateTimes()),
      forwards_(marketModel->initialRates()),
      displacements_(marketModel->displacements()),
      logForwards_(numberOfRates_), initialLogForwards_(numberOfRates_),
      initialDrifts_(numberOfRates_), brownians_(numberOfFactors_),
      correlatedBrownians_(numberOfRates_),
      rateTaus_(marketModel->evolution().rateTaus()),
      alive_(marketModel->evolution().firstAliveRate())
    {
        checkCompatibility(marketModel->evolution(), numeraires);
        QL_REQUIRE( isInTerminalMeasure(marketModel->evolution(), numeraires),
                    "terminal measure required for iBalland " );

        Size steps = marketModel->evolution().numberOfSteps();

        generator_ = factory.create(numberOfFactors_, steps-initialStep_);

        currentStep_ = initialStep_;

        calculators_.reserve(steps);
        fixedDrifts_.reserve(steps);
        for (Size j=0; j<steps; ++j) {
            const Matrix& A = marketModel->pseudoRoot(j);
            calculators_.emplace_back(A, displacements_, marketModel->evolution().rateTaus(),
                                      numeraires[j], alive_[j]);
            const Matrix& C = marketModel->covariance(j);
            std::vector<Real> fixed(numberOfRates_);
            for (Size k=0; k<numberOfRates_; ++k) {
                Real variance = C[k][k];
                fixed[k] = -0.5*variance;
            }
            fixedDrifts_.push_back(fixed);
        }

        setForwards(marketModel_->initialRates());
    }

    const std::vector<Size>& LogNormalFwdRateiBalland::numeraires() const {
        return numeraires_;
    }

    void LogNormalFwdRateiBalland::setForwards(const std::vector<Real>& forwards)
    {
        QL_REQUIRE(forwards.size()==numberOfRates_,
                   "mismatch between forwards and rateTimes");
        for (Size i=0; i<numberOfRates_; ++i)
            initialLogForwards_[i] = std::log(forwards[i] +
                                              displacements_[i]);
        calculators_[initialStep_].compute(forwards, initialDrifts_);
    }

    void LogNormalFwdRateiBalland::setInitialState(const CurveState& cs) {
        setForwards(cs.forwardRates());
    }

    Real LogNormalFwdRateiBalland::startNewPath() {
        currentStep_ = initialStep_;
        std::copy(initialLogForwards_.begin(), initialLogForwards_.end(),
                  logForwards_.begin());
        return generator_->nextPath();
    }

    Real LogNormalFwdRateiBalland::advanceStep()
    {
        Real weight = generator_->nextStep(brownians_);
        const Matrix& A = marketModel_->pseudoRoot(currentStep_);
        const Matrix& C = marketModel_->covariance(currentStep_);
        const std::vector<Real>& fixedDrift = fixedDrifts_[currentStep_];

        Integer alive = alive_[currentStep_];
        Integer i;
        Real blFwd;
        std::vector<Real> g_(numberOfRates_);

        i = numberOfRates_-1;
        if ( i >= alive )
        {
            logForwards_[i] += fixedDrift[i];
            logForwards_[i] += std::inner_product( A.row_begin(i), A.row_end(i),
                                                   brownians_.begin(), Real(0.0) );
            forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];
            blFwd = std::sqrt( marketModel_->initialRates()[i]*forwards_[i] );
            g_[i] = rateTaus_[i]*( blFwd+displacements_[i] )/
                    ( 1.0+rateTaus_[i]*blFwd );
        }

        Real drifts2;
        for ( i = numberOfRates_-2; i >= alive ; --i )
        {
            drifts2 = 0.0;
            for ( Size j = i+1; j < numberOfRates_ ; ++j )
                drifts2 -= g_[j]*C[i][j];
            logForwards_[i] += drifts2 + fixedDrift[i];
            logForwards_[i] += std::inner_product( A.row_begin(i), A.row_end(i),
                                                   brownians_.begin(), Real(0.0));
            forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];

            blFwd = std::sqrt( marketModel_->initialRates()[i]*forwards_[i] );
            g_[i] = rateTaus_[i]*( blFwd+displacements_[i] )/
                    ( 1.0+rateTaus_[i]*blFwd );
        }

        // update curve state
        curveState_.setOnForwardRates(forwards_);

        ++currentStep_;

        return weight;
    }

    Size LogNormalFwdRateiBalland::currentStep() const {
        return currentStep_;
    }

    const CurveState& LogNormalFwdRateiBalland::currentState() const {
        return curveState_;
    }

}
]]></document_content>
  </document>
  <document index="41">
    <source>marketmodels/evolvers/lognormalfwdrateipc.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/evolvers/lognormalfwdrateipc.hpp>
#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/browniangenerator.hpp>
#include <ql/models/marketmodels/driftcomputation/lmmdriftcalculator.hpp>

namespace QuantLib {

    LogNormalFwdRateIpc::LogNormalFwdRateIpc(
                           const ext::shared_ptr<MarketModel>& marketModel,
                           const BrownianGeneratorFactory& factory,
                           const std::vector<Size>& numeraires,
                           Size initialStep)
    : marketModel_(marketModel),
      numeraires_(numeraires),
      initialStep_(initialStep),
      numberOfRates_(marketModel->numberOfRates()),
      numberOfFactors_(marketModel->numberOfFactors()),
      curveState_(marketModel->evolution().rateTimes()),
      forwards_(marketModel->initialRates()),
      displacements_(marketModel->displacements()),
      logForwards_(numberOfRates_), initialLogForwards_(numberOfRates_),
      drifts1_(numberOfRates_), initialDrifts_(numberOfRates_),
      g_(numberOfRates_), brownians_(numberOfFactors_),
      correlatedBrownians_(numberOfRates_),
      rateTaus_(marketModel->evolution().rateTaus()),
      alive_(marketModel->evolution().firstAliveRate())
    {
        checkCompatibility(marketModel->evolution(), numeraires);
        QL_REQUIRE(isInTerminalMeasure(marketModel->evolution(), numeraires),
                   "terminal measure required for ipc ");

        Size steps = marketModel->evolution().numberOfSteps();

        generator_ = factory.create(numberOfFactors_, steps-initialStep_);

        currentStep_ = initialStep_;

        calculators_.reserve(steps);
        fixedDrifts_.reserve(steps);
        for (Size j=0; j<steps; ++j) {
            const Matrix& A = marketModel->pseudoRoot(j);
            calculators_.emplace_back(A, displacements_, marketModel->evolution().rateTaus(),
                                      numeraires[j], alive_[j]);
            const Matrix& C = marketModel->covariance(j);
            std::vector<Real> fixed(numberOfRates_);
            for (Size k=0; k<numberOfRates_; ++k) {
                Real variance = C[k][k];
                fixed[k] = -0.5*variance;
            }
            fixedDrifts_.push_back(fixed);
        }

        setForwards(marketModel_->initialRates());
    }

    const std::vector<Size>& LogNormalFwdRateIpc::numeraires() const {
        return numeraires_;
    }

    void LogNormalFwdRateIpc::setForwards(const std::vector<Real>& forwards)
    {
        QL_REQUIRE(forwards.size()==numberOfRates_,
                   "mismatch between forwards and rateTimes");
        for (Size i=0; i<numberOfRates_; ++i)
            initialLogForwards_[i] = std::log(forwards[i] +
                                              displacements_[i]);
        calculators_[initialStep_].compute(forwards, initialDrifts_);
    }

    void LogNormalFwdRateIpc::setInitialState(const CurveState& cs) {
        setForwards(cs.forwardRates());
    }

    Real LogNormalFwdRateIpc::startNewPath() {
        currentStep_ = initialStep_;
        std::copy(initialLogForwards_.begin(), initialLogForwards_.end(),
                  logForwards_.begin());
        return generator_->nextPath();
    }

    Real LogNormalFwdRateIpc::advanceStep()
    {
        // we're going from T1 to T2:

        // a) compute drifts D1 at T1;
        if (currentStep_ > initialStep_) {
            calculators_[currentStep_].computePlain(forwards_, drifts1_);
        } else {
            std::copy(initialDrifts_.begin(), initialDrifts_.end(),
                      drifts1_.begin());
        }

        Real weight = generator_->nextStep(brownians_);
        const Matrix& A = marketModel_->pseudoRoot(currentStep_);
        const Matrix& C = marketModel_->covariance(currentStep_);
        const std::vector<Real>& fixedDrift = fixedDrifts_[currentStep_];

        Integer alive = alive_[currentStep_];
        Real drifts2;
        for (Integer i=numberOfRates_-1; i>=alive; --i) {
            drifts2 = 0.0;
            for (Size j=i+1; j<numberOfRates_; ++j) {
                drifts2 -= g_[j]*C[i][j];
            }
            logForwards_[i] += 0.5*(drifts1_[i]+drifts2) + fixedDrift[i];
            logForwards_[i] +=
                std::inner_product(A.row_begin(i), A.row_end(i),
                                   brownians_.begin(), Real(0.0));
            forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];
            g_[i] = rateTaus_[i]*(forwards_[i]+displacements_[i])/
                (1.0+rateTaus_[i]*forwards_[i]);
        }

        // update curve state
        curveState_.setOnForwardRates(forwards_);

        ++currentStep_;

        return weight;
    }

    Size LogNormalFwdRateIpc::currentStep() const {
        return currentStep_;
    }

    const CurveState& LogNormalFwdRateIpc::currentState() const {
        return curveState_;
    }

}
]]></document_content>
  </document>
  <document index="42">
    <source>marketmodels/evolvers/lognormalfwdratepc.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/evolvers/lognormalfwdratepc.hpp>
#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/browniangenerator.hpp>
#include <ql/models/marketmodels/driftcomputation/lmmdriftcalculator.hpp>

namespace QuantLib {

    LogNormalFwdRatePc::LogNormalFwdRatePc(
                           const ext::shared_ptr<MarketModel>& marketModel,
                           const BrownianGeneratorFactory& factory,
                           const std::vector<Size>& numeraires,
                           Size initialStep)
    : marketModel_(marketModel),
      numeraires_(numeraires),
      initialStep_(initialStep),
      numberOfRates_(marketModel->numberOfRates()),
      numberOfFactors_(marketModel_->numberOfFactors()),
      curveState_(marketModel->evolution().rateTimes()),
      forwards_(marketModel->initialRates()),
      displacements_(marketModel->displacements()),
      logForwards_(numberOfRates_), initialLogForwards_(numberOfRates_),
      drifts1_(numberOfRates_), drifts2_(numberOfRates_),
      initialDrifts_(numberOfRates_), brownians_(numberOfFactors_),
      correlatedBrownians_(numberOfRates_),
      alive_(marketModel->evolution().firstAliveRate())
    {
        checkCompatibility(marketModel->evolution(), numeraires);

        Size steps = marketModel->evolution().numberOfSteps();

        generator_ = factory.create(numberOfFactors_, steps-initialStep_);

        currentStep_ = initialStep_;

        calculators_.reserve(steps);
        fixedDrifts_.reserve(steps);
        for (Size j=0; j<steps; ++j) {
            const Matrix& A = marketModel_->pseudoRoot(j);
            calculators_.emplace_back(A, displacements_, marketModel->evolution().rateTaus(),
                                      numeraires[j], alive_[j]);
            std::vector<Real> fixed(numberOfRates_);
            for (Size k=0; k<numberOfRates_; ++k) {
                Real variance =
                    std::inner_product(A.row_begin(k), A.row_end(k),
                                       A.row_begin(k), Real(0.0));
                fixed[k] = -0.5*variance;
            }
            fixedDrifts_.push_back(fixed);
        }

        setForwards(marketModel_->initialRates());
    }

    const std::vector<Size>& LogNormalFwdRatePc::numeraires() const {
        return numeraires_;
    }

    void LogNormalFwdRatePc::setForwards(const std::vector<Real>& forwards)
    {
        QL_REQUIRE(forwards.size()==numberOfRates_,
                   "mismatch between forwards and rateTimes");
        for (Size i=0; i<numberOfRates_; ++i)
             initialLogForwards_[i] = std::log(forwards[i] +
                                               displacements_[i]);
        calculators_[initialStep_].compute(forwards, initialDrifts_);
    }

    void LogNormalFwdRatePc::setInitialState(const CurveState& cs) {
        setForwards(cs.forwardRates());
    }

    Real LogNormalFwdRatePc::startNewPath() {
        currentStep_ = initialStep_;
        std::copy(initialLogForwards_.begin(), initialLogForwards_.end(),
                  logForwards_.begin());
        return generator_->nextPath();
    }

    Real LogNormalFwdRatePc::advanceStep()
    {
        // we're going from T1 to T2

        // a) compute drifts D1 at T1;
        if (currentStep_ > initialStep_) {
            calculators_[currentStep_].compute(forwards_, drifts1_);
        } else {
            std::copy(initialDrifts_.begin(), initialDrifts_.end(),
                      drifts1_.begin());
        }

        // b) evolve forwards up to T2 using D1;
        Real weight = generator_->nextStep(brownians_);
        const Matrix& A = marketModel_->pseudoRoot(currentStep_);
        const std::vector<Real>& fixedDrift = fixedDrifts_[currentStep_];

        Size i, alive = alive_[currentStep_];
        for (i=alive; i<numberOfRates_; ++i) {
            logForwards_[i] += drifts1_[i] + fixedDrift[i];
            logForwards_[i] +=
                std::inner_product(A.row_begin(i), A.row_end(i),
                                   brownians_.begin(), Real(0.0));
            forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];
        }

        // c) recompute drifts D2 using the predicted forwards;
        calculators_[currentStep_].compute(forwards_, drifts2_);

        // d) correct forwards using both drifts
        for (i=alive; i<numberOfRates_; ++i) {
            logForwards_[i] += (drifts2_[i]-drifts1_[i])/2.0;
            forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];
        }

        // e) update curve state
        curveState_.setOnForwardRates(forwards_);

        ++currentStep_;

        return weight;
    }

    Size LogNormalFwdRatePc::currentStep() const {
        return currentStep_;
    }

    const CurveState& LogNormalFwdRatePc::currentState() const {
        return curveState_;
    }

}
]]></document_content>
  </document>
  <document index="43">
    <source>marketmodels/evolvers/normalfwdratepc.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2007 Chiara Fornarola

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/evolvers/normalfwdratepc.hpp>
#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/browniangenerator.hpp>
#include <ql/models/marketmodels/driftcomputation/lmmnormaldriftcalculator.hpp>

namespace QuantLib {

    NormalFwdRatePc::NormalFwdRatePc(
                           const ext::shared_ptr<MarketModel>& marketModel,
                           const BrownianGeneratorFactory& factory,
                           const std::vector<Size>& numeraires,
                           Size initialStep)
    : marketModel_(marketModel),
      numeraires_(numeraires),
      initialStep_(initialStep),
      numberOfRates_(marketModel->numberOfRates()),
      numberOfFactors_(marketModel_->numberOfFactors()),
      curveState_(marketModel->evolution().rateTimes()),
      forwards_(marketModel->initialRates()),
      initialForwards_(marketModel->initialRates()),
      drifts1_(numberOfRates_), drifts2_(numberOfRates_),
      initialDrifts_(numberOfRates_), brownians_(numberOfFactors_),
      correlatedBrownians_(numberOfRates_),
      alive_(marketModel->evolution().firstAliveRate())
    {
        checkCompatibility(marketModel->evolution(), numeraires);

        Size steps = marketModel->evolution().numberOfSteps();

        generator_ = factory.create(numberOfFactors_, steps-initialStep_);

        currentStep_ = initialStep_;

        calculators_.reserve(steps);
        for (Size j=0; j<steps; ++j) {
            const Matrix& A = marketModel_->pseudoRoot(j);
            calculators_.emplace_back(A, marketModel->evolution().rateTaus(), numeraires[j],
                                      alive_[j]);
            /*
            for (Size k=0; k<numberOfRates_; ++k) {
                Real variance =
                    std::inner_product(A.row_begin(k), A.row_end(k),
                                       A.row_begin(k), 0.0);
            }
            */
        }

        setForwards(marketModel_->initialRates());
    }

    const std::vector<Size>& NormalFwdRatePc::numeraires() const {
        return numeraires_;
    }

    void NormalFwdRatePc::setForwards(const std::vector<Real>& forwards)
    {
        QL_REQUIRE(forwards.size()==numberOfRates_,
                   "mismatch between forwards and rateTimes");
        for (Size i=0; i<numberOfRates_; ++i)
        calculators_[initialStep_].compute(forwards, initialDrifts_);
    }

    void NormalFwdRatePc::setInitialState(const CurveState& cs) {
        setForwards(cs.forwardRates());
    }

    Real NormalFwdRatePc::startNewPath() {
        currentStep_ = initialStep_;
        std::copy(initialForwards_.begin(), initialForwards_.end(),
                  forwards_.begin());
        return generator_->nextPath();
    }

    Real NormalFwdRatePc::advanceStep()
    {
        // we're going from T1 to T2

        // a) compute drifts D1 at T1;
        if (currentStep_ > initialStep_) {
            calculators_[currentStep_].compute(forwards_, drifts1_);
        } else {
            std::copy(initialDrifts_.begin(), initialDrifts_.end(),
                      drifts1_.begin());
        }

        // b) evolve forwards up to T2 using D1;
        Real weight = generator_->nextStep(brownians_);
        const Matrix& A = marketModel_->pseudoRoot(currentStep_);

        Size i, alive = alive_[currentStep_];
        for (i=alive; i<numberOfRates_; ++i) {
            forwards_[i] += drifts1_[i] ;
            forwards_[i] +=
                std::inner_product(A.row_begin(i), A.row_end(i),
                                   brownians_.begin(), Real(0.0));
        }

        // c) recompute drifts D2 using the predicted forwards;
        calculators_[currentStep_].compute(forwards_, drifts2_);

        // d) correct forwards using both drifts
        for (i=alive; i<numberOfRates_; ++i) {
            forwards_[i] += (drifts2_[i]-drifts1_[i])/2.0;
        }

        // e) update curve state
        curveState_.setOnForwardRates(forwards_);

        ++currentStep_;

        return weight;
    }

    Size NormalFwdRatePc::currentStep() const {
        return currentStep_;
    }

    const CurveState& NormalFwdRatePc::currentState() const {
        return curveState_;
    }

}
]]></document_content>
  </document>
  <document index="44">
    <source>marketmodels/evolvers/svddfwdratepc.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/evolvers/svddfwdratepc.hpp>
#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/browniangenerator.hpp>
#include <ql/models/marketmodels/driftcomputation/lmmdriftcalculator.hpp>
#include <ql/models/marketmodels/evolvers/marketmodelvolprocess.hpp>

namespace QuantLib {

    SVDDFwdRatePc::SVDDFwdRatePc(const ext::shared_ptr<MarketModel>& marketModel,
                           const BrownianGeneratorFactory& factory,
                           const ext::shared_ptr<MarketModelVolProcess>& volProcess,
                           Size firstVolatilityFactor, 
                           Size volatilityFactorStep,
                           const std::vector<Size>& numeraires,
                           Size initialStep )
    : marketModel_(marketModel),
      volProcess_(volProcess),
      firstVolatilityFactor_(firstVolatilityFactor),
      volFactorsPerStep_(volProcess->variatesPerStep()),
      numeraires_(numeraires),
      initialStep_(initialStep),
      isVolVariate_(false,volProcess->variatesPerStep()+marketModel_->numberOfFactors()),
      numberOfRates_(marketModel->numberOfRates()),
      numberOfFactors_(marketModel_->numberOfFactors()),
      curveState_(marketModel->evolution().rateTimes()),
      forwards_(marketModel->initialRates()),
      displacements_(marketModel->displacements()),
      logForwards_(numberOfRates_), initialLogForwards_(numberOfRates_),
      drifts1_(numberOfRates_), drifts2_(numberOfRates_),
      initialDrifts_(numberOfRates_), allBrownians_(volProcess->variatesPerStep()+marketModel_->numberOfFactors()), 
      brownians_(numberOfFactors_),
      volBrownians_(volProcess->variatesPerStep()), 
      correlatedBrownians_(numberOfRates_),
      alive_(marketModel->evolution().firstAliveRate())
    {
        QL_REQUIRE(initialStep ==0, "initial step zero only supported currently. ");
        checkCompatibility(marketModel->evolution(), numeraires);

        Size steps = marketModel->evolution().numberOfSteps();

        generator_ = factory.create(numberOfFactors_+volFactorsPerStep_, steps-initialStep_);

        currentStep_ = initialStep_;

        calculators_.reserve(steps);
        fixedDrifts_.reserve(steps);
        for (Size j=0; j<steps; ++j) 
        {
            const Matrix& A = marketModel_->pseudoRoot(j);
            calculators_.emplace_back(A, displacements_, marketModel->evolution().rateTaus(),
                                      numeraires[j], alive_[j]);
            std::vector<Real> fixed(numberOfRates_);
            for (Size k=0; k<numberOfRates_; ++k) 
            {
                Real variance =
                    std::inner_product(A.row_begin(k), A.row_end(k),
                                       A.row_begin(k), Real(0.0));
                fixed[k] = -0.5*variance;
            }
            fixedDrifts_.push_back(fixed);
        }

        setForwards(marketModel_->initialRates());

        Size variatesPerStep = numberOfFactors_+volFactorsPerStep_;

        firstVolatilityFactor_ = std::min(firstVolatilityFactor_,variatesPerStep - volFactorsPerStep_);

        Size volIncrement = (variatesPerStep - firstVolatilityFactor_)/volFactorsPerStep_;
        
        for (Size i=0; i < volFactorsPerStep_; ++i)
            isVolVariate_[firstVolatilityFactor_+i*volIncrement] = true;
    }

    const std::vector<Size>& SVDDFwdRatePc::numeraires() const {
        return numeraires_;
    }

    void SVDDFwdRatePc::setForwards(const std::vector<Real>& forwards)
    {
        QL_REQUIRE(forwards.size()==numberOfRates_,
                   "mismatch between forwards and rateTimes");
        for (Size i=0; i<numberOfRates_; ++i)
             initialLogForwards_[i] = std::log(forwards[i] +
                                               displacements_[i]);
        calculators_[initialStep_].compute(forwards, initialDrifts_);
    }

    void SVDDFwdRatePc::setInitialState(const CurveState& cs) 
    {
        setForwards(cs.forwardRates());
    }

    Real SVDDFwdRatePc::startNewPath() 
    {
        currentStep_ = initialStep_;
        std::copy(initialLogForwards_.begin(), initialLogForwards_.end(),
                  logForwards_.begin());
        volProcess_->nextPath();
        return  generator_->nextPath();
    }

    Real SVDDFwdRatePc::advanceStep()
    {
        // we're going from T1 to T2

        // a) compute drifts D1 at T1;
        if (currentStep_ > initialStep_) 
        {
            calculators_[currentStep_].compute(forwards_, drifts1_);
        } 
        else 
        {
            std::copy(initialDrifts_.begin(), initialDrifts_.end(),
                      drifts1_.begin());
        }

        // b) evolve forwards up to T2 using D1;
        Real weight = generator_->nextStep(allBrownians_);

        // divide Brownians between vol process and forward process

        for (Size i=0, j=0, k=0; i < allBrownians_.size(); ++i)
            if ( isVolVariate_[i])
            {
                volBrownians_[j] = allBrownians_[i];
                ++j;
            }
            else
            {
                brownians_[k] = allBrownians_[i];
                ++k;
            }


        // get sd for step

        Real weight2 = volProcess_->nextstep(volBrownians_);
        Real sdMultiplier = volProcess_->stepSd();
        Real varianceMultiplier = sdMultiplier*sdMultiplier;

        const Matrix& A = marketModel_->pseudoRoot(currentStep_);
        const std::vector<Real>& fixedDrift = fixedDrifts_[currentStep_];

        Size alive = alive_[currentStep_];
        for (Size i=alive; i<numberOfRates_; ++i) {
            logForwards_[i] += varianceMultiplier*(drifts1_[i] + fixedDrift[i]);
            logForwards_[i] += sdMultiplier*
                std::inner_product(A.row_begin(i), A.row_end(i),
                                   brownians_.begin(), Real(0.0));
            forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];
        }

        // c) recompute drifts D2 using the predicted forwards;
        calculators_[currentStep_].compute(forwards_, drifts2_);

        // d) correct forwards using both drifts
        for (Size i=alive; i<numberOfRates_; ++i) {
            logForwards_[i] += varianceMultiplier*(drifts2_[i]-drifts1_[i])/2.0;
            forwards_[i] = std::exp(logForwards_[i]) - displacements_[i];
        }

        // e) update curve state
        curveState_.setOnForwardRates(forwards_);

        ++currentStep_;

        return weight*weight2;
    }

    Size SVDDFwdRatePc::currentStep() const {
        return currentStep_;
    }

    const CurveState& SVDDFwdRatePc::currentState() const {
        return curveState_;
    }

}
]]></document_content>
  </document>
  <document index="45">
    <source>marketmodels/evolvers/volprocesses/squarerootandersen.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2008 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include <ql/models/marketmodels/evolvers/volprocesses/squarerootandersen.hpp>
#include <ql/errors.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
namespace
QuantLib
{
    SquareRootAndersen::SquareRootAndersen(Real meanLevel,
        Real reversionSpeed,
        Real volVar,
        Real v0,
        const std::vector<Real>& evolutionTimes,
        Size numberSubSteps,
        Real w1,
        Real w2,
        Real cutPoint )
        :
    theta_(meanLevel),
        k_(reversionSpeed),
        epsilon_(volVar),
        v0_(v0),
        numberSubSteps_(numberSubSteps),
        dt_(evolutionTimes.size()*numberSubSteps),
        eMinuskDt_(evolutionTimes.size()*numberSubSteps),
        w1_(w1),
        w2_(w2),
        PsiC_(cutPoint),
        vPath_(evolutionTimes.size()*numberSubSteps+1),
        state_(1)
    {
        Size j=0;
        for (; j < numberSubSteps_; ++j)
            dt_[j] = evolutionTimes[0]/numberSubSteps_;

        for (Size i=1; i < evolutionTimes.size(); ++i)
        {
            Real dt = (evolutionTimes[i] - evolutionTimes[i-1])/numberSubSteps_;

            Real ekdt = std::exp(-k_*dt);
            QL_REQUIRE(dt >0.0, "Steps must be of positive size.");

            for (Size k=0; k < numberSubSteps_; ++k)
            {
                dt_[j] = dt;
                eMinuskDt_[j] = ekdt;

                ++j;
            }
        }
        vPath_[0] = v0_;
    }


    Size SquareRootAndersen::variatesPerStep()
    {
        return numberSubSteps_;
    }

    Size SquareRootAndersen::numberSteps()
    {
        return dt_.size()*numberSubSteps_;
    }

    void SquareRootAndersen::nextPath()
    {
          v_=v0_;
          currentStep_=0;
          subStep_=0;

    }

    void SquareRootAndersen::DoOneSubStep(Real& vt, Real z, Size j)
    {

        Real eminuskT = eMinuskDt_[j];
        Real m = theta_+(vt-theta_)*eminuskT;
        Real s2= vt*epsilon_*epsilon_*eminuskT*(1-eminuskT)/k_
                + theta_*epsilon_*epsilon_*(1- eminuskT)*(1- eminuskT)/(2*k_);
        Real s = std::sqrt(s2);
        Real psi = s*s/(m*m);
        if (psi<= PsiC_)
        {
            Real psiinv = 1.0/psi;
            Real b2 = 2.0*psiinv -1+std::sqrt(2*psiinv*(2*psiinv-1.0));
            Real b = std::sqrt(b2);
            Real a= m/(1+b2);
            vt= a*(b+z)*(b+z);
        }
        else
        {
            Real p = (psi-1.0)/(psi+1.0);
            Real beta = (1.0-p)/m;
            Real u = CumulativeNormalDistribution()(z);

            if (u < p)
            {
                vt=0;
                return;
            }

             vt = std::log((1.0-p)/(1.0-u))/beta;
        }

    }


    Real SquareRootAndersen::nextstep(const std::vector<Real>& variates)
    {
        for (Size j=0; j < numberSubSteps_; ++j)
        {
            DoOneSubStep(v_, variates[j], subStep_);
            ++subStep_;
            vPath_[subStep_] = v_;
        }

        ++currentStep_;

        return 1.0; // no importance sampling here
    }

    Real SquareRootAndersen::stepSd() const
    {
        QL_REQUIRE(currentStep_>0, "nextStep must be called before stepSd");
        Real stepVariance =0.0;
        Size lastStepStart = (currentStep_-1)*numberSubSteps_;
        for (Size k=0; k < numberSubSteps_; ++k)
            stepVariance += w1_*vPath_[k+lastStepStart]+w2_*vPath_[k+lastStepStart+1];

        stepVariance /= numberSubSteps_;

        return std::sqrt(stepVariance);
    }

    const std::vector<Real>& SquareRootAndersen::stateVariables() const
    {
        state_[0] = v_;
        return state_;
    }

    Size SquareRootAndersen::numberStateVariables() const
    {
        return 1;
    }

}
]]></document_content>
  </document>
  <document index="46">
    <source>marketmodels/forwardforwardmappings.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*

Copyright (C) 2007 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/forwardforwardmappings.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>
#include <vector>

namespace QuantLib {

    Matrix ForwardForwardMappings::ForwardForwardJacobian(const CurveState& cs,
                                                          Size multiplier,
                                                          Size offset) {

        Size n = cs.numberOfRates();

        QL_REQUIRE(offset < multiplier, "offset  must be less than period in"
            "  forward forward mappings");
        Size k = (n-offset)/multiplier;

        const std::vector<Time>& tau = cs.rateTaus();

        Matrix jacobian = Matrix(k, n, 0.0);

        Size m=offset;
        for (Size l=0; l < k; ++l)
            {
            Real df = cs.discountRatio(m,m+multiplier);
            Real bigTau = cs.rateTimes()[m+multiplier]
            -  cs.rateTimes()[m];

            for (Size r=0; r < multiplier; ++r, ++m)
                {
                Real value = df * tau[m]*cs.discountRatio(m+1,m)-1;
                value /= bigTau;
                jacobian[l][m]=-value;

                }
            }

        return jacobian;
    }

    Matrix ForwardForwardMappings::YMatrix(const CurveState& cs,
                                           const std::vector<Spread>& shortDisplacements,
                                           const std::vector<Spread>& longDisplacements,
                                           Size multiplier,
                                           Size offset) {
        Size n = cs.numberOfRates();

        QL_REQUIRE(offset < multiplier, "offset  must be less than period in"
            "  forward forward mappings");
        Size k = (n-offset)/multiplier;


        QL_REQUIRE(shortDisplacements.size() == n , "shortDisplacements must be of size"
            " equal to number of rates");

        QL_REQUIRE(longDisplacements.size() == k , "longDisplacements must be of size"
            " equal to (number of rates minus offset) divided by multiplier");

        Matrix jacobian(ForwardForwardJacobian(cs,multiplier,offset));

        for (Size i=0; i < k ; ++i)
            {
            Real tau = cs.rateTimes()[(i+1)*multiplier+offset]
            -  cs.rateTimes()[i*multiplier+offset];

            Real longForward = (cs.discountRatio((i+1)*multiplier+offset,i*multiplier+offset)-1.0)
                /tau;
            Real longForwardDisplaced = longForward+ longDisplacements[i];
            for (Size j=0; j < n; ++j)
                {
                Real shortForward = cs.forwardRate(j);
                Real shortForwardDisplaced = shortForward+shortDisplacements[j];
                jacobian[i][j] *= shortForwardDisplaced/longForwardDisplaced;
                }

            }

        return jacobian;
    }

    LMMCurveState ForwardForwardMappings::RestrictCurveState(const CurveState& cs,
                                                             Size multiplier,
                                                             Size offset) {
           Size n = cs.numberOfRates();

           QL_REQUIRE(offset < multiplier, "offset  must be less than period in"
           "  forward forward mappings");
           Size k = (n-offset)/multiplier;

           std::vector<Time> times(k+1);
           std::vector<DiscountFactor> discRatios(k+1);


           for (Size i=0; i < k+1; ++i)
           {
               times[i] = cs.rateTimes()[i*multiplier+offset];
               discRatios[i] = cs.discountRatio(i*multiplier+offset,0);
           }

           LMMCurveState newState(times);
           newState.setOnDiscountRatios(discRatios);
           return newState;

    }
}
]]></document_content>
  </document>
  <document index="47">
    <source>marketmodels/historicalratesanalysis.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/interestrateindex.hpp>
#include <ql/models/marketmodels/historicalratesanalysis.hpp>
#include <ql/time/calendar.hpp>
#include <utility>

namespace QuantLib {

    void historicalRatesAnalysis(
                SequenceStatistics& statistics,
                std::vector<Date>& skippedDates,
                std::vector<std::string>& skippedDatesErrorMessage,
                const Date& startDate,
                const Date& endDate,
                const Period& step,
                const std::vector<ext::shared_ptr<InterestRateIndex> >& indexes) {

        skippedDates.clear();
        skippedDatesErrorMessage.clear();

        Size nRates = indexes.size();
        statistics.reset(nRates);

        std::vector<Rate> sample(nRates);
        std::vector<Rate> prevSample(nRates);
        std::vector<Rate> sampleDiff(nRates);

        Calendar cal = indexes[0]->fixingCalendar();
        // start with a valid business date
        Date currentDate = cal.advance(startDate, 1*Days, Following);
        bool isFirst = true;
        // Loop over the historical dataset
        for (; currentDate<=endDate;
            currentDate = cal.advance(currentDate, step, Following)) {

            try {
                for (Size i=0; i<nRates; ++i) {
                    Rate fixing = indexes[i]->fixing(currentDate, false);
                    sample[i] = fixing;
                }
            } catch (std::exception& e) {
                skippedDates.push_back(currentDate);
                skippedDatesErrorMessage.emplace_back(e.what());
                continue;
            }

            // From 2nd step onwards, calculate forward rate
            // relative differences
            if (!isFirst){
                for (Size i=0; i<nRates; ++i)
                    sampleDiff[i] = sample[i]/prevSample[i] -1.0;
                // add observation
                statistics.add(sampleDiff.begin(), sampleDiff.end());
            }
            else
                isFirst = false;

            // Store last calculated forward rates
            std::swap(prevSample, sample);

        }
    }

    HistoricalRatesAnalysis::HistoricalRatesAnalysis(
        ext::shared_ptr<SequenceStatistics> stats,
        const Date& startDate,
        const Date& endDate,
        const Period& step,
        const std::vector<ext::shared_ptr<InterestRateIndex> >& indexes)
    : stats_(std::move(stats)) {
        historicalRatesAnalysis(
                    *stats_,
                    skippedDates_, skippedDatesErrorMessage_,
                    startDate, endDate, step,
                    indexes);
    }
}
]]></document_content>
  </document>
  <document index="48">
    <source>marketmodels/marketmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 François du Vignaud
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>


namespace QuantLib {

    const Matrix& MarketModel::covariance(Size i) const {
        if (covariance_.empty()) {
            covariance_.resize(numberOfSteps());
            for (Size j=0; j<numberOfSteps(); ++j)
                covariance_[j] = pseudoRoot(j) * transpose(pseudoRoot(j));
        }
        QL_REQUIRE(i<covariance_.size(),
                   "i (" << i <<
                   ") must be less than covariance_.size() (" << covariance_.size() << ")");
        return covariance_[i];
    }

    const Matrix& MarketModel::totalCovariance(Size endIndex) const {
        if (totalCovariance_.empty()) {
            totalCovariance_.resize(numberOfSteps());
            // call to covariance(0) triggers calculation, if necessary
            // while covariance_[0] would not
            totalCovariance_[0] = covariance(0);
            for (Size j=1; j<numberOfSteps(); ++j)
                totalCovariance_[j] = totalCovariance_[j-1] + covariance_[j];
        }
        QL_REQUIRE(endIndex<covariance_.size(),
                   "endIndex (" << endIndex <<
                   ") must be less than covariance_.size() (" << covariance_.size() << ")");
        return totalCovariance_[endIndex];
    }

   std::vector<Volatility> MarketModel::timeDependentVolatility(Size i) const
   {
        QL_REQUIRE(i<numberOfRates(),
                   "index (" << i << ") must less than number of rates (" <<
                   numberOfRates() << ")");
      
        std::vector<Volatility> result(numberOfSteps());
        const std::vector<Time>& evolutionTime = evolution().evolutionTimes();

        Time lastTime=0.0;
        for (Size j=0; j<numberOfSteps(); ++j) {
            Time tau = evolutionTime[j]-lastTime;
            Real thisVariance = covariance(j)[i][i];
            Real thisVol = std::sqrt(thisVariance/tau);
            result[j] = thisVol;
            lastTime =  evolutionTime[j];
        }
        return result;
   }
     
}
]]></document_content>
  </document>
  <document index="49">
    <source>marketmodels/marketmodeldifferences.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 François du Vignaud

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/piecewiseconstantcorrelation.hpp>
#include <ql/models/marketmodels/models/piecewiseconstantvariance.hpp>

namespace QuantLib {

    std::vector<Volatility> rateVolDifferences(
                                           const MarketModel& marketModel1,
                                           const MarketModel& marketModel2) {
        QL_ENSURE(marketModel1.initialRates() == marketModel2.initialRates(),
                  "initialRates do not match");
        const EvolutionDescription& evolutionDescription1
                                           = marketModel1.evolution();
        const EvolutionDescription& evolutionDescription2
                                           = marketModel2.evolution();
        QL_ENSURE(evolutionDescription1.evolutionTimes()
                  == evolutionDescription2.evolutionTimes(),
                  "Evolution times do not match");

        const Matrix& totalCovariance1
            = marketModel1.totalCovariance(marketModel1.numberOfSteps()-1);
        const Matrix& totalCovariance2
            = marketModel2.totalCovariance(marketModel2.numberOfSteps()-1);
        const std::vector<Time>& maturities =
            evolutionDescription1.evolutionTimes();

        std::vector<Volatility> result(totalCovariance1.columns());
        for (Size i=0; i<totalCovariance1.columns(); ++i) {
            Real diff = totalCovariance1[i][i]-totalCovariance2[i][i];
            result[i] = std::sqrt(diff/maturities[i]);
        }
        return result;
    }

    std::vector<Spread> rateInstVolDifferences(
                                           const MarketModel& marketModel1,
                                           const MarketModel& marketModel2,
                                           Size index) {
        QL_ENSURE(marketModel1.initialRates() == marketModel2.initialRates(),
                  "initialRates do not match");
        const EvolutionDescription& evolutionDescription1
                                           = marketModel1.evolution();
        const EvolutionDescription& evolutionDescription2
                                           = marketModel2.evolution();
        QL_ENSURE(evolutionDescription1.evolutionTimes()
                  == evolutionDescription2.evolutionTimes(),
                  "Evolution times do not match");
        QL_ENSURE(index<evolutionDescription1.numberOfSteps(),
            "the index given is greater than the number of steps");

        const std::vector<Time>& evolutionTimes
            = evolutionDescription1.evolutionTimes();
        std::vector<Spread> result(evolutionTimes.size());

        Time previousEvolutionTime = 0;
        for (Size i=0; i<evolutionTimes.size(); ++i) {
            Time currentEvolutionTime = evolutionTimes[i];
            Time dt = currentEvolutionTime - previousEvolutionTime;
            const Matrix& covariance1 = marketModel1.covariance(i);
            const Matrix& covariance2 = marketModel2.covariance(i);
            Real diff = covariance1[index][index] - covariance2[index][index];
            result[i] = std::sqrt(diff/dt);
            previousEvolutionTime = currentEvolutionTime;
        }
        return result;
    }

    std::vector<Matrix> coterminalSwapPseudoRoots(
        const PiecewiseConstantCorrelation& piecewiseConstantCorrelation,
        const std::vector<ext::shared_ptr<PiecewiseConstantVariance> >&
                                                 piecewiseConstantVariances) {
            QL_ENSURE(piecewiseConstantCorrelation.times()
                == piecewiseConstantVariances.front()->rateTimes(),
                "correlations and volatilities intertave");
            std::vector<Matrix> pseudoRoots;
            const std::vector<Time>& rateTimes
                = piecewiseConstantVariances.front()->rateTimes();
            for (Size i=1; i<rateTimes.size(); ++i) {
                Time sqrtTau = std::sqrt(rateTimes[i]-rateTimes[i-1]);
                const Matrix& correlations
                    = piecewiseConstantCorrelation.correlation(i);
                Matrix pseudoRoot(correlations.rows(), correlations.rows());
                for (Size j=0; j<correlations.rows(); ++j) {
                    Real volatility
                      = piecewiseConstantVariances[j]->volatility(i)*sqrtTau;
                    std::transform(correlations.row_begin(j),
                                   correlations.row_end(j),
                                   pseudoRoot.row_begin(j),
                                   [=](Real x) -> Real { return x * volatility; });
                }
                pseudoRoots.push_back(pseudoRoot);
            }
            return pseudoRoots;
    }

}

]]></document_content>
  </document>
  <document index="50">
    <source>marketmodels/models/abcdvol.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi
 Copyright (C) 2005, 2006 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/models/abcdvol.hpp>
#include <ql/models/marketmodels/piecewiseconstantcorrelation.hpp>
#include <ql/termstructures/volatility/abcd.hpp>
#include <ql/math/matrixutilities/pseudosqrt.hpp>

using std::vector;

namespace QuantLib {

    AbcdVol::AbcdVol(Real a,
                     Real b,
                     Real c,
                     Real d,
                     const vector<Real>& ks,
                     const ext::shared_ptr<PiecewiseConstantCorrelation>& corr,
                     const EvolutionDescription& evolution,
                     const Size numberOfFactors,
                     const vector<Rate>& initialRates,
                     const vector<Spread>& displacements)
    : numberOfFactors_(numberOfFactors),
      numberOfRates_(initialRates.size()),
      numberOfSteps_(evolution.evolutionTimes().size()),
      initialRates_(initialRates),
      displacements_(displacements),
      evolution_(evolution),
      pseudoRoots_(numberOfSteps_, Matrix(numberOfRates_, numberOfFactors_))
    {
        const vector<Time>& rateTimes = evolution.rateTimes();
        QL_REQUIRE(numberOfRates_==rateTimes.size()-1,
                   "mismatch between number of rates (" << numberOfRates_ <<
                   ") and rate times");
        QL_REQUIRE(numberOfRates_==displacements.size(),
                   "mismatch between number of rates (" << numberOfRates_ <<
                   ") and displacements (" << displacements.size() << ")");
        QL_REQUIRE(numberOfRates_==ks.size(),
                   "mismatch between number of rates (" << numberOfRates_ <<
                   ") and ks (" << ks.size() << ")");
      //  QL_REQUIRE(numberOfRates_<=numberOfFactors_*numberOfSteps_,
      //             "number of rates (" << numberOfRates_ <<
     //              ") greater than number of factors (" << numberOfFactors_
       //            << ") times number of steps (" << numberOfSteps_ << ")");
        QL_REQUIRE(numberOfFactors<=numberOfRates_,
                   "number of factors (" << numberOfFactors <<
                   ") cannot be greater than numberOfRates (" <<
                   numberOfRates_ << ")");
        QL_REQUIRE(numberOfFactors>0,
                   "number of factors (" << numberOfFactors <<
                   ") must be greater than zero");

        AbcdFunction abcd(a, b, c, d);
        Time effStopTime = 0.0;
        const vector<Time>& corrTimes = corr->times();
        const vector<Time>& evolTimes = evolution.evolutionTimes();
        Matrix covariance(numberOfRates_, numberOfRates_);
        for (Size k=0, kk=0; k<numberOfSteps_; ++k) {
            // one covariance per evolution step
            std::fill(covariance.begin(), covariance.end(), 0.0);

            // there might be more than one correlation matrix
            // in a single evolution step,
            for (; corrTimes[kk]<evolTimes[k]; ++kk) {
                Time effStartTime = effStopTime;
                effStopTime = corrTimes[kk];
                const Matrix& corrMatrix = corr->correlation(kk);
                for (Size i=0; i<numberOfRates_; ++i) {
                    for (Size j=i; j<numberOfRates_; ++j) {
                        Real cov = ks[i]*ks[j]* abcd.covariance(effStartTime,
                                                                effStopTime,
                                                                rateTimes[i],
                                                                rateTimes[j]);
                        covariance[i][j] += cov * corrMatrix[i][j];
                    }
                }
            }
            // last part in the evolution step
            Time effStartTime = effStopTime;
            effStopTime = evolTimes[k];
            const Matrix& corrMatrix = corr->correlation(kk);
            for (Size i=0; i<numberOfRates_; ++i) {
                for (Size j=i; j<numberOfRates_; ++j) {
                    Real cov = ks[i]*ks[j]* abcd.covariance(effStartTime,
                                                            effStopTime,
                                                            rateTimes[i],
                                                            rateTimes[j]);
                    covariance[i][j] += cov * corrMatrix[i][j];
                }
            }
            // no more use for the kk-th correlation matrix
            while (kk<corrTimes.size() && corrTimes[kk]<=evolTimes[k])
                ++kk;

            // make it symmetric
            for (Size i=0; i<numberOfRates_; ++i) {
                for (Size j=i+1; j<numberOfRates_; ++j) {
                     covariance[j][i] = covariance[i][j];
                 }
            }

            pseudoRoots_[k] = rankReducedSqrt(covariance,
                                              numberOfFactors, 1.0,
                                              SalvagingAlgorithm::None);

            QL_ENSURE(pseudoRoots_[k].rows()==numberOfRates_,
                      "step " << k
                      << " abcd vol wrong number of rows: "
                      << pseudoRoots_[k].rows()
                      << " instead of " << numberOfRates_);
            QL_ENSURE(pseudoRoots_[k].columns()==numberOfFactors,
                      "step " << k
                      << " abcd vol wrong number of columns: "
                      << pseudoRoots_[k].columns()
                      << " instead of " << numberOfFactors);
        }
    }

}
]]></document_content>
  </document>
  <document index="51">
    <source>marketmodels/models/alphafinder.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/quadratic.hpp>
#include <ql/models/marketmodels/models/alphafinder.hpp>
#include <utility>

namespace QuantLib {

namespace
{

    template<class T>
    Real Bisection(Real target,
                   Real low,
                   Real high,
                   Real tolerance,
                   T& theObject,
                   Real (T::*Value)(Real)) {

        Real x=0.5*(low+high);
        Real y=(theObject.*Value)(x);

        do {
            if (y < target) low = x;
            else if (y > target) high = x;

            x = 0.5*(low+high);
            y = (theObject.*Value)(x);
        } while ((std::fabs(high-low) > tolerance));

        return x;
    }

    template<class T>
    Real FindHighestOK(Real low,
                       Real high,
                       Real tolerance,
                       T& theObject,
                       bool (T::*Value)(Real)) {

        Real x=0.5*(low+high);
        bool ok=(theObject.*Value)(x);

        do {
            if (ok) low = x;
            else    high = x;

            x = 0.5*(low+high);
            ok = (theObject.*Value)(x);
        } while ((std::fabs(high-low) > tolerance));

        return x;
    }

    template<class T>
    Real FindLowestOK(Real low,
                      Real high,
                      Real tolerance,
                      T& theObject,
                      bool (T::*Value)(Real)) {

        Real x=0.5*(low+high);
        bool ok=(theObject.*Value)(x);

        do {
            if (ok) high = x;
            else    low = x;

            x = 0.5*(low+high);
            ok = (theObject.*Value)(x);
        } while ( (std::fabs(high-low) > tolerance) );

        return x;
    }


    template<class T>
    Real Minimize(Real low,
                  Real high,
                  Real tolerance,
                  T& theObject,
                  Real (T::*Value)(Real),
                  bool (T::*Condition)(Real),
                  bool& failed) {

        Real leftValue = (theObject.*Value)(low);
        Real rightValue = (theObject.*Value)(high);
        Real W = 0.5*(3.0-std::sqrt(5.0));
        Real x=W*low+(1-W)*high;
        Real midValue =  (theObject.*Value)(x);

        failed = true;

        while(high - low > tolerance) {

            if (x - low > high -x) // left interval is bigger
            {
                Real tentativeNewMid = W*low+(1-W)*x;
                Real tentativeNewMidValue =  (theObject.*Value)(tentativeNewMid);
                bool conditioner = (theObject.*Condition)(tentativeNewMidValue);
                if (!conditioner) {
                    if  ((theObject.*Condition)(x))
                        return x;
                    else
                        if (leftValue < rightValue)
                            return low;
                        else
                            return high;
                }

                if (tentativeNewMidValue < midValue) // go left
                {
                    high =x;
                    rightValue = midValue;
                    x = tentativeNewMid;
                    midValue = tentativeNewMidValue;
                }
                else // go right
                {
                    low = tentativeNewMid;
                    leftValue = tentativeNewMidValue;
                }
            }
            else
            {
                Real tentativeNewMid = W*x+(1-W)*high;
                Real tentativeNewMidValue =  (theObject.*Value)(tentativeNewMid);
                bool conditioner = (theObject.*Condition)(tentativeNewMidValue);
                if (!conditioner) {
                    if  ((theObject.*Condition)(x))
                        return x;
                    else
                        if (leftValue < rightValue)
                            return low;
                        else
                            return high;
                }

                if (tentativeNewMidValue < midValue) // go right
                {
                    low =x;
                    leftValue = midValue;
                    x = tentativeNewMid;
                    midValue = tentativeNewMidValue;
                }
                else // go left
                {
                    high = tentativeNewMid;
                    rightValue = tentativeNewMidValue;
                }
            }




            }
        failed = false;
        return x;
    }
}

AlphaFinder::AlphaFinder(ext::shared_ptr<AlphaForm> parametricform)
: parametricform_(std::move(parametricform)) {}


Real AlphaFinder::computeLinearPart(Real alpha) {
    Real cov = 0.0;
    parametricform_->setAlpha(alpha);

    for (Integer i = 0; i < stepindex_ + 1; ++i) {
        Real vol1 = ratetwohomogeneousvols_[i] * (*parametricform_)(i);
        cov += vol1 * rateonevols_[i] * correlations_[i];
    }

    cov *= 2 * w0_ * w1_;
    return cov;
    }


    Real AlphaFinder::computeQuadraticPart(Real alpha) {
        Real var =0.0;
        parametricform_->setAlpha(alpha);

        for (Integer i=0; i < stepindex_+1; ++i) {
            Real vol = ratetwohomogeneousvols_[i]*(*parametricform_)(i);
            var+= vol*vol;
        }

        var *= w1_*w1_;
        return var;
    }

    Real AlphaFinder::homogeneityfailure(Real alpha) {
        Real dum1, dum2, dum3;
        finalPart(alpha,
                  stepindex_,
                  ratetwohomogeneousvols_,
                  computeQuadraticPart(alpha),
                  computeLinearPart(alpha),
                  constantPart_,
                  dum1,
                  dum2,
                  dum3,
                  putativevols_);

    Real result=0.0;
    for (Size i=0; i<=static_cast<Size>(stepindex_)+1; ++i) {
        Real val =  putativevols_[i]-ratetwohomogeneousvols_[i];
        result +=val*val;
    }

    return result;
}

    bool AlphaFinder::finalPart(Real alphaFound,
                                Integer stepindex,
                                const std::vector<Volatility>& ratetwohomogeneousvols,
                                Real quadraticPart,
                                Real linearPart,
                                Real constantPart,
                                Real& alpha,
                                Real& a,
                                Real& b,
                                std::vector<Volatility>& ratetwovols) {
            alpha = alphaFound;
            quadratic q2(quadraticPart, linearPart, constantPart-targetVariance_ );
            parametricform_->setAlpha(alpha);
            Real y; // dummy
            q2.roots(a,y);

            Real varSoFar=0.0;
            for (Integer i =0; i < stepindex+1; ++i) {
                ratetwovols[i] = ratetwohomogeneousvols[i] *
                                            (*parametricform_)(i) * a;
                varSoFar += ratetwovols[i]* ratetwovols[i];
            }

            Real VarToFind = totalVar_-varSoFar;
            if (VarToFind < 0)
                return false;
            Real requiredSd = std::sqrt(VarToFind);
            b = requiredSd / (ratetwohomogeneousvols[stepindex+1] *
                                            (*parametricform_)(stepindex));
            ratetwovols[stepindex+1] = requiredSd;
            return true;
    }

    Real AlphaFinder::valueAtTurningPoint(Real alpha) {

        linearPart_ = computeLinearPart(alpha);
        quadraticPart_ = computeQuadraticPart(alpha);

        quadratic q(quadraticPart_, linearPart_, constantPart_);
        Real valueAtTP =q.valueAtTurningPoint();
        return valueAtTP;
    }

    Real AlphaFinder::minusValueAtTurningPoint(Real alpha) {
        return -valueAtTurningPoint(alpha);
    }

    bool AlphaFinder::testIfSolutionExists(Real alpha) {
        bool aExists =  valueAtTurningPoint(alpha)<targetVariance_;
        if (!aExists)
            return false;

        Real dum1, dum2, dum3;
        return finalPart(alpha,
                         stepindex_,
                         ratetwohomogeneousvols_,
                         computeQuadraticPart(alpha),
                         computeLinearPart(alpha),
                         constantPart_,
                         dum1,
                         dum2,
                         dum3,
                         putativevols_);
    }

    bool AlphaFinder::solve(Real alpha0,
                            Integer stepindex, // caplet index
                            const std::vector<Volatility>& rateonevols,
                            const std::vector<Volatility>& ratetwohomogeneousvols,
                            const std::vector<Real>& correlations,
                            Real w0,
                            Real w1,
                            Real targetVariance,
                            Real tolerance,
                            Real alphaMax,
                            Real alphaMin,
                            Integer steps,
                            Real& alpha,
                            Real& a,
                            Real& b,
                            std::vector<Volatility>& ratetwovols) {
        stepindex_=stepindex;
        rateonevols_=rateonevols;
        ratetwohomogeneousvols_=ratetwohomogeneousvols;
        correlations_=correlations;
        w0_=w0;
        w1_=w1;
        totalVar_=0;
        for (Size i=0; i <=static_cast<Size>(stepindex)+1; ++i)
            totalVar_+=ratetwohomogeneousvols[i]*ratetwohomogeneousvols[i];
        targetVariance_ = targetVariance;

        // constant part will not depend on alpha

        constantPart_ =0.0;
        for (Integer i=0; i < stepindex+1; ++i)
                constantPart_+=rateonevols[i]*rateonevols[i];

        constantPart_ *= w0*w0;

        // compute linear part with initial alpha
        Real valueAtTP = valueAtTurningPoint(alpha0);

        if (valueAtTP <= targetVariance) {
            finalPart(alpha0,
                      stepindex,
                      ratetwohomogeneousvols,
                      quadraticPart_,
                      linearPart_,
                      constantPart_,
                      alpha,
                      a,
                      b,
                      ratetwovols);
            return true;
        }

        // we now have to solve
        Real bottomValue = valueAtTurningPoint(alphaMin);
        Real bottomAlpha = alphaMin;
        Real topValue = valueAtTurningPoint(alphaMax);
        Real topAlpha = alphaMax;
        Real bilimit = alpha0;

        if (bottomValue > targetVariance && topValue > targetVariance) {
            // see if if ok at some intermediate point by stepping through
            Integer i=1;
            while ( i < steps && topValue> targetVariance) {
                topAlpha = alpha0 + (alphaMax-alpha0)*(i+0.0)/(steps+0.0);
                topValue=valueAtTurningPoint(topAlpha);
                ++i;
            }

            if (topValue <= targetVariance)
                bilimit = alpha0 + (topAlpha-alpha0)*(i-2.0)/(steps+0.0);
        }

        if (bottomValue > targetVariance && topValue > targetVariance) {
            // see if if ok at some intermediate point by stepping through
            Integer i=1;
            while ( i < steps && topValue> targetVariance) {
                bottomAlpha = alpha0 + (alphaMin-alpha0)*(i+0.0)/(steps+0.0);
                bottomValue=valueAtTurningPoint(bottomAlpha);
                ++i;
            }

            if (bottomValue <= targetVariance)
                bilimit = alpha0 +(bottomAlpha-alpha0)*(i-2.0)/(steps+0.0);
        }

        if (bottomValue > targetVariance && topValue > targetVariance)
            return false;

        if (bottomValue <= targetVariance) {
            // then find root of increasing function
            // (or as if increasing function)
            alpha = Bisection<AlphaFinder>(
                                           targetVariance,
                                           bottomAlpha,
                                           bilimit,
                                           tolerance,
                                           *this,
                                           &AlphaFinder::valueAtTurningPoint);
        } else {
            // find root of decreasing function (or as if decreasing function)
            alpha=Bisection<AlphaFinder>(
                                         -targetVariance,
                                         bilimit,
                                         topAlpha,
                                         tolerance,
                                         *this,
                                         &AlphaFinder::minusValueAtTurningPoint);
        }
        finalPart(alpha,
                  stepindex,
                  ratetwohomogeneousvols,
                  quadraticPart_,
                  linearPart_,
                  constantPart_,
                  alpha,
                  a,
                  b,
                  ratetwovols);
        return true;
    }

    bool AlphaFinder::solveWithMaxHomogeneity(
                        Real alpha0,
                        Integer stepindex, // caplet index
                        const std::vector<Volatility>& rateonevols,
                        const std::vector<Volatility>& ratetwohomogeneousvols,
                        const std::vector<Real>& correlations,
                        Real w0,
                        Real w1,
                        Real targetVariance,
                        Real tolerance,
                        Real alphaMax,
                        Real alphaMin,
                        Integer steps,
                        Real& alpha,
                        Real& a,
                        Real& b,
                        std::vector<Volatility>& ratetwovols) {

        stepindex_=stepindex;
        rateonevols_=rateonevols;
        ratetwohomogeneousvols_=ratetwohomogeneousvols;
        putativevols_.resize(ratetwohomogeneousvols_.size());
        correlations_=correlations;
        w0_=w0;
        w1_=w1;
        totalVar_=0;
        for (Size i=0; i <=static_cast<Size>(stepindex)+1; ++i)
            totalVar_+=ratetwohomogeneousvols[i]*ratetwohomogeneousvols[i];
        targetVariance_=targetVariance;

        // constant part will not depend on alpha

        constantPart_ =0.0;
        for (Integer i=0; i < stepindex+1; ++i)
            constantPart_+=rateonevols[i]*rateonevols[i];

        constantPart_ *= w0*w0;

        Real alpha1 = alphaMin;
        Real alpha2 = alphaMax;

        // compute linear part with initial alpha
        bool alpha0OK = testIfSolutionExists(alpha0);
        bool alphaMaxOK = testIfSolutionExists(alphaMax);
        bool alphaMinOK = testIfSolutionExists(alphaMin);

        bool foundOKPoint = alpha0OK || alphaMaxOK || alphaMinOK;

        if (foundOKPoint) {
            if (!alphaMinOK) {
                // lower alpha is bad
                if (alpha0OK) {
                    // must die somewhere in between
                    alpha1 = FindLowestOK<AlphaFinder>(
                         alphaMin,
                         alpha0,
                         tolerance,
                        *this,
                         &AlphaFinder::testIfSolutionExists);
                } else {
                    // alphaMaxOK must be true to get here
                    alpha1 = FindLowestOK<AlphaFinder>(
                         alpha0,
                         alphaMax,
                         tolerance,
                        *this,
                         &AlphaFinder::testIfSolutionExists);
                }
            }


            if (!alphaMaxOK) {
                // higher alpha is bad
                alpha2 = FindHighestOK<AlphaFinder>(
                     alpha1,
                     alphaMax,
                     tolerance,
                     *this,
                     &AlphaFinder::testIfSolutionExists);
            } else
                alpha2= alphaMax;
            }
        else {
            // ok let's see if we can find a value of alpha that works
            bool foundUpOK = false;
            bool foundDownOK = false;
            Real alphaUp = alpha0, alphaDown = alpha0;
            Real stepSize = (alphaMax-alpha0)/steps;

            for (Size j=0;
                 j<static_cast<Size>(steps) && !foundUpOK && !foundDownOK;
                 ++j) {
                alphaUp = alpha0+j*stepSize;
                foundUpOK=testIfSolutionExists(alphaUp);
                alphaDown = alpha0-j*stepSize;
                foundDownOK=testIfSolutionExists(alphaDown);
            }
            foundOKPoint = foundUpOK || foundDownOK;
            if (!foundOKPoint)
                return false;

            if (foundUpOK) {
                alpha1 = alphaUp;
                alpha2 = FindHighestOK<AlphaFinder>(
                     alpha1,
                     alphaMax,
                     tolerance,
                     *this,
                     &AlphaFinder::testIfSolutionExists);
            } else {
                alpha2 = alphaDown;
                alpha1 = FindLowestOK<AlphaFinder>(
                     alphaMin,
                     alpha2,
                     tolerance,
                    *this,
                     &AlphaFinder::testIfSolutionExists);
            }
        }

        // we have now found alpha1, alpha2 such that solution exists
        // at endpoints. we now want to minimize within that interval
        bool failed;
        alpha =  Minimize<AlphaFinder>(
                                        alpha1,
                                        alpha2,
                                        tolerance,
                                        *this,
                                        &AlphaFinder::homogeneityfailure,
                                        &AlphaFinder::testIfSolutionExists,
                                        failed) ;

        finalPart(alpha,
                  stepindex,
                  ratetwohomogeneousvols,
                  computeQuadraticPart(alpha),
                  computeLinearPart(alpha),
                  constantPart_,
                  alpha,
                  a,
                  b,
                  ratetwovols);

        return true;;
    }
}
]]></document_content>
  </document>
  <document index="52">
    <source>marketmodels/models/alphaformconcrete.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/models/alphaformconcrete.hpp>
#include <cmath>
#include <utility>

namespace QuantLib {

    AlphaFormInverseLinear::AlphaFormInverseLinear(std::vector<Time> times, Real alpha)
    : times_(std::move(times)), alpha_(alpha) {}

    Real AlphaFormInverseLinear::operator()(Integer i) const {
        return 1.0/(1.0+alpha_*times_[i]);
    }

    void AlphaFormInverseLinear::setAlpha(Real alpha) {
        alpha_=alpha;
    }


    AlphaFormLinearHyperbolic::AlphaFormLinearHyperbolic(std::vector<Time> times, Real alpha)
    : times_(std::move(times)), alpha_(alpha) {}

    Real AlphaFormLinearHyperbolic::operator()(Integer i) const {
        Real at = alpha_*times_[i];
        Real res = std::atan(at)-0.5*M_PI;
        res *= at;
        res += 1.0;
        res =std::sqrt(res);
        return res;
    }

    void AlphaFormLinearHyperbolic::setAlpha(Real alpha) {
        alpha_ = alpha;
    }

}
]]></document_content>
  </document>
  <document index="53">
    <source>marketmodels/models/capletcoterminalalphacalibration.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/matrixutilities/pseudosqrt.hpp>
#include <ql/models/marketmodels/models/alphafinder.hpp>
#include <ql/models/marketmodels/models/alphaformconcrete.hpp>
#include <ql/models/marketmodels/models/capletcoterminalalphacalibration.hpp>
#include <ql/models/marketmodels/models/piecewiseconstantvariance.hpp>
#include <ql/models/marketmodels/swapforwardmappings.hpp>
#include <utility>

namespace QuantLib {

    CTSMMCapletAlphaFormCalibration::CTSMMCapletAlphaFormCalibration(
        const EvolutionDescription& evolution,
        const ext::shared_ptr<PiecewiseConstantCorrelation>& corr,
        const std::vector<ext::shared_ptr<PiecewiseConstantVariance> >& displacedSwapVariances,
        const std::vector<Volatility>& mktCapletVols,
        const ext::shared_ptr<CurveState>& cs,
        Spread displacement,
        const std::vector<Real>& alphaInitial,
        const std::vector<Real>& alphaMax,
        const std::vector<Real>& alphaMin,
        bool maximizeHomogeneity,
        ext::shared_ptr<AlphaForm> parametricForm)
    : CTSMMCapletCalibration(
          evolution, corr, displacedSwapVariances, mktCapletVols, cs, displacement),
      alphaInitial_(alphaInitial), alphaMax_(alphaMax), alphaMin_(alphaMin),
      maximizeHomogeneity_(maximizeHomogeneity), parametricForm_(std::move(parametricForm)),
      alpha_(numberOfRates_), a_(numberOfRates_), b_(numberOfRates_) {
        if (!parametricForm_)
            parametricForm_ =
                ext::shared_ptr<AlphaForm>(new AlphaFormLinearHyperbolic(evolution.rateTimes()));

        QL_REQUIRE(numberOfRates_==alphaInitial.size(),
            "mismatch between number of rates (" << numberOfRates_ <<
            ") and alphaInitial (" << alphaInitial.size() << ")");

        QL_REQUIRE(numberOfRates_==alphaMax.size(),
            "mismatch between number of rates (" << numberOfRates_ <<
            ") and alphaMax (" << alphaMax.size() << ")");

        QL_REQUIRE(numberOfRates_==alphaMin.size(),
            "mismatch between number of rates (" << numberOfRates_ <<
            ") and alphaMin (" << alphaMin.size() << ")");
    }

    Natural CTSMMCapletAlphaFormCalibration::capletAlphaFormCalibration(
        const EvolutionDescription& evolution,
        const PiecewiseConstantCorrelation& corr,
        const std::vector<ext::shared_ptr<PiecewiseConstantVariance> >& displacedSwapVariances,
        const std::vector<Volatility>& capletVols,
        const CurveState& cs,
        const Spread displacement,

        const std::vector<Real>& alphaInitial,
        const std::vector<Real>& alphaMax,
        const std::vector<Real>& alphaMin,
        bool maximizeHomogeneity,
        const ext::shared_ptr<AlphaForm>& parametricForm,

        const Size numberOfFactors,
        Integer maxIterations,
        Real tolerance,

        std::vector<Real>& alpha,
        std::vector<Real>& a,
        std::vector<Real>& b,

        std::vector<Matrix>& swapCovariancePseudoRoots) {

        CTSMMCapletCalibration::performChecks(evolution, corr,
            displacedSwapVariances, capletVols, cs);

        Size numberOfSteps = evolution.numberOfSteps();
        Size numberOfRates = evolution.numberOfRates();
        const std::vector<Time>& rateTimes = evolution.rateTimes();

        QL_REQUIRE(numberOfFactors<=numberOfRates,
                   "number of factors (" << numberOfFactors <<
                   ") cannot be greater than numberOfRates (" <<
                   numberOfRates << ")");
        QL_REQUIRE(numberOfFactors>0,
                   "number of factors (" << numberOfFactors <<
                   ") must be greater than zero");

        Natural failures=0;

        alpha.resize(numberOfRates);
        a.resize(numberOfRates);
        b.resize(numberOfRates);

        // factor reduction
        std::vector<Matrix> corrPseudo(corr.times().size());
        for (Size i=0; i<corrPseudo.size(); ++i)
            corrPseudo[i] = rankReducedSqrt(corr.correlation(i),
                                            numberOfFactors, 1.0,
                                            SalvagingAlgorithm::None);

        // get Zinverse, we can get wj later
        Matrix zedMatrix =
            SwapForwardMappings::coterminalSwapZedMatrix(cs, displacement);
        Matrix invertedZedMatrix = inverse(zedMatrix);

        // vectors for new vol
        std::vector<std::vector<Volatility> > newVols;
        std::vector<Volatility> theseNewVols(numberOfRates);
        std::vector<Volatility> firstRateVols(numberOfRates);
        firstRateVols[0] = std::sqrt(displacedSwapVariances[0]->variances()[0]);
        std::vector<Volatility> secondRateVols(numberOfRates);
        std::vector<Real> correlations(numberOfRates);
        newVols.push_back(firstRateVols);


        alpha[0] = alphaInitial[0]; // has no effect on anything in any case
        a[0] = b[0] = 1.0; // no modifications to swap vol for first rate

        AlphaFinder solver(parametricForm);

        // final caplet and swaption are the same, so we skip that case
        for (Size i=0; i<numberOfRates-1; ++i) {
            // we will calibrate caplet on forward rate i,
            // we will do this by modifying the vol of swap rate i+1
            const std::vector<Real>& var =
                                    displacedSwapVariances[i+1]->variances();
            for (Size j =0; j < i+2; ++j)
                secondRateVols[j] = std::sqrt(var[j]);

            for (Size k=0; k < i+1; k++) {
                Real correlation=0.0;
                for (Size l=0; l < numberOfFactors; ++l) {
                    Real term1 = corrPseudo[k][i][l];
                    Real term2 = corrPseudo[k][i+1][l];
                    correlation += term1*term2;
                }
                correlations[k] = correlation;
            }

            Real w0 = invertedZedMatrix[i][i];
            Real w1 = invertedZedMatrix[i][i+1];
            // w0 adjustment
            for (Size k = i+2; k <invertedZedMatrix.columns(); ++k)
                w0+= invertedZedMatrix[i][k];

            Real targetVariance= capletVols[i]*capletVols[i]*rateTimes[i];

            bool success;
            if (maximizeHomogeneity)
                success = solver.solveWithMaxHomogeneity(
                                                    alphaInitial[i+1] ,
                                                    i,
                                                    firstRateVols,
                                                    secondRateVols,
                                                    correlations,
                                                    w0,
                                                    w1,
                                                    targetVariance,
                                                    tolerance,
                                                    alphaMax[i+1],
                                                    alphaMin[i+1],
                                                    maxIterations,
                                                    alpha[i+1],
                                                    a[i+1],
                                                    b[i+1],
                                                    theseNewVols);
            else
                success = solver.solve(alphaInitial[i+1] ,
                                       i,
                                       firstRateVols,
                                       secondRateVols,
                                       correlations,
                                       w0,
                                       w1,
                                       targetVariance,
                                       tolerance,
                                       alphaMax[i+1],
                                       alphaMin[i+1],
                                       maxIterations,
                                       alpha[i+1],
                                       a[i+1],
                                       b[i+1],
                                       theseNewVols);

            if (!success) {
                //++failures;
                QL_FAIL("alpha form failure");
            }

            newVols.push_back(theseNewVols);
            firstRateVols = theseNewVols;
        }

        swapCovariancePseudoRoots.resize(numberOfSteps);
        for (Size k=0; k<numberOfSteps; ++k) {
            swapCovariancePseudoRoots[k] = corrPseudo[k];
            for (Size j=0; j<numberOfRates; ++j) {
                Real coeff =newVols[j][k];
                for (Size i=0; i<numberOfFactors; ++i)
                    swapCovariancePseudoRoots[k][j][i]*=coeff;
            }
            QL_ENSURE(swapCovariancePseudoRoots[k].rows()==numberOfRates,
                "step " << k
                << " abcd vol wrong number of rows: "
                << swapCovariancePseudoRoots[k].rows()
                << " instead of " << numberOfRates);
            QL_ENSURE(swapCovariancePseudoRoots[k].columns()==numberOfFactors,
                "step " << k
                << " abcd vol wrong number of columns: "
                << swapCovariancePseudoRoots[k].columns()
                << " instead of " << numberOfFactors);
        }

        return failures;
    }

    Natural CTSMMCapletAlphaFormCalibration::calibrationImpl_(
                                Natural numberOfFactors,
                                Natural maxIterations,
                                Real tolerance) {

        return capletAlphaFormCalibration(evolution_,
                                          *corr_,
                                          displacedSwapVariances_,
                                          // not mktCapletVols_ but...
                                          usedCapletVols_,
                                          *cs_,
                                          displacement_,

                                          alphaInitial_,
                                          alphaMax_,
                                          alphaMin_,
                                          maximizeHomogeneity_,
                                          parametricForm_,

                                          numberOfFactors,
                                          maxIterations,
                                          tolerance,

                                          alpha_,
                                          a_,
                                          b_,

                                          swapCovariancePseudoRoots_);
    }
}
]]></document_content>
  </document>
  <document index="54">
    <source>marketmodels/models/capletcoterminalmaxhomogeneity.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2007 Ferdinando Ametrano
Copyright (C) 2007 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/models/capletcoterminalmaxhomogeneity.hpp>
#include <ql/models/marketmodels/models/piecewiseconstantvariance.hpp>
#include <ql/models/marketmodels/swapforwardmappings.hpp>
#include <ql/math/matrixutilities/pseudosqrt.hpp>
#include <ql/math/matrixutilities/basisincompleteordered.hpp>
#include <ql/math/optimization/spherecylinder.hpp>
#include <ql/math/quadratic.hpp>

namespace QuantLib {

    namespace {

        bool singleRateClosestPointFinder(
            Size capletNumber,
            const std::vector<Volatility>& homogeneousSolution,
            const std::vector<Volatility>& previousRateSolution,
            Real capletVariance,
            const std::vector<Real>& correlations,
            Real w0,
            Real w1,
            Real capletSwaptionPriority,
            Size maxIterations,
            Real tolerance,
            std::vector<Volatility>& solution,
            Real finalWeight,
            Real& swaptionError,
            Real& capletError)
        {
            if (capletNumber ==0) // there only is one point so to go through everything would be silly
            {
                Real previousSwapVariance = previousRateSolution[0] *previousRateSolution[0];
                Real thisSwapVariance = homogeneousSolution[0] *homogeneousSolution[0]
                + homogeneousSolution[1] *homogeneousSolution[1];
                Real crossTerm =  2*w0*w1*correlations[0]*previousRateSolution[0];
                Real constantTerm = w0*w0* previousSwapVariance - capletVariance;
                Real theta = w1*w1;

                quadratic q(theta,crossTerm, constantTerm);
                Real volminus, volplus;
                bool capSuccess = q.roots(volminus,volplus);
                Real residual = thisSwapVariance - volminus*volminus;
                bool swapSuccess = residual >=0;
                bool success = capSuccess && swapSuccess;

                if (success)
                {
                    solution[0]  = volminus;
                    solution[1]  = std::sqrt(residual);
                    swaptionError= 0.0;
                    capletError =0.0;
                    return success;
                }

                bool prioritizeCaplet = capletSwaptionPriority <0.5;

                if (capSuccess && prioritizeCaplet)
                {
                    solution[0]  =  volminus;
                    solution[1]  =  0; // residual is negative or we'd have totally succeeded
                    swaptionError =  std::sqrt(thisSwapVariance)-volminus;
                    capletError =0.0;
                    return success;
                }

                if (capSuccess && !prioritizeCaplet)
                {
                    solution[0] = std::sqrt(thisSwapVariance);
                    solution[1] = 0.0;
                    swaptionError=0.0;
                    capletError= std::sqrt(q(solution[0])+capletVariance) - std::sqrt(capletVariance);
                    return success;
                }


                // ok caplets have failed
                if (swapSuccess)
                {
                    solution[0]  = volminus;
                    solution[1]  = std::sqrt(residual);
                    swaptionError= 0.0;
                    capletError= std::sqrt(q(solution[0])+capletVariance) - std::sqrt(capletVariance);
                    return success;
                }

                // ok caplets have failed and swaps fail with optimal caplet solution

                if (prioritizeCaplet)
                {
                    solution[0]  = volminus; 
                    solution[1]  =  0; // residual is negative or we'd have totally succeeded
                    swaptionError =  std::sqrt(thisSwapVariance)-volminus;
                    capletError =0.0;
  
                }
                else
                {
                    solution[0] = std::sqrt(thisSwapVariance);
                    solution[1] = 0.0;
                    swaptionError=0.0;
                    capletError= std::sqrt(q(solution[0])+capletVariance) - std::sqrt(capletVariance);


                }


                return success;
            }

            // first get in correct format
            Real previousSwapVariance=0.0;
            Real thisSwapVariance =0.0;
            {
                Size i=0;
                for (; i<capletNumber+1; ++i) {
                    previousSwapVariance += previousRateSolution[i] *
                        previousRateSolution[i];
                    thisSwapVariance += homogeneousSolution[i] *
                        homogeneousSolution[i];
                }
                thisSwapVariance+= homogeneousSolution[i]*homogeneousSolution[i];
            }

            Real theta = w1*w1;
            std::vector<Real> b(capletNumber+1);
            Array cylinderCentre(capletNumber+1);
            Array targetArray(capletNumber+2);
            Array targetArrayRestricted(capletNumber+1);


            Real bsq = 0.0;
            for (Size i=0; i<capletNumber+1; ++i) {
                b[i] = 2*w0*w1*correlations[i]*previousRateSolution[i]/theta;
                cylinderCentre[i] = -0.5*b[i];
                targetArray[i] = homogeneousSolution[i];
                targetArrayRestricted[i] = targetArray[i];
                bsq+=b[i]*b[i];
            }
            targetArray[capletNumber+1] = homogeneousSolution[capletNumber+1];

            Real A = previousSwapVariance*w0*w0/theta;
            Real constQuadraticTerm = A - 0.25*bsq;
            Real S2 = capletVariance/theta - constQuadraticTerm;

            // if S2 < 0, there are no solutions so we take the best we can. 
            Real S = S2 > 0 ? Real(std::sqrt(S2)) : 0;

            Real R = std::sqrt(thisSwapVariance);

            BasisIncompleteOrdered basis(capletNumber+1);
            basis.addVector(cylinderCentre);
            basis.addVector(targetArrayRestricted);
            for (Size i=0; i<capletNumber+1; ++i) {
                Array ei(capletNumber+1,0.0);
                ei[i]=1.0;
                basis.addVector(ei);
            }

            Matrix orthTransformationRestricted(basis.getBasisAsRowsInMatrix());
            Matrix orthTransformation(capletNumber+2, capletNumber+2, 0.0);

            orthTransformation[capletNumber+1][capletNumber+1]=1.0;
            for (Size k=0; k<capletNumber+1; ++k)
                for (Size l=0; l<capletNumber+1; ++l)
                    orthTransformation[k][l]=orthTransformationRestricted[k][l];

            Array movedCentre = orthTransformationRestricted*cylinderCentre;
            Real alpha = movedCentre[0];
            Array movedTarget = orthTransformation*targetArray;

            Real Z1=0.0, Z2=0.0, Z3=0.0;

            SphereCylinderOptimizer optimizer(R, S, alpha, movedTarget[0], movedTarget[1],movedTarget[movedTarget.size()-1],finalWeight);

            bool success = false;

            if (!optimizer.isIntersectionNonEmpty())
            {
                Z1 = R*capletSwaptionPriority+(1-capletSwaptionPriority)*(alpha-S);
                Z2 = 0.0;
                Z3 = 0.0;
                swaptionError =Z1-R;
                capletError = (alpha-S)-Z1;
            }
            else
            {
                success = true;
                capletError =0.0;
                swaptionError =0.0;

                if (maxIterations > 0.0)
                {
                    optimizer.findClosest(maxIterations,
                        tolerance,
                        Z1,
                        Z2,
                        Z3);
                }
                else
                    optimizer.findByProjection(
                    Z1,
                    Z2,
                    Z3);
            }

            Array rotatedSolution(capletNumber+2,0.0);
            rotatedSolution[0] = Z1;
            rotatedSolution[1] = Z2;
            rotatedSolution[capletNumber+1] = Z3;

            Array arraySolution(transpose(orthTransformation) *
                rotatedSolution);
            {
                Size i=0;
                for (; i < arraySolution.size(); ++i)
                    solution[i]=arraySolution[i];
                for (; i < solution.size(); ++i)
                    solution[i]=0.0;
            }

            return success;

        }

    }

    CTSMMCapletMaxHomogeneityCalibration::CTSMMCapletMaxHomogeneityCalibration(
        const EvolutionDescription& evolution,
        const ext::shared_ptr<PiecewiseConstantCorrelation>& corr,
        const std::vector<ext::shared_ptr<
        PiecewiseConstantVariance> >&
        displacedSwapVariances,
        const std::vector<Volatility>& mktCapletVols,
        const ext::shared_ptr<CurveState>& cs,
        Spread displacement,
        Real caplet0Swaption1Priority)
        : CTSMMCapletCalibration(evolution, corr, displacedSwapVariances,
        mktCapletVols, cs, displacement),
        caplet0Swaption1Priority_(caplet0Swaption1Priority) {

            QL_REQUIRE(caplet0Swaption1Priority>=0.0 &&
                caplet0Swaption1Priority<=1.0,
                "caplet0Swaption1Priority (" << caplet0Swaption1Priority <<
                ") must be in [0.0, 1.0]");
    }

    // the actual calibration function, this is a static class member
    Natural CTSMMCapletMaxHomogeneityCalibration::capletMaxHomogeneityCalibration(
        const EvolutionDescription& evolution,
        const PiecewiseConstantCorrelation& corr,
        const std::vector<ext::shared_ptr<
        PiecewiseConstantVariance> >& displacedSwapVariances,
        const std::vector<Volatility>& capletVols,
        const CurveState& cs,
        const Spread displacement,
        Real caplet0Swaption1Priority, 
        const Size numberOfFactors,
        Size maxIterations,
        Real tolerance,
        Real& deformationSize,  // ret value
        Real& totalSwaptionError, // ret value
        std::vector<Matrix>& swapCovariancePseudoRoots) 
    {

            CTSMMCapletCalibration::performChecks(evolution, corr,
                displacedSwapVariances, capletVols, cs);

            Size numberOfSteps = evolution.numberOfSteps();
            Size numberOfRates = evolution.numberOfRates();
            const std::vector<Time>& rateTimes = evolution.rateTimes();

            QL_REQUIRE(numberOfFactors<=numberOfRates,
                "number of factors (" << numberOfFactors <<
                ") cannot be greater than numberOfRates (" <<
                numberOfRates << ")");
            QL_REQUIRE(numberOfFactors>0,
                "number of factors (" << numberOfFactors <<
                ") must be greater than zero");


            Natural failures=0;

            totalSwaptionError = 0.0;
            deformationSize = 0.0;

            // factor reduction
            std::vector<Matrix> corrPseudo(corr.times().size());
            for (Size i=0; i<corrPseudo.size(); ++i)
                corrPseudo[i] = rankReducedSqrt(corr.correlation(i),
                numberOfFactors, 1.0,
                SalvagingAlgorithm::None);

            // get Zinverse, we can get wj later
            Matrix zedMatrix =
                SwapForwardMappings::coterminalSwapZedMatrix(cs, displacement);
            Matrix invertedZedMatrix = inverse(zedMatrix);

            // vectors for the new vol of all swap rates
            std::vector<std::vector<Volatility> > newVols;
            std::vector<Volatility> theseNewVols(numberOfRates);
            std::vector<Volatility> firstRateVols(numberOfRates);
            firstRateVols[0] = std::sqrt(displacedSwapVariances[0]->variances()[0]);
            std::vector<Volatility> secondRateVols(numberOfRates);
            std::vector<Real> correlations(numberOfRates);
            newVols.push_back(firstRateVols);

            // final caplet and swaption are the same, so we skip that case
            for (Size i=0; i<numberOfRates-1; ++i) 
            {
                // final weight dont do anything when i < 2 
                Real thisFinalWeight = i  > 1 ? (i-1)/2.0 : 1.0;
                // we will calibrate caplet on forward rate i,
                // we will do this by modifying the vol of swap rate i+1
                const std::vector<Real>& var =
                    displacedSwapVariances[i+1]->variances();

                for (Size j =0; j < i+2; ++j)
                    secondRateVols[j] = std::sqrt(var[j]);

                for (Size k=0; k < i+1; k++) {
                    Real correlation=0.0;
                    for (Size l=0; l < numberOfFactors; ++l) {
                        Real term1 = corrPseudo[k][i][l];
                        Real term2 = corrPseudo[k][i+1][l];
                        correlation += term1*term2;
                    }
                    correlations[k] = correlation;
                }

                Real w0 = invertedZedMatrix[i][i];
                Real w1 = invertedZedMatrix[i][i+1];
                // w0 adjustment
                for (Size k = i+2; k <invertedZedMatrix.columns(); ++k)
                    w0+= invertedZedMatrix[i][k];

                Real targetCapletVariance= capletVols[i]*capletVols[i]*rateTimes[i];

                Real thisCapletError;
                Real thisSwaptionError;

                bool success = singleRateClosestPointFinder(
                    i, secondRateVols, firstRateVols, targetCapletVariance, correlations,
                    w0, w1, caplet0Swaption1Priority,maxIterations, tolerance,
                    theseNewVols, thisFinalWeight ,thisSwaptionError, thisCapletError);

                totalSwaptionError+= thisSwaptionError*thisSwaptionError;

                if (!success)
                    ++failures;

                for (Size j=0; j < i+2; ++j)
                    deformationSize += (theseNewVols[i]-secondRateVols[i])*(theseNewVols[i]-secondRateVols[i]);

                newVols.push_back(theseNewVols);
                firstRateVols = theseNewVols;
            }

            swapCovariancePseudoRoots.resize(numberOfSteps);
            for (Size k=0; k<numberOfSteps; ++k) {
                swapCovariancePseudoRoots[k] = corrPseudo[k];
                for (Size j=0; j<numberOfRates; ++j) {
                    Real coeff =newVols[j][k];
                    for (Size i=0; i<numberOfFactors; ++i)
                        swapCovariancePseudoRoots[k][j][i]*=coeff;
                }
                QL_ENSURE(swapCovariancePseudoRoots[k].rows()==numberOfRates,
                    "step " << k << " abcd vol wrong number of rows: " <<
                    swapCovariancePseudoRoots[k].rows() <<
                    " instead of " << numberOfRates);
                QL_ENSURE(swapCovariancePseudoRoots[k].columns()==numberOfFactors,
                    "step " << k << " abcd vol wrong number of columns: " <<
                    swapCovariancePseudoRoots[k].columns() <<
                    " instead of " << numberOfFactors);
            }

            return failures;
    }

    Natural CTSMMCapletMaxHomogeneityCalibration::calibrationImpl_(
        Natural numberOfFactors, 
        Natural maxIterations,
        Real tolerance) {

            return capletMaxHomogeneityCalibration(evolution_,
                *corr_,
                displacedSwapVariances_,
                // not mktCapletVols_ but...
                usedCapletVols_,
                *cs_, 
                displacement_, 

                caplet0Swaption1Priority_,

                numberOfFactors,
                maxIterations,
                tolerance,

                deformationSize_,
                totalSwaptionError_,

                swapCovariancePseudoRoots_);
    }

}
]]></document_content>
  </document>
  <document index="55">
    <source>marketmodels/models/capletcoterminalperiodic.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*

Copyright (C) 2007 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/models/capletcoterminalperiodic.hpp>
#include <ql/models/marketmodels/models/capletcoterminalmaxhomogeneity.hpp>
#include <ql/models/marketmodels/models/piecewiseconstantvariance.hpp>
#include <ql/models/marketmodels/models/volatilityinterpolationspecifier.hpp>
#include <ql/math/matrix.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/piecewiseconstantcorrelation.hpp>
#include <ql/models/marketmodels/models/pseudorootfacade.hpp>
#include <ql/models/marketmodels/models/cotswaptofwdadapter.hpp>
#include <ql/models/marketmodels/models/fwdperiodadapter.hpp>
#include <ql/models/marketmodels/models/fwdtocotswapadapter.hpp>
#include <ql/shared_ptr.hpp>
#include <vector>

namespace QuantLib
{

    // for the displaced swap

    Integer capletSwaptionPeriodicCalibration(
        const EvolutionDescription& evolution,
        const ext::shared_ptr<PiecewiseConstantCorrelation>& corr,
        VolatilityInterpolationSpecifier&
        displacedSwapVariances,
        const std::vector<Volatility>& capletVols,
        const ext::shared_ptr<CurveState>& cs,
        const Spread displacement,
        Real caplet0Swaption1Priority,
        Size numberOfFactors,
        Size period,
        Size max1dIterations,
        Real tolerance1d,
        Size maxUnperiodicIterations,
        Real toleranceUnperiodic,
        Size maxPeriodIterations,
        Real periodTolerance,
        Real& , // deformationSize used to return information, not set yet
        Real& totalSwaptionError, // ?
        std::vector<Matrix>& swapCovariancePseudoRoots,  // the thing we really want the pseudo root for each time step
        std::vector<Real> & finalScales,  //scalings used for matching
        Size& iterationsDone, // number of  period iteratations done
        Real& errorImprovement, // improvement in error for last iteration
        Matrix& modelSwaptionVolsMatrix // the swaption vols calibrated to at each step of the iteration
        )
    {

        Size numberSmallRates = evolution.numberOfRates();
        Size numberSmallSteps = evolution.numberOfSteps();

        QL_REQUIRE( numberSmallSteps == numberSmallRates,
            "periodic calibration class requires evolution to the reset of each rate");

        Size numberBigRates = numberSmallRates/period;
        Size offset = numberSmallRates % period;

        std::vector<Spread> newDisplacements(numberBigRates,displacement);

        QL_REQUIRE(displacedSwapVariances.getNoBigRates() == numberBigRates,
            "mismatch between number of swap variances given and number of rates and period");

        Integer failures=0;


        std::vector<Real> scalingFactors(numberBigRates);
        for (Size i=0; i < numberBigRates; ++i)
            scalingFactors[i] =1.0;

        displacedSwapVariances.setLastCapletVol(*capletVols.rbegin());


        std::vector<Real> marketSwaptionVols(numberBigRates);
        for (Size i=0; i < numberBigRates; ++i) {
            marketSwaptionVols[i] =
                displacedSwapVariances.originalVariances()[i]->totalVolatility(i);
        }

        std::vector<Real> modelSwaptionVols(numberBigRates);

        Real periodSwaptionRmsError;

        iterationsDone = 0;

        Real previousError = 1.0e+10; // very large number


        modelSwaptionVolsMatrix =Matrix(maxPeriodIterations,numberBigRates,0.0);


        do
        {
            displacedSwapVariances.setScalingFactors(scalingFactors);


            CTSMMCapletMaxHomogeneityCalibration unperiodicCalibrator(
                evolution,
                corr,
                displacedSwapVariances.interpolatedVariances(),
                capletVols,
                cs,
                displacement,
                caplet0Swaption1Priority);


            failures = static_cast<QuantLib::Integer>(
                unperiodicCalibrator.calibrate(numberOfFactors, maxUnperiodicIterations,
                                               toleranceUnperiodic, max1dIterations, tolerance1d));

            swapCovariancePseudoRoots = unperiodicCalibrator.swapPseudoRoots();

            ext::shared_ptr<MarketModel> smm(new
                PseudoRootFacade(swapCovariancePseudoRoots,
                evolution.rateTimes(),
                cs->coterminalSwapRates(),
                std::vector<Spread>(evolution.numberOfRates(), displacement)));

            ext::shared_ptr<MarketModel> flmm(new CotSwapToFwdAdapter(smm));

            Matrix capletTotCovariance = flmm->totalCovariance(numberSmallRates-1);

            ext::shared_ptr<MarketModel> periodflmm( new FwdPeriodAdapter(flmm, period,
                offset,
                newDisplacements));

            ext::shared_ptr<MarketModel> periodsmm(new FwdToCotSwapAdapter(periodflmm));


            Matrix swaptionTotCovariance(periodsmm->totalCovariance(periodsmm->numberOfSteps()-1));



            totalSwaptionError=0.0;

            for (Size i=0; i < numberBigRates; ++i)
            {
                modelSwaptionVols[i] = std::sqrt(swaptionTotCovariance[i][i]/periodsmm->evolution().rateTimes()[i]);
                Real scale = marketSwaptionVols[i]/modelSwaptionVols[i];
                scalingFactors[i] *= scale; // since applied to vol

                totalSwaptionError +=  (marketSwaptionVols[i]-modelSwaptionVols[i])* (marketSwaptionVols[i]-modelSwaptionVols[i]);

            }

            for (Size i=0; i < numberBigRates; ++i)
                modelSwaptionVolsMatrix[iterationsDone][i] = modelSwaptionVols[i];

            periodSwaptionRmsError = std::sqrt(totalSwaptionError/numberBigRates);
            errorImprovement = previousError -periodSwaptionRmsError;
            previousError = periodSwaptionRmsError;
        }
        while (errorImprovement> periodTolerance/10.0 && periodSwaptionRmsError >periodTolerance && ++iterationsDone < maxPeriodIterations);

        finalScales = scalingFactors;

        return failures;

    }


}
]]></document_content>
  </document>
  <document index="56">
    <source>marketmodels/models/capletcoterminalswaptioncalibration.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/models/capletcoterminalswaptioncalibration.hpp>
#include <ql/models/marketmodels/models/piecewiseconstantvariance.hpp>
#include <ql/models/marketmodels/swapforwardmappings.hpp>
#include <ql/math/matrixutilities/pseudosqrt.hpp>

namespace QuantLib {

    CTSMMCapletOriginalCalibration::CTSMMCapletOriginalCalibration(
                            const EvolutionDescription& evolution,
                            const ext::shared_ptr<PiecewiseConstantCorrelation>& corr,
                            const std::vector<ext::shared_ptr<
                                        PiecewiseConstantVariance> >&
                                                displacedSwapVariances,
                            const std::vector<Volatility>& mktCapletVols,
                            const ext::shared_ptr<CurveState>& cs,
                            Spread displacement,
                            const std::vector<Real>& alpha,
                            bool lowestRoot,
                            bool useFullApprox)
    : CTSMMCapletCalibration(evolution, corr, displacedSwapVariances,
                             mktCapletVols, cs, displacement),
      alpha_(alpha), lowestRoot_(lowestRoot),
      useFullApprox_(useFullApprox) {

        QL_REQUIRE(numberOfRates_==alpha.size(),
                   "mismatch between number of rates (" << numberOfRates_ <<
                   ") and alpha (" << alpha.size() << ")");

    }

    Natural CTSMMCapletOriginalCalibration::calibrationFunction(
                            const EvolutionDescription& evolution,
                            const PiecewiseConstantCorrelation& corr,
                            const std::vector<ext::shared_ptr<
                                PiecewiseConstantVariance> >&
                                    displacedSwapVariances,
                            const std::vector<Volatility>& capletVols,
                            const CurveState& cs,
                            Spread displacement,

                            const std::vector<Real>& alpha,
                            bool lowestRoot,
                            bool useFullApprox,

                            Size numberOfFactors,
                            //Size maxIterations,
                            //Real tolerance,

                            std::vector<Matrix>& swapCovariancePseudoRoots) {

        CTSMMCapletCalibration::performChecks(evolution, corr,
            displacedSwapVariances, capletVols, cs);

        Size numberOfSteps = evolution.numberOfSteps();
        Size numberOfRates = evolution.numberOfRates();
        const std::vector<Time>& rateTimes = evolution.rateTimes();

        QL_REQUIRE(numberOfFactors<=numberOfRates,
                   "number of factors (" << numberOfFactors <<
                   ") cannot be greater than numberOfRates (" <<
                   numberOfRates << ")");
        QL_REQUIRE(numberOfFactors>0,
                   "number of factors (" << numberOfFactors <<
                   ") must be greater than zero");

        Natural failures = 0;
        Real extraMultiplier = useFullApprox ? 1.0 : 0.0;

        // factor reduction
        std::vector<Matrix> corrPseudo(corr.times().size());
        for (Size i=0; i<corrPseudo.size(); ++i)
            corrPseudo[i] = rankReducedSqrt(corr.correlation(i),
                                            numberOfFactors, 1.0,
                                            SalvagingAlgorithm::None);

        Matrix zedMatrix =
            SwapForwardMappings::coterminalSwapZedMatrix(cs, displacement);
        Matrix invertedZedMatrix = inverse(zedMatrix);



        // do alpha part
        // first modify variances to take account of alpha
        // then rescale so total variance is unchanged
        Matrix swapTimeInhomogeneousVariances(numberOfSteps, numberOfRates, 0.0);
        std::vector<Real> originalVariances(numberOfRates, 0.0);
        std::vector<Real> modifiedVariances(numberOfRates, 0.0);
        const std::vector<Time>& evolutionTimes = evolution.evolutionTimes();
        for (Size i=0; i<numberOfSteps; ++i) {
            Real s = (i==0 ? 0.0 : evolutionTimes[i-1]);
            for (Size j=i; j<numberOfRates; ++j) {
                const std::vector<Real>& var = displacedSwapVariances[j]->variances();
                originalVariances[j]+=var[i];
                swapTimeInhomogeneousVariances[i][j] = var[i]/
                    ((1.0+alpha[j]*s)*(1.0+alpha[j]*s));
                modifiedVariances[j]+=swapTimeInhomogeneousVariances[i][j];
            }
        }

        for (Size i=0; i<numberOfSteps; ++i)
            for (Size j=i; j<numberOfRates; ++j)
                swapTimeInhomogeneousVariances[i][j] *= originalVariances[j]/
                                                        modifiedVariances[j];


        // compute swap covariances for caplet approximation formula
        // without taking into account A and B
        std::vector<Matrix> CovarianceSwapPseudos(numberOfSteps);
        std::vector<Matrix> CovarianceSwapCovs(numberOfSteps); // this is total cov
        std::vector<Matrix> CovarianceSwapMarginalCovs(numberOfSteps); // this is cov for one step

        for (Size i=0; i<numberOfSteps; ++i) {
            CovarianceSwapPseudos[i] =  corrPseudo[i];
            for (Size j=0; j<numberOfRates; ++j)
                for (Size k=0; k < CovarianceSwapPseudos[i].columns();  ++k)
                    CovarianceSwapPseudos[i][j][k] *=
                            std::sqrt(swapTimeInhomogeneousVariances[i][j]);

            CovarianceSwapMarginalCovs[i] = CovarianceSwapPseudos[i] *
                                    transpose(CovarianceSwapPseudos[i]);

            CovarianceSwapCovs[i] = CovarianceSwapMarginalCovs[i];
            if (i>0)
                CovarianceSwapCovs[i]+= CovarianceSwapCovs[i-1];
        }

        // compute partial variances and covariances which will take A and B coefficients
        //const std::vector<Time>& taus = evolution.rateTaus();
        std::vector<Real> totVariance(numberOfRates, 0.0);
        std::vector<Real> almostTotVariance(numberOfRates, 0.0);
        std::vector<Real> almostTotCovariance(numberOfRates, 0.0);
        std::vector<Real> leftCovariance(numberOfRates, 0.0);
        for (Size i=0; i<numberOfRates; ++i) {
            for (Size jj=0; jj<=i; ++jj)
                totVariance[i] += displacedSwapVariances[i]->variances()[jj];
            Integer j;
            for (j=0; j<=static_cast<Integer>(i)-1; ++j)
                almostTotVariance[i] += swapTimeInhomogeneousVariances[j][i];
            for (j=0; j<=static_cast<Integer>(i)-2; ++j) {
                const Matrix& thisPseudo = corrPseudo[j];
                Real correlation = 0.0;
                for (Size k=0; k<numberOfFactors; ++k)
                    correlation += thisPseudo[i-1][k]*thisPseudo[i][k];
                almostTotCovariance[i] += correlation *
                    std::sqrt(swapTimeInhomogeneousVariances[j][i] *
                    swapTimeInhomogeneousVariances[j][i-1]);
            }
            if (i>0) {
                const Matrix& thisPseudo = corrPseudo[j];
                Real correlation = 0.0;
                for (Size k=0; k<numberOfFactors; ++k)
                    correlation += thisPseudo[i-1][k]*thisPseudo[i][k];
                leftCovariance[i] = correlation *
                    std::sqrt(swapTimeInhomogeneousVariances[j][i] *
                    swapTimeInhomogeneousVariances[j][i-1]);
            }
        }


        // multiplier up to rate reset previous time
        // the first element is not used
        std::vector<Real> a(numberOfSteps, 1.0);
        // multiplier afterward
        std::vector<Real> b(numberOfSteps);

        b[0]=displacedSwapVariances[0]->variances()[0]/swapTimeInhomogeneousVariances[0][0];
        // main loop where work is done
        for (Size i=1; i<numberOfSteps; ++i) {
            Integer j=0;
            // up date variances to take account of last a and b computed
            for (; j <= static_cast<Integer>(i)-2; j++)
                swapTimeInhomogeneousVariances[j][i-1]*= a[i-1]*a[i-1];
            swapTimeInhomogeneousVariances[j][i-1]*= b[i-1]*b[i-1];

            Real w0 = invertedZedMatrix[i-1][i-1];
            Real w1 = -invertedZedMatrix[i-1][i];
            Real v1t1 = capletVols[i-1]*capletVols[i-1]*rateTimes[i-1];

            // now compute contribution from lower right corner
            Real extraConstantPart =0.0;
            // part of caplet approximation formula coming from later rates
            for (Size k = i+1; k < numberOfSteps; ++k)
                for (Size l = i+1; l < numberOfSteps; ++l)
                    extraConstantPart+=invertedZedMatrix[i-1][k] *
                                         CovarianceSwapCovs[i-1][k][l] *
                                         invertedZedMatrix[i-1][l];

            // now compute contribution from top row excluding first two columns and its transpose
            // we divide into two parts as one part is multiplied by a[i-1] and the other by b[i-1]
            // a lot could be precomputed when we need to optimize
            for (Size k = i+1; k < numberOfSteps; ++k)
            {
                if (i > 1)
                {
                    extraConstantPart+=invertedZedMatrix[i-1][i-1] *
                        CovarianceSwapCovs[i-2][i-1][k] *
                        invertedZedMatrix[i-1][k]*a[i-1];

                    extraConstantPart+=invertedZedMatrix[i-1][k] *
                        CovarianceSwapCovs[i-2][k][i-1] *
                        invertedZedMatrix[i-1][i-1]*a[i-1];
                }

                extraConstantPart+=invertedZedMatrix[i-1][i-1] *
                    CovarianceSwapMarginalCovs[i-1][i-1][k] *
                    invertedZedMatrix[i-1][k]*b[i-1];

                extraConstantPart+=invertedZedMatrix[i-1][k] *
                    CovarianceSwapCovs[i-1][k][i-1] *
                    invertedZedMatrix[i-1][i-1]*b[i-1];

            }

            // we also get an extra linear part, this corresponds to row i, and columns j>i+1, and transpose
            Real extraLinearPart=0.0;
            for (Size k = i+1; k < numberOfSteps; ++k)
            {
                    extraLinearPart+=invertedZedMatrix[i-1][k] *
                        CovarianceSwapCovs[i-1][k][i] *
                        invertedZedMatrix[i-1][i];

                    extraLinearPart+=invertedZedMatrix[i-1][i] *
                        CovarianceSwapCovs[i-1][i][k] *
                        invertedZedMatrix[i-1][k];
            }



            Real constantPart = w0*w0*totVariance[i-1] +
                                                    extraConstantPart*extraMultiplier-v1t1;
            Real linearPart = -2*w0*w1*(a[i-1]*almostTotCovariance[i] +
                                                b[i-1]*leftCovariance[i]) +extraLinearPart*extraMultiplier ;
            Real quadraticPart = w1*w1*almostTotVariance[i];
            Real disc = linearPart*linearPart-4.0*constantPart*quadraticPart;

            Real root, minimum = -linearPart/(2.0*quadraticPart);
            bool rightUsed = false;
            if (disc <0.0) {
                ++failures;
                // pick up the minimum vol for the caplet
                root = minimum;
            } else if (lowestRoot) {
                root = (-linearPart-std::sqrt(disc))/(2.0*quadraticPart);
            } else {
                if (minimum>1.0)
                    root = (-linearPart-std::sqrt(disc))/(2.0*quadraticPart);
                else {
                    rightUsed = true;
                    root = (-linearPart+std::sqrt(disc))/(2.0*quadraticPart);
                }
            }

            Real varianceFound = root*root*almostTotVariance[i];
            Real varianceToFind = totVariance[i]-varianceFound;
            Real mult = varianceToFind/swapTimeInhomogeneousVariances[i][i];
            if (mult<=0.0 && rightUsed) {
                root = (-linearPart-std::sqrt(disc))/(2.0*quadraticPart);
                varianceFound = root*root*almostTotVariance[i];
                varianceToFind = totVariance[i]-varianceFound;
                mult = varianceToFind/swapTimeInhomogeneousVariances[i][i];
            }

            if (mult<0.0) // no solution...
            {
               ++failures;
               a[i]=root;
               b[i]=0.0;
            }
            else
            {
                a[i]=root;
                b[i]=std::sqrt(mult);
            }

            QL_ENSURE(root>=0.0,
                      "negative root -- it should have not happened");

        }

        {
            Integer i = numberOfSteps;
            Integer j=0;
            for (; j <= static_cast<Integer>(i)-2; j++)
                swapTimeInhomogeneousVariances[j][i-1]*= a[i-1]*a[i-1];
            swapTimeInhomogeneousVariances[j][i-1]*= b[i-1]*b[i-1];
        }

        // compute the results
        swapCovariancePseudoRoots.resize(numberOfSteps);
        for (Size k=0; k<numberOfSteps; ++k) {
            swapCovariancePseudoRoots[k] = corrPseudo[k];
            for (Size j=0; j<numberOfRates; ++j) {
                Real coeff = std::sqrt(swapTimeInhomogeneousVariances[k][j]);
                 for (Size i=0; i<numberOfFactors; ++i)
                    swapCovariancePseudoRoots[k][j][i]*=coeff;
            }
            QL_ENSURE(swapCovariancePseudoRoots[k].rows()==numberOfRates,
                      "step " << k
                      << " abcd vol wrong number of rows: "
                      << swapCovariancePseudoRoots[k].rows()
                      << " instead of " << numberOfRates);
            QL_ENSURE(swapCovariancePseudoRoots[k].columns()==numberOfFactors,
                      "step " << k
                      << " abcd vol wrong number of columns: "
                      << swapCovariancePseudoRoots[k].columns()
                      << " instead of " << numberOfFactors);
        }

        return failures;
    }

    Natural CTSMMCapletOriginalCalibration::calibrationImpl_(
                                Natural numberOfFactors,
                                Natural ,
                                Real ) {

        return calibrationFunction(evolution_,
                                   *corr_,
                                   displacedSwapVariances_,
                                   // not mktCapletVols_ but...
                                   usedCapletVols_,
                                   *cs_,
                                   displacement_,

                                   alpha_,
                                   lowestRoot_,
                                   useFullApprox_,

                                   numberOfFactors,

                                   swapCovariancePseudoRoots_);
    }

}
]]></document_content>
  </document>
  <document index="57">
    <source>marketmodels/models/cotswaptofwdadapter.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/models/cotswaptofwdadapter.hpp>
#include <ql/models/marketmodels/curvestates/coterminalswapcurvestate.hpp>
#include <ql/models/marketmodels/swapforwardmappings.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/utilities/dataformatters.hpp>

namespace QuantLib {

    CotSwapToFwdAdapter::CotSwapToFwdAdapter(
                               const ext::shared_ptr<MarketModel>& ctModel)
    : coterminalModel_(ctModel),
      numberOfFactors_(ctModel->numberOfFactors()),
      numberOfRates_(ctModel->numberOfRates()),
      numberOfSteps_(ctModel->numberOfSteps()),
      pseudoRoots_(numberOfSteps_, Matrix(numberOfRates_, numberOfFactors_))
    {

        const std::vector<Spread>& displacements =
            coterminalModel_->displacements();
        for (Size i = 1; i<displacements.size(); ++i) {
            QL_REQUIRE(displacements[i]==displacements[0],
                       io::ordinal(i+1) << " displacement (" <<
                       displacements[i] << ") not equal to the previous ones"
                       " (" << displacements[0] << ")");
        }

        const std::vector<Time>& rateTimes =
            coterminalModel_->evolution().rateTimes();
        // we must ensure we step through all rateTimes
        const std::vector<Time>& evolutionTimes =
            coterminalModel_->evolution().evolutionTimes();
        for (Size i = 0;
             i<rateTimes.size() && rateTimes[i]<=evolutionTimes.back(); ++i) {
            QL_REQUIRE(std::find(evolutionTimes.begin(), evolutionTimes.end(),
                                 rateTimes[i])!=evolutionTimes.end(),
                                 "skipping " << io::ordinal(i+1) << " rate time");
        }

        CoterminalSwapCurveState cs(rateTimes);
        const std::vector<Rate>& initialCoterminalSwapRates =
            coterminalModel_->initialRates();
        cs.setOnCoterminalSwapRates(initialCoterminalSwapRates);
        initialRates_ = cs.forwardRates();

        Matrix zedMatrix = SwapForwardMappings::coterminalSwapZedMatrix(
            cs, displacements[0]);
        Matrix invertedZedMatrix = inverse(zedMatrix);

        const std::vector<Size>& alive =
            coterminalModel_->evolution().firstAliveRate();
        for (Size k = 0; k<numberOfSteps_; ++k) {
            pseudoRoots_[k]=invertedZedMatrix*coterminalModel_->pseudoRoot(k);
            for (Size i=0; i<alive[k]; ++i)
                std::fill(pseudoRoots_[k].row_begin(i),
                          pseudoRoots_[k].row_end(i),
                          0.0);
        }
    }


    CotSwapToFwdAdapterFactory::CotSwapToFwdAdapterFactory(
             const ext::shared_ptr<MarketModelFactory>& coterminalFactory)
    : coterminalFactory_(coterminalFactory) {
        registerWith(coterminalFactory);
    }

    ext::shared_ptr<MarketModel>
    CotSwapToFwdAdapterFactory::create(
                                        const EvolutionDescription& evolution,
                                        Size numberOfFactors) const {
        ext::shared_ptr<MarketModel> coterminalModel =
            coterminalFactory_->create(evolution,numberOfFactors);
        return ext::shared_ptr<MarketModel>(
                             new CotSwapToFwdAdapter(coterminalModel));
    }

    void CotSwapToFwdAdapterFactory::update() {
        notifyObservers();
    }

}

]]></document_content>
  </document>
  <document index="58">
    <source>marketmodels/models/ctsmmcapletcalibration.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/comparison.hpp>
#include <ql/math/matrixutilities/pseudosqrt.hpp>
#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/models/cotswaptofwdadapter.hpp>
#include <ql/models/marketmodels/models/ctsmmcapletcalibration.hpp>
#include <ql/models/marketmodels/models/piecewiseconstantvariance.hpp>
#include <ql/models/marketmodels/models/pseudorootfacade.hpp>
#include <ql/models/marketmodels/swapforwardmappings.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <utility>

namespace QuantLib {

    CTSMMCapletCalibration::CTSMMCapletCalibration(
        EvolutionDescription evolution,
        ext::shared_ptr<PiecewiseConstantCorrelation> corr,
        std::vector<ext::shared_ptr<PiecewiseConstantVariance> > displacedSwapVariances,
        std::vector<Volatility> mktCapletVols,
        ext::shared_ptr<CurveState> cs,
        Spread displacement)
    : evolution_(std::move(evolution)), corr_(std::move(corr)),
      displacedSwapVariances_(std::move(displacedSwapVariances)),
      mktCapletVols_(std::move(mktCapletVols)), mdlCapletVols_(evolution_.numberOfRates()),
      mktSwaptionVols_(evolution_.numberOfRates()), mdlSwaptionVols_(evolution_.numberOfRates()),
      cs_(std::move(cs)), displacement_(displacement), numberOfRates_(evolution_.numberOfRates()) {
        performChecks(evolution_, *corr_, displacedSwapVariances_,
                      mktCapletVols_, *cs_);
    }

    const std::vector<Volatility>&
    CTSMMCapletCalibration::timeDependentUnCalibratedSwaptionVols(Size i) const
    {
        QL_REQUIRE(i<numberOfRates_,
                   "index (" << i << ") must less than number of rates (" <<
                   numberOfRates_ << ")");
        return displacedSwapVariances_[i]->volatilities();
    }

    const std::vector<Volatility>&
    CTSMMCapletCalibration::timeDependentCalibratedSwaptionVols(Size i) const
    {
        QL_REQUIRE(i<numberOfRates_,
                   "index (" << i << ") must less than number of rates (" <<
                   numberOfRates_ << ")");
        return timeDependentCalibratedSwaptionVols_[i];
    }

    void CTSMMCapletCalibration::performChecks(
                    const EvolutionDescription& evolution,
                    const PiecewiseConstantCorrelation&  corr,
                    const std::vector<ext::shared_ptr<
                                PiecewiseConstantVariance> >&
                                            displacedSwapVariances,
                    const std::vector<Volatility>& mktCapletVols,
                    const CurveState& cs)
    {
        const std::vector<Time>& evolutionTimes = evolution.evolutionTimes();
        QL_REQUIRE(evolutionTimes==corr.times(),
                   "evolutionTimes "
                   << io::sequence(evolutionTimes)
                   << " not equal to correlation times "
                   << io::sequence(corr.times()));

        const std::vector<Time>& rateTimes = evolution.rateTimes();
        QL_REQUIRE(rateTimes==cs.rateTimes(),
                   "mismatch between EvolutionDescription and "
                   "CurveState rate times");

        Size numberOfRates = evolution.numberOfRates();
        QL_REQUIRE(numberOfRates==displacedSwapVariances.size(),
                   "mismatch between EvolutionDescription number of rates ("
                   << numberOfRates << ") and displacedSwapVariances size ("
                   << displacedSwapVariances.size() << ")");
        QL_REQUIRE(numberOfRates==corr.numberOfRates(),
                   "mismatch between EvolutionDescription number of rates ("
                   << numberOfRates << ") and corr number of rates ("
                   << corr.numberOfRates() << ")");
        QL_REQUIRE(numberOfRates==mktCapletVols.size(),
                   "mismatch between EvolutionDescription number of rates ("
                   << numberOfRates << ") and mktCapletVols size ("
                   << mktCapletVols.size() << ")");
        QL_REQUIRE(numberOfRates==cs.numberOfRates(),
                   "mismatch between EvolutionDescription number of rates ("
                   << numberOfRates << ") and CurveState  number of rates ("
                   << cs.numberOfRates() << ")");

        std::vector<Time> temp(rateTimes.begin(), rateTimes.end()-1);
        QL_REQUIRE(temp==evolutionTimes,
                   "mismatch between evolutionTimes and rateTimes");

        Volatility lastSwaptionVol =
            displacedSwapVariances.back()->totalVolatility(numberOfRates-1);
        QL_REQUIRE(close(lastSwaptionVol, mktCapletVols[numberOfRates-1]),
                   "last caplet vol (" << std::setprecision(16) <<
                   mktCapletVols[numberOfRates-1] <<
                   ") must be equal to last swaption vol (" <<
                   lastSwaptionVol << "); discrepancy is " <<
                   lastSwaptionVol-mktCapletVols[numberOfRates-1]);
    }

    bool CTSMMCapletCalibration::calibrate(Natural numberOfFactors,

                                           Natural maxIterations,
                                           Real capletVolTolerance,

                                           Natural innerSolvingMaxIterations,
                                           Real innerSolvingTolerance) {
        // initialize results
        calibrated_ = false;
        failures_ = 987654321; // a positive large number
        deformationSize_ = 987654321;
        capletRmsError_ = swaptionRmsError_ = 987654321;
        capletMaxError_ = swaptionMaxError_ = 987654321;

        // initialize working variables
        usedCapletVols_ = mktCapletVols_;

        for (Size i=0; i<numberOfRates_; ++i)
            mktSwaptionVols_[i]=displacedSwapVariances_[i]->totalVolatility(i);

        std::vector<Spread> displacements(numberOfRates_,
                                          displacement_);
        const std::vector<Time>& rateTimes = evolution_.rateTimes();
        Natural iterations = 0;

        // calibration loop
        do {
            failures_ = calibrationImpl_(numberOfFactors,
                                         innerSolvingMaxIterations,
                                         innerSolvingTolerance);

            ext::shared_ptr<MarketModel> ctsmm(new
                PseudoRootFacade(swapCovariancePseudoRoots_,
                                 rateTimes,
                                 cs_->coterminalSwapRates(),
                                 displacements));
            const Matrix& swaptionTotCovariance =
                ctsmm->totalCovariance(numberOfRates_-1);

            CotSwapToFwdAdapter flmm(ctsmm);
            const Matrix& capletTotCovariance =
                flmm.totalCovariance(numberOfRates_-1);

            // check fit
            capletRmsError_ = swaptionRmsError_ = 0.0;
            capletMaxError_ = swaptionMaxError_ = -1.0;

            for (Size i=0; i<numberOfRates_; ++i) {
                mdlSwaptionVols_[i] = std::sqrt(swaptionTotCovariance[i][i]/rateTimes[i]);
                Real swaptionError = std::fabs(mktSwaptionVols_[i]-mdlSwaptionVols_[i]);
                swaptionRmsError_ += swaptionError*swaptionError;
                swaptionMaxError_ = std::max(swaptionMaxError_, swaptionError);

                mdlCapletVols_[i] = std::sqrt(capletTotCovariance[i][i]/rateTimes[i]);
                Real capletError = std::fabs(mktCapletVols_[i]-mdlCapletVols_[i]);
                capletRmsError_ += capletError*capletError;
                capletMaxError_ = std::max(capletMaxError_, capletError);

                if (i < numberOfRates_-1)
                    usedCapletVols_[i] *= mktCapletVols_[i]/mdlCapletVols_[i];
            }
            swaptionRmsError_ = std::sqrt(swaptionRmsError_/numberOfRates_);
            capletRmsError_ = std::sqrt(capletRmsError_/numberOfRates_);
            ++iterations;
        } while (iterations<maxIterations &&
                 capletRmsError_>capletVolTolerance);

         ext::shared_ptr<MarketModel> ctsmm(new
                PseudoRootFacade(swapCovariancePseudoRoots_,
                                 rateTimes,
                                 cs_->coterminalSwapRates(),
                                 displacements));

         timeDependentCalibratedSwaptionVols_.clear();
         for (Size i=0; i<numberOfRates_; ++i)
             timeDependentCalibratedSwaptionVols_.push_back(
                ctsmm->timeDependentVolatility(i));

        // calculate deformationSize_ ??
        calibrated_ = true;
        return failures_==0;
    }

}
]]></document_content>
  </document>
  <document index="59">
    <source>marketmodels/models/flatvol.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/math/matrixutilities/pseudosqrt.hpp>
#include <ql/models/marketmodels/correlations/expcorrelations.hpp>
#include <ql/models/marketmodels/correlations/timehomogeneousforwardcorrelation.hpp>
#include <ql/models/marketmodels/models/flatvol.hpp>
#include <ql/models/marketmodels/piecewiseconstantcorrelation.hpp>
#include <utility>

using std::vector;

namespace QuantLib {

    Real flatVolCovariance(Time t1,Time t2,
                           Time T, Time S,
                           Volatility v1, Volatility v2) {
        QL_REQUIRE(t1<=t2,
                   "integrations bounds (" << t1 <<
                   "," << t2 << ") are in reverse order");
        Time cutOff = std::min(S,T);
        if (t1>=cutOff) {
            return 0.0;
        } else {
            cutOff = std::min(t2, cutOff);
            return (cutOff - t1)*v1*v2;
        }
    }

    FlatVol::FlatVol(
            const vector<Volatility>& vols,
            const ext::shared_ptr<PiecewiseConstantCorrelation>& corr,
            const EvolutionDescription& evolution,
            Size numberOfFactors,
            const vector<Rate>& initialRates,
            const vector<Spread>& displacements)
    : numberOfFactors_(numberOfFactors),
      numberOfRates_(initialRates.size()),
      numberOfSteps_(evolution.evolutionTimes().size()),
      initialRates_(initialRates),
      displacements_(displacements),
      evolution_(evolution),
      pseudoRoots_(numberOfSteps_, Matrix(numberOfRates_, numberOfFactors_))
    {
        const vector<Time>& rateTimes = evolution.rateTimes();
        QL_REQUIRE(numberOfRates_==rateTimes.size()-1,
                   "mismatch between number of rates (" << numberOfRates_ <<
                   ") and rate times");
        QL_REQUIRE(numberOfRates_==displacements.size(),
                   "mismatch between number of rates (" << numberOfRates_ <<
                   ") and displacements (" << displacements.size() << ")");
        QL_REQUIRE(numberOfRates_==vols.size(),
                   "mismatch between number of rates (" << numberOfRates_ <<
                   ") and vols (" << vols.size() << ")");
        QL_REQUIRE(numberOfRates_<=numberOfFactors_*numberOfSteps_,
                   "number of rates (" << numberOfRates_ <<
                   ") greater than number of factors (" << numberOfFactors_
                   << ") times number of steps (" << numberOfSteps_ << ")");
        QL_REQUIRE(numberOfFactors<=numberOfRates_,
                   "number of factors (" << numberOfFactors <<
                   ") cannot be greater than numberOfRates (" <<
                   numberOfRates_ << ")");
        QL_REQUIRE(numberOfFactors>0,
                   "number of factors (" << numberOfFactors <<
                   ") must be greater than zero");

        Time effStopTime = 0.0;
        const vector<Time>& corrTimes = corr->times();
        const vector<Time>& evolTimes = evolution.evolutionTimes();
        Matrix covariance(numberOfRates_, numberOfRates_);
        for (Size k=0, kk=0; k<numberOfSteps_; ++k) {
            // one covariance per evolution step
            std::fill(covariance.begin(), covariance.end(), 0.0);

            // there might be more than one correlation matrix
            // in a single evolution step
            for (; corrTimes[kk]<evolTimes[k]; ++kk) {
                Time effStartTime = effStopTime;
                effStopTime = corrTimes[kk];
                const Matrix& corrMatrix = corr->correlation(kk);
                for (Size i=0; i<numberOfRates_; ++i) {
                    for (Size j=i; j<numberOfRates_; ++j) {
                        Real cov = flatVolCovariance(effStartTime, effStopTime,
                                                     rateTimes[i], rateTimes[j],
                                                     vols[i], vols[j]);
                        covariance[i][j] += cov * corrMatrix[i][j];
                     }
                }
            }
            // last part in the evolution step
            Time effStartTime = effStopTime;
            effStopTime = evolTimes[k];
            const Matrix& corrMatrix = corr->correlation(kk);
            for (Size i=0; i<numberOfRates_; ++i) {
                for (Size j=i; j<numberOfRates_; ++j) {
                    Real cov = flatVolCovariance(effStartTime, effStopTime,
                                                 rateTimes[i], rateTimes[j],
                                                 vols[i], vols[j]);
                    covariance[i][j] += cov * corrMatrix[i][j];
                 }
            }
            // no more use for the kk-th correlation matrix
            while (kk<corrTimes.size() && corrTimes[kk]<=evolTimes[k])
                ++kk;

            // make it symmetric
            for (Size i=0; i<numberOfRates_; ++i) {
                for (Size j=i+1; j<numberOfRates_; ++j) {
                     covariance[j][i] = covariance[i][j];
                 }
            }

            pseudoRoots_[k] = rankReducedSqrt(covariance,
                                              numberOfFactors, 1.0,
                                              SalvagingAlgorithm::None);

            QL_ENSURE(pseudoRoots_[k].rows()==numberOfRates_,
                      "step " << k
                      << " flat vol wrong number of rows: "
                      << pseudoRoots_[k].rows()
                      << " instead of " << numberOfRates_);
            QL_ENSURE(pseudoRoots_[k].columns()==numberOfFactors,
                      "step " << k
                      << " flat vol wrong number of columns: "
                      << pseudoRoots_[k].columns()
                      << " instead of " << numberOfFactors_);
        }
    }


    FlatVolFactory::FlatVolFactory(Real longTermCorrelation,
                                   Real beta,
                                   vector<Time> times,
                                   vector<Volatility> vols,
                                   Handle<YieldTermStructure> yieldCurve,
                                   Spread displacement)
    : longTermCorrelation_(longTermCorrelation), beta_(beta), times_(std::move(times)),
      vols_(std::move(vols)), yieldCurve_(std::move(yieldCurve)), displacement_(displacement) {
        volatility_ = LinearInterpolation(times_.begin(), times_.end(),
                                          vols_.begin());
        volatility_.update();
        registerWith(yieldCurve_);
    }

    ext::shared_ptr<MarketModel>
    FlatVolFactory::create(const EvolutionDescription& evolution,
                                  Size numberOfFactors) const {
        const vector<Time>& rateTimes = evolution.rateTimes();
        Size numberOfRates = rateTimes.size()-1;

        vector<Rate> initialRates(numberOfRates);
        for (Size i=0; i<numberOfRates; ++i)
            initialRates[i] = yieldCurve_->forwardRate(rateTimes[i],
                                                       rateTimes[i+1],
                                                       Simple);

        vector<Volatility> displacedVolatilities(numberOfRates);
        for (Size i=0; i<numberOfRates; ++i) {
            Volatility vol = // to be changes
                volatility_(rateTimes[i]);
            displacedVolatilities[i] =
                initialRates[i]*vol/(initialRates[i]+displacement_);
        }

        vector<Spread> displacements(numberOfRates, displacement_);

        Matrix correlations = exponentialCorrelations(evolution.rateTimes(),
                                                      longTermCorrelation_,
                                                      beta_);
        ext::shared_ptr<PiecewiseConstantCorrelation> corr(new
            TimeHomogeneousForwardCorrelation(correlations,
                                              rateTimes));
        return ext::shared_ptr<MarketModel>(new
            FlatVol(displacedVolatilities,
                           corr,
                           evolution,
                           numberOfFactors,
                           initialRates,
                           displacements));
    }

    void FlatVolFactory::update() {
        notifyObservers();
    }

}

]]></document_content>
  </document>
  <document index="60">
    <source>marketmodels/models/fwdperiodadapter.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/forwardforwardmappings.hpp>
#include <ql/models/marketmodels/models/fwdperiodadapter.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <set>
#include <utility>

namespace QuantLib {

    FwdPeriodAdapter::FwdPeriodAdapter(const ext::shared_ptr<MarketModel>& largeModel,
                                       Size period,
                                       Size offset,
                                       std::vector<Spread> newDisplacements)
    : numberOfFactors_(largeModel->numberOfFactors()),
      numberOfRates_((largeModel->numberOfRates() - offset) / (period > 0 ? period : 1)),
      numberOfSteps_(largeModel->numberOfSteps()),
      pseudoRoots_(numberOfSteps_, Matrix(numberOfRates_, numberOfFactors_)),
      displacements_(std::move(newDisplacements)) {
        QL_REQUIRE( period >0, "period must  be greater than zero in fwdperiodadapter");
        QL_REQUIRE(period > offset, "period must be greater than offset in fwdperiodadapter");

        const std::vector<Spread>& largeDisplacements_ =
            largeModel->displacements();

        if (displacements_.size() == 1)
        {
            Real dis = displacements_[0];
            displacements_.resize(numberOfRates_);
            std::fill(displacements_.begin(), displacements_.end(), dis);
        }

        if (displacements_.empty()) // if not specified use average across rate
        {
            displacements_.reserve(numberOfRates_);
            Size m=0;
            Real sum=0.0;
            for (Size k=0; k < numberOfRates_; ++k)
            {
                for (Size l=0; l < period; ++l, ++m)
                    sum+= largeDisplacements_[m];

                displacements_.push_back(sum/period);
            }
        }
        QL_REQUIRE( displacements_.size() == numberOfRates_,"newDisplacements should be empty,1, or number of new rates in fwdperiodadapter");

        LMMCurveState largeCS(largeModel->evolution().rateTimes());
        largeCS.setOnForwardRates(largeModel->initialRates());

        LMMCurveState smallCS(
                ForwardForwardMappings::RestrictCurveState(largeCS,
                                    period, offset
                                        ));

        initialRates_ =smallCS.forwardRates();

        Real finalReset = smallCS.rateTimes()[smallCS.numberOfRates()-1];
        std::vector<Time> oldEvolutionTimes(largeModel->evolution().evolutionTimes());
        std::vector<Time> newEvolutionTimes;
        for (Size i =0; i < oldEvolutionTimes.size() && oldEvolutionTimes[i]<= finalReset; ++i)
            newEvolutionTimes.push_back(oldEvolutionTimes[i]);

        evolution_=EvolutionDescription(smallCS.rateTimes(),
                                        newEvolutionTimes);

        numberOfSteps_ = newEvolutionTimes.size();


        const std::vector<Time>& rateTimes =
            smallCS.rateTimes();
        // we must ensure we step through all rateTimes
        const std::vector<Time>& evolutionTimes =
            evolution_.evolutionTimes();

        std::set<Time> setTimes(evolutionTimes.begin(),evolutionTimes.end());

        for (Size i=0; i < rateTimes.size()-1; ++i)
            QL_REQUIRE(setTimes.find(rateTimes[i]) != setTimes.end(),
                        "every new rate time except last must be an evolution time in fwdperiod adapter");


        Matrix YMatrix =
            ForwardForwardMappings::YMatrix( largeCS,
                                                 largeDisplacements_,
                                                  displacements_,
                                                 period,
                                                 offset
                                                 );

        const std::vector<Size>& alive =
            evolution_.firstAliveRate();

        for (Size k = 0; k<numberOfSteps_; ++k) {
            pseudoRoots_[k]=YMatrix*largeModel->pseudoRoot(k);
            for (Size i=0; i<alive[k]; ++i)
                std::fill(pseudoRoots_[k].row_begin(i),
                          pseudoRoots_[k].row_end(i),
                          0.0);
        }
    }
}


]]></document_content>
  </document>
  <document index="61">
    <source>marketmodels/models/fwdtocotswapadapter.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/models/fwdtocotswapadapter.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/swapforwardmappings.hpp>
#include <ql/utilities/dataformatters.hpp>

namespace QuantLib {

    FwdToCotSwapAdapter::FwdToCotSwapAdapter(
                               const ext::shared_ptr<MarketModel>& fwdModel)
    : fwdModel_(fwdModel),
      numberOfFactors_(fwdModel->numberOfFactors()),
      numberOfRates_(fwdModel->numberOfRates()),
      numberOfSteps_(fwdModel->numberOfSteps()),
      pseudoRoots_(numberOfSteps_, Matrix(numberOfRates_, numberOfFactors_))
    {

        const std::vector<Spread>& displacements =
            fwdModel_->displacements();
        for (Size i = 1; i<displacements.size(); ++i) {
            QL_REQUIRE(displacements[i]==displacements[0],
                       io::ordinal(i+1) << " displacement (" <<
                       displacements[i] << ") not equal to the previous ones"
                       " (" << displacements[0] << ")");
        }

        const std::vector<Time>& rateTimes =
            fwdModel_->evolution().rateTimes();
        // we must ensure we step through all rateTimes
        const std::vector<Time>& evolutionTimes =
            fwdModel_->evolution().evolutionTimes();
        for (Size i = 0;
             i<rateTimes.size() && rateTimes[i]<=evolutionTimes.back(); ++i) {
            QL_REQUIRE(std::find(evolutionTimes.begin(), evolutionTimes.end(),
                                 rateTimes[i])!=evolutionTimes.end(),
                                 "skipping " << io::ordinal(i+1) << " rate time");
        }

        LMMCurveState cs(rateTimes);
        const std::vector<Rate>& initialFwdRates =
            fwdModel_->initialRates();
        cs.setOnForwardRates(initialFwdRates);
        initialRates_ = cs.coterminalSwapRates();

        Matrix zedMatrix = SwapForwardMappings::coterminalSwapZedMatrix(
            cs, displacements[0]);


        const std::vector<Size>& alive =
            fwdModel_->evolution().firstAliveRate();
        for (Size k = 0; k<numberOfSteps_; ++k) {
            pseudoRoots_[k]=zedMatrix*fwdModel_->pseudoRoot(k);
            for (Size i=0; i<alive[k]; ++i)
                std::fill(pseudoRoots_[k].row_begin(i),
                          pseudoRoots_[k].row_end(i),
                          0.0);
        }
    }


    FwdToCotSwapAdapterFactory::FwdToCotSwapAdapterFactory(
                  const ext::shared_ptr<MarketModelFactory>& forwardFactory)
    : forwardFactory_(forwardFactory) {
        registerWith(forwardFactory);
    }

    ext::shared_ptr<MarketModel>
    FwdToCotSwapAdapterFactory::create(
                                        const EvolutionDescription& evolution,
                                        Size numberOfFactors) const {
        ext::shared_ptr<MarketModel> forwardModel =
            forwardFactory_->create(evolution,numberOfFactors);
        return ext::shared_ptr<MarketModel>(
                                new FwdToCotSwapAdapter(forwardModel));
    }

    void FwdToCotSwapAdapterFactory::update() {
        notifyObservers();
    }

}

]]></document_content>
  </document>
  <document index="62">
    <source>marketmodels/models/piecewiseconstantabcdvariance.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2007 Ferdinando Ametrano
Copyright (C) 2007 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/models/piecewiseconstantabcdvariance.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <ql/termstructures/volatility/abcd.hpp>

namespace QuantLib {

    PiecewiseConstantAbcdVariance::PiecewiseConstantAbcdVariance(
        Real a, Real b, Real c, Real d,
        Size resetIndex,
        const std::vector<Time>& rateTimes)
        : variances_(rateTimes.size()-1, 0.0),
        volatilities_(rateTimes.size()-1, 0.0),
        rateTimes_(rateTimes) ,
        a_(a),
        b_(b),
        c_(c),
        d_(d)
    {

        checkIncreasingTimes(rateTimes);
        QL_REQUIRE(rateTimes.size()>1,
            "Rate times must contain at least two values");
        QL_REQUIRE(resetIndex<rateTimes_.size()-1,
            "resetIndex (" << resetIndex <<
            ") must be less than rateTimes.size()-1 (" <<
            rateTimes_.size()-1 << ")");
        AbcdFunction abcd(a,b,c,d);
        for (Size i=0; i<=resetIndex; ++i) {
            Time startTime = (i==0 ? 0.0 : rateTimes_[i-1]);
            variances_[i] = abcd.variance(startTime,
                rateTimes_[i],
                rateTimes_[resetIndex]);
            Time totTime = rateTimes_[i]-startTime;
            volatilities_[i] = std::sqrt(variances_[i]/totTime);
        }
    }


    void PiecewiseConstantAbcdVariance::getABCD(Real& a, Real& b, Real& c, Real& d) const
    {
        a=a_;
        b=b_;
        c=c_;
        d=d_;
    }

    const std::vector<Real>& PiecewiseConstantAbcdVariance::rateTimes() const {
        return rateTimes_;
    }

    const std::vector<Real>& PiecewiseConstantAbcdVariance::variances() const {
        return variances_;
    }

    const std::vector<Real>&
        PiecewiseConstantAbcdVariance::volatilities() const {
            return volatilities_;
    }

}
]]></document_content>
  </document>
  <document index="63">
    <source>marketmodels/models/piecewiseconstantvariance.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include <ql/models/marketmodels/models/piecewiseconstantvariance.hpp>
#include <ql/errors.hpp>
#include <numeric>

namespace QuantLib {

    Real PiecewiseConstantVariance::variance(Size i) const {
        QL_REQUIRE(i<variances().size(),
                   "invalid step index");
        return variances()[i];
    }

    Volatility PiecewiseConstantVariance::volatility(Size i) const {
        QL_REQUIRE(i<volatilities().size(),
                   "invalid step index");
        return volatilities()[i];
    }

    Real PiecewiseConstantVariance::totalVariance(Size i) const {
        QL_REQUIRE(i<variances().size(),
                   "invalid step index");
        return std::accumulate(variances().begin(),
                               variances().begin()+i+1, Real(0.0));
    }

    Volatility PiecewiseConstantVariance::totalVolatility(Size i) const {
        return std::sqrt(totalVariance(i)/rateTimes()[i]);
    }

}
]]></document_content>
  </document>
  <document index="64">
    <source>marketmodels/models/pseudorootfacade.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/matrixutilities/pseudosqrt.hpp>
#include <ql/models/marketmodels/models/pseudorootfacade.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {

    PseudoRootFacade::PseudoRootFacade(const ext::shared_ptr<CTSMMCapletCalibration>& c)
    : numberOfFactors_(c->swapPseudoRoots().front().columns()),
      numberOfRates_(c->swapPseudoRoots().front().rows()),
      numberOfSteps_(c->swapPseudoRoots().size()),
      initialRates_(c->curveState()->coterminalSwapRates()), displacements_(c->displacements()),
      evolution_(c->curveState()->rateTimes()), covariancePseudoRoots_(c->swapPseudoRoots()) {}


    PseudoRootFacade::PseudoRootFacade(const std::vector<Matrix>& covariancePseudoRoots,
                                       const std::vector<Rate>& rateTimes,
                                       std::vector<Rate> initialRates,
                                       const std::vector<Spread>& displacements)
    : numberOfFactors_(covariancePseudoRoots.front().columns()),
      numberOfRates_(covariancePseudoRoots.front().rows()),
      numberOfSteps_(covariancePseudoRoots.size()), initialRates_(std::move(initialRates)),
      displacements_(displacements), evolution_(rateTimes),
      covariancePseudoRoots_(covariancePseudoRoots) {
        checkIncreasingTimes(rateTimes);
        QL_REQUIRE(rateTimes.size()>1,
                   "Rate times must contain at least two values");
        QL_REQUIRE(numberOfRates_==rateTimes.size()-1,
                   "mismatch between number of rates (" << numberOfRates_ <<
                   ") and rate times");
        QL_REQUIRE(numberOfRates_==displacements.size(),
                   "mismatch between number of rates (" << numberOfRates_ <<
                   ") and displacements (" << displacements.size() << ")");
        QL_REQUIRE(numberOfRates_<=numberOfFactors_*numberOfSteps_,
                   "number of rates (" << numberOfRates_ <<
                   ") greater than number of factors (" << numberOfFactors_
                   << ") times number of steps (" << numberOfSteps_ << ")");

        // evolutionTimes are not given for the time being
        QL_REQUIRE(numberOfRates_==covariancePseudoRoots.size(),
                   "number of rates (" << numberOfRates_ <<
                   ") must be equal to covariancePseudoRoots.size() (" <<
                   covariancePseudoRoots.size() << ")");

        for (Size k=0; k<numberOfSteps_; ++k) {
            QL_REQUIRE(covariancePseudoRoots_[k].rows()==numberOfRates_,
                       "step " << k
                       << ": pseudoRoot has wrong number of rows: "
                       << covariancePseudoRoots_[k].rows()
                       << " instead of " << numberOfRates_);
            // not really mandatory
            QL_REQUIRE(covariancePseudoRoots_[k].columns()==numberOfFactors_,
                       "step " << k
                       << ": pseudoRoot has wrong number of columns: "
                       << covariancePseudoRoots_[k].columns()
                       << " instead of " << numberOfFactors_);
        }
    }
}
]]></document_content>
  </document>
  <document index="65">
    <source>marketmodels/models/volatilityinterpolationspecifierabcd.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*

Copyright (C) 2007 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/
/*!
implementation specifies how to decide volatility structure for additional
synthetic rates which are interleaved

here we work with abcd curves and interpolate the a, b, c and d

*/

#include <ql/models/marketmodels/models/volatilityinterpolationspecifierabcd.hpp>
#include <ql/types.hpp>
#include <ql/errors.hpp>
#include <ql/shared_ptr.hpp>
#include <vector>

namespace QuantLib
{

    VolatilityInterpolationSpecifierabcd::VolatilityInterpolationSpecifierabcd(Size period,
        Size offset,
        const std::vector< PiecewiseConstantAbcdVariance>& originalVariances, // these should be associated with the long rates
        const std::vector<Time>& timesForSmallRates, // these should be associated with the shorter rates
        Real lastCapletVol
        )
        :
    period_(period),
        offset_(offset),
        interpolatedVariances_(timesForSmallRates.size()-1),
        originalVariances_(originalVariances.size()),
        originalABCDVariances_(originalVariances),
        originalABCDVariancesScaled_(originalVariances),
        lastCapletVol_(lastCapletVol),
        timesForSmallRates_(timesForSmallRates),
        scalingFactors_(originalVariances.size(),1.0),
        noBigRates_(originalVariances.size()),
        noSmallRates_(timesForSmallRates.size()-1)
    {
        QL_REQUIRE( (noSmallRates_ - offset) /period == noBigRates_, "size mismatch in VolatilityInterpolationSpecifierabcd");

        for (Size i=0; i < noBigRates_; ++i)
            for (Size j=0; j < originalVariances[i].rateTimes().size(); ++j)
                QL_REQUIRE( originalVariances[i].rateTimes()[j] == timesForSmallRates[offset+j*period],"rate times in variances passed in don't match small times in VolatilityInterpolationSpecifierabcd");

        if (lastCapletVol_ == 0.0)
            lastCapletVol_ =  originalVariances[noBigRates_-1].totalVolatility(noBigRates_-1);

        // change type of array to PiecewiseConstantVariance for client, from PiecewiseConstantAbcdVariance
        for (Size i=0; i < noBigRates_; ++i)
            originalVariances_[i] = ext::shared_ptr<PiecewiseConstantVariance>(new PiecewiseConstantAbcdVariance(originalVariances[i]));

        recompute();

    }

    void VolatilityInterpolationSpecifierabcd::setScalingFactors(const std::vector<Real>& scales)
    {
        QL_REQUIRE(scalingFactors_.size() == scales.size(), "inappropriate number of scales passed in to VolatilityInterpolationSpecifierabcd::setScalingFactors ");
        scalingFactors_= scales;
        recompute();
    }

    void VolatilityInterpolationSpecifierabcd::setLastCapletVol(Real vol)
    {
        lastCapletVol_ = vol;
        recompute();
    }


    const std::vector<ext::shared_ptr<PiecewiseConstantVariance> >& VolatilityInterpolationSpecifierabcd::interpolatedVariances() const
    {
        return interpolatedVariances_;
    }

    const std::vector<ext::shared_ptr<PiecewiseConstantVariance> >& VolatilityInterpolationSpecifierabcd::originalVariances() const
    {
        return originalVariances_;
    }

    Size VolatilityInterpolationSpecifierabcd::getPeriod() const
    {
        return period_;
    }

    Size VolatilityInterpolationSpecifierabcd::getOffset() const
    {
        return offset_;
    }

    Size VolatilityInterpolationSpecifierabcd::getNoBigRates() const
    {
        return noBigRates_;
    }
    Size VolatilityInterpolationSpecifierabcd::getNoSmallRates() const
    {
        return noSmallRates_;
    }


    void VolatilityInterpolationSpecifierabcd::recompute()
    {
        //     PiecewiseConstantAbcdVariance(Real a, Real b, Real c, Real d,
        //                                    Size resetIndex,
        //                                  const std::vector<Time>& rateTimes);


        for (Size i=0; i < noBigRates_; ++i)
        {
            Real a,b,c,d;
            originalABCDVariances_[i].getABCD(a,b,c,d);
            a*=scalingFactors_[i];
            b*=scalingFactors_[i];
            // c is not scaled
            d*=scalingFactors_[i];

            originalABCDVariancesScaled_[i] = PiecewiseConstantAbcdVariance(a,b,c,d, i, originalABCDVariances_[i].rateTimes());

        }

        // three cases:
        //before offset,
        // between offset and last big rate,
        // and after last big rate

        // before offset

        {
            Real a,b,c,d;
            originalABCDVariancesScaled_[0].getABCD(a,b,c,d);

            for (Size i=0; i < offset_; ++i)
                interpolatedVariances_[i] = ext::shared_ptr<PiecewiseConstantVariance>(
                new PiecewiseConstantAbcdVariance(a,b,c,d,i,timesForSmallRates_));
        }


        // in between rates

        for (Size j=0; j < noBigRates_-1; ++j)
        {
            Real a,b,c,d;
            Real a0,b0,c0,d0;
            Real a1,b1,c1,d1;
            originalABCDVariancesScaled_[j].getABCD(a0,b0,c0,d0);
            originalABCDVariancesScaled_[j+1].getABCD(a1,b1,c1,d1);
            a= 0.5*(a0+a1);
            b= 0.5*(b0+b1);
            c= 0.5*(c0+c1);
            d= 0.5*(d0+d1);

            for (Size i=0; i < period_; ++i)
                interpolatedVariances_[i+j*period_+offset_] =  ext::shared_ptr<PiecewiseConstantVariance>(
                new PiecewiseConstantAbcdVariance(a,b,c,d,i+j*period_,timesForSmallRates_));

        }


       {
            Real a,b,c,d;
            originalABCDVariancesScaled_[noBigRates_-1].getABCD(a,b,c,d);

            for (Size i=offset_+(noBigRates_-1)*period_; i < noSmallRates_; ++i)
                interpolatedVariances_[i] = ext::shared_ptr<PiecewiseConstantVariance>(
                                                                         new PiecewiseConstantAbcdVariance(a,b,c,d,i,timesForSmallRates_));

            // very last rate is special as we must match the caplet vol
             Real vol = interpolatedVariances_[noSmallRates_-1]->totalVolatility(noSmallRates_-1);

             Real scale = lastCapletVol_/vol;
             a*=scale;
             b*=scale;
             d*=scale;
             interpolatedVariances_[noSmallRates_-1] = ext::shared_ptr<PiecewiseConstantVariance>(
                                                                         new PiecewiseConstantAbcdVariance(a,b,c,d,noSmallRates_-1,timesForSmallRates_));

       }
    }

}
]]></document_content>
  </document>
  <document index="66">
    <source>marketmodels/pathwiseaccountingengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2008 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/discounter.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/evolvers/lognormalfwdrateeuler.hpp>
#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/pathwiseaccountingengine.hpp>
#include <algorithm>
#include <utility>

namespace QuantLib {

    PathwiseAccountingEngine::PathwiseAccountingEngine(
        ext::shared_ptr<LogNormalFwdRateEuler> evolver, // method relies heavily on LMM Euler
        const Clone<MarketModelPathwiseMultiProduct>& product,
        ext::shared_ptr<MarketModel> pseudoRootStructure, // we need pseudo-roots and displacements
        Real initialNumeraireValue)
    : evolver_(std::move(evolver)), product_(product),
      pseudoRootStructure_(std::move(pseudoRootStructure)),
      initialNumeraireValue_(initialNumeraireValue), numberProducts_(product->numberOfProducts()),
      doDeflation_(!product->alreadyDeflated()), numerairesHeld_(product->numberOfProducts()),
      numberCashFlowsThisStep_(product->numberOfProducts()),
      cashFlowsGenerated_(product->numberOfProducts()),
      deflatorAndDerivatives_(pseudoRootStructure_->numberOfRates() + 1) {

        numberRates_ = pseudoRootStructure_->numberOfRates();
        numberSteps_ = pseudoRootStructure_->numberOfSteps();

        Matrix VModel(numberSteps_+1,numberRates_);



        Discounts_ = Matrix(numberSteps_+1,numberRates_+1);

        for (Size i=0; i <= numberSteps_; ++i)
            Discounts_[i][0] = 1.0;


        V_.reserve(numberProducts_);

        Matrix  modelCashFlowIndex(product_->possibleCashFlowTimes().size(), numberRates_+1);


        numberCashFlowsThisIndex_.resize(numberProducts_);

        for (Size i=0; i<numberProducts_; ++i)
        {
            cashFlowsGenerated_[i].resize(
                product_->maxNumberOfCashFlowsPerProductPerStep());

            for (auto& j : cashFlowsGenerated_[i])
                j.amount.resize(numberRates_ + 1);

            numberCashFlowsThisIndex_[i].resize(product_->possibleCashFlowTimes().size());

            V_.push_back(VModel);


            totalCashFlowsThisIndex_.push_back(modelCashFlowIndex);
        }

        LIBORRatios_ = VModel;
        StepsDiscountsSquared_ = VModel;
        LIBORRates_ =VModel;




        const std::vector<Time>& cashFlowTimes =
            product_->possibleCashFlowTimes();
        numberCashFlowTimes_ = cashFlowTimes.size();

        const std::vector<Time>& rateTimes = product_->evolution().rateTimes();
        const std::vector<Time>& evolutionTimes = product_->evolution().evolutionTimes();
        discounters_.reserve(cashFlowTimes.size());

        for (Real cashFlowTime : cashFlowTimes)
            discounters_.emplace_back(cashFlowTime, rateTimes);


        // need to check that we are in money market measure


        // we need to allocate cash-flow times to steps, i.e. what is the last step completed before a flow occurs
        // what we really need is for each step, what cash flow time indices to look at

        cashFlowIndicesThisStep_.resize(numberSteps_);

        for (Size i=0; i < numberCashFlowTimes_; ++i)
        {
            auto it =
                std::upper_bound(evolutionTimes.begin(), evolutionTimes.end(), cashFlowTimes[i]);
            if (it != evolutionTimes.begin())
                --it;
            Size index = it - evolutionTimes.begin();
            cashFlowIndicesThisStep_[index].push_back(i);
        }

        partials_ = Matrix(pseudoRootStructure_->numberOfFactors(),numberRates_);
    }

    Real PathwiseAccountingEngine::singlePathValues(std::vector<Real>& values)
    {

        const std::vector<Real> initialForwards_(pseudoRootStructure_->initialRates());
        currentForwards_ = initialForwards_;
        // clear accumulation variables
        for (Size i=0; i < numberProducts_; ++i)
        {
            numerairesHeld_[i]=0.0;

            for (Size j=0; j < numberCashFlowTimes_; ++j)
            {
                numberCashFlowsThisIndex_[i][j] =0;

                for (Size k=0; k <= numberRates_; ++k)
                    totalCashFlowsThisIndex_[i][j][k] =0.0;
            }

            for (Size l=0;  l< numberRates_; ++l)
                for (Size m=0; m <= numberSteps_; ++m)
                    V_[i][m][l] =0.0;

        }



        Real weight = evolver_->startNewPath();
        product_->reset();

        Size thisStep;

        bool done = false;
        do {
            thisStep = evolver_->currentStep();
            Size storeStep = thisStep+1;
            weight *= evolver_->advanceStep();

            done = product_->nextTimeStep(evolver_->currentState(),
                numberCashFlowsThisStep_,
                cashFlowsGenerated_);

            lastForwards_ = currentForwards_;
            currentForwards_ =  evolver_->currentState().forwardRates();

            for (unsigned long i=0; i < numberRates_; ++i)
            {
                Real x=  evolver_->currentState().discountRatio(i+1,i);
                StepsDiscountsSquared_[storeStep][i] = x*x;

                LIBORRatios_[storeStep][i] = currentForwards_[i]/lastForwards_[i];
                LIBORRates_[storeStep][i] = currentForwards_[i];
                Discounts_[storeStep][i+1] = evolver_->currentState().discountRatio(i+1,0);
            }

            // for each product...
            for (Size i=0; i<numberProducts_; ++i)
            {
                // ...and each cash flow...
                for (Size j=0; j<numberCashFlowsThisStep_[i]; ++j)
                {
                    Size k = cashFlowsGenerated_[i][j].timeIndex;
                    ++numberCashFlowsThisIndex_[i][ k];

                    for (Size l=0; l <= numberRates_; ++l)
                        totalCashFlowsThisIndex_[i][k][l] += cashFlowsGenerated_[i][j].amount[l]*weight;

                }
            }


        } while (!done);

        // ok we've gathered cash-flows, still have to backwards computation

        Size factors = pseudoRootStructure_->numberOfFactors();
        const std::vector<Time>& taus= pseudoRootStructure_->evolution(). rateTaus();

        bool flowsFound = false;

        Integer finalStepDone = thisStep;

        for (Integer currentStep =  numberSteps_-1; currentStep >=0 ; --currentStep) // must be a signed type as we go negative
        {
            Integer stepToUse = std::min<Integer>(currentStep, finalStepDone)+1;

            for (Size k=0; k < cashFlowIndicesThisStep_[currentStep].size(); ++k)
            {
                Size cashFlowIndex =cashFlowIndicesThisStep_[currentStep][k];

                // first check to see if anything actually happened before spending time on computing stuff
                bool noFlows = true;
                for (Size l=0; l < numberProducts_ && noFlows; ++l)
                    noFlows = noFlows && (numberCashFlowsThisIndex_[l][cashFlowIndex] ==0);

                flowsFound = flowsFound || !noFlows;

                if (!noFlows)
                {
                    if (doDeflation_)
                        discounters_[cashFlowIndex].getFactors(LIBORRates_, Discounts_,stepToUse, deflatorAndDerivatives_); // get amount to discount cash flow by and amount to multiply its derivatives by

                    for (Size j=0; j < numberProducts_; ++j)
                    {
                        if (numberCashFlowsThisIndex_[j][cashFlowIndex] > 0)
                        {
                            Real deflatedCashFlow = totalCashFlowsThisIndex_[j][cashFlowIndex][0];
                            if (doDeflation_)
                                deflatedCashFlow *= deflatorAndDerivatives_[0];
                            //cashFlowsGenerated_[j][cashFlowIndex].amount[0]*deflatorAndDerivatives_[0];
                            numerairesHeld_[j] += deflatedCashFlow;

                            for (Size i=1; i <= numberRates_; ++i)
                            {
                                Real thisDerivative =  totalCashFlowsThisIndex_[j][cashFlowIndex][i];
                                if (doDeflation_)
                                {
                                    thisDerivative *= deflatorAndDerivatives_[0];
                                    thisDerivative +=  totalCashFlowsThisIndex_[j][cashFlowIndex][0]*deflatorAndDerivatives_[i];
                                }

                                V_[j][stepToUse][i-1] += thisDerivative; // zeroth row of V is t =0 not t_0
                            }
                        }
                    }
                }
            }

            // need to do backwards updating
            if (flowsFound)
            {
                Integer nextStepToUse  = std::min<Integer>(currentStep-1, finalStepDone);
                Integer nextStepIndex = nextStepToUse+1;
                if (nextStepIndex != stepToUse) // then we need to update V
                {

                    const Matrix& thisPseudoRoot_= pseudoRootStructure_->pseudoRoot(currentStep);

                    for (Size i=0; i < numberProducts_; ++i)
                    {
                        // compute partials
                        for (Size f=0; f < factors; ++f)
                        {
                            Real libor = LIBORRates_[stepToUse][numberRates_-1];
                            Real V = V_[i][stepToUse][numberRates_-1];
                            Real pseudo = thisPseudoRoot_[numberRates_-1][f];
                            Real thisPartialTerm = libor*V*pseudo;
                            partials_[f][numberRates_-1] = thisPartialTerm;

                            for (Integer r = numberRates_-2; r >=0 ; --r)
                            {
                                Real thisPartialTermr = LIBORRates_[stepToUse][r]*V_[i][stepToUse][r]*thisPseudoRoot_[r][f];

                                partials_[f][r] = partials_[f][r+1] + thisPartialTermr;

                            }
                        }
                        for (Size j=0; j < numberRates_; ++j)
                        {
                            Real nextV = V_[i][stepToUse][j] * LIBORRatios_[stepToUse][j];
                            V_[i][nextStepIndex][j] = nextV;

                            Real summandTerm = 0.0;
                            for (Size f=0; f < factors; ++f)
                                summandTerm += thisPseudoRoot_[j][f]*partials_[f][j];

                            summandTerm *= taus[j]*StepsDiscountsSquared_[stepToUse][j];

                            V_[i][nextStepIndex][j] += summandTerm;

                        }
                    }

                }
            }




        }

        // write answer into values

        for (Size i=0; i < numberProducts_; ++i)
        {
            values[i] = numerairesHeld_[i]*initialNumeraireValue_;
            for (Size j=0; j < numberRates_; ++j)
                values[(i+1)*numberProducts_+j] = V_[i][0][j]*initialNumeraireValue_;
        }

        return 1.0; // we have put the weight in already, this results in lower variance since weight changes along the path
    }

    void PathwiseAccountingEngine::multiplePathValues(SequenceStatisticsInc& stats,
        Size numberOfPaths)
    {
        std::vector<Real> values(product_->numberOfProducts()*(numberRates_+1));
        for (Size i=0; i<numberOfPaths; ++i)
        {
            Real weight = singlePathValues(values);
            stats.add(values,weight);
        }
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    PathwiseVegasAccountingEngine::PathwiseVegasAccountingEngine(
        ext::shared_ptr<LogNormalFwdRateEuler> evolver, // method relies heavily on LMM Euler
        const Clone<MarketModelPathwiseMultiProduct>& product,
        ext::shared_ptr<MarketModel> pseudoRootStructure, // we need pseudo-roots and displacements
        const std::vector<std::vector<Matrix> >& vegaBumps,
        Real initialNumeraireValue)
    : evolver_(std::move(evolver)), product_(product),
      pseudoRootStructure_(std::move(pseudoRootStructure)),
      initialNumeraireValue_(initialNumeraireValue), numberProducts_(product->numberOfProducts()),
      doDeflation_(!product->alreadyDeflated()), numerairesHeld_(product->numberOfProducts()),
      numberCashFlowsThisStep_(product->numberOfProducts()),
      cashFlowsGenerated_(product->numberOfProducts()),
      stepsDiscounts_(pseudoRootStructure_->numberOfRates() + 1),
      vegasThisPath_(product->numberOfProducts(), vegaBumps[0].size()),
      deflatorAndDerivatives_(pseudoRootStructure_->numberOfRates() + 1) {

        stepsDiscounts_[0]=1.0;

        numberRates_ = pseudoRootStructure_->numberOfRates();
        numberSteps_ = pseudoRootStructure_->numberOfSteps();
        fullDerivatives_.resize(numberRates_);


        const EvolutionDescription& evolution = pseudoRootStructure_->evolution();
        numeraires_ =  moneyMarketMeasure(evolution);


        QL_REQUIRE(vegaBumps.size() == numberSteps_, "we need one vector of vega bumps for each step.");

        numberBumps_ = vegaBumps[0].size();

        for (Size i =0; i < numberSteps_; ++i)
        {
            Size thisSize = vegaBumps[i].size();
            QL_REQUIRE(thisSize == numberBumps_,"We must have precisely the same number of bumps for each step.");
            jacobianComputers_.emplace_back(
                pseudoRootStructure_->pseudoRoot(i), evolution.firstAliveRate()[i], numeraires_[i],
                evolution.rateTaus(), vegaBumps[i], pseudoRootStructure_->displacements());

            jacobiansThisPaths_.emplace_back(numberBumps_, pseudoRootStructure_->numberOfRates());
        }



        Matrix VModel(numberSteps_+1,numberRates_);



        Discounts_ = Matrix(numberSteps_+1,numberRates_+1);

        for (Size i=0; i <= numberSteps_; ++i)
            Discounts_[i][0] = 1.0;


        V_.reserve(numberProducts_);

        Matrix  modelCashFlowIndex(product_->possibleCashFlowTimes().size(), numberRates_+1);


        numberCashFlowsThisIndex_.resize(numberProducts_);

        for (Size i=0; i<numberProducts_; ++i)
        {
            cashFlowsGenerated_[i].resize(
                product_->maxNumberOfCashFlowsPerProductPerStep());

            for (auto& j : cashFlowsGenerated_[i])
                j.amount.resize(numberRates_ + 1);

            numberCashFlowsThisIndex_[i].resize(product_->possibleCashFlowTimes().size());

            V_.push_back(VModel);


            totalCashFlowsThisIndex_.push_back(modelCashFlowIndex);
        }

        LIBORRatios_ = VModel;
        StepsDiscountsSquared_ = VModel;
        LIBORRates_ =VModel;




        const std::vector<Time>& cashFlowTimes =
            product_->possibleCashFlowTimes();
        numberCashFlowTimes_ = cashFlowTimes.size();

        const std::vector<Time>& rateTimes = product_->evolution().rateTimes();
        const std::vector<Time>& evolutionTimes = product_->evolution().evolutionTimes();
        discounters_.reserve(cashFlowTimes.size());

        for (Real cashFlowTime : cashFlowTimes)
            discounters_.emplace_back(cashFlowTime, rateTimes);


        // need to check that we are in money market measure


        // we need to allocate cash-flow times to steps, i.e. what is the last step completed before a flow occurs
        // what we really need is for each step, what cash flow time indices to look at

        cashFlowIndicesThisStep_.resize(numberSteps_);

        for (Size i=0; i < numberCashFlowTimes_; ++i)
        {
            auto it =
                std::upper_bound(evolutionTimes.begin(), evolutionTimes.end(), cashFlowTimes[i]);
            if (it != evolutionTimes.begin())
                --it;
            Size index = it - evolutionTimes.begin();
            cashFlowIndicesThisStep_[index].push_back(i);
        }

        partials_ = Matrix(pseudoRootStructure_->numberOfFactors(),numberRates_);
    }

    Real PathwiseVegasAccountingEngine::singlePathValues(std::vector<Real>& values)
    {

        const std::vector<Real>& initialForwards_(pseudoRootStructure_->initialRates());
        currentForwards_ = initialForwards_;
        // clear accumulation variables
        for (Size i=0; i < numberProducts_; ++i)
        {
            numerairesHeld_[i]=0.0;

            for (Size j=0; j < numberCashFlowTimes_; ++j)
            {
                numberCashFlowsThisIndex_[i][j] =0;

                for (Size k=0; k <= numberRates_; ++k)
                    totalCashFlowsThisIndex_[i][j][k] =0.0;
            }

            for (Size l=0;  l< numberRates_; ++l)
                for (Size m=0; m <= numberSteps_; ++m)
                    V_[i][m][l] =0.0;

            for (Size p=0; p < numberBumps_; ++p)
                vegasThisPath_[i][p] =0.0;

        }



        Real weight = evolver_->startNewPath();
        product_->reset();

        Size thisStep;

        bool done = false;
        do {
            thisStep = evolver_->currentStep();
            Size storeStep = thisStep+1;
            weight *= evolver_->advanceStep();

            done = product_->nextTimeStep(evolver_->currentState(),
                numberCashFlowsThisStep_,
                cashFlowsGenerated_);

            lastForwards_ = currentForwards_;
            currentForwards_ =  evolver_->currentState().forwardRates();

            for (unsigned long i=0; i < numberRates_; ++i)
            {
                Real x=  evolver_->currentState().discountRatio(i+1,i);
                stepsDiscounts_[i+1] = x;
                StepsDiscountsSquared_[storeStep][i] = x*x;

                LIBORRatios_[storeStep][i] = currentForwards_[i]/lastForwards_[i];
                LIBORRates_[storeStep][i] = currentForwards_[i];
                Discounts_[storeStep][i+1] = evolver_->currentState().discountRatio(i+1,0);
            }

            jacobianComputers_[thisStep].getBumps(lastForwards_,
                                         stepsDiscounts_,
                                         currentForwards_,
                                         evolver_->browniansThisStep(),
                                         jacobiansThisPaths_[thisStep]);



            // for each product...
            for (Size i=0; i<numberProducts_; ++i)
            {
                // ...and each cash flow...
                for (Size j=0; j<numberCashFlowsThisStep_[i]; ++j)
                {
                    Size k = cashFlowsGenerated_[i][j].timeIndex;
                    ++numberCashFlowsThisIndex_[i][ k];

                    for (Size l=0; l <= numberRates_; ++l)
                        totalCashFlowsThisIndex_[i][k][l] += cashFlowsGenerated_[i][j].amount[l]*weight;

                }
            }


        } while (!done);

        // ok we've gathered cash-flows, still have to backwards computation

        Size factors = pseudoRootStructure_->numberOfFactors();
        const std::vector<Time>& taus= pseudoRootStructure_->evolution(). rateTaus();

        bool flowsFound = false;

        Integer finalStepDone = thisStep;

        for (Integer currentStep =  numberSteps_-1; currentStep >=0 ; --currentStep) // must be a signed type as we go negative
        {
            Integer stepToUse = std::min<Integer>(currentStep, finalStepDone)+1;

            for (Size k=0; k < cashFlowIndicesThisStep_[currentStep].size(); ++k)
            {
                Size cashFlowIndex =cashFlowIndicesThisStep_[currentStep][k];

                // first check to see if anything actually happened before spending time on computing stuff
                bool noFlows = true;
                for (Size l=0; l < numberProducts_ && noFlows; ++l)
                    noFlows = noFlows && (numberCashFlowsThisIndex_[l][cashFlowIndex] ==0);

                flowsFound = flowsFound || !noFlows;

                if (!noFlows)
                {
                    if (doDeflation_)
                        discounters_[cashFlowIndex].getFactors(LIBORRates_, Discounts_,stepToUse, deflatorAndDerivatives_); // get amount to discount cash flow by and amount to multiply its derivatives by

                    for (Size j=0; j < numberProducts_; ++j)
                    {
                        if (numberCashFlowsThisIndex_[j][cashFlowIndex] > 0)
                        {
                            Real deflatedCashFlow = totalCashFlowsThisIndex_[j][cashFlowIndex][0];
                            if (doDeflation_)
                                deflatedCashFlow *= deflatorAndDerivatives_[0];
                            //cashFlowsGenerated_[j][cashFlowIndex].amount[0]*deflatorAndDerivatives_[0];
                            numerairesHeld_[j] += deflatedCashFlow;

                            for (Size i=1; i <= numberRates_; ++i)
                            {
                                Real thisDerivative =  totalCashFlowsThisIndex_[j][cashFlowIndex][i];
                                if (doDeflation_)
                                {
                                    thisDerivative *= deflatorAndDerivatives_[0];
                                    thisDerivative +=  totalCashFlowsThisIndex_[j][cashFlowIndex][0]*deflatorAndDerivatives_[i];
                                    fullDerivatives_[i-1] = thisDerivative;
                                }
                                else
                                    fullDerivatives_[i-1] = thisDerivative;

                                V_[j][stepToUse][i-1] += thisDerivative; // zeroth row of V is t =0 not t_0
                            }

                            // ok we've got the derivatives and stored them, now add them to vegas
                            // this corresponds to the \frac{\partial F_n}[\partial theta} term
                            // we add the indirect terms later

                            for (Size k=0; k < numberBumps_; ++k)
                                for (Size i=0; i < numberRates_; ++i)
                                {
                                    vegasThisPath_[j][k] +=  fullDerivatives_[i]*jacobiansThisPaths_[stepToUse-1][k][i];
                                }


                        } // end of (numberCashFlowsThisIndex_[j][cashFlowIndex] > 0)
                    } // end of (Size j=0; j < numberProducts_; ++j)
                } // end of  if (!noFlows)
            }

            // need to do backwards updating
            if (flowsFound)
            {
                Integer nextStepToUse  = std::min<Integer>(currentStep-1, finalStepDone);
                Integer nextStepIndex = nextStepToUse+1;
                if (nextStepIndex != stepToUse) // then we need to update V
                {

                    const Matrix& thisPseudoRoot_= pseudoRootStructure_->pseudoRoot(currentStep);

                    for (Size i=0; i < numberProducts_; ++i)
                    {
                        // compute partials
                        for (Size f=0; f < factors; ++f)
                        {
                            Real libor = LIBORRates_[stepToUse][numberRates_-1];
                            Real V = V_[i][stepToUse][numberRates_-1];
                            Real pseudo = thisPseudoRoot_[numberRates_-1][f];
                            Real thisPartialTerm = libor*V*pseudo;
                            partials_[f][numberRates_-1] = thisPartialTerm;

                            for (Integer r = numberRates_-2; r >=0 ; --r)
                            {
                                Real thisPartialTermr = LIBORRates_[stepToUse][r]*V_[i][stepToUse][r]*thisPseudoRoot_[r][f];

                                partials_[f][r] = partials_[f][r+1] + thisPartialTermr;

                            }
                        } // end of (Size f=0; f < factors; ++f)

                        for (Size j=0; j < numberRates_; ++j)
                        {
                            Real nextV = V_[i][stepToUse][j] * LIBORRatios_[stepToUse][j];
                            V_[i][nextStepIndex][j] = nextV;

                            Real summandTerm = 0.0;
                            for (Size f=0; f < factors; ++f)
                                summandTerm += thisPseudoRoot_[j][f]*partials_[f][j];

                            summandTerm *= taus[j]*StepsDiscountsSquared_[stepToUse][j];

                            V_[i][nextStepIndex][j] += summandTerm;

                        } //end of  for (Size j=0; j < numberRates_; ++j)

                    // we've done the Vs now the vegas

                        if (nextStepIndex >0)

                            for (Size l=0; l < numberBumps_; ++l)
                                for (Size j=0; j < numberRates_; ++j)
                                    vegasThisPath_[i][l] +=  V_[i][nextStepIndex][j] * jacobiansThisPaths_[nextStepIndex-1][l][j];


                    } // end of (Size i=0; i < numberProducts_; ++i)



                } //  end of   if (nextStepIndex != stepToUse)
            } // end of  if (flowsFound)

        } // end of  for (Integer currentStep =  numberSteps_-1; currentStep >=0 ; --currentStep)

        // write answer into values

        Size entriesPerProduct = 1+numberRates_+numberBumps_;

        for (Size i=0; i < numberProducts_; ++i)
        {
            values[i*entriesPerProduct] = numerairesHeld_[i]*initialNumeraireValue_;
            for (Size j=0; j < numberRates_; ++j)
                values[i*entriesPerProduct+1+j] = V_[i][0][j]*initialNumeraireValue_;
            for (Size k=0; k < numberBumps_; ++k)
                values[i*entriesPerProduct + numberRates_ +k +1 ] = vegasThisPath_[i][k]*initialNumeraireValue_;
        }

        return 1.0; // we have put the weight in already, this results in lower variance since weight changes along the path
    }

    void PathwiseVegasAccountingEngine::multiplePathValues(std::vector<Real>& means, std::vector<Real>& errors,
        Size numberOfPaths)
    {
        std::vector<Real> values(product_->numberOfProducts()*(1+numberRates_+numberBumps_));
        means.resize(values.size());
        errors.resize(values.size());
        std::vector<Real> sums(values.size(),0.0);
        std::vector<Real> sumsqs(values.size(),0.0);



        for (Size i=0; i<numberOfPaths; ++i)
        {
            /* Real weight = */ singlePathValues(values);
            // stats.add(values,weight);
            for (Size j=0; j < values.size(); ++j)
            {
                sums[j] += values[j];
                sumsqs[j] += values[j]*values[j];

            }
        }

        for (Size j=0; j < values.size(); ++j)
            {
                means[j] = sums[j]/numberOfPaths;
                Real meanSq = sumsqs[j]/numberOfPaths;
                Real variance = meanSq - means[j]*means[j];
                errors[j] = std::sqrt(variance/numberOfPaths);

            }
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    PathwiseVegasOuterAccountingEngine::PathwiseVegasOuterAccountingEngine(
        ext::shared_ptr<LogNormalFwdRateEuler> evolver, // method relies heavily on LMM Euler
        const Clone<MarketModelPathwiseMultiProduct>& product,
        ext::shared_ptr<MarketModel> pseudoRootStructure, // we need pseudo-roots and displacements
        const std::vector<std::vector<Matrix> >& vegaBumps,
        Real initialNumeraireValue)
    : evolver_(std::move(evolver)), product_(product),
      pseudoRootStructure_(std::move(pseudoRootStructure)), vegaBumps_(vegaBumps),
      initialNumeraireValue_(initialNumeraireValue), numberProducts_(product->numberOfProducts()),
      doDeflation_(!product->alreadyDeflated()), numerairesHeld_(product->numberOfProducts()),
      numberCashFlowsThisStep_(product->numberOfProducts()),
      cashFlowsGenerated_(product->numberOfProducts()),
      stepsDiscounts_(pseudoRootStructure_->numberOfRates() + 1),
      elementary_vegas_ThisPath_(product->numberOfProducts()),
      deflatorAndDerivatives_(pseudoRootStructure_->numberOfRates() + 1) {

        stepsDiscounts_[0]=1.0;

        numberRates_ = pseudoRootStructure_->numberOfRates();
        numberSteps_ = pseudoRootStructure_->numberOfSteps();
        factors_ = pseudoRootStructure_->numberOfFactors();
        fullDerivatives_.resize(numberRates_);


        const EvolutionDescription& evolution = pseudoRootStructure_->evolution();
        numeraires_ =  moneyMarketMeasure(evolution);


        QL_REQUIRE(vegaBumps.size() == numberSteps_, "we need precisely one vector of vega bumps for each step.");

        numberBumps_ = vegaBumps[0].size();

       std::vector<Matrix> jacobiansThisPathsModel;
       jacobiansThisPathsModel.reserve(numberRates_);
       for (Size i =0; i < numberRates_; ++i)
           jacobiansThisPathsModel.emplace_back(numberRates_, factors_);


        for (Size i =0; i < numberSteps_; ++i)
        {
            jacobianComputers_.emplace_back(
                pseudoRootStructure_->pseudoRoot(i), evolution.firstAliveRate()[i], numeraires_[i],
                evolution.rateTaus(), pseudoRootStructure_->displacements());

            // vector of vector of matrices to store jacobians of rates with respect to pseudo-root
            // elements
            jacobiansThisPaths_.push_back(jacobiansThisPathsModel);
        }



        Matrix VModel(numberSteps_+1,numberRates_);



        Discounts_ = Matrix(numberSteps_+1,numberRates_+1);

        for (Size i=0; i <= numberSteps_; ++i)
            Discounts_[i][0] = 1.0;


        V_.reserve(numberProducts_);

        Matrix  modelCashFlowIndex(product_->possibleCashFlowTimes().size(), numberRates_+1);


        numberCashFlowsThisIndex_.resize(numberProducts_);

        for (Size i=0; i<numberProducts_; ++i)
        {
            cashFlowsGenerated_[i].resize(
                product_->maxNumberOfCashFlowsPerProductPerStep());

            for (auto& j : cashFlowsGenerated_[i])
                j.amount.resize(numberRates_ + 1);

            numberCashFlowsThisIndex_[i].resize(product_->possibleCashFlowTimes().size());

            V_.push_back(VModel);


            totalCashFlowsThisIndex_.push_back(modelCashFlowIndex);
        }

        LIBORRatios_ = VModel;
        StepsDiscountsSquared_ = VModel;
        LIBORRates_ =VModel;




        const std::vector<Time>& cashFlowTimes =
            product_->possibleCashFlowTimes();
        numberCashFlowTimes_ = cashFlowTimes.size();

        const std::vector<Time>& rateTimes = product_->evolution().rateTimes();
        const std::vector<Time>& evolutionTimes = product_->evolution().evolutionTimes();
        discounters_.reserve(cashFlowTimes.size());

        for (Real cashFlowTime : cashFlowTimes)
            discounters_.emplace_back(cashFlowTime, rateTimes);


        // need to check that we are in money market measure


        // we need to allocate cash-flow times to steps, i.e. what is the last step completed before a flow occurs
        // what we really need is for each step, what cash flow time indices to look at

        cashFlowIndicesThisStep_.resize(numberSteps_);

        for (Size i=0; i < numberCashFlowTimes_; ++i)
        {
            auto it =
                std::upper_bound(evolutionTimes.begin(), evolutionTimes.end(), cashFlowTimes[i]);
            if (it != evolutionTimes.begin())
                --it;
            Size index = it - evolutionTimes.begin();
            cashFlowIndicesThisStep_[index].push_back(i);
        }

        partials_ = Matrix(pseudoRootStructure_->numberOfFactors(),numberRates_);

//      set up this container object        
//        std::vector<std::vector<std::vector<Matrix> >  > elementary_vegas_ThisPath_;  // dimensions are product, step, rate, rate and factor

        { // force destruction of modelVegaMatrix as soon as no longer needed 
            Matrix modelVegaMatrix(numberRates_, factors_,0.0);

            for (Size i=0; i < numberProducts_; ++i)
            {  
                elementary_vegas_ThisPath_[i].resize(numberSteps_);
                for (Size j=0; j < numberSteps_; ++j)
                {
                   
                        elementary_vegas_ThisPath_[i][j]= modelVegaMatrix;
                }
            }
        } // modelVegaMatrix destroyed here 

        numberElementaryVegas_ = numberSteps_*numberRates_*factors_;
/*
        gaussians_.resize(numberSteps_);
        distinguishedFactor_=0;
        distinguishedRate_=0;
        distinguishedStep_=0;
*/
    }

    Real PathwiseVegasOuterAccountingEngine::singlePathValues(std::vector<Real>& values)
    {

        const std::vector<Real>& initialForwards_(pseudoRootStructure_->initialRates());
        currentForwards_ = initialForwards_;
        // clear accumulation variables
        for (Size i=0; i < numberProducts_; ++i)
        {
            numerairesHeld_[i]=0.0;

            for (Size j=0; j < numberCashFlowTimes_; ++j)
            {
                numberCashFlowsThisIndex_[i][j] =0;

                for (Size k=0; k <= numberRates_; ++k)
                    totalCashFlowsThisIndex_[i][j][k] =0.0;
            }

            for (Size l=0;  l< numberRates_; ++l)
                for (Size m=0; m <= numberSteps_; ++m)
                    V_[i][m][l] =0.0;

        }



        Real weight = evolver_->startNewPath();
        product_->reset();

        Size thisStep;

        bool done = false;
        do 
        {
            thisStep = evolver_->currentStep();
            Size storeStep = thisStep+1;
            weight *= evolver_->advanceStep();

            done = product_->nextTimeStep(evolver_->currentState(),
                numberCashFlowsThisStep_,
                cashFlowsGenerated_);

            lastForwards_ = currentForwards_;
            currentForwards_ =  evolver_->currentState().forwardRates();

            for (unsigned long i=0; i < numberRates_; ++i)
            {
                Real x=  evolver_->currentState().discountRatio(i+1,i);
                stepsDiscounts_[i+1] = x;
                StepsDiscountsSquared_[storeStep][i] = x*x;

                LIBORRatios_[storeStep][i] = currentForwards_[i]/lastForwards_[i];
                LIBORRates_[storeStep][i] = currentForwards_[i];
                Discounts_[storeStep][i+1] = evolver_->currentState().discountRatio(i+1,0);
            }

            jacobianComputers_[thisStep].getBumps(lastForwards_,
                                         stepsDiscounts_,
                                         currentForwards_,
                                         evolver_->browniansThisStep(),
                                         jacobiansThisPaths_[thisStep]);

//            gaussians_[thisStep] = evolver_->browniansThisStep();



            // for each product...
            for (Size i=0; i<numberProducts_; ++i)
            {
                // ...and each cash flow...
                for (Size j=0; j<numberCashFlowsThisStep_[i]; ++j)
                {
                    Size k = cashFlowsGenerated_[i][j].timeIndex;
                    ++numberCashFlowsThisIndex_[i][ k];

                    for (Size l=0; l <= numberRates_; ++l)
                        totalCashFlowsThisIndex_[i][k][l] += cashFlowsGenerated_[i][j].amount[l]*weight;

                }
            }


        } while (!done);

        // ok we've gathered cash-flows, still have to backwards computation

        Size factors = pseudoRootStructure_->numberOfFactors();
        const std::vector<Time>& taus= pseudoRootStructure_->evolution(). rateTaus();

        bool flowsFound = false;

        Integer finalStepDone = thisStep;

        for (Integer currentStep =  numberSteps_-1; currentStep >=0 ; --currentStep) // must be a signed type as we go negative
        {
            Integer stepToUse = std::min<Integer>(currentStep, finalStepDone)+1;

            for (Size k=0; k < cashFlowIndicesThisStep_[currentStep].size(); ++k)
            {
                Size cashFlowIndex =cashFlowIndicesThisStep_[currentStep][k];

                // first check to see if anything actually happened before spending time on computing stuff
                bool noFlows = true;
                for (Size l=0; l < numberProducts_ && noFlows; ++l)
                    noFlows = noFlows && (numberCashFlowsThisIndex_[l][cashFlowIndex] ==0);

                flowsFound = flowsFound || !noFlows;

                if (!noFlows)
                {
                    if (doDeflation_)
                        discounters_[cashFlowIndex].getFactors(LIBORRates_, Discounts_,stepToUse, deflatorAndDerivatives_); // get amount to discount cash flow by and amount to multiply its derivatives by

                    for (Size j=0; j < numberProducts_; ++j)
                    {
                        if (numberCashFlowsThisIndex_[j][cashFlowIndex] > 0)
                        {
                            Real deflatedCashFlow = totalCashFlowsThisIndex_[j][cashFlowIndex][0];
                            if (doDeflation_)
                                deflatedCashFlow *= deflatorAndDerivatives_[0];
                            //cashFlowsGenerated_[j][cashFlowIndex].amount[0]*deflatorAndDerivatives_[0];
                            numerairesHeld_[j] += deflatedCashFlow;

                            for (Size i=1; i <= numberRates_; ++i)
                            {
                                Real thisDerivative =  totalCashFlowsThisIndex_[j][cashFlowIndex][i];
                                if (doDeflation_)
                                {
                                    thisDerivative *= deflatorAndDerivatives_[0];
                                    thisDerivative +=  totalCashFlowsThisIndex_[j][cashFlowIndex][0]*deflatorAndDerivatives_[i];
                                    fullDerivatives_[i-1] = thisDerivative;
                                }
                                else
                                    fullDerivatives_[i-1] = thisDerivative;

                                V_[j][stepToUse][i-1] += thisDerivative; // zeroth row of V is t =0 not t_0
                            } // end of  for (Size i=1; i <= numberRates_; ++i)
                        } // end of (numberCashFlowsThisIndex_[j][cashFlowIndex] > 0)
                    } // end of (Size j=0; j < numberProducts_; ++j)
                } // end of  if (!noFlows)
            }

            // need to do backwards updating
            if (flowsFound)
            {
                Integer nextStepToUse  = std::min<Integer>(currentStep-1, finalStepDone);
                Integer nextStepIndex = nextStepToUse+1;
                if (nextStepIndex != stepToUse) // then we need to update V
                {

                    const Matrix& thisPseudoRoot_= pseudoRootStructure_->pseudoRoot(currentStep);

                    for (Size i=0; i < numberProducts_; ++i)
                    {
                        // compute partials
                        for (Size f=0; f < factors; ++f)
                        {
                            Real libor = LIBORRates_[stepToUse][numberRates_-1];
                            Real V = V_[i][stepToUse][numberRates_-1];
                            Real pseudo = thisPseudoRoot_[numberRates_-1][f];
                            Real thisPartialTerm = libor*V*pseudo;
                            partials_[f][numberRates_-1] = thisPartialTerm;

                            for (Integer r = numberRates_-2; r >=0 ; --r)
                            {
                                Real thisPartialTermr = LIBORRates_[stepToUse][r]*V_[i][stepToUse][r]*thisPseudoRoot_[r][f];

                                partials_[f][r] = partials_[f][r+1] + thisPartialTermr;

                            }
                        } // end of (Size f=0; f < factors; ++f)

                        for (Size j=0; j < numberRates_; ++j)
                        {
                            Real nextV = V_[i][stepToUse][j] * LIBORRatios_[stepToUse][j];
                            V_[i][nextStepIndex][j] = nextV;

                            Real summandTerm = 0.0;
                            for (Size f=0; f < factors; ++f)
                                summandTerm += thisPseudoRoot_[j][f]*partials_[f][j];

                            summandTerm *= taus[j]*StepsDiscountsSquared_[stepToUse][j];

                            V_[i][nextStepIndex][j] += summandTerm;

                        } //end of  for (Size j=0; j < numberRates_; ++j)

                    } // end of (Size i=0; i < numberProducts_; ++i)

                } //  end of   if (nextStepIndex != stepToUse)

            } // end of  if (flowsFound)

        } // end of  for (Integer currentStep =  numberSteps_-1; currentStep >=0 ; --currentStep)


        // all V matrices computed we now compute the elementary vegas for this path 

        for (Size i=0; i < numberProducts_; ++i)
        {
                for (Size j=0; j < numberSteps_; ++j)
                {
                    Size nextIndex = j+1;

                    // we know V, we need to pair against the senstivity of the rate to the elementary vega
                    // note the simplification here arising from the fact that the elementary vega affects the evolution on precisely one step

                    for (Size k=0; k < numberRates_; ++k)
                        for (Size f=0; f < factors_; ++f)
                        {
                                Real sensitivity =0.0;

                                for (Size r=0; r < numberRates_; ++r)
                                {
                                        sensitivity += V_[i][nextIndex][r]*jacobiansThisPaths_[j][r][k][f];

                                  }
/*
                                  if (j ==distinguishedStep_ && k ==distinguishedRate_ &&f== distinguishedFactor_)
                                      std::cout << sensitivity << "," <<  jacobiansThisPaths_[j][j][k][f] << "," << gaussians_[j][f] << "," << V_[i][nextIndex][j] << "," << LIBORRates_[nextIndex][j] << "\n";
  */                


                                elementary_vegas_ThisPath_[i][j][k][f] = sensitivity;
                        }
                }
        }


        // write answer into values

        Size entriesPerProduct = 1+numberRates_+numberElementaryVegas_;

        for (Size i=0; i < numberProducts_; ++i)
        {
            values[i*entriesPerProduct] = numerairesHeld_[i]*initialNumeraireValue_;
            for (Size j=0; j < numberRates_; ++j)
                values[i*entriesPerProduct+1+j] = V_[i][0][j]*initialNumeraireValue_;

            for (Size k=0; k < numberSteps_; ++k)
                for (Size l=0; l < numberRates_; ++l)
                    for (Size m=0; m < factors_; ++m)
                        values[i*entriesPerProduct + numberRates_ +1 + m+ l*factors_ + k*numberRates_*factors_] = elementary_vegas_ThisPath_[i][k][l][m]*initialNumeraireValue_;

        }

        return 1.0; // we have put the weight in already, this results in lower variance since weight changes along the path
    
}

    void PathwiseVegasOuterAccountingEngine::multiplePathValuesElementary(std::vector<Real>& means, std::vector<Real>& errors,
        Size numberOfPaths)
    {
        Size numberOfElementaryVegas = numberRates_*numberSteps_*factors_;

        std::vector<Real> values(product_->numberOfProducts()*(1+numberRates_+numberOfElementaryVegas));
        means.resize(values.size());
        errors.resize(values.size());
        std::vector<Real> sums(values.size(),0.0);
        std::vector<Real> sumsqs(values.size(),0.0);



        for (Size i=0; i<numberOfPaths; ++i)
        {
          singlePathValues(values);
          
          for (Size j=0; j < values.size(); ++j)
            {
                sums[j] += values[j];
                sumsqs[j] += values[j]*values[j];

            }
        }

        for (Size j=0; j < values.size(); ++j)
            {
                means[j] = sums[j]/numberOfPaths;
                Real meanSq = sumsqs[j]/numberOfPaths;
                Real variance = meanSq - means[j]*means[j];
                errors[j] = std::sqrt(variance/numberOfPaths);

            }
    }

        void PathwiseVegasOuterAccountingEngine::multiplePathValues(std::vector<Real>& means, std::vector<Real>& errors,Size numberOfPaths)
        {
            std::vector<Real> allMeans;
            std::vector<Real> allErrors;

            multiplePathValuesElementary(allMeans,allErrors,numberOfPaths);

            Size outDataPerProduct = 1+numberRates_+numberBumps_;
            Size inDataPerProduct = 1+numberRates_+numberElementaryVegas_;

            means.resize((1+numberRates_+numberBumps_)*numberProducts_);
            errors.resize((1+numberRates_+numberBumps_)*numberProducts_); // post linear combinations, errors are not meaningful so don't attempt to compute s.e.s for vegas

            for (Size p=0; p < numberProducts_; ++p)
            {
                for (Size i=0; i < 1 + numberRates_; ++i)
                {
                      means[i+p*outDataPerProduct] = allMeans[i+p*inDataPerProduct];
                      errors[i+p*outDataPerProduct] = allErrors[i+p*inDataPerProduct];
                }

               for (Size bump=0; bump<numberBumps_; ++bump)
                {
                    Real thisVega=0.0;


                    for (Size t=0; t < numberSteps_; ++t)
                        for (Size r=0; r < numberRates_; ++r)
                            for (Size f=0; f < factors_; ++f)
                                thisVega+= vegaBumps_[t][bump][r][f]*allMeans[p*inDataPerProduct+1+numberRates_+t*numberRates_*factors_+r*factors_+f];


                    means[p*outDataPerProduct+1+numberRates_+bump] = thisVega;
               }
                    
            }

        } // end of method

} // end of namespace









]]></document_content>
  </document>
  <document index="67">
    <source>marketmodels/pathwisediscounter.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/
#include <ql/models/marketmodels/pathwisediscounter.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <algorithm>

namespace QuantLib
{

MarketModelPathwiseDiscounter::MarketModelPathwiseDiscounter(Time paymentTime,
                              const std::vector<Time>& rateTimes)
{
    checkIncreasingTimes(rateTimes);

    numberRates_ = rateTimes.size()-1;
        before_ = std::lower_bound(rateTimes.begin(), rateTimes.end(),
                                   paymentTime) - rateTimes.begin();

        // handle the case where the payment is in the last
        // period or after the last period
        if (before_ > rateTimes.size()-2)
            before_ =  rateTimes.size()-2;

        beforeWeight_=1.0-(paymentTime-rateTimes[before_])/
            (rateTimes[before_+1]-rateTimes[before_]);

        postWeight_  = 1.0 - beforeWeight_;
        taus_.resize(numberRates_);

        for (Size i=0; i < numberRates_; ++i)
            taus_[i] = rateTimes[i+1] - rateTimes[i];

}

void MarketModelPathwiseDiscounter::getFactors(
            const Matrix& , // LIBORRates, for all steps
            const Matrix& Discounts, // P(t_0, t_j) for j=0,...n for each step
            Size currentStep,
            std::vector<Real>& factors) const
{
    Real preDF = Discounts[currentStep][before_];
    Real postDF = Discounts[currentStep][before_+1];

    for (Size i=before_+1; i<numberRates_; ++i)
        factors[i+1] =0.0;

    if (postWeight_==0.0)
    {
        factors[0] = preDF;

        for (Size i=0; i<before_; ++i)
            factors[i+1] = -preDF*taus_[i]*Discounts[currentStep][i+1]/Discounts[currentStep][i];

        factors[before_+1]=0.0;

        return;
    }

    Real df = preDF * std::pow(postDF/preDF, postWeight_);

    factors[0] = df;

    for (Size i=0; i<=before_; ++i)
       factors[i+1] = -df*taus_[i]*Discounts[currentStep][i+1]/Discounts[currentStep][i];

    factors[before_+1] *= postWeight_;
}
}
]]></document_content>
  </document>
  <document index="68">
    <source>marketmodels/pathwisegreeks/bumpinstrumentjacobian.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*

Copyright (C) 2008 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/pathwisegreeks/bumpinstrumentjacobian.hpp>
#include <ql/math/matrixutilities/basisincompleteordered.hpp>
#include <ql/models/marketmodels/pathwisegreeks/swaptionpseudojacobian.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>

namespace QuantLib
{   


    VolatilityBumpInstrumentJacobian::VolatilityBumpInstrumentJacobian(const VegaBumpCollection& bumps,
        const std::vector<Swaption>& swaptions,
        const std::vector<Cap>& caps)
        : bumps_(bumps), swaptions_(swaptions), caps_(caps), computed_(false,swaptions.size()+caps.size()),
        derivatives_(swaptions.size()+caps.size(),std::vector<Real>(bumps.numberBumps())),
        bumpMatrix_(swaptions.size()+caps.size(),bumps_.numberBumps())
    {
        onePercentBumps_ = derivatives_;
        allComputed_=false;

    }

    std::vector<Real> VolatilityBumpInstrumentJacobian::derivativesVolatility(Size j) const {
        QL_REQUIRE(j < swaptions_.size()+caps_.size(), "too high index passed to VolatilityBumpInstrumentJacobian::derivativesVolatility");

        if (computed_[j])
            return derivatives_[j];

        derivatives_[j].resize(bumps_.numberBumps());
        onePercentBumps_[j].resize(bumps_.numberBumps());


        Real sizesq=0.0;
        computed_[j] = true;

        Size initj = j;

        if ( j < swaptions_.size()) // ok its a swaptions
        {
            SwaptionPseudoDerivative thisPseudo(bumps_.associatedModel(), swaptions_[j].startIndex_,swaptions_[j].endIndex_);

            for (Size k=0;  k < bumps_.numberBumps(); ++k)
            {
                Real v =0.0;

                for (Size i= bumps_.allBumps()[k].stepBegin(); i < bumps_.allBumps()[k].stepEnd(); ++i)
                {
                    const Matrix& fullDerivative = thisPseudo.volatilityDerivative(i);
                    for (Size f= bumps_.allBumps()[k].factorBegin(); f < bumps_.allBumps()[k].factorEnd(); ++f)
                        for (Size r= bumps_.allBumps()[k].rateBegin(); r < bumps_.allBumps()[k].rateEnd(); ++r)
                            v += fullDerivative[r][f];
                }

                derivatives_[j][k] =v;
                sizesq+= v*v;
            }

        }
        else // its a cap 
        {
            j-= swaptions_.size();

            
            CapPseudoDerivative thisPseudo(bumps_.associatedModel(), caps_[j].strike_, caps_[j].startIndex_,caps_[j].endIndex_,1.0); // ifrst df shouldn't make any difference

           

            for (Size k=0;  k < bumps_.numberBumps(); ++k)
            {
                Real v =0.0;

                for (Size i= bumps_.allBumps()[k].stepBegin(); i < bumps_.allBumps()[k].stepEnd(); ++i)
                {
                    const Matrix& fullDerivative = thisPseudo.volatilityDerivative(i);
                    for (Size f= bumps_.allBumps()[k].factorBegin(); f < bumps_.allBumps()[k].factorEnd(); ++f)
                        for (Size r= bumps_.allBumps()[k].rateBegin(); r < bumps_.allBumps()[k].rateEnd(); ++r)
                            v += fullDerivative[r][f];
                }

                sizesq += v*v;

                derivatives_[initj][k] =v;
            }

        }

        for (Size k=0; k < bumps_.numberBumps(); ++k)
        {
            bumpMatrix_[initj][k] = onePercentBumps_[initj][k] = 0.01 * derivatives_[initj][k]/sizesq;

        }



     return derivatives_[initj];
    }


    std::vector<Real> VolatilityBumpInstrumentJacobian::onePercentBump(Size j) const {
        derivativesVolatility(j); 
    
        return onePercentBumps_[j];
    }

    const Matrix& VolatilityBumpInstrumentJacobian::getAllOnePercentBumps() const
    {
        if (!allComputed_)
             for (Size i=0; i <swaptions_.size()+caps_.size(); ++i)
                derivativesVolatility(i);

        allComputed_ =true;


        return bumpMatrix_;
    }



    OrthogonalizedBumpFinder::OrthogonalizedBumpFinder(const VegaBumpCollection& bumps,
                                     const std::vector<VolatilityBumpInstrumentJacobian::Swaption>& swaptions,
                                     const std::vector<VolatilityBumpInstrumentJacobian::Cap>& caps,
                                     Real multiplierCutOff,
                                     Real tolerance) : 
                                                        derivativesProducer_(bumps,swaptions,caps), 
                                                        multiplierCutOff_(multiplierCutOff), 
                                                        tolerance_(tolerance)
    {
        


    }

    void OrthogonalizedBumpFinder::GetVegaBumps(std::vector<std::vector<Matrix> >& theBumps) const
    {
        OrthogonalProjections projector(derivativesProducer_.getAllOnePercentBumps(),
                                                            multiplierCutOff_,
                                                             tolerance_  );


        Size numberRestrictedBumps(projector.numberValidVectors());

        ext::shared_ptr<MarketModel> marketmodel(derivativesProducer_.getInputBumps().associatedModel());
        const EvolutionDescription& evolution(marketmodel->evolution());

        Size numberSteps = evolution.numberOfSteps();
        Size numberRates = evolution.numberOfRates();
        Size factors = marketmodel->numberOfFactors();

        theBumps.resize(numberSteps);
       // recall that the bumps: We do the outermost vector by time step and inner one by which vega.

        for (auto& theBump : theBumps)
            theBump.resize(numberRestrictedBumps);

        Matrix modelMatrix(numberRates, factors,0.0);

        for (Size i=0;  i< numberSteps; ++i)
            for (Size j=0; j < numberRestrictedBumps; ++j)
                theBumps[i][j] = modelMatrix;

        const std::vector<VegaBumpCluster>& bumpClusters(derivativesProducer_.getInputBumps().allBumps());


        Size bumpIndex =0;

        for (Size instrument=0; instrument < projector.validVectors().size(); ++instrument)
        {
            if (projector.validVectors()[instrument])
            {
                for (Size cluster =0; cluster< bumpClusters.size(); ++cluster)
                {
                    Real magnitude = projector.GetVector(instrument)[cluster];

                    for (Size step = bumpClusters[cluster].stepBegin(); step <  bumpClusters[cluster].stepEnd(); ++step)
                        for (Size rate = bumpClusters[cluster].rateBegin(); rate < bumpClusters[cluster].rateEnd(); ++rate)
                            for (Size factor = bumpClusters[cluster].factorBegin(); factor <  bumpClusters[cluster].factorEnd(); ++factor)
                                theBumps[step][bumpIndex][rate][factor] = magnitude;
                }

                ++bumpIndex;


            }

        }



    }
}
]]></document_content>
  </document>
  <document index="69">
    <source>marketmodels/pathwisegreeks/ratepseudorootjacobian.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*

Copyright (C) 2008 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/



#include <ql/models/marketmodels/pathwisegreeks/ratepseudorootjacobian.hpp>
#include <utility>

namespace QuantLib
{


    RatePseudoRootJacobianNumerical::RatePseudoRootJacobianNumerical(const Matrix& pseudoRoot,
        Size aliveIndex,
        Size numeraire,
        const std::vector<Time>& taus,
        const std::vector<Matrix>& pseudoBumps,
        const std::vector<Spread>& displacements)
        :
    pseudoRoot_(pseudoRoot),
        aliveIndex_(aliveIndex),
        taus_(taus),
        displacements_(displacements),
        numberBumps_(pseudoBumps.size()),
        factors_(pseudoRoot.columns()),
        drifts_(taus.size()),
        bumpedRates_(taus.size())
    {
        Size numberRates= taus.size();

        QL_REQUIRE(pseudoRoot_.rows()==numberRates,
            "pseudoRoot_.rows()<> taus.size()");

        QL_REQUIRE(displacements_.size()==numberRates,
            "displacements_.size()<> taus.size()");

        QL_REQUIRE(drifts_.size()==numberRates,
            "drifts_.size()<> taus.size()");

        for (Size i=0; i < pseudoBumps.size(); ++i)
        {
            QL_REQUIRE(pseudoBumps[i].rows()==numberRates,
                "pseudoBumps[i].rows()<> taus.size() with i =" << i);

            QL_REQUIRE(pseudoBumps[i].columns()==factors_,
                "pseudoBumps[i].columns()<> factors with i = " << i);


            Matrix pseudo(pseudoRoot_);
            pseudo += pseudoBumps[i];
            pseudoBumped_.push_back(pseudo);
            driftsComputers_.emplace_back(pseudo, displacements, taus, numeraire, aliveIndex);
        }

    }


    void RatePseudoRootJacobianNumerical::getBumps(const std::vector<Rate>& oldRates,
        const std::vector<Real>& , // not used in the numerical implementation
        const std::vector<Rate>& newRates,
        const std::vector<Real>& gaussians,
        Matrix& B)
    {
        Size numberRates = taus_.size();

        QL_REQUIRE(B.rows()==numberBumps_,
            "B.rows()<> numberBumps_");

        QL_REQUIRE(B.columns()==taus_.size(),
            "B.columns()<> number of rates");

        for (Size i =0; i < numberBumps_; ++i)
        {
            const Matrix& pseudo = pseudoBumped_[i];
            driftsComputers_[i].compute(oldRates,
                drifts_);

            for (Size j =0; j < aliveIndex_; ++j)
                B[i][j]=0.0;

            for (Size j=aliveIndex_; j < numberRates; ++j)
            {
                bumpedRates_[j] = std::log(oldRates[j]+displacements_[j]);

                for (Size k=0; k < factors_; ++k)
                    bumpedRates_[j] += -0.5*pseudo[j][k]*pseudo[j][k];

                bumpedRates_[j] +=drifts_[j];

                for (Size k=0; k < factors_; ++k)
                    bumpedRates_[j] += pseudo[j][k]*gaussians[k];

                bumpedRates_[j] = std::exp(bumpedRates_[j]);
                bumpedRates_[j] -= displacements_[j];
                Real tmp = bumpedRates_[j] - newRates[j];

                B[i][j] =  tmp;
            }
        }

    }

    RatePseudoRootJacobian::RatePseudoRootJacobian(const Matrix& pseudoRoot,
                                                   Size aliveIndex,
                                                   Size numeraire,
                                                   const std::vector<Time>& taus,
                                                   const std::vector<Matrix>& pseudoBumps,
                                                   std::vector<Spread> displacements)
    : pseudoRoot_(pseudoRoot), aliveIndex_(aliveIndex), taus_(taus), pseudoBumps_(pseudoBumps),
      displacements_(std::move(displacements)), numberBumps_(pseudoBumps.size()),
      factors_(pseudoRoot.columns()),
      //   bumpedRates_(taus.size()),
      e_(pseudoRoot.rows(), pseudoRoot.columns()), ratios_(taus_.size()) {
        Size numberRates= taus.size();

        QL_REQUIRE(aliveIndex == numeraire,
            "we can do only do discretely compounding MM acount so aliveIndex must equal numeraire");

        QL_REQUIRE(pseudoRoot_.rows()==numberRates,
            "pseudoRoot_.rows()<> taus.size()");

        QL_REQUIRE(displacements_.size()==numberRates,
            "displacements_.size()<> taus.size()");


        for (Size i=0; i < pseudoBumps.size(); ++i)
        {
            QL_REQUIRE(pseudoBumps[i].rows()==numberRates,
                "pseudoBumps[i].rows()<> taus.size() with i =" << i);

            QL_REQUIRE(pseudoBumps[i].columns()==factors_,
                "pseudoBumps[i].columns()<> factors with i = " << i);




        }

        for (Size i=0; i < numberRates; ++i)
        {
            allDerivatives_.emplace_back(numberRates, factors_);
        }
    }


    void RatePseudoRootJacobian::getBumps(const std::vector<Rate>& oldRates,
        const std::vector<Real>& discountRatios,
        const std::vector<Rate>& newRates,
        const std::vector<Real>& gaussians,
        Matrix& B)
    {
          Size numberRates = taus_.size();

         QL_REQUIRE(B.rows() == numberBumps_, "we need B.rows() which is " << B.rows() << " to equal numberBumps_ which is "  << numberBumps_);
         QL_REQUIRE(B.columns() == numberRates, "we need B.columns() which is " << B.columns() << " to equal numberRates which is "  << numberRates);


        for (Size j=aliveIndex_; j < numberRates; ++j)
            ratios_[j] = (oldRates[j] + displacements_[j])*discountRatios[j+1];

        for (Size f=0; f < factors_; ++f)
        {
            e_[aliveIndex_][f] = 0;

            for (Size j= aliveIndex_+1; j < numberRates; ++j)
                e_[j][f] = e_[j-1][f] + ratios_[j-1]*pseudoRoot_[j-1][f];
        }


        for (Size f=0; f < factors_; ++f)
            for (Size j=aliveIndex_; j < numberRates; ++j)
            {
                for (Size k= aliveIndex_; k < j ; ++k)
                    allDerivatives_[j][k][f] = newRates[j]*ratios_[k]*taus_[k]*pseudoRoot_[j][f];

                // GG don't seem to have the 2, this term is miniscule in any case
                Real tmp = //2*
                    2*ratios_[j]*taus_[j]*pseudoRoot_[j][f];
                tmp -=  pseudoRoot_[j][f];
                tmp += e_[j][f]*taus_[j];
                tmp += gaussians[f];
                tmp *= (newRates[j]+displacements_[j]);


                allDerivatives_[j][j][f] =tmp;

                for (Size k= j+1; k < numberRates ; ++k)
                    allDerivatives_[j][k][f]=0.0;


            }


        for (Size i =0; i < numberBumps_; ++i)
        {
            Size j=0;

            for (; j < aliveIndex_; ++j)
            {
                B[i][j]=0.0;
            }
            for (; j < numberRates; ++j)
            {
                Real sum =0.0;

                for (Size k=aliveIndex_; k < numberRates; ++k)
                    for (Size f=0; f < factors_; ++f)
                        sum += pseudoBumps_[i][k][f]*allDerivatives_[j][k][f];
                B[i][j] =sum;

            }
        }

    }

    RatePseudoRootJacobianAllElements::RatePseudoRootJacobianAllElements(
        const Matrix& pseudoRoot,
        Size aliveIndex,
        Size numeraire,
        const std::vector<Time>& taus,
        std::vector<Spread> displacements)
    : pseudoRoot_(pseudoRoot), aliveIndex_(aliveIndex), taus_(taus),
      displacements_(std::move(displacements)), factors_(pseudoRoot.columns()),
      //   bumpedRates_(taus.size()),
      e_(pseudoRoot.rows(), pseudoRoot.columns()), ratios_(taus_.size()) {
        Size numberRates= taus.size();

        QL_REQUIRE(aliveIndex == numeraire,
            "we can do only do discretely compounding MM acount so aliveIndex must equal numeraire");

        QL_REQUIRE(pseudoRoot_.rows()==numberRates,
            "pseudoRoot_.rows()<> taus.size()");

        QL_REQUIRE(displacements_.size()==numberRates,
            "displacements_.size()<> taus.size()");
    }


    void RatePseudoRootJacobianAllElements::getBumps(const std::vector<Rate>& oldRates,
        const std::vector<Real>& discountRatios,
        const std::vector<Rate>& newRates,
        const std::vector<Real>& gaussians,
        std::vector<Matrix>& B)
    {
          Size numberRates = taus_.size();

           QL_REQUIRE(B.size() == numberRates, "we need B.size() which is " << B.size() << " to equal numberRates which is "  << numberRates);
           for (auto& j : B)
               QL_REQUIRE(j.columns() == factors_ && j.rows() == numberRates,
                          "we need B[j].rows() which is "
                              << j.rows() << " to equal numberRates which is " << numberRates
                              << " and B[j].columns() which is " << j.columns()
                              << " to be equal to factors which is " << factors_);


           for (Size j = aliveIndex_; j < numberRates; ++j)
               ratios_[j] = (oldRates[j] + displacements_[j]) * discountRatios[j + 1];

           for (Size f = 0; f < factors_; ++f) {
               e_[aliveIndex_][f] = 0;

               for (Size j = aliveIndex_ + 1; j < numberRates; ++j)
                   e_[j][f] = e_[j - 1][f] + ratios_[j - 1] * pseudoRoot_[j - 1][f];
        }

        // nullify B for rates that have already reset
        for (Size j=0; j < aliveIndex_; ++j)
            for (Size k=0; k < numberRates; ++k)
                for (Size f=0; f < factors_; ++f)
                      B[j][k][f] =0.0;


        for (Size f=0; f < factors_; ++f)
            for (Size j=aliveIndex_; j < numberRates; ++j)
            {
                for (Size k= aliveIndex_; k < j ; ++k)
                    B[j][k][f] = newRates[j]*ratios_[k]*taus_[k]*pseudoRoot_[j][f];

                Real tmp = 2*ratios_[j]*taus_[j]*pseudoRoot_[j][f];
                tmp -=  pseudoRoot_[j][f];
                tmp += e_[j][f]*taus_[j];
                tmp += gaussians[f];
                tmp *= (newRates[j]+displacements_[j]);


                B[j][j][f] =tmp;

                for (Size k= 0; k < aliveIndex_ ; ++k)
                    B[j][k][f]=0.0;

                for (Size k= j+1; k < numberRates ; ++k)
                    B[j][k][f]=0.0;


            }
    }

    
}




]]></document_content>
  </document>
  <document index="70">
    <source>marketmodels/pathwisegreeks/swaptionpseudojacobian.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*

Copyright (C) 2008 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/



#include <ql/models/marketmodels/pathwisegreeks/swaptionpseudojacobian.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/swapforwardmappings.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/math/solvers1d/brent.hpp>


namespace QuantLib
{

    SwaptionPseudoDerivative::SwaptionPseudoDerivative(
        const ext::shared_ptr<MarketModel>& inputModel, Size startIndex, Size endIndex) {
        std::vector<Real> subRateTimes(inputModel->evolution().rateTimes().begin()+startIndex, 
            inputModel->evolution().rateTimes().begin()+endIndex+1);

        std::vector<Real> subForwards(inputModel->initialRates().begin()+startIndex,inputModel->initialRates().begin()+endIndex);

        LMMCurveState cs(subRateTimes);
        cs.setOnForwardRates(subForwards);

        Matrix zed(SwapForwardMappings::coterminalSwapZedMatrix(cs,inputModel->displacements()[0]));
        Size factors = inputModel->numberOfFactors();


        //first compute variance and implied vol

        variance_=0.0;
        Size index=0;

        while (index <  inputModel->evolution().numberOfSteps() && inputModel->evolution().firstAliveRate()[index] <= startIndex)
        {   
            const Matrix& thisPseudo = inputModel->pseudoRoot(index);

            Real thisVariance_ =0.0;
            for (Size j=startIndex; j < endIndex; ++j)
                for (Size k=startIndex; k < endIndex; ++k)
                    for (Size f=0; f < factors; ++f)
                        thisVariance_+= zed[0][j-startIndex]*thisPseudo[j][f]*thisPseudo[k][f]*zed[0][k-startIndex];

            variance_ += thisVariance_;

            ++index;
        }

        Size stopIndex = index;

        expiry_ = subRateTimes[0];

        impliedVolatility_ = std::sqrt(variance_/expiry_);

        Real scale = 0.5*(1.0/expiry_)/impliedVolatility_;

        Size numberRates = inputModel->evolution().numberOfRates();

        Matrix thisDerivative(numberRates, factors,0.0);
        Matrix nullDerivative(numberRates, factors,0.0);

        index =0;

        while (index < stopIndex)
        {
            const Matrix& thisPseudo = inputModel->pseudoRoot(index);

            for (Size rate=startIndex; rate<endIndex; ++rate)
            {
                Size zIndex = rate -startIndex;
                for (Size f =0; f < factors; ++f)
                {
                    Real sum=0.0;
                    for (Size rate2 = startIndex; rate2<endIndex; ++rate2)
                    {
                        Size zIndex2 = rate2-startIndex;
                        sum += zed[0][zIndex2] * thisPseudo[rate2][f];
                    }
                    sum *= 2.0*zed[0][zIndex];

                    thisDerivative[rate][f] =sum;

                }
            }

            varianceDerivatives_.push_back(thisDerivative);

            for ( Size rate=startIndex; rate<endIndex; ++rate)
                for (Size f =0; f < factors; ++f)
                    thisDerivative[rate][f] *= scale;

            volatilityDerivatives_.push_back(thisDerivative);     

            ++index;
        }

        for (; index < inputModel->evolution().numberOfSteps(); ++index)
        {
            varianceDerivatives_.push_back(nullDerivative);
            volatilityDerivatives_.push_back(nullDerivative);

        }





    }

    const Matrix& SwaptionPseudoDerivative::varianceDerivative(Size i) const
    {
        return varianceDerivatives_[i];
    }

    const Matrix& SwaptionPseudoDerivative::volatilityDerivative(Size i) const
    {
        return volatilityDerivatives_[i];
    }

    Real SwaptionPseudoDerivative::impliedVolatility() const
    {
        return impliedVolatility_;
    }
    Real SwaptionPseudoDerivative::variance() const
    {
        return variance_;
    }
    Real SwaptionPseudoDerivative::expiry() const
    {
        return expiry_;
    }

    namespace
    {

        // this class doesn't copy anything so fast to create and use
        // but make sure everything it uses stays in scope... 
        class QuickCap
        {
        public:
            QuickCap(Real Strike,
                const std::vector<Real>& annuities,
                const std::vector<Real>& currentRates,
                const std::vector<Real>& expiries,
                Real price);

            Real operator()(Real volatility) const; // returns difference from input price

            Real vega(Real volatility) const; // returns vol derivative



        private:
            Real strike_;
            const std::vector<Real>& annuities_;
            const std::vector<Real>& currentRates_;
            const std::vector<Real>& expiries_;
            Real price_;

        };

        QuickCap::QuickCap(Real Strike,
            const std::vector<Real>& annuities,
            const std::vector<Real>& currentRates,
            const std::vector<Real>& expiries,
            Real price)
            :
        strike_(Strike),
            annuities_(annuities),
            currentRates_(currentRates),
            expiries_(expiries),
            price_(price)
        {
        }

        Real QuickCap::operator()(Real volatility) const
        {
            Real price =0.0;
            for (Size i=0; i < annuities_.size(); ++i)
            {
                price += blackFormula(Option::Call,strike_,
                    currentRates_[i],
                    volatility*std::sqrt(expiries_[i]),
                    annuities_[i]);


            }
            return price-price_;
        }

        Real QuickCap::vega(Real volatility) const // returns vol derivative
        {
            Real vega =0.0;
            for (Size i=0; i < annuities_.size(); ++i)
            {
         

                vega+= blackFormulaVolDerivative(strike_,currentRates_[i],
                                                 
                                                 volatility*std::sqrt(expiries_[i]),
                                                 expiries_[i],
                                                 annuities_[i],
                                                 0.0);
            }

            return vega;
        }



    }

    CapPseudoDerivative::CapPseudoDerivative(const ext::shared_ptr<MarketModel>& inputModel,
                                             Real strike,
                                             Size startIndex,
                                             Size endIndex,
                                             Real firstDF)
    : firstDF_(firstDF) {
        QL_REQUIRE(startIndex < endIndex, "for a cap pseudo derivative the start of the cap must be before the end");
        QL_REQUIRE( endIndex <= inputModel->numberOfRates(), "for a cap pseudo derivative the end of the cap must before the end of the rates");

        Size numberCaplets = endIndex-startIndex;
        Size numberRates = inputModel->numberOfRates();
        Size factors = inputModel->numberOfFactors();
        LMMCurveState curve(inputModel->evolution().rateTimes());
        curve.setOnForwardRates(inputModel->initialRates());

        const Matrix& totalCovariance(inputModel->totalCovariance(inputModel->numberOfSteps()-1));

        std::vector<Real> displacedImpliedVols(numberCaplets);
        std::vector<Real> annuities(numberCaplets);
        std::vector<Real> initialRates(numberCaplets);
        std::vector<Real> expiries(numberCaplets);

        Real capPrice =0.0;

        Real guess=0.0;
        Real minVol = 1e10;
        Real maxVol =0.0;

        for (Size j = startIndex; j < endIndex; ++j)
        {
            Size capletIndex = j - startIndex;
            Time resetTime = inputModel->evolution().rateTimes()[j];
            expiries[capletIndex] =  resetTime;

            Real sd = std::sqrt(totalCovariance[j][j]);
            displacedImpliedVols[capletIndex] = std::sqrt(totalCovariance[j][j]/resetTime);

            Real forward = inputModel->initialRates()[j];
            initialRates[capletIndex] = forward;

            Real annuity = curve.discountRatio(j+1,0)* inputModel->evolution().rateTaus()[j]*firstDF_;
            annuities[capletIndex] = annuity;

            Real displacement =  inputModel->displacements()[j];

            guess+=  displacedImpliedVols[capletIndex]*(forward+displacement)/forward;
            minVol =std::min(minVol, displacedImpliedVols[capletIndex]);
            maxVol =std::max(maxVol, displacedImpliedVols[capletIndex]*(forward+displacement)/forward);


            Real capletPrice = blackFormula(Option::Call,
                strike,
                forward,
                sd,
                annuity,
                displacement
                );

            capPrice += capletPrice;

        }

        guess/=numberCaplets;


        for (Size step =0; step < inputModel->evolution().numberOfSteps(); ++step)
        {
            Matrix thisDerivative(numberRates,factors,0.0);

            for (Size rate =std::max(inputModel->evolution().firstAliveRate()[step],startIndex); 
                rate < endIndex; ++rate)
            {
                for (Size f=0; f < factors; ++f)
                {
                    Real expiry = inputModel->evolution().rateTimes()[rate];
                    Real volDerivative = inputModel->pseudoRoot(step)[rate][f]
                    /(displacedImpliedVols[rate-startIndex]*expiry);
                    Real capletVega = blackFormulaVolDerivative(strike,inputModel->initialRates()[rate],
                        displacedImpliedVols[rate-startIndex]*std::sqrt(expiry),
                        expiry,
                        annuities[rate-startIndex],
                        inputModel->displacements()[rate]);

                    // note that the cap derivative  is equal to one of the caplet ones so we lose a loop
                    thisDerivative[rate][f] = volDerivative*capletVega;
                }
            }

            priceDerivatives_.push_back(thisDerivative);

        }

        QuickCap capPricer(strike, annuities, initialRates, expiries,capPrice);

        Size maxEvaluations = 1000;
        Real accuracy = 1E-6;

        Brent solver;
        solver.setMaxEvaluations(maxEvaluations);
        impliedVolatility_ =   solver.solve(capPricer,accuracy,guess,minVol*0.99,maxVol*1.01);
      
            

        vega_ = capPricer.vega(impliedVolatility_);



        for (Size step =0; step < inputModel->evolution().numberOfSteps(); ++step)
        {
            Matrix thisDerivative(numberRates,factors,0.0);

            for (Size rate =std::max(inputModel->evolution().firstAliveRate()[step],startIndex); 
                rate < endIndex; ++rate)
            {
                for (Size f=0; f < factors; ++f)
                {
                   
                    thisDerivative[rate][f] = priceDerivatives_[step][rate][f]/vega_;
                }
            }

            volatilityDerivatives_.push_back(thisDerivative);

        }



    }


    const Matrix& CapPseudoDerivative::priceDerivative(Size i) const
    {
        return priceDerivatives_[i];
    }

    const Matrix& CapPseudoDerivative::volatilityDerivative(Size i) const
    { 
        return volatilityDerivatives_[i];
    }



    Real CapPseudoDerivative::impliedVolatility() const
    {
        return impliedVolatility_;
    }




}
]]></document_content>
  </document>
  <document index="71">
    <source>marketmodels/pathwisegreeks/vegabumpcluster.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/errors.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/pathwisegreeks/vegabumpcluster.hpp>
#include <utility>
#include <valarray>

namespace QuantLib {



    VegaBumpCluster::VegaBumpCluster(Size factorBegin,
        Size factorEnd,
        Size rateBegin,
        Size rateEnd,
        Size stepBegin,
        Size stepEnd)
        :
    factorBegin_(factorBegin),
        factorEnd_(factorEnd),
        rateBegin_(rateBegin),
        rateEnd_(rateEnd),
        stepBegin_(stepBegin),
        stepEnd_(stepEnd)
    {
        QL_REQUIRE(factorBegin_<factorEnd_, "must have factorBegin_ < factorEnd_ in VegaBumpCluster ");
        QL_REQUIRE(rateBegin_<rateEnd_, "must have rateBegin_ < rateEnd_ in VegaBumpCluster ");
        QL_REQUIRE(stepBegin_<stepEnd_, "must have stepBegin_ < stepEnd_ in VegaBumpCluster ");
    }

    bool VegaBumpCluster::doesIntersect(const VegaBumpCluster& comparee) const
    {
        if (factorEnd_ <= comparee.factorBegin_)
            return false;

        if (rateEnd_ <= comparee.rateBegin_)
            return false;

        if (stepEnd_ <= comparee.stepBegin_)
            return false;


        if (comparee.factorEnd_ <= factorBegin_)
            return false;

        if (comparee.rateEnd_ <= rateBegin_)
            return false;

        if (comparee.stepEnd_ <= stepBegin_)
            return false;

        return true;


    }


    bool VegaBumpCluster::isCompatible(const ext::shared_ptr<MarketModel>& volStructure) const
    {
        if (rateEnd_ > volStructure->numberOfRates())
            return false;

        if (stepEnd_ > volStructure->numberOfSteps())
            return false;

        if (factorEnd_ > volStructure->numberOfFactors())
            return false;

        Size firstAliveRate = volStructure->evolution().firstAliveRate()[stepEnd_-1];

        return rateBegin_ >= firstAliveRate; // if the rate has reset after the beginning of the last step of the bump
    }



    VegaBumpCollection::VegaBumpCollection(const ext::shared_ptr<MarketModel>& volStructure,
                           bool factorwiseBumping)
                            : associatedVolStructure_(volStructure)
    {
        Size steps = volStructure->numberOfSteps();
        Size rates = volStructure->numberOfRates();
        Size factors = volStructure->numberOfFactors();

        for (Size s=0; s < steps; ++s)
            for (Size r=volStructure->evolution().firstAliveRate()[s]; r < rates; ++r)
            {
                if (factorwiseBumping)
                {
                    for (Size f=0; f < factors; ++f)
                    {
                        VegaBumpCluster thisCluster(f,f+1,r,r+1,s,s+1);
                        allBumps_.push_back(thisCluster);

                    }
                }
                else
                {
                     VegaBumpCluster thisCluster(0,factors,r,r+1,s,s+1);
                     allBumps_.push_back(thisCluster);

                }
            }

        checked_=true;
        full_=true;
        nonOverlapped_=true;


    }


    VegaBumpCollection::VegaBumpCollection(std::vector<VegaBumpCluster> allBumps,
                                           ext::shared_ptr<MarketModel> volStructure)
    : allBumps_(std::move(allBumps)), associatedVolStructure_(std::move(volStructure)),
      checked_(false) {
        for (auto& allBump : allBumps_)
            QL_REQUIRE(allBump.isCompatible(associatedVolStructure_),
                       "incompatible bumps passed to VegaBumpCollection");
    }


    const std::vector<VegaBumpCluster>& VegaBumpCollection::allBumps() const
    {
        return allBumps_;
    }

    bool VegaBumpCollection::isFull() const // i.e. is every alive pseudo-root element bumped at least once
    {
        if (checked_)
            return full_;
        std::vector<std::vector<std::valarray<bool> > > v;

        Size factors = associatedVolStructure_->numberOfFactors();

        std::valarray<bool> model(false,factors);
    //    std::fill(model.begin(), model.end(), false);

        std::vector<std::valarray<bool> > modelTwo;
        modelTwo.reserve(associatedVolStructure_->numberOfRates());
        for (Size i=0; i < associatedVolStructure_->numberOfRates(); ++i)
            modelTwo.push_back(model);

        v.reserve(associatedVolStructure_->numberOfSteps());
        for (Size j=0; j < associatedVolStructure_->numberOfSteps(); ++j)
            v.push_back(modelTwo);

        for (const auto& allBump : allBumps_) {
            for (Size f = allBump.factorBegin(); f < allBump.factorEnd(); ++f)
                for (Size r = allBump.rateBegin(); r < allBump.rateEnd(); ++r)
                    for (Size s = allBump.stepBegin(); s < allBump.stepEnd(); ++s)
                        v[s][r][f] = true;
        }

        Size numberFailures =0;
        for (Size s =0; s < associatedVolStructure_->numberOfSteps(); ++s)
            for (Size f=0; f < associatedVolStructure_->numberOfFactors(); ++f)
                for (Size r=associatedVolStructure_->evolution().firstAliveRate()[s]; r <  associatedVolStructure_->numberOfRates(); ++r)
                    if (!v[s][r][f])
                        ++numberFailures;

        return numberFailures>0;

    }

    bool VegaBumpCollection::isNonOverlapping() const // i.e. is every alive pseudo-root element bumped at most once
    {

        if (checked_)
            return nonOverlapped_;

        std::vector<std::vector<std::valarray<bool> > > v;

        Size factors = associatedVolStructure_->numberOfFactors();


        std::valarray<bool> model(false,factors);
        //std::fill(model.begin(), model.end(), false);

        std::vector<std::valarray<bool> > modelTwo;
        modelTwo.reserve(associatedVolStructure_->numberOfRates());
        for (Size i=0; i < associatedVolStructure_->numberOfRates(); ++i)
            modelTwo.push_back(model);

        v.reserve(associatedVolStructure_->numberOfSteps());
        for (Size j=0; j < associatedVolStructure_->numberOfSteps(); ++j)
            v.push_back(modelTwo);

        Size numberFailures=0;

        for (const auto& allBump : allBumps_) {
            for (Size f = allBump.factorBegin(); f < allBump.factorEnd(); ++f)
                for (Size r = allBump.rateBegin(); r < allBump.rateEnd(); ++r)
                    for (Size s = allBump.stepBegin(); s < allBump.stepEnd(); ++s) {
                        if (v[s][r][f])
                            ++numberFailures;
                        v[s][r][f] = true;
                    }
        }

        return numberFailures>0;

    }

    bool VegaBumpCollection::isSensible() const // i.e. is every alive pseudo-root element bumped precisely once
    {
        if (checked_)
            return true;

        return isNonOverlapping() && isFull();
    }


    Size VegaBumpCollection::numberBumps() const
    {
        return allBumps_.size();
    }

}
]]></document_content>
  </document>
  <document index="72">
    <source>marketmodels/products/compositeproduct.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/products/compositeproduct.hpp>
#include <ql/models/marketmodels/utilities.hpp>

namespace QuantLib {

    const EvolutionDescription& MarketModelComposite::evolution() const {
        QL_REQUIRE(finalized_, "composite not finalized");
        return evolution_;
    }

    std::vector<Size> MarketModelComposite::suggestedNumeraires() const {
        QL_REQUIRE(finalized_, "composite not finalized");
        return terminalMeasure(evolution_);
    }

    std::vector<Time> MarketModelComposite::possibleCashFlowTimes() const {
        QL_REQUIRE(finalized_, "composite not finalized");
        return cashflowTimes_;
    }

    void MarketModelComposite::reset() {
        for (auto& component : components_) {
            component.product->reset();
            component.done = false;
        }
        currentIndex_ = 0;
    }



    void MarketModelComposite::add(
                                const Clone<MarketModelMultiProduct>& product,
                                Real multiplier) {
        QL_REQUIRE(!finalized_, "product already finalized");
        EvolutionDescription d = product->evolution();
        if (!components_.empty()) {
            // enforce preconditions
            EvolutionDescription d1 =
                components_.front().product->evolution();
            const std::vector<Time>& rateTimes1 = d1.rateTimes();
            const std::vector<Time>& rateTimes2 = d.rateTimes();
            QL_REQUIRE(rateTimes1.size() == rateTimes2.size() &&
                       std::equal(rateTimes1.begin(), rateTimes1.end(),
                                  rateTimes2.begin()),
                       "incompatible rate times");
        }
        components_.emplace_back();
        components_.back().product = product;
        components_.back().multiplier = multiplier;
        components_.back().done = false;
        allEvolutionTimes_.push_back(d.evolutionTimes());
    }

    void MarketModelComposite::subtract(
                                const Clone<MarketModelMultiProduct>& product,
                                Real multiplier) {
        add(product, -multiplier);
    }

    void MarketModelComposite::finalize() {
        QL_REQUIRE(!finalized_, "product already finalized");
        QL_REQUIRE(!components_.empty(), "no sub-product provided");

        // fetch the rate times from the first subproduct (we checked
        // they're all the same)
        EvolutionDescription description =
            components_.front().product->evolution();
        rateTimes_ = description.rateTimes();

        mergeTimes(allEvolutionTimes_, evolutionTimes_, isInSubset_);

        std::vector<Time> allCashflowTimes;

        // now, for each subproduct...
        iterator i;
        for (i=components_.begin(); i!=components_.end(); ++i) {
            EvolutionDescription d = i->product->evolution();
            // ...collect all possible cash-flow times...
            const std::vector<Time>& cashflowTimes =
                i->product->possibleCashFlowTimes();
            allCashflowTimes.insert(allCashflowTimes.end(),
                                    cashflowTimes.begin(),
                                    cashflowTimes.end());
            // ...allocate working vectors...
            i->numberOfCashflows =
                std::vector<Size>(i->product->numberOfProducts());
            i->cashflows =
                std::vector<std::vector<CashFlow> >(
                     i->product->numberOfProducts(),
                     std::vector<CashFlow>(i->product
                                  ->maxNumberOfCashFlowsPerProductPerStep()));
        }

        // all information having been collected, we can sort and
        // compact the vector of all cash-flow times...
        std::sort(allCashflowTimes.begin(), allCashflowTimes.end());
        auto end = std::unique(allCashflowTimes.begin(), allCashflowTimes.end());
        //std::copy(allCashflowTimes.begin(), end,
        //          std::back_inserter(cashflowTimes_));
        cashflowTimes_.insert(cashflowTimes_.end(),
                              allCashflowTimes.begin(), end);
        // ...and map each product's cash-flow time into the total vector.
        for (i=components_.begin(); i!=components_.end(); ++i) {
            const std::vector<Time>& productTimes =
                i->product->possibleCashFlowTimes();
            i->timeIndices = std::vector<Size>(productTimes.size());
            for (Size j=0; j<productTimes.size(); ++j) {
                i->timeIndices[j] =
                    std::find(cashflowTimes_.begin(), cashflowTimes_.end(),
                              productTimes[j]) - cashflowTimes_.begin();
            }
        }

        evolution_ = EvolutionDescription(rateTimes_, evolutionTimes_);

        // all done.
        finalized_ = true;
    }

    Size MarketModelComposite::size() const {
        return components_.size();
    }

    const MarketModelMultiProduct& MarketModelComposite::item(Size i) const {
        return *(components_.at(i).product);
    }

    MarketModelMultiProduct& MarketModelComposite::item(Size i) {
        return *(components_.at(i).product);
    }

    Real MarketModelComposite::multiplier(Size i) const {
        return components_.at(i).multiplier;
    }

}
]]></document_content>
  </document>
  <document index="73">
    <source>marketmodels/products/multiproductcomposite.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2006 StatPro Italia srl

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/products/multiproductcomposite.hpp>

namespace QuantLib {

    Size MultiProductComposite::numberOfProducts() const {
        Size result = 0;
        for (const auto& component : components_)
            result += component.product->numberOfProducts();
        return result;
    }


    Size MultiProductComposite::maxNumberOfCashFlowsPerProductPerStep() const {
        Size result = 0;
        for (const auto& component : components_)
            result = std::max(result, component.product->maxNumberOfCashFlowsPerProductPerStep());
        return result;
    }


    bool MultiProductComposite::nextTimeStep(
                     const CurveState& currentState,
                     std::vector<Size>& numberCashFlowsThisStep,
                     std::vector<std::vector<CashFlow> >& cashFlowsGenerated) {
        QL_REQUIRE(finalized_, "composite not finalized");
        bool done = true;
        Size n = 0, offset = 0;
        // for each sub-product...
        for (auto i = components_.begin(); i != components_.end(); ++i, ++n) {
            if (isInSubset_[n][currentIndex_] && !i->done) {
                // ...make it evolve...
                bool thisDone = i->product->nextTimeStep(currentState,
                                                         i->numberOfCashflows,
                                                         i->cashflows);
                // ...and copy the results. Time indices need to be remapped
                // so that they point into all cash-flow times. Amounts need
                // to be adjusted by the corresponding multiplier.
                for (Size j=0; j<i->product->numberOfProducts(); ++j) {
                    numberCashFlowsThisStep[j+offset] =
                        i->numberOfCashflows[j];
                    for (Size k=0; k<i->numberOfCashflows[j]; ++k) {
                        CashFlow& from = i->cashflows[j][k];
                        CashFlow& to = cashFlowsGenerated[j+offset][k];
                        to.timeIndex = i->timeIndices[from.timeIndex];
                        to.amount = from.amount * i->multiplier;
                    }
                }
                // finally, set done to false if this product isn't done
                done = done && thisDone;
            }
            else
                for (Size j=0; j<i->product->numberOfProducts(); ++j)
                    numberCashFlowsThisStep[j+offset] =0;

            // the offset is updated whether or not the product was evolved
            offset += i->product->numberOfProducts();
        }
        ++currentIndex_;
        return done;
    }

    std::unique_ptr<MarketModelMultiProduct>
    MultiProductComposite::clone() const {
        return std::unique_ptr<MarketModelMultiProduct>(new MultiProductComposite(*this));
    }

}
]]></document_content>
  </document>
  <document index="74">
    <source>marketmodels/products/multiproductmultistep.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/errors.hpp>
#include <ql/models/marketmodels/products/multiproductmultistep.hpp>
#include <utility>

namespace QuantLib {

    MultiProductMultiStep::MultiProductMultiStep(std::vector<Time> rateTimes)
    : rateTimes_(std::move(rateTimes)) {
        QL_REQUIRE(rateTimes_.size()>1,
                   "Rate times must contain at least two values");
        Size n = rateTimes_.size()-1;
        std::vector<Time> evolutionTimes(n);
        std::vector<std::pair<Size,Size> > relevanceRates(n);
        for (Size i=0; i<n; ++i) {
            evolutionTimes[i] = rateTimes_[i];
            relevanceRates[i] = std::make_pair(i, i+1);
        }

        evolution_ = EvolutionDescription(rateTimes_, evolutionTimes,
                                          relevanceRates);
    }

    const EvolutionDescription& MultiProductMultiStep::evolution() const {
        return evolution_;
    }

    std::vector<Size> MultiProductMultiStep::suggestedNumeraires() const
    {
        Size n = rateTimes_.size()-1;
        std::vector<Size> numeraires(n);
        // MoneyMarketPlus(1)
        for (Size i=0; i<n; ++i)
            numeraires[i]=i+1;
        return numeraires;
    }

}
]]></document_content>
  </document>
  <document index="75">
    <source>marketmodels/products/multiproductonestep.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/errors.hpp>
#include <ql/models/marketmodels/products/multiproductonestep.hpp>
#include <utility>


namespace QuantLib {

    MultiProductOneStep::MultiProductOneStep(std::vector<Time> rateTimes)
    : rateTimes_(std::move(rateTimes)) {
        QL_REQUIRE(rateTimes_.size()>1,
                   "Rate times must contain at least two values");
        std::vector<Time> evolutionTimes(1, rateTimes_[rateTimes_.size()-2]);
        std::vector<std::pair<Size,Size> > relevanceRates(1);
        relevanceRates[0] =
            std::make_pair<Size,Size>(0, rateTimes_.size()-1);

        evolution_ = EvolutionDescription(rateTimes_, evolutionTimes,
                                          relevanceRates);
    }

    const EvolutionDescription& MultiProductOneStep::evolution() const {
        return evolution_;
    }

    std::vector<Size> MultiProductOneStep::suggestedNumeraires() const {
        // Terminal measure
        return std::vector<Size>(1, rateTimes_.size()-1);
    }

}
]]></document_content>
  </document>
  <document index="76">
    <source>marketmodels/products/multistep/callspecifiedmultiproduct.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/products/multistep/callspecifiedmultiproduct.hpp>
#include <ql/models/marketmodels/products/multistep/cashrebate.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {

    CallSpecifiedMultiProduct::CallSpecifiedMultiProduct(
        const Clone<MarketModelMultiProduct>& underlying,
        const Clone<ExerciseStrategy<CurveState> >& strategy,
        Clone<MarketModelMultiProduct> rebate)
    : underlying_(underlying), strategy_(strategy), rebate_(std::move(rebate)) {
        Size products = underlying_->numberOfProducts();
        EvolutionDescription d1 = underlying->evolution();
        const std::vector<Time>& rateTimes1 = d1.rateTimes();
        const std::vector<Time>& evolutionTimes1 = d1.evolutionTimes();
        const std::vector<Time>& exerciseTimes = strategy->exerciseTimes();

        if (!rebate_.empty()) 
        {
            EvolutionDescription d2 = rebate_->evolution();
            const std::vector<Time>& rateTimes2 = d2.rateTimes();
            QL_REQUIRE(rateTimes1.size() == rateTimes2.size() &&
                       std::equal(rateTimes1.begin(), rateTimes1.end(),
                                  rateTimes2.begin()),
                       "incompatible rate times");
        } 
        else
        {
            EvolutionDescription description(rateTimes1, exerciseTimes);
            Matrix amounts(products, exerciseTimes.size(), 0.0);

            rebate_ = MarketModelCashRebate(description, exerciseTimes,
                                            amounts, products);
        }

        std::vector<Time> mergedEvolutionTimes;
        std::vector<std::vector<Time> > allEvolutionTimes(4);
        allEvolutionTimes[0] = evolutionTimes1;
        allEvolutionTimes[1] = exerciseTimes;
        allEvolutionTimes[2] = rebate_->evolution().evolutionTimes();
        allEvolutionTimes[3] = strategy->relevantTimes();

        mergeTimes(allEvolutionTimes,
                                    mergedEvolutionTimes,
                                    isPresent_);

        // TODO: add relevant rates
        evolution_ = EvolutionDescription(rateTimes1, mergedEvolutionTimes);

        cashFlowTimes_ = underlying_->possibleCashFlowTimes();
        rebateOffset_ = cashFlowTimes_.size();
        const std::vector<Time> rebateTimes = rebate_->possibleCashFlowTimes();
        cashFlowTimes_.insert(cashFlowTimes_.end(),
                                                           rebateTimes.begin(), rebateTimes.end());

        dummyCashFlowsThisStep_ = std::vector<Size>(products, 0);
        Size n = rebate_->maxNumberOfCashFlowsPerProductPerStep();
        dummyCashFlowsGenerated_ =
            std::vector<std::vector<CashFlow> >(products,
                                                std::vector<CashFlow>(n));
    }

    std::vector<Size>
    CallSpecifiedMultiProduct::suggestedNumeraires() const 
    {
        return underlying_->suggestedNumeraires();
    }

    const EvolutionDescription& CallSpecifiedMultiProduct::evolution() const 
    {
        return evolution_;
    }

    std::vector<Time>
    CallSpecifiedMultiProduct::possibleCashFlowTimes() const 
    {
        return cashFlowTimes_;
    }

    Size CallSpecifiedMultiProduct::numberOfProducts() const 
    {
        return underlying_->numberOfProducts();
    }

    Size
    CallSpecifiedMultiProduct::maxNumberOfCashFlowsPerProductPerStep() const 
    {
        return std::max(underlying_->maxNumberOfCashFlowsPerProductPerStep(),
                        rebate_->maxNumberOfCashFlowsPerProductPerStep());
    }

    void CallSpecifiedMultiProduct::reset() 
    {
        underlying_->reset();
        rebate_->reset();
        strategy_->reset();
        currentIndex_ = 0;
        wasCalled_ = false;
    }


    bool CallSpecifiedMultiProduct::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<CashFlow> >& cashFlowsGenerated) 
    {

        bool isUnderlyingTime = isPresent_[0][currentIndex_];
        bool isExerciseTime = isPresent_[1][currentIndex_];
        bool isRebateTime = isPresent_[2][currentIndex_];
        bool isStrategyRelevantTime = isPresent_[3][currentIndex_];

        bool done = false;

        if (!wasCalled_ && isStrategyRelevantTime)
            strategy_->nextStep(currentState);


        if (!wasCalled_ && isExerciseTime && callable_)
            wasCalled_ = strategy_->exercise(currentState);

        if (wasCalled_) 
        {
            if (isRebateTime) 
            {
                done = rebate_->nextTimeStep(currentState,
                                             numberCashFlowsThisStep,
                                             cashFlowsGenerated);
                for (Size i=0; i<numberCashFlowsThisStep.size(); ++i)
                    for (Size j=0; j<numberCashFlowsThisStep[i]; ++j)
                        cashFlowsGenerated[i][j].timeIndex += rebateOffset_;
            }
        } 
        else 
        {
            if (isRebateTime)
                rebate_->nextTimeStep(currentState,
                                      dummyCashFlowsThisStep_,
                                      dummyCashFlowsGenerated_);
            if (isUnderlyingTime)
                done = underlying_->nextTimeStep(currentState,
                                                 numberCashFlowsThisStep,
                                                 cashFlowsGenerated);
        }

        ++currentIndex_;
        return done || currentIndex_ == evolution_.evolutionTimes().size();
    }

    std::unique_ptr<MarketModelMultiProduct>
    CallSpecifiedMultiProduct::clone() const 
    {
        return std::unique_ptr<MarketModelMultiProduct>(new CallSpecifiedMultiProduct(*this));
    }

    const MarketModelMultiProduct&
    CallSpecifiedMultiProduct::underlying() const 
    {
        return *underlying_;
    }

    const ExerciseStrategy<CurveState>&
    CallSpecifiedMultiProduct::strategy() const 
    {
        return *strategy_;
    }

    const MarketModelMultiProduct&
    CallSpecifiedMultiProduct::rebate() const 
    {
        return *rebate_;
    }

    void CallSpecifiedMultiProduct::enableCallability() 
    {
        callable_ = true;
    }

    void CallSpecifiedMultiProduct::disableCallability() 
    {
        callable_ = false;
    }

}

]]></document_content>
  </document>
  <document index="77">
    <source>marketmodels/products/multistep/cashrebate.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/products/multistep/cashrebate.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {

    MarketModelCashRebate::MarketModelCashRebate(EvolutionDescription evolution,
                                                 const std::vector<Time>& paymentTimes,
                                                 Matrix amounts,
                                                 Size numberOfProducts)
    : evolution_(std::move(evolution)), paymentTimes_(paymentTimes), amounts_(std::move(amounts)),
      numberOfProducts_(numberOfProducts) {

        checkIncreasingTimes(paymentTimes);

        QL_REQUIRE(amounts_.rows() == numberOfProducts_,
                   "the number of rows in the matrix must equal "
                   "the number of products");
        QL_REQUIRE(amounts_.columns() == paymentTimes_.size(),
                   "the number of columns in the matrix must equal "
                   "the number of payment times");
        QL_REQUIRE(evolution_.evolutionTimes().size() == paymentTimes_.size(),
                   "the number of evolution times must equal "
                   "the number of payment times");
    }


    std::vector<Time>
    MarketModelCashRebate::possibleCashFlowTimes() const 
    {
        return paymentTimes_;
    }

    Size MarketModelCashRebate::numberOfProducts() const 
    {
        return numberOfProducts_;
    }

    Size MarketModelCashRebate::maxNumberOfCashFlowsPerProductPerStep() const 
    {
        return 1;
    }

    void MarketModelCashRebate::reset() 
    {
       currentIndex_=0;
    }

    std::vector<Size>
    MarketModelCashRebate::suggestedNumeraires() const 
    {
        QL_FAIL("not implemented (yet?)");
    }

    const EvolutionDescription& MarketModelCashRebate::evolution() const
    {
        return evolution_;
    }


    bool MarketModelCashRebate::nextTimeStep(
            const CurveState&,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelMultiProduct::CashFlow> >&
                                                               genCashFlows)
    {
        for (Size i=0; i<numberOfProducts_; ++i) 
        {
            numberCashFlowsThisStep[i] = 1;
            genCashFlows[i][0].timeIndex = currentIndex_;
            genCashFlows[i][0].amount = amounts_[i][currentIndex_];
        }
        ++currentIndex_;
        return true;
    }

    std::unique_ptr<MarketModelMultiProduct>
    MarketModelCashRebate::clone() const 
    {
        return std::unique_ptr<MarketModelMultiProduct>(new MarketModelCashRebate(*this));
    }

}

]]></document_content>
  </document>
  <document index="78">
    <source>marketmodels/products/multistep/exerciseadapter.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/products/multistep/exerciseadapter.hpp>

namespace QuantLib {

    ExerciseAdapter::ExerciseAdapter(
                              const Clone<MarketModelExerciseValue>& exercise,
                              Size numberOfProducts)
    : MultiProductMultiStep(exercise->evolution().rateTimes()),
      exercise_(exercise), numberOfProducts_(numberOfProducts),
      isExerciseTime_(exercise->isExerciseTime()) {}

    bool ExerciseAdapter::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelMultiProduct::CashFlow> >&
                                                         generatedCashFlows) {
        std::fill(numberCashFlowsThisStep.begin(),
                  numberCashFlowsThisStep.end(), 0);
        bool done = false;

        exercise_->nextStep(currentState);
        if (isExerciseTime_[currentIndex_]) {
            MarketModelMultiProduct::CashFlow cashflow =
                exercise_->value(currentState);
            numberCashFlowsThisStep[0] = 1;
            generatedCashFlows[0][0] = cashflow;
            done = true;
        }
        ++currentIndex_;
        return done || currentIndex_ == isExerciseTime_.size();
    }

    std::unique_ptr<MarketModelMultiProduct>
    ExerciseAdapter::clone() const {
        return std::unique_ptr<MarketModelMultiProduct>(new ExerciseAdapter(*this));
    }

}

]]></document_content>
  </document>
  <document index="79">
    <source>marketmodels/products/multistep/multistepcoinitialswaps.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/products/multistep/multistepcoinitialswaps.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {

    MultiStepCoinitialSwaps::MultiStepCoinitialSwaps(const std::vector<Time>& rateTimes,
                                                     std::vector<Real> fixedAccruals,
                                                     std::vector<Real> floatingAccruals,
                                                     const std::vector<Time>& paymentTimes,
                                                     Real fixedRate)
    : MultiProductMultiStep(rateTimes), fixedAccruals_(std::move(fixedAccruals)),
      floatingAccruals_(std::move(floatingAccruals)), paymentTimes_(paymentTimes),
      fixedRate_(fixedRate) {
        checkIncreasingTimes(paymentTimes);

        lastIndex_ = rateTimes.size()-1;
    }

    bool MultiStepCoinitialSwaps::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelMultiProduct::CashFlow> >&
                                                               genCashFlows) {
        Rate liborRate = currentState.forwardRate(currentIndex_);
        std::fill(numberCashFlowsThisStep.begin(),
                  numberCashFlowsThisStep.end(),0);

        for (Size i=currentIndex_;i<lastIndex_;i++) {
            genCashFlows[i][0].timeIndex = currentIndex_;
            genCashFlows[i][0].amount =
                -fixedRate_*fixedAccruals_[currentIndex_];

            genCashFlows[i][1].timeIndex = currentIndex_;
            genCashFlows[i][1].amount =
                liborRate*floatingAccruals_[currentIndex_];

            numberCashFlowsThisStep[i] = 2;
        }
        ++currentIndex_;

        return (currentIndex_ == lastIndex_);
    }

    std::unique_ptr<MarketModelMultiProduct>
    MultiStepCoinitialSwaps::clone() const {
        return std::unique_ptr<MarketModelMultiProduct>(new MultiStepCoinitialSwaps(*this));
    }

}
]]></document_content>
  </document>
  <document index="80">
    <source>marketmodels/products/multistep/multistepcoterminalswaps.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/products/multistep/multistepcoterminalswaps.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {

    MultiStepCoterminalSwaps::MultiStepCoterminalSwaps(const std::vector<Time>& rateTimes,
                                                       std::vector<Real> fixedAccruals,
                                                       std::vector<Real> floatingAccruals,
                                                       const std::vector<Time>& paymentTimes,
                                                       Real fixedRate)
    : MultiProductMultiStep(rateTimes), fixedAccruals_(std::move(fixedAccruals)),
      floatingAccruals_(std::move(floatingAccruals)), paymentTimes_(paymentTimes),
      fixedRate_(fixedRate) {
        checkIncreasingTimes(paymentTimes);

        lastIndex_ = rateTimes.size()-1;
    }

    bool MultiStepCoterminalSwaps::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelMultiProduct::CashFlow> >&
                                                               genCashFlows) {
        Rate liborRate = currentState.forwardRate(currentIndex_);
        std::fill(numberCashFlowsThisStep.begin(),
                  numberCashFlowsThisStep.end(),0);
        for(Size i=0;i<=currentIndex_;i++){
            genCashFlows[i][0].timeIndex = currentIndex_;
            genCashFlows[i][0].amount =
                -fixedRate_*fixedAccruals_[currentIndex_];

            genCashFlows[i][1].timeIndex = currentIndex_;
            genCashFlows[i][1].amount =
                liborRate*floatingAccruals_[currentIndex_];

            numberCashFlowsThisStep[i] = 2;
        }
        ++currentIndex_;

        return (currentIndex_ == lastIndex_);
    }

    std::unique_ptr<MarketModelMultiProduct>
    MultiStepCoterminalSwaps::clone() const {
        return std::unique_ptr<MarketModelMultiProduct>(new MultiStepCoterminalSwaps(*this));
    }

}
]]></document_content>
  </document>
  <document index="81">
    <source>marketmodels/products/multistep/multistepcoterminalswaptions.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/payoffs.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/products/multistep/multistepcoterminalswaptions.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {

    MultiStepCoterminalSwaptions::MultiStepCoterminalSwaptions(
        const std::vector<Time>& rateTimes,
        const std::vector<Time>& paymentTimes,
        std::vector<ext::shared_ptr<StrikedTypePayoff> > payoffs)
    : MultiProductMultiStep(rateTimes), paymentTimes_(paymentTimes), payoffs_(std::move(payoffs)) {
        checkIncreasingTimes(paymentTimes);

        lastIndex_ = rateTimes.size()-1;
    }

    bool MultiStepCoterminalSwaptions::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelMultiProduct::CashFlow> >&
                                                               genCashFlows)
    {
        genCashFlows[currentIndex_][0].timeIndex = currentIndex_;

        Rate swapRate = currentState.coterminalSwapRate(currentIndex_);
        Real annuity = currentState.coterminalSwapAnnuity(currentIndex_, currentIndex_);
        genCashFlows[currentIndex_][0].amount =
            (*payoffs_[currentIndex_])(swapRate) * annuity;
        std::fill(numberCashFlowsThisStep.begin(),
                  numberCashFlowsThisStep.end(),0);
        numberCashFlowsThisStep[currentIndex_] = 1;
        ++currentIndex_;
        return (currentIndex_ == lastIndex_);
    }

    std::unique_ptr<MarketModelMultiProduct>
    MultiStepCoterminalSwaptions::clone() const {
        return std::unique_ptr<MarketModelMultiProduct>(new MultiStepCoterminalSwaptions(*this));
    }

}
]]></document_content>
  </document>
  <document index="82">
    <source>marketmodels/products/multistep/multistepforwards.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/products/multistep/multistepforwards.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {

    MultiStepForwards::MultiStepForwards(const std::vector<Time>& rateTimes,
                                         std::vector<Real> accruals,
                                         const std::vector<Time>& paymentTimes,
                                         std::vector<Rate> strikes)
    : MultiProductMultiStep(rateTimes), accruals_(std::move(accruals)), paymentTimes_(paymentTimes),
      strikes_(std::move(strikes)) {
        checkIncreasingTimes(paymentTimes);
    }

    bool MultiStepForwards::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelMultiProduct::CashFlow> >&
                                                               genCashFlows) {
        Rate liborRate = currentState.forwardRate(currentIndex_);
        genCashFlows[currentIndex_][0].timeIndex = currentIndex_;
        genCashFlows[currentIndex_][0].amount =
            (liborRate-strikes_[currentIndex_])*accruals_[currentIndex_];
        std::fill(numberCashFlowsThisStep.begin(),
                  numberCashFlowsThisStep.end(),0);
        numberCashFlowsThisStep[currentIndex_] = 1;
        ++currentIndex_;
        return (currentIndex_ == strikes_.size());
    }

    std::unique_ptr<MarketModelMultiProduct>
    MultiStepForwards::clone() const {
        return std::unique_ptr<MarketModelMultiProduct>(new MultiStepForwards(*this));
    }

}

]]></document_content>
  </document>
  <document index="83">
    <source>marketmodels/products/multistep/multistepinversefloater.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2006 Giorgio Facchinetti

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/products/multistep/multistepinversefloater.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {

    MultiStepInverseFloater::MultiStepInverseFloater(const std::vector<Time>& rateTimes,
                                                     std::vector<Real> fixedAccruals,
                                                     const std::vector<Real>& floatingAccruals,
                                                     const std::vector<Real>& fixedStrikes,
                                                     const std::vector<Real>& fixedMultipliers,
                                                     const std::vector<Real>& floatingSpreads,
                                                     const std::vector<Time>& paymentTimes,
                                                     bool payer)
    : MultiProductMultiStep(rateTimes), fixedAccruals_(std::move(fixedAccruals)),
      floatingAccruals_(floatingAccruals), fixedStrikes_(fixedStrikes),
      fixedMultipliers_(fixedMultipliers), floatingSpreads_(floatingSpreads),
      paymentTimes_(paymentTimes), multiplier_(payer ? -1.0 : 1.0),
      lastIndex_(rateTimes.size() - 1) {
        checkIncreasingTimes(paymentTimes);
        QL_REQUIRE(fixedAccruals_.size() == lastIndex_," Incorrect number of fixedAccruals given, should be " <<  lastIndex_ << " not " << fixedAccruals_.size() );
        QL_REQUIRE(floatingAccruals.size() == lastIndex_," Incorrect number of floatingAccruals given, should be " <<  lastIndex_ << " not " << floatingAccruals.size() );
        QL_REQUIRE(fixedStrikes.size() == lastIndex_," Incorrect number of fixedStrikes given, should be " <<  lastIndex_ << " not " << fixedStrikes.size() );
        QL_REQUIRE(fixedMultipliers.size() == lastIndex_," Incorrect number of fixedMultipliers given, should be " <<  lastIndex_ << " not " << fixedMultipliers.size() );
        QL_REQUIRE(floatingSpreads.size() == lastIndex_," Incorrect number of floatingSpreads given, should be " <<  lastIndex_ << " not " << floatingSpreads.size() );
         QL_REQUIRE(paymentTimes.size() == lastIndex_," Incorrect number of paymentTimes given, should be " <<  lastIndex_ << " not " << paymentTimes.size() );
    }

    bool MultiStepInverseFloater::nextTimeStep(
        const CurveState& currentState,
        std::vector<Size>& numberCashFlowsThisStep,
        std::vector<std::vector<MarketModelMultiProduct::CashFlow> >&
        genCashFlows)
    {
         Rate liborRate = currentState.forwardRate(currentIndex_);
         Real inverseFloatingCoupon = std::max((fixedStrikes_[currentIndex_] - fixedMultipliers_[currentIndex_]*liborRate),0.0)*fixedAccruals_[currentIndex_] ;
         Real floatingCoupon = (liborRate+floatingSpreads_[currentIndex_])*floatingAccruals_[currentIndex_];

        genCashFlows[0][0].timeIndex = currentIndex_;
        genCashFlows[0][0].amount =multiplier_*(inverseFloatingCoupon - floatingCoupon);

        numberCashFlowsThisStep[0] = 1;
        ++currentIndex_;

        return (currentIndex_ == lastIndex_);
    }

    std::unique_ptr<MarketModelMultiProduct>
    MultiStepInverseFloater::clone() const 
    {
        return std::unique_ptr<MarketModelMultiProduct>(new MultiStepInverseFloater(*this));
    }

}

]]></document_content>
  </document>
  <document index="84">
    <source>marketmodels/products/multistep/multistepnothing.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/products/multistep/multistepnothing.hpp>

namespace QuantLib {

    MultiStepNothing::MultiStepNothing(const EvolutionDescription& evolution,
                                       Size numberOfProducts,
                                       Size doneIndex)
    : MultiProductMultiStep(evolution.rateTimes()),
      numberOfProducts_(numberOfProducts), doneIndex_(doneIndex) {}

    bool MultiStepNothing::nextTimeStep(
        const CurveState&,
        std::vector<Size>& numberCashFlowsThisStep,
        std::vector<std::vector<MarketModelMultiProduct::CashFlow> >&) {
        for (auto & i : numberCashFlowsThisStep)
            i = 0;
        ++currentIndex_;
        return (currentIndex_ >= doneIndex_);
    }

    std::unique_ptr<MarketModelMultiProduct>
    MultiStepNothing::clone() const {
        return std::unique_ptr<MarketModelMultiProduct>(new MultiStepNothing(*this));
    }

}
]]></document_content>
  </document>
  <document index="85">
    <source>marketmodels/products/multistep/multistepoptionlets.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/products/multistep/multistepoptionlets.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <ql/payoff.hpp>
#include <utility>

namespace QuantLib {

    MultiStepOptionlets::MultiStepOptionlets(const std::vector<Time>& rateTimes,
                                             std::vector<Real> accruals,
                                             const std::vector<Time>& paymentTimes,
                                             std::vector<ext::shared_ptr<Payoff> > payoffs)
    : MultiProductMultiStep(rateTimes), accruals_(std::move(accruals)), paymentTimes_(paymentTimes),
      payoffs_(std::move(payoffs)) {
        checkIncreasingTimes(paymentTimes);
    }

    bool MultiStepOptionlets::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelMultiProduct::CashFlow> >&
                                                               genCashFlows) {
        Rate liborRate = currentState.forwardRate(currentIndex_);
        genCashFlows[currentIndex_][0].timeIndex = currentIndex_;
        genCashFlows[currentIndex_][0].amount =
            (*payoffs_[currentIndex_])(liborRate) *
            accruals_[currentIndex_];
        std::fill(numberCashFlowsThisStep.begin(),
                  numberCashFlowsThisStep.end(), 0);
        numberCashFlowsThisStep[currentIndex_] = 1;
        ++currentIndex_;
        return (currentIndex_ == payoffs_.size());
    }

    std::unique_ptr<MarketModelMultiProduct>
    MultiStepOptionlets::clone() const {
        return std::unique_ptr<MarketModelMultiProduct>(new MultiStepOptionlets(*this));
    }

}
]]></document_content>
  </document>
  <document index="86">
    <source>marketmodels/products/multistep/multisteppathwisewrapper.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2009 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/products/multistep/multisteppathwisewrapper.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>

namespace QuantLib 
{
    MultiProductPathwiseWrapper::MultiProductPathwiseWrapper(const MarketModelPathwiseMultiProduct& innerProduct)
        :  innerProduct_(innerProduct), cashFlowsGenerated_ (innerProduct.numberOfProducts(), std::vector<MarketModelPathwiseMultiProduct::CashFlow>(innerProduct.maxNumberOfCashFlowsPerProductPerStep())),
        numberOfProducts_(innerProduct.numberOfProducts())
    {

        for (auto& i : cashFlowsGenerated_)
            for (auto& j : i)
                j.amount.resize(1 + innerProduct.evolution().numberOfRates());
    }

        std::vector<Time>  MultiProductPathwiseWrapper::possibleCashFlowTimes() const
        {
            return innerProduct_->possibleCashFlowTimes();
        }
        
        Size  MultiProductPathwiseWrapper::numberOfProducts() const
        {
            return innerProduct_->numberOfProducts();
        }
        
        Size  MultiProductPathwiseWrapper::maxNumberOfCashFlowsPerProductPerStep() const
        {
               return innerProduct_->maxNumberOfCashFlowsPerProductPerStep();
        }
        
        void  MultiProductPathwiseWrapper::reset()
        {
            innerProduct_->reset();
        }
        
        bool  MultiProductPathwiseWrapper::nextTimeStep(
                     const CurveState& currentState,
                     std::vector<Size>& numberCashFlowsThisStep,
                     std::vector<std::vector<CashFlow> >& cashFlowsGenerated)
        {
            bool done = innerProduct_->nextTimeStep(currentState, numberCashFlowsThisStep,cashFlowsGenerated_);

            // tranform the data
            for (Size i=0; i < numberOfProducts_; ++i)
                for (Size j=0; j< numberCashFlowsThisStep[i]; ++j)
                {
                    cashFlowsGenerated[i][j].timeIndex =cashFlowsGenerated_[i][j].timeIndex;
                    cashFlowsGenerated[i][j].amount =cashFlowsGenerated_[i][j].amount[0];
                }


            return done;
        }

        std::vector<Size> MultiProductPathwiseWrapper::suggestedNumeraires() const
        {
            return innerProduct_->suggestedNumeraires();
        }

        const EvolutionDescription& MultiProductPathwiseWrapper::evolution() const
        {
            return innerProduct_->evolution();
        }

        std::unique_ptr<MarketModelMultiProduct>
        MultiProductPathwiseWrapper::clone() const
        {
            return std::unique_ptr<MarketModelMultiProduct>(new MultiProductPathwiseWrapper(*this));
        }

      

}

]]></document_content>
  </document>
  <document index="87">
    <source>marketmodels/products/multistep/multistepperiodcapletswaptions.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/payoffs.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/products/multistep/multistepperiodcapletswaptions.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {

    MultiStepPeriodCapletSwaptions::MultiStepPeriodCapletSwaptions(
        const std::vector<Time>& rateTimes,
        const std::vector<Time>& forwardOptionPaymentTimes,
        const std::vector<Time>& swaptionPaymentTimes,
        std::vector<ext::shared_ptr<StrikedTypePayoff> > forwardPayOffs,
        std::vector<ext::shared_ptr<StrikedTypePayoff> > swapPayOffs,
        Size period,
        Size offset)
    : MultiProductMultiStep(rateTimes), paymentTimes_(forwardOptionPaymentTimes),
      forwardOptionPaymentTimes_(forwardOptionPaymentTimes),
      swaptionPaymentTimes_(swaptionPaymentTimes), forwardPayOffs_(std::move(forwardPayOffs)),
      swapPayOffs_(std::move(swapPayOffs)), period_(period), offset_(offset) {
        QL_REQUIRE(rateTimes.size() >=2,
                       "we need at least two rate times in MultiStepPeriodCapletSwaptions ");

        checkIncreasingTimes(forwardOptionPaymentTimes);
        checkIncreasingTimes(swaptionPaymentTimes);
        for (Real& swaptionPaymentTime : swaptionPaymentTimes_)
            paymentTimes_.push_back(swaptionPaymentTime);
        lastIndex_ = rateTimes.size()-1;
        numberFRAs_ = rateTimes.size()-1;
        numberBigFRAs_ = (numberFRAs_-offset_)/period_;


        QL_REQUIRE(offset_< period_,
                       "the offset must be less then the period in MultiStepPeriodCapletSwaptions ");
        QL_REQUIRE(numberBigFRAs_ > 0,
                       "we must have at least one FRA after the periodizing in  MultiStepPeriodCapletSwaptions ");

        QL_REQUIRE(forwardOptionPaymentTimes_.size() == numberBigFRAs_,
                       "we must have precisely one payment time for each forward option  MultiStepPeriodCapletSwaptions ");

         QL_REQUIRE(forwardPayOffs_.size() == numberBigFRAs_,
                       "we must have precisely one payoff  for each forward option  MultiStepPeriodCapletSwaptions ");

        QL_REQUIRE(swaptionPaymentTimes_.size() == numberBigFRAs_,
                       "we must have precisely one payment time for each swaption in MultiStepPeriodCapletSwaptions ");

         QL_REQUIRE(swapPayOffs_.size() == numberBigFRAs_,
                       "we must have precisely one payoff  for each swaption in  MultiStepPeriodCapletSwaptions ");
    }

    bool MultiStepPeriodCapletSwaptions::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelMultiProduct::CashFlow> >&
                                                               genCashFlows)
    {

        for (Size & i : numberCashFlowsThisStep)
            i = 0UL;

        if (currentIndex_ >= offset_ && (currentIndex_ - offset_) % period_ == 0) {
            // caplet first
            Real df = currentState.discountRatio(currentIndex_ + period_, currentIndex_);
            Time tau = rateTimes_[currentIndex_ + period_] - rateTimes_[currentIndex_];
            Real forward = (1.0 / df - 1.0) / tau;
            Real value = (*forwardPayOffs_[productIndex_])(forward);
            value *= tau * currentState.discountRatio(currentIndex_ + period_, currentIndex_);

            if (value > 0) {
                numberCashFlowsThisStep[productIndex_] = 1UL;
                genCashFlows[productIndex_][0].amount = value;
                genCashFlows[productIndex_][0].timeIndex = productIndex_;
            }

            // now swaption

            unsigned long numberPeriods = numberBigFRAs_ - productIndex_;
            Real B = 0.0;
            double P0 = 1.0; // i.e currentState.discountRatio(currentIndex_,currentIndex_);
            Real Pn =
                currentState.discountRatio(currentIndex_ + numberPeriods * period_, currentIndex_);
            for (unsigned long i = 0; i < numberPeriods; ++i) {
                Time tau = rateTimes_[currentIndex_ + (i + 1) * period_] -
                           rateTimes_[currentIndex_ + i * period_];
                B += tau *
                     currentState.discountRatio(currentIndex_ + (i + 1) * period_, currentIndex_);
            }


            Real swapRate = (P0 - Pn) / B;

            Real swaptionValue = (*swapPayOffs_[productIndex_])(swapRate);
            swaptionValue *= B;

            if (swaptionValue > 0) {
                numberCashFlowsThisStep[productIndex_ + numberBigFRAs_] = 1UL;
                genCashFlows[productIndex_ + numberBigFRAs_][0].amount = swaptionValue;
                genCashFlows[productIndex_ + numberBigFRAs_][0].timeIndex =
                    productIndex_ + numberBigFRAs_;
            }

            ++productIndex_;

    }

    ++currentIndex_;

    bool terminate =(productIndex_ >= numberBigFRAs_);


    return terminate;
    }

    std::unique_ptr<MarketModelMultiProduct>
    MultiStepPeriodCapletSwaptions::clone() const {
        return std::unique_ptr<MarketModelMultiProduct>(new MultiStepPeriodCapletSwaptions(*this));
    }

}
]]></document_content>
  </document>
  <document index="88">
    <source>marketmodels/products/multistep/multistepratchet.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/products/multistep/multistepratchet.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <cmath>
#include <utility>

namespace QuantLib {

    MultiStepRatchet::MultiStepRatchet(const std::vector<Time>& rateTimes,
                                       std::vector<Real> accruals,
                                       const std::vector<Time>& paymentTimes,
                                       Real gearingOfFloor,
                                       Real gearingOfFixing,
                                       Rate spreadOfFloor,
                                       Rate spreadOfFixing,
                                       Real initialFloor,
                                       bool payer)
    : MultiProductMultiStep(rateTimes), accruals_(std::move(accruals)), paymentTimes_(paymentTimes),
      gearingOfFloor_(gearingOfFloor), gearingOfFixing_(gearingOfFixing),
      spreadOfFloor_(spreadOfFloor), spreadOfFixing_(spreadOfFixing),
      multiplier_(payer ? 1.0 : -1.0), lastIndex_(rateTimes.size() - 1),
      initialFloor_(initialFloor) {
        checkIncreasingTimes(paymentTimes);
    }

    bool MultiStepRatchet::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelMultiProduct::CashFlow> >&
                                                                 genCashFlows)
    {
        Rate liborRate = currentState.forwardRate(currentIndex_);
        Real currentCoupon = std::max(gearingOfFloor_* floor_ + spreadOfFloor_,
                                      gearingOfFixing_* liborRate + spreadOfFixing_);

        genCashFlows[0][0].timeIndex = currentIndex_;
        genCashFlows[0][0].amount =
            multiplier_* accruals_[currentIndex_]*currentCoupon;

        //floor_ = liborRate;                           //StepRatchet
        floor_ = currentCoupon;                         //FullRatchet
        numberCashFlowsThisStep[0] = 1;

        ++currentIndex_;

        return (currentIndex_ == lastIndex_);
    }

    std::unique_ptr<MarketModelMultiProduct>
    MultiStepRatchet::clone() const {
        return std::unique_ptr<MarketModelMultiProduct>(new MultiStepRatchet(*this));
    }

}

]]></document_content>
  </document>
  <document index="89">
    <source>marketmodels/products/multistep/multistepswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/products/multistep/multistepswap.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {

    MultiStepSwap::MultiStepSwap(const std::vector<Time>& rateTimes,
                                 std::vector<Real> fixedAccruals,
                                 std::vector<Real> floatingAccruals,
                                 const std::vector<Time>& paymentTimes,
                                 Real fixedRate,
                                 bool payer)
    : MultiProductMultiStep(rateTimes), fixedAccruals_(std::move(fixedAccruals)),
      floatingAccruals_(std::move(floatingAccruals)), paymentTimes_(paymentTimes),
      fixedRate_(fixedRate), multiplier_(payer ? 1.0 : -1.0), lastIndex_(rateTimes.size() - 1) {
        checkIncreasingTimes(paymentTimes);
    }

    bool MultiStepSwap::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelMultiProduct::CashFlow> >&
                                                                 genCashFlows)
    {
        Rate liborRate = currentState.forwardRate(currentIndex_);

        genCashFlows[0][0].timeIndex = currentIndex_;
        genCashFlows[0][0].amount =
            -multiplier_*fixedRate_*fixedAccruals_[currentIndex_];

        genCashFlows[0][1].timeIndex = currentIndex_;
        genCashFlows[0][1].amount =
            multiplier_*liborRate*floatingAccruals_[currentIndex_];

        numberCashFlowsThisStep[0] = 2;

        ++currentIndex_;

        return (currentIndex_ == lastIndex_);
    }

    std::unique_ptr<MarketModelMultiProduct>
    MultiStepSwap::clone() const {
        return std::unique_ptr<MarketModelMultiProduct>(new MultiStepSwap(*this));
    }

}

]]></document_content>
  </document>
  <document index="90">
    <source>marketmodels/products/multistep/multistepswaption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/products/multistep/multistepswaption.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

   
    MultiStepSwaption::MultiStepSwaption(const std::vector<Time>& rateTimes,
                                     Size startIndex,
                                     Size endIndex,
                                     ext::shared_ptr<StrikedTypePayoff> & payOff)
                                     : MultiProductMultiStep(rateTimes),
     startIndex_(startIndex), endIndex_(endIndex), payoff_(payOff) 
    {
        QL_REQUIRE(startIndex_ < endIndex_," start index must be before end index");
   
        QL_REQUIRE(endIndex_ < rateTimes.size(), "end index be before the end of the rates.");
        paymentTimes_.push_back(rateTimes[startIndex_]);

    }

    bool MultiStepSwaption::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelMultiProduct::CashFlow> >&
                                                               genCashFlows)
    {
        if (currentIndex_ == startIndex_)
        {
            genCashFlows[0][0].timeIndex = 0;


            Rate swapRate = currentState.cmSwapRate(startIndex_,endIndex_-startIndex_);
            Real annuity = currentState.cmSwapAnnuity(startIndex_,startIndex_,endIndex_-startIndex_);

            genCashFlows[0][0].amount =
                (*payoff_)(swapRate) * annuity;
             
            numberCashFlowsThisStep[0] =genCashFlows[0][0].amount != 0.0 ? 1 : 0 ;

            return true;
        }
        else
        {
            numberCashFlowsThisStep[0] =0;
            ++currentIndex_;
            return false;
        }
    }

    std::unique_ptr<MarketModelMultiProduct>
    MultiStepSwaption::clone() const {
        return std::unique_ptr<MarketModelMultiProduct>(new MultiStepSwaption(*this));
    }

}
]]></document_content>
  </document>
  <document index="91">
    <source>marketmodels/products/multistep/multisteptarn.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/products/multistep/multisteptarn.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <cmath>
#include <utility>

namespace QuantLib {

    MultiStepTarn::MultiStepTarn(const std::vector<Time>& rateTimes,
                                 const std::vector<Real>& accruals,
                                 const std::vector<Real>& accrualsFloating,
                                 const std::vector<Time>& paymentTimes,
                                 const std::vector<Time>& paymentTimesFloating,
                                 Real totalCoupon,
                                 const std::vector<Real>& strikes,
                                 std::vector<Real> multipliers,
                                 const std::vector<Real>& floatingSpreads)
    : MultiProductMultiStep(rateTimes), accruals_(accruals), accrualsFloating_(accrualsFloating),
      paymentTimes_(paymentTimes), paymentTimesFloating_(paymentTimesFloating),
      allPaymentTimes_(paymentTimes), totalCoupon_(totalCoupon), strikes_(strikes),
      multipliers_(std::move(multipliers)), floatingSpreads_(floatingSpreads) {
        QL_REQUIRE(accruals_.size()+1 == rateTimes.size(), "missized accruals in MultiStepTARN");
        QL_REQUIRE(accrualsFloating.size()+1 == rateTimes.size(), "missized accrualsFloating in MultiStepTARN");
        QL_REQUIRE(paymentTimes.size()+1 == rateTimes.size(), "missized paymentTimes in MultiStepTARN");
        QL_REQUIRE(paymentTimesFloating.size()+1 == rateTimes.size(), "missized paymentTimesFloating in MultiStepTARN");
        QL_REQUIRE(strikes.size()+1 == rateTimes.size(), "missized strikes in MultiStepTARN");
        QL_REQUIRE(floatingSpreads.size()+1 == rateTimes.size(), "missized floatingSpreads in MultiStepTARN");

        lastIndex_ = accruals.size();

        for (Size i=0; i < paymentTimesFloating_.size(); ++i)
            allPaymentTimes_.push_back(paymentTimes[i]);
    }

    bool MultiStepTarn::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelMultiProduct::CashFlow> >&
                                                                 genCashFlows)
    {
        Rate liborRate = currentState.forwardRate(currentIndex_);
        
        numberCashFlowsThisStep[0] =2;
        
        genCashFlows[0][0].amount = (liborRate+floatingSpreads_[currentIndex_])*accrualsFloating_[currentIndex_];
        genCashFlows[0][0].timeIndex = lastIndex_ + currentIndex_;

        genCashFlows[0][1].timeIndex =  currentIndex_;

        Real obviousCoupon = std::max(strikes_[currentIndex_] - multipliers_[currentIndex_]*liborRate,0.0)*accruals_[currentIndex_];

        couponPaid_+= obviousCoupon;

        ++currentIndex_;

        if (couponPaid_ < totalCoupon_ && currentIndex_ < lastIndex_ )
        {
              genCashFlows[0][1].amount = -  obviousCoupon;
              return false;
        }

        Real coupon = obviousCoupon +(totalCoupon_ -couponPaid_);
        genCashFlows[0][1].amount = - coupon;

        return true;
    }

    std::unique_ptr<MarketModelMultiProduct>
    MultiStepTarn::clone() const {
        return std::unique_ptr<MarketModelMultiProduct>(new MultiStepTarn(*this));
    }



    std::vector<Time>
    MultiStepTarn::possibleCashFlowTimes() const {
        return allPaymentTimes_;
    }

   Size MultiStepTarn::numberOfProducts() const {
        return 1;
    }

    Size
    MultiStepTarn::maxNumberOfCashFlowsPerProductPerStep() const {
        return 2;
    }

    void MultiStepTarn::reset() 
    {
       currentIndex_=0;
       couponPaid_ = 0.0;
    }

}

]]></document_content>
  </document>
  <document index="92">
    <source>marketmodels/products/onestep/onestepcoinitialswaps.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/products/onestep/onestepcoinitialswaps.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {

    OneStepCoinitialSwaps::OneStepCoinitialSwaps(const std::vector<Time>& rateTimes,
                                                 std::vector<Real> fixedAccruals,
                                                 std::vector<Real> floatingAccruals,
                                                 const std::vector<Time>& paymentTimes,
                                                 Real fixedRate)
    : MultiProductOneStep(rateTimes), fixedAccruals_(std::move(fixedAccruals)),
      floatingAccruals_(std::move(floatingAccruals)), paymentTimes_(paymentTimes),
      fixedRate_(fixedRate) {

        checkIncreasingTimes(paymentTimes);

        lastIndex_ = rateTimes.size()-1;
    }

    bool OneStepCoinitialSwaps::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelMultiProduct::CashFlow> >&
                                                               genCashFlows) {
        std::fill(numberCashFlowsThisStep.begin(),
                  numberCashFlowsThisStep.end(),0);

        for (Size indexOfTime=0;indexOfTime<lastIndex_;indexOfTime++) {
            Rate liborRate = currentState.forwardRate(indexOfTime);
            for (Size i=indexOfTime;i<lastIndex_;i++) {
                genCashFlows[i][(indexOfTime)*2].timeIndex = indexOfTime;
                genCashFlows[i][(indexOfTime)*2].amount =
                    -fixedRate_*fixedAccruals_[indexOfTime];

                genCashFlows[i][(indexOfTime)*2+1].timeIndex = indexOfTime;
                genCashFlows[i][(indexOfTime)*2+1].amount =
                    liborRate*floatingAccruals_[indexOfTime];

                numberCashFlowsThisStep[i] += 2;
            }
        }
        return true ;
    }

    std::unique_ptr<MarketModelMultiProduct>
    OneStepCoinitialSwaps::clone() const {
        return std::unique_ptr<MarketModelMultiProduct>(new OneStepCoinitialSwaps(*this));
    }

}

]]></document_content>
  </document>
  <document index="93">
    <source>marketmodels/products/onestep/onestepcoterminalswaps.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/products/onestep/onestepcoterminalswaps.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {

    OneStepCoterminalSwaps::OneStepCoterminalSwaps(const std::vector<Time>& rateTimes,
                                                   std::vector<Real> fixedAccruals,
                                                   std::vector<Real> floatingAccruals,
                                                   const std::vector<Time>& paymentTimes,
                                                   Real fixedRate)
    : MultiProductOneStep(rateTimes), fixedAccruals_(std::move(fixedAccruals)),
      floatingAccruals_(std::move(floatingAccruals)), paymentTimes_(paymentTimes),
      fixedRate_(fixedRate) {
        checkIncreasingTimes(paymentTimes);

        lastIndex_ = rateTimes.size()-1;
    }

    bool OneStepCoterminalSwaps::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelMultiProduct::CashFlow> >&
                                                               genCashFlows) {
        std::fill(numberCashFlowsThisStep.begin(),
                  numberCashFlowsThisStep.end(),0);

        for (Size indexOfTime=0;indexOfTime<lastIndex_;indexOfTime++) {
            Rate liborRate = currentState.forwardRate(indexOfTime);

            for (Size i=0;i<=indexOfTime;i++) {
                genCashFlows[i][(indexOfTime-i)*2].timeIndex = indexOfTime;
                genCashFlows[i][(indexOfTime-i)*2].amount =
                    -fixedRate_*fixedAccruals_[indexOfTime];

                genCashFlows[i][(indexOfTime-i)*2+1].timeIndex = indexOfTime;
                genCashFlows[i][(indexOfTime-i)*2+1].amount =
                    liborRate*floatingAccruals_[indexOfTime];

                numberCashFlowsThisStep[i] += 2;
            }
        }
        return true ;
    }

    std::unique_ptr<MarketModelMultiProduct>
    OneStepCoterminalSwaps::clone() const {
        return std::unique_ptr<MarketModelMultiProduct>(new OneStepCoterminalSwaps(*this));
    }

}
]]></document_content>
  </document>
  <document index="94">
    <source>marketmodels/products/onestep/onestepforwards.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/products/onestep/onestepforwards.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {

    OneStepForwards::OneStepForwards(const std::vector<Time>& rateTimes,
                                     std::vector<Real> accruals,
                                     const std::vector<Time>& paymentTimes,
                                     std::vector<Rate> strikes)
    : MultiProductOneStep(rateTimes), accruals_(std::move(accruals)), paymentTimes_(paymentTimes),
      strikes_(std::move(strikes)) {
        checkIncreasingTimes(paymentTimes);
    }

    bool OneStepForwards::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelMultiProduct::CashFlow> >&
                                                               genCashFlows) {
        for (Size i=0; i<strikes_.size(); ++i) {
            Rate liborRate = currentState.forwardRate(i);
            genCashFlows[i][0].timeIndex = i;
            genCashFlows[i][0].amount =
                (liborRate-strikes_[i])*accruals_[i];
        }

        std::fill(numberCashFlowsThisStep.begin(),
                  numberCashFlowsThisStep.end(), 1);
        return true;
    }

    std::unique_ptr<MarketModelMultiProduct>
    OneStepForwards::clone() const {
        return std::unique_ptr<MarketModelMultiProduct>(new OneStepForwards(*this));
    }

}

]]></document_content>
  </document>
  <document index="95">
    <source>marketmodels/products/onestep/onestepoptionlets.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/products/onestep/onestepoptionlets.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <ql/payoff.hpp>
#include <utility>

namespace QuantLib {

    OneStepOptionlets::OneStepOptionlets(const std::vector<Time>& rateTimes,
                                         std::vector<Real> accruals,
                                         const std::vector<Time>& paymentTimes,
                                         std::vector<ext::shared_ptr<Payoff> > payoffs)
    : MultiProductOneStep(rateTimes), accruals_(std::move(accruals)), paymentTimes_(paymentTimes),
      payoffs_(std::move(payoffs)) {
        checkIncreasingTimes(paymentTimes);
    }

    bool OneStepOptionlets::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelMultiProduct::CashFlow> >&
                                                               genCashFlows) {
        std::fill(numberCashFlowsThisStep.begin(),
                  numberCashFlowsThisStep.end(), 0);
        for (Size i=0; i<payoffs_.size(); ++i) {
            Rate liborRate = currentState.forwardRate(i);
            Real payoff = (*payoffs_[i])(liborRate);
            if (payoff>0.0) {
                numberCashFlowsThisStep[i] = 1;
                genCashFlows[i][0].timeIndex = i;
                genCashFlows[i][0].amount = payoff*accruals_[i];
            }
        }

        return true;
    }

    std::unique_ptr<MarketModelMultiProduct>
    OneStepOptionlets::clone() const {
        return std::unique_ptr<MarketModelMultiProduct>(new OneStepOptionlets(*this));
    }

}
]]></document_content>
  </document>
  <document index="96">
    <source>marketmodels/products/pathwise/pathwiseproductcallspecified.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2009 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/matrix.hpp>
#include <ql/models/marketmodels/products/pathwise/pathwiseproductcallspecified.hpp>
#include <ql/models/marketmodels/products/pathwise/pathwiseproductcashrebate.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {

    CallSpecifiedPathwiseMultiProduct::CallSpecifiedPathwiseMultiProduct(
        const Clone<MarketModelPathwiseMultiProduct>& underlying,
        const Clone<ExerciseStrategy<CurveState> >& strategy,
        Clone<MarketModelPathwiseMultiProduct> rebate)
    : underlying_(underlying), strategy_(strategy), rebate_(std::move(rebate)) {
        Size products = underlying_->numberOfProducts();
        EvolutionDescription d1 = underlying->evolution();
        const std::vector<Time>& rateTimes1 = d1.rateTimes();
        const std::vector<Time>& evolutionTimes1 = d1.evolutionTimes();
        const std::vector<Time>& exerciseTimes = strategy->exerciseTimes();

        if (!rebate_.empty()) {
            EvolutionDescription d2 = rebate_->evolution();
            const std::vector<Time>& rateTimes2 = d2.rateTimes();
            QL_REQUIRE(rateTimes1.size() == rateTimes2.size() &&
                           std::equal(rateTimes1.begin(), rateTimes1.end(), rateTimes2.begin()),
                       "incompatible rate times");

            QL_REQUIRE(underlying_->alreadyDeflated() == rebate_->alreadyDeflated(),
                       "incompatible deflations");
        } else {
            EvolutionDescription description(rateTimes1, exerciseTimes);
            Matrix amounts(products, exerciseTimes.size(), 0.0);

            rebate_ = MarketModelPathwiseCashRebate(description, exerciseTimes, amounts, products);
        }

        std::vector<Time> mergedEvolutionTimes;
        std::vector<std::vector<Time> > allEvolutionTimes(4);
        allEvolutionTimes[0] = evolutionTimes1;
        allEvolutionTimes[1] = exerciseTimes;
        allEvolutionTimes[2] = rebate_->evolution().evolutionTimes();
        allEvolutionTimes[3] = strategy->relevantTimes();

        mergeTimes(allEvolutionTimes, mergedEvolutionTimes, isPresent_);

        // TODO: add relevant rates
        evolution_ = EvolutionDescription(rateTimes1, mergedEvolutionTimes);

        cashFlowTimes_ = underlying_->possibleCashFlowTimes();
        rebateOffset_ = cashFlowTimes_.size();
        const std::vector<Time> rebateTimes = rebate_->possibleCashFlowTimes();
        cashFlowTimes_.insert(cashFlowTimes_.end(), rebateTimes.begin(), rebateTimes.end());

        dummyCashFlowsThisStep_ = std::vector<Size>(products, 0);
        Size n = rebate_->maxNumberOfCashFlowsPerProductPerStep();

        CashFlow modelCashFlow;
        modelCashFlow.amount.resize(d1.numberOfRates() + 1);

        dummyCashFlowsGenerated_ =
            std::vector<std::vector<CashFlow> >(products, std::vector<CashFlow>(n, modelCashFlow));
    }

    bool CallSpecifiedPathwiseMultiProduct::alreadyDeflated() const {
        return underlying_->alreadyDeflated();
    }

    std::vector<Size> CallSpecifiedPathwiseMultiProduct::suggestedNumeraires() const {
        return underlying_->suggestedNumeraires();
    }

    const EvolutionDescription& CallSpecifiedPathwiseMultiProduct::evolution() const {
        return evolution_;
    }

    std::vector<Time> CallSpecifiedPathwiseMultiProduct::possibleCashFlowTimes() const {
        return cashFlowTimes_;
    }

    Size CallSpecifiedPathwiseMultiProduct::numberOfProducts() const {
        return underlying_->numberOfProducts();
    }

    Size CallSpecifiedPathwiseMultiProduct::maxNumberOfCashFlowsPerProductPerStep() const {
        return std::max(underlying_->maxNumberOfCashFlowsPerProductPerStep(),
                        rebate_->maxNumberOfCashFlowsPerProductPerStep());
    }

    void CallSpecifiedPathwiseMultiProduct::reset() {
        underlying_->reset();
        rebate_->reset();
        strategy_->reset();
        currentIndex_ = 0;
        wasCalled_ = false;
    }


    bool CallSpecifiedPathwiseMultiProduct::nextTimeStep(
        const CurveState& currentState,
        std::vector<Size>& numberCashFlowsThisStep,
        std::vector<std::vector<CashFlow> >& cashFlowsGenerated) {

        bool isUnderlyingTime = isPresent_[0][currentIndex_];
        bool isExerciseTime = isPresent_[1][currentIndex_];
        bool isRebateTime = isPresent_[2][currentIndex_];
        bool isStrategyRelevantTime = isPresent_[3][currentIndex_];

        bool done = false;

        if (!wasCalled_ && isStrategyRelevantTime)
            strategy_->nextStep(currentState);


        if (!wasCalled_ && isExerciseTime && callable_)
            wasCalled_ = strategy_->exercise(currentState);

        if (wasCalled_) {
            if (isRebateTime) {
                done = rebate_->nextTimeStep(currentState, numberCashFlowsThisStep,
                                             cashFlowsGenerated);
                for (Size i = 0; i < numberCashFlowsThisStep.size(); ++i)
                    for (Size j = 0; j < numberCashFlowsThisStep[i]; ++j)
                        cashFlowsGenerated[i][j].timeIndex += rebateOffset_;
            }
        } else {
            if (isRebateTime)
                rebate_->nextTimeStep(currentState, dummyCashFlowsThisStep_,
                                      dummyCashFlowsGenerated_);
            if (isUnderlyingTime)
                done = underlying_->nextTimeStep(currentState, numberCashFlowsThisStep,
                                                 cashFlowsGenerated);
        }

        ++currentIndex_;
        return done || currentIndex_ == evolution_.evolutionTimes().size();
    }

    std::unique_ptr<MarketModelPathwiseMultiProduct>
    CallSpecifiedPathwiseMultiProduct::clone() const {
        return std::unique_ptr<MarketModelPathwiseMultiProduct>(new CallSpecifiedPathwiseMultiProduct(*this));
    }

    const MarketModelPathwiseMultiProduct& CallSpecifiedPathwiseMultiProduct::underlying() const {
        return *underlying_;
    }

    const ExerciseStrategy<CurveState>& CallSpecifiedPathwiseMultiProduct::strategy() const {
        return *strategy_;
    }

    const MarketModelPathwiseMultiProduct& CallSpecifiedPathwiseMultiProduct::rebate() const {
        return *rebate_;
    }

    void CallSpecifiedPathwiseMultiProduct::enableCallability() { callable_ = true; }

    void CallSpecifiedPathwiseMultiProduct::disableCallability() { callable_ = false; }

    }





]]></document_content>
  </document>
  <document index="97">
    <source>marketmodels/products/pathwise/pathwiseproductcaplet.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2008 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/products/multistep/multistepforwards.hpp>
#include <ql/models/marketmodels/products/pathwise/pathwiseproductcaplet.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib {


    bool MarketModelPathwiseMultiCaplet::alreadyDeflated() const
    {
        return false;
    }

    MarketModelPathwiseMultiCaplet::MarketModelPathwiseMultiCaplet(const std::vector<Time>& rateTimes,
        const std::vector<Real>& accruals,
        const std::vector<Time>& paymentTimes,
        const std::vector<Rate>& strikes)
        : rateTimes_(rateTimes), 
        accruals_(accruals),
        paymentTimes_(paymentTimes), 
        strikes_(strikes) ,
        numberRates_(accruals_.size())
    {
        checkIncreasingTimes(rateTimes);
        checkIncreasingTimes(paymentTimes);
        std::vector<Time> evolTimes(rateTimes_);
        evolTimes.pop_back();

        QL_REQUIRE(evolTimes.size()==numberRates_,
            "rateTimes.size()<> numberOfRates+1");

        QL_REQUIRE(paymentTimes.size()==numberRates_,
            "paymentTimes.size()<> numberOfRates");

        QL_REQUIRE(accruals.size()==numberRates_,
            "accruals.size()<> numberOfRates");

        QL_REQUIRE(strikes.size()==numberRates_,
            "strikes.size()<> numberOfRates");


        evolution_ = EvolutionDescription(rateTimes,evolTimes);

    }

   


    bool MarketModelPathwiseMultiCaplet::nextTimeStep(
        const CurveState& currentState,
        std::vector<Size>& numberCashFlowsThisStep,
        std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >& cashFlowsGenerated) 
    {
        Rate liborRate = currentState.forwardRate(currentIndex_);
        cashFlowsGenerated[currentIndex_][0].timeIndex = currentIndex_;
        cashFlowsGenerated[currentIndex_][0].amount[0] =
            (liborRate-strikes_[currentIndex_])*accruals_[currentIndex_];

        std::fill(numberCashFlowsThisStep.begin(),
            numberCashFlowsThisStep.end(),0);

        if (  cashFlowsGenerated[currentIndex_][0].amount[0]  >0)
        {
            numberCashFlowsThisStep[currentIndex_] = 1;
            for (Size i=1; i <= numberRates_; ++i)
                cashFlowsGenerated[currentIndex_][0].amount[i] =0;

            cashFlowsGenerated[currentIndex_][0].amount[currentIndex_+1]  = accruals_[currentIndex_];
        }
        ++currentIndex_;
        return (currentIndex_ == strikes_.size());
    }

    std::unique_ptr<MarketModelPathwiseMultiProduct>
    MarketModelPathwiseMultiCaplet::clone() const 
    {
        return std::unique_ptr<MarketModelPathwiseMultiProduct>(new MarketModelPathwiseMultiCaplet(*this));
    }

    std::vector<Size> MarketModelPathwiseMultiCaplet::suggestedNumeraires() const
    {
        std::vector<Size> numeraires(numberRates_);
        for (Size i=0; i < numberRates_; ++i)
            numeraires[i] = i+1;

        return numeraires;
    }

    const EvolutionDescription& MarketModelPathwiseMultiCaplet::evolution() const
    {
        return evolution_;
    }

    std::vector<Time> MarketModelPathwiseMultiCaplet::possibleCashFlowTimes() const
    {
        return paymentTimes_;
    }

    Size MarketModelPathwiseMultiCaplet::numberOfProducts() const
    {
        return numberRates_;
    }

    Size MarketModelPathwiseMultiCaplet::maxNumberOfCashFlowsPerProductPerStep() const
    {
        return 1;

    }

    void MarketModelPathwiseMultiCaplet::reset()
    {
        currentIndex_=0;
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    bool MarketModelPathwiseMultiDeflatedCaplet::alreadyDeflated() const
    {
        return true;
    }


    MarketModelPathwiseMultiDeflatedCaplet::MarketModelPathwiseMultiDeflatedCaplet(const std::vector<Time>& rateTimes,
        const std::vector<Real>& accruals,
        const std::vector<Time>& paymentTimes,
        const std::vector<Rate>& strikes)
        : rateTimes_(rateTimes), 
        accruals_(accruals),
        paymentTimes_(paymentTimes), 
        strikes_(strikes) ,
        numberRates_(accruals_.size())
    {
        checkIncreasingTimes(rateTimes);
        checkIncreasingTimes(paymentTimes);
        std::vector<Time> evolTimes(rateTimes_);
        evolTimes.pop_back();

        QL_REQUIRE(evolTimes.size()==numberRates_,
            "rateTimes.size()<> numberOfRates+1");

        QL_REQUIRE(paymentTimes.size()==numberRates_,
            "paymentTimes.size()<> numberOfRates");

        QL_REQUIRE(accruals.size()==numberRates_,
            "accruals.size()<> numberOfRates");

        QL_REQUIRE(strikes.size()==numberRates_,
            "strikes.size()<> numberOfRates");


        evolution_ = EvolutionDescription(rateTimes,evolTimes);

    }

       MarketModelPathwiseMultiDeflatedCaplet::MarketModelPathwiseMultiDeflatedCaplet(const std::vector<Time>& rateTimes,
        const std::vector<Real>& accruals,
        const std::vector<Time>& paymentTimes,
        Rate strike)
        : rateTimes_(rateTimes), 
        accruals_(accruals),
        paymentTimes_(paymentTimes), 
        strikes_(accruals.size()) ,
        numberRates_(accruals_.size())
    {
        checkIncreasingTimes(rateTimes);
        checkIncreasingTimes(paymentTimes);
        std::vector<Time> evolTimes(rateTimes_);
        evolTimes.pop_back();

        QL_REQUIRE(evolTimes.size()==numberRates_,
            "rateTimes.size()<> numberOfRates+1");

        QL_REQUIRE(paymentTimes.size()==numberRates_,
            "paymentTimes.size()<> numberOfRates");

        QL_REQUIRE(accruals.size()==numberRates_,
            "accruals.size()<> numberOfRates");

        
        std::fill(strikes_.begin(), strikes_.end(),strike);


        evolution_ = EvolutionDescription(rateTimes,evolTimes);

    }


    bool MarketModelPathwiseMultiDeflatedCaplet::nextTimeStep(
        const CurveState& currentState,
        std::vector<Size>& numberCashFlowsThisStep,
        std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >& cashFlowsGenerated) 
    {
        Rate liborRate = currentState.forwardRate(currentIndex_);
        cashFlowsGenerated[currentIndex_][0].timeIndex = currentIndex_;
        cashFlowsGenerated[currentIndex_][0].amount[0] =
            (liborRate-strikes_[currentIndex_])*accruals_[currentIndex_]*currentState.discountRatio(currentIndex_+1,0);

        std::fill(numberCashFlowsThisStep.begin(),
            numberCashFlowsThisStep.end(),0);

        if (  cashFlowsGenerated[currentIndex_][0].amount[0]  >0)
        {
            numberCashFlowsThisStep[currentIndex_] = 1;
            for (Size i=1; i <= numberRates_; ++i)
                cashFlowsGenerated[currentIndex_][0].amount[i] =0;

            cashFlowsGenerated[currentIndex_][0].amount[currentIndex_+1]  = accruals_[currentIndex_]*currentState.discountRatio(currentIndex_+1,0);

            for (Size i=0; i <= currentIndex_; ++i)
            {
                Real stepDF = currentState.discountRatio(i+1,i);
                cashFlowsGenerated[currentIndex_][0].amount[i+1] -=   accruals_[i]*stepDF
                    *cashFlowsGenerated[currentIndex_][0].amount[0];
            }
        }
        ++currentIndex_;
        return (currentIndex_ == strikes_.size());
    }

    std::unique_ptr<MarketModelPathwiseMultiProduct>
    MarketModelPathwiseMultiDeflatedCaplet::clone() const 
    {
        return std::unique_ptr<MarketModelPathwiseMultiProduct>(new MarketModelPathwiseMultiDeflatedCaplet(*this));
    }

    std::vector<Size> MarketModelPathwiseMultiDeflatedCaplet::suggestedNumeraires() const
    {
        std::vector<Size> numeraires(numberRates_);
        for (Size i=0; i < numberRates_; ++i)
            numeraires[i] = i;

        return numeraires;
    }

    const EvolutionDescription& MarketModelPathwiseMultiDeflatedCaplet::evolution() const
    {
        return evolution_;
    }

    std::vector<Time> MarketModelPathwiseMultiDeflatedCaplet::possibleCashFlowTimes() const
    {
        return paymentTimes_;
    }

    Size MarketModelPathwiseMultiDeflatedCaplet::numberOfProducts() const
    {
        return numberRates_;
    }

    Size MarketModelPathwiseMultiDeflatedCaplet::maxNumberOfCashFlowsPerProductPerStep() const
    {
        return 1;

    }

    void MarketModelPathwiseMultiDeflatedCaplet::reset()
    {
        currentIndex_=0;
    }

    MarketModelPathwiseMultiDeflatedCap::MarketModelPathwiseMultiDeflatedCap(
        const std::vector<Time>& rateTimes,
        const std::vector<Real>& accruals,
        const std::vector<Time>& paymentTimes,
        Rate strike,
        std::vector<std::pair<Size, Size> > startsAndEnds)
    : underlyingCaplets_(rateTimes, accruals, paymentTimes, strike), numberRates_(accruals.size()),
      startsAndEnds_(std::move(startsAndEnds)) {
        for (Size j=0; j < startsAndEnds_.size(); ++j)
        {
            QL_REQUIRE(startsAndEnds_[j].first < startsAndEnds_[j].second,"a cap must start before it ends: " << j << startsAndEnds_[j].first << startsAndEnds_[j].second );
            QL_REQUIRE(startsAndEnds_[j].second <= accruals.size() ,"a cap must end when the underlying caplets: " << j << startsAndEnds_[j].first << startsAndEnds_[j].second );
           
        }

        innerCashFlowSizes_.resize(accruals.size());
        innerCashFlowsGenerated_.resize(accruals.size());
        for (auto& i : innerCashFlowsGenerated_) {
            i.resize(underlyingCaplets_.maxNumberOfCashFlowsPerProductPerStep());
            for (Size j=0; j < underlyingCaplets_.maxNumberOfCashFlowsPerProductPerStep(); ++j)
                i[j].amount.resize(accruals.size() + 1);
        }
    }


    std::vector<Size> MarketModelPathwiseMultiDeflatedCap::suggestedNumeraires() const
    {
        return underlyingCaplets_.suggestedNumeraires();
    }


    const EvolutionDescription& MarketModelPathwiseMultiDeflatedCap::evolution() const
    {
        return underlyingCaplets_.evolution();
    }

    std::vector<Time> MarketModelPathwiseMultiDeflatedCap::possibleCashFlowTimes() const
    {
        return underlyingCaplets_.possibleCashFlowTimes();
    }

    Size MarketModelPathwiseMultiDeflatedCap::numberOfProducts() const
    {
        return startsAndEnds_.size();
    }
    Size MarketModelPathwiseMultiDeflatedCap::maxNumberOfCashFlowsPerProductPerStep() const
    {
        return underlyingCaplets_.maxNumberOfCashFlowsPerProductPerStep();
    }

    // has division by the numeraire already been done?
    bool MarketModelPathwiseMultiDeflatedCap::alreadyDeflated() const
    {
        return underlyingCaplets_.alreadyDeflated();
    }


    void MarketModelPathwiseMultiDeflatedCap::reset()
    {
        underlyingCaplets_.reset();
        currentIndex_=0;
    }


    bool MarketModelPathwiseMultiDeflatedCap::nextTimeStep(
        const CurveState& currentState,
        std::vector<Size>& numberCashFlowsThisStep,
        std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >& cashFlowsGenerated)
    {

        bool done = underlyingCaplets_.nextTimeStep(currentState, innerCashFlowSizes_, innerCashFlowsGenerated_);
        
        for (Size k=0; k < startsAndEnds_.size(); ++k)
            numberCashFlowsThisStep[k]=0;

        for (Size j=0; j < numberRates_; ++j)
        {
            if (innerCashFlowSizes_[j]>0)
            {
                for (Size k=0; k < startsAndEnds_.size(); ++k)
                {
                    if (startsAndEnds_[k].first <= j && j < startsAndEnds_[k].second)
                    {
                        for (Size l=0; l < innerCashFlowSizes_[j]; ++l)
                            cashFlowsGenerated[k][numberCashFlowsThisStep[k]++] = innerCashFlowsGenerated_[j][l];
                    }
                }
            }
        }

        return done;
    }

    std::unique_ptr<MarketModelPathwiseMultiProduct>
    MarketModelPathwiseMultiDeflatedCap::clone() const
    {
        return std::unique_ptr<MarketModelPathwiseMultiProduct>(new MarketModelPathwiseMultiDeflatedCap(*this));
    }

}

]]></document_content>
  </document>
  <document index="98">
    <source>marketmodels/products/pathwise/pathwiseproductcashrebate.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/products/pathwise/pathwiseproductcashrebate.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib 
{


    bool MarketModelPathwiseCashRebate::alreadyDeflated() const
    {
        return false;
    }

    MarketModelPathwiseCashRebate::MarketModelPathwiseCashRebate(
        EvolutionDescription evolution,
        const std::vector<Time>& paymentTimes,
        Matrix amounts,
        Size numberOfProducts)
    : evolution_(std::move(evolution)), paymentTimes_(paymentTimes), amounts_(std::move(amounts)),
      numberOfProducts_(numberOfProducts) {

        checkIncreasingTimes(paymentTimes);

        QL_REQUIRE(amounts_.rows() == numberOfProducts_,
                   "the number of rows in the matrix must equal "
                   "the number of products");
        QL_REQUIRE(amounts_.columns() == paymentTimes_.size(),
                   "the number of columns in the matrix must equal "
                   "the number of payment times");
        QL_REQUIRE(evolution_.evolutionTimes().size() == paymentTimes_.size(),
                   "the number of evolution times must equal "
                   "the number of payment times");
    }


    std::vector<Time>
    MarketModelPathwiseCashRebate::possibleCashFlowTimes() const 
    {
        return paymentTimes_;
    }

    Size MarketModelPathwiseCashRebate::numberOfProducts() const 
    {
        return numberOfProducts_;
    }

    Size MarketModelPathwiseCashRebate::maxNumberOfCashFlowsPerProductPerStep() const 
    {
        return 1;
    }

    void MarketModelPathwiseCashRebate::reset() 
    {
       currentIndex_=0;
    }

    std::vector<Size>
    MarketModelPathwiseCashRebate::suggestedNumeraires() const 
    {
        QL_FAIL("not implemented (yet?)");
    }

    const EvolutionDescription& MarketModelPathwiseCashRebate::evolution() const
    {
        return evolution_;
    }


    bool MarketModelPathwiseCashRebate::nextTimeStep(
            const CurveState&,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >& cashFlowsGenerated) 
    {
        for (Size i=0; i<numberOfProducts_; ++i) 
        {
            numberCashFlowsThisStep[i] = 1;
            cashFlowsGenerated[i][0].timeIndex = currentIndex_;
            cashFlowsGenerated[i][0].amount[0] = amounts_[i][currentIndex_];

            for (Size k=1; k <= evolution_.numberOfRates(); ++k)
                 cashFlowsGenerated[i][0].amount[k] = 0.0;
 
        }
        ++currentIndex_;
        return true;
    }

    std::unique_ptr<MarketModelPathwiseMultiProduct>
    MarketModelPathwiseCashRebate::clone() const 
    {
        return std::unique_ptr<MarketModelPathwiseMultiProduct>(new MarketModelPathwiseCashRebate(*this));
    }

}
]]></document_content>
  </document>
  <document index="99">
    <source>marketmodels/products/pathwise/pathwiseproductinversefloater.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2009 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/products/pathwise/pathwiseproductinversefloater.hpp>
#include <ql/models/marketmodels/utilities.hpp>
#include <utility>

namespace QuantLib 
{


    bool MarketModelPathwiseInverseFloater::alreadyDeflated() const
    {
        return false;
    }

    MarketModelPathwiseInverseFloater::MarketModelPathwiseInverseFloater(
        const std::vector<Time>& rateTimes,
        std::vector<Real> fixedAccruals,
        const std::vector<Real>& floatingAccruals,
        const std::vector<Real>& fixedStrikes,
        const std::vector<Real>& fixedMultipliers,
        const std::vector<Real>& floatingSpreads,
        const std::vector<Time>& paymentTimes,
        bool payer)
    : rateTimes_(rateTimes), fixedAccruals_(std::move(fixedAccruals)),
      floatingAccruals_(floatingAccruals), fixedStrikes_(fixedStrikes),
      fixedMultipliers_(fixedMultipliers), floatingSpreads_(floatingSpreads),
      paymentTimes_(paymentTimes), multiplier_(payer ? -1.0 : 1.0),
      lastIndex_(rateTimes.size() - 1) {
        checkIncreasingTimes(paymentTimes);
        QL_REQUIRE(fixedAccruals_.size() == lastIndex_," Incorrect number of fixedAccruals given, should be " <<  lastIndex_ << " not " << fixedAccruals_.size() );
        QL_REQUIRE(floatingAccruals.size() == lastIndex_," Incorrect number of floatingAccruals given, should be " <<  lastIndex_ << " not " << floatingAccruals.size() );
        QL_REQUIRE(fixedStrikes.size() == lastIndex_," Incorrect number of fixedStrikes given, should be " <<  lastIndex_ << " not " << fixedStrikes.size() );
        QL_REQUIRE(fixedMultipliers.size() == lastIndex_," Incorrect number of fixedMultipliers given, should be " <<  lastIndex_ << " not " << fixedMultipliers.size() );
        QL_REQUIRE(floatingSpreads.size() == lastIndex_," Incorrect number of floatingSpreads given, should be " <<  lastIndex_ << " not " << floatingSpreads.size() );
        QL_REQUIRE(paymentTimes.size() == lastIndex_," Incorrect number of paymentTimes given, should be " <<  lastIndex_ << " not " << paymentTimes.size() );

        std::vector<Time> evolTimes(rateTimes);
        evolTimes.pop_back();


        evolution_ = EvolutionDescription(rateTimes,evolTimes);
    }

    bool MarketModelPathwiseInverseFloater::nextTimeStep(
        const CurveState& currentState,
        std::vector<Size>& numberCashFlowsThisStep,
        std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >& cashFlowsGenerated) 
    {
        numberCashFlowsThisStep[0] =1 ;
        for (Size i=1; i <= lastIndex_; ++i)
            cashFlowsGenerated[0][0].amount[i] =0;

        Rate liborRate = currentState.forwardRate(currentIndex_);
        Real inverseFloatingCoupon = std::max((fixedStrikes_[currentIndex_] - fixedMultipliers_[currentIndex_]*liborRate),0.0)*fixedAccruals_[currentIndex_] ;
        Real floatingCoupon = (liborRate+floatingSpreads_[currentIndex_])*floatingAccruals_[currentIndex_];
        cashFlowsGenerated[0][0].timeIndex = currentIndex_;
        cashFlowsGenerated[0][0].amount[0] =multiplier_*(inverseFloatingCoupon - floatingCoupon);
 
 

        if (inverseFloatingCoupon > 0.0)
        {

            cashFlowsGenerated[0][0].amount[currentIndex_+1] =multiplier_*( - fixedMultipliers_[currentIndex_]*fixedAccruals_[currentIndex_]  - floatingAccruals_[currentIndex_]);


        }
        else
        {

            cashFlowsGenerated[0][0].amount[currentIndex_+1] =-multiplier_*floatingAccruals_[currentIndex_];

        }

        ++currentIndex_;

        return (currentIndex_ == lastIndex_);


    }

    std::unique_ptr<MarketModelPathwiseMultiProduct>
    MarketModelPathwiseInverseFloater::clone() const 
    {
        return std::unique_ptr<MarketModelPathwiseMultiProduct>(new MarketModelPathwiseInverseFloater(*this));
    }

    std::vector<Size> MarketModelPathwiseInverseFloater::suggestedNumeraires() const
    {
        std::vector<Size> numeraires(lastIndex_);
        for (Size i=0; i < lastIndex_; ++i)
            numeraires[i] = i;

        return numeraires;
    }

    const EvolutionDescription& MarketModelPathwiseInverseFloater::evolution() const
    {
        return evolution_;
    }

    std::vector<Time> MarketModelPathwiseInverseFloater::possibleCashFlowTimes() const
    {
        return paymentTimes_; 
    }

    Size MarketModelPathwiseInverseFloater::numberOfProducts() const
    {
        return 1;
    }

    Size MarketModelPathwiseInverseFloater::maxNumberOfCashFlowsPerProductPerStep() const
    {
        return 1;

    }

    void MarketModelPathwiseInverseFloater::reset()
    {
        currentIndex_=0;
    }

}

]]></document_content>
  </document>
  <document index="100">
    <source>marketmodels/products/pathwise/pathwiseproductswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/products/pathwise/pathwiseproductswap.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/utilities.hpp>

namespace QuantLib 
{


    bool MarketModelPathwiseSwap::alreadyDeflated() const
    {
        return false;
    }

    MarketModelPathwiseSwap::MarketModelPathwiseSwap(const std::vector<Time>& rateTimes,
                         const std::vector<Real>& accruals,
                        const std::vector<Rate>& strikes, 
                        Real multiplier)
    : rateTimes_(rateTimes), 
      accruals_(accruals),
      strikes_(strikes) ,
      numberRates_(rateTimes.size()-1),
      multiplier_(multiplier)
    {
        checkIncreasingTimes(rateTimes);
        std::vector<Time> evolTimes(rateTimes_);
        evolTimes.pop_back();

        QL_REQUIRE(evolTimes.size()==numberRates_,
                   "rateTimes.size()<> numberOfRates+1");

        if (strikes_.size() == 1)
            strikes_ = std::vector<Rate>(numberRates_, strikes[0]);

        if (accruals_.size() == 1)
            accruals_ = std::vector<Rate>(numberRates_, accruals[0]);

        QL_REQUIRE(accruals_.size()==numberRates_,
                   "accruals.size() does not equal numberOfRates or 1");

        QL_REQUIRE(strikes.size()==numberRates_,
                   "strikes.size() does not equal numberOfRates or 1" );

        evolution_ = EvolutionDescription(rateTimes,evolTimes);

    }

    bool MarketModelPathwiseSwap::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >& cashFlowsGenerated) 
    {
        Rate liborRate = currentState.forwardRate(currentIndex_);
        cashFlowsGenerated[0][0].timeIndex = currentIndex_+1;

        cashFlowsGenerated[0][0].amount[0] =
                     (liborRate-strikes_[currentIndex_])*accruals_[currentIndex_]*multiplier_;

        numberCashFlowsThisStep[0] = 1;
        
        for (Size i=1; i <= numberRates_; ++i)
                cashFlowsGenerated[0][0].amount[i] =0;

        cashFlowsGenerated[0][0].amount[currentIndex_+1] = accruals_[currentIndex_]*multiplier_;
            
        ++currentIndex_;
        return (currentIndex_ == strikes_.size());
    }

    std::unique_ptr<MarketModelPathwiseMultiProduct>
    MarketModelPathwiseSwap::clone() const 
    {
        return std::unique_ptr<MarketModelPathwiseMultiProduct>(new MarketModelPathwiseSwap(*this));
    }

    std::vector<Size> MarketModelPathwiseSwap::suggestedNumeraires() const
    {
            std::vector<Size> numeraires(numberRates_);
            for (Size i=0; i < numberRates_; ++i)
                numeraires[i] = i;

            return numeraires;
    }

    const EvolutionDescription& MarketModelPathwiseSwap::evolution() const
    {
        return evolution_;
    }

    std::vector<Time> MarketModelPathwiseSwap::possibleCashFlowTimes() const
    {
        return rateTimes_; // note rateTimes_[0] is not used as a cash flow time but it is easier to keep track if we include it.
    }

    Size MarketModelPathwiseSwap::numberOfProducts() const
    {
           return 1;
    }
    
    Size MarketModelPathwiseSwap::maxNumberOfCashFlowsPerProductPerStep() const
    {
        return 1;

    }
    
    void MarketModelPathwiseSwap::reset()
    {
        currentIndex_=0;
    }

}

]]></document_content>
  </document>
  <document index="101">
    <source>marketmodels/products/pathwise/pathwiseproductswaption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/products/pathwise/pathwiseproductswaption.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/utilities.hpp>

namespace QuantLib {


    bool MarketModelPathwiseCoterminalSwaptionsDeflated::alreadyDeflated() const
    {
        return false;
    }

    MarketModelPathwiseCoterminalSwaptionsDeflated::MarketModelPathwiseCoterminalSwaptionsDeflated(const std::vector<Time>& rateTimes,
                        const std::vector<Rate>& strikes)
    : rateTimes_(rateTimes), 
      strikes_(strikes) ,
      numberRates_(rateTimes.size()-1)
    {
        checkIncreasingTimes(rateTimes);
        std::vector<Time> evolTimes(rateTimes_);
        evolTimes.pop_back();

        QL_REQUIRE(evolTimes.size()==numberRates_,
                   "rateTimes.size()<> numberOfRates+1");

        QL_REQUIRE(strikes.size()==numberRates_,
                   "strikes.size()<> numberOfRates");


        evolution_ = EvolutionDescription(rateTimes,evolTimes);

    }

    bool MarketModelPathwiseCoterminalSwaptionsDeflated::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >& cashFlowsGenerated) 
    {
        Rate swapRate = currentState.coterminalSwapRate(currentIndex_);
        cashFlowsGenerated[currentIndex_][0].timeIndex = currentIndex_;

        Real annuity = currentState.coterminalSwapAnnuity(currentIndex_,currentIndex_);
        cashFlowsGenerated[currentIndex_][0].amount[0] =
            (swapRate-strikes_[currentIndex_])*annuity;
        
        std::fill(numberCashFlowsThisStep.begin(),
                  numberCashFlowsThisStep.end(),0);

        if (  cashFlowsGenerated[currentIndex_][0].amount[0]  >0)
        {
            numberCashFlowsThisStep[currentIndex_] = 1;
            for (Size i=1; i <= numberRates_; ++i)
                cashFlowsGenerated[currentIndex_][0].amount[i] =0;
            
            for (Size k=currentIndex_; k < numberRates_; ++k)
            {
              cashFlowsGenerated[currentIndex_][0].amount[k+1]  = (rateTimes_[k+1]-rateTimes_[k])*currentState.discountRatio(k+1,currentIndex_); 

              Real multiplier = - (rateTimes_[k+1]-rateTimes_[k])*currentState.discountRatio(k+1,k);

              for (Size l=k; l < numberRates_; ++l)
                 cashFlowsGenerated[currentIndex_][0].amount[k+1]  +=(currentState.forwardRate(l)-strikes_[currentIndex_])*(rateTimes_[l+1]-rateTimes_[l])
                                                                    * multiplier*currentState.discountRatio(l+1,currentIndex_);
            }
        }
        ++currentIndex_;
        return (currentIndex_ == strikes_.size());
    }

    std::unique_ptr<MarketModelPathwiseMultiProduct>
    MarketModelPathwiseCoterminalSwaptionsDeflated::clone() const 
    {
        return std::unique_ptr<MarketModelPathwiseMultiProduct>(new MarketModelPathwiseCoterminalSwaptionsDeflated(*this));
    }

    std::vector<Size> MarketModelPathwiseCoterminalSwaptionsDeflated::suggestedNumeraires() const
    {
            std::vector<Size> numeraires(numberRates_);
            for (Size i=0; i < numberRates_; ++i)
                numeraires[i] = i;

            return numeraires;
    }

    const EvolutionDescription& MarketModelPathwiseCoterminalSwaptionsDeflated::evolution() const
    {
        return evolution_;
    }

    std::vector<Time> MarketModelPathwiseCoterminalSwaptionsDeflated::possibleCashFlowTimes() const
    {
        return rateTimes_;
    }

    Size MarketModelPathwiseCoterminalSwaptionsDeflated::numberOfProducts() const
    {
           return numberRates_;
    }
    
    Size MarketModelPathwiseCoterminalSwaptionsDeflated::maxNumberOfCashFlowsPerProductPerStep() const
    {
        return 1;

    }
    
    void MarketModelPathwiseCoterminalSwaptionsDeflated::reset()
    {
        currentIndex_=0;
    }


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    bool MarketModelPathwiseCoterminalSwaptionsNumericalDeflated::alreadyDeflated() const
    {
        return false;
    }

    MarketModelPathwiseCoterminalSwaptionsNumericalDeflated::MarketModelPathwiseCoterminalSwaptionsNumericalDeflated(const std::vector<Time>& rateTimes,
                                                                const std::vector<Rate>& strikes, 
                                                                Real bumpSize)
    : rateTimes_(rateTimes), 
      strikes_(strikes) ,
      numberRates_(rateTimes.size()-1), bumpSize_(bumpSize), up_(rateTimes), down_(rateTimes), forwards_(numberRates_)
    {
        checkIncreasingTimes(rateTimes);
        std::vector<Time> evolTimes(rateTimes_);
        evolTimes.pop_back();

        QL_REQUIRE(evolTimes.size()==numberRates_,
                   "rateTimes.size()<> numberOfRates+1");

        QL_REQUIRE(strikes.size()==numberRates_,
                   "strikes.size()<> numberOfRates");


        evolution_ = EvolutionDescription(rateTimes,evolTimes);

    }

    bool MarketModelPathwiseCoterminalSwaptionsNumericalDeflated::nextTimeStep(
            const CurveState& currentState,
            std::vector<Size>& numberCashFlowsThisStep,
            std::vector<std::vector<MarketModelPathwiseMultiProduct::CashFlow> >& cashFlowsGenerated) 
    {
        Rate swapRate = currentState.coterminalSwapRate(currentIndex_);
        cashFlowsGenerated[currentIndex_][0].timeIndex = currentIndex_;

        Real annuity = currentState.coterminalSwapAnnuity(currentIndex_,currentIndex_);
        cashFlowsGenerated[currentIndex_][0].amount[0] =
            (swapRate-strikes_[currentIndex_])*annuity;
        
        std::fill(numberCashFlowsThisStep.begin(),
                  numberCashFlowsThisStep.end(),0);

        if (  cashFlowsGenerated[currentIndex_][0].amount[0]  >0)
        {
            numberCashFlowsThisStep[currentIndex_] = 1;
            for (Size i=1; i <= numberRates_; ++i)
                cashFlowsGenerated[currentIndex_][0].amount[i] =0;
            
            for (Size k=currentIndex_; k < numberRates_; ++k)
            {
                forwards_ = currentState.forwardRates();
                forwards_[k] += bumpSize_;
                up_.setOnForwardRates(forwards_);
    
                forwards_[k] -= bumpSize_;
                forwards_[k] -= bumpSize_;
                down_.setOnForwardRates(forwards_);

                Real upSR = up_.coterminalSwapRate(currentIndex_);
                Real upAnnuity = up_.coterminalSwapAnnuity(currentIndex_,currentIndex_);
                Real upValue = (upSR -  strikes_[currentIndex_])*  upAnnuity;

                Real downSR = down_.coterminalSwapRate(currentIndex_);
                Real downAnnuity = down_.coterminalSwapAnnuity(currentIndex_,currentIndex_);
                Real downValue = (downSR -  strikes_[currentIndex_])*  downAnnuity;

                Real deriv = (upValue - downValue)/(2.0*bumpSize_);

                cashFlowsGenerated[currentIndex_][0].amount[k+1]  = deriv; 
            
            }
        }
        ++currentIndex_;
        return (currentIndex_ == strikes_.size());
    }

    std::unique_ptr<MarketModelPathwiseMultiProduct>
    MarketModelPathwiseCoterminalSwaptionsNumericalDeflated::clone() const 
    {
        return std::unique_ptr<MarketModelPathwiseMultiProduct>(
          new MarketModelPathwiseCoterminalSwaptionsNumericalDeflated(*this));
    }

    std::vector<Size> MarketModelPathwiseCoterminalSwaptionsNumericalDeflated::suggestedNumeraires() const
    {
            std::vector<Size> numeraires(numberRates_);
            for (Size i=0; i < numberRates_; ++i)
                numeraires[i] = i;

            return numeraires;
    }

    const EvolutionDescription& MarketModelPathwiseCoterminalSwaptionsNumericalDeflated::evolution() const
    {
        return evolution_;
    }

    std::vector<Time> MarketModelPathwiseCoterminalSwaptionsNumericalDeflated::possibleCashFlowTimes() const
    {
        return rateTimes_;
    }

    Size MarketModelPathwiseCoterminalSwaptionsNumericalDeflated::numberOfProducts() const
    {
           return numberRates_;
    }
    
    Size MarketModelPathwiseCoterminalSwaptionsNumericalDeflated::maxNumberOfCashFlowsPerProductPerStep() const
    {
        return 1;

    }
    
    void MarketModelPathwiseCoterminalSwaptionsNumericalDeflated::reset()
    {
        currentIndex_=0;
    }


}

]]></document_content>
  </document>
  <document index="102">
    <source>marketmodels/products/singleproductcomposite.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/products/singleproductcomposite.hpp>

namespace QuantLib {

    Size SingleProductComposite::numberOfProducts() const {
        return 1;
    }


    Size SingleProductComposite::maxNumberOfCashFlowsPerProductPerStep() const {
        Size result = 0;
        for (const auto& component : components_)
            result += component.product->maxNumberOfCashFlowsPerProductPerStep();
        return result;
    }


    bool SingleProductComposite::nextTimeStep(
                     const CurveState& currentState,
                     std::vector<Size>& numberCashFlowsThisStep,
                     std::vector<std::vector<CashFlow> >& cashFlowsGenerated) {
        QL_REQUIRE(finalized_, "composite not finalized");
        bool done = true;
        Size n = 0, totalCashflows = 0;
        // for each sub-product...
        for (auto i = components_.begin(); i != components_.end(); ++i, ++n) {
            if (isInSubset_[n][currentIndex_] && !i->done) {
                // ...make it evolve...
                bool thisDone = i->product->nextTimeStep(currentState,
                                                         i->numberOfCashflows,
                                                         i->cashflows);
                // ...and copy the results. Time indices need to be remapped
                // so that they point into all cash-flow times. Amounts need
                // to be adjusted by the corresponding multiplier.
                for (Size j=0; j<i->product->numberOfProducts(); ++j) {
                    Size offset = totalCashflows;
                    totalCashflows += i->numberOfCashflows[j];
                    for (Size k=0; k<i->numberOfCashflows[j]; ++k) {
                        CashFlow& from = i->cashflows[j][k];
                        CashFlow& to = cashFlowsGenerated[0][k+offset];
                        to.timeIndex = i->timeIndices[from.timeIndex];
                        to.amount = from.amount * i->multiplier;
                    }
                    numberCashFlowsThisStep[0] = totalCashflows;
                }
                // finally, set done to false if this product isn't done
                done = done && thisDone;
            }
        }
        ++currentIndex_;
        return done;
    }

    std::unique_ptr<MarketModelMultiProduct>
    SingleProductComposite::clone() const {
        return std::unique_ptr<MarketModelMultiProduct>(new SingleProductComposite(*this));
    }

}

]]></document_content>
  </document>
  <document index="103">
    <source>marketmodels/proxygreekengine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/constrainedevolver.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/discounter.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/proxygreekengine.hpp>
#include <algorithm>
#include <utility>

namespace QuantLib {

    ProxyGreekEngine::ProxyGreekEngine(
        ext::shared_ptr<MarketModelEvolver> evolver,
        std::vector<std::vector<ext::shared_ptr<ConstrainedEvolver> > > constrainedEvolvers,
        std::vector<std::vector<std::vector<Real> > > diffWeights,
        std::vector<Size> startIndexOfConstraint,
        std::vector<Size> endIndexOfConstraint,
        const Clone<MarketModelMultiProduct>& product,
        Real initialNumeraireValue)
    : originalEvolver_(std::move(evolver)), constrainedEvolvers_(std::move(constrainedEvolvers)),
      diffWeights_(std::move(diffWeights)),
      startIndexOfConstraint_(std::move(startIndexOfConstraint)),
      endIndexOfConstraint_(std::move(endIndexOfConstraint)), product_(product),
      initialNumeraireValue_(initialNumeraireValue), numberProducts_(product->numberOfProducts()),
      numerairesHeld_(product->numberOfProducts()),
      numberCashFlowsThisStep_(product->numberOfProducts()),
      cashFlowsGenerated_(product->numberOfProducts()) {
        for (Size i=0; i<numberProducts_; ++i)
            cashFlowsGenerated_[i].resize(
                       product_->maxNumberOfCashFlowsPerProductPerStep());

        const std::vector<Time>& cashFlowTimes =
            product_->possibleCashFlowTimes();
        const std::vector<Rate>& rateTimes = product_->evolution().rateTimes();
        Size n = cashFlowTimes.size();
        discounters_.reserve(n);
        for (Size j=0; j<n; ++j)
            discounters_.emplace_back(cashFlowTimes[j], rateTimes);
        const std::vector<Rate>& evolutionTimes =
            product_->evolution().evolutionTimes();
        constraints_.resize(evolutionTimes.size());
        constraintsActive_.resize(evolutionTimes.size());
    }

    void ProxyGreekEngine::singlePathValues(
              std::vector<Real>& values,
              std::vector<std::vector<std::vector<Real> > >& modifiedValues) {
        singleEvolverValues(*originalEvolver_, values, true);
        for (Size i=0; i<constrainedEvolvers_.size(); ++i) {
            for (Size j=0; j<constrainedEvolvers_[i].size(); ++j) {
                constrainedEvolvers_[i][j]->setThisConstraint(
                                            constraints_, constraintsActive_);
                singleEvolverValues(*(constrainedEvolvers_[i][j]),
                                    modifiedValues[i][j]);
            }
        }
    }

    void ProxyGreekEngine::multiplePathValues(
                  SequenceStatisticsInc& stats,
                  std::vector<std::vector<SequenceStatisticsInc> >& modifiedStats,
                  Size numberOfPaths) {
        Size N = product_->numberOfProducts();

        std::vector<Real> values(N);
        std::vector<std::vector<std::vector<Real> > > modifiedValues;
        modifiedValues.resize(constrainedEvolvers_.size());
        for (Size i=0; i<modifiedValues.size(); ++i) {
            modifiedValues[i].resize(constrainedEvolvers_[i].size());
            for (auto& j : modifiedValues[i])
                j.resize(N);
        }

        std::vector<Real> results(N);

        for (Size i=0; i<numberOfPaths; ++i) {
            singlePathValues(values, modifiedValues);
            stats.add(values);

            for (Size j=0; j<diffWeights_.size(); ++j) {
                for (Size k=0; k<diffWeights_[j].size(); ++k) {
                    const std::vector<Real>& weights = diffWeights_[j][k];
                    for (Size l=0; l<N; ++l) {
                        results[l] = weights[0]*values[l];
                        for (Size n=1; n<weights.size(); ++n)
                            results[l] += weights[n]*modifiedValues[j][n-1][l];
                    }
                    modifiedStats[j][k].add(results);
                }
            }
        }
    }

    void ProxyGreekEngine::singleEvolverValues(MarketModelEvolver& evolver,
                                               std::vector<Real>& values,
                                               bool storeRates) {

        std::fill(numerairesHeld_.begin(), numerairesHeld_.end(), 0.0);
        Real weight = evolver.startNewPath();
        product_->reset();
        Real principalInNumerairePortfolio = 1.0;

        if (storeRates)
            constraintsActive_ =false;
        //            std::fill(constraintsActive_.begin(),
        //                    constraintsActive_.end(),
        //                  false);
        //  }

        bool done = false;
        do {
            Size thisStep = evolver.currentStep();
            weight *= evolver.advanceStep();
            done = product_->nextTimeStep(evolver.currentState(),
                                          numberCashFlowsThisStep_,
                                          cashFlowsGenerated_);
            if (storeRates) {
                constraints_[thisStep] = evolver.currentState().swapRate(
                                        startIndexOfConstraint_[thisStep],
                                        endIndexOfConstraint_[thisStep]);
                constraintsActive_[thisStep] = true;
            }

            Size numeraire =
                evolver.numeraires()[thisStep];

            // for each product...
            for (Size i=0; i<numberProducts_; ++i) {
                // ...and each cash flow...
                const std::vector<MarketModelMultiProduct::CashFlow>& cashflows =
                    cashFlowsGenerated_[i];
                for (Size j=0; j<numberCashFlowsThisStep_[i]; ++j) {
                    // ...convert the cash flow to numeraires.
                    // This is done by calculating the number of
                    // numeraire bonds corresponding to such cash flow...
                    const MarketModelDiscounter& discounter =
                        discounters_[cashflows[j].timeIndex];

                    Real bonds = cashflows[j].amount *
                        discounter.numeraireBonds(evolver.currentState(),
                                                  numeraire);

                    // ...and adding the newly bought bonds to the number
                    // of numeraires held.
                    numerairesHeld_[i] +=
                        weight*bonds/principalInNumerairePortfolio;
                }
            }

            if (!done) {

                // The numeraire might change between steps. This implies
                // that we might have to convert the numeraire bonds for
                // this step into a corresponding amount of numeraire
                // bonds for the next step. This can be done by changing
                // the principal of the numeraire and updating the number
                // of bonds in the numeraire portfolio accordingly.

                Size nextNumeraire = evolver.numeraires()[thisStep+1];

                principalInNumerairePortfolio *=
                    evolver.currentState().discountRatio(numeraire,
                                                         nextNumeraire);
            }

        } while (!done);

        for (Size i=0; i<numerairesHeld_.size(); ++i)
            values[i] = numerairesHeld_[i] * initialNumeraireValue_;

    }

}
]]></document_content>
  </document>
  <document index="104">
    <source>marketmodels/swapforwardmappings.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2006 Ferdinando Ametrano
Copyright (C) 2006 Marco Bianchetti
Copyright (C) 2006 Giorgio Facchinetti
Copyright (C) 2006, 2008 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/swapforwardmappings.hpp>
#include <ql/models/marketmodels/curvestate.hpp>
#include <ql/models/marketmodels/marketmodel.hpp>
#include <ql/models/marketmodels/evolutiondescription.hpp>
#include <ql/models/marketmodels/curvestates/lmmcurvestate.hpp>
#include <vector>

namespace QuantLib {


    Real SwapForwardMappings::annuity(const CurveState& cs,
                                      Size startIndex,
                                      Size endIndex,
                                      Size numeraireIndex)
    {
        Real annuity = 0.0;
        for (Size i=startIndex; i<endIndex; ++i)
            annuity += cs.rateTaus()[i]*cs.discountRatio(i+1, numeraireIndex);
        return annuity;
    }

    // compute derivative of swap-rate to underlying forward rate
    Real SwapForwardMappings::swapDerivative(const CurveState& cs,
                                             Size startIndex,
                                             Size endIndex,
                                             Size forwardIndex)
    {
        if (forwardIndex < startIndex)
            return 0.0;
        if (forwardIndex >= endIndex)
            return 0.0;

        Real numerator = cs.discountRatio(startIndex, endIndex)-1;
        Real swapAnnuity = annuity(cs, startIndex, endIndex,endIndex);

        Real ratio = cs.rateTaus()[forwardIndex] /
            (1 + cs.rateTaus()[forwardIndex] * cs.forwardRate(forwardIndex));

        Real part1 = ratio*(numerator+1)/swapAnnuity;
        Real part2 = numerator/(swapAnnuity*swapAnnuity);

        if (forwardIndex >=1)
            part2 *= ratio* annuity(cs, startIndex, forwardIndex, endIndex);
        else 
            part2 = 0.0;

        return part1-part2;
    }

    Matrix SwapForwardMappings::coterminalSwapForwardJacobian(const CurveState& cs)
    {
        Size n = cs.numberOfRates();
        const std::vector<Rate>& f = cs.forwardRates();
        const std::vector<Time>& tau = cs.rateTaus();

        // coterminal floating leg values
        std::vector<Real> a(n);
        for (Size k=0; k<n; ++k)
            a[k] = cs.discountRatio(k,n)-1.0;
        //p[k]-p[n];

        Matrix jacobian = Matrix(n, n, 0.0);
        for (Size i=0; i<n; ++i) {     // i = swap rate index
            for (Size j=i; j<n; ++j) { // j = forward rate index
                Real bi = cs.coterminalSwapAnnuity(n,i);
                Real bj = cs.coterminalSwapAnnuity(n,j);
                jacobian[i][j] =
                    //   p[j+1]*tau[j]/b[i] +
                    tau[j]/cs.coterminalSwapAnnuity(j+1,i) +
                    // tau[j]/(1.0+f[j]*tau[j]) *
                    tau[j]/(1.0+f[j]*tau[j]) *
                    //    (-a[j]*b[i]+a[i]*b[j])/(b[i]*b[i]);
                    (-a[j]*bi+a[i]*bj)/(bi*bi);

            }
        }
        return jacobian;
    }

    Matrix SwapForwardMappings::coterminalSwapZedMatrix(const CurveState& cs,
                                                        const Spread displacement) {
            Size n = cs.numberOfRates();
            Matrix zMatrix = coterminalSwapForwardJacobian(cs);
            const std::vector<Rate>& f = cs.forwardRates();
            const std::vector<Rate>& sr = cs.coterminalSwapRates();
            for (Size i=0; i<n; ++i)
                for (Size j=i; j<n; ++j)
                    zMatrix[i][j] *= (f[j]+displacement)/(sr[i]+displacement);
            return zMatrix;
    }


    Matrix SwapForwardMappings::coinitialSwapForwardJacobian(const CurveState& cs)
    {
        Size n = cs.numberOfRates();

        Matrix jacobian = Matrix(n, n, 0.0);
        for (Size i=0; i<n; ++i)      // i = swap rate index
            for (Size j=0; j<n; ++j)  // j = forward rate index
                jacobian[i][j] =swapDerivative(cs, 0, i+1, j);

        return jacobian;
    }

    Matrix SwapForwardMappings::cmSwapForwardJacobian(const CurveState& cs,
                                                      const Size spanningForwards)
    {
        Size n = cs.numberOfRates();

        Matrix jacobian = Matrix(n, n, 0.0);
        for (Size i=0; i<n; ++i)      // i = swap rate index
            for (Size j=0; j<n; ++j)  // j = forward rate index
                jacobian[i][j] =swapDerivative(cs, i, std::min(n,i+spanningForwards), j);

        return jacobian;
    }

    Matrix SwapForwardMappings::coinitialSwapZedMatrix(const CurveState& cs,
                                                       const Spread displacement)
    {
        Size n = cs.numberOfRates();
        Matrix zMatrix = coinitialSwapForwardJacobian(cs);
        const std::vector<Rate>& f = cs.forwardRates();
        std::vector<Rate> sr(n);

        for (Size i=0; i<n; ++i)
            sr[i] = cs.cmSwapRate(0,i+1);

        for (Size i=0; i<n; ++i)
            for (Size j=i; j<n; ++j)
                zMatrix[i][j] *= (f[j]+displacement)/(sr[i]+displacement);
        return zMatrix;
    }

    Matrix SwapForwardMappings::cmSwapZedMatrix(const CurveState& cs,
                                                const Size spanningForwards,
                                                const Spread displacement)
    {
        Size n = cs.numberOfRates();
        Matrix zMatrix = cmSwapForwardJacobian(cs,spanningForwards);
        const std::vector<Rate>& f = cs.forwardRates();
        std::vector<Rate> sr(n);

        for (Size i=0; i<n; ++i)
            sr[i] = cs.cmSwapRate(i,spanningForwards);

        for (Size i=0; i<n; ++i)
            for (Size j=i; j<n; ++j)
                zMatrix[i][j] *= (f[j]+displacement)/(sr[i]+displacement);
        return zMatrix;
    }

    Real SwapForwardMappings::swaptionImpliedVolatility(const MarketModel& volStructure,
                                                        Size startIndex,
                                                        Size endIndex)
    {
          QL_REQUIRE(startIndex < endIndex, "start index must be before end index in swaptionImpliedVolatility");

          LMMCurveState cs(volStructure.evolution().rateTimes());
          cs.setOnForwardRates(volStructure.initialRates());
          Real displacement = volStructure.displacements()[0];

          Matrix cmsZed(cmSwapZedMatrix(cs, endIndex-startIndex,displacement));

          Real variance=0.0;

          Size index=0;

          const EvolutionDescription& evolution(volStructure.evolution());
          Size factors = volStructure.numberOfFactors();

          while (index < evolution.numberOfSteps() && startIndex >= evolution.firstAliveRate()[index] )
          {
              const Matrix& thisPseudo = volStructure.pseudoRoot(index);
              Real thisVariance =0.0;
              
              for (Size f=0; f < factors; ++f)
              {
                  Real sum=0.0;

                  for (Size j=startIndex; j < endIndex;++j)
                  {
                      sum += cmsZed[startIndex][j]*thisPseudo[j][f];

                  }
                  thisVariance += sum*sum;

              }
              variance += thisVariance;
              ++index;

          }

          Real expiry = evolution.rateTimes()[startIndex];
          return std::sqrt(variance/expiry);

    }

}
]]></document_content>
  </document>
  <document index="105">
    <source>marketmodels/utilities.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2006 Marco Bianchetti
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/marketmodels/utilities.hpp>
#include <ql/errors.hpp>
#include <algorithm>
#include <valarray>

namespace QuantLib {

    void mergeTimes(const std::vector<std::vector<Time> >& times,
                    std::vector<Time>& mergedTimes,
                    std::vector<std::valarray<bool> >& isPresent) {

        std::vector<Time> allTimes;
        for (const auto& time : times) {
            allTimes.insert(allTimes.end(), time.begin(), time.end());
        }

        // ...sort and compact the vector mergedTimes...
        std::sort(allTimes.begin(), allTimes.end());
        auto end = std::unique(allTimes.begin(), allTimes.end());
        //mergedTimes.clear(); // shouldn't be cleared?
        mergedTimes.insert(mergedTimes.end(),
                           allTimes.begin(), end);

        isPresent.resize(times.size());
        for (Size i=0; i<times.size(); i++) {
            isPresent[i].resize(allTimes.size());
            for (Size j=0; j<allTimes.size(); j++) {
                isPresent[i][j] = std::binary_search(times[i].begin(),
                                                     times[i].end(),
                                                     allTimes[j]);
            }
        }
    }

    std::valarray<bool> isInSubset(const std::vector<Time>& set,
                                   const std::vector<Time>& subset) {

        std::valarray<bool> result(false,set.size());
        Size dimsubSet = subset.size();
        if (dimsubSet==0)
            return result;
        Size dimSet = set.size();
        Time setElement, subsetElement;

        QL_REQUIRE(dimSet >= dimsubSet,
                   "set is required to be larger or equal than subset");

        for (Size i=0; i<dimSet; ++i) {  // loop in set
            Size j=0;
            setElement = set[i];
            for (;;) {              // loop in subset
                subsetElement = subset[j];
                result[i] = false;
                // if smaller no hope, leave false and go to next i
                if (setElement < subsetElement)
                    break;
                // if match, set result[i] to true and go to next i
                if (setElement == subsetElement) {
                    result[i] = true;
                    break;
                }
                // if larger, leave false if at the end or go to next j
                if (j == dimsubSet-1)
                    break;
                ++j;
            }
        }
        return result;
    }

    void checkIncreasingTimes(const std::vector<Time>& times) {
        Size nTimes = times.size();
        QL_REQUIRE(nTimes>0,
                   "at least one time is required");
        QL_REQUIRE(times[0]>0.0,
                   "first time (" << times[0] <<
                   ") must be greater than zero");
        for (Size i=0; i<nTimes-1; ++i)
            QL_REQUIRE(times[i+1]-times[i]>0,
                       "non increasing rate times: "
                       "times[" << i   << "]=" << times[i] << ", "
                       "times[" << i+1 << "]=" << times[i+1]);
    }

    void checkIncreasingTimesAndCalculateTaus(const std::vector<Time>& times,
                                              std::vector<Time>& taus) {
        Size nTimes = times.size();
        QL_REQUIRE(nTimes>1,
                   "at least two times are required, " << nTimes << " provided");
        QL_REQUIRE(times[0]>0.0,
                   "first time (" << times[0] <<
                   ") must be greater than zero");
        if (taus.size()!=nTimes-1)
            taus.resize(nTimes-1);
        for (Size i=0; i<nTimes-1; ++i) {
            taus[i]=times[i+1]-times[i];
            QL_REQUIRE(taus[i]>0,
                       "non increasing rate times: "
                       "times[" << i   << "]=" << times[i] << ", "
                       "times[" << i+1 << "]=" << times[i+1]);
        }
    }


}
]]></document_content>
  </document>
  <document index="106">
    <source>model.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2013, 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/optimization/problem.hpp>
#include <ql/math/optimization/projectedconstraint.hpp>
#include <ql/math/optimization/projection.hpp>
#include <ql/models/model.hpp>
#include <ql/utilities/null_deleter.hpp>
#include <utility>

using std::vector;

namespace QuantLib {

    CalibratedModel::CalibratedModel(Size nArguments)
    : arguments_(nArguments), constraint_(new PrivateConstraint(arguments_)) {}

    class CalibratedModel::CalibrationFunction : public CostFunction {
      public:
        CalibrationFunction(CalibratedModel* model,
                            const vector<ext::shared_ptr<CalibrationHelper> >& h,
                            vector<Real> weights,
                            const Projection& projection)
        : model_(model, null_deleter()), instruments_(h), weights_(std::move(weights)),
          projection_(projection) {}

        ~CalibrationFunction() override = default;

        Real value(const Array& params) const override {
            model_->setParams(projection_.include(params));
            Real value = 0.0;
            for (Size i=0; i<instruments_.size(); i++) {
                Real diff = instruments_[i]->calibrationError();
                value += diff*diff*weights_[i];
            }
            return std::sqrt(value);
        }

        Array values(const Array& params) const override {
            model_->setParams(projection_.include(params));
            Array values(instruments_.size());
            for (Size i=0; i<instruments_.size(); i++) {
                values[i] = instruments_[i]->calibrationError()
                           *std::sqrt(weights_[i]);
            }
            return values;
        }

        Real finiteDifferenceEpsilon() const override { return 1e-6; }

      private:
        ext::shared_ptr<CalibratedModel> model_;
        const vector<ext::shared_ptr<CalibrationHelper> >& instruments_;
        vector<Real> weights_;
        const Projection projection_;
    };

    void CalibratedModel::calibrate(
            const vector<ext::shared_ptr<CalibrationHelper> >& instruments,
            OptimizationMethod& method,
            const EndCriteria& endCriteria,
            const Constraint& additionalConstraint,
            const vector<Real>& weights,
            const vector<bool>& fixParameters) {

        QL_REQUIRE(!instruments.empty(), "no instruments provided");

        Constraint c;
        if (additionalConstraint.empty())
            c = *constraint_;
        else
            c = CompositeConstraint(*constraint_,additionalConstraint);

        QL_REQUIRE(weights.empty() || weights.size() == instruments.size(),
                   "mismatch between number of instruments (" <<
                   instruments.size() << ") and weights (" <<
                   weights.size() << ")");
        vector<Real> w =
            weights.empty() ? vector<Real>(instruments.size(), 1.0): weights;

        Array prms = params();
        QL_REQUIRE(fixParameters.empty() || fixParameters.size() == prms.size(),
                   "mismatch between number of parameters (" <<
                   prms.size() << ") and fixed-parameter specs (" <<
                   fixParameters.size() << ")");
        vector<bool> all(prms.size(), false);
        Projection proj(prms, !fixParameters.empty() ? fixParameters : all);
        CalibrationFunction f(this,instruments,w,proj);
        ProjectedConstraint pc(c,proj);
        Problem prob(f, pc, proj.project(prms));
        shortRateEndCriteria_ = method.minimize(prob, endCriteria);
        Array result(prob.currentValue());
        setParams(proj.include(result));
        problemValues_ = prob.values(result);
        functionEvaluation_ = prob.functionEvaluation();

        notifyObservers();
    }

    Real CalibratedModel::value(
                const Array& params,
                const vector<ext::shared_ptr<CalibrationHelper> >& instruments) {
        vector<Real> w = vector<Real>(instruments.size(), 1.0);
        Projection p(params);
        CalibrationFunction f(this, instruments, w, p);
        return f.value(params);
    }

    Array CalibratedModel::params() const {
        Size size=0;
        for (const auto& argument : arguments_)
            size += argument.size();
        Array params(size);
        for (Size i=0, k=0; i<arguments_.size(); ++i) {
            for (Size j=0; j<arguments_[i].size(); ++j, ++k)
                params[k] = arguments_[i].params()[j];
        }
        return params;
    }

    void CalibratedModel::setParams(const Array& params) {
        Array::const_iterator p = params.begin();
        for (auto& argument : arguments_) {
            for (Size j = 0; j < argument.size(); ++j, ++p) {
                QL_REQUIRE(p!=params.end(),"parameter array too small");
                argument.setParam(j, *p);
            }
        }
        QL_REQUIRE(p==params.end(),"parameter array too big!");
        generateArguments();
        notifyObservers();
    }

    ShortRateModel::ShortRateModel(Size nArguments)
    : CalibratedModel(nArguments) {}

}
]]></document_content>
  </document>
  <document index="107">
    <source>shortrate/calibrationhelpers/caphelper.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/models/shortrate/calibrationhelpers/caphelper.hpp>
#include <ql/pricingengines/capfloor/bacheliercapfloorengine.hpp>
#include <ql/pricingengines/capfloor/blackcapfloorengine.hpp>
#include <ql/pricingengines/capfloor/discretizedcapfloor.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/time/schedule.hpp>
#include <utility>

namespace QuantLib {

    CapHelper::CapHelper(const Period& length,
                         const Handle<Quote>& volatility,
                         ext::shared_ptr<IborIndex> index,
                         Frequency fixedLegFrequency,
                         DayCounter fixedLegDayCounter,
                         bool includeFirstSwaplet,
                         Handle<YieldTermStructure> termStructure,
                         BlackCalibrationHelper::CalibrationErrorType errorType,
                         const VolatilityType type,
                         const Real shift)
    : BlackCalibrationHelper(volatility, errorType, type, shift), length_(length),
      index_(std::move(index)), termStructure_(std::move(termStructure)),
      fixedLegFrequency_(fixedLegFrequency), fixedLegDayCounter_(std::move(fixedLegDayCounter)),
      includeFirstSwaplet_(includeFirstSwaplet) {
        registerWith(index_);
        registerWith(termStructure_);
    }

    void CapHelper::addTimesTo(std::list<Time>& times) const {
        calculate();
        CapFloor::arguments args;
        cap_->setupArguments(&args);
        std::vector<Time> capTimes =
            DiscretizedCapFloor(args,
                                termStructure_->referenceDate(),
                                termStructure_->dayCounter()).mandatoryTimes();
        times.insert(times.end(),
                     capTimes.begin(), capTimes.end());
    }

    Real CapHelper::modelValue() const {
        calculate();
        cap_->setPricingEngine(engine_);
        return cap_->NPV();
    }

    Real CapHelper::blackPrice(Volatility sigma) const {
        calculate();
        Handle<Quote> vol(ext::shared_ptr<Quote>(new SimpleQuote(sigma)));
        ext::shared_ptr<PricingEngine> engine;
        switch(volatilityType_) {
          case ShiftedLognormal:
            engine = ext::make_shared<BlackCapFloorEngine>(
                termStructure_, vol, Actual365Fixed(), shift_);
            break;
          case Normal:
            engine = ext::make_shared<BachelierCapFloorEngine>(
                termStructure_, vol, Actual365Fixed());
            break;
          default:
            QL_FAIL("unknown volatility type: " << volatilityType_);
        }
        cap_->setPricingEngine(engine);
        Real value = cap_->NPV();
        cap_->setPricingEngine(engine_);
        return value;
    }

    void CapHelper::performCalculations() const {

        Period indexTenor = index_->tenor();
        Rate fixedRate = 0.04; // dummy value
        Date startDate, maturity;
        if (includeFirstSwaplet_) {
            startDate = termStructure_->referenceDate();
            maturity = termStructure_->referenceDate() + length_;
        } else {
            startDate = termStructure_->referenceDate() + indexTenor;
            maturity = termStructure_->referenceDate() + length_;
        }
        ext::shared_ptr<IborIndex> dummyIndex(new
            IborIndex("dummy",
                      indexTenor,
                      index_->fixingDays(),
                      index_->currency(),
                      index_->fixingCalendar(),
                      index_->businessDayConvention(),
                      index_->endOfMonth(),
                      termStructure_->dayCounter(),
                      termStructure_));

        std::vector<Real> nominals(1,1.0);

        Schedule floatSchedule(startDate, maturity,
                               index_->tenor(), index_->fixingCalendar(),
                               index_->businessDayConvention(),
                               index_->businessDayConvention(),
                               DateGeneration::Forward, false);
        Leg floatingLeg = IborLeg(floatSchedule, index_)
            .withNotionals(nominals)
            .withPaymentAdjustment(index_->businessDayConvention())
            .withFixingDays(0);

        Schedule fixedSchedule(startDate, maturity, Period(fixedLegFrequency_),
                               index_->fixingCalendar(),
                               Unadjusted, Unadjusted,
                               DateGeneration::Forward, false);
        Leg fixedLeg = FixedRateLeg(fixedSchedule)
            .withNotionals(nominals)
            .withCouponRates(fixedRate, fixedLegDayCounter_)
            .withPaymentAdjustment(index_->businessDayConvention());

        Swap swap(floatingLeg, fixedLeg);
        swap.setPricingEngine(ext::shared_ptr<PricingEngine>(
                            new DiscountingSwapEngine(termStructure_, false)));
        Rate fairRate = fixedRate - swap.NPV()/(swap.legBPS(1)/1.0e-4);
        cap_ = ext::make_shared<Cap>(floatingLeg,
                                              std::vector<Rate>(1, fairRate));

        BlackCalibrationHelper::performCalculations();

    }


}
]]></document_content>
  </document>
  <document index="108">
    <source>shortrate/calibrationhelpers/swaptionhelper.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/iborindex.hpp>
#include <ql/instruments/overnightindexedswap.hpp>
#include <ql/instruments/vanillaswap.hpp>
#include <ql/models/shortrate/calibrationhelpers/swaptionhelper.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/pricingengines/swaption/blackswaptionengine.hpp>
#include <ql/pricingengines/swaption/discretizedswaption.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/time/schedule.hpp>
#include <utility>

namespace QuantLib {

    SwaptionHelper::SwaptionHelper(const Period& maturity,
                                   const Period& length,
                                   const Handle<Quote>& volatility,
                                   ext::shared_ptr<IborIndex> index,
                                   const Period& fixedLegTenor,
                                   DayCounter fixedLegDayCounter,
                                   DayCounter floatingLegDayCounter,
                                   Handle<YieldTermStructure> termStructure,
                                   CalibrationErrorType errorType,
                                   const Real strike,
                                   const Real nominal,
                                   const VolatilityType type,
                                   const Real shift,
                                   Natural settlementDays,
                                   RateAveraging::Type averagingMethod)
    : BlackCalibrationHelper(volatility, errorType, type, shift),
      maturity_(maturity), length_(length), fixedLegTenor_(fixedLegTenor),
      index_(std::move(index)), termStructure_(std::move(termStructure)),
      fixedLegDayCounter_(std::move(fixedLegDayCounter)),
      floatingLegDayCounter_(std::move(floatingLegDayCounter)), strike_(strike), nominal_(nominal),
      settlementDays_(settlementDays), averagingMethod_(averagingMethod) {
        registerWith(index_);
        registerWith(termStructure_);
    }

    SwaptionHelper::SwaptionHelper(const Date& exerciseDate,
                                   const Period& length,
                                   const Handle<Quote>& volatility,
                                   ext::shared_ptr<IborIndex> index,
                                   const Period& fixedLegTenor,
                                   DayCounter fixedLegDayCounter,
                                   DayCounter floatingLegDayCounter,
                                   Handle<YieldTermStructure> termStructure,
                                   CalibrationErrorType errorType,
                                   const Real strike,
                                   const Real nominal,
                                   const VolatilityType type,
                                   const Real shift,
                                   Natural settlementDays,
                                   RateAveraging::Type averagingMethod)
    : BlackCalibrationHelper(volatility, errorType, type, shift), exerciseDate_(exerciseDate),
      maturity_(0 * Days), length_(length), fixedLegTenor_(fixedLegTenor),
      index_(std::move(index)), termStructure_(std::move(termStructure)),
      fixedLegDayCounter_(std::move(fixedLegDayCounter)),
      floatingLegDayCounter_(std::move(floatingLegDayCounter)), strike_(strike), nominal_(nominal),
      settlementDays_(settlementDays), averagingMethod_(averagingMethod) {
        registerWith(index_);
        registerWith(termStructure_);
    }

    SwaptionHelper::SwaptionHelper(const Date& exerciseDate,
                                   const Date& endDate,
                                   const Handle<Quote>& volatility,
                                   ext::shared_ptr<IborIndex> index,
                                   const Period& fixedLegTenor,
                                   DayCounter fixedLegDayCounter,
                                   DayCounter floatingLegDayCounter,
                                   Handle<YieldTermStructure> termStructure,
                                   CalibrationErrorType errorType,
                                   const Real strike,
                                   const Real nominal,
                                   const VolatilityType type,
                                   const Real shift,
                                   Natural settlementDays,
                                   RateAveraging::Type averagingMethod)
    : BlackCalibrationHelper(volatility, errorType, type, shift), exerciseDate_(exerciseDate),
      endDate_(endDate), maturity_(0 * Days), length_(0 * Days), fixedLegTenor_(fixedLegTenor),
      index_(std::move(index)), termStructure_(std::move(termStructure)),
      fixedLegDayCounter_(std::move(fixedLegDayCounter)),
      floatingLegDayCounter_(std::move(floatingLegDayCounter)), strike_(strike), nominal_(nominal),
      settlementDays_(settlementDays), averagingMethod_(averagingMethod) {
        registerWith(index_);
        registerWith(termStructure_);
    }


    void SwaptionHelper::addTimesTo(std::list<Time>& times) const {
        calculate();
        Swaption::arguments args;
        swaption_->setupArguments(&args);
        std::vector<Time> swaptionTimes =
            DiscretizedSwaption(args,
                                termStructure_->referenceDate(),
                                termStructure_->dayCounter()).mandatoryTimes();
        times.insert(times.end(),
                     swaptionTimes.begin(), swaptionTimes.end());
    }

    Real SwaptionHelper::modelValue() const {
        calculate();
        swaption_->setPricingEngine(engine_);
        return swaption_->NPV();
    }

    Real SwaptionHelper::blackPrice(Volatility sigma) const {
        calculate();
        Handle<Quote> vol(ext::shared_ptr<Quote>(new SimpleQuote(sigma)));
        ext::shared_ptr<PricingEngine> engine;
        switch(volatilityType_) {
        case ShiftedLognormal:
            engine = ext::make_shared<BlackSwaptionEngine>(
                termStructure_, vol, Actual365Fixed(), shift_);
            break;
        case Normal:
            engine = ext::make_shared<BachelierSwaptionEngine>(
                termStructure_, vol, Actual365Fixed());
            break;
        default:
            QL_FAIL("can not construct engine: " << volatilityType_);
            break;
        }
        swaption_->setPricingEngine(engine);
        Real value = swaption_->NPV();
        swaption_->setPricingEngine(engine_);
        return value;
    }

    void SwaptionHelper::performCalculations() const {

        Calendar calendar = index_->fixingCalendar();
        Date exerciseDate = exerciseDate_;
        if (exerciseDate == Date())
            exerciseDate = calendar.advance(termStructure_->referenceDate(),
                                            maturity_,
                                            index_->businessDayConvention());
        Date startDate;
        if (settlementDays_ == Null<Size>()) {
            startDate = index_->valueDate(index_->fixingCalendar().adjust(exerciseDate));
        } else {
            startDate = calendar.advance(exerciseDate,
                                         index_->fixingDays(), Days,
                                         index_->businessDayConvention());
        }

        Date endDate = endDate_;
        if (endDate == Date())
            endDate = calendar.advance(startDate, length_,
                                       index_->businessDayConvention());
        Schedule fixedSchedule(startDate, endDate, fixedLegTenor_, calendar,
                               index_->businessDayConvention(),
                               index_->businessDayConvention(),
                               DateGeneration::Forward, false);
        Schedule floatSchedule(startDate, endDate, index_->tenor(), calendar,
                               index_->businessDayConvention(),
                               index_->businessDayConvention(),
                               DateGeneration::Forward, false);

        auto swapEngine = ext::make_shared<DiscountingSwapEngine>(termStructure_, false);

        Swap::Type type = Swap::Receiver;
        ext::shared_ptr<Exercise> exercise(new EuropeanExercise(exerciseDate));
        auto temp = makeSwap(fixedSchedule, floatSchedule, 0.0, type);
        temp->setPricingEngine(swapEngine);
        Real forward = temp->fairRate();
        if (strike_ == Null<Real>()) {
            exerciseRate_ = forward;
        } else {
            exerciseRate_ = strike_;
            type = strike_ <= forward ? Swap::Receiver : Swap::Payer;
        }
        swap_ = makeSwap(fixedSchedule, floatSchedule, exerciseRate_, type);
        swap_->setPricingEngine(swapEngine);
        swaption_ = ext::make_shared<Swaption>(swap_, exercise);
        BlackCalibrationHelper::performCalculations();
    }

    ext::shared_ptr<FixedVsFloatingSwap> SwaptionHelper::makeSwap(Schedule fixedSchedule,
                                                                  Schedule floatSchedule,
                                                                  Rate exerciseRate,
                                                                  Swap::Type type) const {
        auto onIndex = ext::dynamic_pointer_cast<OvernightIndex>(index_);
        if (onIndex) {
            return ext::make_shared<OvernightIndexedSwap>(
                type, nominal_, std::move(fixedSchedule), exerciseRate, fixedLegDayCounter_,
                std::move(floatSchedule), onIndex, 0.0, 0, Following,
                Calendar(), true, averagingMethod_);
        } else {
            return ext::make_shared<VanillaSwap>(type, nominal_, std::move(fixedSchedule), exerciseRate,
                                                 fixedLegDayCounter_, std::move(floatSchedule), index_, 0.0,
                                                 floatingLegDayCounter_);
        }
    }

}
]]></document_content>
  </document>
  <document index="109">
    <source>shortrate/onefactormodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/solvers1d/brent.hpp>
#include <ql/models/shortrate/onefactormodel.hpp>
#include <ql/stochasticprocess.hpp>
#include <utility>

namespace QuantLib {

    //Private function used by solver to determine time-dependent parameter
    class OneFactorModel::ShortRateTree::Helper {
      public:
        Helper(Size i,
               Real discountBondPrice,
               ext::shared_ptr<TermStructureFittingParameter::NumericalImpl> theta,
               ShortRateTree& tree)
        : size_(tree.size(i)), i_(i), statePrices_(tree.statePrices(i)),
          discountBondPrice_(discountBondPrice), theta_(std::move(theta)), tree_(tree) {
            theta_->set(tree.timeGrid()[i], 0.0);
        }

        Real operator()(Real theta) const {
            Real value = discountBondPrice_;
            theta_->change(theta);
            for (Size j=0; j<size_; j++)
                value -= statePrices_[j]*tree_.discount(i_,j);
            return value;
        }

      private:
        Size size_;
        Size i_;
        const Array& statePrices_;
        Real discountBondPrice_;
        ext::shared_ptr<TermStructureFittingParameter::NumericalImpl> theta_;
        ShortRateTree& tree_;
    };

    OneFactorModel::ShortRateTree::ShortRateTree(
        const ext::shared_ptr<TrinomialTree>& tree,
        ext::shared_ptr<ShortRateDynamics> dynamics,
        const ext::shared_ptr<TermStructureFittingParameter::NumericalImpl>& theta,
        const TimeGrid& timeGrid)
    : TreeLattice1D<OneFactorModel::ShortRateTree>(timeGrid, tree->size(1)), tree_(tree),
      dynamics_(std::move(dynamics)), spread_(0.0) {

        theta->reset();
        Real value = 1.0;
        Real vMin = -100.0;
        Real vMax = 100.0;
        for (Size i=0; i<(timeGrid.size() - 1); i++) {
            Real discountBond = theta->termStructure()->discount(t_[i+1]);
            Helper finder(i, discountBond, theta, *this);
            Brent s1d;
            s1d.setMaxEvaluations(1000);
            value = s1d.solve(finder, 1e-7, value, vMin, vMax);
            // vMin = value - 1.0;
            // vMax = value + 1.0;
            theta->change(value);
        }
    }

    OneFactorModel::ShortRateTree::ShortRateTree(const ext::shared_ptr<TrinomialTree>& tree,
                                                 ext::shared_ptr<ShortRateDynamics> dynamics,
                                                 const TimeGrid& timeGrid)
    : TreeLattice1D<OneFactorModel::ShortRateTree>(timeGrid, tree->size(1)), tree_(tree),
      dynamics_(std::move(dynamics)), spread_(0.0) {}

    OneFactorModel::OneFactorModel(Size nArguments)
    : ShortRateModel(nArguments) {}

    ext::shared_ptr<Lattice>
    OneFactorModel::tree(const TimeGrid& grid) const {
        ext::shared_ptr<TrinomialTree> trinomial(
                              new TrinomialTree(dynamics()->process(), grid));
        return ext::shared_ptr<Lattice>(
                              new ShortRateTree(trinomial, dynamics(), grid));
    }

    DiscountFactor OneFactorAffineModel::discount(Time t) const {
        Real x0 = dynamics()->process()->x0();
        Rate r0 = dynamics()->shortRate(0.0, x0);
        return discountBond(0.0, t, r0);
    }

}

]]></document_content>
  </document>
  <document index="110">
    <source>shortrate/onefactormodels/blackkarasinski.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/shortrate/onefactormodels/blackkarasinski.hpp>
#include <ql/methods/lattices/trinomialtree.hpp>
#include <ql/math/solvers1d/brent.hpp>

namespace QuantLib {

    // Private function used by solver to determine time-dependent parameter
    class BlackKarasinski::Helper {
      public:
        Helper(Size i, Real xMin, Real dx,
               Real discountBondPrice,
               const ext::shared_ptr<ShortRateTree>& tree)
        : size_(tree->size(i)),
          dt_(tree->timeGrid().dt(i)),
          xMin_(xMin), dx_(dx),
          statePrices_(tree->statePrices(i)),
          discountBondPrice_(discountBondPrice) {}

        Real operator()(Real theta) const {
            Real value = discountBondPrice_;
            Real x = xMin_;
            for (Size j=0; j<size_; j++) {
                Real discount = std::exp(-std::exp(theta+x)*dt_);
                value -= statePrices_[j]*discount;
                x += dx_;
            }
            return value;
        }

      private:
        Size size_;
        Time dt_;
        Real xMin_, dx_;
        const Array& statePrices_;
        Real discountBondPrice_;
    };

    BlackKarasinski::BlackKarasinski(
                              const Handle<YieldTermStructure>& termStructure,
                              Real a, Real sigma)
    : OneFactorModel(2), TermStructureConsistentModel(termStructure),
      a_(arguments_[0]), sigma_(arguments_[1]) {
        a_ = ConstantParameter(a, PositiveConstraint());
        sigma_ = ConstantParameter(sigma, PositiveConstraint());
        phi_ = TermStructureFittingParameter(termStructure);

        registerWith(termStructure);
    }

    ext::shared_ptr<Lattice>
    BlackKarasinski::tree(const TimeGrid& grid) const {

        ext::shared_ptr<ShortRateDynamics> numericDynamics(
                         new Dynamics(phi_, a(), sigma()));
        ext::shared_ptr<TrinomialTree> trinomial(
                         new TrinomialTree(numericDynamics->process(), grid));
        ext::shared_ptr<ShortRateTree> numericTree(
                         new ShortRateTree(trinomial, numericDynamics, grid));

        typedef TermStructureFittingParameter::NumericalImpl NumericalImpl;
        ext::shared_ptr<NumericalImpl> impl =
            ext::dynamic_pointer_cast<NumericalImpl>(phi_.implementation());
        impl->reset();
        Real value = 1.0;
        Real vMin = -50.0;
        Real vMax = 50.0;
        for (Size i=0; i<(grid.size() - 1); i++) {
            Real discountBond = termStructure()->discount(grid[i+1]);
            Real xMin = trinomial->underlying(i, 0);
            Real dx = trinomial->dx(i);
            Helper finder(i, xMin, dx, discountBond, numericTree);
            Brent s1d;
            s1d.setMaxEvaluations(1000);
            value = s1d.solve(finder, 1e-7, value, vMin, vMax);
            impl->set(grid[i], value);
        }
        return numericTree;
    }

    ext::shared_ptr<OneFactorModel::ShortRateDynamics>
        BlackKarasinski::dynamics() const {
        // Calibrate fitting parameter to term structure
        Size steps = 50;
        ext::shared_ptr<Lattice> lattice = this->tree(
            TimeGrid(termStructure()->maxTime(), steps));
        ext::shared_ptr<ShortRateDynamics> numericDynamics(
            new Dynamics(phi_, a(), sigma()));
        return numericDynamics;
    }

}
]]></document_content>
  </document>
  <document index="111">
    <source>shortrate/onefactormodels/coxingersollross.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/shortrate/onefactormodels/coxingersollross.hpp>
#include <ql/methods/lattices/trinomialtree.hpp>
#include <ql/math/distributions/chisquaredistribution.hpp>

namespace QuantLib {

    class CoxIngersollRoss::VolatilityConstraint : public Constraint {
      private:
        class Impl final : public Constraint::Impl {
            Real k_, theta_;
          public:
            Impl(Real k, Real theta) : k_(k), theta_(theta) {}
            bool test(const Array& params) const override {
                Real sigma = params[0];
                return (sigma > 0.0) && (sigma*sigma < 2.0*k_*theta_);
            }
        };
      public:
        VolatilityConstraint(Real k, Real theta)
        : Constraint(ext::shared_ptr<Constraint::Impl>(
                                 new VolatilityConstraint::Impl(k, theta))) {}
    };

    CoxIngersollRoss::CoxIngersollRoss(Rate r0, Real theta,
                                       Real k, Real sigma,
                                       bool withFellerConstraint)
    : OneFactorAffineModel(4),
      theta_(arguments_[0]), k_(arguments_[1]),
      sigma_(arguments_[2]), r0_(arguments_[3]) {
        theta_ = ConstantParameter(theta, PositiveConstraint());
        k_ = ConstantParameter(k, PositiveConstraint());
        if (withFellerConstraint)
            sigma_ = ConstantParameter(sigma, VolatilityConstraint(k,theta));
        else
            sigma_ = ConstantParameter(sigma, PositiveConstraint());
        r0_ = ConstantParameter(r0, PositiveConstraint());
    }

    ext::shared_ptr<OneFactorModel::ShortRateDynamics>
    CoxIngersollRoss::dynamics() const {
        return ext::shared_ptr<ShortRateDynamics>(
                                  new Dynamics(theta(), k() , sigma(), x0()));
    }

    Real CoxIngersollRoss::A(Time t, Time T) const {
        Real sigma2 = sigma()*sigma();
        Real h = std::sqrt(k()*k() + 2.0*sigma2);
        Real numerator = 2.0*h*std::exp(0.5*(k()+h)*(T-t));
        Real denominator = 2.0*h + (k()+h)*(std::exp((T-t)*h) - 1.0);
        Real value = std::log(numerator/denominator)*
            2.0*k()*theta()/sigma2;
        return std::exp(value);
    }

    Real CoxIngersollRoss::B(Time t, Time T) const {
        Real h = std::sqrt(k()*k() + 2.0*sigma()*sigma());
        Real temp = std::exp((T-t)*h) - 1.0;
        Real numerator = 2.0*temp;
        Real denominator = 2.0*h + (k()+h)*temp;
        Real value = numerator/denominator;
        return value;
    }

    Real CoxIngersollRoss::discountBondOption(Option::Type type,
                                              Real strike,
                                              Time t, Time s) const {

        QL_REQUIRE(strike>0.0, "strike must be positive");
        DiscountFactor discountT = discountBond(0.0, t, x0());
        DiscountFactor discountS = discountBond(0.0, s, x0());

        if (t < QL_EPSILON) {
            switch(type) {
              case Option::Call:
                return std::max<Real>(discountS - strike, 0.0);
              case Option::Put:
                return std::max<Real>(strike - discountS, 0.0);
              default: QL_FAIL("unsupported option type");
            }
        }

        Real sigma2 = sigma()*sigma();
        Real h = std::sqrt(k()*k() + 2.0*sigma2);
        Real b = B(t,s);

        Real rho = 2.0*h/(sigma2*(std::exp(h*t) - 1.0));
        Real psi = (k() + h)/sigma2;

        Real df = 4.0*k()*theta()/sigma2;
        Real ncps = 2.0*rho*rho*x0()*std::exp(h*t)/(rho+psi+b);
        Real ncpt = 2.0*rho*rho*x0()*std::exp(h*t)/(rho+psi);

        NonCentralCumulativeChiSquareDistribution chis(df, ncps);
        NonCentralCumulativeChiSquareDistribution chit(df, ncpt);

        Real z = std::log(A(t,s)/strike)/b;
        Real call = discountS*chis(2.0*z*(rho+psi+b)) -
            strike*discountT*chit(2.0*z*(rho+psi));

        if (type == Option::Call)
            return call;
        else
            return call - discountS + strike*discountT;
    }

    ext::shared_ptr<Lattice>
    CoxIngersollRoss::tree(const TimeGrid& grid) const {
        ext::shared_ptr<TrinomialTree> trinomial(
                        new TrinomialTree(dynamics()->process(), grid, true));
        return ext::shared_ptr<Lattice>(
                              new ShortRateTree(trinomial, dynamics(), grid));
    }

}

]]></document_content>
  </document>
  <document index="112">
    <source>shortrate/onefactormodels/extendedcoxingersollross.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2021 Magnus Mencke

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/shortrate/onefactormodels/extendedcoxingersollross.hpp>
#include <ql/methods/lattices/trinomialtree.hpp>
#include <ql/math/distributions/chisquaredistribution.hpp>

namespace QuantLib {

    ExtendedCoxIngersollRoss::ExtendedCoxIngersollRoss(
                              const Handle<YieldTermStructure>& termStructure,
                              Real theta, Real k, Real sigma, Real x0,
                              bool withFellerConstraint)
    : CoxIngersollRoss(x0, theta, k, sigma, withFellerConstraint),
      TermStructureConsistentModel(termStructure){
        ExtendedCoxIngersollRoss::generateArguments();
    }

    ext::shared_ptr<Lattice> ExtendedCoxIngersollRoss::tree(
                                                 const TimeGrid& grid) const {
        TermStructureFittingParameter phi(termStructure());
        ext::shared_ptr<Dynamics> numericDynamics(
                              new Dynamics(phi, theta(), k(), sigma(), x0()));

        ext::shared_ptr<TrinomialTree> trinomial(
                   new TrinomialTree(numericDynamics->process(), grid, true));

        typedef TermStructureFittingParameter::NumericalImpl NumericalImpl;
        ext::shared_ptr<NumericalImpl> impl =
            ext::dynamic_pointer_cast<NumericalImpl>(phi.implementation());

        return ext::shared_ptr<Lattice>(
                   new ShortRateTree(trinomial, numericDynamics, impl, grid));
    }

    Real ExtendedCoxIngersollRoss::A(Time t, Time s) const {
        Real pt = termStructure()->discount(t);
        Real ps = termStructure()->discount(s);
        Real value = CoxIngersollRoss::A(t,s)*std::exp(B(t,s)*phi_(t))*
            (ps*CoxIngersollRoss::A(0.0,t)*std::exp(-B(0.0,t)*x0()))/
            (pt*CoxIngersollRoss::A(0.0,s)*std::exp(-B(0.0,s)*x0()));
        return value;
    }

    Real ExtendedCoxIngersollRoss::discountBondOption(Option::Type type,
                                                      Real strike,
                                                      Time t, Time s) const {

        QL_REQUIRE(strike>0.0, "strike must be positive");

        DiscountFactor discountT = termStructure()->discount(t);
        DiscountFactor discountS = termStructure()->discount(s);
        if (t < QL_EPSILON) {
            switch(type) {
              case Option::Call:
                return std::max<Real>(discountS - strike, 0.0);
              case Option::Put:
                return std::max<Real>(strike - discountS, 0.0);
              default: QL_FAIL("unsupported option type");
            }
        }

        Real sigma2 = sigma()*sigma();
        Real h = std::sqrt(k()*k() + 2.0*sigma2);
        Real r0 = termStructure()->forwardRate(0.0, 0.0,
                                               Continuous, NoFrequency);
        Real b = B(t,s);

        Real rho = 2.0*h/(sigma2*(std::exp(h*t) - 1.0));
        Real psi = (k() + h)/sigma2;

        Real df = 4.0*k()*theta()/sigma2;
        Real ncps = 2.0*rho*rho*(r0-phi_(0.0))*std::exp(h*t)/(rho+psi+b);
        Real ncpt = 2.0*rho*rho*(r0-phi_(0.0))*std::exp(h*t)/(rho+psi);

        NonCentralCumulativeChiSquareDistribution chis(df, ncps);
        NonCentralCumulativeChiSquareDistribution chit(df, ncpt);

        Real discountShift = (discountT*CoxIngersollRoss::A(0.0,s)*std::exp(-B(0.0,s)*x0()))/
        (discountS*CoxIngersollRoss::A(0.0,t)*std::exp(-B(0.0,t)*x0()));
        
        Real z = (std::log(CoxIngersollRoss::A(t,s)/strike)-std::log(discountShift))/b;
        Real call = discountS*chis(2.0*z*(rho+psi+b)) -
            strike*discountT*chit(2.0*z*(rho+psi));
        if (type == Option::Call)
            return call;
        else
            return call - discountS + strike*discountT;
    }

}
]]></document_content>
  </document>
  <document index="113">
    <source>shortrate/onefactormodels/gaussian1dmodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/shortrate/onefactormodels/gaussian1dmodel.hpp>
#include <ql/math/interpolations/cubicinterpolation.hpp>
#include <ql/payoff.hpp>
#include <cmath>

namespace QuantLib {

    Real Gaussian1dModel::forwardRate(const Date& fixing,
                                      const Date& referenceDate,
                                      const Real y,
                                      const ext::shared_ptr<IborIndex>& iborIdx) const {

        QL_REQUIRE(iborIdx != nullptr, "no ibor index given");

        calculate();

        if (fixing <= (evaluationDate_ + (enforcesTodaysHistoricFixings_ ? 0 : -1)))
            return iborIdx->fixing(fixing);

        Handle<YieldTermStructure> yts = iborIdx->forwardingTermStructure(); // might be empty, then
                                                                             // use model curve

        Date valueDate = iborIdx->valueDate(fixing);
        Date endDate = iborIdx->fixingCalendar().advance(
            valueDate, iborIdx->tenor(), iborIdx->businessDayConvention(), iborIdx->endOfMonth());
        // FIXME Here we should use the calculation date calendar ?
        Real dcf = iborIdx->dayCounter().yearFraction(valueDate, endDate);

        return (zerobond(valueDate, referenceDate, y, yts) -
                zerobond(endDate, referenceDate, y, yts)) /
               (dcf * zerobond(endDate, referenceDate, y, yts));
}

Real Gaussian1dModel::swapRate(const Date& fixing,
                               const Period& tenor,
                               const Date& referenceDate,
                               const Real y,
                               const ext::shared_ptr<SwapIndex>& swapIdx) const {

    QL_REQUIRE(swapIdx != nullptr, "no swap index given");

    calculate();

    if (fixing <= (evaluationDate_ + (enforcesTodaysHistoricFixings_ ? 0 : -1)))
        return swapIdx->fixing(fixing);

    Handle<YieldTermStructure> ytsf =
        swapIdx->iborIndex()->forwardingTermStructure();
    Handle<YieldTermStructure> ytsd =
        swapIdx->discountingTermStructure(); // either might be empty, then
                                             // use model curve

    Schedule sched, floatSched;

    ext::shared_ptr<VanillaSwap> underlying =
        underlyingSwap(swapIdx, fixing, tenor);

    sched = underlying->fixedSchedule();

    ext::shared_ptr<OvernightIndexedSwapIndex> oisIdx =
        ext::dynamic_pointer_cast<OvernightIndexedSwapIndex>(swapIdx);
    if (oisIdx != nullptr) {
        floatSched = sched;
    } else {
        floatSched = underlying->floatingSchedule();
    }

    Real annuity = swapAnnuity(fixing, tenor, referenceDate, y,
                               swapIdx);  // should be fine for
                                          // overnightindexed swap indices as
                                          // well
    Rate floatleg = 0.0;
    if (ytsf.empty() && ytsd.empty()) { // simple 100-formula can be used
                                        // only in one curve setup
        floatleg =
            (zerobond(sched.dates().front(), referenceDate, y) -
             zerobond(sched.calendar().adjust(sched.dates().back(),
                                              underlying->paymentConvention()),
                      referenceDate, y));
    } else {
        for (Size i = 1; i < floatSched.size(); i++) {
            floatleg +=
                (zerobond(floatSched[i - 1], referenceDate, y, ytsf) /
                     zerobond(floatSched[i], referenceDate, y, ytsf) -
                 1.0) *
                zerobond(floatSched.calendar().adjust(
                             floatSched[i], underlying->paymentConvention()),
                         referenceDate, y, ytsd);
        }
    }
    return floatleg / annuity;
}

Real Gaussian1dModel::swapAnnuity(const Date& fixing,
                                  const Period& tenor,
                                  const Date& referenceDate,
                                  const Real y,
                                  const ext::shared_ptr<SwapIndex>& swapIdx) const {

    QL_REQUIRE(swapIdx != nullptr, "no swap index given");

    calculate();

    Handle<YieldTermStructure> ytsd =
        swapIdx->discountingTermStructure(); // might be empty, then use
                                             // model curve

    ext::shared_ptr<VanillaSwap> underlying =
        underlyingSwap(swapIdx, fixing, tenor);

    Schedule sched = underlying->fixedSchedule();

    Real annuity = 0.0;
    for (unsigned int j = 1; j < sched.size(); j++) {
        annuity += zerobond(sched.calendar().adjust(
                                sched.date(j), underlying->paymentConvention()),
                            referenceDate, y, ytsd) *
                   swapIdx->dayCounter().yearFraction(sched.date(j - 1),
                                                      sched.date(j));
    }
    return annuity;
}

Real Gaussian1dModel::zerobondOption(
    const Option::Type &type, const Date &expiry, const Date &valueDate,
    const Date &maturity, const Rate strike, const Date &referenceDate,
    const Real y, const Handle<YieldTermStructure> &yts, const Real yStdDevs,
    const Size yGridPoints, const bool extrapolatePayoff,
    const bool flatPayoffExtrapolation) const {

    calculate();

    Time fixingTime = termStructure()->timeFromReference(expiry);
    Time referenceTime =
        referenceDate == Date()
            ? 0.0
            : termStructure()->timeFromReference(referenceDate);

    Array yg = yGrid(yStdDevs, yGridPoints, fixingTime, referenceTime, y);
    Array z = yGrid(yStdDevs, yGridPoints);

    Array p(yg.size());

    for (Size i = 0; i < yg.size(); i++) {
        Real expValDsc = zerobond(valueDate, expiry, yg[i], yts);
        Real discount =
            zerobond(maturity, expiry, yg[i], yts) / expValDsc;
        p[i] =
            std::max((type == Option::Call ? 1.0 : -1.0) * (discount - strike),
                     0.0) /
            numeraire(fixingTime, yg[i], yts) * expValDsc;
    }

    CubicInterpolation payoff(
        z.begin(), z.end(), p.begin(), CubicInterpolation::Spline, true,
        CubicInterpolation::Lagrange, 0.0, CubicInterpolation::Lagrange, 0.0);

    Real price = 0.0;
    for (Size i = 0; i < z.size() - 1; i++) {
        price += gaussianShiftedPolynomialIntegral(
            0.0, payoff.cCoefficients()[i], payoff.bCoefficients()[i],
            payoff.aCoefficients()[i], p[i], z[i], z[i], z[i + 1]);
    }
    if (extrapolatePayoff) {
        if (flatPayoffExtrapolation) {
            price += gaussianShiftedPolynomialIntegral(
                0.0, 0.0, 0.0, 0.0, p[z.size() - 2], z[z.size() - 2],
                z[z.size() - 1], 100.0);
            price += gaussianShiftedPolynomialIntegral(0.0, 0.0, 0.0, 0.0, p[0],
                                                       z[0], -100.0, z[0]);
        } else {
            if (type == Option::Call)
                price += gaussianShiftedPolynomialIntegral(
                    0.0, payoff.cCoefficients()[z.size() - 2],
                    payoff.bCoefficients()[z.size() - 2],
                    payoff.aCoefficients()[z.size() - 2], p[z.size() - 2],
                    z[z.size() - 2], z[z.size() - 1], 100.0);
            if (type == Option::Put)
                price += gaussianShiftedPolynomialIntegral(
                    0.0, payoff.cCoefficients()[0], payoff.bCoefficients()[0],
                    payoff.aCoefficients()[0], p[0], z[0], -100.0, z[0]);
        }
    }

    return numeraire(referenceTime, y, yts) * price;
}

Real Gaussian1dModel::gaussianPolynomialIntegral(
    const Real a, const Real b, const Real c, const Real d, const Real e,
    const Real y0, const Real y1) {

#ifdef GAUSS1D_ENABLE_NTL
    const boost::math::ntl::RR aa = 4.0 * a, ba = 2.0 * M_SQRT2 * b,
                               ca = 2.0 * c, da = M_SQRT2 * d;
    const boost::math::ntl::RR x0 = y0 * M_SQRT1_2, x1 = y1 * M_SQRT1_2;
    const boost::math::ntl::RR res =
        (0.125 * (3.0 * aa + 2.0 * ca + 4.0 * e) * std::erf(x1) -
         1.0 / (4.0 * M_SQRTPI) * std::exp(-x1 * x1) *
             (2.0 * aa * x1 * x1 * x1 + 3.0 * aa * x1 +
              2.0 * ba * (x1 * x1 + 1.0) + 2.0 * ca * x1 + 2.0 * da)) -
        (0.125 * (3.0 * aa + 2.0 * ca + 4.0 * e) * std::erf(x0) -
         1.0 / (4.0 * M_SQRTPI) * std::exp(-x0 * x0) *
             (2.0 * aa * x0 * x0 * x0 + 3.0 * aa * x0 +
              2.0 * ba * (x0 * x0 + 1.0) + 2.0 * ca * x0 + 2.0 * da));
    return NTL::to_double(res.value());
#else
    const Real aa = 4.0 * a, ba = 2.0 * M_SQRT2 * b, ca = 2.0 * c,
               da = M_SQRT2 * d;
    const Real x0 = y0 * M_SQRT1_2, x1 = y1 * M_SQRT1_2;
    return (0.125 * (3.0 * aa + 2.0 * ca + 4.0 * e) * std::erf(x1) -
            1.0 / (4.0 * M_SQRTPI) * std::exp(-x1 * x1) *
                (2.0 * aa * x1 * x1 * x1 + 3.0 * aa * x1 +
                 2.0 * ba * (x1 * x1 + 1.0) + 2.0 * ca * x1 + 2.0 * da)) -
           (0.125 * (3.0 * aa + 2.0 * ca + 4.0 * e) * std::erf(x0) -
            1.0 / (4.0 * M_SQRTPI) * std::exp(-x0 * x0) *
                (2.0 * aa * x0 * x0 * x0 + 3.0 * aa * x0 +
                 2.0 * ba * (x0 * x0 + 1.0) + 2.0 * ca * x0 + 2.0 * da));
#endif
}

Real Gaussian1dModel::gaussianShiftedPolynomialIntegral(
    const Real a, const Real b, const Real c, const Real d, const Real e,
    const Real h, const Real x0, const Real x1) {
    return gaussianPolynomialIntegral(
        a, -4.0 * a * h + b, 6.0 * a * h * h - 3.0 * b * h + c,
        -4 * a * h * h * h + 3.0 * b * h * h - 2.0 * c * h + d,
        a * h * h * h * h - b * h * h * h + c * h * h - d * h + e, x0, x1);
}

Array Gaussian1dModel::yGrid(
    const Real stdDevs, const int gridPoints, const Real T, const Real t, const Real y) const {

    // we use that the standard deviation is independent of $x$ here !

    QL_REQUIRE(stateProcess_ != nullptr, "state process not set");

    Array result(2 * gridPoints + 1, 0.0);

    Real x_t, e_0_t, e_t_T, stdDev_0_t, stdDev_t_T;
    Real stdDev_0_T = stateProcess_->stdDeviation(0.0, 0.0, T);
    Real e_0_T = stateProcess_->expectation(0.0, 0.0, T);

    if (t < QL_EPSILON) {
        // stdDev_0_t = 0.0;
        stdDev_t_T = stdDev_0_T;
        // e_0_t = 0.0;
        // x_t = 0.0;
        e_t_T = e_0_T;
    } else {
        stdDev_0_t = stateProcess_->stdDeviation(0.0, 0.0, t);
        stdDev_t_T = stateProcess_->stdDeviation(t, 0.0, T - t);
        e_0_t = stateProcess_->expectation(0.0, 0.0, t);
        x_t = y * stdDev_0_t + e_0_t;
        e_t_T = stateProcess_->expectation(t, x_t, T - t);
    }

    Real h = stdDevs / ((Real)gridPoints);

    for (int j = -gridPoints; j <= gridPoints; j++) {
        result[j + gridPoints] =
            (e_t_T + stdDev_t_T * ((Real)j) * h - e_0_T) / stdDev_0_T;
    }

    return result;
}
}
]]></document_content>
  </document>
  <document index="114">
    <source>shortrate/onefactormodels/gsr.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/shortrate/onefactormodels/gsr.hpp>
#include <ql/quotes/simplequote.hpp>
#include <utility>

namespace QuantLib {

    Gsr::Gsr(const Handle<YieldTermStructure>& termStructure,
             std::vector<Date> volstepdates,
             const std::vector<Real>& volatilities,
             const Real reversion,
             const Real T)
    : Gaussian1dModel(termStructure), CalibratedModel(2), reversion_(arguments_[0]),
      sigma_(arguments_[1]), volstepdates_(std::move(volstepdates)) {

        QL_REQUIRE(!termStructure.empty(), "yield term structure handle is empty");

        volatilities_.resize(volatilities.size());
        for (Size i = 0; i < volatilities.size(); ++i)
            volatilities_[i] = Handle<Quote>(ext::make_shared<SimpleQuote>(volatilities[i]));
        reversions_.resize(1);
        reversions_[0] = Handle<Quote>(ext::make_shared<SimpleQuote>(reversion));

        initialize(T);
    }

    Gsr::Gsr(const Handle<YieldTermStructure>& termStructure,
             std::vector<Date> volstepdates,
             const std::vector<Real>& volatilities,
             const std::vector<Real>& reversions,
             const Real T)
    : Gaussian1dModel(termStructure), CalibratedModel(2), reversion_(arguments_[0]),
      sigma_(arguments_[1]), volstepdates_(std::move(volstepdates)) {

        QL_REQUIRE(!termStructure.empty(), "yield term structure handle is empty");

        volatilities_.resize(volatilities.size());
        for (Size i = 0; i < volatilities.size(); ++i)
            volatilities_[i] = Handle<Quote>(ext::make_shared<SimpleQuote>(volatilities[i]));
        reversions_.resize(reversions.size());
        for (Size i = 0; i < reversions.size(); ++i)
            reversions_[i] = Handle<Quote>(ext::make_shared<SimpleQuote>(reversions[i]));

        initialize(T);
    }

    Gsr::Gsr(const Handle<YieldTermStructure>& termStructure,
             std::vector<Date> volstepdates,
             std::vector<Handle<Quote> > volatilities,
             const Handle<Quote>& reversion,
             const Real T)
    : Gaussian1dModel(termStructure), CalibratedModel(2), reversion_(arguments_[0]),
      sigma_(arguments_[1]), volatilities_(std::move(volatilities)),
      reversions_(std::vector<Handle<Quote> >(1, reversion)),
      volstepdates_(std::move(volstepdates)) {

        QL_REQUIRE(!termStructure.empty(), "yield term structure handle is empty");
        initialize(T);
    }

    Gsr::Gsr(const Handle<YieldTermStructure>& termStructure,
             std::vector<Date> volstepdates,
             std::vector<Handle<Quote> > volatilities,
             std::vector<Handle<Quote> > reversions,
             const Real T)
    : Gaussian1dModel(termStructure), CalibratedModel(2), reversion_(arguments_[0]),
      sigma_(arguments_[1]), volatilities_(std::move(volatilities)),
      reversions_(std::move(reversions)), volstepdates_(std::move(volstepdates)) {

        QL_REQUIRE(!termStructure.empty(), "yield term structure handle is empty");
        initialize(T);
    }

void Gsr::update() {
    if (stateProcess_ != nullptr) {
        ext::static_pointer_cast<GsrProcess>(stateProcess_)->flushCache();
        ext::static_pointer_cast<GsrProcess>(stateProcess_)->notifyObservers();
    }
    LazyObject::update();
}

void Gsr::updateTimes() const {
    volsteptimes_.clear();
    int j = 0;
    for (auto i = volstepdates_.begin(); i != volstepdates_.end(); ++i, ++j) {
        volsteptimes_.push_back(termStructure()->timeFromReference(*i));
        volsteptimesArray_[j] = volsteptimes_[j];
        if (j == 0)
            QL_REQUIRE(volsteptimes_[0] > 0.0, "volsteptimes must be positive ("
                                                   << volsteptimes_[0] << ")");
        else
            QL_REQUIRE(volsteptimes_[j] > volsteptimes_[j - 1],
                       "volsteptimes must be strictly increasing ("
                           << volsteptimes_[j - 1] << "@" << (j - 1) << ", "
                           << volsteptimes_[j] << "@" << j << ")");
    }
    if (stateProcess_ != nullptr) {
        ext::static_pointer_cast<GsrProcess>(stateProcess_)->flushCache();
        ext::static_pointer_cast<GsrProcess>(stateProcess_)->setTimes(volsteptimesArray_);
    }
}

void Gsr::updateVolatility() {
    for (Size i = 0; i < sigma_.size(); i++) {
        sigma_.setParam(i, volatilities_[i]->value());
    }
    ext::static_pointer_cast<GsrProcess>(stateProcess_)->setVols(sigma_.params());
    update();
}

void Gsr::updateReversion() {
    for (Size i = 0; i < reversion_.size(); i++) {
        reversion_.setParam(i, reversions_[i]->value());
    }
    ext::static_pointer_cast<GsrProcess>(stateProcess_)->setReversions(reversion_.params());
    update();
}

void Gsr::initialize(Real T) {

    volsteptimesArray_ = Array(volstepdates_.size());

    updateTimes();

    QL_REQUIRE(volatilities_.size() == volsteptimes_.size() + 1,
               "there must be n+1 volatilities ("
                   << volatilities_.size() << ") for n volatility step times ("
                   << volsteptimes_.size() << ")");

    QL_REQUIRE(reversions_.size() == 1 ||
                   reversions_.size() == volsteptimes_.size() + 1,
               "there must be 1 or n+1 reversions ("
                   << reversions_.size() << ") for n volatility step times ("
                   << volsteptimes_.size() << ")");
    if (reversions_.size() == 1) {
        reversion_ = ConstantParameter(reversions_[0]->value(), NoConstraint());
    } else {
        reversion_ = PiecewiseConstantParameter(volsteptimes_, NoConstraint());
        for (Size i = 0; i < reversion_.size(); i++) {
            reversion_.setParam(i, reversions_[i]->value());
        }
    }

    // sigma_ =
    // PiecewiseConstantParameter(volsteptimes_,PositiveConstraint());
    sigma_ = PiecewiseConstantParameter(volsteptimes_, NoConstraint());
    for (Size i = 0; i < sigma_.size(); i++) {
        sigma_.setParam(i, volatilities_[i]->value());
    }

    stateProcess_ = ext::make_shared<GsrProcess>(
        volsteptimesArray_, sigma_.params(), reversion_.params(), T);

    registerWith(termStructure());

    registerWith(stateProcess_);

    volatilityObserver_ = ext::make_shared<VolatilityObserver>(this);
    reversionObserver_ = ext::make_shared<ReversionObserver>(this);

    for (auto& reversion : reversions_)
        reversionObserver_->registerWith(reversion);

    for (auto& volatilitie : volatilities_)
        volatilityObserver_->registerWith(volatilitie);
}

Real Gsr::zerobondImpl(const Time T, const Time t, const Real y,
                       const Handle<YieldTermStructure> &yts) const {

    calculate();

    if (t == 0.0)
        return yts.empty() ? this->termStructure()->discount(T, true)
                           : yts->discount(T, true);

    ext::shared_ptr<GsrProcess> p = ext::static_pointer_cast<GsrProcess>(stateProcess_);

    Real x = y * stateProcess_->stdDeviation(0.0, 0.0, t) +
             stateProcess_->expectation(0.0, 0.0, t);
    Real gtT = p->G(t, T, x);

    Real d = yts.empty()
                 ? termStructure()->discount(T, true) /
                       termStructure()->discount(t, true)
                 : yts->discount(T, true) / yts->discount(t, true);

    return d * exp(-x * gtT - 0.5 * p->y(t) * gtT * gtT);
}

Real Gsr::numeraireImpl(const Time t, const Real y,
                        const Handle<YieldTermStructure> &yts) const {

    calculate();

    ext::shared_ptr<GsrProcess> p = ext::static_pointer_cast<GsrProcess>(stateProcess_);

    if (t == 0)
        return yts.empty()
                   ? this->termStructure()->discount(p->getForwardMeasureTime(),
                                                     true)
                   : yts->discount(p->getForwardMeasureTime());
    return zerobond(p->getForwardMeasureTime(), t, y, yts);
}
}
]]></document_content>
  </document>
  <document index="115">
    <source>shortrate/onefactormodels/hullwhite.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2006 Chiara Fornarola
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/shortrate/onefactormodels/hullwhite.hpp>
#include <ql/methods/lattices/trinomialtree.hpp>
#include <ql/pricingengines/blackformula.hpp>

using std::exp;
using std::sqrt;

namespace QuantLib {

    HullWhite::HullWhite(const Handle<YieldTermStructure>& termStructure,
                         Real a, Real sigma)
    : Vasicek(termStructure->forwardRate(0.0, 0.0, Continuous, NoFrequency),
                                         a, 0.0, sigma, 0.0),
      TermStructureConsistentModel(termStructure) {
        b_ = NullParameter();
        lambda_ = NullParameter();
        HullWhite::generateArguments();

        registerWith(termStructure);
    }

    ext::shared_ptr<Lattice> HullWhite::tree(const TimeGrid& grid) const {

        TermStructureFittingParameter phi(termStructure());
        ext::shared_ptr<ShortRateDynamics> numericDynamics(
                                             new Dynamics(phi, a(), sigma()));
        ext::shared_ptr<TrinomialTree> trinomial(
                         new TrinomialTree(numericDynamics->process(), grid));
        ext::shared_ptr<ShortRateTree> numericTree(
                         new ShortRateTree(trinomial, numericDynamics, grid));

        typedef TermStructureFittingParameter::NumericalImpl NumericalImpl;
        ext::shared_ptr<NumericalImpl> impl =
            ext::dynamic_pointer_cast<NumericalImpl>(phi.implementation());
        impl->reset();
        for (Size i=0; i<(grid.size() - 1); i++) {
            Real discountBond = termStructure()->discount(grid[i+1]);
            const Array& statePrices = numericTree->statePrices(i);
            Size size = numericTree->size(i);
            Time dt = numericTree->timeGrid().dt(i);
            Real dx = trinomial->dx(i);
            Real x = trinomial->underlying(i,0);
            Real value = 0.0;
            for (Size j=0; j<size; j++) {
                value += statePrices[j]*std::exp(-x*dt);
                x += dx;
            }
            value = std::log(value/discountBond)/dt;
            impl->set(grid[i], value);
        }
        return numericTree;
    }

    Real HullWhite::A(Time t, Time T) const {
        DiscountFactor discount1 = termStructure()->discount(t);
        DiscountFactor discount2 = termStructure()->discount(T);
        Rate forward = termStructure()->forwardRate(t, t,
                                                    Continuous, NoFrequency);
        Real temp = sigma()*B(t,T);
        Real value = B(t,T)*forward - 0.25*temp*temp*B(0.0,2.0*t);
        return std::exp(value)*discount2/discount1;
    }

    void HullWhite::generateArguments() {
        phi_ = FittingParameter(termStructure(), a(), sigma());
    }

    Real HullWhite::discountBondOption(Option::Type type, Real strike,
                                       Time maturity,
                                       Time bondMaturity) const {

        Real _a = a();
        Real v;
        if (_a < std::sqrt(QL_EPSILON)) {
            v = sigma()*B(maturity, bondMaturity)* std::sqrt(maturity);
        } else {
            v = sigma()*B(maturity, bondMaturity)*
                std::sqrt(0.5*(1.0 - std::exp(-2.0*_a*maturity))/_a);
        }
        Real f = termStructure()->discount(bondMaturity);
        Real k = termStructure()->discount(maturity)*strike;

        return blackFormula(type, k, f, v);
    }

    Real HullWhite::discountBondOption(Option::Type type, Real strike,
                                       Time maturity, Time bondStart,
                                       Time bondMaturity) const {

        Real _a = a();
        Real v;
        if (_a < std::sqrt(QL_EPSILON)) {
            v = sigma()*B(bondStart, bondMaturity)* std::sqrt(maturity);
        } else {
            Real c = exp(-2.0*_a*(bondStart-maturity))
                - exp(-2.0*_a*bondStart)
                -2.0*(exp(-_a*(bondStart+bondMaturity-2.0*maturity))
                      - exp(-_a*(bondStart+bondMaturity)))
                + exp(-2.0*_a*(bondMaturity-maturity))
                - exp(-2.0*_a*bondMaturity);
            // The above should always be positive, but due to
            // numerical errors it can be a very small negative number.
            // We floor it at 0 to avoid NaNs.
            v = sigma()/(_a*sqrt(2.0*_a)) * sqrt(std::max(c, 0.0));
        }
        Real f = termStructure()->discount(bondMaturity);
        Real k = termStructure()->discount(bondStart)*strike;

        return blackFormula(type, k, f, v);
    }

    Rate HullWhite::convexityBias(Real futuresPrice,
                                  Time t,
                                  Time T,
                                  Real sigma,
                                  Real a) {
        QL_REQUIRE(futuresPrice>=0.0,
            "negative futures price (" << futuresPrice << ") not allowed");
        QL_REQUIRE(t>=0.0,
            "negative t (" << t << ") not allowed");
        QL_REQUIRE(T>=t,
            "T (" << T << ") must not be less than t (" << t << ")");
        QL_REQUIRE(sigma>=0.0,
            "negative sigma (" << sigma << ") not allowed");
        QL_REQUIRE(a>=0.0,
            "negative a (" << a << ") not allowed");

        auto temp = [a](Real x) { return a < QL_EPSILON ? x : (1.0-std::exp(-a*x)) / a; };

        Time deltaT = (T-t);
        Real tempDeltaT = temp(deltaT);
        Real halfSigmaSquare = sigma*sigma/2.0;

        // lambda adjusts for the fact that the underlying is an interest rate
        Real lambda = temp(2.0*t) * tempDeltaT;

        Real tempT = temp(t);

        // phi is the MtM adjustment
        Real phi = tempT * tempT;

        // the adjustment
        Real z = halfSigmaSquare * (lambda + phi);

        Rate futureRate = (100.0-futuresPrice)/100.0;
        return deltaT < QL_EPSILON ? z : (1.0-std::exp(-z*tempDeltaT)) * (futureRate + 1.0/deltaT);
    }

}

]]></document_content>
  </document>
  <document index="116">
    <source>shortrate/onefactormodels/markovfunctional.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2018 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/math/interpolations/cubicinterpolation.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/models/shortrate/onefactormodels/markovfunctional.hpp>
#include <ql/termstructures/volatility/atmadjustedsmilesection.hpp>
#include <ql/termstructures/volatility/atmsmilesection.hpp>
#include <ql/termstructures/volatility/kahalesmilesection.hpp>
#include <ql/termstructures/volatility/sabrinterpolatedsmilesection.hpp>
#include <ql/termstructures/volatility/smilesection.hpp>
#include <ql/termstructures/volatility/smilesectionutils.hpp>
#include <utility>

namespace QuantLib {

    MarkovFunctional::MarkovFunctional(const Handle<YieldTermStructure>& termStructure,
                                       const Real reversion,
                                       std::vector<Date> volstepdates,
                                       std::vector<Real> volatilities,
                                       const Handle<SwaptionVolatilityStructure>& swaptionVol,
                                       const std::vector<Date>& swaptionExpiries,
                                       const std::vector<Period>& swaptionTenors,
                                       const ext::shared_ptr<SwapIndex>& swapIndexBase,
                                       MarkovFunctional::ModelSettings modelSettings)
    : Gaussian1dModel(termStructure), CalibratedModel(1), modelSettings_(std::move(modelSettings)),
      capletCalibrated_(false), reversion_(ConstantParameter(reversion, NoConstraint())),
      sigma_(arguments_[0]), volstepdates_(std::move(volstepdates)),
      volatilities_(std::move(volatilities)), swaptionVol_(swaptionVol),
      swaptionExpiries_(swaptionExpiries), swaptionTenors_(swaptionTenors),
      swapIndexBase_(swapIndexBase), iborIndex_(swapIndexBase->iborIndex()) {

        QL_REQUIRE(swaptionExpiries.size() == swaptionTenors.size(),
                   "number of swaption expiries ("
                       << swaptionExpiries.size()
                       << ") is differnt from number of swaption tenors ("
                       << swaptionTenors.size() << ")");
        QL_REQUIRE(!swaptionExpiries.empty(),
                   "need at least one swaption expiry to calibrate numeraire");
        QL_REQUIRE(!termStructure.empty(),
                   "yield term structure handle is empty");
        QL_REQUIRE(!swaptionVol.empty(),
                   "swaption volatility structure is empty");
        modelSettings_.validate();
        initialize();
    }

    MarkovFunctional::MarkovFunctional(const Handle<YieldTermStructure>& termStructure,
                                       const Real reversion,
                                       std::vector<Date> volstepdates,
                                       std::vector<Real> volatilities,
                                       const Handle<OptionletVolatilityStructure>& capletVol,
                                       const std::vector<Date>& capletExpiries,
                                       ext::shared_ptr<IborIndex> iborIndex,
                                       MarkovFunctional::ModelSettings modelSettings)
    : Gaussian1dModel(termStructure), CalibratedModel(1), modelSettings_(std::move(modelSettings)),
      capletCalibrated_(true), reversion_(ConstantParameter(reversion, NoConstraint())),
      sigma_(arguments_[0]), volstepdates_(std::move(volstepdates)),
      volatilities_(std::move(volatilities)), capletVol_(capletVol),
      capletExpiries_(capletExpiries), iborIndex_(std::move(iborIndex)) {

        QL_REQUIRE(!capletExpiries.empty(),
                   "need at least one caplet expiry to calibrate numeraire");
        QL_REQUIRE(!termStructure.empty(),
                   "yield term structure handle is empty");
        QL_REQUIRE(!capletVol.empty(), "caplet volatility structure is empty");
        modelSettings_.validate();
        initialize();
    }

    void MarkovFunctional::updateTimes() const {
        QL_MFMESSAGE(modelOutputs_,"updating times");
        updateTimes1();
        updateTimes2();
    }

    void MarkovFunctional::updateTimes1() const {
        volsteptimes_.clear();
        int j = 0;
        for (auto i = volstepdates_.begin(); i != volstepdates_.end(); ++i, ++j) {
            volsteptimes_.push_back(termStructure()->timeFromReference(*i));
            volsteptimesArray_[j] = volsteptimes_[j];
            if (j == 0)
                QL_REQUIRE(volsteptimes_[0] > 0.0,
                           "volsteptimes must be positive (" << volsteptimes_[0]
                                                             << ")");
            else
                QL_REQUIRE(volsteptimes_[j] > volsteptimes_[j - 1],
                           "volsteptimes must be strictly increasing ("
                               << volsteptimes_[j - 1] << "@" << (j - 1) << ", "
                               << volsteptimes_[j] << "@" << j << ")");
        }
        if (stateProcess_)
            ext::static_pointer_cast<MfStateProcess>(stateProcess_)->setTimes(volsteptimesArray_);
    }

    void MarkovFunctional::updateTimes2() const {
        numeraireTime_ = termStructure()->timeFromReference(numeraireDate_);
        times_.clear();
        times_.push_back(0.0);
        modelOutputs_.expiries_.clear();
        modelOutputs_.tenors_.clear();
        for (auto& calibrationPoint : calibrationPoints_) {
            times_.push_back(termStructure()->timeFromReference(calibrationPoint.first));
            modelOutputs_.expiries_.push_back(calibrationPoint.first);
            modelOutputs_.tenors_.push_back(calibrationPoint.second.tenor_);
        }
        times_.push_back(numeraireTime_);
        QL_REQUIRE(volatilities_.size() == volsteptimes_.size() + 1,
                   "there must be n+1 volatilities ("
                       << volatilities_.size()
                       << ") for n volatility step times ("
                       << volsteptimes_.size() << ")");
    }


    void MarkovFunctional::initialize() {

        QL_MFMESSAGE(modelOutputs_, "initializing");
        modelOutputs_.dirty_ = true;

        modelOutputs_.settings_ = modelSettings_;

        GaussHermiteIntegration gaussHermite(
            modelSettings_.gaussHermitePoints_);
        normalIntegralX_ = gaussHermite.x();
        normalIntegralW_ = gaussHermite.weights();
        for (Size i = 0; i < normalIntegralX_.size(); i++) {
            normalIntegralW_[i] *=
                std::exp(-normalIntegralX_[i] * normalIntegralX_[i]) * M_1_SQRTPI;
            normalIntegralX_[i] *= M_SQRT2;
        }

        volsteptimesArray_ = Array(volstepdates_.size());

        updateTimes1();

        if (capletCalibrated_) {
            for (auto capletExpirie : capletExpiries_) {
                makeCapletCalibrationPoint(capletExpirie);
            }
        } else {
            std::vector<Date>::const_iterator i;
            std::vector<Period>::const_iterator j;
            for (i = swaptionExpiries_.begin(), j = swaptionTenors_.begin();
                 i != swaptionExpiries_.end(); ++i, ++j) {
                makeSwaptionCalibrationPoint(*i, *j);
            }
        }

        bool done;
        numeraireDate_ = Date::minDate();
        do {
            Date numeraireKnown = numeraireDate_;
            done = true;
            for (auto i = calibrationPoints_.rbegin(); i != calibrationPoints_.rend() && done;
                 ++i) {
                if (i->second.paymentDates_.back() > numeraireDate_) {
                    numeraireDate_ = i->second.paymentDates_.back();
                    numeraireKnown = i->second.paymentDates_.back();
                    done = i == calibrationPoints_.rbegin();
                }
                for (auto j = i->second.paymentDates_.rbegin();
                     j != i->second.paymentDates_.rend() && done; ++j) {
                    if (*j < numeraireKnown) {
                        if (capletCalibrated_) {
                            makeCapletCalibrationPoint(*j);
                            done = false;
                            break;
                        } else {
                            Size months = std::max(
                                1, static_cast<Integer>(((numeraireKnown - *j) / 365.25) * 12.0));
                            while (underlyingSwap(swapIndexBase_, *j, months * Months)
                                       ->maturityDate() < numeraireKnown)
                                ++months;
                            makeSwaptionCalibrationPoint(*j, months * Months);
                            done = false;
                            break;
                        }
                    }
                }
                if (done) {
                    numeraireKnown = i->first;
                }
            }
        } while (!done);

        updateTimes2();

        sigma_ =
            PiecewiseConstantParameter(volsteptimes_, PositiveConstraint());
        for (Size i = 0; i < sigma_.size(); i++) {
            sigma_.setParam(i, volatilities_[i]);
        }

        stateProcess_ = ext::make_shared<MfStateProcess>(
            reversion_(0.0), volsteptimesArray_, sigma_.params());

        y_ = yGrid(modelSettings_.yStdDevs_, modelSettings_.yGridPoints_);

        discreteNumeraire_ = ext::make_shared<Matrix>(
            times_.size(), 2 * modelSettings_.yGridPoints_ + 1, 1.0);
        for (Size i = 0; i < times_.size(); i++) {
            ext::shared_ptr<Interpolation> numInt(new CubicInterpolation(
                y_.begin(), y_.end(), discreteNumeraire_->row_begin(i),
                CubicInterpolation::Spline, true, CubicInterpolation::Lagrange,
                0.0, CubicInterpolation::Lagrange, 0.0));
            numInt->enableExtrapolation();
            numeraire_.push_back(numInt);
        }

        registerWith(termStructure());
        if (!swaptionVol_.empty())
            registerWith(swaptionVol_);
        if (!capletVol_.empty())
            registerWith(capletVol_);
    }

    void MarkovFunctional::makeSwaptionCalibrationPoint(const Date &expiry,
                                                        const Period &tenor) {

        QL_REQUIRE(calibrationPoints_.count(expiry) == 0,
                   "swaption expiry ("
                       << expiry
                       << ") occurs more than once in calibration set");

        CalibrationPoint p;
        p.isCaplet_ = false;
        p.tenor_ = tenor;

        ext::shared_ptr<VanillaSwap> underlying = underlyingSwap(swapIndexBase_, expiry, tenor);

        Schedule sched = underlying->fixedSchedule();
        const Calendar& cal = sched.calendar();
        BusinessDayConvention bdc = underlying->paymentConvention();

        for (unsigned int k = 1; k < sched.size(); k++) {
            p.yearFractions_.push_back(
                swapIndexBase_->dayCounter().yearFraction(
                    k == 1 ? expiry : sched.date(k - 1), sched.date(k)));
            p.paymentDates_.push_back(cal.adjust(sched.date(k), bdc));
        }
        calibrationPoints_[expiry] = p;
    }

    void MarkovFunctional::makeCapletCalibrationPoint(const Date &expiry) {

        QL_REQUIRE(
            calibrationPoints_.count(expiry) == 0,
            "caplet expiry (" << expiry
                              << ") occurs more than once in calibration set");

        CalibrationPoint p;
        p.isCaplet_ = true;
        // p.expiry_ = expiry;
        p.tenor_ = iborIndex_->tenor();
        Date valueDate = iborIndex_->valueDate(expiry);
        Date endDate = iborIndex_->fixingCalendar().advance(
            valueDate, iborIndex_->tenor(), iborIndex_->businessDayConvention(),
            iborIndex_->endOfMonth());
        // FIXME Here we should use a calculation date calendar ?
        p.paymentDates_.push_back(endDate);
        p.yearFractions_.push_back(
            iborIndex_->dayCounter().yearFraction(expiry, endDate));
        // adjust the first period to start on expiry
        calibrationPoints_[expiry] = p;
    }

    void MarkovFunctional::updateSmiles() const {

        QL_MFMESSAGE(modelOutputs_, "updating smiles");
        modelOutputs_.dirty_ = true;

        arbitrageIndices_.clear();

        Size pointIndex = 0;

        for (auto i = calibrationPoints_.rbegin(); i != calibrationPoints_.rend(); ++i) {

            ext::shared_ptr<SmileSection> smileSection;
            if (i->second.isCaplet_) {
                i->second.annuity_ =
                    i->second.yearFractions_[0] *
                    termStructure()->discount(i->second.paymentDates_[0], true);
                i->second.atm_ = (termStructure()->discount(i->first, true) -
                                  termStructure()->discount(
                                      i->second.paymentDates_[0], true)) /
                                 i->second.annuity_;
                smileSection = capletVol_->smileSection(i->first, true);
            } else {
                Real annuity = 0.0;
                for (unsigned int k = 0; k < i->second.paymentDates_.size();
                     k++) {
                    annuity += i->second.yearFractions_[k] *
                               termStructure()->discount(
                                   i->second.paymentDates_[k], true);
                }
                i->second.annuity_ = annuity;
                i->second.atm_ = (termStructure()->discount(i->first, true) -
                                  termStructure()->discount(
                                      i->second.paymentDates_.back(), true)) /
                                 annuity;
                smileSection = swaptionVol_->smileSection(
                    i->first, i->second.tenor_, true);
            }

            i->second.rawSmileSection_ = ext::shared_ptr<SmileSection>(
                new AtmSmileSection(smileSection, i->second.atm_));

            int forcedLeftIndex = -1;
            int forcedRightIndex = QL_MAX_INTEGER;
            if(forcedArbitrageIndices_.size() > pointIndex) {
                forcedLeftIndex = forcedArbitrageIndices_[pointIndex].first;
                forcedRightIndex = forcedArbitrageIndices_[pointIndex].second;
            }

            if ((modelSettings_.adjustments_ & ModelSettings::KahaleSmile) != 0) {

                i->second.smileSection_ = ext::make_shared<KahaleSmileSection>(
                    
                        i->second.rawSmileSection_, i->second.atm_,
                        (modelSettings_.adjustments_ &
                         ModelSettings::KahaleInterpolation) != 0,
                        (modelSettings_.adjustments_ &
                         ModelSettings::SmileExponentialExtrapolation) != 0,
                        (modelSettings_.adjustments_ &
                         ModelSettings::SmileDeleteArbitragePoints) != 0,
                        modelSettings_.smileMoneynessCheckpoints_,
                        modelSettings_.digitalGap_,
                        forcedLeftIndex, forcedRightIndex);

                arbitrageIndices_.push_back(
                    ext::dynamic_pointer_cast<KahaleSmileSection>(
                        i->second.smileSection_)->coreIndices());

            } else {

                if ((modelSettings_.adjustments_ & ModelSettings::SabrSmile) != 0) {

                    SmileSectionUtils ssutils(
                        *i->second.rawSmileSection_,
                        modelSettings_.smileMoneynessCheckpoints_);
                    std::vector<Real> k = ssutils.strikeGrid();
                    k.erase(k.begin()); // the first strike is zero which we do
                                        // not want in the sabr calibration
                    QL_REQUIRE(i->second.rawSmileSection_->volatilityType() ==
                                   ShiftedLognormal,
                               "MarkovFunctional: SABR calibration to normal "
                               "input volatilities is not supported");
                    QL_REQUIRE(
                        k.size() >= 4,
                        "for sabr calibration at least 4 points are needed (is "
                            << k.size() << ")");
                    std::vector<Real> v;
                    v.reserve(k.size());
                    for (Real j : k) {
                        v.push_back(i->second.rawSmileSection_->volatility(j));
                    }

                    // TODO should we fix beta to avoid numerical instabilities
                    // during calibration ?
                    ext::shared_ptr<SabrInterpolatedSmileSection> sabrSection(
                        new SabrInterpolatedSmileSection(
                            i->first, i->second.atm_, k, false,
                            i->second.rawSmileSection_->volatility(
                                i->second.atm_),
                            v, 0.03, 0.80, 0.50, 0.00, false, false, false,
                            false, true, ext::shared_ptr<EndCriteria>(),
                            ext::shared_ptr<OptimizationMethod>(),
                            Actual365Fixed(),
                                i->second.rawSmileSection_->shift()));

                    // we make the sabr section arbitrage free by superimposing
                    // a kahalesection

                    i->second.smileSection_ = ext::make_shared<
                        KahaleSmileSection>(
                        sabrSection, i->second.atm_, false,
                        (modelSettings_.adjustments_ &
                         ModelSettings::SmileExponentialExtrapolation) != 0,
                        (modelSettings_.adjustments_ &
                         ModelSettings::SmileDeleteArbitragePoints) != 0,
                        modelSettings_.smileMoneynessCheckpoints_,
                        modelSettings_.digitalGap_,
                        forcedLeftIndex, forcedRightIndex);

                    arbitrageIndices_.push_back(
                        ext::dynamic_pointer_cast<KahaleSmileSection>(
                            i->second.smileSection_)->coreIndices());

                } else if ((modelSettings_.adjustments_ & ModelSettings::CustomSmile) != 0) {

                    // Custom smile section is af by assumption
                    i->second.smileSection_ =
                        modelSettings_.customSmileFactory_->smileSection(
                            i->second.rawSmileSection_, i->second.atm_);
                    arbitrageIndices_.emplace_back(Null<Size>(), Null<Size>());
                } else { // no smile pretreatment

                    i->second.smileSection_ = i->second.rawSmileSection_;
                }
            }

            // custom smile will take care of this itself
            if ((modelSettings_.adjustments_ & ModelSettings::CustomSmile) == 0) {
                i->second.minRateDigital_ =
                    i->second.smileSection_->digitalOptionPrice(
                        modelSettings_.lowerRateBound_ -
                            i->second.smileSection_->shift(),
                        Option::Call, i->second.annuity_,
                        modelSettings_.digitalGap_);
                i->second.maxRateDigital_ =
                    i->second.smileSection_->digitalOptionPrice(
                        modelSettings_.upperRateBound_ -
                            i->second.smileSection_->shift(),
                        Option::Call, i->second.annuity_,
                        modelSettings_.digitalGap_);
            }

            ++pointIndex;
        }
    }

    void MarkovFunctional::updateNumeraireTabulation() const {

        QL_MFMESSAGE(modelOutputs_, "updating numeraire tabulation");
        modelOutputs_.dirty_ = true;

        modelOutputs_.adjustmentFactors_.clear();
        modelOutputs_.digitalsAdjustmentFactors_.clear();

        int idx = times_.size() - 2;

        for (auto i = calibrationPoints_.rbegin(); i != calibrationPoints_.rend(); ++i, --idx) {

            ext::shared_ptr<CustomSmileSection> mfSec;
            if ((modelSettings_.adjustments_ & ModelSettings::CustomSmile) != 0) {
                mfSec = ext::dynamic_pointer_cast<CustomSmileSection>(
                    i->second.smileSection_);
                QL_REQUIRE(mfSec,
                           "no CustomSmileSection given, this is unexpected...");
            }

            Array discreteDeflatedAnnuities(y_.size(), 0.0);
            Array deflatedFinalPayments;

            Real numeraire0 = termStructure()->discount(numeraireTime_, true);
            Real normalization =
                termStructure()->discount(times_[idx], true) / numeraire0;

            for (unsigned int k = 0; k < i->second.paymentDates_.size(); k++) {
                deflatedFinalPayments =
                    deflatedZerobondArray(termStructure()->timeFromReference(
                                              i->second.paymentDates_[k]),
                                          times_[idx], y_);
                discreteDeflatedAnnuities +=
                    deflatedFinalPayments * i->second.yearFractions_[k];
            }

            CubicInterpolation deflatedAnnuities(
                y_.begin(), y_.end(), discreteDeflatedAnnuities.begin(),
                CubicInterpolation::Spline, true, CubicInterpolation::Lagrange,
                0.0, CubicInterpolation::Lagrange, 0.0);
            deflatedAnnuities.enableExtrapolation();

            Real digitalsCorrectionFactor = 1.0;
            modelOutputs_.digitalsAdjustmentFactors_.insert(
                modelOutputs_.digitalsAdjustmentFactors_.begin(),
                digitalsCorrectionFactor);

            Real digital = 0.0, swapRate, swapRate0;

            for (int c = 0;
                 c == 0 ||
                 (c == 1 && ((modelSettings_.adjustments_ & ModelSettings::AdjustDigitals) != 0));
                 c++) {

                if (c == 1) {
                    digitalsCorrectionFactor = i->second.annuity_ / digital;
                    modelOutputs_.digitalsAdjustmentFactors_.front() =
                        digitalsCorrectionFactor;
                }

                digital = 0.0;
                swapRate0 =
                    modelSettings_.upperRateBound_ / 2.0; // initial guess
                for (int j = y_.size() - 1; j >= 0; j--) {

                    Real integral = 0.0;

                    if (j == (int)(y_.size() - 1)) {
                        if ((modelSettings_.adjustments_ &
                             ModelSettings::NoPayoffExtrapolation) == 0) {
                            if ((modelSettings_.adjustments_ &
                                 ModelSettings::ExtrapolatePayoffFlat) != 0) {
                                integral = gaussianShiftedPolynomialIntegral(
                                    0.0, 0.0, 0.0, 0.0,
                                    discreteDeflatedAnnuities[j - 1], y_[j - 1],
                                    y_[j], 100.0);
                            } else {
                                Real ca =
                                    deflatedAnnuities.aCoefficients()[j - 1];
                                Real cb =
                                    deflatedAnnuities.bCoefficients()[j - 1];
                                Real cc =
                                    deflatedAnnuities.cCoefficients()[j - 1];
                                integral = gaussianShiftedPolynomialIntegral(
                                    0.0, cc, cb, ca,
                                    discreteDeflatedAnnuities[j - 1], y_[j - 1],
                                    y_[j], 100.0);
                            }
                        }
                    } else {
                        Real ca = deflatedAnnuities.aCoefficients()[j];
                        Real cb = deflatedAnnuities.bCoefficients()[j];
                        Real cc = deflatedAnnuities.cCoefficients()[j];
                        integral = gaussianShiftedPolynomialIntegral(
                            0.0, cc, cb, ca, discreteDeflatedAnnuities[j],
                            y_[j], y_[j], y_[j + 1]);
                    }

                    if (integral < 0) {
                        QL_MFMESSAGE(modelOutputs_,
                                     "WARNING: integral for digitalPrice is "
                                     "negative for j="
                                         << j << " (" << integral
                                         << ") --- reset it to zero.");
                        integral = 0.0;
                    }

                    digital += integral * numeraire0 * digitalsCorrectionFactor;

                    bool check = true;
                    if ((modelSettings_.adjustments_ & ModelSettings::CustomSmile) != 0) {
                        swapRate = mfSec->inverseDigitalCall(
                            digital, i->second.annuity_);
                    } else if (digital >= i->second.minRateDigital_) {
                        swapRate = modelSettings_.lowerRateBound_ -
                                   i->second.rawSmileSection_->shift();
                        check = false;
                    } else if (digital <= i->second.maxRateDigital_) {
                        swapRate = modelSettings_.upperRateBound_;
                        check = false;
                    } else {
                        swapRate = marketSwapRate(
                            i->first, i->second, digital, swapRate0,
                            i->second.rawSmileSection_->shift());
                    }
                    if (check && j < (int)y_.size() - 1 &&
                        swapRate > swapRate0) {
                        QL_MFMESSAGE(
                            modelOutputs_,
                            "WARNING: swap rate is decreasing in y for "
                            "t=" << times_[idx]
                                 << ", j=" << j << " (y, swap rate) is ("
                                 << y_[j] << "," << swapRate << ") but for j="
                                 << j + 1 << " it is (" << y_[j + 1] << ","
                                 << swapRate0 << ") --- reset rate to "
                                 << swapRate0 << " in node j=" << j);
                        swapRate = swapRate0;
                    }
                    swapRate0 = swapRate;
                    Real numeraire =
                        1.0 / std::max(swapRate * discreteDeflatedAnnuities[j] +
                                       deflatedFinalPayments[j], 1E-6);
                    (*discreteNumeraire_)[idx][j] = numeraire * normalization;
                }
            }

            if ((modelSettings_.adjustments_ & ModelSettings::AdjustYts) != 0) {
                numeraire_[idx]->update();
                Real modelDeflatedZerobond = deflatedZerobond(times_[idx], 0.0);
                Real marketDeflatedZerobond =
                    termStructure()->discount(times_[idx], true) /
                    termStructure()->discount(numeraireTime_, true);
                for (int j = y_.size() - 1; j >= 0; j--) {
                    (*discreteNumeraire_)[idx][j] *=
                        modelDeflatedZerobond / marketDeflatedZerobond;
                }
                modelOutputs_.adjustmentFactors_.insert(
                    modelOutputs_.adjustmentFactors_.begin(),
                    modelDeflatedZerobond / marketDeflatedZerobond);
            } else {
                modelOutputs_.adjustmentFactors_.insert(
                    modelOutputs_.adjustmentFactors_.begin(), 1.0);
            }

            numeraire_[idx]->update();
        }
    }

    const MarkovFunctional::ModelOutputs &
    MarkovFunctional::modelOutputs() const {

        if (modelOutputs_.dirty_) {

            calculate();

            // yield term structure
            modelOutputs_.marketZerorate_.clear();
            modelOutputs_.modelZerorate_.clear();
            for (Size i = 1; i < times_.size() - 1; i++) {
                modelOutputs_.marketZerorate_.push_back(
                    termStructure()->zeroRate(times_[i], QuantLib::Continuous,
                                              QuantLib::Annual));
                // we need to put a small positive time here since the zerobond
                // implementation optimizes the case t=0.0 then using the
                // initial yts
                modelOutputs_.modelZerorate_.push_back(
                    -std::log(zerobond(times_[i], 1.0E-10)) / times_[i]);
            }

            // volatility surface
            modelOutputs_.smileStrikes_.clear();
            modelOutputs_.marketCallPremium_.clear();
            modelOutputs_.marketPutPremium_.clear();
            modelOutputs_.modelCallPremium_.clear();
            modelOutputs_.modelPutPremium_.clear();
            modelOutputs_.marketVega_.clear();
            modelOutputs_.marketRawCallPremium_.clear();
            modelOutputs_.marketRawPutPremium_.clear();

            for (auto& calibrationPoint : calibrationPoints_) {
                modelOutputs_.atm_.push_back(calibrationPoint.second.atm_);
                modelOutputs_.annuity_.push_back(calibrationPoint.second.annuity_);
                ext::shared_ptr<SmileSection> sec = calibrationPoint.second.smileSection_;
                ext::shared_ptr<SmileSection> rawSec = calibrationPoint.second.rawSmileSection_;
                SmileSectionUtils ssutils(*sec, modelSettings_.smileMoneynessCheckpoints_,
                                          calibrationPoint.second.atm_);
                Real shift = sec->shift();
                const std::vector<Real>& money = ssutils.moneyGrid();
                std::vector<Real> strikes, marketCall, marketPut, modelCall,
                    modelPut, marketVega, marketRawCall, marketRawPut;
                for (Size j = 0; j < money.size(); j++) {
                    strikes.push_back(sec->volatilityType() == Normal ?
                                          Real(calibrationPoint.second.atm_ + money[j]) :
                                          money[j] * (calibrationPoint.second.atm_ + shift) -
                                              shift);
                    try {
                        marketRawCall.push_back(rawSec->optionPrice(
                            strikes[j], Option::Call, calibrationPoint.second.annuity_));
                        marketRawPut.push_back(rawSec->optionPrice(
                            strikes[j], Option::Put, calibrationPoint.second.annuity_));
                    }
                    catch (Error&) {
                        // the smile section might not be able to output an
                        // option price because it has no atm level
                        marketRawCall.push_back(0.0);
                        marketRawPut.push_back(0.0);
                    }
                    marketCall.push_back(sec->optionPrice(strikes[j], Option::Call,
                                                          calibrationPoint.second.annuity_));
                    marketPut.push_back(sec->optionPrice(strikes[j], Option::Put,
                                                         calibrationPoint.second.annuity_));
                    modelCall.push_back(
                        calibrationPoint.second.isCaplet_ ?
                            capletPriceInternal(Option::Call, calibrationPoint.first, strikes[j],
                                                Date(), 0.0, true) :
                            swaptionPriceInternal(Option::Call, calibrationPoint.first,
                                                  calibrationPoint.second.tenor_, strikes[j],
                                                  Date(), 0.0, true));
                    modelPut.push_back(
                        calibrationPoint.second.isCaplet_ ?
                            capletPriceInternal(Option::Put, calibrationPoint.first, strikes[j],
                                                Date(), 0.0, true) :
                            swaptionPriceInternal(Option::Put, calibrationPoint.first,
                                                  calibrationPoint.second.tenor_, strikes[j],
                                                  Date(), 0.0, true));
                    marketVega.push_back(sec->vega(strikes[j], calibrationPoint.second.annuity_));
                }
                modelOutputs_.smileStrikes_.push_back(strikes);
                modelOutputs_.marketCallPremium_.push_back(marketCall);
                modelOutputs_.marketPutPremium_.push_back(marketPut);
                modelOutputs_.modelCallPremium_.push_back(modelCall);
                modelOutputs_.modelPutPremium_.push_back(modelPut);
                modelOutputs_.marketVega_.push_back(marketVega);
                modelOutputs_.marketRawCallPremium_.push_back(marketRawCall);
                modelOutputs_.marketRawPutPremium_.push_back(marketRawPut);
            }

            modelOutputs_.dirty_ = false;
        }

        return modelOutputs_;
    }

    Array MarkovFunctional::numeraireArray(const Time t, const Array& y) const {

        calculate();
        Array res(y.size(), termStructure()->discount(numeraireTime_, true));
        if (t < QL_EPSILON)
            return res;

        Real inverseNormalization =
            termStructure()->discount(numeraireTime_, true) /
            termStructure()->discount(t, true);

        Time tz = std::min(t, times_.back());
        Size i = std::min<Size>(
            std::upper_bound(times_.begin(), times_.end() - 1, t) -
                times_.begin(),
            times_.size() - 1);

        Real ta = times_[i - 1];
        Real tb = times_[i];
        Real dt = tb - ta;

        for (Size j = 0; j < y.size(); j++) {
            Real yv = y[j];
            if (yv < y_.front())
                yv = y_.front();
            // FIXME flat extrapolation should be incoperated into interpolation
            // object, see above
            if (yv > y_.back())
                yv = y_.back();
            Real na = (*numeraire_[i - 1])(yv);
            Real nb = (*numeraire_[i])(yv);
            res[j] =
                inverseNormalization / ((tz - ta) / nb + (tb - tz) / na) * dt;
            // linear in reciprocal of normalized numeraire
        }

        return res;
    }

    Array MarkovFunctional::zerobondArray(const Time T, const Time t, const Array& y) const {

        return deflatedZerobondArray(T, t, y) * numeraireArray(t, y);
    }

    Array MarkovFunctional::deflatedZerobondArray(const Time T, const Time t, const Array& y) const {

        calculate();

        Array result(y.size(), 0.0);

        // Gauss Hermite

        Real stdDev_0_t = stateProcess_->stdDeviation(0.0, 0.0, t);
        // we use that the standard deviation is independent of $x$ here
        Real stdDev_0_T = stateProcess_->stdDeviation(0.0, 0.0, T);
        Real stdDev_t_T = stateProcess_->stdDeviation(t, 0.0, T - t);

        for (Size j = 0; j < y.size(); j++) {
            Array ya(modelSettings_.gaussHermitePoints_);
            for (Size i = 0; i < modelSettings_.gaussHermitePoints_; i++) {
                ya[i] = (y[j] * stdDev_0_t + stdDev_t_T * normalIntegralX_[i]) /
                        stdDev_0_T;
            }
            Array res = numeraireArray(T, ya);
            for (Size i = 0; i < modelSettings_.gaussHermitePoints_; i++) {
                result[j] += normalIntegralW_[i] / res[i];
            }
        }

        return result;
    }

    Real MarkovFunctional::numeraireImpl(
        const Time t, const Real y,
        const Handle<YieldTermStructure> &yts) const {

        if (t == 0)
            return yts.empty()
                       ? this->termStructure()->discount(numeraireTime(), true)
                       : yts->discount(numeraireTime());

        Array ya(1, y);
        return numeraireArray(t, ya)[0] *
               (yts.empty() ? Real(1.0)
                            : (yts->discount(numeraireTime()) /
                               yts->discount(t) * termStructure()->discount(t) /
                               termStructure()->discount(numeraireTime())));
    }

    Real
    MarkovFunctional::zerobondImpl(const Time T, const Time t, const Real y,
                                   const Handle<YieldTermStructure> &yts) const {

        if (t == 0.0)
            return yts.empty() ? this->termStructure()->discount(T, true)
                               : yts->discount(T, true);
        Array ya(1, y);
        return zerobondArray(T, t, ya)[0] *
               (yts.empty() ? Real(1.0) : (yts->discount(T) / yts->discount(t) *
                                     termStructure()->discount(t) /
                                     termStructure()->discount(T)));
    }

    Real MarkovFunctional::deflatedZerobond(Time T, Time t,
                                            Real y) const {

        Array ya(1, y);
        return deflatedZerobondArray(T, t, ya)[0];
    }

    Real MarkovFunctional::marketSwapRate(const Date &expiry,
                                          const CalibrationPoint &p,
                                          const Real digitalPrice,
                                          const Real guess,
                                          const Real shift) const {

        ZeroHelper z(this, expiry, p, digitalPrice);
        Brent b;
        Real solution = b.solve(
            z, modelSettings_.marketRateAccuracy_,
            std::max(std::min(guess, modelSettings_.upperRateBound_ - 0.00001),
                     modelSettings_.lowerRateBound_ - shift + 0.00001),
            modelSettings_.lowerRateBound_ - shift, modelSettings_.upperRateBound_);
        return solution;
    }

    Real MarkovFunctional::marketDigitalPrice(const Date &expiry,
                                              const CalibrationPoint &p,
                                              const Option::Type &type,
                                              const Real strike) const {

        return p.smileSection_->digitalOptionPrice(strike, type, p.annuity_,
                                                   modelSettings_.digitalGap_);
    }

    std::ostream &operator<<(std::ostream &out,
                             const MarkovFunctional::ModelOutputs &m) {
        out << "Markov functional model trace output " << std::endl;
        out << "Model settings" << std::endl;
        out << "Grid points y        : " << m.settings_.yGridPoints_
            << std::endl;
        out << "Std devs y           : " << m.settings_.yStdDevs_ << std::endl;
        out << "Lower rate bound     : " << m.settings_.lowerRateBound_
            << std::endl;
        out << "Upper rate bound     : " << m.settings_.upperRateBound_
            << std::endl;
        out << "Gauss Hermite points : " << m.settings_.gaussHermitePoints_
            << std::endl;
        out << "Digital gap          : " << m.settings_.digitalGap_
            << std::endl;
        out << "Adjustments          : "
            << ((m.settings_.adjustments_ & MarkovFunctional::ModelSettings::AdjustDigitals) != 0 ?
                    "Digitals " :
                    "")
            << ((m.settings_.adjustments_ & MarkovFunctional::ModelSettings::AdjustYts) != 0 ?
                    "Yts " :
                    "")
            << ((m.settings_.adjustments_ &
                 MarkovFunctional::ModelSettings::ExtrapolatePayoffFlat) != 0 ?
                    "FlatPayoffExt " :
                    "")
            << ((m.settings_.adjustments_ &
                 MarkovFunctional::ModelSettings::NoPayoffExtrapolation) != 0 ?
                    "NoPayoffExt " :
                    "")
            << ((m.settings_.adjustments_ & MarkovFunctional::ModelSettings::KahaleSmile) != 0 ?
                    "Kahale " :
                    "")
            << ((m.settings_.adjustments_ &
                 MarkovFunctional::ModelSettings::SmileExponentialExtrapolation) != 0 ?
                    "SmileExp " :
                    "")
            << ((m.settings_.adjustments_ & MarkovFunctional::ModelSettings::KahaleInterpolation) !=
                        0 ?
                    "KahaleInt " :
                    "")
            << ((m.settings_.adjustments_ &
                 MarkovFunctional::ModelSettings::SmileDeleteArbitragePoints) != 0 ?
                    "SmileDelArb " :
                    "")
            << ((m.settings_.adjustments_ & MarkovFunctional::ModelSettings::SabrSmile) != 0 ?
                    "Sabr" :
                    "")
            << std::endl;
        out << "Smile moneyness checkpoints: ";
        for (Size i = 0; i < m.settings_.smileMoneynessCheckpoints_.size(); i++)
            out << m.settings_.smileMoneynessCheckpoints_[i]
                << (i < m.settings_.smileMoneynessCheckpoints_.size() - 1 ? ";"
                                                                          : "");
        out << std::endl;

        QL_REQUIRE(!m.dirty_, "model outputs are dirty");

        if (m.expiries_.empty())
            return out; // no trace information was collected so no output
        out << std::endl;
        out << "Messages:" << std::endl;
        for (const auto& message : m.messages_)
            out << message << std::endl;
        out << std::endl << std::setprecision(16);
        out << "Yield termstructure fit:" << std::endl;
        out << "expiry;tenor;atm;annuity;digitalAdj;ytsAdj;marketzerorate;"
               "modelzerorate;diff(bp)" << std::endl;
        for (Size i = 0; i < m.expiries_.size(); i++) {
            out << m.expiries_[i] << ";" << m.tenors_[i] << ";" << m.atm_[i]
                << ";" << m.annuity_[i] << ";"
                << m.digitalsAdjustmentFactors_[i] << ";"
                << m.adjustmentFactors_[i] << ";" << m.marketZerorate_[i] << ";"
                << m.modelZerorate_[i] << ";"
                << (m.marketZerorate_[i] - m.modelZerorate_[i]) * 10000.0
                << std::endl;
        }
        out << std::endl;
        out << "Volatility smile fit:" << std::endl;
        for (Size i = 0; i < m.expiries_.size(); i++) {
            std::ostringstream os;
            os << m.expiries_[i] << "/" << m.tenors_[i];
            std::string p = os.str();
            out << "strike(" << p << ");marketCallRaw(" << p << ";marketCall("
                << p << ");modelCall(" << p << ");marketPutRaw(" << p
                << ");marketPut(" << p << ");modelPut(" << p << ");marketVega("
                << p << ")" << (i < m.expiries_.size() - 1 ? ";" : "");
        }
        out << std::endl;
        for (Size j = 0; j < m.smileStrikes_[0].size(); j++) {
            for (Size i = 0; i < m.expiries_.size(); i++) {
                out << m.smileStrikes_[i][j] << ";"
                    << m.marketRawCallPremium_[i][j] << ";"
                    << m.marketCallPremium_[i][j] << ";"
                    << m.modelCallPremium_[i][j] << ";"
                    << m.marketRawPutPremium_[i][j] << ";"
                    << m.marketPutPremium_[i][j] << ";"
                    << m.modelPutPremium_[i][j] << ";" << m.marketVega_[i][j]
                    << (i < m.expiries_.size() - 1 ? ";" : "");
            }
            out << std::endl;
        }
        return out;
    }

    Real MarkovFunctional::forwardRateInternal(
        const Date &fixing, const Date &referenceDate, const Real y,
        const bool zeroFixingDays, ext::shared_ptr<IborIndex> iborIdx) const {

        calculate();

        if (!iborIdx)
            iborIdx = iborIndex_;

        Date valueDate = zeroFixingDays ? fixing : iborIdx->valueDate(fixing);
        Date endDate = iborIdx->fixingCalendar().advance(
            iborIdx->valueDate(fixing), iborIdx->tenor(),
            iborIdx->businessDayConvention(),
            iborIdx->endOfMonth()); // FIXME Here we should use the calculation
                                    // date calendar ?
        Real dcf = iborIdx->dayCounter().yearFraction(valueDate, endDate);

        return (zerobond(valueDate, referenceDate, y) -
                zerobond(endDate, referenceDate, y)) /
               (dcf * zerobond(endDate, referenceDate, y));
    }

    Real
    MarkovFunctional::swapRateInternal(const Date &fixing, const Period &tenor,
                                       const Date &referenceDate, const Real y,
                                       bool zeroFixingDays,
                                       ext::shared_ptr<SwapIndex> swapIdx) const {

        calculate();

        if (!swapIdx)
            swapIdx = swapIndexBase_;
        QL_REQUIRE(swapIdx, "No swap index given");

        ext::shared_ptr<VanillaSwap> underlying = underlyingSwap(swapIdx, fixing, tenor);

        Schedule sched = underlying->fixedSchedule();
        Real annuity = swapAnnuityInternal(fixing, tenor, referenceDate, y,
                                      zeroFixingDays, swapIdx);
        Rate atm =
            (zerobond(zeroFixingDays ? fixing : sched.dates().front(),
                      referenceDate, y) -
             zerobond(sched.calendar().adjust(sched.dates().back(),
                                              underlying->paymentConvention()),
                      referenceDate, y)) /
            annuity;
        return atm;
    }

    Real MarkovFunctional::swapAnnuityInternal(
        const Date &fixing, const Period &tenor, const Date &referenceDate,
        const Real y, const bool zeroFixingDays,
        ext::shared_ptr<SwapIndex> swapIdx) const {

        calculate();

        if (!swapIdx)
            swapIdx = swapIndexBase_;
        QL_REQUIRE(swapIdx, "No swap index given");

        ext::shared_ptr<VanillaSwap> underlying = underlyingSwap(swapIdx, fixing, tenor);

        Schedule sched = underlying->fixedSchedule();

        Real annuity = 0.0;
        for (unsigned int j = 1; j < sched.size(); j++) {
            annuity +=
                zerobond(sched.calendar().adjust(
                             sched.date(j), underlying->paymentConvention()),
                         referenceDate, y) *
                swapIdx->dayCounter().yearFraction(
                    j == 1 && zeroFixingDays ? fixing : sched.date(j - 1),
                    sched.date(j));
        }
        return annuity;
    }

    Real MarkovFunctional::swaptionPriceInternal(const Option::Type& type,
                                                 const Date& expiry,
                                                 const Period& tenor,
                                                 const Rate strike,
                                                 const Date& referenceDate,
                                                 const Real y,
                                                 const bool zeroFixingDays,
                                                 const ext::shared_ptr<SwapIndex>& swapIdx) const {

        calculate();

        Time fixingTime = termStructure()->timeFromReference(expiry);
        Time referenceTime =
            referenceDate == Date()
                ? 0.0
                : termStructure()->timeFromReference(referenceDate);

        Array yg = yGrid(modelSettings_.yStdDevs_, modelSettings_.yGridPoints_,
                         fixingTime, referenceTime, y);
        Array z = yGrid(modelSettings_.yStdDevs_, modelSettings_.yGridPoints_);
        Array p(yg.size());

        for (Size i = 0; i < yg.size(); i++) {
            Real annuity = swapAnnuityInternal(expiry, tenor, expiry, yg[i],
                                          zeroFixingDays, swapIdx);
            Rate atm = swapRateInternal(expiry, tenor, expiry, yg[i], zeroFixingDays,
                                   swapIdx);
            p[i] = annuity * std::max((type == Option::Call ? 1.0 : -1.0) *
                                          (atm - strike),
                                      0.0) /
                   numeraire(fixingTime, yg[i]);
        }

        CubicInterpolation payoff(z.begin(), z.end(), p.begin(),
                                  CubicInterpolation::Spline, true,
                                  CubicInterpolation::Lagrange, 0.0,
                                  CubicInterpolation::Lagrange, 0.0);

        Real price = 0.0;
        for (Size i = 0; i < z.size() - 1; i++) {
            price += gaussianShiftedPolynomialIntegral(
                0.0, payoff.cCoefficients()[i], payoff.bCoefficients()[i],
                payoff.aCoefficients()[i], p[i], z[i], z[i], z[i + 1]);
        }
        if ((modelSettings_.adjustments_ &
             ModelSettings::NoPayoffExtrapolation) == 0) {
            if ((modelSettings_.adjustments_ &
                 ModelSettings::ExtrapolatePayoffFlat) != 0) {
                price += gaussianShiftedPolynomialIntegral(
                    0.0, 0.0, 0.0, 0.0, p[z.size() - 2], z[z.size() - 2],
                    z[z.size() - 1], 100.0);
                price += gaussianShiftedPolynomialIntegral(
                    0.0, 0.0, 0.0, 0.0, p[0], z[0], -100.0, z[0]);
            } else {
                if (type == Option::Call)
                    price += gaussianShiftedPolynomialIntegral(
                        0.0, payoff.cCoefficients()[z.size() - 2],
                        payoff.bCoefficients()[z.size() - 2],
                        payoff.aCoefficients()[z.size() - 2], p[z.size() - 2],
                        z[z.size() - 2], z[z.size() - 1], 100.0);
                if (type == Option::Put)
                    price += gaussianShiftedPolynomialIntegral(
                        0.0, payoff.cCoefficients()[0],
                        payoff.bCoefficients()[0], payoff.aCoefficients()[0],
                        p[0], z[0], -100.0, z[0]);
            }
        }

        return numeraire(referenceTime, y) * price;
    }

    Real MarkovFunctional::capletPriceInternal(
        const Option::Type &type, const Date &expiry, const Rate strike,
        const Date &referenceDate, const Real y, const bool zeroFixingDays,
        ext::shared_ptr<IborIndex> iborIdx) const {

        calculate();

        if (!iborIdx)
            iborIdx = iborIndex_;

        Time fixingTime = termStructure()->timeFromReference(expiry);
        Time referenceTime =
            referenceDate == Date()
                ? 0.0
                : termStructure()->timeFromReference(referenceDate);

        Array yg = yGrid(modelSettings_.yStdDevs_, modelSettings_.yGridPoints_,
                         fixingTime, referenceTime, y);
        Array z = yGrid(modelSettings_.yStdDevs_, modelSettings_.yGridPoints_);
        Array p(yg.size());

        Date valueDate = iborIdx->valueDate(expiry);
        Date endDate = iborIdx->fixingCalendar().advance(
            valueDate, iborIdx->tenor(), iborIdx->businessDayConvention(),
            iborIdx->endOfMonth()); // FIXME Here we should use the calculation
                                    // date calendar ?
        Real dcf = iborIdx->dayCounter().yearFraction(
            zeroFixingDays ? expiry : valueDate, endDate);

        for (Size i = 0; i < yg.size(); i++) {
            Real annuity = zerobond(endDate, expiry, yg[i]) * dcf;
            Rate atm =
                forwardRateInternal(expiry, expiry, yg[i], zeroFixingDays, iborIdx);
            p[i] = annuity * std::max((type == Option::Call ? 1.0 : -1.0) *
                                          (atm - strike),
                                      0.0) /
                   numeraire(fixingTime, yg[i]);
        }

        CubicInterpolation payoff(z.begin(), z.end(), p.begin(),
                                  CubicInterpolation::Spline, true,
                                  CubicInterpolation::Lagrange, 0.0,
                                  CubicInterpolation::Lagrange, 0.0);

        Real price = 0.0;
        for (Size i = 0; i < z.size() - 1; i++) {
            price += gaussianShiftedPolynomialIntegral(
                0.0, payoff.cCoefficients()[i], payoff.bCoefficients()[i],
                payoff.aCoefficients()[i], p[i], z[i], z[i], z[i + 1]);
        }
        if ((modelSettings_.adjustments_ &
             ModelSettings::NoPayoffExtrapolation) == 0) {
            if ((modelSettings_.adjustments_ &
                 ModelSettings::ExtrapolatePayoffFlat) != 0) {
                price += gaussianShiftedPolynomialIntegral(
                    0.0, 0.0, 0.0, 0.0, p[z.size() - 2], z[z.size() - 2],
                    z[z.size() - 1], 100.0);
                price += gaussianShiftedPolynomialIntegral(
                    0.0, 0.0, 0.0, 0.0, p[0], z[0], -100.0, z[0]);
            } else {
                if (type == Option::Call)
                    price += gaussianShiftedPolynomialIntegral(
                        0.0, payoff.cCoefficients()[z.size() - 2],
                        payoff.bCoefficients()[z.size() - 2],
                        payoff.aCoefficients()[z.size() - 2], p[z.size() - 2],
                        z[z.size() - 2], z[z.size() - 1], 100.0);
                if (type == Option::Put)
                    price += gaussianShiftedPolynomialIntegral(
                        0.0, payoff.cCoefficients()[0],
                        payoff.bCoefficients()[0], payoff.aCoefficients()[0],
                        p[0], z[0], -100.0, z[0]);
            }
        }

        return numeraire(referenceTime, y) * price;
    }
}
]]></document_content>
  </document>
  <document index="117">
    <source>shortrate/onefactormodels/vasicek.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/shortrate/onefactormodels/vasicek.hpp>
#include <ql/pricingengines/blackformula.hpp>

namespace QuantLib {

    Vasicek::Vasicek(Rate r0, Real a, Real b, Real sigma, Real lambda)
    : OneFactorAffineModel(4), r0_(r0),
      a_(arguments_[0]), b_(arguments_[1]), sigma_(arguments_[2]),
      lambda_(arguments_[3]) {
        a_ = ConstantParameter(a, PositiveConstraint());
        b_ = ConstantParameter(b, NoConstraint());
        sigma_ = ConstantParameter(sigma, PositiveConstraint());
        lambda_ = ConstantParameter(lambda, NoConstraint());
    }

    Real Vasicek::A(Time t, Time T) const {
        Real _a = a();
        if (_a < std::sqrt(QL_EPSILON)) {
            return 0.0;
        } else {
            Real sigma2 = sigma()*sigma();
            Real bt = B(t, T);
            return std::exp((b() + lambda()*sigma()/_a
                             - 0.5*sigma2/(_a*_a))*(bt - (T - t))
                             - 0.25*sigma2*bt*bt/_a);
        }
    }

    Real Vasicek::B(Time t, Time T) const {
        Real _a = a();
        if (_a < std::sqrt(QL_EPSILON))
            return (T - t);
        else
            return (1.0 - std::exp(-_a*(T - t)))/_a;
    }

    Real Vasicek::discountBondOption(Option::Type type,
                                     Real strike, Time maturity,
                                     Time bondMaturity) const {

        Real v;
        Real _a = a();
        if (std::fabs(maturity) < QL_EPSILON) {
            v = 0.0;
        } else if (_a < std::sqrt(QL_EPSILON)) {
            v = sigma()*B(maturity, bondMaturity)* std::sqrt(maturity);
        } else {
            v = sigma()*B(maturity, bondMaturity)*
                std::sqrt(0.5*(1.0 - std::exp(-2.0*_a*maturity))/_a);
        }
        Real f = discountBond(0.0, bondMaturity, r0_);
        Real k = discountBond(0.0, maturity, r0_)*strike;

        return blackFormula(type, k, f, v);
    }

}

]]></document_content>
  </document>
  <document index="118">
    <source>shortrate/twofactormodel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/shortrate/twofactormodel.hpp>
#include <ql/processes/stochasticprocessarray.hpp>

namespace QuantLib {

    TwoFactorModel::TwoFactorModel(Size nArguments)
    : ShortRateModel(nArguments) {}

    ext::shared_ptr<Lattice>
    TwoFactorModel::tree(const TimeGrid& grid) const {
        ext::shared_ptr<ShortRateDynamics> dyn = dynamics();

        ext::shared_ptr<TrinomialTree> tree1(
                                    new TrinomialTree(dyn->xProcess(), grid));
        ext::shared_ptr<TrinomialTree> tree2(
                                    new TrinomialTree(dyn->yProcess(), grid));

        return ext::shared_ptr<Lattice>(
                        new TwoFactorModel::ShortRateTree(tree1, tree2, dyn));
    }

    TwoFactorModel::ShortRateTree::ShortRateTree(
                         const ext::shared_ptr<TrinomialTree>& tree1,
                         const ext::shared_ptr<TrinomialTree>& tree2,
                         const ext::shared_ptr<ShortRateDynamics>& dynamics)
    : TreeLattice2D<TwoFactorModel::ShortRateTree,TrinomialTree>(
                                       tree1, tree2, dynamics->correlation()),
      dynamics_(dynamics) {}

    ext::shared_ptr<StochasticProcess>
    TwoFactorModel::ShortRateDynamics::process() const {
        Matrix correlation(2,2);
        correlation[0][0] = correlation[1][1] = 1.0;
        correlation[0][1] = correlation[1][0] = correlation_;
        std::vector<ext::shared_ptr<StochasticProcess1D> > processes(2);
        processes[0] = xProcess_;
        processes[1] = yProcess_;
        return ext::shared_ptr<StochasticProcess>(
                           new StochasticProcessArray(processes,correlation));
    }

}
]]></document_content>
  </document>
  <document index="119">
    <source>shortrate/twofactormodels/g2.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004 Mike Parker
 Copyright (C) 2021 Magnus Mencke

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/integrals/segmentintegral.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/models/shortrate/twofactormodels/g2.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <utility>

namespace QuantLib {

    G2::G2(const Handle<YieldTermStructure>& termStructure,
           Real a, Real sigma, Real b, Real eta, Real rho)
    : TwoFactorModel(5), TermStructureConsistentModel(termStructure),
      a_(arguments_[0]), sigma_(arguments_[1]), b_(arguments_[2]),
      eta_(arguments_[3]), rho_(arguments_[4]) {

        a_     = ConstantParameter(a,     PositiveConstraint());
        sigma_ = ConstantParameter(sigma, PositiveConstraint());
        b_     = ConstantParameter(b,     PositiveConstraint());
        eta_   = ConstantParameter(eta,   PositiveConstraint());
        rho_   = ConstantParameter(rho,   BoundaryConstraint(-1.0, 1.0));

        G2::generateArguments();

        registerWith(termStructure);
    }

    ext::shared_ptr<TwoFactorModel::ShortRateDynamics> G2::dynamics() const {
        return ext::shared_ptr<ShortRateDynamics>(new
            Dynamics(phi_, a(), sigma(), b(), eta(), rho()));
    }

    void G2::generateArguments() {

        phi_ = FittingParameter(termStructure(),
            a(), sigma(), b(), eta(), rho());
    }

    Real G2::sigmaP(Time t, Time s) const {
        Real temp = 1.0 - std::exp(-(a()+b())*t);
        Real temp1 = 1.0 - std::exp(-a()*(s-t));
        Real temp2 = 1.0 - std::exp(-b()*(s-t));
        Real a3 = a()*a()*a();
        Real b3 = b()*b()*b();
        Real sigma2 = sigma()*sigma();
        Real eta2 = eta()*eta();
        Real value =
            0.5*sigma2*temp1*temp1*(1.0 - std::exp(-2.0*a()*t))/a3 +
            0.5*eta2*temp2*temp2*(1.0 - std::exp(-2.0*b()*t))/b3 +
            2.0*rho()*sigma()*eta()/(a()*b()*(a()+b()))*
            temp1*temp2*temp;
        return std::sqrt(value);
    }

    Real G2::discountBond(Time t, Time T, Real x, Real y) const {
        return A(t,T) * std::exp(-B(a(),(T-t))*x-B(b(),(T-t))*y);
    }

    Real G2::discountBondOption(Option::Type type, Real strike, Time maturity,
        Time bondMaturity) const {

        Real v = sigmaP(maturity, bondMaturity);
        Real f = termStructure()->discount(bondMaturity);
        Real k = termStructure()->discount(maturity)*strike;

        return blackFormula(type, k, f, v);
    }

    Real G2::V(Time t) const {
        Real expat = std::exp(-a()*t);
        Real expbt = std::exp(-b()*t);
        Real cx = sigma()/a();
        Real cy = eta()/b();
        Real valuex = cx*cx*(t + (2.0*expat-0.5*expat*expat-1.5)/a());
        Real valuey = cy*cy*(t + (2.0*expbt-0.5*expbt*expbt-1.5)/b());
        Real value = 2.0*rho()*cx*cy* (t + (expat - 1.0)/a()
                                         + (expbt - 1.0)/b()
                                         - (expat*expbt-1.0)/(a()+b()));
        return valuex + valuey + value;
    }

    Real G2::A(Time t, Time T) const {
        return termStructure()->discount(T)/termStructure()->discount(t)*
            std::exp(0.5*(V(T-t) - V(T) + V(t)));
    }

    Real G2::B(Real x, Time t) const {
        return (1.0 - std::exp(-x*t))/x;
    }

    class G2::SwaptionPricingFunction {
      public:
        SwaptionPricingFunction(Real a,
                                Real sigma,
                                Real b,
                                Real eta,
                                Real rho,
                                Real w,
                                Real start,
                                std::vector<Time> payTimes,
                                Rate fixedRate,
                                const G2& model)
        : a_(a), sigma_(sigma), b_(b), eta_(eta), rho_(rho), w_(w), T_(start),
          t_(std::move(payTimes)), rate_(fixedRate), size_(t_.size()), A_(size_), Ba_(size_),
          Bb_(size_) {


            sigmax_ = sigma_*std::sqrt(0.5*(1.0-std::exp(-2.0*a_*T_))/a_);
            sigmay_ =   eta_*std::sqrt(0.5*(1.0-std::exp(-2.0*b_*T_))/b_);
            rhoxy_ = rho_*eta_*sigma_*(1.0 - std::exp(-(a_+b_)*T_))/
                ((a_+b_)*sigmax_*sigmay_);

            Real temp = sigma_*sigma_/(a_*a_);
            mux_ = -((temp+rho_*sigma_*eta_/(a_*b_))*(1.0 - std::exp(-a*T_)) -
                     0.5*temp*(1.0 - std::exp(-2.0*a_*T_)) -
                     rho_*sigma_*eta_/(b_*(a_+b_))*
                     (1.0- std::exp(-(b_+a_)*T_)));

            temp = eta_*eta_/(b_*b_);
            muy_ = -((temp+rho_*sigma_*eta_/(a_*b_))*(1.0 - std::exp(-b*T_)) -
                     0.5*temp*(1.0 - std::exp(-2.0*b_*T_)) -
                     rho_*sigma_*eta_/(a_*(a_+b_))*
                     (1.0- std::exp(-(b_+a_)*T_)));

            for (Size i=0; i<size_; i++) {
                A_[i] = model.A(T_, t_[i]);
                Ba_[i] = model.B(a_, t_[i]-T_);
                Bb_[i] = model.B(b_, t_[i]-T_);
            }
        }

        Real mux() const { return mux_; }
        Real sigmax() const { return sigmax_; }
        Real operator()(Real x) const {
            CumulativeNormalDistribution phi;
            Real temp = (x - mux_)/sigmax_;
            Real txy = std::sqrt(1.0 - rhoxy_*rhoxy_);

            Array lambda(size_);
            Size i;
            for (i=0; i<size_; i++) {
                Real tau = (i==0 ? t_[0] - T_ : t_[i] - t_[i-1]);
                Real c = (i==size_-1 ? Real(1.0+rate_*tau) : rate_*tau);
                lambda[i] = c*A_[i]*std::exp(-Ba_[i]*x);
            }

            SolvingFunction function(lambda, Bb_) ;
            Brent s1d;
            s1d.setMaxEvaluations(1000);
            Real searchBound = std::max(10.0*sigmay_, 1.0);
            Real yb = s1d.solve(function, 1e-6, 0.00, -searchBound, searchBound);

            Real h1 = (yb - muy_)/(sigmay_*txy) -
                rhoxy_*(x  - mux_)/(sigmax_*txy);
            Real value = phi(-w_*h1);


            for (i=0; i<size_; i++) {
                Real h2 = h1 +
                    Bb_[i]*sigmay_*std::sqrt(1.0-rhoxy_*rhoxy_);
                Real kappa = - Bb_[i] *
                    (muy_ - 0.5*txy*txy*sigmay_*sigmay_*Bb_[i] +
                     rhoxy_*sigmay_*(x-mux_)/sigmax_);
                value -= lambda[i] *std::exp(kappa)*phi(-w_*h2);
            }

            return std::exp(-0.5*temp*temp)*value/
                (sigmax_*std::sqrt(2.0*M_PI));
        }


      private:
        class SolvingFunction {
          public:
            SolvingFunction(const Array& lambda, const Array& Bb)
            : lambda_(lambda), Bb_(Bb) {}
            Real operator()(Real y) const {
                Real value = 1.0;
                for (Size i=0; i<lambda_.size(); i++) {
                    value -= lambda_[i]*std::exp(-Bb_[i]*y);
                }
                return value;
            }
          private:
            const Array& lambda_;
            const Array& Bb_;
        };

        Real a_, sigma_, b_, eta_, rho_, w_;
        Time T_;
        std::vector<Time> t_;
        Rate rate_;
        Size size_;
        Array A_, Ba_, Bb_;
        Real mux_, muy_, sigmax_, sigmay_, rhoxy_;
    };

    Real G2::swaption(const Swaption::arguments& arguments,
                      Rate fixedRate, Real range, Size intervals) const {

        QL_REQUIRE(arguments.nominal != Null<Real>(),
                   "non-constant nominals are not supported yet");

        Date settlement = termStructure()->referenceDate();
        DayCounter dayCounter = termStructure()->dayCounter();
        Time start = dayCounter.yearFraction(settlement,
                                             arguments.floatingResetDates[0]);
        Real w = (arguments.type==Swap::Payer ? 1 : -1 );

        std::vector<Time> fixedPayTimes(arguments.fixedPayDates.size());
        for (Size i=0; i<fixedPayTimes.size(); ++i)
            fixedPayTimes[i] =
                dayCounter.yearFraction(settlement,
                                        arguments.fixedPayDates[i]);

        SwaptionPricingFunction function(a(), sigma(), b(), eta(), rho(),
                                         w, start,
                                         fixedPayTimes,
                                         fixedRate, (*this));

        Real upper = function.mux() + range*function.sigmax();
        Real lower = function.mux() - range*function.sigmax();
        SegmentIntegral integrator(intervals);
        return arguments.nominal * w * termStructure()->discount(start) *
            integrator(function, lower, upper);
    }

}
]]></document_content>
  </document>
  <document index="120">
    <source>volatility/constantestimator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/models/volatility/constantestimator.hpp>

namespace QuantLib {
    TimeSeries<Volatility>
    ConstantEstimator::calculate(const TimeSeries<Volatility>& volatilitySeries) {
        TimeSeries<Volatility> retval;
        const std::vector<Volatility> u = volatilitySeries.values();
        TimeSeries<Volatility>::const_iterator prev, next, cur, start;
        cur = volatilitySeries.begin();
        std::advance(cur, size_);
        // ICK.  This could probably be made a lot more efficient
        for (Size i=size_; i < volatilitySeries.size(); i++) {
            Size j;
            Real sumu2=0.0, sumu=0.0;
            for (j=i-size_; j <i; j++) {
                sumu += u[j];
                sumu2 += u[j]*u[j];
            }
            Real s = std::sqrt(sumu2/(Real)size_ - sumu*sumu / (Real) size_ /
                               (Real) (size_+1));
            retval[cur->first] = s;
            ++cur;
        }
        return retval;
    }

}

]]></document_content>
  </document>
  <document index="121">
    <source>volatility/garch.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Joseph Wang
 Copyright (C) 2012 Liquidnet Holdings, Inc.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/autocovariance.hpp>
#include <ql/math/optimization/leastsquare.hpp>
#include <ql/math/optimization/simplex.hpp>
#include <ql/models/volatility/garch.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        const Real tol_level = 1.0e-8;

        class Garch11Constraint : public Constraint {
          private:
            class Impl final : public Constraint::Impl {
                Real gammaLower_, gammaUpper_;
              public:
                Impl (Real gammaLower, Real gammaUpper)
                : gammaLower_(gammaLower), gammaUpper_(gammaUpper) {}
                bool test(const Array& x) const override {
                    QL_REQUIRE(x.size() >= 3, "size of parameters vector < 3");
                    return x[0] > 0 && x[1] >= 0 && x[2] >= 0
                        && x[1] + x[2] < gammaUpper_
                        && x[1] + x[2] >= gammaLower_;
                }
            };
          public:
            Garch11Constraint(Real gammaLower, Real gammaUpper)
            : Constraint(ext::shared_ptr<Constraint::Impl>(
                      new Garch11Constraint::Impl(gammaLower, gammaUpper))) {}
        };


        class Garch11CostFunction : public CostFunction {
          public:
            explicit Garch11CostFunction (const std::vector<Volatility> &);
            Real value(const Array& x) const override;
            Array values(const Array& x) const override;
            void gradient(Array& grad, const Array& x) const override;
            Real valueAndGradient(Array& grad, const Array& x) const override;

          private:
            const std::vector<Volatility> &r2_;
        };

        Garch11CostFunction::Garch11CostFunction(
                                            const std::vector<Volatility> &r2)
        : r2_(r2) {}

        Real Garch11CostFunction::value(const Array& x) const {
            Real retval(0.0);
            Real sigma2 = 0;
            Real u2 = 0;
            for (auto r2 : r2_) {
                sigma2 = x[0] + x[1] * u2 + x[2] * sigma2;
                u2 = r2;
                retval += std::log(sigma2) + u2 / sigma2;
            }
            return retval / (2.0*r2_.size());
        }

        Array Garch11CostFunction::values(const Array& x) const {
            Array retval (r2_.size());
            Real sigma2 = 0;
            Real u2 = 0;
            Size i = 0;
            for (auto r2 : r2_) {
                sigma2 = x[0] + x[1] * u2 + x[2] * sigma2;
                u2 = r2;
                retval[i++] = (std::log(sigma2) + u2 / sigma2)/(2.0*r2_.size());
            }
            return retval;
        }

        void Garch11CostFunction::gradient(Array& grad, const Array& x) const {
            std::fill (grad.begin(), grad.end(), 0.0);
            Real sigma2 = 0;
            Real u2 = 0;
            Real sigma2prev = sigma2;
            Real u2prev = u2;
            Real norm = 2.0 * r2_.size();
            for (auto r2 : r2_) {
                sigma2 = x[0] + x[1] * u2 + x[2] * sigma2;
                u2 = r2;
                Real w = (sigma2 - u2) / (sigma2*sigma2);
                grad[0] += w;
                grad[1] += u2prev * w;
                grad[2] += sigma2prev * w;
                u2prev = u2;
                sigma2prev = sigma2;
            }
            std::transform(grad.begin(), grad.end(), grad.begin(),
                           [=](Real x) -> Real { return x / norm; });
        }

        Real Garch11CostFunction::valueAndGradient(Array& grad,
                                                   const Array& x) const {
            std::fill (grad.begin(), grad.end(), 0.0);
            Real retval(0.0);
            Real sigma2 = 0;
            Real u2 = 0;
            Real sigma2prev = sigma2;
            Real u2prev = u2;
            Real norm = 2.0 * r2_.size();
            for (auto r2 : r2_) {
                sigma2 = x[0] + x[1] * u2 + x[2] * sigma2;
                u2 = r2;
                retval += std::log(sigma2) + u2 / sigma2;
                Real w = (sigma2 - u2) / (sigma2*sigma2);
                grad[0] += w;
                grad[1] += u2prev * w;
                grad[2] += sigma2prev * w;
                u2prev = u2;
                sigma2prev = sigma2;
            }
            std::transform(grad.begin(), grad.end(), grad.begin(),
                           [=](Real x) -> Real { return x / norm; });
            return retval / norm;
        }


        class FitAcfProblem : public LeastSquareProblem {
          public:
            FitAcfProblem(Real A2, Array acf, std::vector<std::size_t> idx);
            Size size() override;
            void targetAndValue(const Array& x, Array& target, Array& fct2fit) override;
            void targetValueAndGradient(const Array& x,
                                        Matrix& grad_fct2fit,
                                        Array& target,
                                        Array& fct2fit) override;

          private:
            Real A2_;
            Array acf_;
            std::vector<std::size_t> idx_;
        };

        FitAcfProblem::FitAcfProblem(Real A2, Array acf, std::vector<std::size_t> idx)
        : A2_(A2), acf_(std::move(acf)), idx_(std::move(idx)) {}

        Size FitAcfProblem::size() { return idx_.size(); }

        void FitAcfProblem::targetAndValue(const Array& x, Array& target,
                                           Array& fct2fit) {
            Real A4 = acf_[0] + A2_*A2_;
            Real gamma = x[0];
            Real beta = x[1];
            target[0] = A2_*A2_/A4;
            fct2fit[0] =
                (1 - 3*gamma*gamma - 2*beta*beta + 4*beta*gamma)
                / (3*(1 - gamma*gamma));
            target[1] = acf_[1] / A4;
            fct2fit[1] = gamma * (1 - fct2fit[0]) - beta;
            for (std::size_t i = 2; i < idx_.size(); ++i) {
                target[i] = acf_[idx_[i]] / A4;
                fct2fit[i] = std::pow(gamma, (int)idx_[i]-1)* fct2fit[1];
            }
        }

        void FitAcfProblem::targetValueAndGradient(const Array& x,
                                                   Matrix& grad_fct2fit,
                                                   Array& target,
                                                   Array& fct2fit) {
            Real A4 = acf_[0] + A2_*A2_;
            Real gamma = x[0];
            Real beta = x[1];
            target[0] = A2_*A2_/A4;
            Real w1 = (1 - 3*gamma*gamma - 2*beta*beta + 4*beta*gamma);
            Real w2 = (1 - gamma*gamma);
            fct2fit[0] = w1 / (3*w2);
            grad_fct2fit[0][0] = (2.0/3.0) * ((2*beta-3*gamma)*w2 + 2*w1*gamma) / (w2*w2);
            grad_fct2fit[0][1] = (4.0/3.0) * (gamma - beta) / w2;
            target[1] = acf_[1] / A4;
            fct2fit[1] = gamma * (1 - fct2fit[0]) - beta;
            grad_fct2fit[1][0] = (1 - fct2fit[0]) - gamma * grad_fct2fit[0][0];
            grad_fct2fit[1][1] = -gamma * grad_fct2fit[0][1] - 1;
            for (std::size_t i = 2; i < idx_.size(); ++i) {
                target[i] = acf_[idx_[i]] / A4;
                w1 = std::pow(gamma, (int)idx_[i]-1);
                fct2fit[i] = w1 * fct2fit[1];
                grad_fct2fit[i][0] = (idx_[i]-1) * (w1/gamma)*fct2fit[1] + w1*grad_fct2fit[1][0];
                grad_fct2fit[i][1] = w1 * grad_fct2fit[1][1];
            }
        }


        class FitAcfConstraint : public Constraint {
          private:
            class Impl final : public Constraint::Impl {
                Real gammaLower_, gammaUpper_;
              public:
                Impl(Real gammaLower, Real gammaUpper)
                : gammaLower_(gammaLower), gammaUpper_(gammaUpper) {}
                bool test(const Array& x) const override {
                    QL_REQUIRE(x.size() >= 2, "size of parameters vector < 2");
                    return x[0] >= gammaLower_ && x[0] < gammaUpper_
                        && x[1] >= 0 && x[1] <= x[0];
                }
            };
          public:
            FitAcfConstraint(Real gammaLower, Real gammaUpper)
            : Constraint(ext::shared_ptr<Constraint::Impl>(
                       new FitAcfConstraint::Impl(gammaLower, gammaUpper))) {}
        };


        // Initial guess based on fitting ACF - initial guess for
        // fitting acf is a moment matching estimates for mean(r2),
        // acf(0), and acf(1).
        Real initialGuess1(const Array &acf, Real mean_r2,
                           Real &alpha, Real &beta, Real &omega) {
            Real A21 = acf[1];
            Real A4 = acf[0] + mean_r2*mean_r2;

            Real A = mean_r2*mean_r2/A4; // 1/sigma^2
            Real B = A21 / A4; // rho(1)

            Real gammaLower = A <= 1./3. - tol_level ? std::sqrt((1 - 3*A)/(3 - 3*A)) + tol_level : Real(tol_level);
            Garch11Constraint constraints(gammaLower, 1.0 - tol_level);

            Real gamma = gammaLower + (1 - gammaLower) * 0.5;
            beta = std::min(gamma, std::max(gamma * (1 - A) - B, 0.0));
            alpha = gamma - beta;
            omega = mean_r2 * (1 - gamma);

            if (std::fabs(A-0.5) < QL_EPSILON) {
                gamma = std::max(gammaLower, -(1+4*B*B)/(4*B));
                beta = std::min(gamma, std::max(gamma * (1 - A) - B, 0.0));
                alpha = gamma - beta;
                omega = mean_r2 * (1 - gamma);
            } else {
                if (A > 1.0 - QL_EPSILON) {
                    gamma = std::max(gammaLower, -(1+B*B)/(2*B));
                    beta = std::min(gamma, std::max(gamma * (1 - A) - B, 0.0));
                    alpha = gamma - beta;
                    omega = mean_r2 * (1 - gamma);
                } else {
                    Real D = (3*A-1)*(2*B*B+(1-A)*(2*A-1));
                    if (D >= 0) {
                        Real d = std::sqrt(D);
                        Real b = (B - d)/(2*A-1);
                        Real g = 0;
                        if (b >= tol_level && b <= 1.0 - tol_level) {
                            g = (b + B) / (1 - A);
                        }
                        if (g < gammaLower) {
                            b = (B + d)/(2*A-1);
                            if (b >= tol_level && b <= 1.0 - tol_level) {
                                g = (b + B) / (1 - A);
                            }
                        }
                        if (g >= gammaLower) {
                            gamma = g;
                            beta = std::min(gamma, std::max(gamma * (1 - A) - B, 0.0));
                            alpha = gamma - beta;
                            omega = mean_r2 * (1 - gamma);
                        }
                    }
                }
            }

            std::vector<std::size_t> idx;
            std::size_t nCov = acf.size() - 1;
            for (std::size_t i = 0; i <= nCov; ++i) {
                if (i < 2 || (acf[i] > 0 && acf[i-1] > 0 && acf[i-1] > acf[i])) {
                    idx.push_back(i);
                }
            }

            Array x(2);
            x[0] = gamma;
            x[1] = beta;

            try {
                FitAcfConstraint c(gammaLower, 1.0 - tol_level);
                NonLinearLeastSquare nnls(c);
                nnls.setInitialValue(x);
                FitAcfProblem pr(mean_r2, acf, idx);
                x = nnls.perform(pr);
                Array guess(3);
                guess[0] = mean_r2 * (1 - x[0]);
                guess[1] = x[0] - x[1];
                guess[2] = x[1];
                if (constraints.test(guess)) {
                    omega = guess[0];
                    alpha = guess[1];
                    beta = guess[2];
                }
            } catch (const std::exception &) {
                // failed -- returning initial values
            }
            return gammaLower;
        }

        // Initial guess based on fitting ACF - initial guess for
        // fitting acf is an estimate of gamma = alpfa+beta based on
        // the property: acf(i+1) = gamma*acf(i) for i > 1.
        Real initialGuess2 (const Array &acf, Real mean_r2,
                            Real &alpha, Real &beta, Real &omega) {
            Real A21 = acf[1];
            Real A4 = acf[0] + mean_r2*mean_r2;
            Real A = mean_r2*mean_r2/A4; // 1/sigma^2
            Real B = A21 / A4; // rho(1)
            Real gammaLower = A <= 1./3. - tol_level ? std::sqrt((1 - 3*A)/(3 - 3*A)) + tol_level : Real(tol_level);
            Garch11Constraint constraints(gammaLower, 1.0 - tol_level);

            // ACF
            Real gamma = 0;
            std::size_t nn = 0;
            std::vector<std::size_t> idx;
            std::size_t nCov = acf.size() - 1;
            for (std::size_t i = 0; i <= nCov; ++i) {
                if (i < 2) idx.push_back(i);
                if (i > 1 && acf[i] > 0 && acf[i-1] > 0 && acf[i-1] > acf[i]) {
                    gamma += acf[i]/acf[i-1];
                    nn++;
                    idx.push_back(i);
                }
            }
            if (nn > 0)
                gamma /= nn;
            if (gamma < gammaLower) gamma = gammaLower;
            beta = std::min(gamma, std::max(gamma * (1 - A) - B, 0.0));
            omega = mean_r2 * (1 - gamma);

            Array x(2);
            x[0] = gamma;
            x[1] = beta;

            try {
                FitAcfConstraint c(gammaLower, 1 - tol_level);
                NonLinearLeastSquare nnls(c);
                nnls.setInitialValue(x);
                FitAcfProblem pr(mean_r2, acf, idx);
                x = nnls.perform(pr);
                Array guess(3);
                guess[0] = mean_r2 * (1 - x[0]);
                guess[1] = x[0] - x[1];
                guess[2] = x[1];
                if (constraints.test(guess)) {
                    omega = guess[0];
                    alpha = guess[1];
                    beta = guess[2];
                }
            } catch (const std::exception &) {
                // failed -- returning initial values
            }
            return gammaLower;
        }

    }

    Garch11::time_series
    Garch11::calculate(const time_series& quoteSeries,
                       Real alpha, Real beta, Real omega) {
        time_series retval;
        auto cur = quoteSeries.cbegin();
        Real u = cur->second;
        Real sigma2 = u*u;
        while (++cur != quoteSeries.end()) {
            sigma2 = omega + alpha * u * u + beta * sigma2;
            retval[cur->first] = std::sqrt(sigma2);
            u = cur->second;
        }
        sigma2 = omega + alpha * u * u + beta * sigma2;
        --cur;
        auto prev = cur;
        retval[cur->first + (cur->first - (--prev)->first) ] = std::sqrt(sigma2);
        return retval;
    }


    ext::shared_ptr<Problem> Garch11::calibrate_r2(
                   Mode mode, const std::vector<Volatility> &r2, Real mean_r2,
                   Real &alpha, Real &beta, Real &omega) {
        EndCriteria endCriteria(10000, 500, tol_level, tol_level, tol_level);
        Simplex method(0.001);
        return calibrate_r2(mode, r2, mean_r2, method, endCriteria,
                            alpha, beta, omega);
    }

    ext::shared_ptr<Problem> Garch11::calibrate_r2(
                   Mode mode, const std::vector<Volatility> &r2, Real mean_r2,
                   OptimizationMethod &method, const EndCriteria &endCriteria,
                   Real &alpha, Real &beta, Real &omega) {
        Real dataSize = Real(r2.size());
        alpha = 0.0;
        beta = 0.0;
        omega = 0.0;
        QL_REQUIRE (dataSize >= 4,
                    "Data series is too short to fit GARCH model");
        QL_REQUIRE (mean_r2 > 0, "Data series is constant");
        omega = mean_r2 * dataSize / (dataSize - 1);

        // ACF
        Size maxLag = (Size)std::sqrt(dataSize);
        Array acf(maxLag+1);
        std::vector<Volatility> tmp(r2.size());
        std::transform (r2.begin(), r2.end(), tmp.begin(),
                       [=](Real x) -> Real { return x - mean_r2; });
        autocovariances (tmp.begin(), tmp.end(), acf.begin(), maxLag);
        QL_REQUIRE (acf[0] > 0, "Data series is constant");

        Garch11CostFunction cost (r2);

        // two initial guesses based on fitting ACF
        Real gammaLower = 0.0;
        Array opt1(3);
        Real fCost1 = QL_MAX_REAL;
        if (mode != GammaGuess) {
            gammaLower = initialGuess1(acf, mean_r2, opt1[1], opt1[2], opt1[0]);
            fCost1 = cost.value(opt1);
        }

        Array opt2(3);
        Real fCost2 = QL_MAX_REAL;
        if (mode != MomentMatchingGuess) {
            gammaLower = initialGuess2(acf, mean_r2, opt2[1], opt2[2], opt2[0]);
            fCost2 = cost.value(opt2);
        }

        Garch11Constraint constraints(gammaLower, 1.0 - tol_level);

        ext::shared_ptr<Problem> ret;
        if (mode != DoubleOptimization) {
            try {
                ret = calibrate_r2(r2, method, constraints, endCriteria,
                                   fCost1 <= fCost2 ? opt1 : opt2,
                                   alpha, beta, omega);
            } catch (const std::exception &) {
                if (fCost1 <= fCost2) {
                    alpha = opt1[1];
                    beta = opt1[2];
                    omega = opt1[0];
                } else {
                    alpha = opt2[1];
                    beta = opt2[2];
                    omega = opt2[0];
                }
            }
        } else {
            ext::shared_ptr<Problem> ret1, ret2;
            try {
                ret1 = calibrate_r2(r2, method, constraints, endCriteria,
                                    opt1, alpha, beta, omega);
                opt1[1] = alpha;
                opt1[2] = beta;
                opt1[0] = omega;
                if (constraints.test(opt1))
                    fCost1 = std::min(fCost1, cost.value(opt1));
            } catch (const std::exception &) {
                fCost1 = QL_MAX_REAL;
            }

            try {
                ret2 = calibrate_r2(r2, method, constraints, endCriteria,
                                    opt2, alpha, beta, omega);
                opt2[1] = alpha;
                opt2[2] = beta;
                opt2[0] = omega;
                if (constraints.test(opt2))
                    fCost2 = std::min(fCost2, cost.value(opt2));
            } catch (const std::exception &) {
                fCost2 = QL_MAX_REAL;
            }

            if (fCost1 <= fCost2) {
                alpha = opt1[1];
                beta = opt1[2];
                omega = opt1[0];
                ret = ret1;
            } else {
                alpha = opt2[1];
                beta = opt2[2];
                omega = opt2[0];
                ret = ret2;
            }
        }
        return ret;
    }

    ext::shared_ptr<Problem> Garch11::calibrate_r2(
               const std::vector<Volatility> &r2,
               OptimizationMethod &method,
               const EndCriteria &endCriteria,
               const Array &initGuess, Real &alpha, Real &beta, Real &omega) {
        Garch11Constraint constraints(0.0, 1.0 - tol_level);
        return calibrate_r2(r2, method, constraints, endCriteria,
                            initGuess, alpha, beta, omega);
    }

    ext::shared_ptr<Problem> Garch11::calibrate_r2(
               const std::vector<Volatility> &r2,
               Real mean_r2,
               OptimizationMethod &method,
               const EndCriteria &endCriteria,
               const Array &initGuess, Real &alpha, Real &beta, Real &omega) {
        std::vector<Volatility> tmp(r2.size());
        std::transform(r2.begin(), r2.end(), tmp.begin(),
                       [=](Real x) -> Real { return x - mean_r2; });
        return calibrate_r2(tmp, method, endCriteria, initGuess,
                            alpha, beta, omega);
    }

    ext::shared_ptr<Problem> Garch11::calibrate_r2(
               const std::vector<Volatility> &r2,
               OptimizationMethod &method,
               Constraint &constraints,
               const EndCriteria &endCriteria,
               const Array &initGuess, Real &alpha, Real &beta, Real &omega) {
        Garch11CostFunction cost(r2);
        ext::shared_ptr<Problem> problem(
                               new Problem(cost, constraints, initGuess));
        // TODO: check return value from minimize()
        /* EndCriteria::Type ret = */
        method.minimize(*problem, endCriteria);
        const Array &optimum = problem->currentValue();
        alpha = optimum[1];
        beta = optimum[2];
        omega = optimum[0];
        return problem;
    }

    ext::shared_ptr<Problem> Garch11::calibrate_r2(
               const std::vector<Volatility> &r2,
               Real mean_r2,
               OptimizationMethod &method,
               Constraint &constraints,
               const EndCriteria &endCriteria,
               const Array &initGuess, Real &alpha, Real &beta, Real &omega) {
        std::vector<Volatility> tmp(r2.size());
        std::transform(r2.begin(), r2.end(), tmp.begin(),
                       [=](Real x) -> Real { return x - mean_r2; });
        return calibrate_r2(tmp, method, constraints, endCriteria,
                            initGuess, alpha, beta, omega);
    }

}

]]></document_content>
  </document>
</documents>