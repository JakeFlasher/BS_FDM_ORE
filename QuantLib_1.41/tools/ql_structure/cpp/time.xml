<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>asx.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007 StatPro Italia srl
 Copyright (C) 2004, 2005, 2006 Ferdinando Ametrano
 Copyright (C) 2006 Katiuscia Manzoni
 Copyright (C) 2015 Maddalena Zanzi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/asx.hpp>
#include <ql/settings.hpp>
#include <ql/utilities/dataparsers.hpp>
#include <boost/algorithm/string/case_conv.hpp>
#include <boost/utility/string_view.hpp>
#include <string>
#include <cctype>

namespace QuantLib {

    namespace {
        const boost::string_view All_MONTH_CODES = "FGHJKMNQUVXZ";
    }

    bool ASX::isASXdate(const Date& date, bool mainCycle) {
        if (date.weekday()!=Friday)
            return false;

        Day d = date.dayOfMonth();
        if (d<8 || d>14)
            return false;

        if (!mainCycle) return true;

        switch (date.month()) {
          case March:
          case June:
          case September:
          case December:
            return true;
          default:
            return false;
        }
    }

    bool ASX::isASXcode(const std::string& in, bool mainCycle) {
        if (in.length() != 2)
            return false;

        // 2nd character of code needs to be digit
        if (std::isdigit(static_cast<unsigned char>(in[1])) == 0)
            return false;

        // 1st character needs to represent the correct month
        const boost::string_view validMonthCodes = mainCycle ? "HMUZ" : All_MONTH_CODES;
        return validMonthCodes.find(std::toupper(in[0])) != boost::string_view::npos;
    }

    std::string ASX::code(const Date& date) {
        QL_REQUIRE(isASXdate(date, false),
                   date << " is not an ASX date");

        // month() is 1-based!
        const char monthCode = All_MONTH_CODES[date.month()-1];
        const char yearDigit = static_cast<char>(static_cast<int>('0') + (date.year() % 10));
        std::string code{monthCode, yearDigit};

        #ifdef QL_EXTRA_SAFETY_CHECKS
            QL_ENSURE(isASXcode(code, false),
                    "the result " << code <<
                    " is an invalid ASX code");
        #endif

        return code;
    }

    Date ASX::date(const std::string& asxCode,
                   const Date& refDate) {
        QL_REQUIRE(isASXcode(asxCode, false),
                   asxCode << " is not a valid ASX code");

        const Date referenceDate = (refDate != Date() ?
                                    refDate :
                                    Date(Settings::instance().evaluationDate()));

        const char ms = std::toupper(asxCode.front());
        const std::size_t idxZeroBased = All_MONTH_CODES.find(ms);
        QL_ASSERT(idxZeroBased != All_MONTH_CODES.npos, "invalid ASX month letter. code: " + asxCode);

        // QuantLib::Month is 1-based!
        const auto m = static_cast<QuantLib::Month>(idxZeroBased + 1);

        // convert 2nd char to year digit
        Year y = static_cast<int>(asxCode[1]) - static_cast<int>('0');
        QL_ASSERT((y>=0) && (y <= 9), "invalid ASX year digit. code: " + asxCode);

        /* year<1900 are not valid QuantLib years: to avoid a run-time
           exception few lines below we need to add 10 years right away */
        if (y==0 && referenceDate.year()<=1909) y+=10;
        const Year referenceYear = (referenceDate.year() % 10);
        y += referenceDate.year() - referenceYear;
        Date result = ASX::nextDate(Date(1, m, y), false);
        return (result >= referenceDate) ? result : ASX::nextDate(Date(1, m, y+10), false);
    }

    Date ASX::nextDate(const Date& date, bool mainCycle) {
        Date refDate = (date == Date() ?
                        Date(Settings::instance().evaluationDate()) :
                        date);
        Year y = refDate.year();
        QuantLib::Month m = refDate.month();

        Size offset = mainCycle ? 3 : 1;
        Size skipMonths = offset-(m%offset);
        if (skipMonths != offset || refDate.dayOfMonth() > 14) {
            skipMonths += Size(m);
            if (skipMonths<=12) {
                m = QuantLib::Month(skipMonths);
            } else {
                m = QuantLib::Month(skipMonths-12);
                y += 1;
            }
        }

        Date result = Date::nthWeekday(2, Friday, m, y);
        if (result<=refDate)
            result = nextDate(Date(15, m, y), mainCycle);
        return result;
    }

    Date ASX::nextDate(const std::string& ASXcode,
                       bool mainCycle,
                       const Date& referenceDate)  {
        Date asxDate = date(ASXcode, referenceDate);
        return nextDate(asxDate+1, mainCycle);
    }

    std::string ASX::nextCode(const Date& d,
                              bool mainCycle) {
        Date date = nextDate(d, mainCycle);
        return code(date);
    }

    std::string ASX::nextCode(const std::string& asxCode,
                              bool mainCycle,
                              const Date& referenceDate) {
        Date date = nextDate(asxCode, mainCycle, referenceDate);
        return code(date);
    }

}
]]></document_content>
  </document>
  <document index="2">
    <source>businessdayconvention.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl
 Copyright (C) 2004 Jeff Yu
 Copyright (C) 2014 Paolo Mazzocchi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/businessdayconvention.hpp>
#include <ql/types.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    std::ostream& operator<<(std::ostream& out,
                             BusinessDayConvention b) {
        switch (b) {
          case Following:
            return out << "Following";
          case ModifiedFollowing:
            return out << "Modified Following";
          case HalfMonthModifiedFollowing:
            return out << "Half-Month Modified Following";
          case Preceding:
            return out << "Preceding";
          case ModifiedPreceding:
            return out << "Modified Preceding";
          case Unadjusted:
            return out << "Unadjusted";
          case Nearest:
            return out << "Nearest";
          default:
            QL_FAIL("unknown BusinessDayConvention (" << Integer(b) << ")");
        }
    }

}
]]></document_content>
  </document>
  <document index="3">
    <source>calendar.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007 StatPro Italia srl
 Copyright (C) 2004 Jeff Yu
 Copyright (C) 2014 Paolo Mazzocchi
 Copyright (C) 2020 Leonardo Arcari
 Copyright (C) 2020 Kline s.r.l.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendar.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    namespace {

        // Requires: from < to.
        Date::serial_type daysBetweenImpl(const Calendar& cal,
                                          const Date& from, const Date& to,
                                          bool includeFirst, bool includeLast) {
            auto res = static_cast<Date::serial_type>(includeLast && cal.isBusinessDay(to));
            for (Date d = includeFirst ? from : from + 1; d < to; ++d) {
                res += static_cast<Date::serial_type>(cal.isBusinessDay(d));
            }
            return res;
        }

    }

    void Calendar::addHoliday(const Date& d) {
        QL_REQUIRE(impl_, "no calendar implementation provided");

#ifdef QL_HIGH_RESOLUTION_DATE
        const Date _d(d.dayOfMonth(), d.month(), d.year());
#else
        const Date& _d = d;
#endif

        // if d was a genuine holiday previously removed, revert the change
        impl_->removedHolidays.erase(_d);
        // if it's already a holiday, leave the calendar alone.
        // Otherwise, add it.
        if (impl_->isBusinessDay(_d))
            impl_->addedHolidays.insert(_d);
    }

    void Calendar::removeHoliday(const Date& d) {
        QL_REQUIRE(impl_, "no calendar implementation provided");

#ifdef QL_HIGH_RESOLUTION_DATE
        const Date _d(d.dayOfMonth(), d.month(), d.year());
#else
        const Date& _d = d;
#endif

        // if d was an artificially-added holiday, revert the change
        impl_->addedHolidays.erase(_d);
        // if it's already a business day, leave the calendar alone.
        // Otherwise, add it.
        if (!impl_->isBusinessDay(_d))
            impl_->removedHolidays.insert(_d);
    }

    void Calendar::resetAddedAndRemovedHolidays() {
        impl_->addedHolidays.clear();
        impl_->removedHolidays.clear();
    }

    Date Calendar::adjust(const Date& d,
                          BusinessDayConvention c) const {
        QL_REQUIRE(d != Date(), "null date");

        if (c == Unadjusted)
            return d;

        Date d1 = d;
        if (c == Following || c == ModifiedFollowing 
            || c == HalfMonthModifiedFollowing) {
            while (isHoliday(d1))
                ++d1;
            if (c == ModifiedFollowing 
                || c == HalfMonthModifiedFollowing) {
                if (d1.month() != d.month()) {
                    return adjust(d, Preceding);
                }
                if (c == HalfMonthModifiedFollowing) {
                    if (d.dayOfMonth() <= 15 && d1.dayOfMonth() > 15) {
                        return adjust(d, Preceding);
                    }
                }
            }
        } else if (c == Preceding || c == ModifiedPreceding) {
            while (isHoliday(d1))
                --d1;
            if (c == ModifiedPreceding && d1.month() != d.month()) {
                return adjust(d,Following);
            }
        } else if (c == Nearest) {
            Date d2 = d;
            while (isHoliday(d1) && isHoliday(d2))
            {
                ++d1;
                --d2;
            }
            if (isHoliday(d1))
                return d2;
            else
                return d1;
        } else {
            QL_FAIL("unknown business-day convention");
        }
        return d1;
    }

    Date Calendar::advance(const Date& d,
                           Integer n, TimeUnit unit,
                           BusinessDayConvention c,
                           bool endOfMonth) const {
        QL_REQUIRE(d!=Date(), "null date");
        if (n == 0) {
            return adjust(d,c);
        } else if (unit == Days) {
            Date d1 = d;
            if (n > 0) {
                while (n > 0) {
                    ++d1;
                    while (isHoliday(d1))
                        ++d1;
                    --n;
                }
            } else {
                while (n < 0) {
                    --d1;
                    while(isHoliday(d1))
                        --d1;
                    ++n;
                }
            }
            return d1;
        } else if (unit == Weeks) {
            Date d1 = d + n*unit;
            return adjust(d1,c);
        } else {
            Date d1 = d + n*unit;

            // we are sure the unit is Months or Years
            if (endOfMonth) {
                if (c == Unadjusted) {
                    // move to the last calendar day if d is the last calendar day
                    if (Date::isEndOfMonth(d)) return Date::endOfMonth(d1);
                } else {
                    // move to the last business day if d is the last business day
                    if (isEndOfMonth(d)) return Calendar::endOfMonth(d1);
                }
            }
            return adjust(d1, c);
        }
    }

    Date Calendar::advance(const Date & d,
                           const Period & p,
                           BusinessDayConvention c,
                           bool endOfMonth) const {
        return advance(d, p.length(), p.units(), c, endOfMonth);
    }

    Date::serial_type Calendar::businessDaysBetween(const Date& from,
                                                    const Date& to,
                                                    bool includeFirst,
                                                    bool includeLast) const {
        return (from < to) ? daysBetweenImpl(*this, from, to, includeFirst, includeLast) :
               (from > to) ? -daysBetweenImpl(*this, to, from, includeLast, includeFirst) :
               Date::serial_type(includeFirst && includeLast && isBusinessDay(from));
    }



   // Western calendars

    bool Calendar::WesternImpl::isWeekend(Weekday w) const {
        return w == Saturday || w == Sunday;
    }

    Day Calendar::WesternImpl::easterMonday(Year y) {
        static const unsigned char EasterMonday[] = {
                  98,  90, 103,  95, 114, 106,  91, 111, 102,   // 1901-1909
             87, 107,  99,  83, 103,  95, 115,  99,  91, 111,   // 1910-1919
             96,  87, 107,  92, 112, 103,  95, 108, 100,  91,   // 1920-1929
            111,  96,  88, 107,  92, 112, 104,  88, 108, 100,   // 1930-1939
             85, 104,  96, 116, 101,  92, 112,  97,  89, 108,   // 1940-1949
            100,  85, 105,  96, 109, 101,  93, 112,  97,  89,   // 1950-1959
            109,  93, 113, 105,  90, 109, 101,  86, 106,  97,   // 1960-1969
             89, 102,  94, 113, 105,  90, 110, 101,  86, 106,   // 1970-1979
             98, 110, 102,  94, 114,  98,  90, 110,  95,  86,   // 1980-1989
            106,  91, 111, 102,  94, 107,  99,  90, 103,  95,   // 1990-1999
            115, 106,  91, 111, 103,  87, 107,  99,  84, 103,   // 2000-2009
             95, 115, 100,  91, 111,  96,  88, 107,  92, 112,   // 2010-2019
            104,  95, 108, 100,  92, 111,  96,  88, 108,  92,   // 2020-2029
            112, 104,  89, 108, 100,  85, 105,  96, 116, 101,   // 2030-2039
             93, 112,  97,  89, 109, 100,  85, 105,  97, 109,   // 2040-2049
            101,  93, 113,  97,  89, 109,  94, 113, 105,  90,   // 2050-2059
            110, 101,  86, 106,  98,  89, 102,  94, 114, 105,   // 2060-2069
             90, 110, 102,  86, 106,  98, 111, 102,  94, 114,   // 2070-2079
             99,  90, 110,  95,  87, 106,  91, 111, 103,  94,   // 2080-2089
            107,  99,  91, 103,  95, 115, 107,  91, 111, 103,   // 2090-2099
             88, 108, 100,  85, 105,  96, 109, 101,  93, 112,   // 2100-2109
             97,  89, 109,  93, 113, 105,  90, 109, 101,  86,   // 2110-2119
            106,  97,  89, 102,  94, 113, 105,  90, 110, 101,   // 2120-2129
             86, 106,  98, 110, 102,  94, 114,  98,  90, 110,   // 2130-2139
             95,  86, 106,  91, 111, 102,  94, 107,  99,  90,   // 2140-2149
            103,  95, 115, 106,  91, 111, 103,  87, 107,  99,   // 2150-2159
             84, 103,  95, 115, 100,  91, 111,  96,  88, 107,   // 2160-2169
             92, 112, 104,  95, 108, 100,  92, 111,  96,  88,   // 2170-2179
            108,  92, 112, 104,  89, 108, 100,  85, 105,  96,   // 2180-2189
            116, 101,  93, 112,  97,  89, 109, 100,  85, 105    // 2190-2199
        };
        return EasterMonday[y-1901];
    }

    // Orthodox calendars

    bool Calendar::OrthodoxImpl::isWeekend(Weekday w) const {
        return w == Saturday || w == Sunday;
    }

    Day Calendar::OrthodoxImpl::easterMonday(Year y) {
        static const unsigned char EasterMonday[] = {
                 105, 118, 110, 102, 121, 106, 126, 118, 102,   // 1901-1909
            122, 114,  99, 118, 110,  95, 115, 106, 126, 111,   // 1910-1919
            103, 122, 107,  99, 119, 110, 123, 115, 107, 126,   // 1920-1929
            111, 103, 123, 107,  99, 119, 104, 123, 115, 100,   // 1930-1939
            120, 111,  96, 116, 108, 127, 112, 104, 124, 115,   // 1940-1949
            100, 120, 112,  96, 116, 108, 128, 112, 104, 124,   // 1950-1959
            109, 100, 120, 105, 125, 116, 101, 121, 113, 104,   // 1960-1969
            117, 109, 101, 120, 105, 125, 117, 101, 121, 113,   // 1970-1979
             98, 117, 109, 129, 114, 105, 125, 110, 102, 121,   // 1980-1989
            106,  98, 118, 109, 122, 114, 106, 118, 110, 102,   // 1990-1999
            122, 106, 126, 118, 103, 122, 114,  99, 119, 110,   // 2000-2009
             95, 115, 107, 126, 111, 103, 123, 107,  99, 119,   // 2010-2019
            111, 123, 115, 107, 127, 111, 103, 123, 108,  99,   // 2020-2029
            119, 104, 124, 115, 100, 120, 112,  96, 116, 108,   // 2030-2039
            128, 112, 104, 124, 116, 100, 120, 112,  97, 116,   // 2040-2049
            108, 128, 113, 104, 124, 109, 101, 120, 105, 125,   // 2050-2059
            117, 101, 121, 113, 105, 117, 109, 101, 121, 105,   // 2060-2069
            125, 110, 102, 121, 113,  98, 118, 109, 129, 114,   // 2070-2079
            106, 125, 110, 102, 122, 106,  98, 118, 110, 122,   // 2080-2089
            114,  99, 119, 110, 102, 115, 107, 126, 118, 103,   // 2090-2099
            123, 115, 100, 120, 112,  96, 116, 108, 128, 112,   // 2100-2109
            104, 124, 109, 100, 120, 105, 125, 116, 108, 121,   // 2110-2119
            113, 104, 124, 109, 101, 120, 105, 125, 117, 101,   // 2120-2129
            121, 113,  98, 117, 109, 129, 114, 105, 125, 110,   // 2130-2139
            102, 121, 113,  98, 118, 109, 129, 114, 106, 125,   // 2140-2149
            110, 102, 122, 106, 126, 118, 103, 122, 114,  99,   // 2150-2159
            119, 110, 102, 115, 107, 126, 111, 103, 123, 114,   // 2160-2169
             99, 119, 111, 130, 115, 107, 127, 111, 103, 123,   // 2170-2179
            108,  99, 119, 104, 124, 115, 100, 120, 112, 103,   // 2180-2189
            116, 108, 128, 119, 104, 124, 116, 100, 120, 112    // 2190-2199
        };
        return EasterMonday[y-1901];
    }

    std::vector<Date> Calendar::holidayList(
        const Date& from, const Date& to, bool includeWeekEnds) const {

        std::vector<Date> result;
        for (Date d = from; d <= to; ++d) {
            if (isHoliday(d) && (includeWeekEnds || !isWeekend(d.weekday())))
                result.push_back(d);
       }
       return result;
    }

    std::vector<Date> Calendar::businessDayList(
        const Date& from, const Date& to) const {

        std::vector<Date> result;
        for (Date d = from; d <= to; ++d) {
            if (isBusinessDay(d))
                result.push_back(d);
       }
       return result;
    }
}
]]></document_content>
  </document>
  <document index="4">
    <source>calendars/argentina.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/argentina.hpp>

namespace QuantLib {

    Argentina::Argentina(Market) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(
                                                   new Argentina::MervalImpl);
        impl_ = impl;
    }

    bool Argentina::MervalImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Holy Thursday
            || (dd == em-4)
            // Good Friday
            || (dd == em-3)
            // Labour Day
            || (d == 1 && m == May)
            // May Revolution
            || (d == 25 && m == May)
            // Death of General Manuel Belgrano
            || (d >= 15 && d <= 21 && w == Monday && m == June)
            // Independence Day
            || (d == 9 && m == July)
            // Death of General José de San Martín
            || (d >= 15 && d <= 21 && w == Monday && m == August)
            // Columbus Day
            || ((d == 10 || d == 11 || d == 12 || d == 15 || d == 16)
                && w == Monday && m == October)
            // Immaculate Conception
            || (d == 8 && m == December)
            // Christmas Eve
            || (d == 24 && m == December)
            // New Year's Eve
            || ((d == 31 || (d == 30 && w == Friday)) && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="5">
    <source>calendars/australia.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/australia.hpp>

namespace QuantLib {

    Australia::Australia(Australia::Market market) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> settlementImpl(
                                            new Australia::SettlementImpl);
        static ext::shared_ptr<Calendar::Impl> asxImpl(
                                            new Australia::AsxImpl);
        switch (market) {
          case Settlement:
            impl_ = settlementImpl;
            break;
          case ASX:
            impl_ = asxImpl;
            break;
          default:
            QL_FAIL("unknown market");
        }
    }

    bool Australia::SettlementImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day (possibly moved to Monday)
            || ((d == 1 || ((d == 2 || d == 3) && w == Monday)) && m == January)
            // Australia Day, January 26th (possibly moved to Monday)
            || ((d == 26 || ((d == 27 || d == 28) && w == Monday)) &&
                m == January)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // ANZAC Day, April 25th
            || (d == 25 && m == April)
            // Queen's Birthday, second Monday in June
            || ((d > 7 && d <= 14) && w == Monday && m == June)
            // Bank Holiday, first Monday in August
            || (d <= 7 && w == Monday && m == August)
            // Labour Day, first Monday in October
            || (d <= 7 && w == Monday && m == October)
            // Christmas, December 25th (possibly Monday or Tuesday)
            || ((d == 25 || (d == 27 && (w == Monday || w == Tuesday)))
                && m == December)
            // Boxing Day, December 26th (possibly Monday or Tuesday)
            || ((d == 26 || (d == 28 && (w == Monday || w == Tuesday)))
                && m == December)
            // National Day of Mourning for Her Majesty, September 22 (only 2022)
            || (d == 22 && m == September && y == 2022))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

    bool Australia::AsxImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day (possibly moved to Monday)
            || ((d == 1 || ((d == 2 || d == 3) && w == Monday)) && m == January)
            // Australia Day, January 26th (possibly moved to Monday)
            || ((d == 26 || ((d == 27 || d == 28) && w == Monday)) &&
                m == January)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // ANZAC Day, April 25th
            || (d == 25 && m == April)
            // Queen's Birthday, second Monday in June
            || ((d > 7 && d <= 14) && w == Monday && m == June)
            // Christmas, December 25th (possibly Monday or Tuesday)
            || ((d == 25 || (d == 27 && (w == Monday || w == Tuesday)))
                && m == December)
            // Boxing Day, December 26th (possibly Monday or Tuesday)
            || ((d == 26 || (d == 28 && (w == Monday || w == Tuesday)))
                && m == December)
            // National Day of Mourning for Her Majesty, September 22 (only 2022)
            || (d == 22 && m == September && y == 2022))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}]]></document_content>
  </document>
  <document index="6">
    <source>calendars/austria.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/austria.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    Austria::Austria(Austria::Market market) {
        // all calendar instances on the same market share the same
        // implementation instance
        static ext::shared_ptr<Calendar::Impl> settlementImpl(
                                                   new Austria::SettlementImpl);
        static ext::shared_ptr<Calendar::Impl> exchangeImpl(
                                                   new Austria::ExchangeImpl);
        switch (market) {
          case Settlement:
            impl_ = settlementImpl;
            break;
          case Exchange:
            impl_ = exchangeImpl;
            break;
          default:
            QL_FAIL("unknown market");
        }
    }


    bool Austria::SettlementImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Epiphany
            || (d == 6 && m == January)
            // Easter Monday
            || (dd == em)
            // Ascension Thurday 
            || (dd == em+38)
            // Whit Monday
            || (dd == em+49)
            // Corpus Christi
            || (dd == em+59)
            // Labour Day
            || (d == 1 && m == May)
            // Assumption
            || (d == 15 && m == August)
            // National Holiday since 1967
            || (d == 26 && m == October && y >= 1967)
            // National Holiday 1919-1934
            || (d == 12 && m == November && y >= 1919 && y <= 1934)
            // All Saints' Day
            || (d == 1 && m == November)
            // Immaculate Conception
            || (d == 8 && m == December)
            // Christmas
            || (d == 25 && m == December)
            // St. Stephen
            || (d == 26 && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }


    bool Austria::ExchangeImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // Whit Monay
            || (dd == em+49)
            // Labour Day
            || (d == 1 && m == May)
            // National Holiday since 1967
            || (d == 26 && m == October && y >= 1967)
            // National Holiday 1919-1934
            || (d == 12 && m == November && y >= 1919 && y <= 1934)
            // Christmas' Eve
            || (d == 24 && m == December)
            // Christmas
            || (d == 25 && m == December)
            // St. Stephen
            || (d == 26 && m == December)
            // Exchange Holiday
            || (d == 31 && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="7">
    <source>calendars/bespokecalendar.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/bespokecalendar.hpp>
#include <sstream>
#include <utility>

namespace QuantLib {

    BespokeCalendar::Impl::Impl(std::string name) : name_(std::move(name)) {}

    std::string BespokeCalendar::Impl::name() const {
        return name_;
    }

    bool BespokeCalendar::Impl::isWeekend(Weekday w) const {
        return (weekend_mask_ & (1 << w)) != 0;
    }

    bool BespokeCalendar::Impl::isBusinessDay(const Date& date) const {
        return !isWeekend(date.weekday());
    }

    void BespokeCalendar::Impl::addWeekend(Weekday w) {
        weekend_mask_ |= (1 << w);
    }


    BespokeCalendar::BespokeCalendar(const std::string& name) {
        bespokeImpl_ = ext::make_shared<BespokeCalendar::Impl>(
                                             name);
        impl_ = bespokeImpl_;
    }

    void BespokeCalendar::addWeekend(Weekday w) {
        bespokeImpl_->addWeekend(w);
    }

}

]]></document_content>
  </document>
  <document index="8">
    <source>calendars/botswana.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
Copyright (C) 2017 Francois Botha

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<https://www.quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/botswana.hpp>

namespace QuantLib {

    Botswana::Botswana() {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new Botswana::Impl);
        impl_ = impl;
    }

    bool Botswana::Impl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day (possibly moved to Monday or Tuesday)
            || ((d == 1 || (d == 2 && w == Monday) || (d == 3 && w == Tuesday)) 
                && m == January)
            // Good Friday
            || (dd == em - 3)
            // Easter Monday
            || (dd == em)
            // Labour Day, May 1st (possibly moved to Monday)
            || ((d == 1 || (d == 2 && w == Monday))
                && m == May)
            // Ascension
            || (dd == em + 38)
            // Sir Seretse Khama Day, July 1st (possibly moved to Monday)
            || ((d == 1 || (d == 2 && w == Monday))
                && m == July)
            // Presidents' Day (third Monday of July)
            || ((d >= 15 && d <= 21) && w == Monday && m == July)
            // Independence Day, September 30th (possibly moved to Monday)
            || ((d == 30 && m == September) || 
                (d == 1  && w == Monday && m == October))
            // Botswana Day, October 1st (possibly moved to Monday or Tuesday)
            || ((d == 1 || (d == 2 && w == Monday) || (d == 3 && w == Tuesday)) 
                && m == October)
            // Christmas
            || (d == 25 && m == December)
            // Boxing Day (possibly moved to Monday)
            || ((d == 26 || (d == 27 && w == Monday))
                && m == December)
            )
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="9">
    <source>calendars/brazil.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2006 Piter Dias
 Copyright (C) 2007 Richard Gomes

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/brazil.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    Brazil::Brazil(Brazil::Market market) {
        // all calendar instances on the same market share the same
        // implementation instance
        static ext::shared_ptr<Calendar::Impl> settlementImpl(
                                                  new Brazil::SettlementImpl);
        static ext::shared_ptr<Calendar::Impl> exchangeImpl(
                                                    new Brazil::ExchangeImpl);
        switch (market) {
          case Settlement:
            impl_ = settlementImpl;
            break;
          case Exchange:
            impl_ = exchangeImpl;
            break;
          default:
            QL_FAIL("unknown market");
        }
    }

    bool Brazil::SettlementImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();
        Day dd = date.dayOfYear();
        Day em = easterMonday(y);

        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Tiradentes Day
            || (d == 21 && m == April)
            // Labor Day
            || (d == 1 && m == May)
            // Independence Day
            || (d == 7 && m == September)
            // Nossa Sra. Aparecida Day
            || (d == 12 && m == October)
            // All Souls Day
            || (d == 2 && m == November)
            // Republic Day
            || (d == 15 && m == November)
            // Black Awareness Day
            || (d == 20 && m == November && y >= 2024)
            // Christmas
            || (d == 25 && m == December)
            // Passion of Christ
            || (dd == em-3)
            // Carnival
            || (dd == em-49 || dd == em-48)
            // Corpus Christi
            || (dd == em+59)
            )
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

    bool Brazil::ExchangeImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();
        Day dd = date.dayOfYear();
        Day em = easterMonday(y);

        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Sao Paulo City Day
            || (d == 25 && m == January && y < 2022)
            // Tiradentes Day
            || (d == 21 && m == April)
            // Labor Day
            || (d == 1 && m == May)
            // Revolution Day
            || (d == 9 && m == July && y < 2022)
            // Independence Day
            || (d == 7 && m == September)
            // Nossa Sra. Aparecida Day
            || (d == 12 && m == October)
            // All Souls Day
            || (d == 2 && m == November)
            // Republic Day
            || (d == 15 && m == November)
            // Black Consciousness Day
            || (d == 20 && m == November && y >= 2007 && y != 2022 && y != 2023)
            // Christmas Eve
            || (d == 24 && m == December)
            // Christmas
            || (d == 25 && m == December)
            // Passion of Christ
            || (dd == em-3)
            // Carnival
            || (dd == em-49 || dd == em-48)
            // Corpus Christi
            || (dd == em+59)
            // last business day of the year
            || (m == December && (d == 31 || (d >= 29 && w == Friday)))
            )
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="10">
    <source>calendars/canada.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/canada.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    Canada::Canada(Canada::Market market) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> settlementImpl(
                                                  new Canada::SettlementImpl);
        static ext::shared_ptr<Calendar::Impl> tsxImpl(new Canada::TsxImpl);
        switch (market) {
          case Settlement:
            impl_ = settlementImpl;
            break;
          case TSX:
            impl_ = tsxImpl;
            break;
          default:
            QL_FAIL("unknown market");
        }
    }

    bool Canada::SettlementImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day (possibly moved to Monday)
            || ((d == 1 || ((d == 2 || d == 3) && w == Monday)) && m == January)
            // Family Day (third Monday in February, since 2008)
            || ((d >= 15 && d <= 21) && w == Monday && m == February
                && y >= 2008)
            // Good Friday
            || (dd == em-3)
            // The Monday on or preceding 24 May (Victoria Day)
            || (d > 17 && d <= 24 && w == Monday && m == May)
            // July 1st, possibly moved to Monday (Canada Day)
            || ((d == 1 || ((d == 2 || d == 3) && w == Monday)) && m==July)
            // first Monday of August (Provincial Holiday)
            || (d <= 7 && w == Monday && m == August)
            // first Monday of September (Labor Day)
            || (d <= 7 && w == Monday && m == September)
            // September 30th, possibly moved to Monday
            // (National Day for Truth and Reconciliation, since 2021)
            || (((d == 30 && m == September) || (d <= 2 && m == October && w == Monday)) && y >= 2021)
            // second Monday of October (Thanksgiving Day)
            || (d > 7 && d <= 14 && w == Monday && m == October)
            // November 11th (possibly moved to Monday)
            || ((d == 11 || ((d == 12 || d == 13) && w == Monday))
                && m == November)
            // Christmas (possibly moved to Monday or Tuesday)
            || ((d == 25 || (d == 27 && (w == Monday || w == Tuesday)))
                && m == December)
            // Boxing Day (possibly moved to Monday or Tuesday)
            || ((d == 26 || (d == 28 && (w == Monday || w == Tuesday)))
                && m == December)
            )
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

    bool Canada::TsxImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day (possibly moved to Monday)
            || ((d == 1 || ((d == 2 || d == 3) && w == Monday)) && m == January)
            // Family Day (third Monday in February, since 2008)
            || ((d >= 15 && d <= 21) && w == Monday && m == February
                && y >= 2008)
            // Good Friday
            || (dd == em-3)
            // The Monday on or preceding 24 May (Victoria Day)
            || (d > 17 && d <= 24 && w == Monday && m == May)
            // July 1st, possibly moved to Monday (Canada Day)
            || ((d == 1 || ((d == 2 || d == 3) && w == Monday)) && m==July)
            // first Monday of August (Provincial Holiday)
            || (d <= 7 && w == Monday && m == August)
            // first Monday of September (Labor Day)
            || (d <= 7 && w == Monday && m == September)
            // second Monday of October (Thanksgiving Day)
            || (d > 7 && d <= 14 && w == Monday && m == October)
            // Christmas (possibly moved to Monday or Tuesday)
            || ((d == 25 || (d == 27 && (w == Monday || w == Tuesday)))
                && m == December)
            // Boxing Day (possibly moved to Monday or Tuesday)
            || ((d == 26 || (d == 28 && (w == Monday || w == Tuesday)))
                && m == December)
            )
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}
]]></document_content>
  </document>
  <document index="11">
    <source>calendars/chile.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Anubhav Pandey

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/chile.hpp>

namespace QuantLib {

    namespace {

        // Celebrated on the Winter Solstice day, except in 2021, when it was the day after.
        inline bool isAboriginalPeopleDay(Day d, Month m, Year y) {
            static const unsigned char aboriginalPeopleDay[] = {
                    21, 21, 21, 20, 20, 21, 21, 20, 20,   // 2021-2029
                21, 21, 20, 20, 21, 21, 20, 20, 21, 21,   // 2030-2039
                20, 20, 21, 21, 20, 20, 21, 21, 20, 20,   // 2040-2049
                20, 21, 20, 20, 20, 21, 20, 20, 20, 21,   // 2050-2059
                20, 20, 20, 21, 20, 20, 20, 21, 20, 20,   // 2060-2069
                20, 21, 20, 20, 20, 21, 20, 20, 20, 20,   // 2070-2079
                20, 20, 20, 20, 20, 20, 20, 20, 20, 20,   // 2080-2089
                20, 20, 20, 20, 20, 20, 20, 20, 20, 20,   // 2090-2099
                21, 21, 21, 21, 21, 21, 21, 21, 20, 21,   // 2100-2109
                21, 21, 20, 21, 21, 21, 20, 21, 21, 21,   // 2110-2119
                20, 21, 21, 21, 20, 21, 21, 21, 20, 21,   // 2120-2129
                21, 21, 20, 21, 21, 21, 20, 20, 21, 21,   // 2130-2139
                20, 20, 21, 21, 20, 20, 21, 21, 20, 20,   // 2140-2149
                21, 21, 20, 20, 21, 21, 20, 20, 21, 21,   // 2150-2159
                20, 20, 21, 21, 20, 20, 21, 21, 20, 20,   // 2160-2169
                20, 21, 20, 20, 20, 21, 20, 20, 20, 21,   // 2170-2179
                20, 20, 20, 21, 20, 20, 20, 21, 20, 20,   // 2180-2189
                20, 21, 20, 20, 20, 21, 20, 20, 20, 20    // 2190-2199
            };
            return m == June && y >= 2021 && d == aboriginalPeopleDay[y-2021];
        }

    }

    Chile::Chile(Market) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new Chile::SseImpl);
        impl_ = impl;
    }

    bool Chile::SseImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();
        Day dd = date.dayOfYear();
        Day em = easterMonday(y);

        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            || (d == 2 && m == January && w == Monday && y > 2016)
            // Papal visit in 2018
            || (d == 16 && m == January && y == 2018)
            // Good Friday
            || (dd == em-3)
            // Easter Saturday
            || (dd == em-2)
            // Census Day in 2017
            || (d == 19 && m == April && y == 2017)
            // Labour Day
            || (d == 1 && m == May)
            // Navy Day
            || (d == 21 && m == May)
            // Day of Aboriginal People
            || isAboriginalPeopleDay(d, m, y)
            // St. Peter and St. Paul
            || (d >= 26 && d <= 29 && m == June && w == Monday)
            || (d == 2 && m == July && w == Monday)
            // Our Lady of Mount Carmel
            || (d == 16 && m == July)
            // Assumption Day
            || (d == 15 && m == August)
            // Independence Day
            || (d == 16 && m == September && y == 2022)
            || (d == 17 && m == September && ((w == Monday && y >= 2007) || (w == Friday && y > 2016)))
            || (d == 18 && m == September)
            // Army Day
            || (d == 19 && m == September)
            || (d == 20 && m == September && w == Friday && y >= 2007)
            // Discovery of Two Worlds
            || (d >= 9 && d <= 12 && m == October && w == Monday)
            || (d == 15 && m == October && w == Monday)
            // Reformation Day
            || (((d == 27 && m == October && w == Friday)
                 || (d == 31 && m == October && w != Tuesday && w != Wednesday)
                 || (d == 2 && m == November && w == Friday)) && y >= 2008)
            // All Saints' Day
            || (d == 1 && m == November)
            // Immaculate Conception
            || (d == 8 && m == December)
            // Christmas Day
            || (d == 25 && m == December)
            // New Year's Eve 
            || (d == 31 && m == December)
            )
            return false;

        return true;
    }

}

]]></document_content>
  </document>
  <document index="12">
    <source>calendars/china.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 FIMAT Group
 Copyright (C) 2007, 2009, 2010, 2011 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/china.hpp>
#include <ql/errors.hpp>
#include <set>

namespace QuantLib {

    China::China(Market m) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> sseImpl(new China::SseImpl);
        static ext::shared_ptr<Calendar::Impl> IBImpl(new China::IbImpl);
        switch (m) {
          case SSE:
            impl_ = sseImpl;
            break;
          case IB:
            impl_ = IBImpl;
            break;
          default:
            QL_FAIL("unknown market");
        }
    }

    bool China::SseImpl::isWeekend(Weekday w) const {
        return w == Saturday || w == Sunday;
    }

    bool China::SseImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();

        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            || (y == 2005 && d == 3 && m == January)
            || (y == 2006 && (d == 2 || d == 3) && m == January)
            || (y == 2007 && d <= 3 && m == January)
            || (y == 2007 && d == 31 && m == December)
            || (y == 2009 && d == 2 && m == January)
            || (y == 2011 && d == 3 && m == January)
            || (y == 2012 && (d == 2 || d == 3) && m == January)
            || (y == 2013 && d <= 3 && m == January)
            || (y == 2014 && d == 1 && m == January)
            || (y == 2015 && d <= 3 && m == January)
            || (y == 2017 && d == 2 && m == January)
            || (y == 2018 && d == 1 && m == January)
            || (y == 2018 && d == 31 && m == December)
            || (y == 2019 && d == 1 && m == January)
            || (y == 2020 && d == 1 && m == January)
            || (y == 2021 && d == 1 && m == January)
            || (y == 2022 && d == 3 && m == January)
            || (y == 2023 && d == 2 && m == January)
            // Chinese New Year
            || (y == 2004 && d >= 19 && d <= 28 && m == January)
            || (y == 2005 && d >=  7 && d <= 15 && m == February)
            || (y == 2006 && ((d >= 26 && m == January) ||
                              (d <= 3 && m == February)))
            || (y == 2007 && d >= 17 && d <= 25 && m == February)
            || (y == 2008 && d >= 6 && d <= 12 && m == February)
            || (y == 2009 && d >= 26 && d <= 30 && m == January)
            || (y == 2010 && d >= 15 && d <= 19 && m == February)
            || (y == 2011 && d >= 2 && d <= 8 && m == February)
            || (y == 2012 && d >= 23 && d <= 28 && m == January)
            || (y == 2013 && d >= 11 && d <= 15 && m == February)
            || (y == 2014 && d >= 31 && m == January)
            || (y == 2014 && d <= 6 && m == February)
            || (y == 2015 && d >= 18 && d <= 24 && m == February)
            || (y == 2016 && d >= 8 && d <= 12 && m == February)
            || (y == 2017 && ((d >= 27 && m == January) ||
                              (d <= 2 && m == February)))
            || (y == 2018 && (d >= 15 && d <= 21 && m == February))
            || (y == 2019 && d >= 4 && d <= 8 && m == February)
            || (y == 2020 && (d == 24 || (d >= 27 && d <= 31)) && m == January)
            || (y == 2021 && (d == 11 || d == 12 || d == 15 || d == 16 || d == 17) && m == February)
            || (y == 2022 && ((d == 31 && m == January) || (d <= 4 && m == February)))
            || (y == 2023 && d >= 23 && d <= 27 && m == January)
            || (y == 2024 && (d == 9 || (d >= 12 && d <= 16)) && m == February)
            || (y == 2025 && ((d >= 28 && d <= 31 && m == January) || (d >= 3 && d <= 4 && m == February)))
            // Ching Ming Festival
            || (y <= 2008 && d == 4 && m == April)
            || (y == 2009 && d == 6 && m == April)
            || (y == 2010 && d == 5 && m == April)
            || (y == 2011 && d >=3 && d <= 5 && m == April)
            || (y == 2012 && d >= 2 && d <= 4 && m == April)
            || (y == 2013 && d >= 4 && d <= 5 && m == April)
            || (y == 2014 && d == 7 && m == April)
            || (y == 2015 && d >= 5 && d <= 6 && m == April)
            || (y == 2016 && d == 4 && m == April)
            || (y == 2017 && d >= 3 && d <= 4 && m == April)
            || (y == 2018 && d >= 5 && d <= 6 && m == April)
            || (y == 2019 && d == 5 && m == April)
            || (y == 2020 && d == 6 && m == April)
            || (y == 2021 && d == 5 && m == April)
            || (y == 2022 && d >= 4 && d <= 5 && m == April)
            || (y == 2023 && d == 5 && m == April)
            || (y == 2024 && d >= 4 && d <= 5 && m == April)
            || (y == 2025 && d == 4 && m == April)
            // Labor Day
            || (y <= 2007 && d >= 1 && d <= 7 && m == May)
            || (y == 2008 && d >= 1 && d <= 2 && m == May)
            || (y == 2009 && d == 1 && m == May)
            || (y == 2010 && d == 3 && m == May)
            || (y == 2011 && d == 2 && m == May)
            || (y == 2012 && ((d == 30 && m == April) ||
                              (d == 1 && m == May)))
            || (y == 2013 && ((d >= 29 && m == April) ||
                              (d == 1 && m == May)))
            || (y == 2014 && d >= 1 && d <=3 && m == May)
            || (y == 2015 && d == 1 && m == May)
            || (y == 2016 && d >= 1 && d <=2 && m == May)
            || (y == 2017 && d == 1 && m == May)
            || (y == 2018 && ((d == 30 && m == April) || (d == 1 && m == May)))
            || (y == 2019 && d >= 1 && d <=3 && m == May)
            || (y == 2020 && (d == 1 || d == 4 || d == 5) && m == May)
            || (y == 2021 && (d == 3 || d == 4 || d == 5) && m == May)
            || (y == 2022 && d >= 2 && d <= 4 && m == May)
            || (y == 2023 && d >= 1 && d <= 3 && m == May)
            || (y == 2024 && d >= 1 && d <= 3 && m == May)
            || (y == 2025 && (d == 1 || d == 2 || d == 5) && m == May)
            // Tuen Ng Festival
            || (y <= 2008 && d == 9 && m == June)
            || (y == 2009 && (d == 28 || d == 29) && m == May)
            || (y == 2010 && d >= 14 && d <= 16 && m == June)
            || (y == 2011 && d >= 4 && d <= 6 && m == June)
            || (y == 2012 && d >= 22 && d <= 24 && m == June)
            || (y == 2013 && d >= 10 && d <= 12 && m == June)
            || (y == 2014 && d == 2 && m == June)
            || (y == 2015 && d == 22 && m == June)
            || (y == 2016 && d >= 9 && d <= 10 && m == June)
            || (y == 2017 && d >= 29 && d <= 30 && m == May)
            || (y == 2018 && d == 18 && m == June)
            || (y == 2019 && d == 7 && m == June)
            || (y == 2020 && d >= 25 && d <= 26 && m == June)
            || (y == 2021 && d == 14 && m == June)
            || (y == 2022 && d == 3 && m == June)
            || (y == 2023 && d >= 22 && d <= 23 && m == June)
            || (y == 2024 && d == 10 && m == June)
            || (y == 2025 && d == 2 && m == June)
            // Mid-Autumn Festival
            || (y <= 2008 && d == 15 && m == September)
            || (y == 2010 && d >= 22 && d <= 24 && m == September)
            || (y == 2011 && d >= 10 && d <= 12 && m == September)
            || (y == 2012 && d == 30 && m == September)
            || (y == 2013 && d >= 19 && d <= 20 && m == September)
            || (y == 2014 && d == 8 && m == September)
            || (y == 2015 && d == 27 && m == September)
            || (y == 2016 && d >= 15 && d <= 16 && m == September)
            || (y == 2018 && d == 24 && m == September)
            || (y == 2019 && d == 13 && m == September)
            || (y == 2021 && (d == 20 || d == 21) && m == September)
            || (y == 2022 && d == 12 && m == September)
            || (y == 2023 && d == 29 && m == September)
            || (y == 2024 && d >= 16 && d <= 17 && m == September)
            // National Day
            || (y <= 2007 && d >= 1 && d <= 7 && m == October) 
            || (y == 2008 && ((d >= 29 && m == September) ||
                              (d <= 3 && m == October)))
            || (y == 2009 && d >= 1 && d <= 8 && m == October)
            || (y == 2010 && d >= 1 && d <= 7 && m == October)
            || (y == 2011 && d >= 1 && d <= 7 && m == October)
            || (y == 2012 && d >= 1 && d <= 7 && m == October)
            || (y == 2013 && d >= 1 && d <= 7 && m == October)
            || (y == 2014 && d >= 1 && d <= 7 && m == October)
            || (y == 2015 && d >= 1 && d <= 7 && m == October)
            || (y == 2016 && d >= 3 && d <= 7 && m == October)
            || (y == 2017 && d >= 2 && d <= 6 && m == October)
            || (y == 2018 && d >= 1 && d <= 5 && m == October)
            || (y == 2019 && d >= 1 && d <= 7 && m == October)
            || (y == 2020 && d >= 1 && d <= 2 && m == October)
            || (y == 2020 && d >= 5 && d <= 8 && m == October)
            || (y == 2021 && (d == 1 || d == 4 || d == 5 || d == 6 || d == 7) && m == October)
            || (y == 2022 && d >= 3 && d <= 7 && m == October)
            || (y == 2023 && d >= 2 && d <= 6 && m == October)
            || (y == 2024 && ((d >= 1 && d <= 4) || d == 7) && m == October)
            || (y == 2025 && ((d >= 1 && d <= 3) || (d >= 6 && d <= 8)) && m == October)
            // 70th anniversary of the victory of anti-Japaneses war
            || (y == 2015 && d >= 3 && d <= 4 && m == September)
            )
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

    bool China::IbImpl::isWeekend(Weekday w) const {
        return w == Saturday || w == Sunday;
    }

    bool China::IbImpl::isBusinessDay(const Date& date) const {
        static const std::set<Date> workingWeekends = {
            // 2005
            Date(5, February, 2005),
            Date(6, February, 2005),
            Date(30, April, 2005),
            Date(8, May, 2005),
            Date(8, October, 2005),
            Date(9, October, 2005),
            Date(31, December, 2005),
            //2006
            Date(28, January, 2006),
            Date(29, April, 2006),
            Date(30, April, 2006),
            Date(30, September, 2006),
            Date(30, December, 2006),
            Date(31, December, 2006),
            // 2007
            Date(17, February, 2007),
            Date(25, February, 2007),
            Date(28, April, 2007),
            Date(29, April, 2007),
            Date(29, September, 2007),
            Date(30, September, 2007),
            Date(29, December, 2007),
            // 2008
            Date(2, February, 2008),
            Date(3, February, 2008),
            Date(4, May, 2008),
            Date(27, September, 2008),
            Date(28, September, 2008),
            // 2009
            Date(4, January, 2009),
            Date(24, January, 2009),
            Date(1, February, 2009),
            Date(31, May, 2009),
            Date(27, September, 2009),
            Date(10, October, 2009),
            // 2010
            Date(20, February, 2010),
            Date(21, February, 2010),
            Date(12, June, 2010),
            Date(13, June, 2010),
            Date(19, September, 2010),
            Date(25, September, 2010),
            Date(26, September, 2010),
            Date(9, October, 2010),
            // 2011
            Date(30, January, 2011),
            Date(12, February, 2011),
            Date(2, April, 2011),
            Date(8, October, 2011),
            Date(9, October, 2011),
            Date(31, December, 2011),
            // 2012
            Date(21, January, 2012),
            Date(29, January, 2012),
            Date(31, March, 2012),
            Date(1, April, 2012),
            Date(28, April, 2012),
            Date(29, September, 2012),
            // 2013
            Date(5,January,2013),
            Date(6,January,2013),
            Date(16,February,2013),
            Date(17,February,2013),
            Date(7,April,2013),
            Date(27,April,2013),
            Date(28,April,2013),
            Date(8,June,2013),
            Date(9,June,2013),
            Date(22,September,2013),
            Date(29,September,2013),
            Date(12,October,2013),
            // 2014
            Date(26,January,2014),
            Date(8,February,2014),
            Date(4,May,2014),
            Date(28,September,2014),
            Date(11,October,2014),
            // 2015
            Date(4,January,2015),
            Date(15,February,2015),
            Date(28,February,2015),
            Date(6,September,2015),
            Date(10,October,2015),
            // 2016
            Date(6,February,2016),
            Date(14,February,2016),
            Date(12,June,2016),
            Date(18,September,2016),
            Date(8,October,2016),
            Date(9,October,2016),
            // 2017
            Date(22,January,2017),
            Date(4,February,2017),
            Date(1,April,2017),
            Date(27,May,2017),
            Date(30,September,2017),
            // 2018
            Date(11, February, 2018),
            Date(24, February, 2018),
            Date(8, April, 2018),
            Date(28, April, 2018),
            Date(29, September, 2018),
            Date(30, September, 2018),
            Date(29, December, 2018),
            // 2019
            Date(2, February, 2019),
            Date(3, February, 2019),
            Date(28, April, 2019),
            Date(5, May, 2019),
            Date(29, September, 2019),
            Date(12, October, 2019),
            // 2020
            Date(19, January, 2020),
            Date(26, April, 2020),
            Date(9, May, 2020),
            Date(28, June, 2020),
            Date(27, September, 2020),
            Date(10, October, 2020),
            // 2021
            Date(7, February, 2021),
            Date(20, February, 2021),
            Date(25, April, 2021),
            Date(8, May, 2021),
            Date(18, September, 2021),
            Date(26, September, 2021),
            Date(9, October, 2021),
            // 2022
            Date(29, January, 2022),
            Date(30, January, 2022),
            Date(2, April, 2022),
            Date(24, April, 2022),
            Date(7, May, 2022),
            Date(8, October, 2022),
            Date(9, October, 2022),
            // 2023
            Date(28, January, 2023),
            Date(29, January, 2023),
            Date(23, April, 2023),
            Date(6, May, 2023),
            Date(25, June, 2023),
            Date(7, October, 2023),
            Date(8, October, 2023),
            // 2024
            Date(4, Feb, 2024),
            Date(9, Feb, 2024),
            Date(18, Feb, 2024),
            Date(7, Apr, 2024),
            Date(28, Apr, 2024),
            Date(11, May, 2024),
            Date(14, Sep, 2024),
            Date(29, Sep, 2024),
            Date(12, October, 2024),
            // 2025
            Date(26, Jan, 2025),
            Date(8, Feb, 2025),
            Date(27, Apr, 2025),
            Date(28, Sep, 2025),
            Date(11, Oct, 2025)
        };

        // If it is already a SSE business day, it must be a IB business day
        return sseImpl->isBusinessDay(date) ||
            (workingWeekends.find(date) != workingWeekends.end());
    }

}

]]></document_content>
  </document>
  <document index="13">
    <source>calendars/czechrepublic.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/czechrepublic.hpp>

namespace QuantLib {

    CzechRepublic::CzechRepublic(Market) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(
                                                  new CzechRepublic::PseImpl);
        impl_ = impl;
    }

    bool CzechRepublic::PseImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
			// Good Friday
			|| (dd == em - 3 && y >= 2016)
            // Easter Monday
            || (dd == em)
            // Labour Day
            || (d == 1 && m == May)
            // Liberation Day
            || (d == 8 && m == May)
            // SS. Cyril and Methodius
            || (d == 5 && m == July)
            // Jan Hus Day
            || (d == 6 && m == July)
            // Czech Statehood Day
            || (d == 28 && m == September)
            // Independence Day
            || (d == 28 && m == October)
            // Struggle for Freedom and Democracy Day
            || (d == 17 && m == November)
            // Christmas Eve
            || (d == 24 && m == December)
            // Christmas
            || (d == 25 && m == December)
            // St. Stephen
            || (d == 26 && m == December)
            // unidentified closing days for stock exchange
            || (d == 2 && m == January && y == 2004)
            || (d == 31 && m == December && y == 2004))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="14">
    <source>calendars/denmark.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 StatPro Italia srl
 Copyright (C) 2022 Skandinaviska Enskilda Banken AB (publ)

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/denmark.hpp>

namespace QuantLib {

    Denmark::Denmark() {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new Denmark::Impl);
        impl_ = impl;
    }

    bool Denmark::Impl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // Maunday Thursday
            || (dd == em-4)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // General Prayer Day
            || (dd == em+25 && y <= 2023)
            // Ascension
            || (dd == em+38)
            // Day after Ascension
            || (dd == em+39 && y >= 2009)
            // Whit Monday
            || (dd == em+49)
            // New Year's Day
            || (d == 1  && m == January)
            // Constitution Day, June 5th
            || (d == 5  && m == June)
            // Christmas Eve
            || (d == 24 && m == December)
            // Christmas
            || (d == 25 && m == December)
            // Boxing Day
            || (d == 26 && m == December)
            // New Year's Eve
            || (d == 31 && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="15">
    <source>calendars/finland.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/finland.hpp>

namespace QuantLib {

    Finland::Finland() {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new Finland::Impl);
        impl_ = impl;
    }

    bool Finland::Impl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Epiphany
            || (d == 6 && m == January)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // Ascension Thursday
            || (dd == em+38)
            // Labour Day
            || (d == 1 && m == May)
            // Midsummer Eve (Friday between June 19-25)
            || (w == Friday && (d >= 19 && d <= 25) && m == June)
            // Independence Day
            || (d == 6 && m == December)
            // Christmas Eve
            || (d == 24 && m == December)
            // Christmas
            || (d == 25 && m == December)
            // Boxing Day
            || (d == 26 && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="16">
    <source>calendars/france.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/france.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    France::France(France::Market market) {
        // all calendar instances on the same market share the same
        // implementation instance
        static ext::shared_ptr<Calendar::Impl> settlementImpl(
                                                   new France::SettlementImpl);
        static ext::shared_ptr<Calendar::Impl> exchangeImpl(
                                                   new France::ExchangeImpl);
        switch (market) {
          case Settlement:
            impl_ = settlementImpl;
            break;
          case Exchange:
            impl_ = exchangeImpl;
            break;
          default:
            QL_FAIL("unknown market");
        }
    }


    bool France::SettlementImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // Jour de l'An
            || (d == 1 && m == January)
            // Lundi de Paques
            || (dd == em)
            // Fete du Travail
            || (d == 1 && m == May)
            // Victoire 1945
            || (d == 8 && m == May)
            // Ascension
            || (d == 10 && m == May)
            // Pentecote
            || (d == 21 && m == May)
            // Fete nationale
            || (d == 14 && m == July)
            // Assomption
            || (d == 15 && m == August)
            // Toussaint
            || (d == 1 && m == November)
            // Armistice 1918
            || (d == 11 && m == November)
            // Noel
            || (d == 25 && m == December))
            
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }


    bool France::ExchangeImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // Jour de l'An
            || (d == 1 && m == January)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // Labor Day
            || (d == 1 && m == May)
            // Christmas Eve
            || (d == 24 && m == December)
            // Christmas Day
            || (d == 25 && m == December)
            // Boxing Day
            || (d == 26 && m == December)
            // New Year's Eve
            || (d == 31 && m == December))
         
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="17">
    <source>calendars/germany.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/germany.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    Germany::Germany(Germany::Market market) {
        // all calendar instances on the same market share the same
        // implementation instance
        static ext::shared_ptr<Calendar::Impl> settlementImpl(
            new Germany::SettlementImpl);
        static ext::shared_ptr<Calendar::Impl> frankfurtStockExchangeImpl(
            new Germany::FrankfurtStockExchangeImpl);
        static ext::shared_ptr<Calendar::Impl> xetraImpl(
            new Germany::XetraImpl);
        static ext::shared_ptr<Calendar::Impl> eurexImpl(
            new Germany::EurexImpl);
        static ext::shared_ptr<Calendar::Impl> euwaxImpl(
            new Germany::EuwaxImpl);

        switch (market) {
          case Settlement:
            impl_ = settlementImpl;
            break;
          case FrankfurtStockExchange:
            impl_ = frankfurtStockExchangeImpl;
            break;
          case Xetra:
            impl_ = xetraImpl;
            break;
          case Eurex:
            impl_ = eurexImpl;
            break;
          case Euwax:
            impl_ = euwaxImpl;
            break;
          default:
            QL_FAIL("unknown market");
        }
    }


    bool Germany::SettlementImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // Ascension Thursday
            || (dd == em+38)
            // Whit Monday
            || (dd == em+49)
            // Corpus Christi
            || (dd == em+59)
            // Labour Day
            || (d == 1 && m == May)
            // National Day
            || (d == 3 && m == October)
            // Christmas Eve
            || (d == 24 && m == December)
            // Christmas
            || (d == 25 && m == December)
            // Boxing Day
            || (d == 26 && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

    bool Germany::FrankfurtStockExchangeImpl::isBusinessDay(
      const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // Labour Day
            || (d == 1 && m == May)
            // Christmas' Eve
            || (d == 24 && m == December)
            // Christmas
            || (d == 25 && m == December)
            // Christmas Day
            || (d == 26 && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

    bool Germany::XetraImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // Labour Day
            || (d == 1 && m == May)
            // Christmas' Eve
            || (d == 24 && m == December)
            // Christmas
            || (d == 25 && m == December)
            // Christmas Day
            || (d == 26 && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

    bool Germany::EurexImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // Labour Day
            || (d == 1 && m == May)
            // Christmas' Eve
            || (d == 24 && m == December)
            // Christmas
            || (d == 25 && m == December)
            // Christmas Day
            || (d == 26 && m == December)
            // New Year's Eve
            || (d == 31 && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }
    
    bool Germany::EuwaxImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if ((w == Saturday || w == Sunday)
            // New Year's Day
            || (d == 1 && m == January)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // Labour Day
            || (d == 1 && m == May)
            // Whit Monday
            || (dd == em+49)
            // Christmas' Eve
            || (d == 24 && m == December)
            // Christmas
            || (d == 25 && m == December)
            // Christmas Day
            || (d == 26 && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }
}

]]></document_content>
  </document>
  <document index="18">
    <source>calendars/hongkong.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 FIMAT Group
 Copyright (C) 2007, 2009, 2010, 2011 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/hongkong.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    HongKong::HongKong(Market m) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new HongKong::HkexImpl);
        switch (m) {
          case HKEx:
            impl_ = impl;
            break;
          default:
            QL_FAIL("unknown market");
        }
    }

    bool HongKong::HkexImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);

        if (isWeekend(w)
            // New Year's Day
            || ((d == 1 || ((d == 2) && w == Monday))
                && m == January)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // Labor Day
            || ((d == 1 || ((d == 2) && w == Monday)) && m == May)
            // SAR Establishment Day
            || ((d == 1 || ((d == 2) && w == Monday)) && m == July)
            // National Day
            || ((d == 1 || ((d == 2) && w == Monday))
                && m == October)
            // Christmas Day
            || (d == 25 && m == December)
            // Boxing Day
            || (d == 26 && m == December)
            )
            return false;

        if (y == 2004) {
            if (// Lunar New Year
                ((d==22 || d==23 || d==24) && m == January)
                // Ching Ming Festival
                || (d == 5 && m == April)
                // Buddha's birthday
                || (d == 26 && m == May)
                // Tuen Ng festival
                || (d == 22 && m == June)
                // Mid-autumn festival
                || (d == 29 && m == September)
                // Chung Yeung
                || (d == 22 && m == October))
                return false;
        }

        if (y == 2005) {
            if (// Lunar New Year
                ((d==9 || d==10 || d==11) && m == February)
                // Ching Ming Festival
                || (d == 5 && m == April)
                // Buddha's birthday
                || (d == 16 && m == May)
                // Tuen Ng festival
                || (d == 11 && m == June)
                // Mid-autumn festival
                || (d == 19 && m == September)
                // Chung Yeung festival
                || (d == 11 && m == October))
            return false;
        }

        if (y == 2006) {
            if (// Lunar New Year
                ((d >= 28 && d <= 31) && m == January)
                // Ching Ming Festival
                || (d == 5 && m == April)
                // Buddha's birthday
                || (d == 5 && m == May)
                // Tuen Ng festival
                || (d == 31 && m == May)
                // Mid-autumn festival
                || (d == 7 && m == October)
                // Chung Yeung festival
                || (d == 30 && m == October))
            return false;
        }

        if (y == 2007) {
            if (// Lunar New Year
                ((d >= 17 && d <= 20) && m == February)
                // Ching Ming Festival
                || (d == 5 && m == April)
                // Buddha's birthday
                || (d == 24 && m == May)
                // Tuen Ng festival
                || (d == 19 && m == June)
                // Mid-autumn festival
                || (d == 26 && m == September)
                // Chung Yeung festival
                || (d == 19 && m == October))
            return false;
        }

        if (y == 2008) {
            if (// Lunar New Year
                ((d >= 7 && d <= 9) && m == February)
                // Ching Ming Festival
                || (d == 4 && m == April)
                // Buddha's birthday
                || (d == 12 && m == May)
                // Tuen Ng festival
                || (d == 9 && m == June)
                // Mid-autumn festival
                || (d == 15 && m == September)
                // Chung Yeung festival
                || (d == 7 && m == October))
            return false;
        }

        if (y == 2009) {
            if (// Lunar New Year
                ((d >= 26 && d <= 28) && m == January)
                // Ching Ming Festival
                || (d == 4 && m == April)
                // Buddha's birthday
                || (d == 2 && m == May)
                // Tuen Ng festival
                || (d == 28 && m == May)
                // Mid-autumn festival
                || (d == 3 && m == October)
                // Chung Yeung festival
                || (d == 26 && m == October))
            return false;
        }

        if (y == 2010) {
            if (// Lunar New Year
                ((d == 15 || d == 16) && m == February)
                // Ching Ming Festival
                || (d == 6 && m == April)
                // Buddha's birthday
                || (d == 21 && m == May)
                // Tuen Ng festival
                || (d == 16 && m == June)
                // Mid-autumn festival
                || (d == 23 && m == September))
            return false;
        }

        if (y == 2011) {
            if (// Lunar New Year
                ((d == 3 || d == 4) && m == February)
                // Ching Ming Festival
                || (d == 5 && m == April)
                // Buddha's birthday
                || (d == 10 && m == May)
                // Tuen Ng festival
                || (d == 6 && m == June)
                // Mid-autumn festival
                || (d == 13 && m == September)
                // Chung Yeung festival
                || (d == 5 && m == October)
                // Second day after Christmas
                || (d == 27 && m == December))
            return false;
        }

        if (y == 2012) {
            if (// Lunar New Year
                (d >= 23 && d <= 25 && m == January)
                // Ching Ming Festival
                || (d == 4 && m == April)
                // Buddha's birthday
                || (d == 10 && m == May)
                // Mid-autumn festival
                || (d == 1 && m == October)
                // Chung Yeung festival
                || (d == 23 && m == October))
            return false;
        }

        if (y == 2013) {
            if (// Lunar New Year
                (d >= 11 && d <= 13 && m == February)
                // Ching Ming Festival
                || (d == 4 && m == April)
                // Buddha's birthday
                || (d == 17 && m == May)
                // Tuen Ng festival
                || (d == 12 && m == June)
                // Mid-autumn festival
                || (d == 20 && m == September)
                // Chung Yeung festival
                || (d == 14 && m == October))
            return false;
        }

        if (y == 2014) {
            if (// Lunar New Year
                ((d == 31 && m == January) || (d <= 3 && m == February))
                // Buddha's birthday
                || (d == 6 && m == May)
                // Tuen Ng festival
                || (d == 2 && m == June)
                // Mid-autumn festival
                || (d == 9 && m == September)
                // Chung Yeung festival
                || (d == 2 && m == October))
            return false;
        }

        if (y == 2015) {
            if (// Lunar New Year
                ((d == 19 && m == February) || (d == 20 && m == February))
                // The day following Easter Monday
                || (d == 7 && m == April)
                // Buddha's birthday
                || (d == 25 && m == May)
                // Tuen Ng festival
                || (d == 20 && m == June)
                // The 70th anniversary day of the victory of the Chinese 
                // people's war of resistance against Japanese aggression
                || (d == 3 && m == September)
                // Mid-autumn festival
                || (d == 28 && m == September)
                // Chung Yeung festival
                || (d == 21 && m == October))
                return false;
        }

        if (y == 2016) {
            if (// Lunar New Year
                ((d >= 8 && d <= 10) && m == February)
                // Ching Ming Festival
                || (d == 4 && m == April)
                // Tuen Ng festival
                || (d == 9 && m == June)
                // Mid-autumn festival
                || (d == 16 && m == September)
                // Chung Yeung festival
                || (d == 10 && m == October)
                // Second day after Christmas
                || (d == 27 && m == December))
                return false;
        }

        if (y == 2017) {
            if (// Lunar New Year
                ((d == 30 || d == 31) && m == January)
                // Ching Ming Festival
                || (d == 4 && m == April)
                // Buddha's birthday
                || (d == 3 && m == May)
                // Tuen Ng festival
                || (d == 30 && m == May)
                // Mid-autumn festival
                || (d == 5 && m == October))
                return false;
        }

        if (y == 2018) {
            if (// Lunar New Year
                ((d == 16 && m == February) || (d == 19 && m == February))
                // Ching Ming Festival
                || (d == 5 && m == April)
                // Buddha's birthday
                || (d == 22 && m == May)
                // Tuen Ng festival
                || (d == 18 && m == June)
                // Mid-autumn festival
                || (d == 25 && m == September)
                // Chung Yeung festival
                || (d == 17 && m == October))
                return false;
        }

        if (y == 2019) {
           if (// Lunar New Year
               ((d >= 5 && d <= 7) && m == February)
               // Ching Ming Festival
               || (d == 5 && m == April)
               // Tuen Ng festival
               || (d == 7 && m == June)
               // Chung Yeung festival
               || (d == 7 && m == October))
               return false;
        }

        if (y == 2020) {
           if (// Lunar New Year
               ((d == 27 || d == 28) && m == January)
               // Ching Ming Festival
               || (d == 4 && m == April)
               // Buddha's birthday
               || (d == 30 && m == April)
               // Tuen Ng festival
               || (d == 25 && m == June)
               // Mid-autumn festival
               || (d == 2 && m == October)
               // Chung Yeung festival
               || (d == 26 && m == October))
               return false;
        }

        // data from https://www.hkex.com.hk/-/media/hkex-market/services/circulars-and-notices/participant-and-members-circulars/sehk/2020/ce_sehk_ct_038_2020.pdf
        if (y == 2021)
        {
            if (// Lunar New Year
                ((d == 12 || d == 15) && m == February)
                // Ching Ming Festival
                || (d == 5 && m == April)
                // Buddha's birthday
                || (d == 19 && m == May)
                // Tuen Ng festival
                || (d == 14 && m == June)
                // Mid-autumn festival
                || (d == 22 && m == September)
                // Chung Yeung festival
                || (d == 14 && m == October))
                return false;
        }

        // data from https://www.hkex.com.hk/-/media/HKEX-Market/Services/Circulars-and-Notices/Participant-and-Members-Circulars/SEHK/2021/ce_SEHK_CT_082_2021.pdf
        if (y == 2022)
        {
            if (// Lunar New Year
                ((d >= 1 && d <= 3) && m == February)
                // Ching Ming Festival
                || (d == 5 && m == April)
                // Buddha's birthday
                || (d == 9 && m == May)
                // Tuen Ng festival
                || (d == 3 && m == June)
                // Mid-autumn festival
                || (d == 12 && m == September)
                // Chung Yeung festival
                || (d == 4 && m == October))
                return false;
        }

        // data from https://www.hkex.com.hk/-/media/HKEX-Market/Services/Circulars-and-Notices/Participant-and-Members-Circulars/SEHK/2022/ce_SEHK_CT_058_2022.pdf
        if (y == 2023)
        {
            if (// Lunar New Year
                ((d >= 23 && d <= 25) && m == January)
                // Ching Ming Festival
                || (d == 5 && m == April)
                // Buddha's birthday
                || (d == 26 && m == May)
                // Tuen Ng festival
                || (d == 22 && m == June)
                // Chung Yeung festival
                || (d == 23 && m == October))
                return false;
        }

        // data from https://www.hkex.com.hk/-/media/HKEX-Market/Services/Circulars-and-Notices/Participant-and-Members-Circulars/SEHK/2023/ce_SEHK_CT_079_2023.pdf
        if (y == 2024) {
            if (// Lunar New Year
                ((d == 12 || d == 13) && m == February)
                // Ching Ming Festival
                || (d == 4 && m == April)
                // Buddha's birthday
                || (d == 15 && m == May)
                // Tuen Ng festival
                || (d == 10 && m == June)
                // Mid-autumn festival
                || (d == 18 && m == September)
                // Chung Yeung festival
                || (d == 11 && m == October))
                return false;
        }

        // data from https://www.hkex.com.hk/-/media/HKEX-Market/Services/Circulars-and-Notices/Participant-and-Members-Circulars/SEHK/2024/ce_SEHK_CT_063_2024.pdf
        if (y == 2025) {
            if (// Lunar New Year
                ((d >= 29 && d <= 31) && m == January)
                // Ching Ming Festival
                || (d == 4 && m == April)
                // Buddha's birthday
                || (d == 5 && m == May)
                // Mid-autumn festival
                || (d == 7 && m == October)
                // Chung Yeung festival
                || (d == 29 && m == October))
                return false;
        }

        return true;
    }

}
]]></document_content>
  </document>
  <document index="19">
    <source>calendars/hungary.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/hungary.hpp>

namespace QuantLib {

    Hungary::Hungary() {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new Hungary::Impl);
        impl_ = impl;
    }

    bool Hungary::Impl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // Good Friday (since 2017)
            || (dd == em - 3 && y >= 2017)
            // Easter Monday
            || (dd == em)
            // Whit Monday
            || (dd == em+49)
            // New Year's Day
            || (d == 1  && m == January)
            // National Day
            || (d == 15  && m == March)
            // Labour Day
            || (d == 1  && m == May)
            // Constitution Day
            || (d == 20  && m == August)
            // Republic Day
            || (d == 23  && m == October)
            // All Saints Day
            || (d == 1  && m == November)
            // Christmas
            || (d == 25 && m == December)
            // 2nd Day of Christmas
            || (d == 26 && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="20">
    <source>calendars/iceland.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/iceland.hpp>

namespace QuantLib {

    Iceland::Iceland(Market) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new Iceland::IcexImpl);
        impl_ = impl;
    }

    bool Iceland::IcexImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Holy Thursday
            || (dd == em-4)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // First day of Summer
            || (d >= 19 && d <= 25 && w == Thursday && m == April)
            // Ascension Thursday
            || (dd == em+38)
            // Pentecost Monday
            || (dd == em+49)
            // Labour Day
            || (d == 1 && m == May)
            // Independence Day
            || (d == 17 && m == June)
            // Commerce Day
            || (d <= 7 && w == Monday && m == August)
            // Christmas
            || (d == 25 && m == December)
            // Boxing Day
            || (d == 26 && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="21">
    <source>calendars/india.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2007, 2008, 2009, 2010, 2011 StatPro Italia srl
 Copyright (C) 2023, 2024 Skandinaviska Enskilda Banken AB (publ)

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/india.hpp>

namespace QuantLib {

    India::India(Market) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new India::NseImpl);
        impl_ = impl;
    }

    bool India::NseImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();
        Day dd = date.dayOfYear();
        Day em = easterMonday(y);

        if (isWeekend(w)
            // Republic Day
            || (d == 26 && m == January)
            // Good Friday
            || (dd == em-3)
            // Ambedkar Jayanti
            || (d == 14 && m == April)
            // May Day
            || (d == 1 && m == May)
            // Independence Day
            || (d == 15 && m == August)
            // Gandhi Jayanti
            || (d == 2 && m == October)
            // Christmas
            || (d == 25 && m == December)
            )
            return false;

        if (y == 2005) {
            // Moharram, Holi, Maharashtra Day, and Ramzan Id fall
            // on Saturday or Sunday in 2005
            if (// Bakri Id
                (d == 21 && m == January)
                // Ganesh Chaturthi
                || (d == 7 && m == September)
                // Dasara
                || (d == 12 && m == October)
                // Laxmi Puja
                || (d == 1 && m == November)
                // Bhaubeej
                || (d == 3 && m == November)
                // Guru Nanak Jayanti
                || (d == 15 && m == November)
                )
                return false;
        }

        if (y == 2006) {
            if (// Bakri Id
                (d == 11 && m == January)
                // Moharram
                || (d == 9 && m == February)
                // Holi
                || (d == 15 && m == March)
                // Ram Navami
                || (d == 6 && m == April)
                // Mahavir Jayanti
                || (d == 11 && m == April)
                // Maharashtra Day
                || (d == 1 && m == May)
                // Bhaubeej
                || (d == 24 && m == October)
                // Ramzan Id
                || (d == 25 && m == October)
                )
                return false;
        }

        if (y == 2007) {
            if (// Bakri Id
                (d == 1 && m == January)
                // Moharram
                || (d == 30 && m == January)
                // Mahashivratri
                || (d == 16 && m == February)
                // Ram Navami
                || (d == 27 && m == March)
                // Maharashtra Day
                || (d == 1 && m == May)
                // Buddha Pournima
                || (d == 2 && m == May)
                // Laxmi Puja
                || (d == 9 && m == November)
                // Bakri Id (again)
                || (d == 21 && m == December)
                )
                return false;
        }

        if (y == 2008) {
            if (// Mahashivratri
                (d == 6 && m == March)
                // Id-E-Milad
                || (d == 20 && m == March)
                // Mahavir Jayanti
                || (d == 18 && m == April)
                // Maharashtra Day
                || (d == 1 && m == May)
                // Buddha Pournima
                || (d == 19 && m == May)
                // Ganesh Chaturthi
                || (d == 3 && m == September)
                // Ramzan Id
                || (d == 2 && m == October)
                // Dasara
                || (d == 9 && m == October)
                // Laxmi Puja
                || (d == 28 && m == October)
                // Bhau bhij
                || (d == 30 && m == October)
                // Gurunanak Jayanti
                || (d == 13 && m == November)
                // Bakri Id
                || (d == 9 && m == December)
                )
                return false;
        }

        if (y == 2009) {
            if (// Moharram
                (d == 8 && m == January)
                // Mahashivratri
                || (d == 23 && m == February)
                // Id-E-Milad
                || (d == 10 && m == March)
                // Holi
                || (d == 11 && m == March)
                // Ram Navmi
                || (d == 3 && m == April)
                // Mahavir Jayanti
                || (d == 7 && m == April)
                // Maharashtra Day
                || (d == 1 && m == May)
                // Ramzan Id
                || (d == 21 && m == September)
                // Dasara
                || (d == 28 && m == September)
                // Bhau Bhij
                || (d == 19 && m == October)
                // Gurunanak Jayanti
                || (d == 2 && m == November)
                // Moharram (again)
                || (d == 28 && m == December)
                )
                return false;
        }

        if (y == 2010) {
            if (// New Year's Day
                (d == 1 && m == January)
                // Mahashivratri
                || (d == 12 && m == February)
                // Holi
                || (d == 1 && m == March)
                // Ram Navmi
                || (d == 24 && m == March)
                // Ramzan Id
                || (d == 10 && m == September)
                // Laxmi Puja
                || (d == 5 && m == November)
                // Bakri Id
                || (d == 17 && m == November)
                // Moharram
                || (d == 17 && m == December)
                )
                return false;
        }

        if (y == 2011) {
            if (// Mahashivratri
                (d == 2 && m == March)
                // Ram Navmi
                || (d == 12 && m == April)
                // Ramzan Id
                || (d == 31 && m == August)
                // Ganesh Chaturthi
                || (d == 1 && m == September)
                // Dasara
                || (d == 6 && m == October)
                // Laxmi Puja
                || (d == 26 && m == October)
                // Diwali - Balipratipada
                || (d == 27 && m == October)
                // Bakri Id
                || (d == 7 && m == November)
                // Gurunanak Jayanti
                || (d == 10 && m == November)
                // Moharram
                || (d == 6 && m == December)
                )
                return false;
        }

        if (y == 2012) {
            if (// Mahashivratri
                (d == 20 && m == February)
                // Holi
                || (d == 8 && m == March)
                // Mahavir Jayanti
                || (d == 5 && m == April)
                // Ramzan Id
                || (d == 20 && m == August)
                // Ganesh Chaturthi
                || (d == 19 && m == September)
                // Dasara
                || (d == 24 && m == October)
                // Diwali - Balipratipada
                || (d == 14 && m == November)
                // Gurunanak Jayanti
                || (d == 28 && m == November)
                )
                return false;
        }

        if (y == 2013) {
            if (// Holi
                (d == 27 && m == March)
                // Ram Navmi
                || (d == 19 && m == April)
                // Mahavir Jayanti
                || (d == 24 && m == April)
                // Ramzan Id
                || (d == 9 && m == August)
                // Ganesh Chaturthi
                || (d == 9 && m == September)
                // Bakri Id
                || (d == 16 && m == October)
                // Diwali - Balipratipada
                || (d == 4 && m == November)
                // Moharram
                || (d == 14 && m == November)
                )
                return false;
        }

        if (y == 2014) {
            if (// Mahashivratri
                (d == 27 && m == February)
                // Holi
                || (d == 17 && m == March)
                // Ram Navmi
                || (d == 8 && m == April)
                // Ramzan Id
                || (d == 29 && m == July)
                // Ganesh Chaturthi
                || (d == 29 && m == August)
                // Dasera
                || (d == 3 && m == October)
                // Bakri Id
                || (d == 6 && m == October)
                // Diwali - Balipratipada
                || (d == 24 && m == October)
                // Moharram
                || (d == 4 && m == November)
                // Gurunank Jayanti
                || (d == 6 && m == November)
                )
                return false;
        }

      if (y == 2019) {
          if (// Chatrapati Shivaji Jayanti
              (d == 19 && m == February)
              // Mahashivratri
              || (d == 4 && m == March)
              // Holi
              || (d == 21 && m == March)
              // Annual Bank Closing
              || (d == 1 && m == April)
              // Mahavir Jayanti
              || (d == 17 && m == April)
              // Parliamentary Elections
              || (d == 29 && m == April)
              // Ramzan Id
              || (d == 05 && m == June)
              // Bakri Id
              || (d == 12 && m == August)
              // Ganesh Chaturthi
              || (d == 2 && m == September)
              // Moharram
              || (d == 10 && m == September)
              // Dasera
              || (d == 8 && m == October)
              // General Assembly Elections in Maharashtra
              || (d == 21 && m == October)
              // Diwali - Balipratipada
              || (d == 28 && m == October)
              // Gurunank Jayanti
              || (d == 12 && m == November)
              )
              return false;
      }

      if (y == 2020) {
          if (// Chatrapati Shivaji Jayanti
              (d == 19 && m == February)
              // Mahashivratri
              || (d == 21 && m == February)
              // Holi
              || (d == 10 && m == March)
              // Gudi Padwa
              || (d == 25 && m == March)
              // Annual Bank Closing
              || (d == 1 && m == April)
              // Ram Navami
              || (d == 2 && m == April)
              // Mahavir Jayanti
              || (d == 6 && m == April)
              // Buddha Pournima
              || (d == 7 && m == May)
              // Ramzan Id
              || (d == 25 && m == May)
              // Id-E-Milad
              || (d == 30 && m == October)
              // Diwali - Balipratipada
              || (d == 16 && m == November)
              // Gurunank Jayanti
              || (d == 30 && m == November)
              )
              return false;
      }

        if (y == 2021) {
            if (// Chatrapati Shivaji Jayanti
                (d == 19 && m == February)
                // Mahashivratri
                || (d == 11 && m == March)
                // Holi
                || (d == 29 && m == March) 
                // Gudi Padwa
                || (d == 13 && m == April)
                // Mahavir Jayanti
                || (d == 14 && m == April)
                // Ram Navami
                || (d == 21 && m == April)
                // Buddha Pournima
                || (d == 26 && m == May)
                // Bakri Id
                || (d == 21 && m == July)
                // Ganesh Chaturthi
                || (d == 10 && m == September)
                // Dasera
                || (d == 15 && m == October)
                // Id-E-Milad
                || (d == 19 && m == October)
                // Diwali - Balipratipada
                || (d == 5 && m == November)
                // Gurunank Jayanti
                || (d == 19 && m == November))
                return false;
        }

        if (y == 2022) {
            if ( // Mahashivratri
                (d == 1 && m == March)
                // Holi
                || (d == 18 && m == March)
                // Ramzan Id
                || (d == 3 && m == May)
                // Buddha Pournima
                || (d == 16 && m == May)
                // Ganesh Chaturthi
                || (d == 31 && m == August)
                // Dasera
                || (d == 5 && m == October)
                // Diwali - Balipratipada
                || (d == 26 && m == October)
                // Gurunank Jayanti
                || (d == 8 && m == November))
                return false;
        }

        if (y == 2023) {
            if ( 
                // Holi
                (d == 7 && m == March)
                // Gudi Padwa
                || (d == 22 && m == March)
                // Ram Navami
                || (d == 30 && m == March)
                // Mahavir Jayanti
                || (d == 4 && m == April)
                // Buddha Pournima
                || (d == 5 && m == May)
                // Bakri Id
                || (d == 29 && m == June)
                // Parsi New year
                || (d == 16 && m == August)
                // Ganesh Chaturthi
                || (d == 19 && m == September)
                // Id-E-Milad (was moved to Friday 29th)
                || (d == 29 && m == September)
                // Dasera
                || (d == 24 && m == October)
                // Diwali - Balipratipada
                || (d == 14 && m == November)
                // Gurunank Jayanti
                || (d == 27 && m == November))
                return false;
        }

        if (y == 2024) {
            if ( // Special holiday
                (d == 22 && m == January)
                // Chatrapati Shivaji Jayanti
                || (d == 19 && m == February)
                // Mahashivratri
                || (d == 8 && m == March)
                // Holi
                || (d == 25 && m == March)
                // Annual Bank Closing
                || (d == 1 && m == April)
                // Gudi Padwa
                || (d == 9 && m == April)
                // Id-Ul-Fitr (Ramadan Eid)
                || (d == 11 && m == April)
                // Ram Navami
                || (d == 17 && m == April)
                // Mahavir Jayanti
                || (d == 21 && m == April)
                // General Parliamentary Elections
                || (d == 20 && m == May)
                // Buddha Pournima
                || (d == 23 && m == May)
                // Bakri Eid
                || (d == 17 && m == June)
                // Moharram
                || (d == 17 && m == July)
                // Eid-E-Milad (estimated Sunday 15th or Monday 16th)
                || (d == 16 && m == September)
                // Diwali-Laxmi Pujan
                || (d == 1 && m == November)
                // Gurunank Jayanti
                || (d == 15 && m == November))
                return false;
        }

        if (y == 2025) {
            if ( // Chatrapati Shivaji Jayanti
                (d == 19 && m == February)
                // Mahashivratri
                || (d == 26 && m == February)
                // Holi
                || (d == 14 && m == March)
                // Ramzan Id (estimated Sunday 30th or Monday 31st)
                || (d == 31  && m == March)
                // Mahavir Jayanti
                || (d == 10 && m == April)
                // Buddha Pournima
                || (d == 12 && m == May)
                // Id-E-Milad (estimated Thursday 4th or Friday 5th)
                || (d == 5 && m == September)
                // Diwali - Balipratipada
                || (d == 22 && m == October)
                // Gurunank Jayanti
                || (d == 5 && m == November))
                return false;
        }

     return true;
    }

}

]]></document_content>
  </document>
  <document index="22">
    <source>calendars/indonesia.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2007, 2008, 2009, 2010, 2011 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/indonesia.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    Indonesia::Indonesia(Market market) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> bejImpl(
                                                      new Indonesia::BejImpl);
        switch (market) {
          case BEJ:
          case JSX:
          case IDX:
            impl_ = bejImpl;
            break;
          default:
            QL_FAIL("unknown market");
        }
    }

    bool Indonesia::BejImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();
        Day dd = date.dayOfYear();
        Day em = easterMonday(y);

        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Good Friday
            || (dd == em-3)
            // Ascension Thursday
            || (dd == em+38)
            // Independence Day
            || (d == 17 && m == August)
            // Christmas
            || (d == 25 && m == December)
            )
            return false;

        if (y == 2005) {
            if (// Idul Adha
                (d == 21 && m == January)
                // Imlek
                || (d == 9 && m == February)
                // Moslem's New Year Day
                || (d == 10 && m == February)
                // Nyepi
                || (d == 11 && m == March)
                // Birthday of Prophet Muhammad SAW
                || (d == 22 && m == April)
                // Waisak
                || (d == 24 && m == May)
                // Ascension of Prophet Muhammad SAW
                || (d == 2 && m == September)
                // Idul Fitri
                || ((d == 3 || d == 4) && m == November)
                // National leaves
                || ((d == 2 || d == 7 || d == 8) && m == November)
                || (d == 26 && m == December)
                )
                return false;
        }

        if (y == 2006) {
            if (// Idul Adha
                (d == 10 && m == January)
                // Moslem's New Year Day
                || (d == 31 && m == January)
                // Nyepi
                || (d == 30 && m == March)
                // Birthday of Prophet Muhammad SAW
                || (d == 10 && m == April)
                // Ascension of Prophet Muhammad SAW
                || (d == 21 && m == August)
                // Idul Fitri
                || ((d == 24 || d == 25) && m == October)
                // National leaves
                || ((d == 23 || d == 26 || d == 27) && m == October)
                )
                return false;
        }

        if (y == 2007) {
            if (// Nyepi
                (d == 19 && m == March)
                // Waisak
                || (d == 1 && m == June)
                // Ied Adha
                || (d == 20 && m == December)
                // National leaves
                || (d == 18 && m == May)
                || ((d == 12 || d == 15 || d == 16) && m == October)
                || ((d == 21 || d == 24) && m == October)
                )
                return false;
        }

        if (y == 2008) {
            if (// Islamic New Year
                ((d == 10 || d == 11) && m == January)
                // Chinese New Year
                || ((d == 7 || d == 8) && m == February)
                // Saka's New Year
                || (d == 7 && m == March)
                // Birthday of the prophet Muhammad SAW
                || (d == 20 && m == March)
                // Vesak Day
                || (d == 20 && m == May)
                // Isra' Mi'raj of the prophet Muhammad SAW
                || (d == 30 && m == July)
                // National leave
                || (d == 18 && m == August)
                // Ied Fitr
                || (d == 30 && m == September)
                || ((d == 1 || d == 2 || d == 3) && m == October)
                // Ied Adha
                || (d == 8 && m == December)
                // Islamic New Year
                || (d == 29 && m == December)
                // New Year's Eve
                || (d == 31 && m == December)
                )
                return false;
        }

        if (y == 2009) {
            if (// Public holiday
                (d == 2 && m == January)
                // Chinese New Year
                || (d == 26 && m == January)
                // Birthday of the prophet Muhammad SAW
                || (d == 9 && m == March)
                // Saka's New Year
                || (d == 26 && m == March)
                // National leave
                || (d == 9 && m == April)
                // Isra' Mi'raj of the prophet Muhammad SAW
                || (d == 20 && m == July)
                // Ied Fitr
                || (d >= 18 && d <= 23 && m == September)
                // Ied Adha
                || (d == 27 && m == November)
                // Islamic New Year
                || (d == 18 && m == December)
                // Public Holiday
                || (d == 24 && m == December)
                // Trading holiday
                || (d == 31 && m == December)
                )
                return false;
        }

        if (y == 2010) {
            if (// Birthday of the prophet Muhammad SAW
                   (d == 26 && m == February)
                // Saka's New Year
                || (d == 16 && m == March)
                // Birth of Buddha
                || (d == 28 && m == May)
                // Ied Fitr
                || (d >= 8 && d <= 14 && m == September)
                // Ied Adha
                || (d == 17 && m == November)
                // Islamic New Year
                || (d == 7 && m == December)
                // Public Holiday
                || (d == 24 && m == December)
                // Trading holiday
                || (d == 31 && m == December)
                )
                return false;
        }

        if (y == 2011) {
            if (// Chinese New Year
                   (d == 3 && m == February)
                // Birthday of the prophet Muhammad SAW
                || (d == 15 && m == February)
                // Birth of Buddha
                || (d == 17 && m == May)
                // Isra' Mi'raj of the prophet Muhammad SAW
                || (d == 29 && m == June)
                // Ied Fitr
                || (d >= 29 && m == August)
                || (d <= 2 && m == September)
                // Public Holiday
                || (d == 26 && m == December)
                )
                return false;
        }

        if (y == 2012) {
            if (// Chinese New Year
                (d == 23 && m == January)
                // Saka New Year
                || (d == 23 && m == March)
                // Ied ul-Fitr
                || (d >= 20 && d <= 22 && m == August)
                // Eid ul-Adha
                || (d == 26 && m == October)
                // Islamic New Year
                || (d >= 15 && d <= 16 && m == November)
                // Public Holiday
                || (d == 24 && m == December)
                // Trading Holiday
                || (d == 31 && m == December)
                )
                return false;
        }

        if (y == 2013) {
            if (// Birthday of the prophet Muhammad SAW
                (d == 24 && m == January)
                // Saka New Year
                || (d == 12 && m == March)
                // Isra' Mi'raj of the prophet Muhammad SAW
                || (d == 6 && m == June)
                // Ied ul-Fitr
                || (d >= 5 && d <= 9 && m == August)
                // Eid ul-Adha
                || (d >= 14 && d <= 15 && m == October)
                // Islamic New Year
                || (d == 5 && m == November)
                // Public Holiday
                || (d == 26 && m == December)
                // Trading Holiday
                || (d == 31 && m == December)
                )
                return false;
        }

        if (y == 2014) {
            if (// Birthday of the prophet Muhammad SAW
                (d == 14 && m == January)
                // Chinese New Year
                || (d == 31 && m == January)
                // Saka New Year
                || (d == 31 && m == March)
                // Labour Day
                || (d == 1 && m == May)
                // Birth of Buddha
                || (d == 15 && m == May)
                // Isra' Mi'raj of the prophet Muhammad SAW
                || (d == 27 && m == May)
                // Ascension Day of Jesus Christ
                || (d == 29 && m == May)
                // Ied ul-Fitr
                || ((d >= 28 && m == July) || (d == 1 && m == August))
                // Public Holiday
                || (d == 26 && m == December)
                // Trading Holiday
                || (d == 31 && m == December)
                )
                return false;
        }

        return true;
    }

}

]]></document_content>
  </document>
  <document index="23">
    <source>calendars/israel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Paolo Mazzocchi
 Copyright (C) 2015 Riccardo Barone

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/israel.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    namespace {

        bool isPurim(const Date& d) {
            static std::set<Date> knownDates = {
                {21, March,    2000},
                {9,  March,    2001},
                {26, February, 2002},
                {18, March,    2003},
                {7,  March,    2004},
                {25, March,    2005},
                {14, March,    2006},
                {4,  March,    2007},
                {21, March,    2008},
                {10, March,    2009},
                {28, February, 2010},
                {20, March,    2011},
                {8,  March,    2012},
                {24, February, 2013},
                {16, March,    2014},
                {05, March,    2015},
                {24, March,    2016},
                {12, March,    2017},
                {1,  March,    2018},
                {21, March,    2019},
                {10, March,    2020},
                {26, February, 2021},
                {17, March,    2022},
                {7,  March,    2023},
                {24, March,    2024},
                {14, March,    2025},
                {3,  March,    2026},
                {23, March,    2027},
                {12, March,    2028},
                {1,  March,    2029},
                {19, March,    2030},
                {9,  March,    2031},
                {26, February, 2032},
                {15, March,    2033},
                {5,  March,    2034},
                {25, March,    2035},
                {13, March,    2036},
                {1,  March,    2037},
                {21, March,    2038},
                {10, March,    2039},
                {28, February, 2040},
                {17, March,    2041},
                {6,  March,    2042},
                {26, March,    2043},
                {13, March,    2044},
                {3,  March,    2045},
                {22, March,    2046},
                {12, March,    2047},
                {28, February, 2048},
                {18, March,    2049},
                {8,  March,    2050},
            };
            return knownDates.find(d) != knownDates.end();
        }

        bool isPassover1st(const Date& d) {
            static std::set<Date> knownDates = {
                {20, April, 2000},
                {8,  April, 2001},
                {28, March, 2002},
                {17, April, 2003},
                {6,  April, 2004},
                {24, April, 2005},
                {13, April, 2006},
                {3,  April, 2007},
                {20, April, 2008},
                {9,  April, 2009},
                {30, March, 2010},
                {19, April, 2011},
                {7,  April, 2012},
                {26, March, 2013},
                {15, April, 2014},
                {4,  April, 2015},
                {23, April, 2016},
                {11, April, 2017},
                {31, March, 2018},
                {20, April, 2019},
                {9,  April, 2020},
                {28, March, 2021},
                {16, April, 2022},
                {6 , April, 2023},
                {23, April, 2024},
                {13, April, 2025},
                {2 , April, 2026},
                {22, April, 2027},
                {11, April, 2028},
                {31, March, 2029},
                {18, April, 2030},
                {8,  April, 2031},
                {27, March, 2032},
                {14, April, 2033},
                {4,  April, 2034},
                {24, April, 2035},
                {12, April, 2036},
                {31, March, 2037},
                {20, April, 2038},
                {9,  April, 2039},
                {29, March, 2040},
                {16, April, 2041},
                {5,  April, 2042},
                {25, April, 2043},
                {12, April, 2044},
                {2,  April, 2045},
                {21, April, 2046},
                {11, April, 2047},
                {29, March, 2048},
                {17, April, 2049},
                {7,  April, 2050},
            };
            return knownDates.find(d) != knownDates.end();
        }

        bool isIndependenceDay(const Date& d) {
            static std::set<Date> knownDates = {
                {10, May,   2000},
                {26, April, 2001},
                {17, April, 2002},
                {7,  May,   2003},
                {27, April, 2004},
                {12, May,   2005},
                {3,  May,   2006},
                {24, April, 2007},
                {8,  May,   2008},
                {29, April, 2009},
                {20, April, 2010},
                {10, May,   2011},
                {26, April, 2012},
                {16, April, 2013},
                {6,  May,   2014},
                {23, April, 2015},
                {12, May,   2016},
                {2,  May,   2017},
                {19, April, 2018},
                {9,  May,   2019},
                {29, April, 2020},
                {15, April, 2021},
                {5,  May,   2022},
                {26, April, 2023},
                {14, May,   2024},
                {1,  May,   2025},
                {22, April, 2026},
                {12, May,   2027},
                {2,  May,   2028},
                {19, April, 2029},
                {8,  May,   2030},
                {29, April, 2031},
                {15, April, 2032},
                {4,  May,   2033},
                {25, April, 2034},
                {15, May,   2035},
                {1,  May,   2036},
                {21, April, 2037},
                {10, May,   2038},
                {28, April, 2039},
                {18, April, 2040},
                {7,  May,   2041},
                {24, April, 2042},
                {14, May,   2043},
                {3,  May,   2044},
                {20, April, 2045},
                {10, May,   2046},
                {1,  May,   2047},
                {16, April, 2048},
                {6,  May,   2049},
                {27, April, 2050},
            };
            return knownDates.find(d) != knownDates.end();
        }

        bool isMemorialDay(const Date& d) {
            return isIndependenceDay(d+1);
        }

        bool isShavuot(const Date& d) {
            static std::set<Date> knownDates = {
                {9,  June, 2000},
                {28, May,  2001},
                {17, May,  2002},
                {6,  June, 2003},
                {26, May,  2004},
                {13, June, 2005},
                {2,  June, 2006},
                {23, May,  2007},
                {9,  June, 2008},
                {29, May,  2009},
                {19, May,  2010},
                {8,  June, 2011},
                {27, May,  2012},
                {15, May,  2013},
                {4,  June, 2014},
                {24, May,  2015},
                {12, June, 2016},
                {31, May,  2017},
                {20, May,  2018},
                {9,  June, 2019},
                {29, May,  2020},
                {17, May,  2021},
                {5,  June, 2022},
                {26, May,  2023},
                {12, June, 2024},
                {2,  June, 2025},
                {22, May,  2026},
                {11, June, 2027},
                {31, May,  2028},
                {20, May,  2029},
                {7,  June, 2030},
                {28, May,  2031},
                {16, May,  2032},
                {3,  June, 2033},
                {24, May,  2034},
                {13, June, 2035},
                {1,  June, 2036},
                {20, May,  2037},
                {9,  June, 2038},
                {29, May,  2039},
                {18, May,  2040},
                {5,  June, 2041},
                {25, May,  2042},
                {14, June, 2043},
                {1,  June, 2044},
                {22, May,  2045},
                {10, June, 2046},
                {31, May,  2047},
                {18, May,  2048},
                {6,  June, 2049},
                {27, May,  2050},
            };
            return knownDates.find(d) != knownDates.end();
        }

        bool isFastDay(const Date& d) {
            static std::set<Date> knownDates = {
                {10, August, 2000},
                {29, July,   2001},
                {18, July,   2002},
                {7,  August, 2003},
                {27, July,   2004},
                {14, August, 2005},
                {3,  August, 2006},
                {24, July,   2007},
                {10, August, 2008},
                {30, July,   2009},
                {20, July,   2010},
                {9,  August, 2011},
                {29, July,   2012},
                {16, July,   2013},
                {5,  August, 2014},
                {26, July,   2015},
                {14, August, 2016},
                {1,  August, 2017},
                {22, July,   2018},
                {11, August, 2019},
                {30, July,   2020},
                {18, July,   2021},
                {7,  August, 2022},
                {27, July,   2023},
                {13, August, 2024},
                {3,  August, 2025},
                {23, July,   2026},
                {12, August, 2027},
                {1,  August, 2028},
                {22, July,   2029},
                {8,  August, 2030},
                {29, July,   2031},
                {18, July,   2032},
                {4,  August, 2033},
                {25, July,   2034},
                {14, August, 2035},
                {3,  August, 2036},
                {21, July,   2037},
                {10, August, 2038},
                {31, July,   2039},
                {19, July,   2040},
                {6,  August, 2041},
                {27, July,   2042},
                {16, August, 2043},
                {2,  August, 2044},
                {23, July,   2045},
                {12, August, 2046},
                {1,  August, 2047},
                {19, July,   2048},
                {8,  August, 2049},
                {28, July,   2050},
            };
            return knownDates.find(d) != knownDates.end();
        }

        bool isNewYearsDay(const Date& d) {
            static std::set<Date> knownDates = {
                {30, September, 2000},
                {17, September, 2001},
                {7,  September, 2002},
                {27, September, 2003},
                {16, September, 2004},
                {4,  October,   2005},
                {23, September, 2006},
                {13, September, 2007},
                {30, September, 2008},
                {19, September, 2009},
                {9,  September, 2010},
                {29, September, 2011},
                {17, September, 2012},
                {5,  September, 2013},
                {25, September, 2014},
                {14, September, 2015},
                {3,  October,   2016},
                {21, September, 2017},
                {10, September, 2018},
                {30, September, 2019},
                {19, September, 2020},
                {7,  September, 2021},
                {26, September, 2022},
                {16, September, 2023},
                {3,  October,   2024},
                {23, September, 2025},
                {12, September, 2026},
                {2,  October,   2027},
                {21, September, 2028},
                {10, September, 2029},
                {28, September, 2030},
                {18, September, 2031},
                {6,  September, 2032},
                {24, September, 2033},
                {14, September, 2034},
                {4,  October,   2035},
                {22, September, 2036},
                {10, September, 2037},
                {30, September, 2038},
                {19, September, 2039},
                {8,  September, 2040},
                {26, September, 2041},
                {15, September, 2042},
                {5,  October,   2043},
                {22, September, 2044},
                {12, September, 2045},
                {1,  October,   2046},
                {21, September, 2047},
                {8,  September, 2048},
                {27, September, 2049},
                {17, September, 2050},
            };
            return knownDates.find(d) != knownDates.end();
        }

        bool isYomKippur(const Date& d) {
            return isNewYearsDay(d-9);
        }

        bool isSukkot(const Date& d) {
            return isYomKippur(d-5);
        }

        bool isSimchatTorah(const Date& d) {
            return isSukkot(d-7);
        }

    }


    class Israel::TelAvivImpl final : public Calendar::Impl {
      public:
        std::string name() const override { return "Tel Aviv stock exchange"; }
        bool isWeekend(Weekday) const override;
        bool isBusinessDay(const Date&) const override;
    };

    class Israel::ShirImpl final : public Calendar::WesternImpl {
      public:
        std::string name() const override { return "SHIR fixing calendar"; }
        bool isBusinessDay(const Date&) const override;
    };

    Israel::Israel(Israel::Market market) {
        // all calendar instances share the same implementation instance
        static auto telAvivImpl = ext::make_shared<Israel::TelAvivImpl>();
        static auto shirImpl = ext::make_shared<Israel::ShirImpl>();
        switch (market) {
        case Settlement:
        case TASE:
            impl_ = telAvivImpl;
            break;
        case SHIR:
            impl_ = shirImpl;
            break;
        default:
            QL_FAIL("unknown market");
        }
    }

    bool Israel::TelAvivImpl::isWeekend(Weekday w) const {
        return w == Friday || w == Saturday;
    }

    bool Israel::TelAvivImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Year y = date.year();

        if (isWeekend(w)
            || isPurim(date)
            || (y <= 2020 && isPassover1st(date+1)) // Eve of Passover, until 2020
            || isPassover1st(date)
            || isPassover1st(date-5) // Eve of Passover VII, until 2020
            || isPassover1st(date-6) // Passover VII
            || isMemorialDay(date)
            || isIndependenceDay(date)
            || (y <= 2020 && isShavuot(date+1)) // Eve of Shavuot, until 2020
            || isShavuot(date)
            || isFastDay(date)
            || (y <= 2019 && isNewYearsDay(date+1))  // Eve of new year, until 2019
            || isNewYearsDay(date)
            || isNewYearsDay(date-1)  // 2nd day of new year
            || isYomKippur(date+1) // Eve of Yom Kippur
            || isYomKippur(date)
            || isSukkot(date+1)  // Eve of Sukkot
            || isSukkot(date)
            || isSimchatTorah(date+1)  // Eve of Simchat Torah
            || isSimchatTorah(date))
            return false; // NOLINT(readability-simplify-boolean-expr)

        return true;
    }

    bool Israel::ShirImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Day dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();

        if (isWeekend(w)
            || isPurim(date)
            || isPurim(date-1) // Purim (Jerusalem)
            || isPassover1st(date+1) // Eve of Passover
            || isPassover1st(date)
            || isPassover1st(date-6) // Last day of Passover
            || isIndependenceDay(date)
            || isShavuot(date)
            || isFastDay(date)
            || isNewYearsDay(date+1)  // Eve of new year, until 2019
            || isNewYearsDay(date)
            || isNewYearsDay(date-1)  // 2nd day of new year
            || isYomKippur(date+1) // Eve of Yom Kippur
            || isYomKippur(date)
            || isSukkot(date)
            || isSimchatTorah(date)
            // one-off closings
            || (d == 27 && m == February && y == 2024) // Municipal elections
            // holidays abroad
            || (d == 1 && m == January)  // Western New Year's day
            || dd == easterMonday(y) - 3  // Good Friday
            || (d >= 25 && w == Monday && m == May && y != 2022) // Spring Bank Holiday
            || (d == 3 && m == June && y == 2022)
            || (d == 25 && m == December)  // Christmas
            || (d == 26 && m == December)  // Boxing day
            // other days when fixings were not published
            || (d == 1 && m == November && y == 2022) // no idea why
            || (d == 2 && m == January && y == 2023) // Maybe New Year's Day is adjusted to Monday?
            || (d == 10 && m == April && y == 2023) // Easter Monday, not a holiday in 2024 and 2025
            )
            return false; // NOLINT(readability-simplify-boolean-expr)

        return true;
    }

}
]]></document_content>
  </document>
  <document index="24">
    <source>calendars/italy.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/italy.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    Italy::Italy(Italy::Market market) {
        // all calendar instances on the same market share the same
        // implementation instance
        static ext::shared_ptr<Calendar::Impl> settlementImpl(
                                                   new Italy::SettlementImpl);
        static ext::shared_ptr<Calendar::Impl> exchangeImpl(
                                                   new Italy::ExchangeImpl);
        switch (market) {
          case Settlement:
            impl_ = settlementImpl;
            break;
          case Exchange:
            impl_ = exchangeImpl;
            break;
          default:
            QL_FAIL("unknown market");
        }
    }


    bool Italy::SettlementImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Epiphany
            || (d == 6 && m == January)
            // Easter Monday
            || (dd == em)
            // Liberation Day
            || (d == 25 && m == April)
            // Labour Day
            || (d == 1 && m == May)
            // Republic Day
            || (d == 2 && m == June && y >= 2000)
            // Assumption
            || (d == 15 && m == August)
            // All Saints' Day
            || (d == 1 && m == November)
            // Immaculate Conception
            || (d == 8 && m == December)
            // Christmas
            || (d == 25 && m == December)
            // St. Stephen
            || (d == 26 && m == December)
            // December 31st, 1999 only
            || (d == 31 && m == December && y == 1999))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }


    bool Italy::ExchangeImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // Labour Day
            || (d == 1 && m == May)
            // Assumption
            || (d == 15 && m == August)
            // Christmas' Eve
            || (d == 24 && m == December)
            // Christmas
            || (d == 25 && m == December)
            // St. Stephen
            || (d == 26 && m == December)
            // New Year's Eve
            || (d == 31 && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="25">
    <source>calendars/japan.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000-2003 RiskMap srl
 Copyright (C) 2003 Kawanishi Tomoya
 Copyright (C) 2016, 2019, 2020 Eisuke Tani

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/japan.hpp>

namespace QuantLib {

    Japan::Japan() {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new Japan::Impl);
        impl_ = impl;
    }

    bool Japan::Impl::isWeekend(Weekday w) const {
        return w == Saturday || w == Sunday;
    }

    bool Japan::Impl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();
        // equinox calculation
        const Time exact_vernal_equinox_time = 20.69115;
        const Time exact_autumnal_equinox_time = 23.09;
        const Time diff_per_year = 0.242194;
        const Time moving_amount = (y-2000)*diff_per_year;
        Integer number_of_leap_years = (y-2000)/4+(y-2000)/100-(y-2000)/400;
        Day ve =    // vernal equinox day
            Day(exact_vernal_equinox_time
                + moving_amount - number_of_leap_years);
        Day ae =    // autumnal equinox day
            Day(exact_autumnal_equinox_time
                + moving_amount - number_of_leap_years);
        // checks
        if (isWeekend(w)
            // New Year's Day
            || (d == 1  && m == January)
            // Bank Holiday
            || (d == 2  && m == January)
            // Bank Holiday
            || (d == 3  && m == January)
            // Coming of Age Day (2nd Monday in January),
            // was January 15th until 2000
            || (w == Monday && (d >= 8 && d <= 14) && m == January
                && y >= 2000)
            || ((d == 15 || (d == 16 && w == Monday)) && m == January
                && y < 2000)
            // National Foundation Day
            || ((d == 11 || (d == 12 && w == Monday)) && m == February)
            // Emperor's Birthday (Emperor Naruhito)
            || ((d == 23 || (d == 24 && w == Monday)) && m == February
                && y >= 2020)
            // Emperor's Birthday (Emperor Akihito)
            || ((d == 23 || (d == 24 && w == Monday)) && m == December
                && (y >= 1989 && y < 2019))
            // Vernal Equinox
            || ((d == ve || (d == ve+1 && w == Monday)) && m == March)
            // Greenery Day
            || ((d == 29 || (d == 30 && w == Monday)) && m == April)
            // Constitution Memorial Day
            || (d == 3  && m == May)
            // Holiday for a Nation
            || (d == 4  && m == May)
            // Children's Day
            || (d == 5  && m == May)
            // any of the three above observed later if on Saturday or Sunday
            || (d == 6 && m == May
                && (w == Monday || w == Tuesday || w == Wednesday))
            // Marine Day (3rd Monday in July),
            // was July 20th until 2003, not a holiday before 1996,
            // July 23rd in 2020 due to Olympics games
            // July 22nd in 2021 due to Olympics games
            || (w == Monday && (d >= 15 && d <= 21) && m == July
                && ((y >= 2003 && y < 2020) || y >= 2022))
            || ((d == 20 || (d == 21 && w == Monday)) && m == July
                && y >= 1996 && y < 2003)
            || (d == 23 && m == July && y == 2020)
            || (d == 22 && m == July && y == 2021)
            // Mountain Day
            // (moved in 2020 due to Olympics games)
            // (moved in 2021 due to Olympics games)
            || ((d == 11 || (d == 12 && w == Monday)) && m == August
                && ((y >= 2016 && y < 2020) || y >= 2022))
            || (d == 10 && m == August && y == 2020)
            || (d == 9 && m == August && y == 2021)
            // Respect for the Aged Day (3rd Monday in September),
            // was September 15th until 2003
            || (w == Monday && (d >= 15 && d <= 21) && m == September
                && y >= 2003)
            || ((d == 15 || (d == 16 && w == Monday)) && m == September
                && y < 2003)
            // If a single day falls between Respect for the Aged Day
            // and the Autumnal Equinox, it is holiday
            || (w == Tuesday && d+1 == ae && d >= 16 && d <= 22
                && m == September && y >= 2003)
            // Autumnal Equinox
            || ((d == ae || (d == ae+1 && w == Monday)) && m == September)
            // Health and Sports Day (2nd Monday in October),
            // was October 10th until 2000,
            // July 24th in 2020 due to Olympics games
            // July 23rd in 2021 due to Olympics games
            || (w == Monday && (d >= 8 && d <= 14) && m == October
                && ((y >= 2000 && y < 2020) || y >= 2022))
            || ((d == 10 || (d == 11 && w == Monday)) && m == October
                && y < 2000)
            || (d == 24 && m == July && y == 2020)
            || (d == 23 && m == July && y == 2021)
            // National Culture Day
            || ((d == 3  || (d == 4 && w == Monday)) && m == November)
            // Labor Thanksgiving Day
            || ((d == 23 || (d == 24 && w == Monday)) && m == November)
            // Bank Holiday
            || (d == 31 && m == December)
            // one-shot holidays
            // Marriage of Prince Akihito
            || (d == 10 && m == April && y == 1959)
            // Rites of Imperial Funeral
            || (d == 24 && m == February && y == 1989)
            // Enthronement Ceremony (Emperor Akihito)
            || (d == 12 && m == November && y == 1990)
            // Marriage of Prince Naruhito
            || (d == 9 && m == June && y == 1993)
            // Special holiday based on Japanese public holidays law
            || (d == 30 && m == April && y == 2019)
            // Enthronement Day (Emperor Naruhito)
            || (d == 1 && m == May && y == 2019)
            // Special holiday based on Japanese public holidays law
            || (d == 2 && m == May && y == 2019)
            // Enthronement Ceremony (Emperor Naruhito)
            || (d == 22 && m == October && y == 2019))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}
]]></document_content>
  </document>
  <document index="26">
    <source>calendars/jointcalendar.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2020 Piotr Siejda

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/errors.hpp>
#include <ql/time/calendars/jointcalendar.hpp>
#include <sstream>
#include <utility>

namespace QuantLib {

    JointCalendar::Impl::Impl(const Calendar& c1,
                              const Calendar& c2,
                              JointCalendarRule r)
    : rule_(r), calendars_(2) {
        calendars_[0] = c1;
        calendars_[1] = c2;
    }


    JointCalendar::Impl::Impl(const Calendar& c1,
                              const Calendar& c2,
                              const Calendar& c3,
                              JointCalendarRule r)
    : rule_(r), calendars_(3) {
        calendars_[0] = c1;
        calendars_[1] = c2;
        calendars_[2] = c3;
    }

    JointCalendar::Impl::Impl(const Calendar& c1,
                              const Calendar& c2,
                              const Calendar& c3,
                              const Calendar& c4,
                              JointCalendarRule r)
    : rule_(r), calendars_(4) {
        calendars_[0] = c1;
        calendars_[1] = c2;
        calendars_[2] = c3;
        calendars_[3] = c4;
    }

    JointCalendar::Impl::Impl(std::vector<Calendar> cv, JointCalendarRule r)
    : rule_(r), calendars_(std::move(cv)) {}

    std::string JointCalendar::Impl::name() const {
        std::ostringstream out;
        switch (rule_) {
          case JoinHolidays:
            out << "JoinHolidays(";
            break;
          case JoinBusinessDays:
            out << "JoinBusinessDays(";
            break;
          default:
            QL_FAIL("unknown joint calendar rule");
        }
        out << calendars_.front().name();
        std::vector<Calendar>::const_iterator i;
        for (i=calendars_.begin()+1; i!=calendars_.end(); ++i)
            out << ", " << i->name();
        out << ")";
        return out.str();
    }

    bool JointCalendar::Impl::isWeekend(Weekday w) const {
        std::vector<Calendar>::const_iterator i;
        switch (rule_) {
          case JoinHolidays:
            for (i=calendars_.begin(); i!=calendars_.end(); ++i) {
                if (i->isWeekend(w))
                    return true;
            }
            return false;
          case JoinBusinessDays:
            for (i=calendars_.begin(); i!=calendars_.end(); ++i) {
                if (!i->isWeekend(w))
                    return false;
            }
            return true;
          default:
            QL_FAIL("unknown joint calendar rule");
        }
    }

    bool JointCalendar::Impl::isBusinessDay(const Date& date) const {
        std::vector<Calendar>::const_iterator i;
        switch (rule_) {
          case JoinHolidays:
            for (i=calendars_.begin(); i!=calendars_.end(); ++i) {
                if (i->isHoliday(date))
                    return false;
            }
            return true;
          case JoinBusinessDays:
            for (i=calendars_.begin(); i!=calendars_.end(); ++i) {
                if (i->isBusinessDay(date))
                    return true;
            }
            return false;
          default:
            QL_FAIL("unknown joint calendar rule");
        }
    }


    JointCalendar::JointCalendar(const Calendar& c1,
                                 const Calendar& c2,
                                 JointCalendarRule r) {
        impl_ = ext::shared_ptr<Calendar::Impl>(
                                            new JointCalendar::Impl(c1,c2,r));
    }

    JointCalendar::JointCalendar(const Calendar& c1,
                                 const Calendar& c2,
                                 const Calendar& c3,
                                 JointCalendarRule r) {
        impl_ = ext::shared_ptr<Calendar::Impl>(
                                         new JointCalendar::Impl(c1,c2,c3,r));
    }

    JointCalendar::JointCalendar(const Calendar& c1,
                                 const Calendar& c2,
                                 const Calendar& c3,
                                 const Calendar& c4,
                                 JointCalendarRule r) {
        impl_ = ext::shared_ptr<Calendar::Impl>(
                                      new JointCalendar::Impl(c1,c2,c3,c4,r));
    }

    JointCalendar::JointCalendar(const std::vector<Calendar> &cv,
                                 JointCalendarRule r) {
        impl_ = ext::shared_ptr<Calendar::Impl>(
                                      new JointCalendar::Impl(cv,r));
    }

}
]]></document_content>
  </document>
  <document index="27">
    <source>calendars/mexico.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl
 Copyright (C) 2024 Skandinaviska Enskilda Banken AB (publ)

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/mexico.hpp>

namespace QuantLib {

    Mexico::Mexico(Market) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new Mexico::BmvImpl);
        impl_ = impl;
    }

    bool Mexico::BmvImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Constitution Day
            || (y <= 2005 && d == 5 && m == February)
            || (y >= 2006 && d <= 7 && w == Monday && m == February)
            // Birthday of Benito Juarez
            || (y <= 2005 && d == 21 && m == March)
            || (y >= 2006 && (d >= 15 && d <= 21) && w == Monday && m == March)
            // Holy Thursday
            || (dd == em-4)
            // Good Friday
            || (dd == em-3)
            // Labour Day
            || (d == 1 && m == May)
            // National Day
            || (d == 16 && m == September)
            // Inauguration Day
            || (d == 1 && m == October && y >= 2024 && (y - 2024) % 6 == 0)
            // All Souls Day
            || (d == 2 && m == November)
            // Revolution Day
            || (y <= 2005 && d == 20 && m == November)
            || (y >= 2006 && (d >= 15 && d <= 21) && w == Monday && m == November)
            // Our Lady of Guadalupe
            || (d == 12 && m == December)
            // Christmas
            || (d == 25 && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="28">
    <source>calendars/newzealand.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/newzealand.hpp>

namespace QuantLib {

    bool NewZealand::CommonImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day (possibly moved to Monday or Tuesday)
            || ((d == 1 || (d == 3 && (w == Monday || w == Tuesday))) &&
                m == January)
            // Day after New Year's Day (possibly moved to Mon or Tuesday)
            || ((d == 2 || (d == 4 && (w == Monday || w == Tuesday))) &&
                m == January)
            // Waitangi Day. February 6th (possibly moved to Monday since 2013)
            || (d == 6 && m == February)
            || ((d == 7 || d == 8) && w == Monday && m == February && y > 2013)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // ANZAC Day. April 25th (possibly moved to Monday since 2013) 
            || (d == 25 && m == April)
            || ((d == 26 || d == 27) && w == Monday && m == April && y > 2013)
            // Queen's Birthday, first Monday in June
            || (d <= 7 && w == Monday && m == June)
            // Labour Day, fourth Monday in October
            || ((d >= 22 && d <= 28) && w == Monday && m == October)
            // Christmas, December 25th (possibly Monday or Tuesday)
            || ((d == 25 || (d == 27 && (w == Monday || w == Tuesday)))
                && m == December)
            // Boxing Day, December 26th (possibly Monday or Tuesday)
            || ((d == 26 || (d == 28 && (w == Monday || w == Tuesday)))
                && m == December)
            // Matariki, it happens on Friday in June or July
            // official calendar released by the NZ government for the
            // next 30 years
            || (d == 20 && m == June && y == 2025)
            || (d == 21 && m == June && (y == 2030 || y == 2052))
            || (d == 24 && m == June && (y == 2022 || y == 2033 || y == 2044))
            || (d == 25 && m == June && (y == 2027 || y == 2038 || y == 2049))
            || (d == 28 && m == June && y == 2024)
            || (d == 29 && m == June && (y == 2035 || y == 2046))
            || (d == 30 && m == June && y == 2051)
            || (d == 2  && m == July && y == 2032)
            || (d == 3  && m == July && (y == 2043 || y == 2048))
            || (d == 6  && m == July && (y == 2029 || y == 2040))
            || (d == 7  && m == July && (y == 2034 || y == 2045))
            || (d == 10 && m == July && (y == 2026 || y == 2037))
            || (d == 11 && m == July && (y == 2031 || y == 2042))
            || (d == 14 && m == July && (y == 2023 || y == 2028))
            || (d == 15 && m == July && (y == 2039 || y == 2050))
            || (d == 18 && m == July && y == 2036)
            || (d == 19 && m == July && (y == 2041 || y == 2047))
            // Queen Elizabeth's funeral
            || (d == 26 && m == September && y == 2022))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

    bool NewZealand::WellingtonImpl::isBusinessDay(const Date& date) const {
        if (!NewZealand::CommonImpl::isBusinessDay(date))
            return false;
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        // Anniversary Day, Monday nearest January 22nd
        if ((d >= 19 && d <= 25) && w == Monday && m == January)
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

    bool NewZealand::AucklandImpl::isBusinessDay(const Date& date) const {
        if (!NewZealand::CommonImpl::isBusinessDay(date))
            return false;
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        // Anniversary Day, Monday nearest January 29nd
        if ((d >= 26 && w == Monday && m == January)
            || (d == 1 && w == Monday && m == February))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }
        

    NewZealand::NewZealand(Market market) {
        // all calendar instances for a given market share the same implementation instance
        static auto wellingtonImpl = ext::make_shared<NewZealand::WellingtonImpl>();
        static auto aucklandImpl = ext::make_shared<NewZealand::AucklandImpl>();

        switch (market) {
          case Wellington:
            impl_ = wellingtonImpl;
            break;
          case Auckland:
            impl_ = aucklandImpl;
            break;
          default:
            QL_FAIL("unknown market");
        }
    }

}
]]></document_content>
  </document>
  <document index="29">
    <source>calendars/norway.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/norway.hpp>

namespace QuantLib {

    Norway::Norway() {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new Norway::Impl);
        impl_ = impl;
    }

    bool Norway::Impl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // Holy Thursday
            || (dd == em-4)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // Ascension Thursday
            || (dd == em+38)
            // Whit Monday
            || (dd == em+49)
            // New Year's Day
            || (d == 1  && m == January)
            // May Day
            || (d == 1  && m == May)
            // National Independence Day
            || (d == 17 && m == May)
            // Christmas Eve
            || (d == 24 && m == December && y >= 2002)
            // Christmas
            || (d == 25 && m == December)
            // Boxing Day
            || (d == 26 && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="30">
    <source>calendars/poland.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/poland.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    Poland::Poland(Poland::Market market) {
        // all calendar instances share the same implementation instance
        static auto settlementImpl = ext::make_shared<Poland::SettlementImpl>();
        static auto wseImpl = ext::make_shared<Poland::WseImpl>();
        switch (market) {
          case Settlement:
            impl_ = settlementImpl;
            break;
          case WSE:
            impl_ = wseImpl;
            break;
          default:
            QL_FAIL("unknown market");
        }
    }

    bool Poland::SettlementImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // Easter Monday
            || (dd == em)
            // Corpus Christi
            || (dd == em+59)
            // New Year's Day
            || (d == 1  && m == January)
            // Epiphany
            || (d == 6  && m == January && y >= 2011)
            // May Day
            || (d == 1  && m == May)
            // Constitution Day
            || (d == 3  && m == May)
            // Assumption of the Blessed Virgin Mary
            || (d == 15  && m == August)
            // All Saints Day
            || (d == 1  && m == November)
            // Independence Day
            || (d ==11  && m == November)
            // Christmas
            || (d == 25 && m == December)
            // 2nd Day of Christmas
            || (d == 26 && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

    
    bool Poland::WseImpl::isBusinessDay(const Date& date) const {
        // Additional holidays for Warsaw Stock Exchange
        // see https://www.gpw.pl/session-details
        Day d = date.dayOfMonth();
        Month m = date.month();

        if (
            (d == 24  && m == December)
            || (d == 31  && m == December)
            ) return false; // NOLINT(readability-simplify-boolean-expr)

        return SettlementImpl::isBusinessDay(date);
    }

}

]]></document_content>
  </document>
  <document index="31">
    <source>calendars/romania.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 StatPro Italia srl
 Copyright (C) 2015 Riccardo Barone
 Copyright (C) 2018 Matthias Lungwitz

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/romania.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    Romania::Romania(Market market) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> publicImpl =
            ext::make_shared<Romania::PublicImpl>();
        static ext::shared_ptr<Calendar::Impl> bvbImpl =
            ext::make_shared<Romania::BVBImpl>();
        switch (market) {
          case Public:
            impl_ = publicImpl;
            break;
          case BVB:
            impl_ = bvbImpl;
            break;
          default:
            QL_FAIL("unknown market");
        }
    }

    bool Romania::PublicImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Day after New Year's Day
            || (d == 2 && m == January)
            // Unification Day
            || (d == 24 && m == January)
            // Orthodox Easter Monday
            || (dd == em)
            // Labour Day
            || (d == 1 && m == May)
            // Pentecost
            || (dd == em+49)
            // Children's Day (since 2017)
            || (d == 1 && m == June && y >= 2017)
            // St Marys Day
            || (d == 15 && m == August)
            // Feast of St Andrew
            || (d == 30 && m == November)
            // National Day
            || (d == 1 && m == December)
            // Christmas
            || (d == 25 && m == December)
            // 2nd Day of Chritsmas
            || (d == 26 && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

    bool Romania::BVBImpl::isBusinessDay(const Date& date) const {
        if (!PublicImpl::isBusinessDay(date))
            return false;
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();
        if (// one-off closing days
            (d == 24 && m == December && y == 2014) ||
            (d == 31 && m == December && y == 2014)
            )
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }
            
}

]]></document_content>
  </document>
  <document index="32">
    <source>calendars/russia.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 StatPro Italia srl
 Copyright (C) 2015 Dmitri Nesteruk

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/russia.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    Russia::Russia(Russia::Market market) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> settlementImpl(
                                                  new Russia::SettlementImpl);
        static ext::shared_ptr<Calendar::Impl> exchangeImpl(
                                                    new Russia::ExchangeImpl);

        switch (market) {
          case Settlement:
            impl_ = settlementImpl;
            break;
          case MOEX:
            impl_ = exchangeImpl;
            break;
          default:
            QL_FAIL("unknown market");
        }
    }

    namespace {

        bool isExtraHolidaySettlementImpl(Day d, Month month, Year year) {
            switch (year) {
              case 2017:
                switch (month) {
                  case February: return d == 24;
                  case May:      return d == 8;
                  case November: return d == 6;
                  default:       return false;
                }
              case 2018:
                switch (month) {
                  case March:     return d == 9;
                  case April:     return d == 30;
                  case May:       return d == 2;
                  case June:      return d == 11;
                  case December:  return d == 31;
                  default:        return false;
                }
              case 2019:
                switch (month) {
                  case May: return d == 2 || d == 3 || d == 10;
                  default: return false;
                }
              case 2020:
                switch (month) {
                  case March:     return d == 30 || d == 31;
                  case April:     return d == 1 || d == 2 || d == 3;
                  case May:       return d == 4 || d == 5;
                  default:        return false;
                }
              default:
                return false;
            }
        }

    }

    bool Russia::SettlementImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();
        if (isWeekend(w)
            // New Year's holidays
            || (y <= 2005 && d <= 2 && m == January)
            || (y >= 2005 && d <= 5 && m == January)
            // in 2012, the 6th was also a holiday
            || (y == 2012 && d == 6 && m == January)
            // Christmas (possibly moved to Monday)
            || ((d == 7 || ((d == 8 || d == 9) && w == Monday)) &&
                m == January)
            // Defender of the Fatherland Day (possibly moved to Monday)
            || ((d == 23 || ((d == 24 || d == 25) && w == Monday)) &&
                m == February)
            // International Women's Day (possibly moved to Monday)
            || ((d == 8 || ((d == 9 || d == 10) && w == Monday)) &&
                m == March)
            // Labour Day (possibly moved to Monday)
            || ((d == 1 || ((d == 2 || d == 3) && w == Monday)) &&
                m == May)
            // Victory Day (possibly moved to Monday)
            || ((d == 9 || ((d == 10 || d == 11) && w == Monday)) &&
                m == May)
            // Russia Day (possibly moved to Monday)
            || ((d == 12 || ((d == 13 || d == 14) && w == Monday)) &&
                m == June)
            // Unity Day (possibly moved to Monday)
            || ((d == 4 || ((d == 5 || d == 6) && w == Monday)) &&
                m == November))
            return false; // NOLINT(readability-simplify-boolean-expr)

        if (isExtraHolidaySettlementImpl(d,m,y))
            return false;

        return true;
    }

    namespace {

        bool isWorkingWeekend(Day d, Month month, Year year) {
            switch (year) {
              case 2012:
                switch (month) {
                  case March: return d == 11;
                  case April: return d == 28;
                  case May:   return d == 5 || d == 12;
                  case June:  return d == 9;
                  default:    return false;
                }
              case 2016:
                switch (month)
                {
                case February: return d == 20;
                default: return false;
                }
              case 2018:
                switch (month) {
                  case April: return d == 28;
                  case June: return d == 9;
                  case December: return d == 29;
                  default: return false;
                }
              default:
                return false;
            }
        }

        bool isExtraHolidayExchangeImpl(Day d, Month month, Year year) {
            switch (year) {
              case 2012:
                switch (month) {
                  case January: return d == 2;
                  case March:   return d == 9;
                  case April:   return d == 30;
                  case June:    return d == 11;
                  default:      return false;
                }
              case 2013:
                switch (month) {
                  case January: return d == 1 || d == 2 || d == 3
                                    || d == 4 || d == 7;
                  default:      return false;
                }
              case 2014:
                switch (month) {
                  case January: return d == 1 || d == 2 || d == 3 || d == 7;
                  default:      return false;
                }
              case 2015:
                switch (month) {
                  case January: return d == 1 || d == 2 || d == 7;
                  default:      return false;
                }
              case 2016:
                switch (month)
                {
                case January: return d == 1 || d == 7 || d == 8;
                case May:     return d == 2 || d == 3;
                case June:    return d == 13;
                case December: return d == 30;
                default:      return false;
                }
              case 2017:
                switch (month) {
                  case January: return d == 2;
                  case May:     return d == 8;
                  default:      return false;
                }
              case 2018:
                switch (month) {
                  case January:   return d == 1 || d == 2 || d == 8;
                  case December:  return d == 31;
                  default:        return false;
                }
              case 2019:
                switch (month) {
                case January:   return d == 1 || d == 2 || d == 7;
                case December:  return d == 31;
                default:        return false;
                }
              case 2020:
                switch (month) {
                  case January:   return d == 1 || d == 2 || d == 7;
                  case February:  return d == 24;
                  case June:      return d == 24;
                  case July:      return d == 1;
                  default:        return false;
                }
              default:
                return false;
            }
        }

    }

    bool Russia::ExchangeImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();

        // the exchange was formally established in 2011, so data are only
        // available from 2012 to present
        if (y < 2012)
            QL_FAIL("MOEX calendar for the year " << y
                    << " does not exist.");

        if (isWorkingWeekend(d,m,y))
            return true;

        // Known holidays
        if (isWeekend(w)
            // Defender of the Fatherland Day
            || (d == 23 && m == February)
            // International Women's Day (possibly moved to Monday)
            || ((d == 8 || ((d == 9 || d == 10) && w == Monday)) && m == March)
            // Labour Day
            || (d == 1 && m == May)
            // Victory Day (possibly moved to Monday)
            || ((d == 9 || ((d == 10 || d == 11) && w == Monday)) && m == May)
            // Russia Day
            || (d == 12 && m == June)
            // Unity Day (possibly moved to Monday)
            || ((d == 4 || ((d == 5 || d == 6) && w == Monday))
                && m == November)
            // New Years Eve
            || (d == 31 && m == December))
            return false;

        if (isExtraHolidayExchangeImpl(d,m,y))
            return false;

        return true;
    }

}
]]></document_content>
  </document>
  <document index="33">
    <source>calendars/saudiarabia.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 FIMAT Group
 Copyright (C) 2007, 2011 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/saudiarabia.hpp>
#include <ql/errors.hpp>
#include <algorithm>

namespace QuantLib {

    namespace {

        bool isTrueWeekend(Date d) {
            // The Saudi weekend was changed from 29th June 2013
            Weekday w = d.weekday();
            return (d < Date(29, June, 2013)) ?
                (w == Thursday || w == Friday) :
                (w == Friday || w == Saturday);
        }

        // In 2015 and 2014, the Eid holidays of the Tadawul Exchange
        // have been from Eid-1 to Eid+4
        // Sometimes, slightly longer holidays are observed 
        // But conservatively, we take Eid-1 to Eid+4 as the holiday

        // Eid Date    Holiday     Offset    Remarks
        // 2015-09-23    22-27     -1,+4     later extended to 22-28 or -1+5
        // 2015-07-17    18-21     -1,+4
        // 2014-10-05    03-11     -1,+4     because of weekend 03-11 is same as 04-09 
        // 2014-07-28    25-03     -1,+4     because of weekend 25-03 is same as 27-01
        // 2013-10-15    11-19     -2,+4     because of weekend 11-19 is same as 13-19 
        // 2013-08-08    06-12     -2,+4 
        // 2012-10-26    25-03     -1,+5     because of weekend 25-03 is same as 25-31 
        // 2012-08-19    16-24     -1,+4     because of weekend 16-24 is same as 18-23

        bool isEidAlAdha(Date d) {
            // Eid al Adha dates taken from:
            // https://en.wikipedia.org/wiki/Eid_al-Adha#Eid_al-Adha_in_the_Gregorian_calendar
            static std::vector<Date> EidAlAdha = {
                Date(7, April, 1998),
                Date(27, March, 1999),
                Date(16, March, 2000),
                Date(5, March, 2001),
                Date(23, February, 2002),
                Date(12, February, 2003),
                Date(1, February, 2004),
                Date(21, January, 2005),
                Date(10, January, 2006),
                Date(31, December, 2006),
                Date(20, December, 2007),
                Date(8, December, 2008),
                Date(27, November, 2009),
                Date(16, November, 2010),
                Date(6, November, 2011),
                Date(26, October, 2012),
                Date(15, October, 2013),
                Date(4, October, 2014),
                Date(24, September, 2015),
                Date(11, September, 2016),
                Date(1, September, 2017),
                Date(23, August, 2018),
                Date(12, August, 2019),
                Date(31, July, 2020),
                Date(20, July, 2021),
                Date(10, July, 2022)
            };

            return std::any_of(EidAlAdha.begin(), EidAlAdha.end(),
                               [=](Date p) { return d >= p - 1 && d <= p + 4; });
        }

        bool isEidAlFitr(Date d) {
            // Eid al Fitr dates taken from:
            // https://en.wikipedia.org/wiki/Eid_al-Fitr#In_the_Gregorian_calendar
            static std::vector<Date> EidAlFitr = {
                Date(16, Dec, 2001),
                Date(5, Dec, 2002),
                Date(25, Nov, 2003),
                Date(13, Nov, 2004),
                Date(3, Nov, 2005),
                Date(23, Oct, 2006),
                Date(12, Oct, 2007),
                Date(30, Sep, 2008),
                Date(20, Sep, 2009),
                Date(10, Sep, 2010),
                Date(30, Aug, 2011),
                Date(19, Aug, 2012),
                Date(8, Aug, 2013),
                Date(28, Jul, 2014),
                Date(17, Jul, 2015),
                Date(6, Jul, 2016),
                Date(25, Jun, 2017),
                Date(15, Jun, 2018),
                Date(4, Jun, 2019),
                Date(24, May, 2020),
                Date(13, May, 2021),
                Date(2, May, 2022),
                Date(21, Apr, 2023),
                Date(10, Apr, 2024),
                Date(30, Mar, 2025),
                Date(20, Mar, 2026),
                Date(9, Mar, 2027),
                Date(26, Feb, 2028),
                Date(14, Feb, 2029)
            };

            return std::any_of(EidAlFitr.begin(), EidAlFitr.end(),
                               [=](Date p) { return d >= p - 1 && d <= p + 4; });
        }

    }

    SaudiArabia::SaudiArabia(Market market) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> tadawulImpl(
                                                new SaudiArabia::TadawulImpl);
        switch (market) {
          case Tadawul:
            impl_ = tadawulImpl;
            break;
          default:
            QL_FAIL("unknown market");
        }
    }

    bool SaudiArabia::TadawulImpl::isWeekend(Weekday w) const {
        return w == Friday || w == Saturday;
    }

    bool SaudiArabia::TadawulImpl::isBusinessDay(const Date& date) const {
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();

        if (isTrueWeekend(date)
            || isEidAlAdha(date)
            || isEidAlFitr(date)
            // National Day
            || (d == 23 && m == September)
            // other one-shot holidays
            || (d == 26 && m == February && y==2011)
            || (d == 19 && m == March && y==2011)
            )
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="34">
    <source>calendars/singapore.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 FIMAT Group
 Copyright (C) 2007, 2008, 2009, 2010 StatPro Italia srl
 Copyright (C) 2024 Skandinaviska Enskilda Banken AB (publ)

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/singapore.hpp>

namespace QuantLib {

    Singapore::Singapore(Market) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new Singapore::SgxImpl);
        impl_ = impl;
    }

    bool Singapore::SgxImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);

        if (isWeekend(w)
            // New Year's Day
            || ((d == 1 || (d == 2 && w == Monday)) && m == January)
            // Good Friday
            || (dd == em-3)
            // Labor Day
            || (d == 1 && m == May)
            // National Day
            || ((d == 9 || (d == 10 && w == Monday)) && m == August)
            // Christmas Day
            || (d == 25 && m == December)

            // Chinese New Year
            || ((d == 22 || d == 23) && m == January && y == 2004)
            || ((d == 9 || d == 10) && m == February && y == 2005)
            || ((d == 30 || d == 31) && m == January && y == 2006)
            || ((d == 19 || d == 20) && m == February && y == 2007)
            || ((d == 7 || d == 8) && m == February && y == 2008)
            || ((d == 26 || d == 27) && m == January && y == 2009)
            || ((d == 15 || d == 16) && m == January && y == 2010)
            || ((d == 23 || d == 24) && m == January && y == 2012)
            || ((d == 11 || d == 12) && m == February && y == 2013)
            || (d == 31 && m == January && y == 2014)
            || (d == 1 && m == February && y == 2014)

            // Hari Raya Haji
            || ((d == 1 || d == 2) && m == February && y == 2004)
            || (d == 21 && m == January && y == 2005)
            || (d == 10 && m == January && y == 2006)
            || (d == 2 && m == January && y == 2007)
            || (d == 20 && m == December && y == 2007)
            || (d == 8 && m == December && y == 2008)
            || (d == 27 && m == November && y == 2009)
            || (d == 17 && m == November && y == 2010)
            || (d == 26 && m == October && y == 2012)
            || (d == 15 && m == October && y == 2013)
            || (d == 6 && m == October && y == 2014)

            // Vesak Poya Day
            || (d == 2 && m == June && y == 2004)
            || (d == 22 && m == May && y == 2005)
            || (d == 12 && m == May && y == 2006)
            || (d == 31 && m == May && y == 2007)
            || (d == 18 && m == May && y == 2008)
            || (d == 9 && m == May && y == 2009)
            || (d == 28 && m == May && y == 2010)
            || (d == 5 && m == May && y == 2012)
            || (d == 24 && m == May && y == 2013)
            || (d == 13 && m == May && y == 2014)

            // Deepavali
            || (d == 11 && m == November && y == 2004)
            || (d == 8 && m == November && y == 2007)
            || (d == 28 && m == October && y == 2008)
            || (d == 16 && m == November && y == 2009)
            || (d == 5 && m == November && y == 2010)
            || (d == 13 && m == November && y == 2012)
            || (d == 2 && m == November && y == 2013)
            || (d == 23 && m == October && y == 2014)

            // Diwali
            || (d == 1 && m == November && y == 2005)

            // Hari Raya Puasa
            || ((d == 14 || d == 15) && m == November && y == 2004)
            || (d == 3 && m == November && y == 2005)
            || (d == 24 && m == October && y == 2006)
            || (d == 13 && m == October && y == 2007)
            || (d == 1 && m == October && y == 2008)
            || (d == 21 && m == September && y == 2009)
            || (d == 10 && m == September && y == 2010)
            || (d == 20 && m == August && y == 2012)
            || (d == 8 && m == August && y == 2013)
            || (d == 28 && m == July && y == 2014)
            )
            return false; // NOLINT(readability-simplify-boolean-expr)

        // https://api2.sgx.com/sites/default/files/2019-01/2019%20DT%20Calendar.pdf
        if (y == 2019)
        {
            if ( // Chinese New Year
                ((d == 5 || d == 6) && m == February)
                // Vesak Poya Day
                || (d == 20 && m == May)
                // Hari Raya Puasa
                || (d == 5 && m == June)
                // Hari Raya Haji
                || (d == 12 && m == August)
                // Deepavali
                || (d == 28 && m == October)
                )
                return false;
        }

        // https://api2.sgx.com/sites/default/files/2020-11/SGX%20Derivatives%20Trading%20Calendar%202020_Dec%20Update_D3.pdf
        if (y == 2020)
        {
            if ( // Chinese New Year
                (d == 27 && m == January)
                // Vesak Poya Day
                || (d == 7 && m == May)
                // Hari Raya Puasa
                || (d == 25 && m == May)
                // Hari Raya Haji
                || (d == 31 && m == July)
                // Deepavali
                || (d == 14 && m == November)
                )
                return false;
        }

        // https://api2.sgx.com/sites/default/files/2021-07/SGX_Derivatives%20Trading%20Calendar%202021%20%28Final%20-%20Jul%29.pdf
        if (y == 2021)
        {
            if ( // Chinese New Year
                (d == 12 && m == February)
                // Hari Raya Puasa
                || (d == 13 && m == May)
                // Vesak Poya Day
                || (d == 26 && m == May)
                // Hari Raya Haji
                || (d == 20 && m == July)
                // Deepavali
                || (d == 4 && m == November)
                )
                return false;
        }

        // https://api2.sgx.com/sites/default/files/2022-06/DT%20Trading%20Calendar%202022%20%28Final%29.pdf
        if (y == 2022)
        {
            if (// Chinese New Year
                ((d == 1 || d == 2) && m == February)
                // Labour Day
                || (d == 2 && m == May)
                // Hari Raya Puasa
                || (d == 3 && m == May)
                // Vesak Poya Day
                || (d == 16 && m == May)
                // Hari Raya Haji
                || (d == 11 && m == July)
                // Deepavali
                || (d == 24 && m == October)
                // Christmas Day
                || (d == 26 && m == December)
                )
                return false;
        }

        // https://api2.sgx.com/sites/default/files/2023-01/SGX%20Calendar%202023_0.pdf
        if (y == 2023)
        {
            if (// Chinese New Year
                ((d == 23 || d == 24) && m == January)
                // Hari Raya Puasa
                || (d == 22 && m == April)
                // Vesak Poya Day
                || (d == 2 && m == June)
                // Hari Raya Haji
                || (d == 29 && m == June)
                // Public holiday on polling day
                || (d == 1 && m == September)
                // Deepavali
                || (d == 13 && m == November))
                return false;
        }
        // https://api2.sgx.com/sites/default/files/2024-01/SGX%20Calendar%202024_2.pdf
        if (y == 2024)
        {
            if (// Chinese New Year
                (d == 12 && m == February)
                // Hari Raya Puasa
                || (d == 10 && m == April)
                // Vesak Poya Day
                || (d == 22 && m == May)
                // Hari Raya Haji
                || (d == 17 && m == June)
                // Deepavali
                || (d == 31 && m == October))
                return false;
        }
        
        // https://api2.sgx.com/sites/default/files/2025-07/DT%20Trading%20Calendar%202025%20%28updated%2031%20Jul%202025%29.pdf
        if (y == 2025)
        {
            if (// Chinese New Year
                ((d == 29 || d == 30) && m == January)
                // Hari Raya Puasa
                || (d == 31 && m == March)
                // Vesak Poya Day
                || (d == 12 && m == May)
                // Deepavali
                || (d == 20 && m == October))
                return false;
        }
        return true;
    }

}

]]></document_content>
  </document>
  <document index="35">
    <source>calendars/slovakia.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/slovakia.hpp>

namespace QuantLib {

    Slovakia::Slovakia(Market) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new Slovakia::BsseImpl);
        impl_ = impl;
    }

    bool Slovakia::BsseImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Epiphany
            || (d == 6 && m == January)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // May Day
            || (d == 1 && m == May)
            // Liberation of the Republic
            || (d == 8 && m == May)
            // SS. Cyril and Methodius
            || (d == 5 && m == July)
            // Slovak National Uprising
            || (d == 29 && m == August)
            // Constitution of the Slovak Republic
            || (d == 1 && m == September)
            // Our Lady of the Seven Sorrows
            || (d == 15 && m == September)
            // All Saints Day
            || (d == 1 && m == November)
            // Freedom and Democracy of the Slovak Republic
            || (d == 17 && m == November)
            // Christmas Eve
            || (d == 24 && m == December)
            // Christmas
            || (d == 25 && m == December)
            // St. Stephen
            || (d == 26 && m == December)
            // unidentified closing days for stock exchange
            || (d >= 24 && d <= 31 && m == December && y == 2004)
            || (d >= 24 && d <= 31 && m == December && y == 2005))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="36">
    <source>calendars/southafrica.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2023, 2024 Skandinaviska Enskilda Banken AB (publ)

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/southafrica.hpp>

namespace QuantLib {

    SouthAfrica::SouthAfrica() {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new SouthAfrica::Impl);
        impl_ = impl;
    }

    bool SouthAfrica::Impl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day (possibly moved to Monday)
            || ((d == 1 || (d == 2 && w == Monday)) && m == January)
            // Good Friday
            || (dd == em-3)
            // Family Day
            || (dd == em)
            // Human Rights Day, March 21st (possibly moved to Monday)
            || ((d == 21 || (d == 22 && w == Monday))
                && m == March)
            // Freedom Day, April 27th (possibly moved to Monday)
            || ((d == 27 || (d == 28 && w == Monday))
                && m == April)
            // Election Day, April 14th 2004
            || (d == 14 && m == April && y == 2004)
            // Workers Day, May 1st (possibly moved to Monday)
            || ((d == 1 || (d == 2 && w == Monday))
                && m == May)
            // Youth Day, June 16th (possibly moved to Monday)
            || ((d == 16 || (d == 17 && w == Monday))
                && m == June)
            // National Women's Day, August 9th (possibly moved to Monday)
            || ((d == 9 || (d == 10 && w == Monday))
                && m == August)
            // Heritage Day, September 24th (possibly moved to Monday)
            || ((d == 24 || (d == 25 && w == Monday))
                && m == September)
            // Day of Reconciliation, December 16th
            // (possibly moved to Monday)
            || ((d == 16 || (d == 17 && w == Monday))
                && m == December)
            // Christmas
            || (d == 25 && m == December)
            // Day of Goodwill (possibly moved to Monday)
            || ((d == 26 || (d == 27 && w == Monday))
                && m == December)
            // one-shot: Election day 2009
            || (d == 22 && m == April && y == 2009)
            // one-shot: Election day 2016
            || (d == 3 && m == August && y == 2016)
            // one-shot: Election day 2021
            || (d == 1 && m == November && y == 2021)
            // one-shot: In lieu of Christmas falling on Sunday in 2022
            || (d == 27 && m == December && y == 2022)
            // one-shot: Special holiday to celebrate winning of Rugby World Cup 2023
            || (d == 15 && m == December && y == 2023)
            // one-shot: Election day 2024
            || (d == 29 && m == May && y == 2024)
            )
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="37">
    <source>calendars/southkorea.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 FIMAT Group
 Copyright (C) 2007, 2011 StatPro Italia srl
 Copyright (C) 2008, 2011 Charles Chongseok Hyun
 Copyright (C) 2015 Riccardo Barone
 Copyright (C) 2015 Paolo Mazzocchi
 Copyright (C) 2023 Skandinaviska Enskilda Banken AB (publ)
 Copyright (C) 2023 Jonghee Lee

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/southkorea.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    SouthKorea::SouthKorea(Market market) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> settlementImpl(
                                              new SouthKorea::SettlementImpl);
        static ext::shared_ptr<Calendar::Impl> krxImpl(
                                                     new SouthKorea::KrxImpl);
        switch (market) {
          case Settlement:
            impl_ = settlementImpl;
            break;
          case KRX:
            impl_ = krxImpl;
            break;
          default:
            QL_FAIL("unknown market");
        }
    }

    bool SouthKorea::SettlementImpl::isWeekend(Weekday w) const {
        return w == Saturday || w == Sunday;
    }

    bool SouthKorea::SettlementImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();

        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Independence Day
            || (d == 1 && m == March)
            || (w == Monday && (d ==  2 || d ==  3) && m == March && y > 2021)
            // Arbour Day
            || (d == 5 && m == April && y <= 2005)
            // Labour Day
            || (d == 1 && m == May)
            // Children's Day
            || (d == 5 && m == May)
            || (w == Monday && (d ==  6 || d ==  7) && m == May && y > 2013)
            // Memorial Day
            || (d == 6 && m == June)
            // Constitution Day
            || (d == 17 && m == July && y <= 2007)
            // Liberation Day
            || (d == 15 && m == August)
            || (w == Monday && (d == 16 || d == 17) && m == August && y > 2020)
            // National Foundation Day
            || (d == 3 && m == October)
            || (w == Monday && (d ==  4 || d ==  5) && m == October && y > 2020)
            // Christmas Day
            || (d == 25 && m == December)
            || (w == Monday && (d == 26 || d == 27) && m == December && y > 2022)

            // Lunar New Year
            || ((d == 21 || d == 22 || d == 23) && m == January  && y == 2004)
            || ((d ==  8 || d ==  9 || d == 10) && m == February && y == 2005)
            || ((d == 28 || d == 29 || d == 30) && m == January  && y == 2006)
            || ( d == 19                        && m == February && y == 2007)
            || ((d ==  6 || d ==  7 || d ==  8) && m == February && y == 2008)
            || ((d == 25 || d == 26 || d == 27) && m == January  && y == 2009)
            || ((d == 13 || d == 14 || d == 15) && m == February && y == 2010)
            || ((d ==  2 || d ==  3 || d ==  4) && m == February && y == 2011)
            || ((d == 23 || d == 24)            && m == January  && y == 2012)
            || ( d == 11                        && m == February && y == 2013)
            || ((d == 30 || d == 31)            && m == January  && y == 2014)
            || ((d == 18 || d == 19 || d == 20) && m == February && y == 2015)
            || ((d >=  7 && d <= 10)            && m == February && y == 2016)
            || ((d >= 27 && d <= 30)            && m == January  && y == 2017)
            || ((d == 15 || d == 16 || d == 17) && m == February && y == 2018)
            || ((d ==  4 || d ==  5 || d ==  6) && m == February && y == 2019)
            || ((d >= 24 && d <= 27)            && m == January  && y == 2020)
            || ((d == 11 || d == 12 || d == 13) && m == February && y == 2021)
            || (((d == 31 && m == January) || ((d == 1 || d == 2)
                                              && m == February)) && y == 2022)
            || ((d == 23 || d == 24) && m == January   && y == 2023)
            || ((d >=  9 && d <= 12) && m == February  && y == 2024)
            || ((d == 28 || d == 29 || d == 30) && m == January   && y == 2025)
            || ((d == 16 || d == 17 || d == 18) && m == February  && y == 2026)
            || ((d ==  8 || d ==  9) && m == February  && y == 2027)
            || ((d == 26 || d == 27 || d == 28) && m == January   && y == 2028)
            || ((d == 12 || d == 13 || d == 14) && m == February  && y == 2029)
            || ((d ==  4 || d ==  5) && m == February  && y == 2030)
            || ((d == 22 || d == 23 || d == 24) && m == January   && y == 2031)
            || ((d == 10 || d == 11 || d == 12) && m == February  && y == 2032)
            || (((d == 31 && m == January) || ((d ==  1|| d ==  2)
                                               && m == February)) && y == 2033)
            || ((d == 20 || d == 21) && m == February  && y == 2034)
            || ((d ==  7 || d ==  8 || d ==  9) && m == February  && y == 2035)
            || ((d == 28 || d == 29 || d == 30) && m == January   && y == 2036)
            || ((d == 16 || d == 17) && m == February  && y == 2037)
            || ((d ==  3 || d ==  4 || d ==  5) && m == February  && y == 2038)
            || ((d == 24 || d == 25 || d == 26) && m == January   && y == 2039)
            || ((d == 13 || d == 14) && m == February  && y == 2040)
            || (((d == 31 && m == January) || ((d ==  1|| d ==  2)
                                               && m == February)) && y == 2041)
            || ((d == 21 || d == 22 || d == 23) && m == January   && y == 2042)
            || ((d ==  9 || d == 10 || d == 11) && m == February  && y == 2043)
            || ((((d == 29|| d == 30|| d == 31) && m == January)
                                   || (d ==  1 && m == February)) && y == 2044)
            || ((d == 16 || d == 17 || d == 18) && m == February  && y == 2045)
            || ((d ==  5 || d ==  6 || d ==  7) && m == February  && y == 2046)
            || ((d >= 25 && d <= 28)            && m == January   && y == 2047)
            || ((d == 13 || d == 14 || d == 15) && m == February  && y == 2048)
            || ((d ==  1 || d ==  2 || d ==  3) && m == February  && y == 2049)
            || ((d == 24 || d == 25)            && m == January   && y == 2050)

            // Election Days
            || (d == 15 && m == April    && y == 2004) // National Assembly
            || (d == 31 && m == May      && y == 2006) // Regional election
            || (d == 19 && m == December && y == 2007) // Presidency
            || (d ==  9 && m == April    && y == 2008) // National Assembly
            || (d ==  2 && m == June     && y == 2010) // Local election
            || (d == 11 && m == April    && y == 2012) // National Assembly
            || (d == 19 && m == December && y == 2012) // Presidency
            || (d ==  4 && m == June     && y == 2014) // Local election
            || (d == 13 && m == April    && y == 2016) // National Assembly
            || (d ==  9 && m == May      && y == 2017) // Presidency
            || (d == 13 && m == June     && y == 2018) // Local election
            || (d == 15 && m == April    && y == 2020) // National Assembly
            || (d ==  9 && m == March    && y == 2022) // Presidency
            || (d ==  1 && m == June     && y == 2022) // Local election
            || (d == 10 && m == April    && y == 2024) // National Assembly
            // Buddha's birthday
            || (d == 26 && m == May   && y == 2004)
            || (d == 15 && m == May   && y == 2005)
            || (d ==  5 && m == May   && y == 2006)
            || (d == 24 && m == May   && y == 2007)
            || (d == 12 && m == May   && y == 2008)
            || (d ==  2 && m == May   && y == 2009)
            || (d == 21 && m == May   && y == 2010)
            || (d == 10 && m == May   && y == 2011)
            || (d == 28 && m == May   && y == 2012)
            || (d == 17 && m == May   && y == 2013)
            || (d ==  6 && m == May   && y == 2014)
            || (d == 25 && m == May   && y == 2015)
            || (d == 14 && m == May   && y == 2016)
            || (d ==  3 && m == May   && y == 2017)
            || (d == 22 && m == May   && y == 2018)
            || (d == 12 && m == May   && y == 2019)
            || (d == 30 && m == April && y == 2020)
            || (d == 19 && m == May   && y == 2021)
            || (d ==  8 && m == May   && y == 2022)
            || (d == 29 && m == May   && y == 2023) // Substitute holiday
            || (d == 15 && m == May   && y == 2024)
            || (d ==  6 && m == May   && y == 2025)
            || (d == 25 && m == May   && y == 2026) // Substitute holiday
            || (d == 13 && m == May   && y == 2027)
            || (d ==  2 && m == May   && y == 2028)
            || (d == 21 && m == May   && y == 2029) // Substitute holiday
            || (d ==  9 && m == May   && y == 2030)
            || (d == 28 && m == May   && y == 2031)
            || (d == 17 && m == May   && y == 2032) // Substitute holiday
            || (d ==  6 && m == May   && y == 2033)
            || (d == 25 && m == May   && y == 2034)
            || (d == 15 && m == May   && y == 2035)
            || (d ==  6 && m == May   && y == 2036) // Substitute holiday
            || (d == 22 && m == May   && y == 2037)
            || (d == 11 && m == May   && y == 2038)
            || (d ==  2 && m == May   && y == 2039) // Substitute holiday
            || (d == 18 && m == May   && y == 2040)
            || (d ==  7 && m == May   && y == 2041)
            || (d == 26 && m == May   && y == 2042)
            || (d == 18 && m == May   && y == 2043) // Substitute holiday
            || (d ==  6 && m == May   && y == 2044)
            || (d == 24 && m == May   && y == 2045)
            || (d == 14 && m == May   && y == 2046) // Substitute holiday
            || (d ==  2 && m == May   && y == 2047)
            || (d == 20 && m == May   && y == 2048)
            || (d == 10 && m == May   && y == 2049) // Substitute holiday
            || (d == 30 && m == May   && y == 2050) // Substitute holiday

            // Special holiday: 70 years from Independence Day
            || (d == 14 && m == August && y == 2015)
            // Special temporary holiday
            || (d == 17 && m == August && y == 2020)
            || (d == 2 && m == October && y == 2023)
            || (d == 1 && m == October && y == 2024)

            // Harvest Moon Day
            || ((d == 27 || d == 28 || d == 29) && m == September && y == 2004)
            || ((d == 17 || d == 18 || d == 19) && m == September && y == 2005)
            || ((d ==  5 || d ==  6 || d ==  7) && m == October   && y == 2006)
            || ((d == 24 || d == 25 || d == 26) && m == September && y == 2007)
            || ((d == 13 || d == 14 || d == 15) && m == September && y == 2008)
            || ((d ==  2 || d ==  3 || d ==  4) && m == October   && y == 2009)
            || ((d == 21 || d == 22 || d == 23) && m == September && y == 2010)
            || ((d == 12 || d == 13)            && m == September && y == 2011)
            || ((d == 1)                        && m == October   && y == 2012)
            || ((d == 18 || d == 19 || d == 20) && m == September && y == 2013)
            || ((d ==  8 || d ==  9 || d == 10) && m == September && y == 2014)
            || ((d == 28 || d == 29)            && m == September && y == 2015)
            || ((d == 14 || d == 15 || d == 16) && m == September && y == 2016)
            || ((d >=  3 && d <=  6)            && m == October   && y == 2017)
            || ((d >= 23 && d <= 26)            && m == September && y == 2018)
            || ((d == 12 || d == 13 || d == 14) && m == September && y == 2019)
            || (((d == 30 && m == September) || ((d == 1 || d == 2) 
                                                && m == October)) && y == 2020)
            || ((d == 20 || d == 21 || d == 22) && m == September && y == 2021)
            || ((d ==  9 || d == 10 || d == 11) && m == September && y == 2022)
            || ((d >=  9 && d <= 12)            && m == September && y == 2022)
            || ((d == 28 || d == 29 || d == 30) && m == September && y == 2023)
            || ((d == 16 || d == 17 || d == 18) && m == September && y == 2024)
            || ((d ==  6 || d ==  7 || d ==  8) && m == October   && y == 2025)
            || ((d == 24 || d == 25 || d == 26) && m == September && y == 2026)
            || ((d == 14 || d == 15 || d == 16) && m == September && y == 2027)
            || ((d >=  2 && d <=  5)            && m == October   && y == 2028)
            || ((d >= 21 && d <= 24)            && m == September && y == 2029)
            || ((d == 11 || d == 12 || d == 13) && m == September && y == 2030)
            || (((d == 30 && m == September) || ((d == 1 || d == 2)
                                                && m == October)) && y == 2031)
            || ((d == 20 || d == 21) && m == September && y == 2032)
            || ((d ==  7 || d ==  8 || d ==  9) && m == September && y == 2033)
            || ((d == 26 || d == 27 || d == 28) && m == September && y == 2034)
            || ((d == 17 || d == 18) && m == September && y == 2035)
            || ((d >=  3 && d <=  7) && m == October   && y == 2036)
            || ((d == 23 || d == 24 || d == 25) && m == September && y == 2037)
            || ((d == 13 || d == 14 || d == 15) && m == September && y == 2038)
            || ((d ==  3 || d ==  4 || d == 5) && m == October   && y == 2039)
            || ((d == 20 || d == 21 || d == 22) && m == September && y == 2040)
            || ((d ==  9 || d == 10 || d == 11) && m == September && y == 2041)
            || ((d == 29 || d == 30) && m == September && y == 2042)
            || ((d == 16 || d == 17 || d == 18) && m == September && y == 2043)
            || ((d ==  4 || d ==  5 || d ==  6) && m == October   && y == 2044)
            || ((d == 25 || d == 26 || d == 27) && m == September && y == 2045)
            || ((d >= 14 && d <= 17) && m == September && y == 2046)
            || ((d ==  4 || d ==  5 || d ==  7) && m == October   && y == 2047)
            || ((d == 21 || d == 22 || d == 23) && m == September && y == 2048)
            || ((d >= 10 && d <= 13) && m == September && y == 2049)
            || ((((d == 29|| d == 30) && m == September) 
                                    || (d ==  1 && m == October)) && y == 2050)

            // Hangul Proclamation of Korea
            || (d == 9 && m == October && y >= 2013)
            || (w == Monday && (d == 10 || d == 11) && m == October && y > 2020)
            )
            return false; // NOLINT(readability-simplify-boolean-expr)

        return true;
    }

    bool SouthKorea::KrxImpl::isBusinessDay(const Date& date) const {
        // public holidays
        if ( !SettlementImpl::isBusinessDay(date) )
            return false;

        Day d = date.dayOfMonth();
        Weekday w = date.weekday();
        Month m = date.month();
        Year y = date.year();

        if (// Year-end closing
            ((((d == 29 || d == 30) && w == Friday) || d == 31) 
             && m == December)
            )
            return false;
        if (// occasional closing days (KRX day)
            (d ==  6 && m == May     && y == 2016) ||
            (d ==  2 && m == October && y == 2017)
            )
            return false;

        return true;
    }

}

]]></document_content>
  </document>
  <document index="38">
    <source>calendars/sweden.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/sweden.hpp>

namespace QuantLib {

    Sweden::Sweden() {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new Sweden::Impl);
        impl_ = impl;
    }

    bool Sweden::Impl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // Ascension Thursday
            || (dd == em+38)
            // Whit Monday (till 2004)
            || (dd == em+49 && y < 2005)
            // New Year's Day
            || (d == 1  && m == January)
            // Epiphany
            || (d == 6  && m == January)
            // May Day
            || (d == 1  && m == May)
            // National Day
            // Only a holiday since 2005
            || (d == 6 && m == June && y >= 2005)
            // Midsummer Eve (Friday between June 19-25)
            || (w == Friday && (d >= 19 && d <= 25) && m == June)
            // Christmas Eve
            || (d == 24 && m == December)
            // Christmas Day
            || (d == 25 && m == December)
            // Boxing Day
            || (d == 26 && m == December)
            // New Year's Eve
            || (d == 31 && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="39">
    <source>calendars/switzerland.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/switzerland.hpp>

namespace QuantLib {

    Switzerland::Switzerland() {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new Switzerland::Impl);
        impl_ = impl;
    }

    bool Switzerland::Impl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day
            || (d == 1  && m == January)
            // Berchtoldstag
            || (d == 2  && m == January)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            // Ascension Day
            || (dd == em+38)
            // Whit Monday
            || (dd == em+49)
            // Labour Day
            || (d == 1  && m == May)
            // National Day
            || (d == 1  && m == August)
            // Christmas
            || (d == 25 && m == December)
            // St. Stephen's Day
            || (d == 26 && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="40">
    <source>calendars/taiwan.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 FIMAT Group
 Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011 StatPro Italia srl
 Copyright (C) 2023 Skandinaviska Enskilda Banken AB (publ)

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/taiwan.hpp>

namespace QuantLib {

    Taiwan::Taiwan(Market) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new Taiwan::TsecImpl);
        impl_ = impl;
    }

    bool Taiwan::TsecImpl::isWeekend(Weekday w) const {
        return w == Saturday || w == Sunday;
    }

    bool Taiwan::TsecImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();

        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // Peace Memorial Day
            || (d == 28 && m == February)
            // Labor Day
            || (d == 1 && m == May)
            // Double Tenth
            || (d == 10 && m == October)
            )
            return false;

        if (y == 2002) {
            // Dragon Boat Festival and Moon Festival fall on Saturday
            if (// Chinese Lunar New Year
                (d >= 9 && d <= 17 && m == February)
                // Tomb Sweeping Day
                || (d == 5 && m == April)
                )
                return false;
        }

        if (y == 2003) {
            // Tomb Sweeping Day falls on Saturday
            if (// Chinese Lunar New Year
                ((d >= 31 && m == January) || (d <= 5 && m == February))
                // Dragon Boat Festival
                || (d == 4 && m == June)
                // Moon Festival
                || (d == 11 && m == September)
                )
                return false;
        }

        if (y == 2004) {
            // Tomb Sweeping Day falls on Sunday
            if (// Chinese Lunar New Year
                (d >= 21 && d <= 26 && m == January)
                // Dragon Boat Festival
                || (d == 22 && m == June)
                // Moon Festival
                || (d == 28 && m == September)
                )
                return false;
        }

        if (y == 2005) {
            // Dragon Boat and Moon Festival fall on Saturday or Sunday
            if (// Chinese Lunar New Year
                (d >= 6 && d <= 13 && m == February)
                // Tomb Sweeping Day
                || (d == 5 && m == April)
                // make up for Labor Day, not seen in other years
                || (d == 2 && m == May)
                )
                return false;
        }

        if (y == 2006) {
            // Dragon Boat and Moon Festival fall on Saturday or Sunday
            if (// Chinese Lunar New Year
                ((d >= 28 && m == January) || (d <= 5 && m == February))
                // Tomb Sweeping Day
                || (d == 5 && m == April)
                // Dragon Boat Festival
                || (d == 31 && m == May)
                // Moon Festival
                || (d == 6 && m == October)
                )
                return false;
        }

        if (y == 2007) {
            if (// Chinese Lunar New Year
                (d >= 17 && d <= 25 && m == February)
                // Tomb Sweeping Day
                || (d == 5 && m == April)
                // adjusted holidays
                || (d == 6 && m == April)
                || (d == 18 && m == June)
                // Dragon Boat Festival
                || (d == 19 && m == June)
                // adjusted holiday
                || (d == 24 && m == September)
                // Moon Festival
                || (d == 25 && m == September)
                )
                return false;
        }

        if (y == 2008) {
            if (// Chinese Lunar New Year
                (d >= 4 && d <= 11 && m == February)
                // Tomb Sweeping Day
                || (d == 4 && m == April)
                )
                return false;
        }

        if (y == 2009) {
            if (// Public holiday
                (d == 2 && m == January)
                // Chinese Lunar New Year
                || (d >= 24 && m == January)
                // Tomb Sweeping Day
                || (d == 4 && m == April)
                // Dragon Boat Festival
                || ((d == 28 || d == 29) && m == May)
                // Moon Festival
                || (d == 3 && m == October)
                )
                return false;
        }

        if (y == 2010) {
            if (// Chinese Lunar New Year
                   (d >= 13 && d <= 21 && m == January)
                // Tomb Sweeping Day
                || (d == 5 && m == April)
                // Dragon Boat Festival
                || (d == 16 && m == May)
                // Moon Festival
                || (d == 22 && m == September)
                )
                return false;
        }

        if (y == 2011) {
            if (// Spring Festival
                   (d >= 2 && d <= 7 && m == February)
                // Children's Day
                || (d == 4 && m == April)
                // Tomb Sweeping Day
                || (d == 5 && m == April)
                // Labour Day
                || (d == 2 && m == May)
                // Dragon Boat Festival
                || (d == 6 && m == June)
                // Mid-Autumn Festival
                || (d == 12 && m == September)
                )
                return false;
        }

        if (y == 2012) {
            if (// Spring Festival
                (d >= 23 && d <= 27 && m == January)
                // Peace Memorial Day
                || (d == 27 && m == February)
                // Children's Day
                // Tomb Sweeping Day
                || (d == 4 && m == April)
                // Labour Day
                || (d == 1 && m == May)
                // Dragon Boat Festival
                || (d == 23 && m == June)
                // Mid-Autumn Festival
                || (d == 30 && m == September)
                // Memorial Day:
                // Founding of the Republic of China
                || (d == 31 && m == December)
                )
                return false;
        }

        if (y == 2013) {
            if (// Spring Festival
                (d >= 10 && d <= 15 && m == February)
                // Children's Day
                || (d == 4 && m == April)
                // Tomb Sweeping Day
                || (d == 5 && m == April)
                // Labour Day
                || (d == 1 && m == May)
                // Dragon Boat Festival
                || (d == 12 && m == June)
                // Mid-Autumn Festival
                || (d >= 19 && d <= 20 && m == September)
                )
                return false;
        }

        if (y == 2014) {
            if (// Lunar New Year
                (d >= 28 && d <= 30 && m == January)
                // Spring Festival
                || ((d == 31 && m == January) || (d <= 4 && m == February))
                // Children's Day
                || (d == 4 && m == April)
                // Tomb Sweeping Day
                || (d == 5 && m == April)
                // Dragon Boat Festival
                || (d == 2 && m == June)
                // Mid-Autumn Festival
                || (d == 8 && m == September)
                )
                return false;
        }

        if (y == 2015) {
            if (// adjusted holidays
                (d == 2 && m == January)
                // Lunar New Year
                || (d >= 18 && d <= 23 && m == February)
                // adjusted holidays
                || (d == 27 && m == February)
                // adjusted holidays
                || (d == 3 && m == April)
                // adjusted holidays
                || (d == 6 && m == April)
                // adjusted holidays
                || (d == 19 && m == June)
                // adjusted holidays
                || (d == 28 && m == September)
                // adjusted holidays
                || (d == 9 && m == October)
                )
                return false;
        }
        
        if (y == 2016) {
            if (// Lunar New Year
                (d >= 8 && d <= 12 && m == February)
                // adjusted holidays
                || (d == 29 && m == February)
                // Children's Day
                || (d == 4 && m == April)
                // adjusted holidays
                || (d == 5 && m == April)
                // adjusted holidays
                || (d == 2 && m == May)
                // Dragon Boat Festival
                || (d == 9 && m == June)
                // adjusted holidays
                || (d == 10 && m == June)
                // Mid-Autumn Festival
                || (d == 15 && m == September)
                // adjusted holidays
                || (d == 16 && m == September)
                )
                return false;
        }

        if (y == 2017) {
            if (// adjusted holidays
                (d == 2 && m == January)
                // Lunar New Year
                || ((d >= 27 && m == January) || (d == 1 && m == February))
                // adjusted holidays
                || (d == 27 && m == February)
                // adjusted holidays
                || (d == 3 && m == April)
                // Children's Day
                || (d == 4 && m == April)
                // adjusted holidays
                || (d == 29 && m == May)
                // Dragon Boat Festival
                || (d == 30 && m == May)
                // Mid-Autumn Festival
                || (d == 4 && m == October)
                // adjusted holidays
                || (d == 9 && m == October)
                )
                return false;
        }
    
        if (y == 2018) {
            if (// Lunar New Year
                (d >= 15 && d <= 20 && m == February)
                // Children's Day
                || (d == 4 && m == April)
                // Tomb Sweeping Day
                || (d == 5 && m == April)
                // adjusted holidays
                || (d == 6 && m == April)
                // Dragon Boat Festival
                || (d == 18 && m == June)
                // Mid-Autumn Festival
                || (d == 24 && m == September)
                // adjusted holidays
                || (d == 31 && m == December)
                )
                return false;
        }

        if (y == 2019) {
            if (// Lunar New Year
                (d >= 4 && d <= 8 && m == February)
                // adjusted holidays
                || (d == 1 && m == March)
                // Children's Day
                || (d == 4 && m == April)
                // Tomb Sweeping Day
                || (d == 5 && m == April)
                // Dragon Boat Festival
                || (d == 7 && m == June)
                // Mid-Autumn Festival
                || (d == 13 && m == September)
                // adjusted holidays
                || (d == 11 && m == October)
                )
                return false;
        }

        if (y == 2020) {
            if (// adjusted holiday
                (d == 23 && m == January)
                // Lunar New Year
                || (d >= 24 && d <= 29 && m == January)
                // adjusted holiday
                || (d == 2 && m == April)
                // adjusted holiday
                || (d == 3 && m == April)
                // Dragon Boat Festival
                || (d == 25 && m == June)
                // adjusted holiday
                || (d == 26 && m == June)
                // Mid-Autumn Festival
                || (d == 1 && m == October)
                // adjusted holiday
                || (d == 2 && m == October)
                // adjusted holiday
                || (d == 9 && m == October)
                )
                return false;
        }

        if (y == 2021) {
            // Tomb Sweeping Day falls on Sunday
            if (// adjusted holiday
                (d == 10 && m == February)
                // Lunar New Year
                || (d >= 11 && d <= 16 && m == February)
                // adjusted holiday
                || (d == 1 && m == March)
                // Children's Day
                || (d == 2 && m == April)
                // adjusted holiday
                || (d == 5 && m == April)
                // adjusted holiday
                || (d == 30 && m == April)
                // Dragon Boat Festival
                || (d == 14 && m == June)
                // adjusted holiday
                || (d == 20 && m == September)
                // Mid-Autumn Festival
                || (d == 21 && m == September)
                // adjusted holiday
                || (d == 11 && m == October)
                // adjusted holiday
                || (d == 31 && m == December)
                )
                return false;
        }

        if (y == 2022) {
            // Mid-Autumn Festival falls on Saturday
            if ( // Lunar New Year
                ((d == 31 && m == January) || (d <= 4 && m == February))
                // Children's Day
                || (d == 4 && m == April)
                // Tomb Sweeping Day
                || (d == 5 && m == April)
                // adjusted holiday
                || (d == 2 && m == May)
                // Dragon Boat Festival
                || (d == 3 && m == June)
                // adjusted holiday
                || (d == 9 && m == September)
                )
                return false;
        }

        if (y == 2023) {
            if (// adjusted holiday
                (d == 2 && m == January)
                // adjusted holiday
                || (d == 20 && m == January)
                // Lunar New Year
                || (d >= 21 && d <= 24 && m == January)
                // adjusted holiday
                || (d >= 25 && d <= 27 && m == January)
                // adjusted holiday
                || (d == 27 && m == February)
                // adjusted holiday
                || (d == 3 && m == April)
                // Children's Day
                || (d == 4 && m == April)
                // Tomb Sweeping Day
                || (d == 5 && m == April)
                // Dragon Boat Festival
                || (d == 22 && m == June)
                // adjusted holiday
                || (d == 23 && m == June)
                // Mid-Autumn Festival
                || (d == 29 && m == September)
                // adjusted holiday
                || (d == 9 && m == October)
                )
                return false;
        }

        if (y == 2024) {
            if ( // adjusted holiday
                (d == 8 && m == February)
                // Lunar New Year
                || (d >= 9 && d <= 12 && m == February)
                // adjusted holiday
                || (d >= 13 && d <= 14 && m == February)
                // Children's Day
                || (d == 4 && m == April)
                // Tomb-sweeping Day
                || (d == 5 && m == April)
                // Dragon Boat Festival
                || (d == 10 && m == June)
                // Mid-autumn/Moon Festival
                || (d == 17 && m == September)
            )
                return false;
        }

        return true;
    }

}
]]></document_content>
  </document>
  <document index="41">
    <source>calendars/target.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/target.hpp>

namespace QuantLib {

    TARGET::TARGET() {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new TARGET::Impl);
        impl_ = impl;
    }

    bool TARGET::Impl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day
            || (d == 1  && m == January)
            // Good Friday
            || (dd == em-3 && y >= 2000)
            // Easter Monday
            || (dd == em && y >= 2000)
            // Labour Day
            || (d == 1  && m == May && y >= 2000)
            // Christmas
            || (d == 25 && m == December)
            // Day of Goodwill
            || (d == 26 && m == December && y >= 2000)
            // December 31st, 1998, 1999, and 2001 only
            || (d == 31 && m == December &&
                (y == 1998 || y == 1999 || y == 2001)))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="42">
    <source>calendars/thailand.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Matthias Groncki
 Copyright (C) 2023, 2024 Skandinaviska Enskilda Banken AB (publ)

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/thailand.hpp>

namespace QuantLib {

    Thailand::Thailand() {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new Thailand::SetImpl);
        impl_ = impl;
    }

    bool Thailand::SetImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();

        if (isWeekend(w)
            // New Year's Day
            || ((d == 1 || (d == 3 && w == Monday)) && m == January)
            // Chakri Memorial Day
            || ((d == 6 || ((d == 7 || d == 8) && w == Monday)) && m == April)
            // Songkran Festival (was cancelled in 2020 due to the Covid-19 Pandamic)
            || ((d == 13 || d == 14 || d == 15) && m == April && y != 2020)
            // Substitution Songkran Festival, usually not more than 5 days in total (was cancelled
            // in 2020 due to the Covid-19 Pandamic)
            || (d == 16 && (w == Monday || w == Tuesday) && m == April && y != 2020)
            // Labor Day
            || ((d == 1 || ((d == 2 || d == 3) && w == Monday)) && m == May)
            // Coronation Day
            || ((d == 4 || ((d == 5 || d == 6) && w == Monday)) && m == May && y >= 2019)
            // H.M.Queen Suthida Bajrasudhabimalalakshana’s Birthday
            || ((d == 03 || ((d == 04 || d == 05) && w == Monday)) && m == June && y >= 2019)
            // H.M. King Maha Vajiralongkorn Phra Vajiraklaochaoyuhua’s Birthday
            || ((d == 28 || ((d == 29 || d == 30) && w == Monday)) && m == July && y >= 2017)
            // 	​H.M. Queen Sirikit The Queen Mother’s Birthday / Mother’s Day
            || ((d == 12 || ((d == 13 || d == 14) && w == Monday)) && m == August)
            // H.M. King Bhumibol Adulyadej The Great Memorial Day
            || ((d == 13 || ((d == 14 || d == 15) && w == Monday)) && m == October && y >= 2017)
            // Chulalongkorn Day
            || ((d == 23 || ((d == 24 || d == 25) && w == Monday)) && m == October && y != 2021)  // Moved 2021, see below
            // H.M. King Bhumibol Adulyadej The Great’s Birthday/ National Day / Father’s Day
            || ((d == 5 || ((d == 6 || d == 7) && w == Monday)) && m == December)
            // Constitution Day
            || ((d == 10 || ((d == 11 || d == 12) && w == Monday)) && m == December)
            // New Year’s Eve
            || ((d == 31 && m == December) || (d == 2 && w == Monday && m == January && y != 2024))  // Moved 2024
            )
            return false;

        if ((y == 2000) &&
            (   (d==21 && m==February)  // Makha Bucha Day (Substitution Day)
             || (d==5  && m==May)       // Coronation Day
             || (d==17 && m==May)       // Wisakha Bucha Day
             || (d==17 && m==July)      // Buddhist Lent Day
             || (d==23 && m==October)   // Chulalongkorn Day
                ))
            return false;

        if ((y == 2001) &&
            (   (d==8 && m==February) // Makha Bucha Day
             || (d==7 && m==May)      // Wisakha Bucha Day
             || (d==8 && m==May)      // Coronation Day (Substitution Day)
             || (d==6 && m==July)     // Buddhist Lent Day
             || (d==23 && m==October) // Chulalongkorn Day
                ))
            return false;

        // 2002, 2003 and 2004 are missing

        if ((y == 2005) &&
            (   (d==23 && m==February) // Makha Bucha Day
             || (d==5 && m==May)       // Coronation Day
             || (d==23 && m==May)      // Wisakha Bucha Day (Substitution Day for Sunday 22 May)
             || (d==1 && m==July)      // Mid Year Closing Day
             || (d==22 && m==July)     // Buddhist Lent Day
             || (d==24 && m==October)  // Chulalongkorn Day (Substitution Day for Sunday 23 October)
                ))
            return false;

        if ((y == 2006) &&
            (  (d==13 && m==February) // Makha Bucha Day
            || (d==19 && m==April)    // Special Holiday
            || (d==5 && m==May)       // Coronation Day
            || (d==12 && m==May)      // Wisakha Bucha Day
            || (d==12 && m==June)     // Special Holidays (Due to the auspicious occasion of the
                                      // celebration of 60th Anniversary of His Majesty's Accession
                                      // to the throne. For Bangkok, Samut Prakan, Nonthaburi,
                                      // Pathumthani and Nakhon Pathom province)
            || (d==13 && m==June)     // Special Holidays (as above)
            || (d==11 && m==July)     // Buddhist Lent Day
            || (d==23 && m==October)  // Chulalongkorn Day
               ))
            return false;

        if ((y == 2007) &&
            (   (d==5 && m==March)     // Makha Bucha Day (Substitution Day for Saturday 3 March)
             || (d==7 && m==May)       // Coronation Day (Substitution Day for Saturday 5 May)
             || (d==31 && m==May)      // Wisakha Bucha Day
             || (d==30 && m==July)     // Asarnha Bucha Day (Substitution Day for Sunday 29 July)
             || (d==23 && m==October)  // Chulalongkorn Day
             || (d==24 && m==December) // Special Holiday
                ))
            return false;

        if ((y == 2008) &&
            (   (d==21 && m==February) // Makha Bucha Day
             || (d==5 && m==May)       // Coronation Day
             || (d==19 && m==May)      // Wisakha Bucha Day
             || (d==1 && m==July)      // Mid Year Closing Day
             || (d==17 && m==July)     // Asarnha Bucha Day
             || (d==23 && m==October)  // Chulalongkorn Day
               ))
            return false;

        if ((y == 2009) &&
            (   (d==2 && m==January)  // Special Holiday
             || (d==9 && m==February) // Makha Bucha Day
             || (d==5 && m==May)      // Coronation Day
             || (d==8 && m==May)      // Wisakha Bucha Day
             || (d==1 && m==July)     // Mid Year Closing Day
             || (d==6 && m==July)     // Special Holiday
             || (d==7 && m==July)     // Asarnha Bucha Day
             || (d==23 && m==October) // Chulalongkorn Day
               ))
            return false;

        if ((y == 2010) &&
            (   (d==1 && m==March)    // Substitution for Makha Bucha Day(Sunday 28 February)
             || (d==5 && m==May)      // Coronation Day
             || (d==20 && m==May)     // Special Holiday
             || (d==21 && m==May)     // Special Holiday
             || (d==28 && m==May)     // Wisakha Bucha Day
             || (d==1 && m==July)     // Mid Year Closing Day
             || (d==26 && m==July)    // Asarnha Bucha Day
             || (d==13 && m==August)  // Special Holiday
             || (d==25 && m==October) // Substitution for Chulalongkorn Day(Saturday 23 October)
               ))
            return false;

        if ((y == 2011) &&
            (   (d==18 && m==February) // Makha Bucha Day
             || (d==5 && m==May)       // Coronation Day
             || (d==16 && m==May)      // Special Holiday
             || (d==17 && m==May)      // Wisakha Bucha Day
             || (d==1 && m==July)      // Mid Year Closing Day
             || (d==15 && m==July)     // Asarnha Bucha Day
             || (d==24 && m==October)  // Substitution for Chulalongkorn Day(Sunday 23 October)
               ))
            return false;

        if ((y == 2012) &&
            (   (d==3 && m==January)  // Special Holiday
             || (d==7 && m==March)    // Makha Bucha Day 2/
             || (d==9 && m==April)    // Special Holiday
             || (d==7 && m==May)      // Substitution for Coronation Day(Saturday 5 May)
             || (d==4 && m==June)     // Wisakha Bucha Day
             || (d==2 && m==August)   // Asarnha Bucha Day
             || (d==23 && m==October) // Chulalongkorn Day
                ))
            return false;

        if ((y == 2013) &&
            (   (d==25 && m==February) // Makha Bucha Day
             || (d==6 && m==May)       // Substitution for Coronation Day(Sunday 5 May)
             || (d==24 && m==May)      // Wisakha Bucha Day
             || (d==1 && m==July)      // Mid Year Closing Day
             || (d==22 && m==July)     // Asarnha Bucha Day 2/
             || (d==23 && m==October)  // Chulalongkorn Day
             || (d==30 && m==December) // Special Holiday
                ))
            return false;

        if ((y == 2014) &&
            (   (d==14 && m==February) // Makha Bucha Day
             || (d==5 && m==May)       // Coronation Day
             || (d==13 && m==May)      // Wisakha Bucha Day
             || (d==1 && m==July)      // Mid Year Closing Day
             || (d==11 && m==July)     // Asarnha Bucha Day 1/
             || (d==11 && m==August)   // Special Holiday
             || (d==23 && m==October)  // Chulalongkorn Day
                ))
            return false;

        if ((y == 2015) &&
            (   (d==2 && m==January)  // Special Holiday
             || (d==4 && m==March)    // Makha Bucha Day
             || (d==4 && m==May)      // Special Holiday
             || (d==5 && m==May)      // Coronation Day
             || (d==1 && m==June)     // Wisakha Bucha Day
             || (d==1 && m==July)     // Mid Year Closing Day
             || (d==30 && m==July)    // Asarnha Bucha Day 1/
             || (d==23 && m==October) // Chulalongkorn Day
                ))
            return false;

        if ((y == 2016) &&
            (   (d==22 && m==February) // Makha Bucha Day
             || (d==5 && m==May)       // Coronation Day
             || (d==6 && m==May)       // Special Holiday
             || (d==20 && m==May)      // Wisakha Bucha Day
             || (d==1 && m==July)      //  Mid Year Closing Day
             || (d==18 && m==July)     // Special Holiday
             || (d==19 && m==July)     // Asarnha Bucha Day 1/
             || (d==24 && m==October)  // Substitution for Chulalongkorn Day (Sunday 23rd October)
                ))
            return false;

        if ((y == 2017) &&
            (      (d == 13 && m == February)  // Makha Bucha Day
                || (d == 10 && m == May)       // Wisakha Bucha Day
                || (d == 10 && m == July)      // Asarnha Bucha Day
                || (d == 23 && m == October)   // Chulalongkorn Day
                || (d == 26 && m == October)   // Special Holiday
                ))
            return false;

        if ((y == 2018) &&
            (   (d==1 && m==March)    // Makha Bucha Day
             || (d==29 && m==May)     // Wisakha Bucha Day
             || (d==27 && m==July)    // Asarnha Bucha Day1
             || (d==23 && m==October) // Chulalongkorn Day
                ))
            return false;

        if ((y == 2019) && ((d == 19 && m == February) // Makha Bucha Day
                            || (d == 6 && m == May)    // Special Holiday
                            || (d == 20 && m == May)   // Wisakha Bucha Day
                            || (d == 16 && m == July)  // Asarnha Bucha Day
                            ))
            return false;

        if ((y == 2020) && ((d == 10 && m == February)    // Makha Bucha Day
                            || (d == 6 && m == May)       // Wisakha Bucha Day
                            || (d == 6 && m == July)      // Asarnha Bucha Day
                            || (d == 27 && m == July)     // Substitution for Songkran Festival
                            || (d == 4 && m == September) // Substitution for Songkran Festival
                            || (d == 7 && m == September) // Substitution for Songkran Festival
                            || (d == 11 && m == December) // Special Holiday
                            ))
            return false;

        if ((y == 2021) && ((d == 12 && m == February)     // Special Holiday
                            || (d == 26 && m == February)  // Makha Bucha Day
                            || (d == 26 && m == May)       // Wisakha Bucha Day
                            || (d == 26 && m == July)      // Substitution for Asarnha Bucha Day (Saturday 24th July 2021)
                            || (d == 24 && m == September) // Special Holiday
                            || (d == 22 && m == October)   // ​Substitution for Chulalongkorn Day
                            ))
            return false;

        if ((y == 2022) && ((d == 16 && m == February)   // Makha Bucha Day
                            || (d == 16 && m == May)     // Substitution for Wisakha Bucha Day (Sunday 15th May 2022)
                            || (d == 13 && m == July)    // Asarnha Bucha Day
                            || (d == 29 && m == July)    // Additional special holiday (added)
                            || (d == 14 && m == October) // Additional special holiday (added)
                            || (d == 24 && m == October) // ​Substitution for Chulalongkorn Day (Sunday 23rd October 2022)
            ))
            return false;

        if ((y == 2023) && ((d == 6 && m == March)        // Makha Bucha Day
                            || (d == 5 && m == May)       // Additional special holiday (added)
                            || (d == 5 && m == June)      // Substitution for H.M. Queen's birthday and Wisakha Bucha Day (Saturday 3rd June 2022)
                            || (d == 1 && m == August)    // Asarnha Bucha Day
                            || (d == 23 && m == October)  // Chulalongkorn Day
                            || (d == 29 && m == December) // Substitution for New Year’s Eve (Sunday 31st December 2023) (added)
            ))
            return false;

        if ((y == 2024) && ((d == 26 && m == February)    // Substitution for Makha Bucha Day (Saturday 24th February 2024)
                            || (d == 8 && m == April)     // Substitution for Chakri Memorial Day (Saturday 6th April 2024)
                            || (d == 12 && m == April)    // Additional holiday in relation to the Songkran festival
                            || (d == 6 && m == May)       // Substitution for Coronation Day (Saturday 4th May 2024)
                            || (d == 22 && m == May)      // Wisakha Bucha Day
                            || (d == 22 && m == July)     // Substitution for Asarnha Bucha Day (Saturday 20th July 2024)
                            || (d == 23 && m == October)  // Chulalongkorn Day
            ))
            return false;

        if ((y == 2025) && ((d == 12 && m == February)    // Substitution for Makha Bucha Day (Wednesday 12th February 2025)
            || (d == 7 && m == April)     // Substitution for Chakri Memorial Day (Sunday 6th April 2025)
            || (d == 5 && m == May)       // Substitution for Coronation Day (Sunday 4th May 2025)
            || (d == 12 && m == May)      // Wisakha Bucha Day
            || (d == 10 && m == July)     // Substitution for Asarnha Bucha Day (Tuesday 20th July 2025)
            || (d == 23 && m == October)  // Chulalongkorn Day
            ))
            return false;

        return true;
    }

}
]]></document_content>
  </document>
  <document index="43">
    <source>calendars/turkey.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Sercan Atalik
 Copyright (C) 2010 StatPro Italia srl
 Copyright (C) 2018 Matthias Lungwitz
 Copyright (C) 2022 Skandinaviska Enskilda Banken AB (publ)

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/turkey.hpp>

namespace QuantLib {

    Turkey::Turkey() {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new Turkey::Impl);
        impl_ = impl;
    }

    bool Turkey::Impl::isWeekend(Weekday w) const {
        return w == Saturday || w == Sunday;
    }

    bool Turkey::Impl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();

        if (isWeekend(w)
            // New Year's Day
            || (d == 1 && m == January)
            // 23 nisan / National Holiday
            || (d == 23 && m == April)
            // 1 may/ National Holiday
            || (d == 1 && m == May)
            // 19 may/ National Holiday
            || (d == 19 && m == May)
            // 15 july / National Holiday (since 2017)
            || (d == 15 && m == July && y >= 2017)
            // 30 aug/ National Holiday
            || (d == 30 && m == August)
            ///29 ekim  National Holiday
            || (d == 29 && m == October))
            return false;

        // Local Holidays
        if (y == 2004) {
            // Kurban
            if ((m == February && d <= 4)
            // Ramadan
                || (m == November && d >= 14 && d <= 16))
                return false;
        } else if (y == 2005) {
            // Kurban
            if ((m == January && d >= 19 && d <= 21)
            // Ramadan
                || (m == November && d >= 2 && d <= 5))
                return false;
        } else if (y == 2006) {
            // Kurban
            if ((m == January && d >= 10 && d <= 13)
            // Ramadan
                || (m == October && d >= 23 && d <= 25)
            // Kurban
                || (m == December && d == 31))
                return false;
        } else if (y == 2007) {
            // Kurban
            if ((m == January && d <= 3)
            // Ramadan
                || (m == October && d >= 12 && d <= 14)
            // Kurban
                || (m == December && d >= 20 && d <= 23))
                return false;
        } else if (y == 2008) {
            // Ramadan
            if ((m == September && d == 30)
                || (m == October && d <= 2)
            // Kurban
                || (m == December && d >= 8 && d <= 11))
                return false;
        } else if (y == 2009) {
            // Ramadan
            if ((m == September && d >= 20 && d <= 22)
            // Kurban
                || (m == November && d >= 27 && d <= 30))
                return false;
        } else if (y == 2010) {
            // Ramadan
            if ((m == September && d >= 9 && d <= 11)
            // Kurban
                || (m == November && d >= 16 && d <= 19))
                return false;
        } else if (y == 2011) {
            // not clear from borsainstanbul.com
            if ((m == October && d == 1)
                || (m == November && d >= 9 && d <= 13))
                return false;
        } else if (y == 2012) {
            // Ramadan
            if ((m == August && d >= 18 && d <= 21)
            // Kurban
                || (m == October && d >= 24 && d <= 28))
                return false;
        } else if (y == 2013) {
            // Ramadan
            if ((m == August && d >= 7 && d <= 10)
            // Kurban
                || (m == October && d >= 14 && d <= 18)
            // additional holiday for Republic Day
                || (m == October && d == 28))
                return false;
        } else if (y == 2014) {
            // Ramadan
            if ((m == July && d >= 27 && d <= 30)
            // Kurban
                || (m == October && d >= 4 && d <= 7)
            // additional holiday for Republic Day
                || (m == October && d == 29))
                return false;
		} else if (y == 2015) {
			// Ramadan
			if ((m == July && d >= 17 && d <= 19)
				// Kurban
				|| (m == October && d >= 24 && d <= 27))
				return false;
		} else if (y == 2016) {
			// Ramadan
			if ((m == July && d >= 5 && d <= 7)
				// Kurban
				|| (m == September && d >= 12 && d <= 15))
				return false;
		} else if (y == 2017) {
			// Ramadan
			if ((m == June && d >= 25 && d <= 27)
				// Kurban
				|| (m == September && d >= 1 && d <= 4))
				return false;
		} else if (y == 2018) {
			// Ramadan
			if ((m == June && d >= 15 && d <= 17)
				// Kurban
				|| (m == August && d >= 21 && d <= 24))
				return false;
		} else if (y == 2019) {
			// Ramadan
			if ((m == June && d >= 4 && d <= 6)
				// Kurban
				|| (m == August && d >= 11 && d <= 14))
				return false;
		} else if (y == 2020) {
			// Ramadan
			if ((m == May && d >= 24 && d <= 26)
				// Kurban
				|| (m == July && d == 31) || (m == August && d >= 1 && d <= 3))
				return false;
		} else if (y == 2021) {
			// Ramadan
			if ((m == May && d >= 13 && d <= 15)
				// Kurban
				|| (m == July && d >= 20 && d <= 23))
				return false;
		} else if (y == 2022) {
			// Ramadan
			if ((m == May && d >= 2 && d <= 4)
				// Kurban
				|| (m == July && d >= 9 && d <= 12))
				return false;
		} else if (y == 2023) {
			// Ramadan
			if ((m == April && d >= 21 && d <= 23)
				// Kurban
                // July 1 is also a holiday but falls on a Saturday which is already flagged
				|| (m == June && d >= 28 && d <= 30))
				return false;
		} else if (y == 2024) {
		// Note: Holidays >= 2024 are not yet officially anounced by borsaistanbul.com
		// and need further validation
			// Ramadan
			if ((m == April && d >= 10 && d <= 12)
				// Kurban
				|| (m == June && d >= 17 && d <= 19))
				return false;
		} else if (y == 2025) {
			// Ramadan
			if ((m == March && d == 31) || (m == April && d >= 1 && d <= 2)
				// Kurban
				|| (m == June && d >= 6 && d <= 9))
				return false;
		} else if (y == 2026) {
			// Ramadan
			if ((m == March && d >= 20 && d <= 22)
				// Kurban
				|| (m == May && d >= 26 && d <= 29))
				return false;
		} else if (y == 2027) {
			// Ramadan
			if ((m == March && d >= 10 && d <= 12)
				// Kurban
				|| (m == May && d >= 16 && d <= 19))
				return false;
		} else if (y == 2028) {
			// Ramadan
			if ((m == February && d >= 27 && d <= 29)
				// Kurban
				|| (m == May && d >= 4 && d <= 7))
				return false;
		} else if (y == 2029) {
			// Ramadan
			if ((m == February && d >= 15 && d <= 17)
				// Kurban
				|| (m == April && d >= 23 && d <= 26))
				return false;
		} else if (y == 2030) {
			// Ramadan
			if ((m == February && d >= 5 && d <= 7)
				// Kurban
				|| (m == April && d >= 13 && d <= 16))
				return false;
		} else if (y == 2031) {
			// Ramadan
			if ((m == January && d >= 25 && d <= 27)
				// Kurban
				|| (m == April && d >= 2 && d <= 5))
				return false;
		} else if (y == 2032) {
			// Ramadan
			if ((m == January && d >= 14 && d <= 16)
				// Kurban
				|| (m == March && d >= 21 && d <= 24))
				return false;
		} else if (y == 2033) {
			// Ramadan
			if ((m == January && d >= 3 && d <= 5) || (m == December && d == 23)
				// Kurban
				|| (m == March && d >= 11 && d <= 14))
				return false;
		} else if (y == 2034) {
			// Ramadan
			if ((m == December && d >= 12 && d <= 14) 
				// Kurban
				|| (m == February && d == 28) || (m == March && d >= 1 && d <= 3))
				return false;
		}
        return true;
    }

}

]]></document_content>
  </document>
  <document index="44">
    <source>calendars/ukraine.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/ukraine.hpp>

namespace QuantLib {

    Ukraine::Ukraine(Market) {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new Ukraine::UseImpl);
        impl_ = impl;
    }

    bool Ukraine::UseImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day (possibly moved to Monday)
            || ((d == 1 || ((d == 2 || d == 3) && w == Monday))
                && m == January)
            // Orthodox Christmas
            || ((d == 7 || ((d == 8 || d == 9) && w == Monday))
                && m == January)
            // Women's Day
            || ((d == 8 || ((d == 9 || d == 10) && w == Monday))
                && m == March)
            // Orthodox Easter Monday
            || (dd == em)
            // Holy Trinity Day
            || (dd == em+49)
            // Workers' Solidarity Days
            || ((d == 1 || d == 2 || (d == 3 && w == Monday)) && m == May)
            // Victory Day
            || ((d == 9 || ((d == 10 || d == 11) && w == Monday)) && m == May)
            // Constitution Day
            || (d == 28 && m == June)
            // Independence Day
            || (d == 24 && m == August)
            // Defender's Day (since 2015)
            || (d == 14 && m == October && y >= 2015))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="45">
    <source>calendars/unitedkingdom.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/unitedkingdom.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    namespace {

        // common rules

        bool isBankHoliday(Day d, Weekday w, Month m, Year y) {
            return
                // first Monday of May (Early May Bank Holiday)
                // moved to May 8th in 1995 and 2020 for V.E. day
                (d <= 7 && w == Monday && m == May && y != 1995 && y != 2020)
                || (d == 8 && m == May && (y == 1995 || y == 2020))
                // last Monday of May (Spring Bank Holiday)
                // moved to in 2002, 2012 and 2022 for the Golden, Diamond and Platinum
                // Jubilee with an additional holiday
                || (d >= 25 && w == Monday && m == May && y != 2002 && y != 2012 && y != 2022)
                || ((d == 3 || d == 4) && m == June && y == 2002)
                || ((d == 4 || d == 5) && m == June && y == 2012)
                || ((d == 2 || d == 3) && m == June && y == 2022)
                // last Monday of August (Summer Bank Holiday)
                || (d >= 25 && w == Monday && m == August)
                // April 29th, 2011 only (Royal Wedding Bank Holiday)
                || (d == 29 && m == April && y == 2011)
                // September 19th, 2022 only (The Queen's Funeral Bank Holiday)
                || (d == 19 && m == September && y == 2022)
                // May 8th, 2023 (King Charles III Coronation Bank Holiday)
                || (d == 8 && m == May && y == 2023)
                ;
        }

    }

    UnitedKingdom::UnitedKingdom(UnitedKingdom::Market market) {
        // all calendar instances on the same market share the same
        // implementation instance
        static ext::shared_ptr<Calendar::Impl> settlementImpl(
                                           new UnitedKingdom::SettlementImpl);
        static ext::shared_ptr<Calendar::Impl> exchangeImpl(
                                           new UnitedKingdom::ExchangeImpl);
        static ext::shared_ptr<Calendar::Impl> metalsImpl(
                                           new UnitedKingdom::MetalsImpl);
        switch (market) {
          case Settlement:
            impl_ = settlementImpl;
            break;
          case Exchange:
            impl_ = exchangeImpl;
            break;
          case Metals:
            impl_ = metalsImpl;
            break;
          default:
            QL_FAIL("unknown market");
        }
    }

    bool UnitedKingdom::SettlementImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day (possibly moved to Monday)
            || ((d == 1 || ((d == 2 || d == 3) && w == Monday)) &&
                m == January)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            || isBankHoliday(d, w, m, y)
            // Christmas (possibly moved to Monday or Tuesday)
            || ((d == 25 || (d == 27 && (w == Monday || w == Tuesday)))
                && m == December)
            // Boxing Day (possibly moved to Monday or Tuesday)
            || ((d == 26 || (d == 28 && (w == Monday || w == Tuesday)))
                && m == December)
            // December 31st, 1999 only
            || (d == 31 && m == December && y == 1999))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }


    bool UnitedKingdom::ExchangeImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day (possibly moved to Monday)
            || ((d == 1 || ((d == 2 || d == 3) && w == Monday)) &&
                m == January)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            || isBankHoliday(d, w, m, y)
            // Christmas (possibly moved to Monday or Tuesday)
            || ((d == 25 || (d == 27 && (w == Monday || w == Tuesday)))
                && m == December)
            // Boxing Day (possibly moved to Monday or Tuesday)
            || ((d == 26 || (d == 28 && (w == Monday || w == Tuesday)))
                && m == December)
            // December 31st, 1999 only
            || (d == 31 && m == December && y == 1999))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }


    bool UnitedKingdom::MetalsImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day (possibly moved to Monday)
            || ((d == 1 || ((d == 2 || d == 3) && w == Monday)) &&
                m == January)
            // Good Friday
            || (dd == em-3)
            // Easter Monday
            || (dd == em)
            || isBankHoliday(d, w, m, y)
            // Christmas (possibly moved to Monday or Tuesday)
            || ((d == 25 || (d == 27 && (w == Monday || w == Tuesday)))
                && m == December)
            // Boxing Day (possibly moved to Monday or Tuesday)
            || ((d == 26 || (d == 28 && (w == Monday || w == Tuesday)))
                && m == December)
            // December 31st, 1999 only
            || (d == 31 && m == December && y == 1999))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}

]]></document_content>
  </document>
  <document index="46">
    <source>calendars/unitedstates.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2005 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl
 Copyright (C) 2017 Peter Caspers
 Copyright (C) 2017 Oleg Kulkov
 Copyright (C) 2023 Skandinaviska Enskilda Banken AB (publ)
 Copyright (C) 2024 Dirk Eddelbuettel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/unitedstates.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    namespace {

        // a few rules used by multiple calendars

        bool isWashingtonBirthday(Day d, Month m, Year y, Weekday w) {
            if (y >= 1971) {
                // third Monday in February
                return (d >= 15 && d <= 21) && w == Monday && m == February;
            } else {
                // February 22nd, possibly adjusted
                return (d == 22 || (d == 23 && w == Monday)
                        || (d == 21 && w == Friday)) && m == February;
            }
        }

        bool isMemorialDay(Day d, Month m, Year y, Weekday w) {
            if (y >= 1971) {
                // last Monday in May
                return d >= 25 && w == Monday && m == May;
            } else {
                // May 30th, possibly adjusted
                return (d == 30 || (d == 31 && w == Monday)
                        || (d == 29 && w == Friday)) && m == May;
            }
        }

        bool isLaborDay(Day d, Month m, Year y, Weekday w) {
            // first Monday in September
            return d <= 7 && w == Monday && m == September;
        }

        bool isColumbusDay(Day d, Month m, Year y, Weekday w) {
            // second Monday in October
            return (d >= 8 && d <= 14) && w == Monday && m == October
                && y >= 1971;
        }

        bool isVeteransDay(Day d, Month m, Year y, Weekday w) {
            if (y <= 1970 || y >= 1978) {
                // November 11th, adjusted
                return (d == 11 || (d == 12 && w == Monday) ||
                        (d == 10 && w == Friday)) && m == November;
            } else {
                // fourth Monday in October
                return (d >= 22 && d <= 28) && w == Monday && m == October;
            }
        }

        bool isVeteransDayNoSaturday(Day d, Month m, Year y, Weekday w) {
            if (y <= 1970 || y >= 1978) {
                // November 11th, adjusted, but no Saturday to Friday
                return (d == 11 || (d == 12 && w == Monday)) && m == November;
            } else {
                // fourth Monday in October
                return (d >= 22 && d <= 28) && w == Monday && m == October;
            }
        }

        bool isJuneteenth(Day d, Month m, Year y, Weekday w, bool moveToFriday = true) {
            // declared in 2021, but only observed by exchanges since 2022
            return (d == 19 || (d == 20 && w == Monday) || ((d == 18 && w == Friday) && moveToFriday))
                && m == June && y >= 2022;
        }
    }

    UnitedStates::UnitedStates(UnitedStates::Market market) {
        // all calendar instances on the same market share the same implementation instance
        static auto settlementImpl = ext::make_shared<UnitedStates::SettlementImpl>();
        static auto liborImpactImpl = ext::make_shared<UnitedStates::LiborImpactImpl>();
        static auto nyseImpl = ext::make_shared<UnitedStates::NyseImpl>();
        static auto governmentImpl = ext::make_shared<UnitedStates::GovernmentBondImpl>();
        static auto nercImpl = ext::make_shared<UnitedStates::NercImpl>();
        static auto federalReserveImpl = ext::make_shared<UnitedStates::FederalReserveImpl>();
        static auto sofrImpl = ext::make_shared<UnitedStates::SofrImpl>();

        switch (market) {
          case Settlement:
            impl_ = settlementImpl;
            break;
          case LiborImpact:
            impl_ = liborImpactImpl;
            break;
          case NYSE:
            impl_ = nyseImpl;
            break;
          case GovernmentBond:
            impl_ = governmentImpl;
            break;
          case SOFR:
            impl_ = sofrImpl;
            break;
          case NERC:
            impl_ = nercImpl;
            break;
          case FederalReserve:
            impl_ = federalReserveImpl;
            break;
          default:
            QL_FAIL("unknown market");
        }
    }


    bool UnitedStates::SettlementImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();
        if (isWeekend(w)
            // New Year's Day (possibly moved to Monday if on Sunday)
            || ((d == 1 || (d == 2 && w == Monday)) && m == January)
            // (or to Friday if on Saturday)
            || (d == 31 && w == Friday && m == December)
            // Martin Luther King's birthday (third Monday in January)
            || ((d >= 15 && d <= 21) && w == Monday && m == January
                && y >= 1983)
            // Washington's birthday (third Monday in February)
            || isWashingtonBirthday(d, m, y, w)
            // Memorial Day (last Monday in May)
            || isMemorialDay(d, m, y, w)
            // Juneteenth (Monday if Sunday or Friday if Saturday)
            || isJuneteenth(d, m, y, w)
            // Independence Day (Monday if Sunday or Friday if Saturday)
            || ((d == 4 || (d == 5 && w == Monday) ||
                 (d == 3 && w == Friday)) && m == July)
            // Labor Day (first Monday in September)
            || isLaborDay(d, m, y, w)
            // Columbus Day (second Monday in October)
            || isColumbusDay(d, m, y, w)
            // Veteran's Day (Monday if Sunday or Friday if Saturday)
            || isVeteransDay(d, m, y, w)
            // Thanksgiving Day (fourth Thursday in November)
            || ((d >= 22 && d <= 28) && w == Thursday && m == November)
            // Christmas (Monday if Sunday or Friday if Saturday)
            || ((d == 25 || (d == 26 && w == Monday) ||
                 (d == 24 && w == Friday)) && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

    bool UnitedStates::LiborImpactImpl::isBusinessDay(const Date& date) const {
        // Since 2015 Independence Day only impacts Libor if it falls
        // on a weekday
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();
        if (((d == 5 && w == Monday) ||
            (d == 3 && w == Friday)) && m == July && y >= 2015)
            return true;
        return SettlementImpl::isBusinessDay(date);
    }

    bool UnitedStates::NyseImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day (possibly moved to Monday if on Sunday)
            || ((d == 1 || (d == 2 && w == Monday)) && m == January)
            // Washington's birthday (third Monday in February)
            || isWashingtonBirthday(d, m, y, w)
            // Good Friday
            || (dd == em-3)
            // Memorial Day (last Monday in May)
            || isMemorialDay(d, m, y, w)
            // Juneteenth (Monday if Sunday or Friday if Saturday)
            || isJuneteenth(d, m, y, w)
            // Independence Day (Monday if Sunday or Friday if Saturday)
            || ((d == 4 || (d == 5 && w == Monday) ||
                 (d == 3 && w == Friday)) && m == July)
            // Labor Day (first Monday in September)
            || isLaborDay(d, m, y, w)
            // Thanksgiving Day (fourth Thursday in November)
            || ((d >= 22 && d <= 28) && w == Thursday && m == November)
            // Christmas (Monday if Sunday or Friday if Saturday)
            || ((d == 25 || (d == 26 && w == Monday) ||
                 (d == 24 && w == Friday)) && m == December)
            ) return false;

        if (y >= 1998 && (d >= 15 && d <= 21) && w == Monday && m == January)
            // Martin Luther King's birthday (third Monday in January)
            return false;

        if ((y <= 1968 || (y <= 1980 && y % 4 == 0)) && m == November
            && d <= 7 && w == Tuesday)
            // Presidential election days
            return false;

        // Special closings
        if (// President Carter's Funeral
            (y == 2025 && m == January && d == 9)
            // President Bush's Funeral
            || (y == 2018 && m == December && d == 5)
            // Hurricane Sandy
            || (y == 2012 && m == October && (d == 29 || d == 30))
            // President Ford's funeral
            || (y == 2007 && m == January && d == 2)
            // President Reagan's funeral
            || (y == 2004 && m == June && d == 11)
            // September 11-14, 2001
            || (y == 2001 && m == September && (11 <= d && d <= 14))
            // President Nixon's funeral
            || (y == 1994 && m == April && d == 27)
            // Hurricane Gloria
            || (y == 1985 && m == September && d == 27)
            // 1977 Blackout
            || (y == 1977 && m == July && d == 14)
            // Funeral of former President Lyndon B. Johnson.
            || (y == 1973 && m == January && d == 25)
            // Funeral of former President Harry S. Truman
            || (y == 1972 && m == December && d == 28)
            // National Day of Participation for the lunar exploration.
            || (y == 1969 && m == July && d == 21)
            // Funeral of former President Eisenhower.
            || (y == 1969 && m == March && d == 31)
            // Closed all day - heavy snow.
            || (y == 1969 && m == February && d == 10)
            // Day after Independence Day.
            || (y == 1968 && m == July && d == 5)
            // June 12-Dec. 31, 1968
            // Four day week (closed on Wednesdays) - Paperwork Crisis
            || (y == 1968 && dd >= 163 && w == Wednesday)
            // Day of mourning for Martin Luther King Jr.
            || (y == 1968 && m == April && d == 9)
            // Funeral of President Kennedy
            || (y == 1963 && m == November && d == 25)
            // Day before Decoration Day
            || (y == 1961 && m == May && d == 29)
            // Day after Christmas
            || (y == 1958 && m == December && d == 26)
            // Christmas Eve
            || ((y == 1954 || y == 1956 || y == 1965)
                && m == December && d == 24)
            ) return false;

        return true;
    }


    bool UnitedStates::GovernmentBondImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth(), dd = date.dayOfYear();
        Month m = date.month();
        Year y = date.year();
        Day em = easterMonday(y);
        if (isWeekend(w)
            // New Year's Day (possibly moved to Monday if on Sunday)
            || ((d == 1 || (d == 2 && w == Monday)) && m == January)
            // Martin Luther King's birthday (third Monday in January)
            || ((d >= 15 && d <= 21) && w == Monday && m == January
                && y >= 1983)
            // Washington's birthday (third Monday in February)
            || isWashingtonBirthday(d, m, y, w)
            // Good Friday. Since 1996 it's an early close and not a full market
            // close when it coincides with the NFP release date, which is the
            // first Friday of the month(*).
            // See <https://www.sifma.org/resources/general/holiday-schedule/>
            //
            // (*) The full rule is "the third Friday after the conclusion of the
            // week which includes the 12th of the month". This is usually the
            // first Friday of the next month, but can be the second Friday if the
            // month has fewer than 31 days. Since Good Friday is always between
            // March 20th and April 23rd, it can only coincide with the April NFP,
            // which is always on the first Friday, because March has 31 days.
            || (dd == em-3 && (y < 1996 || d > 7))
            // Memorial Day (last Monday in May)
            || isMemorialDay(d, m, y, w)
            // Juneteenth (Monday if Sunday or Friday if Saturday)
            || isJuneteenth(d, m, y, w)
            // Independence Day (Monday if Sunday or Friday if Saturday)
            || ((d == 4 || (d == 5 && w == Monday) ||
                 (d == 3 && w == Friday)) && m == July)
            // Labor Day (first Monday in September)
            || isLaborDay(d, m, y, w)
            // Columbus Day (second Monday in October)
            || isColumbusDay(d, m, y, w)
            // Veteran's Day (Monday if Sunday)
            || isVeteransDayNoSaturday(d, m, y, w)
            // Thanksgiving Day (fourth Thursday in November)
            || ((d >= 22 && d <= 28) && w == Thursday && m == November)
            // Christmas (Monday if Sunday or Friday if Saturday)
            || ((d == 25 || (d == 26 && w == Monday) ||
                 (d == 24 && w == Friday)) && m == December))
            return false;

        // Special closings
        if (// President Bush's Funeral
            (y == 2018 && m == December && d == 5)
            // Hurricane Sandy
            || (y == 2012 && m == October && d == 30)
            // President Reagan's funeral
            || (y == 2004 && m == June && d == 11)
            ) return false;

        return true;
    }


    bool UnitedStates::SofrImpl::isBusinessDay(const Date& date) const {
        // so far (that is, up to 2023 at the time of this change) SOFR never fixed
        // on Good Friday.  We're extrapolating that pattern.  This might change if
        // a fixing on Good Friday occurs in future years.
        const Day dY = date.dayOfYear();
        const Year y = date.year();

        // Good Friday
        if (dY == (easterMonday(y) - 3))
            return false;

        return GovernmentBondImpl::isBusinessDay(date);
    }


    bool UnitedStates::NercImpl::isBusinessDay(const Date& date) const {
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();
        if (isWeekend(w)
            // New Year's Day (possibly moved to Monday if on Sunday)
            || ((d == 1 || (d == 2 && w == Monday)) && m == January)
            // Memorial Day (last Monday in May)
            || isMemorialDay(d, m, y, w)
            // Independence Day (Monday if Sunday)
            || ((d == 4 || (d == 5 && w == Monday)) && m == July)
            // Labor Day (first Monday in September)
            || isLaborDay(d, m, y, w)
            // Thanksgiving Day (fourth Thursday in November)
            || ((d >= 22 && d <= 28) && w == Thursday && m == November)
            // Christmas (Monday if Sunday)
            || ((d == 25 || (d == 26 && w == Monday)) && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }


    bool UnitedStates::FederalReserveImpl::isBusinessDay(const Date& date) const {
        // see https://www.frbservices.org/about/holiday-schedules for details
        Weekday w = date.weekday();
        Day d = date.dayOfMonth();
        Month m = date.month();
        Year y = date.year();
        if (isWeekend(w)
            // New Year's Day (possibly moved to Monday if on Sunday)
            || ((d == 1 || (d == 2 && w == Monday)) && m == January)
            // Martin Luther King's birthday (third Monday in January)
            || ((d >= 15 && d <= 21) && w == Monday && m == January
                && y >= 1983)
            // Washington's birthday (third Monday in February)
            || isWashingtonBirthday(d, m, y, w)
            // Memorial Day (last Monday in May)
            || isMemorialDay(d, m, y, w)
            // Juneteenth (Monday if Sunday)
            || isJuneteenth(d, m, y, w, false)
            // Independence Day (Monday if Sunday)
            || ((d == 4 || (d == 5 && w == Monday)) && m == July)
            // Labor Day (first Monday in September)
            || isLaborDay(d, m, y, w)
            // Columbus Day (second Monday in October)
            || isColumbusDay(d, m, y, w)
            // Veteran's Day (Monday if Sunday)
            || isVeteransDayNoSaturday(d, m, y, w)
            // Thanksgiving Day (fourth Thursday in November)
            || ((d >= 22 && d <= 28) && w == Thursday && m == November)
            // Christmas (Monday if Sunday)
            || ((d == 25 || (d == 26 && w == Monday)) && m == December))
            return false; // NOLINT(readability-simplify-boolean-expr)
        return true;
    }

}
]]></document_content>
  </document>
  <document index="47">
    <source>calendars/weekendsonly.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/calendars/weekendsonly.hpp>

namespace QuantLib {

    WeekendsOnly::WeekendsOnly() {
        // all calendar instances share the same implementation instance
        static ext::shared_ptr<Calendar::Impl> impl(new WeekendsOnly::Impl);
        impl_ = impl;
    }

    bool WeekendsOnly::Impl::isBusinessDay(const Date& date) const {
        return !isWeekend(date.weekday());
    }

}

]]></document_content>
  </document>
  <document index="48">
    <source>date.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007 StatPro Italia srl
 Copyright (C) 2004, 2005, 2006 Ferdinando Ametrano
 Copyright (C) 2006 Katiuscia Manzoni
 Copyright (C) 2006 Toyin Akin
 Copyright (C) 2015 Klaus Spanderen
 Copyright (C) 2020 Leonardo Arcari
 Copyright (C) 2020 Kline s.r.l.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/date.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/errors.hpp>
#include <boost/date_time/gregorian/gregorian.hpp>
#include <boost/date_time/posix_time/posix_time_types.hpp>
#include <functional>
#include <iomanip>
#include <ctime>

#ifdef QL_HIGH_RESOLUTION_DATE
#if BOOST_VERSION < 106700
#include <boost/functional/hash.hpp>
#else
#include <boost/container_hash/hash.hpp>
#endif
#endif

#if defined(BOOST_NO_STDC_NAMESPACE)
    namespace std { using ::time; using ::time_t; using ::tm;
                    using ::gmtime; using ::localtime; }
#endif

#ifdef QL_HIGH_RESOLUTION_DATE
using boost::posix_time::ptime;
using boost::posix_time::time_duration;
#endif


namespace QuantLib {
#ifndef QL_HIGH_RESOLUTION_DATE
    // constructors
    Date::Date()
    : serialNumber_(Date::serial_type(0)) {}

    Date::Date(Date::serial_type serialNumber)
    : serialNumber_(serialNumber) {
        checkSerialNumber(serialNumber);
    }

    Date::Date(Day d, Month m, Year y) {
        QL_REQUIRE(y > 1900 && y < 2200,
                   "year " << y << " out of bound. It must be in [1901,2199]");
        QL_REQUIRE(Integer(m) > 0 && Integer(m) < 13,
                   "month " << Integer(m)
                   << " outside January-December range [1,12]");

        bool leap = isLeap(y);
        Day len = monthLength(m,leap), offset = monthOffset(m,leap);
        QL_REQUIRE(d <= len && d > 0,
                   "day outside month (" << Integer(m) << ") day-range "
                   << "[1," << len << "]");

        serialNumber_ = d + offset + yearOffset(y);
    }

    Month Date::month() const {
        Day d = dayOfYear(); // dayOfYear is 1 based
        Integer m = d/30 + 1;
        bool leap = isLeap(year());
        while (d <= monthOffset(Month(m),leap))
            --m;
        while (d > monthOffset(Month(m+1),leap)) // NOLINT(misc-misplaced-widening-cast)
            ++m;
        return Month(m);
    }

    Year Date::year() const {
        Year y = (serialNumber_ / 365)+1900;
        // yearOffset(y) is December 31st of the preceding year
        if (serialNumber_ <= yearOffset(y))
            --y;
        return y;
    }

    Date& Date::operator+=(Date::serial_type days) {
        Date::serial_type serial = serialNumber_ + days;
        checkSerialNumber(serial);
        serialNumber_ = serial;
        return *this;
    }

    Date& Date::operator+=(const Period& p) {
        serialNumber_ = advance(*this,p.length(),p.units()).serialNumber();
        return *this;
    }

    Date& Date::operator-=(Date::serial_type days) {
        Date::serial_type serial = serialNumber_ - days;
        checkSerialNumber(serial);
        serialNumber_ = serial;
        return *this;
    }

    Date& Date::operator-=(const Period& p) {
        serialNumber_ = advance(*this,-p.length(),p.units()).serialNumber();
        return *this;
    }

    Date& Date::operator++() {
        Date::serial_type serial = serialNumber_ + 1;
        checkSerialNumber(serial);
        serialNumber_ = serial;
        return *this;
    }

    Date& Date::operator--() {
        Date::serial_type serial = serialNumber_ - 1;
        checkSerialNumber(serial);
        serialNumber_ = serial;
        return *this;
    }

    Date Date::advance(const Date& date, Integer n, TimeUnit units) {
        switch (units) {
          case Days:
            return date + n;
          case Weeks:
            return date + 7*n;
          case Months: {
            Day d = date.dayOfMonth();
            Integer m = Integer(date.month())+n;
            Year y = date.year();
            while (m > 12) {
                m -= 12;
                y += 1;
            }
            while (m < 1) {
                m += 12;
                y -= 1;
            }

            QL_ENSURE(y >= 1900 && y <= 2199,
                      "year " << y << " out of bounds. "
                      << "It must be in [1901,2199]");

            Integer length = monthLength(Month(m), isLeap(y));
            if (d > length)
                d = length;

            return {d, Month(m), y};
          }
          case Years: {
              Day d = date.dayOfMonth();
              Month m = date.month();
              Year y = date.year()+n;

              QL_ENSURE(y >= 1900 && y <= 2199,
                        "year " << y << " out of bounds. "
                        << "It must be in [1901,2199]");

              if (d == 29 && m == February && !isLeap(y))
                  d = 28;

              return {d, m, y};
          }
          default:
            QL_FAIL("undefined time units");
        }
    }

    bool Date::isLeap(Year y) {
        static const bool YearIsLeap[] = {
            // 1900 is leap in agreement with Excel's bug
            // 1900 is out of valid date range anyway
            // 1900-1909
             true,false,false,false, true,false,false,false, true,false,
            // 1910-1919
            false,false, true,false,false,false, true,false,false,false,
            // 1920-1929
             true,false,false,false, true,false,false,false, true,false,
            // 1930-1939
            false,false, true,false,false,false, true,false,false,false,
            // 1940-1949
             true,false,false,false, true,false,false,false, true,false,
            // 1950-1959
            false,false, true,false,false,false, true,false,false,false,
            // 1960-1969
             true,false,false,false, true,false,false,false, true,false,
            // 1970-1979
            false,false, true,false,false,false, true,false,false,false,
            // 1980-1989
             true,false,false,false, true,false,false,false, true,false,
            // 1990-1999
            false,false, true,false,false,false, true,false,false,false,
            // 2000-2009
             true,false,false,false, true,false,false,false, true,false,
            // 2010-2019
            false,false, true,false,false,false, true,false,false,false,
            // 2020-2029
             true,false,false,false, true,false,false,false, true,false,
            // 2030-2039
            false,false, true,false,false,false, true,false,false,false,
            // 2040-2049
             true,false,false,false, true,false,false,false, true,false,
            // 2050-2059
            false,false, true,false,false,false, true,false,false,false,
            // 2060-2069
             true,false,false,false, true,false,false,false, true,false,
            // 2070-2079
            false,false, true,false,false,false, true,false,false,false,
            // 2080-2089
             true,false,false,false, true,false,false,false, true,false,
            // 2090-2099
            false,false, true,false,false,false, true,false,false,false,
            // 2100-2109
            false,false,false,false, true,false,false,false, true,false,
            // 2110-2119
            false,false, true,false,false,false, true,false,false,false,
            // 2120-2129
             true,false,false,false, true,false,false,false, true,false,
            // 2130-2139
            false,false, true,false,false,false, true,false,false,false,
            // 2140-2149
             true,false,false,false, true,false,false,false, true,false,
            // 2150-2159
            false,false, true,false,false,false, true,false,false,false,
            // 2160-2169
             true,false,false,false, true,false,false,false, true,false,
            // 2170-2179
            false,false, true,false,false,false, true,false,false,false,
            // 2180-2189
             true,false,false,false, true,false,false,false, true,false,
            // 2190-2199
            false,false, true,false,false,false, true,false,false,false,
            // 2200
            false
        };
        QL_REQUIRE(y>=1900 && y<=2200, "year outside valid range");
        return YearIsLeap[y-1900];
    }


    Integer Date::monthLength(Month m, bool leapYear) {
        static const Integer MonthLength[] = {
            31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
        };
        static const Integer MonthLeapLength[] = {
            31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
        };
        return (leapYear? MonthLeapLength[m-1] : MonthLength[m-1]);
    }

    Integer Date::monthOffset(Month m, bool leapYear) {
        static const Integer MonthOffset[] = {
              0,  31,  59,  90, 120, 151,   // Jan - Jun
            181, 212, 243, 273, 304, 334,   // Jun - Dec
            365     // used in dayOfMonth to bracket day
        };
        static const Integer MonthLeapOffset[] = {
              0,  31,  60,  91, 121, 152,   // Jan - Jun
            182, 213, 244, 274, 305, 335,   // Jun - Dec
            366     // used in dayOfMonth to bracket day
        };
        return (leapYear? MonthLeapOffset[m-1] : MonthOffset[m-1]);
    }

    Date::serial_type Date::yearOffset(Year y) {
        // the list of all December 31st in the preceding year
        // e.g. for 1901 yearOffset[1] is 366, that is, December 31 1900
        static const Date::serial_type YearOffset[] = {
            // 1900-1909
                0,  366,  731, 1096, 1461, 1827, 2192, 2557, 2922, 3288,
            // 1910-1919
             3653, 4018, 4383, 4749, 5114, 5479, 5844, 6210, 6575, 6940,
            // 1920-1929
             7305, 7671, 8036, 8401, 8766, 9132, 9497, 9862,10227,10593,
            // 1930-1939
            10958,11323,11688,12054,12419,12784,13149,13515,13880,14245,
            // 1940-1949
            14610,14976,15341,15706,16071,16437,16802,17167,17532,17898,
            // 1950-1959
            18263,18628,18993,19359,19724,20089,20454,20820,21185,21550,
            // 1960-1969
            21915,22281,22646,23011,23376,23742,24107,24472,24837,25203,
            // 1970-1979
            25568,25933,26298,26664,27029,27394,27759,28125,28490,28855,
            // 1980-1989
            29220,29586,29951,30316,30681,31047,31412,31777,32142,32508,
            // 1990-1999
            32873,33238,33603,33969,34334,34699,35064,35430,35795,36160,
            // 2000-2009
            36525,36891,37256,37621,37986,38352,38717,39082,39447,39813,
            // 2010-2019
            40178,40543,40908,41274,41639,42004,42369,42735,43100,43465,
            // 2020-2029
            43830,44196,44561,44926,45291,45657,46022,46387,46752,47118,
            // 2030-2039
            47483,47848,48213,48579,48944,49309,49674,50040,50405,50770,
            // 2040-2049
            51135,51501,51866,52231,52596,52962,53327,53692,54057,54423,
            // 2050-2059
            54788,55153,55518,55884,56249,56614,56979,57345,57710,58075,
            // 2060-2069
            58440,58806,59171,59536,59901,60267,60632,60997,61362,61728,
            // 2070-2079
            62093,62458,62823,63189,63554,63919,64284,64650,65015,65380,
            // 2080-2089
            65745,66111,66476,66841,67206,67572,67937,68302,68667,69033,
            // 2090-2099
            69398,69763,70128,70494,70859,71224,71589,71955,72320,72685,
            // 2100-2109
            73050,73415,73780,74145,74510,74876,75241,75606,75971,76337,
            // 2110-2119
            76702,77067,77432,77798,78163,78528,78893,79259,79624,79989,
            // 2120-2129
            80354,80720,81085,81450,81815,82181,82546,82911,83276,83642,
            // 2130-2139
            84007,84372,84737,85103,85468,85833,86198,86564,86929,87294,
            // 2140-2149
            87659,88025,88390,88755,89120,89486,89851,90216,90581,90947,
            // 2150-2159
            91312,91677,92042,92408,92773,93138,93503,93869,94234,94599,
            // 2160-2169
            94964,95330,95695,96060,96425,96791,97156,97521,97886,98252,
            // 2170-2179
            98617,98982,99347,99713,100078,100443,100808,101174,101539,101904,
            // 2180-2189
            102269,102635,103000,103365,103730,104096,104461,104826,105191,105557,
            // 2190-2199
            105922,106287,106652,107018,107383,107748,108113,108479,108844,109209,
            // 2200
            109574
        };
        return YearOffset[y-1900];
    }

#else

    namespace {
        const boost::gregorian::date& serialNumberDateReference() {
            static const boost::gregorian::date dateReference(
                1899, boost::gregorian::Dec, 30);
            return dateReference;
        }


#define compatibleEnums (   int(boost::date_time::Monday)   +1 == Monday    \
                         && int(boost::date_time::Tuesday)  +1 == Tuesday   \
                         && int(boost::date_time::Wednesday)+1 == Wednesday \
                         && int(boost::date_time::Thursday) +1 == Thursday  \
                         && int(boost::date_time::Friday)   +1 == Friday    \
                         && int(boost::date_time::Saturday) +1 == Saturday  \
                         && int(boost::date_time::Sunday)   +1 == Sunday    \
                         && int(boost::date_time::Jan) == January           \
                         && int(boost::date_time::Feb) == February          \
                         && int(boost::date_time::Mar) == March             \
                         && int(boost::date_time::Apr) == April             \
                         && int(boost::date_time::May) == May               \
                         && int(boost::date_time::Jun) == June              \
                         && int(boost::date_time::Jul) == July              \
                         && int(boost::date_time::Aug) == August            \
                         && int(boost::date_time::Sep) == September         \
                         && int(boost::date_time::Oct) == October           \
                         && int(boost::date_time::Nov) == November          \
                         && int(boost::date_time::Dec) == December           )

        template <bool compatible>
        Weekday mapBoostDateType2QL(boost::gregorian::greg_weekday d) {
            if (compatible) {
                return Weekday(d.as_number() + 1);
            }
            else {
                switch (d) {
                  case boost::date_time::Monday   : return Monday;
                  case boost::date_time::Tuesday  : return Tuesday;
                  case boost::date_time::Wednesday: return Wednesday;
                  case boost::date_time::Thursday : return Thursday;
                  case boost::date_time::Friday   : return Friday;
                  case boost::date_time::Saturday : return Saturday;
                  case boost::date_time::Sunday   : return Sunday;
                  default:
                    QL_FAIL("unknown boost date_time day of week given");
                }
            }
        }

        template <bool compatible>
        Month mapBoostDateType2QL(boost::gregorian::greg_month m) {
            if (compatible) {
                return Month(m.as_number());
            }
            else {
                switch (m) {
                  case boost::date_time::Jan : return January;
                  case boost::date_time::Feb : return February;
                  case boost::date_time::Mar : return March;
                  case boost::date_time::Apr : return April;
                  case boost::date_time::May : return May;
                  case boost::date_time::Jun : return June;
                  case boost::date_time::Jul : return July;
                  case boost::date_time::Aug : return August;
                  case boost::date_time::Sep : return September;
                  case boost::date_time::Oct : return October;
                  case boost::date_time::Nov : return November;
                  case boost::date_time::Dec : return December;
                  default:
                    QL_FAIL("unknown boost date_time month of week given");
                }
            }
        }


        template <bool compatible>
        boost::gregorian::greg_month mapQLDateType2Boost(Month m) {
            if (compatible) {
                return boost::gregorian::greg_month(m);
            }
            else {
                switch (m) {
                  case January  : return boost::date_time::Jan;
                  case February : return boost::date_time::Feb;
                  case March    : return boost::date_time::Mar;
                  case April    : return boost::date_time::Apr;
                  case May      : return boost::date_time::May;
                  case June     : return boost::date_time::Jun;
                  case July     : return boost::date_time::Jul;
                  case August   : return boost::date_time::Aug;
                  case September: return boost::date_time::Sep;
                  case October  : return boost::date_time::Oct;
                  case November : return boost::date_time::Nov;
                  case December : return boost::date_time::Dec;
                  default:
                    QL_FAIL("unknown boost date_time month of week given");
                }
            }
        }

        void advance(ptime& dt, Integer n, TimeUnit units) {
            using boost::gregorian::gregorian_calendar;

            switch (units) {
              case Days:
                dt += boost::gregorian::days(n);
                break;
              case Weeks:
                dt += boost::gregorian::weeks(n);
                break;
              case Months:
              case Years : {
                  const boost::gregorian::date date = dt.date();
                  const Day eoM = gregorian_calendar::end_of_month_day(
                      date.year(), date.month());

                  if (units == Months) {
                      dt += boost::gregorian::months(n);
                  }
                  else {
                      dt += boost::gregorian::years(n);
                  }

                  if (date.day() == eoM) {
                      // avoid snap-to-end-of-month
                      // behavior of boost::date_time
                      const Day newEoM
                            = gregorian_calendar::end_of_month_day(
                                  dt.date().year(), dt.date().month());

                      if (newEoM > eoM) {
                          dt -= boost::gregorian::days(newEoM - eoM);
                      }
                  }
                 }
                break;
              case Hours:
                dt += boost::posix_time::hours(n);
                break;
              case Minutes:
                  dt += boost::posix_time::minutes(n);
                  break;
              case Seconds:
                dt += boost::posix_time::seconds(n);
                break;
              case Milliseconds:
                dt += boost::posix_time::milliseconds(n);
                break;
              case Microseconds:
                dt += boost::posix_time::microseconds(n);
                break;
              default:
                QL_FAIL("undefined time units");
           }
        }

        boost::gregorian::date gregorianDate(Year y, Month m, Day d) {
            QL_REQUIRE(y > 1900 && y < 2200,
                       "year " << y << " out of bound. It must be in [1901,2199]");
            QL_REQUIRE(Integer(m) > 0 && Integer(m) < 13,
                       "month " << Integer(m)
                       << " outside January-December range [1,12]");

            const boost::gregorian::greg_month bM
                = mapQLDateType2Boost<compatibleEnums>(m);

            const Day len =
                boost::gregorian::gregorian_calendar::end_of_month_day(y, bM);
            QL_REQUIRE(d <= len && d > 0,
                       "day outside month (" << Integer(m) << ") day-range "
                       << "[1," << len << "]");

            return boost::gregorian::date(y, bM, d);
        }
    }


    Date::Date()
    : dateTime_(serialNumberDateReference()) {}

    Date::Date(const ptime& dateTime)
    : dateTime_(dateTime) {}

    Date::Date(Day d, Month m, Year y)
    : dateTime_(gregorianDate(y, m, d)) {}

    Date::Date(Day d, Month m, Year y,
               Hour hours, Minute minutes, Second seconds,
               Millisecond millisec, Microsecond microsec)
    : dateTime_(
         gregorianDate(y, m, d),
         boost::posix_time::time_duration(
             hours, minutes, seconds,
               millisec*(time_duration::ticks_per_second()/1000)
             + microsec*(time_duration::ticks_per_second()/1000000))) {}

    Date::Date(Date::serial_type serialNumber)
    : dateTime_(
         serialNumberDateReference() +
         boost::gregorian::days(serialNumber)) {
        checkSerialNumber(serialNumber);
    }

    Weekday Date::weekday() const {
        return mapBoostDateType2QL<compatibleEnums>(
            dateTime_.date().day_of_week());
    }

    Day Date::dayOfMonth() const {
        return dateTime_.date().day();
    }

    Day Date::dayOfYear() const {
        return dateTime_.date().day_of_year();
    }

    Month Date::month() const {
        return mapBoostDateType2QL<compatibleEnums>(dateTime_.date().month());
    }

    Year Date::year() const {
        return dateTime_.date().year();
    }

    Hour Date::hours() const {
        return dateTime_.time_of_day().hours();
    }

    Minute Date::minutes() const {
        return dateTime_.time_of_day().minutes();
    }

    Second Date::seconds() const {
        return dateTime_.time_of_day().seconds();
    }

    Time Date::fractionOfDay() const {
        const time_duration t = dateTime().time_of_day();

        const Time seconds
            = (t.hours()*60.0 + t.minutes())*60.0 + t.seconds()
                + Real(t.fractional_seconds())/ticksPerSecond();

        return seconds/86400.0; // ignore any DST hocus-pocus
    }

    Time Date::fractionOfSecond() const {
        return dateTime_.time_of_day().fractional_seconds()
            /Real(ticksPerSecond());
    }

    Millisecond Date::milliseconds() const {
        return dateTime_.time_of_day().fractional_seconds()
               /(ticksPerSecond()/1000);
    }

    Microsecond Date::microseconds() const {
        return (dateTime_.time_of_day().fractional_seconds()
                - milliseconds()*(time_duration::ticks_per_second()/1000))
            /(ticksPerSecond()/1000000);
    }

    time_duration::tick_type Date::ticksPerSecond() {
        return time_duration::ticks_per_second();
    }

    Date::serial_type Date::serialNumber() const {
        const Date::serial_type n =
            (dateTime_.date() - serialNumberDateReference()).days();
        if (n != 0)
            checkSerialNumber(n);
        return n;
    }

    const ptime& Date::dateTime() const { return dateTime_; }

    Date& Date::operator+=(Date::serial_type d) {
        dateTime_ += boost::gregorian::days(d);
        return *this;
    }

    Date& Date::operator+=(const Period& p) {
        advance(dateTime_, p.length(), p.units());
        return *this;
    }

    Date& Date::operator-=(Date::serial_type d) {
        dateTime_ -= boost::gregorian::days(d);
        return *this;
    }
    Date& Date::operator-=(const Period& p) {
        advance(dateTime_, -p.length(), p.units());
        return *this;
    }

    Date& Date::operator++() {
        dateTime_ +=boost::gregorian::days(1);
        return *this;
    }

    Date& Date::operator--() {
        dateTime_ -=boost::gregorian::days(1);
        return *this;
    }

    Date Date::operator+(Date::serial_type days) const {
        Date retVal(*this);
        retVal+=days;

        return retVal;
    }

    Date Date::operator-(Date::serial_type days) const {
        Date retVal(*this);
        retVal-=days;

        return retVal;
    }

    Date Date::operator+(const Period& p) const {
        Date retVal(*this);
        retVal+=p;

        return retVal;
    }

    Date Date::operator-(const Period& p) const {
        Date retVal(*this);
        retVal-=p;

        return retVal;
    }

    Date Date::localDateTime() {
        return Date(boost::posix_time::microsec_clock::local_time());
    }

    Date Date::universalDateTime() {
        return Date(boost::posix_time::microsec_clock::universal_time());
    }

    bool Date::isLeap(Year y) {
        return boost::gregorian::gregorian_calendar::is_leap_year(y);
    }

    Date Date::endOfMonth(const Date& d) {
        const Month m = d.month();
        const Year y = d.year();
        const Day eoM = boost::gregorian::gregorian_calendar::end_of_month_day(
            d.year(), mapQLDateType2Boost<compatibleEnums>(d.month()));

        return Date(eoM, m, y);
    }

    bool Date::isEndOfMonth(const Date& d) {
        return d.dayOfMonth() ==
            boost::gregorian::gregorian_calendar::end_of_month_day(
                d.year(), mapQLDateType2Boost<compatibleEnums>(d.month()));
    }


    Date::serial_type operator-(const Date& d1, const Date& d2) {
        return (d1.dateTime().date() - d2.dateTime().date()).days();
    }

    Time daysBetween(const Date& d1, const Date& d2) {
        const Date::serial_type days = d2 - d1;
        return days + d2.fractionOfDay() - d1.fractionOfDay();
    }

    bool operator<(const Date& d1, const Date& d2) {
        return (d1.dateTime() < d2.dateTime());
    }

    bool operator<=(const Date& d1, const Date& d2) {
        return (d1.dateTime() <= d2.dateTime());
    }

    bool operator>(const Date& d1, const Date& d2) {
        return (d1.dateTime() > d2.dateTime());
    }

    bool operator>=(const Date& d1, const Date& d2) {
        return (d1.dateTime() >= d2.dateTime());
    }

    bool operator==(const Date& d1, const Date& d2) {
        return (d1.dateTime() == d2.dateTime());
    }

    bool operator!=(const Date& d1, const Date& d2) {
        return (d1.dateTime() != d2.dateTime());
    }
#endif

    Date::serial_type Date::minimumSerialNumber() {
        return 367;       // Jan 1st, 1901
    }

    Date::serial_type Date::maximumSerialNumber() {
        return 109574;    // Dec 31st, 2199
    }

    void Date::checkSerialNumber(Date::serial_type serialNumber) {
        QL_REQUIRE(serialNumber >= minimumSerialNumber() &&
                   serialNumber <= maximumSerialNumber(),
                   "Date's serial number (" << serialNumber << ") outside "
                   "allowed range [" << minimumSerialNumber() <<
                   "-" << maximumSerialNumber() << "], i.e. [" <<
                   minDate() << "-" << maxDate() << "]");
    }

    Date Date::minDate() {
        static const Date minimumDate(minimumSerialNumber());
        return minimumDate;
    }

    Date Date::maxDate() {
        static const Date maximumDate(maximumSerialNumber());
        return maximumDate;
    }

    Date Date::operator++(int ) {
        Date old(*this);
        ++*this; // use the pre-increment
        return old;
    }

    Date Date::operator--(int ) {
        Date old(*this);
        --*this; // use the pre-decrement
        return old;
    }

    Date Date::todaysDate() {
        std::time_t t;

        if (std::time(&t) == std::time_t(-1)) // -1 means time() didn't work
            return {};
        std::tm *lt = std::localtime(&t);
        return {Day(lt->tm_mday), Month(lt->tm_mon + 1), Year(lt->tm_year + 1900)};
    }

    Date Date::nextWeekday(const Date& d, Weekday dayOfWeek) {
        Weekday wd = d.weekday();
        return d + ((wd>dayOfWeek ? 7 : 0) - wd + dayOfWeek);
    }

    Date Date::nthWeekday(Size nth, Weekday dayOfWeek,
                          Month m, Year y) {
        QL_REQUIRE(nth>0,
                   "zeroth day of week in a given (month, year) is undefined");
        QL_REQUIRE(nth<6,
                   "no more than 5 weekday in a given (month, year)");
        Weekday first = Date(1, m, y).weekday();
        Size skip = nth - (dayOfWeek>=first ? 1 : 0);
        return {Day((1 + dayOfWeek + skip * 7) - first), m, y};
    }

    // month formatting

    std::ostream& operator<<(std::ostream& out, Month m) {
        switch (m) {
          case January:
            return out << "January";
          case February:
            return out << "February";
          case March:
            return out << "March";
          case April:
            return out << "April";
          case May:
            return out << "May";
          case June:
            return out << "June";
          case July:
            return out << "July";
          case August:
            return out << "August";
          case September:
            return out << "September";
          case October:
            return out << "October";
          case November:
            return out << "November";
          case December:
            return out << "December";
          default:
            QL_FAIL("unknown month (" << Integer(m) << ")");
        }
    }

    std::size_t hash_value(const Date& d) {
#ifdef QL_HIGH_RESOLUTION_DATE
        std::size_t seed = 0;
        boost::hash_combine(seed, d.serialNumber());
        boost::hash_combine(seed, d.dateTime().time_of_day().total_nanoseconds());
        return seed;
#else
        return std::hash<Date::serial_type>()(d.serialNumber());
#endif
    }

    // date formatting

    std::ostream& operator<<(std::ostream& out, const Date& d) {
        return out << io::long_date(d);
    }

    namespace detail {

        struct FormatResetter { // NOLINT(cppcoreguidelines-special-member-functions)
            // An instance of this object will have undefined behaviour
            // if the object out passed in the constructor is destroyed
            // before this instance
            struct nopunct : std::numpunct<char> {
                std::string do_grouping() const override { return ""; }
            };
            explicit FormatResetter(std::ostream &out)
                : out_(&out), flags_(out.flags()), filler_(out.fill()),
                  loc_(out.getloc()) {
                std::locale loc (out.getloc(),new nopunct);
                out.imbue(loc);
                out << std::resetiosflags(
                    std::ios_base::adjustfield | std::ios_base::basefield |
                    std::ios_base::floatfield | std::ios_base::showbase |
                    std::ios_base::showpos | std::ios_base::uppercase);
                out << std::right;
            }
            ~FormatResetter() {
                out_->flags(flags_);
                out_->fill(filler_);
                out_->imbue(loc_);
            }
            std::ostream *out_;
            std::ios_base::fmtflags flags_;
            char filler_;
            std::locale loc_;
        };

        std::ostream& operator<<(std::ostream& out,
                                 const short_date_holder& holder) {
            const Date& d = holder.d;
            if (d == Date()) {
                out << "null date";
            } else {
                FormatResetter resetter(out);
                Integer dd = d.dayOfMonth(), mm = Integer(d.month()),
                        yyyy = d.year();
                char filler = out.fill();
                out << std::setw(2) << std::setfill('0') << mm << "/";
                out << std::setw(2) << std::setfill('0') << dd << "/";
                out << yyyy;
                out.fill(filler);
            }
            return out;
        }

        std::ostream& operator<<(std::ostream& out,
                                 const long_date_holder& holder) {
            const Date& d = holder.d;
            if (d == Date()) {
                out << "null date";
            } else {
                FormatResetter resetter(out);
                out << d.month() << " ";
                out << io::ordinal(d.dayOfMonth()) << ", ";
                out << d.year();
            }
            return out;
        }

        std::ostream& operator<<(std::ostream& out,
                                 const iso_date_holder& holder) {
            const Date& d = holder.d;
            if (d == Date()) {
                out << "null date";
            } else {
                FormatResetter resetter(out);
                Integer dd = d.dayOfMonth(), mm = Integer(d.month()),
                        yyyy = d.year();
                out << yyyy << "-";
                out << std::setw(2) << std::setfill('0') << mm << "-";
                out << std::setw(2) << std::setfill('0') << dd;
            }
            return out;
        }

        std::ostream& operator<<(std::ostream& out,
                                 const formatted_date_holder& holder) {
            using namespace boost::gregorian;
            const Date& d = holder.d;
            if (d == Date()) {
                out << "null date";
            } else {
                FormatResetter resetter(out);
                date boostDate(d.year(), d.month(), d.dayOfMonth());
                out.imbue(std::locale(std::locale(),
                                      new date_facet(holder.f.c_str())));
                out << boostDate;
            }
            return out;
        }

#ifdef QL_HIGH_RESOLUTION_DATE
        std::ostream& operator<<(std::ostream& out,
                                 const iso_datetime_holder& holder) {
            const Date& d = holder.d;

            out << io::iso_date(d) << "T";
            FormatResetter resetter(out);
            const Hour hh= d.hours();
            const Minute mm = d.minutes();
            const Second s = d.seconds();
            const Millisecond millis = d.milliseconds();
            const Microsecond micros = d.microseconds();

            out << std::setw(2) << std::setfill('0') << hh << ":"
                << std::setw(2) << std::setfill('0') << mm << ":"
                << std::setw(2) << std::setfill('0') << s << ","
                << std::setw(3) << std::setfill('0') << millis
                << std::setw(3) << std::setfill('0') << micros;

            return out;
        }
#endif
    }

    namespace io {
        detail::short_date_holder short_date(const Date& d) {
            return detail::short_date_holder(d);
        }

        detail::long_date_holder long_date(const Date& d) {
            return detail::long_date_holder(d);
        }

        detail::iso_date_holder iso_date(const Date& d) {
            return detail::iso_date_holder(d);
        }

        detail::formatted_date_holder formatted_date(const Date& d,
                                                     const std::string& f) {
            return detail::formatted_date_holder(d, f);
        }

#ifdef QL_HIGH_RESOLUTION_DATE
        detail::iso_datetime_holder iso_datetime(const Date& d) {
            return detail::iso_datetime_holder(d);
        }
#endif
    }
}
]]></document_content>
  </document>
  <document index="49">
    <source>dategenerationrule.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/dategenerationrule.hpp>
#include <ql/types.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    std::ostream& operator<<(std::ostream& out, DateGeneration::Rule r) {
        switch (r) {
          case DateGeneration::Backward:
            return out << "Backward";
          case DateGeneration::Forward:
            return out << "Forward";
          case DateGeneration::Zero:
            return out << "Zero";
          case DateGeneration::ThirdWednesday:
            return out << "ThirdWednesday";
          case DateGeneration::ThirdWednesdayInclusive:
            return out << "ThirdWednesdayInclusive";
          case DateGeneration::Twentieth:
            return out << "Twentieth";
          case DateGeneration::TwentiethIMM:
            return out << "TwentiethIMM";
          case DateGeneration::OldCDS:
            return out << "OldCDS";
          case DateGeneration::CDS:
            return out << "CDS";
          case DateGeneration::CDS2015:
            return out << "CDS2015";
          default:
            QL_FAIL("unknown DateGeneration::Rule (" << Integer(r) << ")");
        }
    }

}
]]></document_content>
  </document>
  <document index="50">
    <source>daycounters/actual365fixed.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2013 BGC Partners L.P.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/daycounters/actual365fixed.hpp>
#include <cmath>

namespace QuantLib {

    ext::shared_ptr<DayCounter::Impl>
    Actual365Fixed::implementation(Actual365Fixed::Convention c) {
        switch (c) {
          case Standard:
            return ext::shared_ptr<DayCounter::Impl>(new Impl);
          case Canadian:
            return ext::shared_ptr<DayCounter::Impl>(new CA_Impl);
          case NoLeap:
            return ext::shared_ptr<DayCounter::Impl>(new NL_Impl);
          default:
            QL_FAIL("unknown Actual/365 (Fixed) convention");
        }
    }

    Time Actual365Fixed::CA_Impl::yearFraction(const Date& d1,
                                               const Date& d2,
                                               const Date& refPeriodStart,
                                               const Date& refPeriodEnd) const {
        if (d1 == d2)
            return 0.0;

        // We need the period to calculate the frequency
        QL_REQUIRE(refPeriodStart != Date(), "invalid refPeriodStart");
        QL_REQUIRE(refPeriodEnd != Date(), "invalid refPeriodEnd");

        Time dcs = daysBetween(d1,d2);
        Time dcc = daysBetween(refPeriodStart,refPeriodEnd);
        auto months = Integer(std::lround(12 * dcc / 365));
        QL_REQUIRE(months != 0,
                   "invalid reference period for Act/365 Canadian; "
                   "must be longer than a month");
        auto frequency = Integer(12 / months);
        QL_REQUIRE(frequency != 0,
                   "invalid reference period for Act/365 Canadian; "
                   "must not be longer than a year");

        if (dcs < Integer(365/frequency))
            return dcs/365.0;

        return 1./frequency - (dcc-dcs)/365.0;

    }

    Date::serial_type Actual365Fixed::NL_Impl::dayCount(const Date& d1,
                                                        const Date& d2) const {

        static const Integer MonthOffset[] = {
            0,  31,  59,  90, 120, 151,  // Jan - Jun
            181, 212, 243, 273, 304, 334   // Jun - Dec
        };

        Date::serial_type s1 = d1.dayOfMonth()
                             + MonthOffset[d1.month()-1] + (d1.year() * 365);
        Date::serial_type s2 = d2.dayOfMonth()
                             + MonthOffset[d2.month()-1] + (d2.year() * 365);

        if (d1.month() == Feb && d1.dayOfMonth() == 29) {
            --s1;
        }

        if (d2.month() == Feb && d2.dayOfMonth() == 29) {
            --s2;
        }

        return s2 - s1;
    }

    Time Actual365Fixed::NL_Impl::yearFraction(const Date& d1,
                                               const Date& d2,
                                               const Date& d3,
                                               const Date& d4) const {
        return dayCount(d1, d2)/365.0;
    }

}

]]></document_content>
  </document>
  <document index="51">
    <source>daycounters/actualactual.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/daycounters/actualactual.hpp>
#include <algorithm>
#include <cmath>

namespace QuantLib {

    namespace {

        // the template argument works around passing a protected type

        template <class T>
        Integer findCouponsPerYear(const T& impl,
                                   Date refStart, Date refEnd) {
            // This will only work for day counts longer than 15 days.
            auto months = (Integer)std::lround(12 * Real(impl.dayCount(refStart, refEnd)) / 365.0);
            return (Integer)std::lround(12.0 / Real(months));
        }

        /* An ISMA day counter either needs a schedule or to have
           been explicitly passed a reference period. This usage
           leads to inaccurate year fractions.
        */
        template <class T>
        Time yearFractionGuess(const T& impl,
                               const Date& start, const Date& end) {
            // asymptotically correct.
            return Real(impl.dayCount(start, end)) / 365.0;
        }

        std::vector<Date> getListOfPeriodDatesIncludingQuasiPayments(
                                                   const Schedule& schedule) {
            // Process the schedule into an array of dates.
            Date issueDate = schedule.date(0);
            std::vector<Date> newDates = schedule.dates();

            if (!schedule.hasIsRegular() || !schedule.isRegular(1))
            {
                Date firstCoupon = schedule.date(1);

                Date notionalFirstCoupon =
                    schedule.calendar().advance(firstCoupon,
                        -schedule.tenor(),
                        schedule.businessDayConvention(),
                        schedule.endOfMonth());

                newDates[0] = notionalFirstCoupon;

                //long first coupon
                if (notionalFirstCoupon > issueDate) {
                    Date priorNotionalCoupon =
                        schedule.calendar().advance(notionalFirstCoupon,
                                                    -schedule.tenor(),
                                                    schedule.businessDayConvention(),
                                                    schedule.endOfMonth());
                    newDates.insert(newDates.begin(),
                                    priorNotionalCoupon); //insert as the first element?
                }
            }

            if (!schedule.hasIsRegular() || !schedule.isRegular(schedule.size() - 1))
            {
                Date notionalLastCoupon =
                    schedule.calendar().advance(schedule.date(schedule.size() - 2),
                        schedule.tenor(),
                        schedule.businessDayConvention(),
                        schedule.endOfMonth());

                newDates[schedule.size() - 1] = notionalLastCoupon;

                if (notionalLastCoupon < schedule.endDate())
                {
                    Date nextNotionalCoupon =
                        schedule.calendar().advance(notionalLastCoupon,
                                                    schedule.tenor(),
                                                    schedule.businessDayConvention(),
                                                    schedule.endOfMonth());
                    newDates.push_back(nextNotionalCoupon);
                }
            }

            return newDates;
        }

        template <class T>
        Time yearFractionWithReferenceDates(const T& impl,
                                            const Date& d1, const Date& d2,
                                            const Date& d3, const Date& d4) {
            QL_REQUIRE(d1 <= d2,
                       "This function is only correct if d1 <= d2\n"
                       "d1: " << d1 << " d2: " << d2);

            Real referenceDayCount = Real(impl.dayCount(d3, d4));
            //guess how many coupon periods per year:
            Integer couponsPerYear;
            if (referenceDayCount < 16) {
                couponsPerYear = 1;
                referenceDayCount = impl.dayCount(d1, d1 + 1 * Years);
            }
            else {
                couponsPerYear = findCouponsPerYear(impl, d3, d4);
            }
            return Real(impl.dayCount(d1, d2)) / (referenceDayCount*couponsPerYear);
        }

    }

    ext::shared_ptr<DayCounter::Impl>
    ActualActual::implementation(ActualActual::Convention c, Schedule schedule) {
        switch (c) {
          case ISMA:
          case Bond:
            if (!schedule.empty())
                return ext::shared_ptr<DayCounter::Impl>(new ISMA_Impl(std::move(schedule)));
            else
                return ext::shared_ptr<DayCounter::Impl>(new Old_ISMA_Impl);
          case ISDA:
          case Historical:
          case Actual365:
            return ext::shared_ptr<DayCounter::Impl>(new ISDA_Impl);
          case AFB:
          case Euro:
            return ext::shared_ptr<DayCounter::Impl>(new AFB_Impl);
          default:
            QL_FAIL("unknown act/act convention");
        }
    }


    Time ActualActual::ISMA_Impl::yearFraction(const Date& d1,
                                               const Date& d2,
                                               const Date& d3,
                                               const Date& d4) const {
        if (d1 == d2) {
            return 0.0;
        } else if (d2 < d1) {
            return -yearFraction(d2, d1, d3, d4);
        }

        std::vector<Date> couponDates =
            getListOfPeriodDatesIncludingQuasiPayments(schedule_);

        Date firstDate = *std::min_element(couponDates.begin(), couponDates.end());
        Date lastDate = *std::max_element(couponDates.begin(), couponDates.end());

        QL_REQUIRE(d1 >= firstDate && d2 <= lastDate, "Dates out of range of schedule: "
                       << "date 1: " << d1 << ", date 2: " << d2 << ", first date: "
                       << firstDate << ", last date: " << lastDate);

        Real yearFractionSum = 0.0;
        for (Size i = 0; i < couponDates.size() - 1; i++) {
            Date startReferencePeriod = couponDates[i];
            Date endReferencePeriod = couponDates[i + 1];
            if (d1 < endReferencePeriod && d2 > startReferencePeriod) {
                yearFractionSum +=
                    yearFractionWithReferenceDates(*this,
                                                   std::max(d1, startReferencePeriod),
                                                   std::min(d2, endReferencePeriod),
                                                   startReferencePeriod,
                                                   endReferencePeriod);
            }
        }
        return yearFractionSum;
    }


    Time ActualActual::Old_ISMA_Impl::yearFraction(const Date& d1,
                                                   const Date& d2,
                                                   const Date& d3,
                                                   const Date& d4) const {
        if (d1 == d2)
            return 0.0;

        if (d1 > d2)
            return -yearFraction(d2,d1,d3,d4);

        // when the reference period is not specified, try taking
        // it equal to (d1,d2)
        Date refPeriodStart = (d3 != Date() ? d3 : d1);
        Date refPeriodEnd = (d4 != Date() ? d4 : d2);

        QL_REQUIRE(refPeriodEnd > refPeriodStart && refPeriodEnd > d1,
                   "invalid reference period: "
                   << "date 1: " << d1
                   << ", date 2: " << d2
                   << ", reference period start: " << refPeriodStart
                   << ", reference period end: " << refPeriodEnd);

        // estimate roughly the length in months of a period
        auto months = (Integer)std::lround(12 * Real(refPeriodEnd - refPeriodStart) / 365);

        // for short periods...
        if (months == 0) {
            // ...take the reference period as 1 year from d1
            refPeriodStart = d1;
            refPeriodEnd = d1 + 1*Years;
            months = 12;
        }

        Time period = Real(months)/12.0;

        if (d2 <= refPeriodEnd) {
            // here refPeriodEnd is a future (notional?) payment date
            if (d1 >= refPeriodStart) {
                // here refPeriodStart is the last (maybe notional)
                // payment date.
                // refPeriodStart <= d1 <= d2 <= refPeriodEnd
                // [maybe the equality should be enforced, since
                // refPeriodStart < d1 <= d2 < refPeriodEnd
                // could give wrong results] ???
                return period*Real(daysBetween(d1,d2)) /
                    daysBetween(refPeriodStart,refPeriodEnd);
            } else {
                // here refPeriodStart is the next (maybe notional)
                // payment date and refPeriodEnd is the second next
                // (maybe notional) payment date.
                // d1 < refPeriodStart < refPeriodEnd
                // AND d2 <= refPeriodEnd
                // this case is long first coupon

                // the last notional payment date
                Date previousRef = refPeriodStart - months*Months;

                if (d2 > refPeriodStart)
                    return yearFraction(d1, refPeriodStart, previousRef,
                                        refPeriodStart) +
                        yearFraction(refPeriodStart, d2, refPeriodStart,
                                     refPeriodEnd);
                else
                    return yearFraction(d1,d2,previousRef,refPeriodStart);
            }
        } else {
            // here refPeriodEnd is the last (notional?) payment date
            // d1 < refPeriodEnd < d2 AND refPeriodStart < refPeriodEnd
            QL_REQUIRE(refPeriodStart<=d1,
                       "invalid dates: "
                       "d1 < refPeriodStart < refPeriodEnd < d2");
            // now it is: refPeriodStart <= d1 < refPeriodEnd < d2

            // the part from d1 to refPeriodEnd
            Time sum = yearFraction(d1, refPeriodEnd,
                                    refPeriodStart, refPeriodEnd);

            // the part from refPeriodEnd to d2
            // count how many regular periods are in [refPeriodEnd, d2],
            // then add the remaining time
            Integer i=0;
            Date newRefStart, newRefEnd;
            for (;;) {
                newRefStart = refPeriodEnd + (months*i)*Months;
                newRefEnd = refPeriodEnd + (months*(i+1))*Months;
                if (d2 < newRefEnd) {
                    break;
                } else {
                    sum += period;
                    i++;
                }
            }
            sum += yearFraction(newRefStart,d2,newRefStart,newRefEnd);
            return sum;
        }
    }


    Time ActualActual::ISDA_Impl::yearFraction(const Date& d1,
                                               const Date& d2,
                                               const Date&,
                                               const Date&) const {
        if (d1 == d2)
            return 0.0;

        if (d1 > d2)
            return -yearFraction(d2,d1,Date(),Date());

        Integer y1 = d1.year(), y2 = d2.year();
        Real dib1 = (Date::isLeap(y1) ? 366.0 : 365.0),
             dib2 = (Date::isLeap(y2) ? 366.0 : 365.0);

        Time sum = y2 - y1 - 1;
        sum += daysBetween(d1, Date(1,January,y1+1))/dib1;
        sum += daysBetween(Date(1,January,y2),d2)/dib2;
        return sum;
    }


    Time ActualActual::AFB_Impl::yearFraction(const Date& d1,
                                              const Date& d2,
                                              const Date&,
                                              const Date&) const {
        if (d1 == d2)
            return 0.0;

        if (d1 > d2)
            return -yearFraction(d2,d1,Date(),Date());

        Date newD2=d2, temp=d2;
        Time sum = 0.0;
        while (temp > d1) {
            temp = newD2 - 1*Years;
            if (temp.dayOfMonth()==28 && temp.month()==2
                && Date::isLeap(temp.year())) {
                temp += 1;
            }
            if (temp>=d1) {
                sum += 1.0;
                newD2 = temp;
            }
        }

        Real den = 365.0;

        if (Date::isLeap(newD2.year())) {
            temp = Date(29, February, newD2.year());
            if (newD2>temp && d1<=temp)
                den += 1.0;
        } else if (Date::isLeap(d1.year())) {
            temp = Date(29, February, d1.year());
            if (newD2>temp && d1<=temp)
                den += 1.0;
        }

        return sum+daysBetween(d1, newD2)/den;
    }

}
]]></document_content>
  </document>
  <document index="52">
    <source>daycounters/business252.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Piter Dias
 Copyright (C) 2011 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/daycounters/business252.hpp>
#include <map>

namespace QuantLib {

    namespace {

        typedef std::map<Year, std::map<Month, Date::serial_type> > Cache;
        typedef std::map<Year, Date::serial_type> OuterCache;
        
        std::map<std::string, Cache> monthlyFigures_;
        std::map<std::string, OuterCache> yearlyFigures_;

        bool sameYear(const Date& d1, const Date& d2) {
            return d1.year() == d2.year();
        }

        bool sameMonth(const Date& d1, const Date& d2) {
            return d1.year() == d2.year() && d1.month() == d2.month();
        }

        Date::serial_type businessDays(Cache& cache,
                                       const Calendar& calendar,
                                       Month month, Year year) {
            if (cache[year][month] == 0) {
                // calculate and store.
                Date d1 = Date(1,month,year);
                Date d2 = d1 + 1*Months;
                cache[year][month] = calendar.businessDaysBetween(d1, d2);
            }
            return cache[year][month];
        }

        Date::serial_type businessDays(OuterCache& outerCache,
                                       Cache& cache,
                                       const Calendar& calendar,
                                       Year year) {
            if (outerCache[year] == 0) {
                // calculate and store.
                Date::serial_type total = 0;
                for (Integer i=1; i<=12; ++i) {
                    total += businessDays(cache,calendar,
                                          Month(i), year);
                }
                outerCache[year] = total;
            }
            return outerCache[year];
        }

    }

    std::string Business252::Impl::name() const {
        std::ostringstream out;
        out << "Business/252(" << calendar_.name() << ")";
        return out.str();
    }

    Date::serial_type Business252::Impl::dayCount(const Date& d1,
                                                  const Date& d2) const {
        if (sameMonth(d1,d2) || d1 >= d2) {
            // we treat the case of d1 > d2 here, since we'd need a
            // second cache to get it right (our cached figures are
            // for first included, last excluded and might have to be
            // changed going the other way.)
            return calendar_.businessDaysBetween(d1, d2);
        } else if (sameYear(d1,d2)) {
            Cache& cache = monthlyFigures_[calendar_.name()];
            Date::serial_type total = 0;
            Date d;
            // first, we get to the beginning of next month.
            d = Date(1,d1.month(),d1.year()) + 1*Months;
            total += calendar_.businessDaysBetween(d1, d);
            // then, we add any whole months (whose figures might be
            // cached already) in the middle of our period.
            while (!sameMonth(d,d2)) {
                total += businessDays(cache, calendar_,
                                      d.month(), d.year());
                d += 1*Months;
            }
            // finally, we get to the end of the period.
            total += calendar_.businessDaysBetween(d, d2);
            return total;
        } else {
            Cache& cache = monthlyFigures_[calendar_.name()];
            OuterCache& outerCache = yearlyFigures_[calendar_.name()];
            Date::serial_type total = 0;
            Date d;
            // first, we get to the beginning of next year.
            // The first bit gets us to the end of this month...
            d = Date(1,d1.month(),d1.year()) + 1*Months;
            total += calendar_.businessDaysBetween(d1, d);
            // ...then we add any remaining months, possibly cached
            for (Integer m = Integer(d1.month())+1; m <= 12; ++m) {
                total += businessDays(cache, calendar_,
                                      Month(m), d.year());
            }
            // then, we add any whole year in the middle of our period.
            d = Date(1,January,d1.year()+1);
            while (!sameYear(d,d2)) {
                total += businessDays(outerCache, cache,
                                      calendar_, d.year());
                d += 1*Years;
            }
            // finally, we get to the end of the period.
            // First, we add whole months...
            for (Integer m = 1; m<Integer(d2.month()); ++m) {
                total += businessDays(cache, calendar_,
                                      Month(m), d2.year());
            }
            // ...then the last bit.
            d = Date(1,d2.month(),d2.year());
            total += calendar_.businessDaysBetween(d, d2);
            return total;
        }
    }

    Time Business252::Impl::yearFraction(const Date& d1,
                                         const Date& d2,
                                         const Date&,
                                         const Date&) const {
        return dayCount(d1, d2)/252.0;
    }

}
]]></document_content>
  </document>
  <document index="53">
    <source>daycounters/simpledaycounter.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/daycounters/simpledaycounter.hpp>
#include <ql/time/daycounters/thirty360.hpp>

namespace QuantLib {

    namespace { DayCounter fallback = Thirty360(Thirty360::BondBasis); }

    Date::serial_type SimpleDayCounter::Impl::dayCount(const Date& d1,
                                                       const Date& d2) const {
        return fallback.dayCount(d1,d2);
    }

    Time SimpleDayCounter::Impl::yearFraction(const Date& d1,
                                              const Date& d2,
                                              const Date&,
                                              const Date&) const {
        Day dm1 = d1.dayOfMonth(),
            dm2 = d2.dayOfMonth();

        if (dm1 == dm2 ||
            // e.g., Aug 30 -> Feb 28 ?
            (dm1 > dm2 && Date::isEndOfMonth(d2)) ||
            // e.g., Feb 28 -> Aug 30 ?
            (dm1 < dm2 && Date::isEndOfMonth(d1))) {

            return (d2.year()-d1.year()) +
                (Integer(d2.month())-Integer(d1.month()))/12.0;

        } else {
            return fallback.yearFraction(d1,d2);
        }
    }

}

]]></document_content>
  </document>
  <document index="54">
    <source>daycounters/thirty360.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2018 Alexey Indiryakov

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/daycounters/thirty360.hpp>
#include <algorithm>

namespace QuantLib {

    namespace {

        bool isLastOfFebruary(Day d, Month m, Year y) {
            return m == 2 && d == 28 + (Date::isLeap(y) ? 1 : 0);
        }

    }

    ext::shared_ptr<DayCounter::Impl>
    Thirty360::implementation(Thirty360::Convention c, const Date& terminationDate) {
        switch (c) {
          case USA:
            return ext::shared_ptr<DayCounter::Impl>(new US_Impl);
          case European:
          case EurobondBasis:
            return ext::shared_ptr<DayCounter::Impl>(new EU_Impl);
          case Italian:
            return ext::shared_ptr<DayCounter::Impl>(new IT_Impl);
          case ISMA:
          case BondBasis:
            return ext::shared_ptr<DayCounter::Impl>(new ISMA_Impl);
          case ISDA:
          case German:
            return ext::shared_ptr<DayCounter::Impl>(new ISDA_Impl(terminationDate));
          case NASD:
            return ext::shared_ptr<DayCounter::Impl>(new NASD_Impl);
          default:
            QL_FAIL("unknown 30/360 convention");
        }
    }

    Date::serial_type Thirty360::US_Impl::dayCount(const Date& d1,
                                                   const Date& d2) const {
        Day dd1 = d1.dayOfMonth(), dd2 = d2.dayOfMonth();
        Month mm1 = d1.month(), mm2 = d2.month();
        Year yy1 = d1.year(), yy2 = d2.year();

        // See https://en.wikipedia.org/wiki/Day_count_convention#30/360_US
        // NOTE: the order of checks is important
        if (isLastOfFebruary(dd1, mm1, yy1)) {
            if (isLastOfFebruary(dd2, mm2, yy2)) { dd2 = 30; }
            dd1 = 30;
        }
        if (dd2 == 31 && dd1 >= 30) { dd2 = 30; }
        if (dd1 == 31) { dd1 = 30; }

        return 360*(yy2-yy1) + 30*(mm2-mm1) + (dd2-dd1);
    }

    Date::serial_type Thirty360::ISMA_Impl::dayCount(const Date& d1,
                                                     const Date& d2) const {
        Day dd1 = d1.dayOfMonth(), dd2 = d2.dayOfMonth();
        Month mm1 = d1.month(), mm2 = d2.month();
        Year yy1 = d1.year(), yy2 = d2.year();

        if (dd1 == 31) { dd1 = 30; }
        if (dd2 == 31 && dd1 == 30) { dd2 = 30; }

        return 360*(yy2-yy1) + 30*(mm2-mm1) + (dd2-dd1);
    }

    Date::serial_type Thirty360::EU_Impl::dayCount(const Date& d1,
                                                   const Date& d2) const {
        Day dd1 = d1.dayOfMonth(), dd2 = d2.dayOfMonth();
        Month mm1 = d1.month(), mm2 = d2.month();
        Year yy1 = d1.year(), yy2 = d2.year();

        if (dd1 == 31) { dd1 = 30; }
        if (dd2 == 31) { dd2 = 30; }

        return 360*(yy2-yy1) + 30*(mm2-mm1) + (dd2-dd1);
    }

    Date::serial_type Thirty360::IT_Impl::dayCount(const Date& d1,
                                                   const Date& d2) const {
        Day dd1 = d1.dayOfMonth(), dd2 = d2.dayOfMonth();
        Month mm1 = d1.month(), mm2 = d2.month();
        Year yy1 = d1.year(), yy2 = d2.year();

        if (dd1 == 31) { dd1 = 30; }
        if (dd2 == 31) { dd2 = 30; }

        if (mm1 == 2 && dd1 > 27) { dd1 = 30; }
        if (mm2 == 2 && dd2 > 27) { dd2 = 30; }

        return 360*(yy2-yy1) + 30*(mm2-mm1) + (dd2-dd1);
    }

    Date::serial_type Thirty360::ISDA_Impl::dayCount(const Date& d1,
                                                     const Date& d2) const {
        Day dd1 = d1.dayOfMonth(), dd2 = d2.dayOfMonth();
        Month mm1 = d1.month(), mm2 = d2.month();
        Year yy1 = d1.year(), yy2 = d2.year();

        if (dd1 == 31) { dd1 = 30; }
        if (dd2 == 31) { dd2 = 30; }

        if (isLastOfFebruary(dd1, mm1, yy1)) { dd1 = 30; }

        if (d2 != terminationDate_ && isLastOfFebruary(dd2, mm2, yy2)) { dd2 = 30; }

        return 360*(yy2-yy1) + 30*(mm2-mm1) + (dd2-dd1);
    }

    Date::serial_type Thirty360::NASD_Impl::dayCount(const Date& d1,
                                                     const Date& d2) const {
        Day dd1 = d1.dayOfMonth(), dd2 = d2.dayOfMonth();
        Integer mm1 = d1.month(), mm2 = d2.month();
        Year yy1 = d1.year(), yy2 = d2.year();

        if (dd1 == 31) { dd1 = 30; }
        if (dd2 == 31 && dd1 >= 30) { dd2 = 30; }
        if (dd2 == 31 && dd1 < 30) { dd2 = 1; mm2++; }

        return 360*(yy2-yy1) + 30*(mm2-mm1) + (dd2-dd1);
    }

}
]]></document_content>
  </document>
  <document index="55">
    <source>daycounters/thirty365.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/daycounters/thirty365.hpp>

namespace QuantLib {

    Date::serial_type Thirty365::Impl::dayCount(const Date& d1,
                                                const Date& d2) const {
        Day dd1 = d1.dayOfMonth(), dd2 = d2.dayOfMonth();
        Integer mm1 = d1.month(), mm2 = d2.month();
        Year yy1 = d1.year(), yy2 = d2.year();

        // date adjustment rules as in ISO 20022
        // see https://www.iso20022.org/15022/uhb/mt565-16-field-22f.htm
        if (dd1 == 31) { dd1 = 30; }
        if (dd2 == 31) { dd2 = 30; }

        return 360*(yy2-yy1) + 30*(mm2-mm1) + (dd2-dd1);
    }

    Thirty365::Thirty365()
    : DayCounter(ext::shared_ptr<DayCounter::Impl>(new Thirty365::Impl)) {}

}
]]></document_content>
  </document>
  <document index="56">
    <source>daycounters/yearfractiontodate.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2023 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/comparison.hpp>
#include <ql/time/daycounters/yearfractiontodate.hpp>

#include <boost/numeric/conversion/cast.hpp>
#include <cmath>

namespace QuantLib {

    Date yearFractionToDate(
        const DayCounter& dayCounter, const Date& referenceDate, Time t) {
        Date guessDate = referenceDate
            + Period(boost::numeric_cast<Integer>(round(t * 365.25)), Days);
        Time guessTime = dayCounter.yearFraction(referenceDate, guessDate);

        guessDate += Period(boost::numeric_cast<Integer>(
            round((t - guessTime)*365.25)), Days);
        guessTime = dayCounter.yearFraction(referenceDate, guessDate);

        if (close_enough(guessTime, t))
            return guessDate;

        const auto searchDirection = boost::numeric_cast<Integer>(copysign(1.0, t - guessTime));

        t += searchDirection*100*QL_EPSILON;

        Date nextDate;
        for (TimeUnit u: {Years, Months, Days}) {
            while (searchDirection*(
                dayCounter.yearFraction(
                    referenceDate,
                    nextDate = guessDate + Period(searchDirection, u)) - t) < 0.0)
                guessDate = nextDate;
        }

        guessTime = dayCounter.yearFraction(referenceDate, guessDate);
        if (close_enough(guessTime, t)
                || std::abs(dayCounter.yearFraction(referenceDate,
                    guessDate + Period(searchDirection, Days)) - t) >
                    std::abs(guessTime - t))
            return guessDate;
        else
            return guessDate + Period(searchDirection, Days);
    }
}

]]></document_content>
  </document>
  <document index="57">
    <source>ecb.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009, 2011 Ferdinando Ametrano
 Copyright (C) 2015 Paolo Mazzocchi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/ecb.hpp>
#include <ql/settings.hpp>
#include <ql/utilities/dataparsers.hpp>
#include <boost/utility/string_view.hpp>
#include <boost/bimap/bimap.hpp>
#include <boost/bimap/set_of.hpp>
#include <algorithm>
#include <string>
#include <cstdio>
#include <cctype>

using std::string;

namespace QuantLib {

    namespace {
        // case-insensitive comparison. answers: lhs < rhs.
        struct is_iless {
          bool operator()(const boost::string_view lhs,
                          const boost::string_view rhs) const {
            char lhsUpper[3];
            char rhsUpper[3];
            for (int i = 0; i < 3; ++i) {
              lhsUpper[i] = std::toupper(lhs[i]);
              rhsUpper[i] = std::toupper(rhs[i]);
            }
            return boost::string_view(lhsUpper, 3) <
                   boost::string_view(rhsUpper, 3);
          }
        };

        using MonthBimap_t = boost::bimaps::bimap<
            boost::bimaps::set_of<boost::string_view, is_iless>, Month>;

        // bimap: generalization of map. can be queried by string_view or Month.
        const MonthBimap_t MONTHS = []() {
          MonthBimap_t months;
          months.insert({"JAN", January});
          months.insert({"FEB", February});
          months.insert({"MAR", March});
          months.insert({"APR", April});
          months.insert({"MAY", May});
          months.insert({"JUN", June});
          months.insert({"JUL", July});
          months.insert({"AUG", August});
          months.insert({"SEP", September});
          months.insert({"OCT", October});
          months.insert({"NOV", November});
          months.insert({"DEC", December});
          return months;
        }();

        //clang-format off
        // Start of maintenance period
        // source: https://web.archive.org/web/20230610050642/https://www.ecb.europa.eu/press/calendars/reserve/html/index.en.html
        std::set<Date> ecbKnownDateSet = {
            // 2005
            Date(38371), Date(38391), Date(38420), Date(38455), Date(38483), Date(38511),
            Date(38546), Date(38574), Date(38602), Date(38637), Date(38665), Date(38692),

            // 2006
            Date(38735), Date(38756), Date(38784), Date(38819), Date(38847), Date(38883),
            Date(38910), Date(38938), Date(38966), Date(39001), Date(39029), Date(39064),

            // 2007
            Date(39099), Date(39127), Date(39155), Date(39190), Date(39217), Date(39246),
            Date(39274), Date(39302), Date(39337), Date(39365), Date(39400), Date(39428),

            // 2008
            Date(39463), Date(39491), Date(39519), Date(39554), Date(39582), Date(39610),
            Date(39638), Date(39673), Date(39701), Date(39729), Date(39764), Date(39792),

            // 2009
            Date(39834), Date(39855), Date(39883), Date(39911), Date(39946), Date(39974),
            Date(40002), Date(40037), Date(40065), Date(40100), Date(40128), Date(40155),

            // 2010
            Date(40198), Date(40219), Date(40247), Date(40282), Date(40310), Date(40345),
            Date(40373), Date(40401), Date(40429), Date(40464), Date(40492), Date(40520),

            // 2011
            Date(40562), Date(40583), Date(40611), Date(40646), Date(40674), Date(40709),
            Date(40737), Date(40765), Date(40800), Date(40828), Date(40856), Date(40891),

            // 2012
            Date(40926), Date(40954), Date(40982), Date(41010), Date(41038), Date(41073),
            Date(41101), Date(41129), Date(41164), Date(41192), Date(41227), Date(41255),

            // 2013
            Date(41290), Date(41318), Date(41346), Date(41374), Date(41402), Date(41437),
            Date(41465), Date(41493), Date(41528), Date(41556), Date(41591), Date(41619),

            // 2014
            Date(41654), Date(41682), Date(41710), Date(41738), Date(41773), Date(41801),
            Date(41829), Date(41864), Date(41892), Date(41920), Date(41955), Date(41983),

            // 2015
            Date(42032), Date(42074), Date(42116), Date(42165), Date(42207), Date(42256),
            Date(42305), Date(42347),

            // 2016
            Date(42396), Date(42445), Date(42487), Date(42529), Date(42578), Date(42627),
            Date(42669), Date(42718),

            // 2017
            Date(42760), Date(42809), Date(42858), Date(42900), Date(42942), Date(42991),
            Date(43040), Date(43089),

            // 2018
            Date(43131), Date(43167), Date(43216), Date(43265), Date(43307), Date(43356),
            Date(43398), Date(43447),

            // 2019
            Date(43495), Date(43537), Date(43572), Date(43628), Date(43677), Date(43726),
            Date(43768), Date(43817),

            // 2020
            Date(43859), Date(43908), Date(43957), Date(43992), Date(44034), Date(44090),
            Date(44139), Date(44181),

            // 2021
            Date(44223), Date(44272), Date(44314), Date(44363), Date(44405), Date(44454),
            Date(44503), Date(44552),

            // 2022
            Date(44601), Date(44636), Date(44671), Date(44727), Date(44769), Date(44818),
            Date(44867), Date(44916),

            // 2023
            Date(44965), Date(45007), Date(45056), Date(45098), Date(45140), Date(45189),
            Date(45231), Date(45280),

            // 2024
            Date(45322), Date(45364), Date(45399), Date(45455), Date(45497), Date(45553),
            Date(45588), Date(45644)
        };
        //clang-format on
    }

    const std::set<Date>& ECB::knownDates() {
        return ecbKnownDateSet;
    }

    void ECB::addDate(const Date& d) {
        ecbKnownDateSet.insert(d);
    }

    void ECB::removeDate(const Date& d) {
        ecbKnownDateSet.erase(d);
    }

    namespace {
        int ToInteger(const char c) {
            const int i = static_cast<int>(c) - static_cast<int>('0');
            QL_ASSERT((i >= 0) && (i <= 9), "Character does not represent a digit. char: " << c);
            return i;
        }
    }

    Date ECB::date(const string& ecbCode,
                   const Date& refDate) {

        QL_REQUIRE(isECBcode(ecbCode),
                   ecbCode << " is not a valid ECB code");

        // convert first 3 characters to `Month m`
        const boost::string_view monthCode(ecbCode.data(), 3);
        const Month m = MONTHS.left.at(monthCode);

        // convert 4th, 5th characters to `Year y`
        Year y = ToInteger(ecbCode[3])*10 + ToInteger(ecbCode[4]);
        Date referenceDate = (refDate != Date() ?
                              refDate :
                              Date(Settings::instance().evaluationDate()));
        Year referenceYear = (referenceDate.year() % 100);
        y += referenceDate.year() - referenceYear;
        if (y<Date::minDate().year())
            return ECB::nextDate(Date::minDate());

        return ECB::nextDate(Date(1, m, y) - 1);
    }

    string ECB::code(const Date& ecbDate) {

        QL_REQUIRE(isECBdate(ecbDate),
                   ecbDate << " is not a valid ECB date");

        // 3 characters for the month
        const boost::string_view month = MONTHS.right.at(ecbDate.month());

        // last two digits of the year
        const unsigned int y = ecbDate.year() % 100;

        // c-style string. length: 6 == (3 for month + 2 for year + 1 for terminating null)
        char ECBcode[6];
        std::snprintf(ECBcode, 6, "%3s%02u", month.data(), y);

        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_ENSURE(isECBcode(ECBcode),
                  "the result " << ECBcode <<
                  " is an invalid ECB code");
        #endif
        return ECBcode;
    }

    Date ECB::nextDate(const Date& date) {
        Date d = (date == Date() ?
                  Settings::instance().evaluationDate() :
                  date);

        auto i = std::upper_bound(knownDates().begin(), knownDates().end(), d);

        QL_REQUIRE(i != knownDates().end(),
                   "ECB dates after " << *knownDates().rbegin() << " are unknown");
        return *i;
    }

    std::vector<Date> ECB::nextDates(const Date& date) {
        Date d = (date == Date() ?
                  Settings::instance().evaluationDate() :
                  date);

        auto i = std::upper_bound(knownDates().begin(), knownDates().end(), d);

        QL_REQUIRE(i != knownDates().end(),
                   "ECB dates after " << *knownDates().rbegin() << " are unknown");
        return std::vector<Date>(i, knownDates().end());
    }


    bool ECB::isECBcode(const std::string& ecbCode) {

        if (ecbCode.length() != 5)
            return false;

        // first 3 characters need to represent month, case insensitive
        {
            const boost::string_view month(ecbCode.data(), 3);
            if (MONTHS.left.find(month) == MONTHS.left.end())
                return false;
        }

        // 4th, 5th characters need to be digit
        return (std::isdigit(static_cast<unsigned char>(ecbCode[3])) != 0)
            && (std::isdigit(static_cast<unsigned char>(ecbCode[4])) != 0);
    }

    string ECB::nextCode(const std::string& ecbCode) {
        QL_REQUIRE(isECBcode(ecbCode),
                   ecbCode << " is not a valid ECB code");

        const boost::string_view month(ecbCode.data(), 3);
        const Month monthEnum = MONTHS.left.at(month);

        string nextCodeStr;
        nextCodeStr.reserve(5);
        if (monthEnum != December) {
            // use next month
            const auto nextMonthEnum = static_cast<Month>(monthEnum + 1);
            const boost::string_view nextMonth = MONTHS.right.at(nextMonthEnum);
            nextCodeStr.append(nextMonth.data(), 3);

            // copy year
            nextCodeStr += {ecbCode[3], ecbCode[4]};
        } else {
            // previous month was DEC
            nextCodeStr.append("JAN");

            // init with previous year
            nextCodeStr += { ecbCode[3], ecbCode[4] };

            // increment year's last digit (e.g. '22' -> '23').
            // if overflow (e.g. '29' -> '20'), then also increment 2nd digit (e.g. '20' -> '30').
            const auto incrementAndCheckForOverlow = [](char& dig) -> bool {
                if (dig == '9') {
                    dig = '0';
                    return true;
                } else {
                    ++dig;
                    return false;
                }
            };
            if (incrementAndCheckForOverlow(nextCodeStr[4]))
                incrementAndCheckForOverlow(nextCodeStr[3]);
        }

        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_ENSURE(isECBcode(nextCodeStr),
                  "the result " << nextCodeStr <<
                  " is an invalid ECB code");
        #endif
        return nextCodeStr;
    }

}
]]></document_content>
  </document>
  <document index="58">
    <source>frequency.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2005, 2006 Ferdinando Ametrano
 Copyright (C) 2006 Katiuscia Manzoni
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/frequency.hpp>
#include <ql/types.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    std::ostream& operator<<(std::ostream& out, Frequency f) {
        switch (f) {
          case NoFrequency:
            return out << "No-Frequency";
          case Once:
            return out << "Once";
          case Annual:
            return out << "Annual";
          case Semiannual:
            return out << "Semiannual";
          case EveryFourthMonth:
            return out << "Every-Fourth-Month";
          case Quarterly:
            return out << "Quarterly";
          case Bimonthly:
            return out << "Bimonthly";
          case Monthly:
            return out << "Monthly";
          case EveryFourthWeek:
            return out << "Every-fourth-week";
          case Biweekly:
            return out << "Biweekly";
          case Weekly:
            return out << "Weekly";
          case Daily:
            return out << "Daily";
          case OtherFrequency:
            return out << "Unknown frequency";
          default:
            QL_FAIL("unknown frequency (" << Integer(f) << ")");
        }
    }

}
]]></document_content>
  </document>
  <document index="59">
    <source>imm.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007 StatPro Italia srl
 Copyright (C) 2004, 2005, 2006 Ferdinando Ametrano
 Copyright (C) 2006 Katiuscia Manzoni

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/imm.hpp>
#include <ql/settings.hpp>
#include <ql/utilities/dataparsers.hpp>
#include <boost/algorithm/string/case_conv.hpp>
#include <string>

using boost::algorithm::to_upper_copy;
using std::string;

namespace QuantLib {

    bool IMM::isIMMdate(const Date& date, bool mainCycle) {
        if (date.weekday()!=Wednesday)
            return false;

        Day d = date.dayOfMonth();
        if (d<15 || d>21)
            return false;

        if (!mainCycle) return true;

        switch (date.month()) {
          case March:
          case June:
          case September:
          case December:
            return true;
          default:
            return false;
        }
    }

    bool IMM::isIMMcode(const std::string& in, bool mainCycle) {
        if (in.length() != 2)
            return false;

        string str1("0123456789");
        string::size_type loc = str1.find(in.substr(1,1), 0);
        if (loc == string::npos)
            return false;

        if (mainCycle) str1 = "hmzuHMZU";
        else           str1 = "fghjkmnquvxzFGHJKMNQUVXZ";
        loc = str1.find(in.substr(0,1), 0);
        return loc != string::npos;
    }

    std::string IMM::code(const Date& date) {
        QL_REQUIRE(isIMMdate(date, false),
                   date << " is not an IMM date");

        std::ostringstream IMMcode;
        unsigned int y = date.year() % 10;
        switch(date.month()) {
          case January:
            IMMcode << 'F' << y;
            break;
          case February:
            IMMcode << 'G' << y;
            break;
          case March:
            IMMcode << 'H' << y;
            break;
          case April:
            IMMcode << 'J' << y;
            break;
          case May:
            IMMcode << 'K' << y;
            break;
          case June:
            IMMcode << 'M' << y;
            break;
          case July:
            IMMcode << 'N' << y;
            break;
          case August:
            IMMcode << 'Q' << y;
            break;
          case September:
            IMMcode << 'U' << y;
            break;
          case October:
            IMMcode << 'V' << y;
            break;
          case November:
            IMMcode << 'X' << y;
            break;
          case December:
            IMMcode << 'Z' << y;
            break;
          default:
            QL_FAIL("not an IMM month (and it should have been)");
        }

        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_ENSURE(isIMMcode(IMMcode.str(), false),
                  "the result " << IMMcode.str() <<
                  " is an invalid IMM code");
        #endif
        return IMMcode.str();
    }

    Date IMM::date(const std::string& immCode,
                   const Date& refDate) {
        QL_REQUIRE(isIMMcode(immCode, false),
                   immCode << " is not a valid IMM code");

        Date referenceDate = (refDate != Date() ?
                              refDate :
                              Date(Settings::instance().evaluationDate()));

        std::string code = to_upper_copy(immCode);
        std::string ms = code.substr(0,1);
        QuantLib::Month m;
        if (ms=="F")      m = January;
        else if (ms=="G") m = February;
        else if (ms=="H") m = March;
        else if (ms=="J") m = April;
        else if (ms=="K") m = May;
        else if (ms=="M") m = June;
        else if (ms=="N") m = July;
        else if (ms=="Q") m = August;
        else if (ms=="U") m = September;
        else if (ms=="V") m = October;
        else if (ms=="X") m = November;
        else if (ms=="Z") m = December;
        else QL_FAIL("invalid IMM month letter");

        Year y = std::stoi(code.substr(1,1));
        /* year<1900 are not valid QuantLib years: to avoid a run-time
           exception few lines below we need to add 10 years right away */
        if (y==0 && referenceDate.year()<=1909) y+=10;
        Year referenceYear = (referenceDate.year() % 10);
        y += referenceDate.year() - referenceYear;
        Date result = IMM::nextDate(Date(1, m, y), false);
        if (result<referenceDate)
            return IMM::nextDate(Date(1, m, y+10), false);

        return result;
    }

    Date IMM::nextDate(const Date& date, bool mainCycle) {
        Date refDate = (date == Date() ?
                        Date(Settings::instance().evaluationDate()) :
                        date);
        Year y = refDate.year();
        QuantLib::Month m = refDate.month();

        Size offset = mainCycle ? 3 : 1;
        Size skipMonths = offset-(m%offset);
        if (skipMonths != offset || refDate.dayOfMonth() > 21) {
            skipMonths += Size(m);
            if (skipMonths<=12) {
                m = QuantLib::Month(skipMonths);
            } else {
                m = QuantLib::Month(skipMonths-12);
                y += 1;
            }
        }

        Date result = Date::nthWeekday(3, Wednesday, m, y);
        if (result<=refDate)
            result = nextDate(Date(22, m, y), mainCycle);
        return result;
    }

    Date IMM::nextDate(const std::string& IMMcode,
                       bool mainCycle,
                       const Date& referenceDate)  {
        Date immDate = date(IMMcode, referenceDate);
        return nextDate(immDate+1, mainCycle);
    }

    std::string IMM::nextCode(const Date& d,
                              bool mainCycle) {
        Date date = nextDate(d, mainCycle);
        return code(date);
    }

    std::string IMM::nextCode(const std::string& immCode,
                              bool mainCycle,
                              const Date& referenceDate) {
        Date date = nextDate(immCode, mainCycle, referenceDate);
        return code(date);
    }

}
]]></document_content>
  </document>
  <document index="60">
    <source>period.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2005, 2006, 2007, 2008, 2014 Ferdinando Ametrano
 Copyright (C) 2006 Katiuscia Manzoni
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2008 StatPro Italia srl
 Copyright (C) 2014 Paolo Mazzocchi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/period.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    Period::Period(Frequency f) {
        switch (f) {
          case NoFrequency:
            // same as Period()
            units_ = Days;
            length_ = 0;
            break;
          case Once:
            units_ = Years;
            length_ = 0;
            break;
          case Annual:
            units_ = Years;
            length_ = 1;
            break;
          case Semiannual:
          case EveryFourthMonth:
          case Quarterly:
          case Bimonthly:
          case Monthly:
            units_ = Months;
            length_ = 12/f;
            break;
          case EveryFourthWeek:
          case Biweekly:
          case Weekly:
            units_ = Weeks;
            length_ = 52/f;
            break;
          case Daily:
            units_ = Days;
            length_ = 1;
            break;
          case OtherFrequency:
            QL_FAIL("unknown frequency");  // no point in showing 999...
          default:
            QL_FAIL("unknown frequency (" << Integer(f) << ")");
        }
    }

    Frequency Period::frequency() const {
        // unsigned version
        Size length = std::abs(length_);

        if (length==0) {
            if (units_==Years) return Once;
            return NoFrequency;
        }

        switch (units_) {
          case Years:
            if (length == 1)
                return Annual;
            else
                return OtherFrequency;
          case Months:
            if (12%length == 0 && length <= 12)
                return Frequency(12/length);
            else
                return OtherFrequency;
          case Weeks:
            if (length==1)
                return Weekly;
            else if (length==2)
                return Biweekly;
            else if (length==4)
                return EveryFourthWeek;
            else
                return OtherFrequency;
          case Days:
            if (length==1)
                return Daily;
            else
                return OtherFrequency;
          default:
            QL_FAIL("unknown time unit (" << Integer(units_) << ")");
        }
    }

    void Period::normalize() {
        if (length_ == 0) {
            units_ = Days;
        } else {
            switch (units_) {
              case Months:
                if ((length_ % 12) == 0) {
                    length_ /= 12;
                    units_ = Years;
                }
                break;
              case Days:
                if ((length_ % 7) == 0) {
                    length_ /= 7;
                    units_ = Weeks;
                }
                break;
              case Weeks:
              case Years:
                break;
              default:
                QL_FAIL("unknown time unit (" << Integer(units_) << ")");
            }
        }
    }

    Period& Period::operator+=(const Period& p) {

        if (length_==0) {
            length_ = p.length();
            units_ = p.units();
        } else if (units_==p.units()) {
            // no conversion needed
            length_ += p.length();
        } else {
            switch (units_) {

              case Years:
                switch (p.units()) {
                  case Months:
                    units_ = Months;
                    length_ = length_*12 + p.length();
                    break;
                  case Weeks:
                  case Days:
                    QL_REQUIRE(p.length()==0,
                               "impossible addition between " << *this <<
                               " and " << p);
                    break;
                  default:
                    QL_FAIL("unknown time unit (" << Integer(p.units()) << ")");
                }
                break;

              case Months:
                switch (p.units()) {
                  case Years:
                    length_ += p.length()*12;
                    break;
                  case Weeks:
                  case Days:
                    QL_REQUIRE(p.length()==0,
                               "impossible addition between " << *this <<
                               " and " << p);
                    break;
                  default:
                    QL_FAIL("unknown time unit (" << Integer(p.units()) << ")");
                }
                break;

              case Weeks:
                switch (p.units()) {
                  case Days:
                    units_ = Days;
                    length_ = length_*7 + p.length();
                    break;
                  case Years:
                  case Months:
                    QL_REQUIRE(p.length()==0,
                               "impossible addition between " << *this <<
                               " and " << p);
                    break;
                  default:
                    QL_FAIL("unknown time unit (" << Integer(p.units()) << ")");
                }
                break;

              case Days:
                switch (p.units()) {
                  case Weeks:
                    length_ += p.length()*7;
                    break;
                  case Years:
                  case Months:
                    QL_REQUIRE(p.length()==0,
                               "impossible addition between " << *this <<
                               " and " << p);
                    break;
                  default:
                    QL_FAIL("unknown time unit (" << Integer(p.units()) << ")");
                }
                break;

              default:
                QL_FAIL("unknown time unit (" << Integer(units_) << ")");
            }
        }

        return *this;
    }

    Period& Period::operator-=(const Period& p) {
        return operator+=(-p);
    }

    Period& Period::operator*=(Integer n) {
        length_ *= n;
        return *this;
    }

    Period& Period::operator/=(Integer n) {
        QL_REQUIRE(n != 0, "cannot be divided by zero");
        if (length_ % n == 0) {
            // keep the original units. If the user created a
            // 24-months period, he'll probably want a 12-months one
            // when he halves it.
            length_ /= n;
        } else {
            // try
            TimeUnit units = units_;
            Integer length = length_;
            switch (units) {
              case Years:
                length *= 12;
                units = Months;
                break;
              case Weeks:
                length *= 7;
                units = Days;
                break;
              default:
                ;
            }
            QL_REQUIRE(length % n == 0,
                       *this << " cannot be divided by " << n);
            length_ = length/n;
            units_ = units;
        }
        return *this;
    }


    namespace {

        std::pair<Integer,Integer> daysMinMax(const Period& p) {
            switch (p.units()) {
              case Days:
                return std::make_pair(p.length(), p.length());
              case Weeks:
                return std::make_pair(7*p.length(), 7*p.length());
              case Months:
                return std::make_pair(28*p.length(), 31*p.length());
              case Years:
                return std::make_pair(365*p.length(), 366*p.length());
              default:
                QL_FAIL("unknown time unit (" << Integer(p.units()) << ")");
            }
        }

    }

    Real years(const Period& p) {
        if (p.length()==0) return 0.0;

        switch (p.units()) {
          case Days:
            QL_FAIL("cannot convert Days into Years");
          case Weeks:
            QL_FAIL("cannot convert Weeks into Years");
          case Months:
              return p.length()/12.0;
          case Years:
              return p.length();
          default:
            QL_FAIL("unknown time unit (" << Integer(p.units()) << ")");
        }
    }

    Real months(const Period& p) {
        if (p.length()==0) return 0.0;

        switch (p.units()) {
          case Days:
            QL_FAIL("cannot convert Days into Months");
          case Weeks:
            QL_FAIL("cannot convert Weeks into Months");
          case Months:
              return p.length();
          case Years:
              return p.length()*12.0;
          default:
            QL_FAIL("unknown time unit (" << Integer(p.units()) << ")");
        }
    }

    Real weeks(const Period& p) {
        if (p.length()==0) return 0.0;

        switch (p.units()) {
          case Days:
              return p.length()/7.0;
          case Weeks:
              return p.length();
          case Months:
            QL_FAIL("cannot convert Months into Weeks");
          case Years:
            QL_FAIL("cannot convert Years into Weeks");
          default:
            QL_FAIL("unknown time unit (" << Integer(p.units()) << ")");
        }
    }

    Real days(const Period& p) {
        if (p.length()==0) return 0.0;

        switch (p.units()) {
          case Days:
              return p.length();
          case Weeks:
              return p.length()*7.0;
          case Months:
            QL_FAIL("cannot convert Months into Days");
          case Years:
            QL_FAIL("cannot convert Years into Days");
          default:
            QL_FAIL("unknown time unit (" << Integer(p.units()) << ")");
        }
    }

    bool operator<(const Period& p1, const Period& p2) {

        // special cases
        if (p1.length() == 0)
            return p2.length() > 0;
        if (p2.length() == 0)
            return p1.length() < 0;

        // exact comparisons
        if (p1.units() == p2.units())
            return p1.length() < p2.length();
        if (p1.units() == Months && p2.units() == Years)
            return p1.length() < 12*p2.length();
        if (p1.units() == Years && p2.units() == Months)
            return 12*p1.length() < p2.length();
        if (p1.units() == Days && p2.units() == Weeks)
            return p1.length() < 7*p2.length();
        if (p1.units() == Weeks && p2.units() == Days)
            return 7*p1.length() < p2.length();

        // inexact comparisons (handled by converting to days and using limits)
        std::pair<Integer, Integer> p1lim = daysMinMax(p1);
        std::pair<Integer, Integer> p2lim = daysMinMax(p2);

        if (p1lim.second < p2lim.first)
            return true;
        else if (p1lim.first > p2lim.second)
            return false;
        else
            QL_FAIL("undecidable comparison between " << p1 << " and " << p2);
    }


    Period operator+(const Period& p1, const Period& p2) {
        Period result = p1;
        result += p2;
        return result;
    }

    Period operator-(const Period& p1, const Period& p2) {
        return p1+(-p2);
    }

    Period operator/(const Period& p, Integer n) {
        Period result = p;
        result /= n;
        return result;
    }

    // period formatting

    std::ostream& operator<<(std::ostream& out, const Period& p) {
        return out << io::short_period(p);
    }

    namespace detail {

        std::ostream& operator<<(std::ostream& out,
                                 const long_period_holder& holder) {
            Integer n = holder.p.length();
            switch (holder.p.units()) {
              case Days:
                return out << n << (n == 1 ? " day" : " days");
              case Weeks:
                return out << n << (n == 1 ? " week" : " weeks");
              case Months:
                return out << n << (n == 1 ? " month" : " months");
              case Years:
                return out << n << (n == 1 ? " year" : " years");
              default:
                QL_FAIL("unknown time unit (" << Integer(holder.p.units()) << ")");
            }
        }

        std::ostream& operator<<(std::ostream& out,
                                 const short_period_holder& holder) {
            Integer n = holder.p.length();
            switch (holder.p.units()) {
              case Hours:
                return out << n << "h";
              case Minutes:
                return out << n << "m";
              case Seconds:
                return out << n << "s";
              case Days:
                return out << n << "D";
              case Weeks:
                return out << n << "W";
              case Months:
                return out << n << "M";
              case Years:
                return out << n << "Y";
              default:
                QL_FAIL("unknown time unit (" << Integer(holder.p.units()) << ")");
            }
        }

    }

    namespace io {

        detail::long_period_holder long_period(const Period& p) {
            return detail::long_period_holder(p);
        }

        detail::short_period_holder short_period(const Period& p) {
            return detail::short_period_holder(p);
        }

    }

}
]]></document_content>
  </document>
  <document index="61">
    <source>schedule.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007, 2008, 2010, 2011, 2015 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2009, 2012 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/optional.hpp>
#include <ql/settings.hpp>
#include <ql/time/imm.hpp>
#include <ql/time/schedule.hpp>
#include <algorithm>
#include <utility>

namespace QuantLib {

    namespace {

        Date nextTwentieth(const Date& d, DateGeneration::Rule rule) {
            Date result = Date(20, d.month(), d.year());
            if (result < d)
                result += 1*Months;
            if (rule == DateGeneration::TwentiethIMM ||
                rule == DateGeneration::OldCDS ||
                rule == DateGeneration::CDS ||
                rule == DateGeneration::CDS2015) {
                Month m = result.month();
                if (m % 3 != 0) { // not a main IMM nmonth
                    Integer skip = 3 - m%3;
                    result += skip*Months;
                }
            }
            return result;
        }

        bool allowsEndOfMonth(const Period& tenor) {
            return (tenor.units() == Months || tenor.units() == Years)
                && tenor >= 1*Months;
        }

    }


    Schedule::Schedule(const std::vector<Date>& dates,
                       Calendar calendar,
                       BusinessDayConvention convention,
                       const ext::optional<BusinessDayConvention>& terminationDateConvention,
                       const ext::optional<Period>& tenor,
                       const ext::optional<DateGeneration::Rule>& rule,
                       const ext::optional<bool>& endOfMonth,
                       std::vector<bool> isRegular)
    : tenor_(tenor), calendar_(std::move(calendar)), convention_(convention),
      terminationDateConvention_(terminationDateConvention), rule_(rule), dates_(dates),
      isRegular_(std::move(isRegular)) {

        if (tenor && !allowsEndOfMonth(*tenor))
            endOfMonth_ = false;
        else
            endOfMonth_ = endOfMonth;

        QL_REQUIRE(isRegular_.empty() || isRegular_.size() == dates.size() - 1,
                   "isRegular size (" << isRegular_.size()
                                      << ") must be zero or equal to the number of dates minus 1 ("
                                      << dates.size() - 1 << ")");
    }

    Schedule::Schedule(Date effectiveDate,
                       const Date& terminationDate,
                       const Period& tenor,
                       Calendar cal,
                       BusinessDayConvention convention,
                       BusinessDayConvention terminationDateConvention,
                       DateGeneration::Rule rule,
                       bool endOfMonth,
                       const Date& first,
                       const Date& nextToLast)
    : tenor_(tenor), calendar_(std::move(cal)), convention_(convention),
      terminationDateConvention_(terminationDateConvention), rule_(rule),
      endOfMonth_(allowsEndOfMonth(tenor) ? endOfMonth : false),
      firstDate_(first == effectiveDate ? Date() : first),
      nextToLastDate_(nextToLast == terminationDate ? Date() : nextToLast) {
        // sanity checks
        QL_REQUIRE(terminationDate != Date(), "null termination date");

        // in many cases (e.g. non-expired bonds) the effective date is not
        // really necessary. In these cases a decent placeholder is enough
        if (effectiveDate==Date() && first==Date()
                                  && rule==DateGeneration::Backward) {
            Date evalDate = Settings::instance().evaluationDate();
            QL_REQUIRE(evalDate < terminationDate, "null effective date");
            Natural y;
            if (nextToLast != Date()) {
                y = (nextToLast - evalDate)/366 + 1;
                effectiveDate = nextToLast - y*Years;
            } else {
                y = (terminationDate - evalDate)/366 + 1;
                effectiveDate = terminationDate - y*Years;
            }
        } else
            QL_REQUIRE(effectiveDate != Date(), "null effective date");

        QL_REQUIRE(effectiveDate < terminationDate,
                   "effective date (" << effectiveDate
                   << ") later than or equal to termination date ("
                   << terminationDate << ")");

        if (tenor.length()==0)
            rule_ = DateGeneration::Zero;
        else
            QL_REQUIRE(tenor.length()>0,
                       "non positive tenor (" << tenor << ") not allowed");

        if (firstDate_ != Date()) {
            switch (*rule_) {
              case DateGeneration::Backward:
              case DateGeneration::Forward:
                QL_REQUIRE(firstDate_ > effectiveDate &&
                           firstDate_ <= terminationDate,
                           "first date (" << firstDate_ <<
                           ") out of effective-termination date range (" <<
                           effectiveDate << ", " << terminationDate << "]");
                // we should ensure that the above condition is still
                // verified after adjustment
                break;
              case DateGeneration::ThirdWednesday:
                  QL_REQUIRE(IMM::isIMMdate(firstDate_, false),
                             "first date (" << firstDate_ <<
                             ") is not an IMM date");
                break;
              case DateGeneration::Zero:
              case DateGeneration::Twentieth:
              case DateGeneration::TwentiethIMM:
              case DateGeneration::OldCDS:
              case DateGeneration::CDS:
              case DateGeneration::CDS2015:
                QL_FAIL("first date incompatible with " << *rule_ <<
                        " date generation rule");
              default:
                QL_FAIL("unknown rule (" << Integer(*rule_) << ")");
            }
        }
        if (nextToLastDate_ != Date()) {
            switch (*rule_) {
              case DateGeneration::Backward:
              case DateGeneration::Forward:
                QL_REQUIRE(nextToLastDate_ >= effectiveDate &&
                           nextToLastDate_ < terminationDate,
                           "next to last date (" << nextToLastDate_ <<
                           ") out of effective-termination date range [" <<
                           effectiveDate << ", " << terminationDate << ")");
                // we should ensure that the above condition is still
                // verified after adjustment
                break;
              case DateGeneration::ThirdWednesday:
                QL_REQUIRE(IMM::isIMMdate(nextToLastDate_, false),
                           "next-to-last date (" << nextToLastDate_ <<
                           ") is not an IMM date");
                break;
              case DateGeneration::Zero:
              case DateGeneration::Twentieth:
              case DateGeneration::TwentiethIMM:
              case DateGeneration::OldCDS:
              case DateGeneration::CDS:
              case DateGeneration::CDS2015:
                QL_FAIL("next to last date incompatible with " << *rule_ <<
                        " date generation rule");
              default:
                QL_FAIL("unknown rule (" << Integer(*rule_) << ")");
            }
        }


        // calendar needed for endOfMonth adjustment
        Calendar nullCalendar = NullCalendar();
        Integer periods = 1;
        Date seed, exitDate;
        switch (*rule_) {

          case DateGeneration::Zero:
            tenor_ = 0*Years;
            dates_.push_back(effectiveDate);
            dates_.push_back(terminationDate);
            isRegular_.push_back(true);
            break;

          case DateGeneration::Backward:

            dates_.push_back(terminationDate);

            seed = terminationDate;
            if (nextToLastDate_ != Date()) {
                dates_.push_back(nextToLastDate_);
                Date temp = nullCalendar.advance(seed,
                    -periods*(*tenor_), convention, *endOfMonth_);
                isRegular_.push_back(temp == nextToLastDate_);
                seed = nextToLastDate_;
            }

            exitDate = effectiveDate;
            if (firstDate_ != Date())
                exitDate = firstDate_;

            for (;;) {
                Date temp = nullCalendar.advance(seed,
                    -periods*(*tenor_), convention, *endOfMonth_);
                if (temp < exitDate) {
                    if (firstDate_ != Date() &&
                        (calendar_.adjust(dates_.back(),convention)!=
                         calendar_.adjust(firstDate_,convention))) {
                        dates_.push_back(firstDate_);
                        isRegular_.push_back(false);
                    }
                    break;
                } else {
                    // skip dates that would result in duplicates
                    // after adjustment
                    if (calendar_.adjust(dates_.back(),convention)!=
                        calendar_.adjust(temp,convention)) {
                        dates_.push_back(temp);
                        isRegular_.push_back(true);
                    }
                    ++periods;
                }
            }

            if (calendar_.adjust(dates_.back(),convention)!=
                calendar_.adjust(effectiveDate,convention)) {
                dates_.push_back(effectiveDate);
                isRegular_.push_back(false);
            }
	    std::reverse(dates_.begin(), dates_.end());
	    std::reverse(isRegular_.begin(), isRegular_.end());
            break;

          case DateGeneration::Twentieth:
          case DateGeneration::TwentiethIMM:
          case DateGeneration::ThirdWednesday:
          case DateGeneration::ThirdWednesdayInclusive:
          case DateGeneration::OldCDS:
          case DateGeneration::CDS:
          case DateGeneration::CDS2015:
            QL_REQUIRE(!*endOfMonth_,
                       "endOfMonth convention incompatible with " << *rule_ <<
                       " date generation rule");
            [[fallthrough]];
          case DateGeneration::Forward:

            if (*rule_ == DateGeneration::CDS || *rule_ == DateGeneration::CDS2015) {
                Date prev20th = previousTwentieth(effectiveDate, *rule_);
                if (calendar_.adjust(prev20th, convention) > effectiveDate) {
                    dates_.push_back(prev20th - 3 * Months);
                    isRegular_.push_back(true);
                }
                dates_.push_back(prev20th);
            } else {
                dates_.push_back(effectiveDate);
            }

            seed = dates_.back();

            if (firstDate_!=Date()) {
                dates_.push_back(firstDate_);
                Date temp = nullCalendar.advance(seed, periods*(*tenor_),
                                                 convention, *endOfMonth_);
                if (temp!=firstDate_)
                    isRegular_.push_back(false);
                else
                    isRegular_.push_back(true);
                seed = firstDate_;
            } else if (*rule_ == DateGeneration::Twentieth ||
                       *rule_ == DateGeneration::TwentiethIMM ||
                       *rule_ == DateGeneration::OldCDS ||
                       *rule_ == DateGeneration::CDS ||
                       *rule_ == DateGeneration::CDS2015) {
                Date next20th = nextTwentieth(effectiveDate, *rule_);
                if (*rule_ == DateGeneration::OldCDS) {
                    // distance rule inforced in natural days
                    static const Date::serial_type stubDays = 30;
                    if (next20th - effectiveDate < stubDays) {
                        // +1 will skip this one and get the next
                        next20th = nextTwentieth(next20th + 1, *rule_);
                    }
                }
                if (next20th != effectiveDate) {
                    dates_.push_back(next20th);
                    isRegular_.push_back(*rule_ == DateGeneration::CDS || *rule_ == DateGeneration::CDS2015);
                    seed = next20th;
                }
            }

            exitDate = terminationDate;
            if (nextToLastDate_ != Date())
                exitDate = nextToLastDate_;
            for (;;) {
                Date temp = nullCalendar.advance(seed, periods*(*tenor_),
                                                 convention, *endOfMonth_);
                if (temp > exitDate) {
                    if (nextToLastDate_ != Date() &&
                        (calendar_.adjust(dates_.back(),convention)!=
                         calendar_.adjust(nextToLastDate_,convention))) {
                        dates_.push_back(nextToLastDate_);
                        isRegular_.push_back(false);
                    }
                    break;
                } else {
                    // skip dates that would result in duplicates
                    // after adjustment
                    if (calendar_.adjust(dates_.back(),convention)!=
                        calendar_.adjust(temp,convention)) {
                        dates_.push_back(temp);
                        isRegular_.push_back(true);
                    }
                    ++periods;
                }
            }

            if (calendar_.adjust(dates_.back(),terminationDateConvention)!=
                calendar_.adjust(terminationDate,terminationDateConvention)) {
                if (*rule_ == DateGeneration::Twentieth ||
                    *rule_ == DateGeneration::TwentiethIMM ||
                    *rule_ == DateGeneration::OldCDS ||
                    *rule_ == DateGeneration::CDS ||
                    *rule_ == DateGeneration::CDS2015) {
                    dates_.push_back(nextTwentieth(terminationDate, *rule_));
                    isRegular_.push_back(true);
                } else {
                    dates_.push_back(terminationDate);
                    isRegular_.push_back(false);
                }
            }

            break;

          default:
            QL_FAIL("unknown rule (" << Integer(*rule_) << ")");
        }

        // adjustments
        if (*rule_==DateGeneration::ThirdWednesday)
            for (Size i=1; i<dates_.size()-1; ++i)
                dates_[i] = Date::nthWeekday(3, Wednesday,
                                             dates_[i].month(),
                                             dates_[i].year());
        else if (*rule_ == DateGeneration::ThirdWednesdayInclusive)
            for (auto& date : dates_)
                date = Date::nthWeekday(3, Wednesday, date.month(), date.year());

        // first date not adjusted for old CDS schedules
        if (convention != Unadjusted && *rule_ != DateGeneration::OldCDS)
            dates_.front() = calendar_.adjust(dates_.front(), convention);

        // termination date is NOT adjusted as per ISDA
        // specifications, unless otherwise specified in the
        // confirmation of the deal or unless we're creating a CDS
        // schedule
        if (terminationDateConvention != Unadjusted 
            && *rule_ != DateGeneration::CDS 
            && *rule_ != DateGeneration::CDS2015) {
            dates_.back() = calendar_.adjust(dates_.back(), 
                                             terminationDateConvention);
        }

        if (*endOfMonth_ && calendar_.isEndOfMonth(seed)) {
            // adjust to end of month
            for (Size i=1; i<dates_.size()-1; ++i)
                dates_[i] = calendar_.adjust(Date::endOfMonth(dates_[i]), convention);
        } else {
            for (Size i=1; i<dates_.size()-1; ++i)
                dates_[i] = calendar_.adjust(dates_[i], convention);
        }

        // Final safety checks to remove extra next-to-last date, if
        // necessary.  It can happen to be equal or later than the end
        // date due to EOM adjustments (see the Schedule test suite
        // for an example).
        if (dates_.size() >= 2 && dates_[dates_.size()-2] >= dates_.back()) {
            // there might be two dates only, then isRegular_ has size one
            if (isRegular_.size() >= 2) {
                isRegular_[isRegular_.size() - 2] =
                    (dates_[dates_.size() - 2] == dates_.back());
            }
            dates_[dates_.size() - 2] = dates_.back();
            dates_.pop_back();
            isRegular_.pop_back();
        }
        if (dates_.size() >= 2 && dates_[1] <= dates_.front()) {
            isRegular_[1] =
                (dates_[1] == dates_.front());
            dates_[1] = dates_.front();
            dates_.erase(dates_.begin());
            isRegular_.erase(isRegular_.begin());
        }

        QL_ENSURE(dates_.size()>1,
            "degenerate single date (" << dates_[0] << ") schedule" <<
            "\n seed date: " << seed <<
            "\n exit date: " << exitDate <<
            "\n effective date: " << effectiveDate <<
            "\n first date: " << first <<
            "\n next to last date: " << nextToLast <<
            "\n termination date: " << terminationDate <<
            "\n generation rule: " << *rule_ <<
            "\n end of month: " << *endOfMonth_);
    }

    Schedule Schedule::after(const Date& truncationDate) const {
        Schedule result = *this;

        QL_REQUIRE(truncationDate < result.dates_.back(),
            "truncation date " << truncationDate <<
            " must be before the last schedule date " <<
            result.dates_.back());
        if (truncationDate > result.dates_[0]) {
            // remove earlier dates
            while (result.dates_[0] < truncationDate) {
                result.dates_.erase(result.dates_.begin());
                if (!result.isRegular_.empty())
                    result.isRegular_.erase(result.isRegular_.begin());
            }

            // add truncationDate if missing
            if (truncationDate != result.dates_.front()) {
                result.dates_.insert(result.dates_.begin(), truncationDate);
                result.isRegular_.insert(result.isRegular_.begin(), false);
                result.terminationDateConvention_ = Unadjusted;
            }
            else {
                result.terminationDateConvention_ = convention_;
            }

            if (result.nextToLastDate_ <= truncationDate)
                result.nextToLastDate_ = Date();
            if (result.firstDate_ <= truncationDate)
                result.firstDate_ = Date();
        }

        return result;
    }

    Schedule Schedule::until(const Date& truncationDate) const {
        Schedule result = *this;

        QL_REQUIRE(truncationDate>result.dates_[0],
                   "truncation date " << truncationDate <<
                   " must be later than schedule first date " <<
                   result.dates_[0]);
        if (truncationDate<result.dates_.back()) {
            // remove later dates
            while (result.dates_.back()>truncationDate) {
                result.dates_.pop_back();
                if(!result.isRegular_.empty())
                    result.isRegular_.pop_back();
            }

            // add truncationDate if missing
            if (truncationDate!=result.dates_.back()) {
                result.dates_.push_back(truncationDate);
                result.isRegular_.push_back(false);
                result.terminationDateConvention_ = Unadjusted;
            } else {
                result.terminationDateConvention_ = convention_;
            }

            if (result.nextToLastDate_>=truncationDate)
                result.nextToLastDate_ = Date();
            if (result.firstDate_>=truncationDate)
                result.firstDate_ = Date();
        }

        return result;
    }

    std::vector<Date>::const_iterator
    Schedule::lower_bound(const Date& refDate) const {
        Date d = (refDate==Date() ?
                  Settings::instance().evaluationDate() :
                  refDate);
        return std::lower_bound(dates_.begin(), dates_.end(), d);
    }

    Date Schedule::nextDate(const Date& refDate) const {
        auto res = lower_bound(refDate);
        if (res!=dates_.end())
            return *res;
        else
            return {};
    }

    Date Schedule::previousDate(const Date& refDate) const {
        auto res = lower_bound(refDate);
        if (res!=dates_.begin())
            return *(--res);
        else
            return {};
    }

    bool Schedule::hasIsRegular() const { return !isRegular_.empty(); }

    bool Schedule::isRegular(Size i) const {
        QL_REQUIRE(hasIsRegular(),
                   "full interface (isRegular) not available");
        QL_REQUIRE(i<=isRegular_.size() && i>0,
                   "index (" << i << ") must be in [1, " <<
                   isRegular_.size() <<"]");
        return isRegular_[i-1];
    }

    const std::vector<bool>& Schedule::isRegular() const {
        QL_REQUIRE(!isRegular_.empty(), "full interface (isRegular) not available");
        return isRegular_;
    }

    MakeSchedule& MakeSchedule::from(const Date& effectiveDate) {
        effectiveDate_ = effectiveDate;
        return *this;
    }

    MakeSchedule& MakeSchedule::to(const Date& terminationDate) {
        terminationDate_ = terminationDate;
        return *this;
    }

    MakeSchedule& MakeSchedule::withTenor(const Period& tenor) {
        tenor_ = tenor;
        return *this;
    }

    MakeSchedule& MakeSchedule::withFrequency(Frequency frequency) {
        tenor_ = Period(frequency);
        return *this;
    }

    MakeSchedule& MakeSchedule::withCalendar(const Calendar& calendar) {
        calendar_ = calendar;
        return *this;
    }

    MakeSchedule& MakeSchedule::withConvention(BusinessDayConvention conv) {
        convention_ = conv;
        return *this;
    }

    MakeSchedule& MakeSchedule::withTerminationDateConvention(
                                                BusinessDayConvention conv) {
        terminationDateConvention_ = conv;
        return *this;
    }

    MakeSchedule& MakeSchedule::withRule(DateGeneration::Rule r) {
        rule_ = r;
        return *this;
    }

    MakeSchedule& MakeSchedule::forwards() {
        rule_ = DateGeneration::Forward;
        return *this;
    }

    MakeSchedule& MakeSchedule::backwards() {
        rule_ = DateGeneration::Backward;
        return *this;
    }

    MakeSchedule& MakeSchedule::endOfMonth(bool flag) {
        endOfMonth_ = flag;
        return *this;
    }

    MakeSchedule& MakeSchedule::withFirstDate(const Date& d) {
        firstDate_ = d;
        return *this;
    }

    MakeSchedule& MakeSchedule::withNextToLastDate(const Date& d) {
        nextToLastDate_ = d;
        return *this;
    }

    MakeSchedule::operator Schedule() const {
        // check for mandatory arguments
        QL_REQUIRE(effectiveDate_ != Date(), "effective date not provided");
        QL_REQUIRE(terminationDate_ != Date(), "termination date not provided");
        QL_REQUIRE(tenor_, "tenor/frequency not provided");

        // set dynamic defaults:
        BusinessDayConvention convention;
        // if a convention was set, we use it.
        if (convention_) { // NOLINT(readability-implicit-bool-conversion)
            convention = *convention_;
        } else {
            if (!calendar_.empty()) {
                // ...if we set a calendar, we probably want it to be used;
                convention = Following;
            } else {
                // if not, we don't care.
                convention = Unadjusted;
            }
        }

        BusinessDayConvention terminationDateConvention;
        // if set explicitly, we use it;
        if (terminationDateConvention_) { // NOLINT(readability-implicit-bool-conversion)
            terminationDateConvention = *terminationDateConvention_;
        } else {
            // Unadjusted as per ISDA specification
            terminationDateConvention = convention;
        }

        Calendar calendar = calendar_;
        // if no calendar was set...
        if (calendar.empty()) {
            // ...we use a null one.
            calendar = NullCalendar();
        }

        return Schedule(effectiveDate_, terminationDate_, *tenor_, calendar,
                        convention, terminationDateConvention,
                        rule_, endOfMonth_, firstDate_, nextToLastDate_);
    }

    Date previousTwentieth(const Date& d, DateGeneration::Rule rule) {
        Date result = Date(20, d.month(), d.year());
        if (result > d)
            result -= 1 * Months;
        if (rule == DateGeneration::TwentiethIMM ||
            rule == DateGeneration::OldCDS ||
            rule == DateGeneration::CDS ||
            rule == DateGeneration::CDS2015) {
            Month m = result.month();
            if (m % 3 != 0) { // not a main IMM nmonth
                Integer skip = m % 3;
                result -= skip * Months;
            }
        }
        return result;
    }

}
]]></document_content>
  </document>
  <document index="62">
    <source>timeunit.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/timeunit.hpp>
#include <ql/types.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    // timeunit formatting

    std::ostream& operator<<(std::ostream& out, const TimeUnit& timeunit) {
        switch (timeunit) {
            case Years:
                return out << "Years";
            case Months:
                return out << "Months";
            case Weeks:
                return out << "Weeks";
            case Days:
                return out << "Days";
            case Hours:
                return out << "Hours";
            case Minutes:
                return out << "Minutes";
            case Seconds:
                return out << "Seconds";
            case Milliseconds:
                return out << "Milliseconds";
            case Microseconds:
                return out << "Microseconds";
            default:
                QL_FAIL("unknown TimeUnit");
        }
    }

}
]]></document_content>
  </document>
  <document index="63">
    <source>weekday.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl
 Copyright (C) 2004, 2005, 2006 Ferdinando Ametrano
 Copyright (C) 2006 Katiuscia Manzoni
 Copyright (C) 2006 Toyin Akin

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/weekday.hpp>
#include <ql/types.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    // weekday formatting

    std::ostream& operator<<(std::ostream& out, const Weekday& w) {
        return out << io::long_weekday(w);
    }

    namespace detail {

        std::ostream& operator<<(std::ostream& out,
                                 const long_weekday_holder& holder) {
            switch (holder.d) {
              case Sunday:
                return out << "Sunday";
              case Monday:
                return out << "Monday";
              case Tuesday:
                return out << "Tuesday";
              case Wednesday:
                return out << "Wednesday";
              case Thursday:
                return out << "Thursday";
              case Friday:
                return out << "Friday";
              case Saturday:
                return out << "Saturday";
              default:
                QL_FAIL("unknown weekday");
            }
        }

        std::ostream& operator<<(std::ostream& out,
                                 const short_weekday_holder& holder) {
            switch (holder.d) {
              case Sunday:
                return out << "Sun";
              case Monday:
                return out << "Mon";
              case Tuesday:
                return out << "Tue";
              case Wednesday:
                return out << "Wed";
              case Thursday:
                return out << "Thu";
              case Friday:
                return out << "Fri";
              case Saturday:
                return out << "Sat";
              default:
                QL_FAIL("unknown weekday");
            }
        }

        std::ostream& operator<<(std::ostream& out,
                                 const shortest_weekday_holder& holder) {
            switch (holder.d) {
              case Sunday:
                return out << "Su";
              case Monday:
                return out << "Mo";
              case Tuesday:
                return out << "Tu";
              case Wednesday:
                return out << "We";
              case Thursday:
                return out << "Th";
              case Friday:
                return out << "Fr";
              case Saturday:
                return out << "Sa";
              default:
                QL_FAIL("unknown weekday");
            }
        }

    }

    namespace io {

        detail::long_weekday_holder long_weekday(Weekday d) {
            return detail::long_weekday_holder(d);
        }

        detail::short_weekday_holder short_weekday(Weekday d) {
            return detail::short_weekday_holder(d);
        }

        detail::shortest_weekday_holder shortest_weekday(Weekday d) {
            return detail::shortest_weekday_holder(d);
        }

    }

}
]]></document_content>
  </document>
</documents>