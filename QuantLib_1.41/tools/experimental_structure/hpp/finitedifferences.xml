<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/finitedifferences/dynprogvppintrinsicvalueengine.hpp>
#include <ql/experimental/finitedifferences/fdextoujumpvanillaengine.hpp>
#include <ql/experimental/finitedifferences/fdklugeextouspreadengine.hpp>
#include <ql/experimental/finitedifferences/fdmdupire1dop.hpp>
#include <ql/experimental/finitedifferences/fdmexpextouinnervaluecalculator.hpp>
#include <ql/experimental/finitedifferences/fdmextendedornsteinuhlenbeckop.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpmodelinnervalue.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpop.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpsolver.hpp>
#include <ql/experimental/finitedifferences/fdmklugeextouop.hpp>
#include <ql/experimental/finitedifferences/fdmklugeextousolver.hpp>
#include <ql/experimental/finitedifferences/fdmsimple2dextousolver.hpp>
#include <ql/experimental/finitedifferences/fdmsimple3dextoujumpsolver.hpp>
#include <ql/experimental/finitedifferences/fdmspreadpayoffinnervalue.hpp>
#include <ql/experimental/finitedifferences/fdmvppstartlimitstepcondition.hpp>
#include <ql/experimental/finitedifferences/fdmvppstepcondition.hpp>
#include <ql/experimental/finitedifferences/fdmvppstepconditionfactory.hpp>
#include <ql/experimental/finitedifferences/fdmzabrop.hpp>
#include <ql/experimental/finitedifferences/fdornsteinuhlenbeckvanillaengine.hpp>
#include <ql/experimental/finitedifferences/fdsimpleextoujumpswingengine.hpp>
#include <ql/experimental/finitedifferences/fdsimpleextoustorageengine.hpp>
#include <ql/experimental/finitedifferences/fdsimpleklugeextouvppengine.hpp>
#include <ql/experimental/finitedifferences/glued1dmesher.hpp>
#include <ql/experimental/finitedifferences/vanillavppoption.hpp>

]]></document_content>
  </document>
  <document index="2">
    <source>dynprogvppintrinsicvalueengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file dynprogvppintrinsicvalueengine.hpp
    \brief intrinsic value engine using dynamic programming
*/

#ifndef quantlib_dp_vpp_intrinsic_value_engine_hpp
#define quantlib_dp_vpp_intrinsic_value_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/experimental/finitedifferences/vanillavppoption.hpp>
#include <vector>

namespace QuantLib {

    class YieldTermStructure;

    class DynProgVPPIntrinsicValueEngine
        : public GenericEngine<VanillaVPPOption::arguments,
                               VanillaVPPOption::results> {
      public:
        DynProgVPPIntrinsicValueEngine(std::vector<Real> fuelPrices,
                                       std::vector<Real> powerPrices,
                                       Real fuelCostAddon,
                                       ext::shared_ptr<YieldTermStructure> rTS);

        void calculate() const override;

      private:
        const std::vector<Real> fuelPrices_;
        const std::vector<Real> powerPrices_;
        const Real fuelCostAddon_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
    };
}

#endif

]]></document_content>
  </document>
  <document index="3">
    <source>fdextoujumpvanillaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdextoujumpvanillaengine.hpp
    \brief Finite Differences Ornstein Uhlenbeck plus exponential jumps engine 
           for vanilla options
*/

#ifndef quantlib_fd_simple_ou_jump_swing_engine_hpp
#define quantlib_fd_simple_ou_jump_swing_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpmodelinnervalue.hpp>

namespace QuantLib {

    class YieldTermStructure;
    class ExtOUWithJumpsProcess;

    class FdExtOUJumpVanillaEngine
        : public GenericEngine<VanillaOption::arguments,
                               VanillaOption::results> {
      public:
        typedef FdmExtOUJumpModelInnerValue::Shape Shape;
        FdExtOUJumpVanillaEngine(ext::shared_ptr<ExtOUWithJumpsProcess> p,
                                 ext::shared_ptr<YieldTermStructure> rTS,
                                 Size tGrid = 50,
                                 Size xGrid = 200,
                                 Size yGrid = 50,
                                 ext::shared_ptr<Shape> shape = ext::shared_ptr<Shape>(),
                                 const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

        void calculate() const override;

      private:
        const ext::shared_ptr<ExtOUWithJumpsProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const ext::shared_ptr<Shape> shape_;
        const Size tGrid_, xGrid_, yGrid_;
        const FdmSchemeDesc schemeDesc_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="4">
    <source>fdklugeextouspreadengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdklugeextouspreadengine.hpp
    \brief FD Kluge/extended Ornstein-Uhlenbeck engine
           for a simple power-gas spread option
*/

#ifndef quantlib_fd_kluge_extou_spread_engine_hpp
#define quantlib_fd_kluge_extou_spread_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpmodelinnervalue.hpp>
#include <ql/experimental/finitedifferences/fdmexpextouinnervaluecalculator.hpp>
#include <ql/experimental/processes/klugeextouprocess.hpp>

namespace QuantLib {

    class YieldTermStructure;
    class ExtOUWithJumpsProcess;
    class ExtendedOrnsteinUhlenbeckProcess;

    class FdKlugeExtOUSpreadEngine
        : public GenericEngine<VanillaOption::arguments,
                               VanillaOption::results> {
      public:
          typedef FdmExtOUJumpModelInnerValue::Shape GasShape;
          typedef FdmExtOUJumpModelInnerValue::Shape PowerShape;

          FdKlugeExtOUSpreadEngine(
              ext::shared_ptr<KlugeExtOUProcess> klugeOUProcess,
              ext::shared_ptr<YieldTermStructure> rTS,
              Size tGrid = 25,
              Size xGrid = 50,
              Size yGrid = 10,
              Size uGrid = 25,
              ext::shared_ptr<GasShape> gasShape = ext::shared_ptr<GasShape>(),
              ext::shared_ptr<PowerShape> powerShape = ext::shared_ptr<PowerShape>(),
              const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

          void calculate() const override;

        private:
          const ext::shared_ptr<KlugeExtOUProcess> klugeOUProcess_;
          const ext::shared_ptr<YieldTermStructure> rTS_;
          const Size tGrid_, xGrid_, yGrid_, uGrid_;
          const ext::shared_ptr<GasShape> gasShape_;
          const ext::shared_ptr<PowerShape> powerShape_;
          const FdmSchemeDesc schemeDesc_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="5">
    <source>fdmdupire1dop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmdupire1dop.hpp
    \brief Dupire local volatility pricing operator
        Note that time is reversed in order to make backward solvers work
*/

#ifndef quantlib_fdm_dupire1d_op_hpp
#define quantlib_fdm_dupire1d_op_hpp

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>

namespace QuantLib {

class FdmDupire1dOp : public FdmLinearOpComposite {
  public:
    FdmDupire1dOp(const ext::shared_ptr<FdmMesher> &mesher,
                  const Array &localVolatility);

    Size size() const override;
    void setTime(Time t1, Time t2) override;

    Array apply(const Array& r) const override;
    Array apply_mixed(const Array& r) const override;

    Array apply_direction(Size direction, const Array& r) const override;
    Array solve_splitting(Size direction, const Array& r, Real s) const override;
    Array preconditioner(const Array& r, Real s) const override;

    std::vector<SparseMatrix> toMatrixDecomp() const override;

  private:
    const ext::shared_ptr<FdmMesher> mesher_;
    const Array localVolatility_;
    TripleBandLinearOp mapT_;
};
}

#endif
]]></document_content>
  </document>
  <document index="6">
    <source>fdmexpextouinnervaluecalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmexpextouinnervaluecalculator.hpp
    \brief inner value calculator for an exponential extended
           Ornstein Uhlenbeck grid
*/

#ifndef quantlib_fdm_exp_ext_ou_inner_value_calculator_hpp
#define quantlib_fdm_exp_ext_ou_inner_value_calculator_hpp

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/payoff.hpp>
#include <utility>

namespace QuantLib {

    class FdmExpExtOUInnerValueCalculator : public FdmInnerValueCalculator {
      public:
        typedef std::vector<std::pair<Time, Real> > Shape;

        FdmExpExtOUInnerValueCalculator(ext::shared_ptr<Payoff> payoff,
                                        ext::shared_ptr<FdmMesher> mesher,
                                        ext::shared_ptr<Shape> shape = ext::shared_ptr<Shape>(),
                                        Size direction = 0)
        : direction_(direction), payoff_(std::move(payoff)), mesher_(std::move(mesher)),
          shape_(std::move(shape)) {}

        Real innerValue(const FdmLinearOpIterator& iter, Time t) override {
            const Real u = mesher_->location(iter, direction_);

            Real f = 0;
            if (shape_ != nullptr) {
                f = std::lower_bound(shape_->begin(), shape_->end(),
                   std::pair<Time, Real>(t-std::sqrt(QL_EPSILON), 0.0))->second;
            }

            return (*payoff_)(std::exp(f + u));
        }
        Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override {
            return innerValue(iter, t);
        }

      private:
        const Size direction_;
        const ext::shared_ptr<Payoff> payoff_;
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<Shape> shape_;
    };

}
#endif
]]></document_content>
  </document>
  <document index="7">
    <source>fdmextendedornsteinuhlenbeckop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmextendedornsteinuhlenbeckop.hpp
    \brief Ornstein Uhlenbeck process plus jumps (Kluge Model)
*/

#ifndef quantlib_fdm_extended_ornsteinuhlenback_op_hpp
#define quantlib_fdm_extended_ornsteinuhlenback_op_hpp

#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmboundaryconditionset.hpp>


namespace QuantLib {

    class FdmMesher;
    class YieldTermStructure;
    class ExtendedOrnsteinUhlenbeckProcess;

    class FdmExtendedOrnsteinUhlenbeckOp : public FdmLinearOpComposite {
      public:
        FdmExtendedOrnsteinUhlenbeckOp(const ext::shared_ptr<FdmMesher>& mesher,
                                       ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> p,
                                       ext::shared_ptr<YieldTermStructure> rTS,
                                       FdmBoundaryConditionSet bcSet,
                                       Size direction = 0);

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Array apply(const Array& r) const override;
        Array apply_mixed(const Array& r) const override;

        Array apply_direction(Size direction, const Array& r) const override;
        Array solve_splitting(Size direction, const Array& r, Real s) const override;
        Array preconditioner(const Array& r, Real s) const override;

        std::vector<SparseMatrix> toMatrixDecomp() const override;

      private:
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const FdmBoundaryConditionSet bcSet_;
        const Size direction_;

        const Array x_;
        const FirstDerivativeOp dxMap_;
        const TripleBandLinearOp dxxMap_;
        TripleBandLinearOp mapX_;

    };

}
#endif
]]></document_content>
  </document>
  <document index="8">
    <source>fdmextoujumpmodelinnervalue.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmextoujumpmodelinnervalue.hpp
    \brief inner value calculator for the Ornstein Uhlenbeck
           plus exponential jumps model (Kluge Model)
*/

#ifndef quantlib_fdm_ext_ou_jump_model_inner_value_hpp
#define quantlib_fdm_ext_ou_jump_model_inner_value_hpp

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopiterator.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/payoff.hpp>
#include <utility>

namespace QuantLib {

    class FdmExtOUJumpModelInnerValue : public FdmInnerValueCalculator {
      public:
        typedef std::vector<std::pair<Time, Real> > Shape;

        FdmExtOUJumpModelInnerValue(ext::shared_ptr<Payoff> payoff,
                                    ext::shared_ptr<FdmMesher> mesher,
                                    ext::shared_ptr<Shape> shape = ext::shared_ptr<Shape>())
        : payoff_(std::move(payoff)), mesher_(std::move(mesher)), shape_(std::move(shape)) {}

        Real innerValue(const FdmLinearOpIterator& iter, Time t) override {
            const Real x = mesher_->location(iter, 0);
            const Real y = mesher_->location(iter, 1);

            Real f = 0;
            if (shape_ != nullptr) {
                f = std::lower_bound(shape_->begin(), shape_->end(),
                   std::pair<Time, Real>(t-std::sqrt(QL_EPSILON), 0.0))->second;
            }
            return (*payoff_)(std::exp(f + x + y));
        }
        Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override {
            return innerValue(iter, t);
        }

      private:
        const ext::shared_ptr<Payoff> payoff_;
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<Shape> shape_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="9">
    <source>fdmextoujumpop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmextoujumpop.hpp
    \brief Ornstein Uhlenbeck process plus jumps (Kluge Model)
*/

#ifndef quantlib_fdm_ext_ou_jump_op_hpp
#define quantlib_fdm_ext_ou_jump_op_hpp

#include <ql/math/matrixutilities/sparsematrix.hpp>
#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmboundaryconditionset.hpp>

namespace QuantLib {
    
    class FdmMesher;
    class YieldTermStructure;
    class LinearInterpolation;
    class ExtOUWithJumpsProcess;
    class FdmExtendedOrnsteinUhlenbeckOp;
    
    /*! References:
        Kluge, Timo L., 2008. Pricing Swing Options and other 
        Electricity Derivatives, http://eprints.maths.ox.ac.uk/246/1/kluge.pdf
    */

    class FdmExtOUJumpOp : public FdmLinearOpComposite {
      public:
        FdmExtOUJumpOp(const ext::shared_ptr<FdmMesher>& mesher,
                       const ext::shared_ptr<ExtOUWithJumpsProcess>& process,
                       const ext::shared_ptr<YieldTermStructure>& rTS,
                       const FdmBoundaryConditionSet& bcSet,
                       Size integroIntegrationOrder);

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Array apply(const Array& r) const override;
        Array apply_mixed(const Array& r) const override;

        Array apply_direction(Size direction, const Array& r) const override;
        Array solve_splitting(Size direction, const Array& r, Real s) const override;
        Array preconditioner(const Array& r, Real s) const override;

        std::vector<SparseMatrix> toMatrixDecomp() const override;
      private:
        Array integro(const Array& r) const;

        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<ExtOUWithJumpsProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const FdmBoundaryConditionSet bcSet_;
        GaussLaguerreIntegration gaussLaguerreIntegration_;

        const Array x_;
        const ext::shared_ptr<FdmExtendedOrnsteinUhlenbeckOp> ouOp_;

        const TripleBandLinearOp dyMap_;

        SparseMatrix integroPart_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="10">
    <source>fdmextoujumpsolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmextoujumpsolver.hpp
*/

#ifndef quantlib_fdm_ext_ou_jump_solver_hpp
#define quantlib_fdm_ext_ou_jump_solver_hpp

#include <ql/handle.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    class Fdm2DimSolver;
    class ExtOUWithJumpsProcess;
    class YieldTermStructure;

    class FdmExtOUJumpSolver : public LazyObject {
      public:
        FdmExtOUJumpSolver(Handle<ExtOUWithJumpsProcess> process,
                           ext::shared_ptr<YieldTermStructure> rTS,
                           FdmSolverDesc solverDesc,
                           const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

        Real valueAt(Real x, Real y) const;
        
      protected:
        void performCalculations() const override;

      private:
        const Handle<ExtOUWithJumpsProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;

        mutable ext::shared_ptr<Fdm2DimSolver> solver_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="11">
    <source>fdmklugeextouop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmklugeextouop.hpp
    \brief Kluge process (power) plus Ornstein Uhlenbeck process (gas)
*/

#ifndef quantlib_fdm_kluge_ext_ou_op_hpp
#define quantlib_fdm_kluge_ext_ou_op_hpp

#include <ql/methods/finitedifferences/operators/ninepointlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmboundaryconditionset.hpp>


namespace QuantLib {

    class FdmMesher;
    class YieldTermStructure;
    class KlugeExtOUProcess;
    class ExtOUWithJumpsProcess;
    class FdmExtOUJumpOp;
    class FdmExtendedOrnsteinUhlenbeckOp;
    class ExtendedOrnsteinUhlenbeckProcess;

    /*! This class describes a correlated Kluge - extended Ornstein-Uhlenbeck
        process governed by
        \f[
        \begin{array}{rcl}
            P_t &=& \exp(p_t + X_t + Y_t) \\
            dX_t &=& -\alpha X_tdt + \sigma_x dW_t^x \\
            dY_t &=& -\beta Y_{t-}dt + J_tdN_t \\
            \omega(J) &=& \eta e^{-\eta J} \\
            G_t &=& \exp(g_t + U_t) \\
            dU_t &=& -\kappa U_tdt + \sigma_udW_t^u \\
            \rho &=& \mathrm{corr} (dW_t^x, dW_t^u)
         \end{array}
         \f]
    */

    /*! References:
        Kluge, Timo L., 2008. Pricing Swing Options and other
        Electricity Derivatives, http://eprints.maths.ox.ac.uk/246/1/kluge.pdf

        http://spanderen.de/2011/06/13/vpp-pricing-i-stochastic-processes-partial-integro-differential-equation/
    */

    class FdmKlugeExtOUOp : public FdmLinearOpComposite {
      public:
        FdmKlugeExtOUOp(
            const ext::shared_ptr<FdmMesher>& mesher,
            const ext::shared_ptr<KlugeExtOUProcess>& klugeOUProcess,
            const ext::shared_ptr<YieldTermStructure>& rTS,
            const FdmBoundaryConditionSet& bcSet,
            Size integroIntegrationOrder);

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Array apply(const Array& r) const override;
        Array apply_mixed(const Array& r) const override;

        Array apply_direction(Size direction, const Array& r) const override;
        Array solve_splitting(Size direction, const Array& r, Real s) const override;
        Array preconditioner(const Array& r, Real s) const override;

        std::vector<SparseMatrix> toMatrixDecomp() const override;

      private:

        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<ExtOUWithJumpsProcess> kluge_;
        const ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> extOU_;

        const ext::shared_ptr<YieldTermStructure> rTS_;
        const FdmBoundaryConditionSet bcSet_;

        const ext::shared_ptr<FdmExtOUJumpOp> klugeOp_;
        const ext::shared_ptr<FdmExtendedOrnsteinUhlenbeckOp> ouOp_;

        const NinePointLinearOp corrMap_;
    };
}
#endif
]]></document_content>
  </document>
  <document index="12">
    <source>fdmklugeextousolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmklugeextousolver.hpp
    \brief Kluge/extended Ornstein-Uhlenbeck FDM solver
*/

#ifndef quantlib_fdm_kluge_ou_solver_hpp
#define quantlib_fdm_kluge_ou_solver_hpp

#include <ql/experimental/finitedifferences/fdmklugeextouop.hpp>
#include <ql/experimental/processes/klugeextouprocess.hpp>
#include <ql/handle.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmndimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <utility>

namespace QuantLib {

    class ExtOUWithJumpsProcess;
    class ExtendedOrnsteinUhlenbeckProcess;

    template <Size N=3>
    class FdmKlugeExtOUSolver : public LazyObject {
      public:
        FdmKlugeExtOUSolver(Handle<KlugeExtOUProcess> klugeOUProcess,
                            ext::shared_ptr<YieldTermStructure> rTS,
                            FdmSolverDesc solverDesc,
                            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer())
        : klugeOUProcess_(std::move(klugeOUProcess)), rTS_(std::move(rTS)),
          solverDesc_(std::move(solverDesc)), schemeDesc_(schemeDesc) {
            registerWith(klugeOUProcess_);
        }

        Real valueAt(const std::vector<Real>& x) const {
            calculate();
            return solver_->interpolateAt(x);
        }

      protected:
        void performCalculations() const override {
            ext::shared_ptr<FdmLinearOpComposite>op(
                new FdmKlugeExtOUOp(solverDesc_.mesher,
                                    klugeOUProcess_.currentLink(),
                                    rTS_, solverDesc_.bcSet, 16));

            solver_ = ext::shared_ptr<FdmNdimSolver<N> >(
                          new FdmNdimSolver<N>(solverDesc_, schemeDesc_, op));
        }

      private:
        const Handle<KlugeExtOUProcess> klugeOUProcess_;
        const ext::shared_ptr<YieldTermStructure> rTS_;

        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;

        mutable ext::shared_ptr<FdmNdimSolver<N> > solver_;
        BOOST_STATIC_ASSERT(N >= 3); // NOLINT(readability-simplify-boolean-expr)
                                     // KlugeExtOU solver can't be applied on meshes
                                     // with less than three dimensions
    };
}

#endif
]]></document_content>
  </document>
  <document index="13">
    <source>fdmsimple2dextousolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmsimple2dextousolver.hpp
    \brief solver for simple swing options based on ext OU process
*/


#ifndef quantlib_fdm_2d_ext_ou_solver_hpp
#define quantlib_fdm_2d_ext_ou_solver_hpp

#include <ql/experimental/finitedifferences/fdmextendedornsteinuhlenbeckop.hpp>
#include <ql/experimental/processes/extendedornsteinuhlenbeckprocess.hpp>
#include <ql/handle.hpp>
#include <ql/methods/finitedifferences/solvers/fdm2dimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    class FdmSimple2dExtOUSolver : public LazyObject {
      public:
        FdmSimple2dExtOUSolver(const Handle<ExtendedOrnsteinUhlenbeckProcess>& process,
                               ext::shared_ptr<YieldTermStructure> rTS,
                               FdmSolverDesc solverDesc,
                               const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer())
        : process_(process), rTS_(std::move(rTS)), solverDesc_(std::move(solverDesc)),
          schemeDesc_(schemeDesc) {
            registerWith(process);
        }

        Real valueAt(Real x, Real y) const {
            calculate();
            return solver_->interpolateAt(x, y);
        }

      protected:
        void performCalculations() const override {
            ext::shared_ptr<FdmLinearOpComposite>op(
                new FdmExtendedOrnsteinUhlenbeckOp(
                                solverDesc_.mesher, process_.currentLink(),
                                rTS_, solverDesc_.bcSet));

            solver_ = ext::make_shared<Fdm2DimSolver>(
                          solverDesc_, schemeDesc_, op);
        }

      private:
        const Handle<ExtendedOrnsteinUhlenbeckProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;

        mutable ext::shared_ptr<Fdm2DimSolver> solver_;
    };
}

#endif

]]></document_content>
  </document>
  <document index="14">
    <source>fdmsimple3dextoujumpsolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmsimple3dextoujumpsolver.hpp
    \brief solver for simple swing options based on ext OU-Jump (Kluge) Model
*/


#ifndef quantlib_fdm_3d_ext_ou_jump_solver_hpp
#define quantlib_fdm_3d_ext_ou_jump_solver_hpp

#include <ql/experimental/finitedifferences/fdmextoujumpop.hpp>
#include <ql/experimental/processes/extouwithjumpsprocess.hpp>
#include <ql/handle.hpp>
#include <ql/methods/finitedifferences/solvers/fdm3dimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    class FdmSimple3dExtOUJumpSolver : public LazyObject {
      public:
        FdmSimple3dExtOUJumpSolver(const Handle<ExtOUWithJumpsProcess>& process,
                                   ext::shared_ptr<YieldTermStructure> rTS,
                                   FdmSolverDesc solverDesc,
                                   const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer())
        : process_(process), rTS_(std::move(rTS)), solverDesc_(std::move(solverDesc)),
          schemeDesc_(schemeDesc) {
            registerWith(process);
        }

        Real valueAt(Real x, Real y, Real z) const {
            calculate();
            return solver_->interpolateAt(x, y, z);
        }

      protected:
        void performCalculations() const override {
            ext::shared_ptr<FdmLinearOpComposite>op(
                new FdmExtOUJumpOp(solverDesc_.mesher,
                                   process_.currentLink(),
                                   rTS_, solverDesc_.bcSet, 32));

            solver_ = ext::make_shared<Fdm3DimSolver>(
                          solverDesc_, schemeDesc_, op);
        }

      private:
        const Handle<ExtOUWithJumpsProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;

        mutable ext::shared_ptr<Fdm3DimSolver> solver_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="15">
    <source>fdmspreadpayoffinnervalue.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmspreadpayoffinnervalue.hpp
    \brief inner value calculator for a spread payoff
*/

#ifndef quantlib_fdm_spread_payoff_inner_value_hpp
#define quantlib_fdm_spread_payoff_inner_value_hpp

#include <ql/instruments/basketoption.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <utility>

namespace QuantLib {

    class FdmSpreadPayoffInnerValue : public FdmInnerValueCalculator {
      public:
        FdmSpreadPayoffInnerValue(ext::shared_ptr<BasketPayoff> payoff,
                                  ext::shared_ptr<FdmInnerValueCalculator> calc1,
                                  ext::shared_ptr<FdmInnerValueCalculator> calc2)
        : payoff_(std::move(payoff)), calc1_(std::move(calc1)), calc2_(std::move(calc2)) {}

        Real innerValue(const FdmLinearOpIterator& iter, Time t) override {
            Array a(2);
            a[0] = calc1_->innerValue(iter, t);
            a[1] = calc2_->innerValue(iter, t);

            return (*payoff_)(a);
        }
        Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override {
            return innerValue(iter, t);
        }

      private:
        const ext::shared_ptr<BasketPayoff> payoff_;
        const ext::shared_ptr<FdmInnerValueCalculator> calc1_;
        const ext::shared_ptr<FdmInnerValueCalculator> calc2_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="16">
    <source>fdmvppstartlimitstepcondition.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011, 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmvppstartlimitstepcondition.hpp
    \brief VPP incl start limit step condition for FD models
*/

#ifndef quantlib_fdm_vpp_start_limit_step_condition_hpp
#define quantlib_fdm_vpp_start_limit_step_condition_hpp

#include <ql/experimental/finitedifferences/fdmvppstepcondition.hpp>
#include <ql/shared_ptr.hpp>
#include <vector>

namespace QuantLib {

    class FdmVPPStartLimitStepCondition : public FdmVPPStepCondition {
      public:
        FdmVPPStartLimitStepCondition(
            const FdmVPPStepConditionParams& params,
            Size nStarts,
            const FdmVPPStepConditionMesher& mesh,
            const ext::shared_ptr<FdmInnerValueCalculator>& gasPrice,
            const ext::shared_ptr<FdmInnerValueCalculator>& sparkSpreadPrice);

        static Size nStates(Size tMinUp, Size tMinDown, Size nStarts);
        Real maxValue(const Array& states) const override;

      private:
        Array changeState(Real gasPrice, const Array& state, Time t) const override;

        const Size nStarts_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="17">
    <source>fdmvppstepcondition.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011, 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmvppstepcondition.hpp
    \brief VPP step condition for FD models
*/

#ifndef quantlib_fdm_vpp_step_condition_hpp
#define quantlib_fdm_vpp_step_condition_hpp

#include <ql/methods/finitedifferences/stepcondition.hpp>
#include <ql/shared_ptr.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <functional>
#include <vector>

namespace QuantLib {
    class FdmMesher;
    class FdmLinearOpIterator;
    class FdmInnerValueCalculator;

    struct FdmVPPStepConditionParams {
        Real heatRate;
        Real pMin; Real pMax;
        Size tMinUp; Size tMinDown;
        Real startUpFuel; Real startUpFixCost;
        Real fuelCostAddon;
    };

    struct FdmVPPStepConditionMesher {
        Size stateDirection;
        ext::shared_ptr<FdmMesher> mesher;
    };

    class FdmVPPStepCondition : public StepCondition<Array> {
      public:
        FdmVPPStepCondition(const FdmVPPStepConditionParams& params,
                            Size nStates,
                            const FdmVPPStepConditionMesher& mesh,
                            ext::shared_ptr<FdmInnerValueCalculator> gasPrice,
                            ext::shared_ptr<FdmInnerValueCalculator> sparkSpreadPrice);

        Size nStates() const;
        void applyTo(Array& a, Time t) const override;

        virtual Real maxValue(const Array& states) const = 0;

      protected:
        Real evolveAtPMin(Real sparkSpread) const;
        Real evolveAtPMax(Real sparkSpread) const;

        Real evolve(const FdmLinearOpIterator& iter, Time t) const;

        virtual Array changeState(Real gasPrice, const Array& state, Time t) const = 0;

        const Real heatRate_;
        const Real pMin_, pMax_;
        const Size tMinUp_, tMinDown_;
        const Real startUpFuel_, startUpFixCost_;
        const Real fuelCostAddon_;
        const Size stateDirection_;
        const Size nStates_;

        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<FdmInnerValueCalculator> gasPrice_;
        const ext::shared_ptr<FdmInnerValueCalculator> sparkSpreadPrice_;

        std::vector<std::function<Real (Real)> > stateEvolveFcts_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="18">
    <source>fdmvppstepconditionfactory.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmvppstepconditionfactory.hpp
    \brief factory for VPP step conditions for FD models
*/

#ifndef quantlib_fdm_vpp_step_condition_factory_hpp
#define quantlib_fdm_vpp_step_condition_factory_hpp

#include <ql/math/array.hpp>
#include <ql/methods/finitedifferences/stepcondition.hpp>
#include <ql/experimental/finitedifferences/vanillavppoption.hpp>
#include <ql/experimental/finitedifferences/fdmvppstepcondition.hpp>

namespace QuantLib {
    class Fdm1dMesher;

    class FdmVPPStepConditionFactory {
      public:
        explicit FdmVPPStepConditionFactory(VanillaVPPOption::arguments args);

        ext::shared_ptr<Fdm1dMesher> stateMesher() const;
        ext::shared_ptr<FdmVPPStepCondition> build(
            const FdmVPPStepConditionMesher& mesh,
            Real fuelCostAddon,
            const ext::shared_ptr<FdmInnerValueCalculator>& fuel,
            const ext::shared_ptr<FdmInnerValueCalculator>& spark) const;

      private:
        enum Type { Vanilla, StartLimit, RunningHourLimit } type_;

        const VanillaVPPOption::arguments args_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="19">
    <source>fdmzabrop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmzabrop.hpp
    \brief Zabr linear pricing operator
*/

#ifndef quantlib_fdm_zabr_op_hpp
#define quantlib_fdm_zabr_op_hpp

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/ninepointlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>

namespace QuantLib {

class FdmZabrUnderlyingPart {
  public:
    FdmZabrUnderlyingPart(
        const ext::shared_ptr<FdmMesher>& mesher, Real beta, Real nu, Real rho, Real gamma);

    void setTime(Time t1, Time t2);
    const TripleBandLinearOp &getMap() const;

  protected:
    const Array volatilityValues_;
    const Array forwardValues_;
    TripleBandLinearOp mapT_;

    const ext::shared_ptr<FdmMesher> mesher_;
};

class FdmZabrVolatilityPart {
  public:
    FdmZabrVolatilityPart(
        const ext::shared_ptr<FdmMesher>& mesher, Real beta, Real nu, Real rho, Real gamma);

    void setTime(Time t1, Time t2);
    const TripleBandLinearOp &getMap() const;

  protected:
    const Array volatilityValues_;
    const Array forwardValues_;
    TripleBandLinearOp mapT_;

    const ext::shared_ptr<FdmMesher> mesher_;
};

class FdmZabrOp : public FdmLinearOpComposite {
  public:
    FdmZabrOp(const ext::shared_ptr<FdmMesher>& mesher,
              Real beta,
              Real nu,
              Real rho,
              Real gamma = 1.0); // gamma=1.0 recovers the classic sabr model

    Size size() const override;
    void setTime(Time t1, Time t2) override;

    Array apply(const Array& r) const override;
    Array apply_mixed(const Array& r) const override;

    Array apply_direction(Size direction, const Array& r) const override;
    Array solve_splitting(Size direction, const Array& r, Real s) const override;
    Array preconditioner(const Array& r, Real s) const override;

    std::vector<SparseMatrix> toMatrixDecomp() const override;

  private:
    const Array volatilityValues_;
    const Array forwardValues_;
    NinePointLinearOp dxyMap_;
    FdmZabrUnderlyingPart dxMap_;
    FdmZabrVolatilityPart dyMap_;
};
}

#endif
]]></document_content>
  </document>
  <document index="20">
    <source>fdornsteinuhlenbeckvanillaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdornsteinuhlenbeckvanillaengine.hpp
    \brief Finite-Differences Ornstein Uhlenbeck vanilla option engine
*/

#ifndef quantlib_fd_ornstein_uhlenbeck_vanilla_engine_hpp
#define quantlib_fd_ornstein_uhlenbeck_vanilla_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    class YieldTermStructure;
    class OrnsteinUhlenbeckProcess;

    class FdOrnsteinUhlenbeckVanillaEngine : public VanillaOption::engine {
      public:
        FdOrnsteinUhlenbeckVanillaEngine(
            ext::shared_ptr<OrnsteinUhlenbeckProcess>,
            const ext::shared_ptr<YieldTermStructure>& rTS,
            Size tGrid = 100,
            Size xGrid = 100,
            Size dampingSteps = 0,
            Real epsilon = 0.0001,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas());

        FdOrnsteinUhlenbeckVanillaEngine(
            ext::shared_ptr<OrnsteinUhlenbeckProcess>,
            const ext::shared_ptr<YieldTermStructure>& rTS,
            DividendSchedule dividends,
            Size tGrid = 100,
            Size xGrid = 100,
            Size dampingSteps = 0,
            Real epsilon = 0.0001,
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas());

        void calculate() const override;

      private:
        const ext::shared_ptr<OrnsteinUhlenbeckProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        DividendSchedule dividends_;
        const Size tGrid_, xGrid_, dampingSteps_;
        const Real epsilon_;
        const FdmSchemeDesc schemeDesc_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="21">
    <source>fdsimpleextoujumpswingengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdsimpleextoujumpswingengine.hpp
    \brief Finite Differences engine for simple swing options
*/

#ifndef quantlib_fd_simple_ext_ou_jump_swing_engine_hpp
#define quantlib_fd_simple_ext_ou_jump_swing_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/instruments/vanillaswingoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpmodelinnervalue.hpp>

namespace QuantLib {

    //! Finite-Differences engine for simple swing options

    class YieldTermStructure;
    class ExtOUWithJumpsProcess;

    class FdSimpleExtOUJumpSwingEngine
        : public GenericEngine<VanillaSwingOption::arguments,
                               VanillaSwingOption::results> {
      public:
        typedef FdmExtOUJumpModelInnerValue::Shape Shape;

        FdSimpleExtOUJumpSwingEngine(
            ext::shared_ptr<ExtOUWithJumpsProcess> p,
            ext::shared_ptr<YieldTermStructure> rTS,
            Size tGrid = 50,
            Size xGrid = 200,
            Size yGrid = 50,
            ext::shared_ptr<Shape> shape = ext::shared_ptr<Shape>(),
            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

        void calculate() const override;

      private:
        const ext::shared_ptr<ExtOUWithJumpsProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const ext::shared_ptr<Shape> shape_;
        const Size tGrid_, xGrid_, yGrid_;
        const FdmSchemeDesc schemeDesc_;
    };
}

#endif

]]></document_content>
  </document>
  <document index="22">
    <source>fdsimpleextoustorageengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen
 Copyright (C) 2014 Ralph Schreyer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdsimpleextoustorageengine.hpp
    \brief Finite Differences extended OU engine for simple storage options
*/

#ifndef quantlib_fd_simple_ext_ou_storage_engine_hpp
#define quantlib_fd_simple_ext_ou_storage_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/instruments/vanillastorageoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    class ExtendedOrnsteinUhlenbeckProcess;
    class YieldTermStructure;

    class FdSimpleExtOUStorageEngine
        : public GenericEngine<VanillaStorageOption::arguments,
                               VanillaStorageOption::results> {
      public:
        typedef std::vector<std::pair<Time, Real> > Shape;


        FdSimpleExtOUStorageEngine(ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> p,
                                   ext::shared_ptr<YieldTermStructure> rTS,
                                   Size tGrid = 50,
                                   Size xGrid = 100,
                                   Size yGrid = Null<Size>(),
                                   ext::shared_ptr<Shape> shape = ext::shared_ptr<Shape>(),
                                   const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas());

        void calculate() const override;

      private:
        const ext::shared_ptr<ExtendedOrnsteinUhlenbeckProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const Size tGrid_, xGrid_, yGrid_;
        const ext::shared_ptr<Shape> shape_;
        const FdmSchemeDesc schemeDesc_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="23">
    <source>fdsimpleklugeextouvppengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011, 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdsimpleklugeextouvppengine.hpp
    \brief Finite Differences engine for simple vpp options
*/

#ifndef quantlib_fd_simple_kluge_ou_vpp_engine_hpp
#define quantlib_fd_simple_kluge_ou_vpp_engine_hpp

#include <ql/pricingengine.hpp>
#include <ql/experimental/finitedifferences/vanillavppoption.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/experimental/finitedifferences/fdmextoujumpmodelinnervalue.hpp>

namespace QuantLib {

    //! Finite-Differences engine for simple vpp options

    class YieldTermStructure;
    class KlugeExtOUProcess;

    class FdSimpleKlugeExtOUVPPEngine
        : public GenericEngine<VanillaVPPOption::arguments,
                               VanillaVPPOption::results> {
      public:
        typedef FdmExtOUJumpModelInnerValue::Shape Shape;

        FdSimpleKlugeExtOUVPPEngine(ext::shared_ptr<KlugeExtOUProcess> process,
                                    ext::shared_ptr<YieldTermStructure> rTS,
                                    ext::shared_ptr<Shape> fuelShape,
                                    ext::shared_ptr<Shape> powerShape,
                                    Real fuelCostAddon,
                                    Size tGrid = 1,
                                    Size xGrid = 50,
                                    Size yGrid = 10,
                                    Size gGrid = 20,
                                    const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

        void calculate() const override;

      private:
        const ext::shared_ptr<KlugeExtOUProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const Real fuelCostAddon_;
        const ext::shared_ptr<Shape> fuelShape_;
        const ext::shared_ptr<Shape> powerShape_;
        const Size tGrid_, xGrid_, yGrid_, gGrid_;
        const FdmSchemeDesc schemeDesc_;
    };
}

#endif

]]></document_content>
  </document>
  <document index="24">
    <source>glued1dmesher.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file glued1dmesher.hpp
    \brief One-dimensional grid mesher combining two existing ones
*/

#ifndef quantlib_glued_1d_mesher_hpp
#define quantlib_glued_1d_mesher_hpp

#include <ql/methods/finitedifferences/meshers/fdm1dmesher.hpp>

namespace QuantLib {

    class Glued1dMesher : public Fdm1dMesher {
      public:
        Glued1dMesher(
            const Fdm1dMesher& leftMesher,
            const Fdm1dMesher& rightMesher);
      private:
          const bool commonPoint_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="25">
    <source>vanillavppoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <https://www.quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vanillavppoption.hpp
    \brief vanilla virtual power plant option
*/

#ifndef quantlib_vanilla_vpp_option_hpp
#define quantlib_vanilla_vpp_option_hpp

#include <ql/instruments/multiassetoption.hpp>

namespace QuantLib {
    class BasketPayoff;
    class SwingExercise;

    class VanillaVPPOption : public MultiAssetOption {
      public:
        class arguments;
        VanillaVPPOption(Real heatRate,
                         Real pMin, Real pMax,
                         Size tMinUp, Size tMinDown,
                         Real startUpFuel, Real startUpFixCost,
                         const ext::shared_ptr<SwingExercise>& exercise,
                         Size nStarts = Null<Size>(),
                         Size nRunningHours = Null<Size>());

        bool isExpired() const override;
        void setupArguments(PricingEngine::arguments*) const override;

      private:
        const Real heatRate_;
        const Real pMin_, pMax_;
        const Size tMinUp_, tMinDown_;
        const Real startUpFuel_, startUpFixCost_;
        const Size nStarts_, nRunningHours_;
    };

    class VanillaVPPOption::arguments
        : public virtual MultiAssetOption::arguments {
      public:
        arguments() = default;
        void validate() const override;

        Real heatRate;
        Real pMin, pMax;
        Size tMinUp, tMinDown;
        Real startUpFuel, startUpFixCost;
        Size nStarts, nRunningHours;
    };
}

#endif
]]></document_content>
  </document>
</documents>