<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/methods/finitedifferences/americancondition.hpp>
#include <ql/methods/finitedifferences/boundarycondition.hpp>
#include <ql/methods/finitedifferences/bsmoperator.hpp>
#include <ql/methods/finitedifferences/bsmtermoperator.hpp>
#include <ql/methods/finitedifferences/cranknicolson.hpp>
#include <ql/methods/finitedifferences/dminus.hpp>
#include <ql/methods/finitedifferences/dplus.hpp>
#include <ql/methods/finitedifferences/dplusdminus.hpp>
#include <ql/methods/finitedifferences/dzero.hpp>
#include <ql/methods/finitedifferences/expliciteuler.hpp>
#include <ql/methods/finitedifferences/fdtypedefs.hpp>
#include <ql/methods/finitedifferences/finitedifferencemodel.hpp>
#include <ql/methods/finitedifferences/impliciteuler.hpp>
#include <ql/methods/finitedifferences/mixedscheme.hpp>
#include <ql/methods/finitedifferences/onefactoroperator.hpp>
#include <ql/methods/finitedifferences/operatortraits.hpp>
#include <ql/methods/finitedifferences/parallelevolver.hpp>
#include <ql/methods/finitedifferences/pde.hpp>
#include <ql/methods/finitedifferences/pdebsm.hpp>
#include <ql/methods/finitedifferences/pdeshortrate.hpp>
#include <ql/methods/finitedifferences/shoutcondition.hpp>
#include <ql/methods/finitedifferences/stepcondition.hpp>
#include <ql/methods/finitedifferences/trbdf2.hpp>
#include <ql/methods/finitedifferences/tridiagonaloperator.hpp>
#include <ql/methods/finitedifferences/zerocondition.hpp>

#include <ql/methods/finitedifferences/meshers/all.hpp>
#include <ql/methods/finitedifferences/operators/all.hpp>
#include <ql/methods/finitedifferences/schemes/all.hpp>
#include <ql/methods/finitedifferences/solvers/all.hpp>
#include <ql/methods/finitedifferences/stepconditions/all.hpp>
#include <ql/methods/finitedifferences/utilities/all.hpp>
]]></document_content>
  </document>
  <document index="2">
    <source>americancondition.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file americancondition.hpp
    \brief american option exercise condition
*/

#ifndef quantlib_fd_american_condition_h
#define quantlib_fd_american_condition_h

#include <ql/discretizedasset.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/methods/finitedifferences/fdtypedefs.hpp>
#include <utility>

namespace QuantLib {

    //! American exercise condition.
    /*! \deprecated Use the new finite-differences framework instead.
                    Deprecated in version 1.22.
    */
    class QL_DEPRECATED AmericanCondition : public StandardStepCondition {
      public:
        explicit AmericanCondition(const Array& intrinsicValues)
        : impl_(new ArrayImpl(intrinsicValues)) {}

        /*! \deprecated Use the other constructor.
                        Deprecated in version 1.19.
        */
        QL_DEPRECATED
        AmericanCondition(Option::Type type,
                          Real strike)
        : impl_(new PayoffImpl(type, strike)) {}

        void applyTo(Array& a, Time) const override {
            //#pragma omp parallel for
            for (Size i = 0; i < a.size(); i++) {
                a[i] = std::max(a[i], impl_->getValue(a, i));
            }
        }

      private:
        // This part should be removed and the array-based implementation
        // inlined once the payoff-based constructor is removed.

        class Impl;

        ext::shared_ptr<Impl> impl_;

        class Impl {
          public:
            virtual ~Impl() = default;
            virtual Real getValue(const Array &a,
                                  int i) = 0;
        };

        class ArrayImpl : public Impl {
          private:
            Array intrinsicValues_;
          public:
            explicit ArrayImpl(Array a) : intrinsicValues_(std::move(a)) {}

            Real getValue(const Array&, int i) override { return intrinsicValues_[i]; }
        };

        class PayoffImpl : public Impl {
          private:
            ext::shared_ptr<const Payoff> payoff_;
          public:
            PayoffImpl(Option::Type type, Real strike)
            : payoff_(new PlainVanillaPayoff(type, strike)) {};
            Real getValue(const Array& a, int i) override { return (*payoff_)(std::exp(a[i])); }
        };
    };
}


#endif
]]></document_content>
  </document>
  <document index="3">
    <source>boundarycondition.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file boundarycondition.hpp
    \brief boundary conditions for differential operators
*/

#ifndef quantlib_boundary_condition_hpp
#define quantlib_boundary_condition_hpp

#include <ql/utilities/null.hpp>
#include <ql/methods/finitedifferences/tridiagonaloperator.hpp>

namespace QuantLib {

    //! Abstract boundary condition class for finite difference problems
    /*! \ingroup findiff */
    template <class Operator>
    class BoundaryCondition {
      public:
        // types and enumerations
        typedef Operator operator_type;
        typedef typename Operator::array_type array_type;
        //! \todo Generalize for n-dimensional conditions
        enum Side { None, Upper, Lower };
        // destructor
        virtual ~BoundaryCondition() = default;
        // interface
        /*! This method modifies an operator \f$ L \f$ before it is
            applied to an array \f$ u \f$ so that \f$ v = Lu \f$ will
            satisfy the given condition. */
        virtual void applyBeforeApplying(operator_type&) const = 0;
        /*! This method modifies an array \f$ u \f$ so that it satisfies
            the given condition. */
        virtual void applyAfterApplying(array_type&) const = 0;
        /*! This method modifies an operator \f$ L \f$ before the linear
            system \f$ Lu' = u \f$ is solved so that \f$ u' \f$ will
            satisfy the given condition. */
        virtual void applyBeforeSolving(operator_type&,
                                        array_type& rhs) const = 0;
        /*! This method modifies an array \f$ u \f$ so that it satisfies
            the given condition. */
        virtual void applyAfterSolving(array_type&) const = 0;
        /*! This method sets the current time for time-dependent
            boundary conditions. */
        virtual void setTime(Time t) = 0;
    };

    // Time-independent boundary conditions for tridiagonal operators

    //! Neumann boundary condition (i.e., constant derivative)
    /*! \warning The value passed must not be the value of the derivative.
                 Instead, it must be comprehensive of the grid step
                 between the first two points--i.e., it must be the
                 difference between f[0] and f[1].
        \todo generalize to time-dependent conditions.

        \ingroup findiff
    */
    class NeumannBC : public BoundaryCondition<TridiagonalOperator> {
      public:
        NeumannBC(Real value, Side side);
        // interface
        void applyBeforeApplying(TridiagonalOperator&) const override;
        void applyAfterApplying(Array&) const override;
        void applyBeforeSolving(TridiagonalOperator&, Array& rhs) const override;
        void applyAfterSolving(Array&) const override;
        void setTime(Time) override {}

      private:
        Real value_;
        Side side_;
    };

    //! Neumann boundary condition (i.e., constant value)
    /*! \todo generalize to time-dependent conditions.

        \ingroup findiff
    */
    class DirichletBC : public BoundaryCondition<TridiagonalOperator> {
      public:
        DirichletBC(Real value, Side side);
        // interface
        void applyBeforeApplying(TridiagonalOperator&) const override;
        void applyAfterApplying(Array&) const override;
        void applyBeforeSolving(TridiagonalOperator&, Array& rhs) const override;
        void applyAfterSolving(Array&) const override;
        void setTime(Time) override {}

      private:
        Real value_;
        Side side_;
    };

}




#endif
]]></document_content>
  </document>
  <document index="4">
    <source>bsmoperator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bsmoperator.hpp
    \brief differential operator for Black-Scholes-Merton equation
*/

#ifndef quantlib_bsm_operator_hpp
#define quantlib_bsm_operator_hpp

#include <ql/methods/finitedifferences/tridiagonaloperator.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Black-Scholes-Merton differential operator
    /*! \ingroup findiff */
    class BSMOperator : public TridiagonalOperator {
      public:
        BSMOperator() = default;
        BSMOperator(Size size, Real dx, Rate r, Rate q, Volatility sigma);
        BSMOperator(const Array& grid, Rate r, Rate q, Volatility sigma);
    };

}


#endif
]]></document_content>
  </document>
  <document index="5">
    <source>bsmtermoperator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bsmtermoperator.hpp
    \brief differential operator for Black-Scholes-Merton equation
*/

#ifndef quantlib_bsm_term_operator_hpp
#define quantlib_bsm_term_operator_hpp

#include <ql/methods/finitedifferences/tridiagonaloperator.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/math/transformedgrid.hpp>
#include <ql/methods/finitedifferences/pdebsm.hpp>

namespace QuantLib {

    //! Black-Scholes-Merton differential operator
    /*! \ingroup findiff

        \test coefficients are tested against constant BSM operator
    */
    typedef PdeOperator<PdeBSM> BSMTermOperator;
}


#endif
]]></document_content>
  </document>
  <document index="6">
    <source>cranknicolson.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cranknicolson.hpp
    \brief Crank-Nicolson scheme for finite difference methods
*/

#ifndef quantlib_crank_nicolson_hpp
#define quantlib_crank_nicolson_hpp

#include <ql/methods/finitedifferences/mixedscheme.hpp>

namespace QuantLib {

    //! Crank-Nicolson scheme for finite difference methods
    /*! In this implementation, the passed operator must be derived
        from either TimeConstantOperator or TimeDependentOperator.
        Also, it must implement at least the following interface:

        \code
        typedef ... array_type;

        // copy constructor/assignment
        // (these will be provided by the compiler if none is defined)
        Operator(const Operator&);
        Operator& operator=(const Operator&);

        // inspectors
        Size size();

        // modifiers
        void setTime(Time t);

        // operator interface
        array_type applyTo(const array_type&);
        array_type solveFor(const array_type&);
        static Operator identity(Size size);

        // operator algebra
        Operator operator*(Real, const Operator&);
        Operator operator+(const Operator&, const Operator&);
        Operator operator+(const Operator&, const Operator&);
        \endcode

        \warning The differential operator must be linear for
                 this evolver to work.

        \ingroup findiff
    */
    template <class Operator>
    class CrankNicolson : public MixedScheme<Operator> {
      public:
        // typedefs
        typedef OperatorTraits<Operator> traits;
        typedef typename traits::operator_type operator_type;
        typedef typename traits::array_type array_type;
        typedef typename traits::bc_set bc_set;
        typedef typename traits::condition_type condition_type;
        // constructors
        CrankNicolson(const operator_type& L,
                      const bc_set& bcs)
        : MixedScheme<Operator>(L, 0.5, bcs) {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="7">
    <source>dminus.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file dminus.hpp
    \brief \f$ D_{-} \f$ matricial representation
*/

#ifndef quantlib_d_minus_h
#define quantlib_d_minus_h

#include <ql/methods/finitedifferences/tridiagonaloperator.hpp>

namespace QuantLib {

    //! \f$ D_{-} \f$ matricial representation
    /*! The differential operator \f$ D_{-} \f$ discretizes the
        first derivative with the first-order formula
        \f[ \frac{\partial u_{i}}{\partial x} \approx
            \frac{u_{i}-u_{i-1}}{h} = D_{-} u_{i}
        \f]

        \ingroup findiff
    */
    class DMinus : public TridiagonalOperator {
      public:
        DMinus(Size gridPoints, Real h);
    };


    // inline definitions

    inline DMinus::DMinus(Size gridPoints, Real h)
    : TridiagonalOperator(gridPoints) {
        setFirstRow(-1/h,1/h);                  // linear extrapolation
        setMidRows(-1/h,1/h,0.0);
        setLastRow(-1/h,1/h);
    }

}


#endif
]]></document_content>
  </document>
  <document index="8">
    <source>dplus.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file dplus.hpp
    \brief \f$ D_{+} \f$ matricial representation
*/

#ifndef quantlib_d_plus_h
#define quantlib_d_plus_h

#include <ql/methods/finitedifferences/tridiagonaloperator.hpp>

namespace QuantLib {

    //! \f$ D_{+} \f$ matricial representation
    /*! The differential operator \f$ D_{+} \f$ discretizes the
        first derivative with the first-order formula
        \f[ \frac{\partial u_{i}}{\partial x} \approx
            \frac{u_{i+1}-u_{i}}{h} = D_{+} u_{i}
        \f]

        \ingroup findiff
    */
    class DPlus : public TridiagonalOperator {
      public:
        DPlus(Size gridPoints, Real h);
    };


    // inline definitions

    inline DPlus::DPlus(Size gridPoints, Real h)
    : TridiagonalOperator(gridPoints) {
        setFirstRow(-1/h,1/h);
        setMidRows(0.0,-1/h,1/h);
        setLastRow(-1/h,1/h);                   // linear extrapolation
    }

}


#endif
]]></document_content>
  </document>
  <document index="9">
    <source>dplusdminus.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file dplusdminus.hpp
    \brief \f$ D_{+}D_{-} \f$ matricial representation
*/

#ifndef quantlib_d_plus_d_minus_h
#define quantlib_d_plus_d_minus_h

#include <ql/methods/finitedifferences/tridiagonaloperator.hpp>

namespace QuantLib {

    //! \f$ D_{+}D_{-} \f$ matricial representation
    /*! The differential operator \f$  D_{+}D_{-} \f$ discretizes the
        second derivative with the second-order formula
        \f[ \frac{\partial^2 u_{i}}{\partial x^2} \approx
            \frac{u_{i+1}-2u_{i}+u_{i-1}}{h^2} = D_{+}D_{-} u_{i}
        \f]

        \ingroup findiff

        \test the correctness of the returned values is tested by
              checking them against numerical calculations.
    */
    class DPlusDMinus : public TridiagonalOperator {
      public:
        DPlusDMinus(Size gridPoints, Real h);
    };


    // inline definitions

    inline DPlusDMinus::DPlusDMinus(Size gridPoints, Real h)
    : TridiagonalOperator(gridPoints) {
        setFirstRow(0.0,0.0);                   // linear extrapolation
        setMidRows(1/(h*h),-2/(h*h),1/(h*h));
        setLastRow(0.0,0.0);                    // linear extrapolation
    }

}


#endif
]]></document_content>
  </document>
  <document index="10">
    <source>dzero.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file dzero.hpp
    \brief \f$ D_{0} \f$ matricial representation
*/

#ifndef quantlib_d_zero_h
#define quantlib_d_zero_h

#include <ql/methods/finitedifferences/tridiagonaloperator.hpp>

namespace QuantLib {

    //! \f$ D_{0} \f$ matricial representation
    /*! The differential operator \f$ D_{0} \f$ discretizes the
        first derivative with the second-order formula
        \f[ \frac{\partial u_{i}}{\partial x} \approx
            \frac{u_{i+1}-u_{i-1}}{2h} = D_{0} u_{i}
        \f]

        \ingroup findiff

        \test the correctness of the returned values is tested by
              checking them against numerical calculations.
    */
    class DZero : public TridiagonalOperator {
      public:
        DZero(Size gridPoints, Real h);
    };


    // inline definitions

    inline DZero::DZero(Size gridPoints, Real h)
    : TridiagonalOperator(gridPoints) {
        setFirstRow(-1/h,1/h);                  // linear extrapolation
        setMidRows(-1/(2*h),0.0,1/(2*h));
        setLastRow(-1/h,1/h);                   // linear extrapolation
    }

}


#endif
]]></document_content>
  </document>
  <document index="11">
    <source>expliciteuler.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file expliciteuler.hpp
    \brief explicit Euler scheme for finite difference methods
*/

#ifndef quantlib_explicit_euler_hpp
#define quantlib_explicit_euler_hpp

#include <ql/methods/finitedifferences/mixedscheme.hpp>

namespace QuantLib {

    //! %Forward Euler scheme for finite difference methods
    /*! See sect. \ref findiff for details on the method.

        In this implementation, the passed operator must be derived
        from either TimeConstantOperator or TimeDependentOperator.
        Also, it must implement at least the following interface:

        \code
        typedef ... array_type;

        // copy constructor/assignment
        // (these will be provided by the compiler if none is defined)
        Operator(const Operator&);
        Operator& operator=(const Operator&);

        // inspectors
        Size size();

        // modifiers
        void setTime(Time t);

        // operator interface
        array_type applyTo(const array_type&);
        static Operator identity(Size size);

        // operator algebra
        Operator operator*(Real, const Operator&);
        Operator operator-(const Operator&, const Operator&);
        \endcode

        \todo add Richardson extrapolation

        \ingroup findiff
    */
    template <class Operator>
    class ExplicitEuler : public MixedScheme<Operator> {
      public:
        // typedefs
        typedef OperatorTraits<Operator> traits;
        typedef typename traits::operator_type operator_type;
        typedef typename traits::array_type array_type;
        typedef typename traits::bc_type bc_type;
        typedef typename traits::bc_set bc_set;
        typedef typename traits::condition_type condition_type;
        // constructors
        ExplicitEuler(const operator_type& L,
                      const std::vector<ext::shared_ptr<bc_type> >& bcs)
        : MixedScheme<Operator>(L, 0.0, bcs) {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="12">
    <source>fdtypedefs.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdtypedefs.hpp
    \brief default choices for template instantiations
*/

#ifndef quantlib_fd_typedefs_hpp
#define quantlib_fd_typedefs_hpp

#include <ql/methods/finitedifferences/cranknicolson.hpp>
#include <ql/methods/finitedifferences/parallelevolver.hpp>

namespace QuantLib {

    //! default choice for finite-difference model
    typedef FiniteDifferenceModel<
                    CrankNicolson<TridiagonalOperator>  >
                                  StandardFiniteDifferenceModel;

    //! default choice for parallel finite-difference model
    typedef FiniteDifferenceModel<ParallelEvolver<
                    CrankNicolson<TridiagonalOperator> > >
                                  StandardSystemFiniteDifferenceModel;

    //! default choice for step condition
    typedef StepCondition<Array> StandardStepCondition;

    QL_DEPRECATED_DISABLE_WARNING

    /*! \deprecated Inherit from StandardStepCondition directly.
                    Deprecated in version 1.19.
    */
    QL_DEPRECATED
    typedef CurveDependentStepCondition<Array> StandardCurveDependentStepCondition;

    QL_DEPRECATED_ENABLE_WARNING

}


#endif
]]></document_content>
  </document>
  <document index="13">
    <source>finitedifferencemodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file finitedifferencemodel.hpp
    \brief generic finite difference model
*/

#ifndef quantlib_finite_difference_model_hpp
#define quantlib_finite_difference_model_hpp

#include <ql/methods/finitedifferences/boundarycondition.hpp>
#include <ql/methods/finitedifferences/operatortraits.hpp>
#include <ql/methods/finitedifferences/stepcondition.hpp>
#include <utility>

namespace QuantLib {

    //! Generic finite difference model
    /*! \ingroup findiff */
    template<class Evolver>
    class FiniteDifferenceModel {
      public:
        typedef typename Evolver::traits traits;
        typedef typename traits::operator_type operator_type;
        typedef typename traits::array_type array_type;
        typedef typename traits::bc_set bc_set;
        typedef typename traits::condition_type condition_type;
        // constructors
        FiniteDifferenceModel(const operator_type& L,
                              const bc_set& bcs,
                              std::vector<Time> stoppingTimes = std::vector<Time>())
        : evolver_(L, bcs), stoppingTimes_(std::move(stoppingTimes)) {
            std::sort(stoppingTimes_.begin(), stoppingTimes_.end());
            auto last = std::unique(stoppingTimes_.begin(), stoppingTimes_.end());
            stoppingTimes_.erase(last, stoppingTimes_.end());
        }
        FiniteDifferenceModel(Evolver evolver,
                              std::vector<Time> stoppingTimes = std::vector<Time>())
        : evolver_(std::move(evolver)), stoppingTimes_(std::move(stoppingTimes)) {
            std::sort(stoppingTimes_.begin(), stoppingTimes_.end());
            auto last = std::unique(stoppingTimes_.begin(), stoppingTimes_.end());
            stoppingTimes_.erase(last, stoppingTimes_.end());
        }
        // methods
        // array_type grid() const { return evolver.xGrid(); }
        const Evolver& evolver() const{ return evolver_; }
        /*! solves the problem between the given times.
            \warning being this a rollback, <tt>from</tt> must be a later
                     time than <tt>to</tt>.
        */
        void rollback(array_type& a,
                      Time from,
                      Time to,
                      Size steps) {
            rollbackImpl(a, from, to, steps, (const condition_type*)nullptr);
        }
        /*! solves the problem between the given times,
            applying a condition at every step.
            \warning being this a rollback, <tt>from</tt> must be a later
                     time than <tt>to</tt>.
        */
        void rollback(array_type& a,
                      Time from,
                      Time to,
                      Size steps,
                      const condition_type& condition) {
            rollbackImpl(a,from,to,steps,&condition);
        }
      private:
        void rollbackImpl(array_type& a,
                          Time from,
                          Time to,
                          Size steps,
                          const condition_type* condition) {

            QL_REQUIRE(from >= to,
                       "trying to roll back from " << from << " to " << to);

            Time dt = (from-to)/steps, t = from;
            evolver_.setStep(dt);

            if(!stoppingTimes_.empty() && stoppingTimes_.back() == from) {
                if (condition)
                    condition->applyTo(a,from);
            }
            for (Size i=0; i<steps; ++i, t -= dt) {
                Time now = t;
                // make sure last step ends exactly on "to" in order to not
                // miss a stopping time at "to" due to numerical issues
                Time next = (i < steps -1)? t-dt : to;

                if (std::fabs(to-next) < std::sqrt(QL_EPSILON)) next = to;
                bool hit = false;
                for (Integer j = static_cast<Integer>(stoppingTimes_.size())-1; j >= 0 ; --j) {
                    if (next <= stoppingTimes_[j] && stoppingTimes_[j] < now) {
                        // a stopping time was hit
                        hit = true;

                        // perform a small step to stoppingTimes_[j]...
                        evolver_.setStep(now-stoppingTimes_[j]);
                        evolver_.step(a,now);
                        if (condition)
                            condition->applyTo(a,stoppingTimes_[j]);
                        // ...and continue the cycle
                        now = stoppingTimes_[j];
                    }
                }
                // if we did hit...
                if (hit) {
                    // ...we might have to make a small step to
                    // complete the big one...
                    if (now > next) {
                        evolver_.setStep(now - next);
                        evolver_.step(a,now);
                        if (condition)
                            condition->applyTo(a,next);
                    }
                    // ...and in any case, we have to reset the
                    // evolver to the default step.
                    evolver_.setStep(dt);
                } else {
                    // if we didn't, the evolver is already set to the
                    // default step, which is ok for us.
                    evolver_.step(a,now);
                    if (condition)
                        condition->applyTo(a, next);
                }
            }
        }
        Evolver evolver_;
        std::vector<Time> stoppingTimes_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="14">
    <source>impliciteuler.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file impliciteuler.hpp
    \brief implicit Euler scheme for finite difference methods
*/

#ifndef quantlib_implicit_euler_hpp
#define quantlib_implicit_euler_hpp

#include <ql/methods/finitedifferences/mixedscheme.hpp>

namespace QuantLib {

    //! Backward Euler scheme for finite difference methods
    /*! In this implementation, the passed operator must be derived
        from either TimeConstantOperator or TimeDependentOperator.
        Also, it must implement at least the following interface:

        \code
        typedef ... array_type;

        // copy constructor/assignment
        // (these will be provided by the compiler if none is defined)
        Operator(const Operator&);
        Operator& operator=(const Operator&);

        // inspectors
        Size size();

        // modifiers
        void setTime(Time t);

        // operator interface
        array_type solveFor(const array_type&);
        static Operator identity(Size size);

        // operator algebra
        Operator operator*(Real, const Operator&);
        Operator operator+(const Operator&, const Operator&);
        \endcode

        \ingroup findiff
    */
    template <class Operator>
    class ImplicitEuler : public MixedScheme<Operator> {
      public:
        // typedefs
        typedef OperatorTraits<Operator> traits;
        typedef typename traits::operator_type operator_type;
        typedef typename traits::array_type array_type;
        typedef typename traits::bc_set bc_set;
        typedef typename traits::condition_type condition_type;
        // constructors
        ImplicitEuler(const operator_type& L,
                      const bc_set& bcs)
        : MixedScheme<Operator>(L, 1.0, bcs) {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="15">
    <source>meshers/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/methods/finitedifferences/meshers/concentrating1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/exponentialjump1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdm1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmblackscholesmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmblackscholesmultistrikemesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmcev1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmhestonvariancemesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmsimpleprocess1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/predefined1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/uniform1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/uniformgridmesher.hpp>

]]></document_content>
  </document>
  <document index="16">
    <source>meshers/concentrating1dmesher.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Ralph Schreyer
 Copyright (C) 2014 Johannes GÃ¶ttker-Schnetmann
 Copyright (C) 2014 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file concentrating1dmesher.hpp
    \brief One-dimensional grid mesher concentrating around critical points
*/

#ifndef quantlib_concentrating_1d_mesher_hpp
#define quantlib_concentrating_1d_mesher_hpp

#include <ql/methods/finitedifferences/meshers/fdm1dmesher.hpp>
#include <ql/utilities/null.hpp>

#include <ql/tuple.hpp>

#include <utility>
#include <vector>

namespace QuantLib {

    class Concentrating1dMesher : public Fdm1dMesher {
      public:
        Concentrating1dMesher(Real start,
                              Real end,
                              Size size,
                              const std::pair<Real, Real>& cPoints =
                                  (std::pair<Real, Real>(Null<Real>(), Null<Real>())),
                              bool requireCPoint = false);

        Concentrating1dMesher(
            Real start, Real end, Size size,
            const std::vector<ext::tuple<Real, Real, bool> >& cPoints,
            Real tol = 1e-8);
    };
}

#endif
]]></document_content>
  </document>
  <document index="17">
    <source>meshers/exponentialjump1dmesher.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file exponentialjump1dmesher.hpp
    \brief mesher for a exponential jump mesher with high 
           mean reversion rate and low jump intensity
*/

#ifndef quantlib_exponential_jump_1d_mesher_hpp
#define quantlib_exponential_jump_1d_mesher_hpp

#include <ql/methods/finitedifferences/meshers/fdm1dmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopiterator.hpp>

namespace QuantLib {

    /*! Mesher for a exponential jump process with high 
        mean reversion rate and low jump intensity
        \f[
        \begin{array}{rcl}
        dY_t  &=& -\beta Y_{t-}dt + J_tdN_t \\
        \omega(J)&=&\frac{1}{\eta_u}e^{-\frac{1}{\eta_u}J}
        \end{array}
        \f]
    */

    /*! References:
        B. Hambly, S. Howison, T. Kluge, Modelling spikes and pricing 
        swing options in electricity markets,
        http://people.maths.ox.ac.uk/hambly/PDF/Papers/elec.pdf
    */

    class ExponentialJump1dMesher : public Fdm1dMesher {
      public:
        ExponentialJump1dMesher(Size steps, Real beta, Real jumpIntensity, 
                                Real eta, Real eps = 1e-3);
        
        // approximation. see Hambly et.al.
        Real jumpSizeDensity(Real x) const; // t->\inf
        Real jumpSizeDensity(Real x, Time t) const;
        Real jumpSizeDistribution(Real x) const; // t->\inf
        Real jumpSizeDistribution(Real x, Time t) const;
        
      private:
        const Real beta_, jumpIntensity_, eta_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="18">
    <source>meshers/fdm1dmesher.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdm1dmesher.hpp
    \brief One-dimensional simple FDM mesher object working on an index
*/

#ifndef quantlib_fdm_1d_mesher_hpp
#define quantlib_fdm_1d_mesher_hpp

#include <ql/types.hpp>
#include <vector>

namespace QuantLib {

    class Fdm1dMesher {
      public:
        explicit Fdm1dMesher(Size size)
        : locations_(size), dplus_(size), dminus_(size) {}
        virtual ~Fdm1dMesher() = default;

        Size size() const { return locations_.size(); }
        Real dplus(Size index) const {return dplus_[index];}
        Real dminus(Size index) const {return dminus_[index];}
        Real location(Size index) const {return locations_[index];}
        const std::vector<Real>& locations() const {return locations_;}

      protected:
        std::vector<Real> locations_;
        std::vector<Real> dplus_, dminus_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="19">
    <source>meshers/fdmblackscholesmesher.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmblackscholesmesher.hpp
    \brief 1-d mesher for the Black-Scholes process (in ln(S))
*/

#ifndef quantlib_fdm_black_scholes_mesher_hpp
#define quantlib_fdm_black_scholes_mesher_hpp

#include <ql/instruments/dividendschedule.hpp>
#include <ql/methods/finitedifferences/meshers/fdm1dmesher.hpp>

#include <ql/handle.hpp>
#include <ql/quote.hpp>

namespace QuantLib {

    class FdmQuantoHelper;
    class YieldTermStructure;
    class GeneralizedBlackScholesProcess;

    class FdmBlackScholesMesher : public Fdm1dMesher {
      public:
        FdmBlackScholesMesher(
            Size size,
            const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
            Time maturity, Real strike,
            Real xMinConstraint = Null<Real>(),
            Real xMaxConstraint = Null<Real>(),
            Real eps = 0.0001,
            Real scaleFactor = 1.5,
            const std::pair<Real, Real>& cPoint
                = (std::pair<Real, Real>(Null<Real>(), Null<Real>())),
            const DividendSchedule& dividendSchedule = DividendSchedule(),
            const ext::shared_ptr<FdmQuantoHelper>& fdmQuantoHelper
                = ext::shared_ptr<FdmQuantoHelper>(),
            Real spotAdjustment = 0.0);

        static ext::shared_ptr<GeneralizedBlackScholesProcess> processHelper(
             const Handle<Quote>& s0,
             const Handle<YieldTermStructure>& rTS,
             const Handle<YieldTermStructure>& qTS,
             Volatility vol);
    };
}

#endif
]]></document_content>
  </document>
  <document index="20">
    <source>meshers/fdmblackscholesmultistrikemesher.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmblackscholesmultistrikemesher.hpp
    \brief 1-d mesher for the Black-Scholes process (in ln(S))
*/

#ifndef quantlib_fdm_black_scholes_multi_strike_mesher_hpp
#define quantlib_fdm_black_scholes_multi_strike_mesher_hpp

#include <ql/instruments/dividendschedule.hpp>
#include <ql/methods/finitedifferences/meshers/fdm1dmesher.hpp>
#include <ql/handle.hpp>
#include <ql/quote.hpp>

namespace QuantLib {

    class YieldTermStructure;
    class GeneralizedBlackScholesProcess;

    class FdmBlackScholesMultiStrikeMesher : public Fdm1dMesher {
      public:
        FdmBlackScholesMultiStrikeMesher(
            Size size,
            const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
            Time maturity, const std::vector<Real>& strikes,
            Real eps = 0.0001,
            Real scaleFactor = 1.5,
            const std::pair<Real, Real>& cPoint
                        = (std::pair<Real, Real>(Null<Real>(), Null<Real>())));
    };
}
#endif
]]></document_content>
  </document>
  <document index="21">
    <source>meshers/fdmcev1dmesher.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmcev1dmesher.hpp
    \brief One-dimensional mesher for the CEV model
*/

#ifndef quantlib_fdm_cev_1d_mesher_hpp
#define quantlib_fdm_cev_1d_mesher_hpp

#include <ql/utilities/null.hpp>
#include <ql/methods/finitedifferences/meshers/fdm1dmesher.hpp>

namespace QuantLib {

    class FdmCEV1dMesher : public Fdm1dMesher {
      public:
        FdmCEV1dMesher(
            Size size,
            Real f0, Real alpha, Real beta,
            Time maturity,
            Real eps = 0.0001,
            Real scaleFactor = 1.5,
            const std::pair<Real, Real>& cPoint
                = (std::pair<Real, Real>(Null<Real>(), Null<Real>())));
    };
}

#endif
]]></document_content>
  </document>
  <document index="22">
    <source>meshers/fdmhestonvariancemesher.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008, 2019 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmhestonvariancemesher.hpp
    \brief One-dimensional grid mesher for the variance part of the Heston model
*/

#ifndef quantlib_fdm_heston_variance_mesher_hpp
#define quantlib_fdm_heston_variance_mesher_hpp

#include <ql/processes/hestonprocess.hpp>
#include <ql/methods/finitedifferences/meshers/fdm1dmesher.hpp>

namespace QuantLib {

    class FdmHestonVarianceMesher : public Fdm1dMesher {
      public:
        FdmHestonVarianceMesher(
            Size size,
            const ext::shared_ptr<HestonProcess> & process,
            Time maturity, Size tAvgSteps = 10, Real epsilon = 0.0001,
            Real mixingFactor = 1.0);

        Real volaEstimate() const { return volaEstimate_; }

      private:
        Real volaEstimate_;
    };


    class LocalVolTermStructure;

    class FdmHestonLocalVolatilityVarianceMesher : public Fdm1dMesher {
      public:
        FdmHestonLocalVolatilityVarianceMesher(
            Size size,
            const ext::shared_ptr<HestonProcess>& process,
            const ext::shared_ptr<LocalVolTermStructure>& leverageFct,
            Time maturity, Size tAvgSteps = 10, Real epsilon = 0.0001,
            Real mixingFactor = 1.0);

        Real volaEstimate() const { return volaEstimate_; }

      private:
        Real volaEstimate_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="23">
    <source>meshers/fdmmesher.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmmesher.hpp
    \brief mesher for a fdm grid
*/
#ifndef quantlib_fdm_mesher_hpp
#define quantlib_fdm_mesher_hpp

#include <ql/math/array.hpp>
#include <ql/shared_ptr.hpp>
#include <utility>
#include <vector>

namespace QuantLib {
    class FdmLinearOpLayout;
    class FdmLinearOpIterator;

    class FdmMesher {
      public:
        explicit FdmMesher(ext::shared_ptr<FdmLinearOpLayout> layout)
        : layout_(std::move(layout)) {}
        virtual ~FdmMesher() = default;

        virtual Real dplus(const FdmLinearOpIterator& iter,
                           Size direction)  const = 0;
        virtual Real dminus(const FdmLinearOpIterator& iter,
                            Size direction) const = 0;
        virtual Real location(const FdmLinearOpIterator& iter ,
                              Size direction) const = 0;
        virtual Disposable<Array> locations(Size direction) const = 0;

        const ext::shared_ptr<FdmLinearOpLayout>& layout() const {
            return layout_;
        }

      protected:
        const ext::shared_ptr<FdmLinearOpLayout> layout_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="24">
    <source>meshers/fdmmeshercomposite.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmmeshercomposite.hpp
    \brief FdmMesher which is a composite of Fdm1dMesher
*/

#ifndef quantlib_fdm_mesher_composite_hpp
#define quantlib_fdm_mesher_composite_hpp

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdm1dmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopiterator.hpp>

namespace QuantLib {

    class FdmMesherComposite : public FdmMesher {
      public:
        FdmMesherComposite(
            const ext::shared_ptr<FdmLinearOpLayout>& layout,
            const std::vector<ext::shared_ptr<Fdm1dMesher> > & mesher);

        // convenient constructors
        explicit FdmMesherComposite(
            const std::vector<ext::shared_ptr<Fdm1dMesher> > & mesher);
        explicit FdmMesherComposite(
            const ext::shared_ptr<Fdm1dMesher>& mesher);
        FdmMesherComposite(const ext::shared_ptr<Fdm1dMesher>& m1,
                           const ext::shared_ptr<Fdm1dMesher>& m2);
        FdmMesherComposite(const ext::shared_ptr<Fdm1dMesher>& m1,
                           const ext::shared_ptr<Fdm1dMesher>& m2,
                           const ext::shared_ptr<Fdm1dMesher>& m3);
        FdmMesherComposite(const ext::shared_ptr<Fdm1dMesher>& m1,
                           const ext::shared_ptr<Fdm1dMesher>& m2,
                           const ext::shared_ptr<Fdm1dMesher>& m3,
                           const ext::shared_ptr<Fdm1dMesher>& m4);


        Real dplus(const FdmLinearOpIterator& iter, Size direction) const override;
        Real dminus(const FdmLinearOpIterator& iter, Size direction) const override;
        Real location(const FdmLinearOpIterator& iter, Size direction) const override;
        Disposable<Array> locations(Size direction) const override;

        const std::vector<ext::shared_ptr<Fdm1dMesher> >&
            getFdm1dMeshers() const;

      private:
        const std::vector<ext::shared_ptr<Fdm1dMesher> > mesher_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="25">
    <source>meshers/fdmsimpleprocess1dmesher.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009, 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmsimpleprocess1dmesher.hpp
    \brief One-dimensional grid mesher
*/

#ifndef quantlib_fdm_simple_process_1d_mesher_hpp
#define quantlib_fdm_simple_process_1d_mesher_hpp

#include <ql/methods/finitedifferences/meshers/fdm1dmesher.hpp>
#include <ql/utilities/null.hpp>
#include <ql/shared_ptr.hpp>

namespace QuantLib {

    class StochasticProcess1D;

    class FdmSimpleProcess1dMesher : public Fdm1dMesher {
      public:
          FdmSimpleProcess1dMesher(
            Size size,
            const ext::shared_ptr<StochasticProcess1D>& process,
            Time maturity, Size tAvgSteps = 10, Real epsilon = 0.0001,
            Real mandatoryPoint = Null<Real>());
    };

}

#endif
]]></document_content>
  </document>
  <document index="26">
    <source>meshers/predefined1dmesher.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file predefined1dmesher.hpp
    \brief One-dimensional mesher build from a given set of points
*/

#ifndef quantlib_predefined_1d_mesher_hpp
#define quantlib_predefined_1d_mesher_hpp

#include <ql/utilities/null.hpp>
#include <ql/methods/finitedifferences/meshers/fdm1dmesher.hpp>

#include <vector>

namespace QuantLib {

    class Predefined1dMesher : public Fdm1dMesher {
      public:
        explicit Predefined1dMesher(const std::vector<Real>& x)
        : Fdm1dMesher(x.size()) {
            std::copy(x.begin(), x.end(), locations_.begin());

            dplus_.back() = dminus_.front() = Null<Real>();
            for (Size i=0; i < x.size()-1; ++i) {
                dplus_[i] = dminus_[i+1] = x[i+1] - x[i];
            }
        }
    };
}

#endif
]]></document_content>
  </document>
  <document index="27">
    <source>meshers/uniform1dmesher.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file uniform1dmesher.hpp
    \brief One-dimensional simple uniform grid mesher
*/

#ifndef quantlib_fdm_uniform_1d_mesher_hpp
#define quantlib_fdm_uniform_1d_mesher_hpp

#include <ql/methods/finitedifferences/meshers/fdm1dmesher.hpp>
#include <ql/errors.hpp>
#include <ql/utilities/null.hpp>

namespace QuantLib {

    class Uniform1dMesher : public Fdm1dMesher {
      public:
        Uniform1dMesher(Real start, Real end, Size size)
        : Fdm1dMesher(size) {
            QL_REQUIRE(end > start, "end must be large than start");

            const Real dx = (end-start)/(size-1);

            for (Size i=0; i < size-1; ++i) {
                locations_[i] = start + i*dx;
                dplus_[i] = dminus_[i+1] = dx;
            }

            locations_.back() = end;
            dplus_.back() = dminus_.front() = Null<Real>();
        }
    };
}

#endif
]]></document_content>
  </document>
  <document index="28">
    <source>meshers/uniformgridmesher.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file uniformgridmesher.hpp
    \brief uniform grid mesher
*/

#ifndef quantlib_uniform_grid_mesher_hpp
#define quantlib_uniform_grid_mesher_hpp

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopiterator.hpp>
#include <memory>

namespace QuantLib {

    class UniformGridMesher : public FdmMesher {
      public:
        UniformGridMesher(
            const ext::shared_ptr<FdmLinearOpLayout> & index,
            const std::vector<std::pair<Real, Real> > & boundaries);

        Real dplus(const FdmLinearOpIterator&, Size direction) const override {
            return dx_[direction];
        }
        Real dminus(const FdmLinearOpIterator&, Size direction) const override {
            return dx_[direction];
        }

        Real location(const FdmLinearOpIterator& iter, Size direction) const override {
            return locations_[direction][iter.coordinates()[direction]];
        }

        Disposable<Array> locations(Size direction) const override;

      private:
        std::unique_ptr<Real[]> dx_;
        std::vector<std::vector<Real> > locations_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="29">
    <source>mixedscheme.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mixedscheme.hpp
    \brief Mixed (explicit/implicit) scheme for finite difference methods
*/

#ifndef quantlib_mixed_scheme_hpp
#define quantlib_mixed_scheme_hpp

#include <ql/methods/finitedifferences/finitedifferencemodel.hpp>
#include <utility>

namespace QuantLib {

    //! Mixed (explicit/implicit) scheme for finite difference methods
    /*! In this implementation, the passed operator must be derived
        from either TimeConstantOperator or TimeDependentOperator.
        Also, it must implement at least the following interface:

        \code
        typedef ... array_type;

        // copy constructor/assignment
        // (these will be provided by the compiler if none is defined)
        Operator(const Operator&);
        Operator& operator=(const Operator&);

        // inspectors
        Size size();

        // modifiers
        void setTime(Time t);

        // operator interface
        array_type applyTo(const array_type&);
        array_type solveFor(const array_type&);
        static Operator identity(Size size);

        // operator algebra
        Operator operator*(Real, const Operator&);
        Operator operator+(const Operator&, const Operator&);
        Operator operator+(const Operator&, const Operator&);
        \endcode

        \warning The differential operator must be linear for
                 this evolver to work.

        \todo
        - derive variable theta schemes
        - introduce multi time-level schemes.

        \ingroup findiff
    */
    template <class Operator>
    class MixedScheme  {
      public:
        // typedefs
        typedef OperatorTraits<Operator> traits;
        typedef typename traits::operator_type operator_type;
        typedef typename traits::array_type array_type;
        typedef typename traits::bc_set bc_set;
        typedef typename traits::condition_type condition_type;
        // constructors
        MixedScheme(const operator_type& L, Real theta, bc_set bcs)
        : L_(L), I_(operator_type::identity(L.size())), dt_(0.0), theta_(theta),
          bcs_(std::move(bcs)) {}
        void step(array_type& a,
                  Time t);
        void setStep(Time dt) {
            dt_ = dt;
            if (theta_!=1.0) // there is an explicit part
                explicitPart_ = I_-((1.0-theta_) * dt_)*L_;
            if (theta_!=0.0) // there is an implicit part
                implicitPart_ = I_+(theta_ * dt_)*L_;
        }
      protected:
        operator_type L_, I_, explicitPart_, implicitPart_;
        Time dt_;
        Real theta_;
        bc_set bcs_;
    };


    // inline definitions

    template <class Operator>
    inline void MixedScheme<Operator>::step(array_type& a, Time t) {
        Size i;
        for (i=0; i<bcs_.size(); i++)
            bcs_[i]->setTime(t);
        if (theta_!=1.0) { // there is an explicit part
            if (L_.isTimeDependent()) {
                L_.setTime(t);
                explicitPart_ = I_-((1.0-theta_) * dt_)*L_;
            }
            for (i=0; i<bcs_.size(); i++)
                bcs_[i]->applyBeforeApplying(explicitPart_);
            a = explicitPart_.applyTo(a);
            for (i=0; i<bcs_.size(); i++)
                bcs_[i]->applyAfterApplying(a);
        }
        if (theta_!=0.0) { // there is an implicit part
            if (L_.isTimeDependent()) {
                L_.setTime(t-dt_);
                implicitPart_ = I_+(theta_ * dt_)*L_;
            }
            for (i=0; i<bcs_.size(); i++)
                bcs_[i]->applyBeforeSolving(implicitPart_,a);
            implicitPart_.solveFor(a, a);
            for (i=0; i<bcs_.size(); i++)
                bcs_[i]->applyAfterSolving(a);
        }
    }

}


#endif
]]></document_content>
  </document>
  <document index="30">
    <source>onefactoroperator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file onefactoroperator.hpp
    \brief general differential operator for one-factor interest rate models
*/

#ifndef quantlib_finite_differences_one_factor_operator_hpp
#define quantlib_finite_differences_one_factor_operator_hpp

#include <ql/methods/finitedifferences/tridiagonaloperator.hpp>
#include <ql/models/shortrate/onefactormodel.hpp>
#include <ql/math/transformedgrid.hpp>
#include <ql/methods/finitedifferences/pdeshortrate.hpp>

namespace QuantLib {

    //! Interest-rate single factor model differential operator
    /*! \ingroup findiff

        \deprecated Use the new finite-differences framework instead.
                    Deprecated in version 1.22.
    */
    QL_DEPRECATED
    typedef PdeOperator<PdeShortRate> OneFactorOperator;

}


#endif
]]></document_content>
  </document>
  <document index="31">
    <source>operators/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/methods/finitedifferences/operators/fdm2dblackscholesop.hpp>
#include <ql/methods/finitedifferences/operators/fdmbatesop.hpp>
#include <ql/methods/finitedifferences/operators/fdmblackscholesop.hpp>
#include <ql/methods/finitedifferences/operators/fdmcevop.hpp>
#include <ql/methods/finitedifferences/operators/fdmg2op.hpp>
#include <ql/methods/finitedifferences/operators/fdmhestonhullwhiteop.hpp>
#include <ql/methods/finitedifferences/operators/fdmhestonop.hpp>
#include <ql/methods/finitedifferences/operators/fdmcirop.hpp>
#include <ql/methods/finitedifferences/operators/fdmhullwhiteop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/operators/fdmlocalvolfwdop.hpp>
#include <ql/methods/finitedifferences/operators/fdmornsteinuhlenbeckop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopiterator.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/fdmsabrop.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/ninepointlinearop.hpp>
#include <ql/methods/finitedifferences/operators/nthorderderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/numericaldifferentiation.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/secondordermixedderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>

]]></document_content>
  </document>
  <document index="32">
    <source>operators/fdm2dblackscholesop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


/*! \file fdm2dblackscholesop.hpp
*/

#ifndef quantlib_fdm_2d_black_scholes_op_hpp
#define quantlib_fdm_2d_black_scholes_op_hpp

#include <ql/methods/finitedifferences/operators/ninepointlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmblackscholesop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>

namespace QuantLib {

    class FdmMesher;
    class GeneralizedBlackScholesProcess;

    class Fdm2dBlackScholesOp : public FdmLinearOpComposite {
      public:
        Fdm2dBlackScholesOp(
            const ext::shared_ptr<FdmMesher>& mesher,
            const ext::shared_ptr<GeneralizedBlackScholesProcess>& p1,
            const ext::shared_ptr<GeneralizedBlackScholesProcess>& p2,
            Real correlation,
            Time maturity,
            bool localVol = false,
            Real illegalLocalVolOverwrite = -Null<Real>());

        Size size() const override;
        void setTime(Time t1, Time t2) override;
        Disposable<Array> apply(const Array& x) const override;
        Disposable<Array> apply_mixed(const Array& x) const override;

        Disposable<Array> apply_direction(Size direction, const Array& x) const override;

        Disposable<Array> solve_splitting(Size direction, const Array& x, Real s) const override;
        Disposable<Array> preconditioner(const Array& r, Real s) const override;

        Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;

      private:
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<GeneralizedBlackScholesProcess> p1_, p2_;
        const ext::shared_ptr<LocalVolTermStructure> localVol1_, localVol2_;
        const Array x_, y_;
        
        Real currentForwardRate_;
        FdmBlackScholesOp opX_, opY_;
        NinePointLinearOp corrMapT_;
        const NinePointLinearOp corrMapTemplate_;
        const Real illegalLocalVolOverwrite_;
    };
}
#endif
]]></document_content>
  </document>
  <document index="33">
    <source>operators/fdmbatesop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmbatesop.hpp
    \brief Bates linear operator
*/

#ifndef quantlib_fdm_bates_op_hpp
#define quantlib_fdm_bates_op_hpp

#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/methods/finitedifferences/operators/fdmhestonop.hpp>
#include <ql/methods/finitedifferences/utilities/fdmboundaryconditionset.hpp>

namespace QuantLib {

    class LinearInterpolation;
    class BatesProcess;
    
    class FdmBatesOp : public FdmLinearOpComposite {
      public:
        FdmBatesOp(const ext::shared_ptr<FdmMesher>& mesher,
                   const ext::shared_ptr<BatesProcess>& batesProcess,
                   FdmBoundaryConditionSet bcSet,
                   Size integroIntegrationOrder,
                   const ext::shared_ptr<FdmQuantoHelper>& quantoHelper =
                       ext::shared_ptr<FdmQuantoHelper>());

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Disposable<Array> apply(const Array& r) const override;
        Disposable<Array> apply_mixed(const Array& r) const override;

        Disposable<Array> apply_direction(Size direction, const Array& r) const override;
        Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
        Disposable<Array> preconditioner(const Array& r, Real s) const override;

        Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;

      private:
        class IntegroIntegrand {
          public:
            IntegroIntegrand(const ext::shared_ptr<LinearInterpolation>& i,
                             const FdmBoundaryConditionSet& bcSet,
                             Real x, Real delta, Real nu);
            Real operator()(Real y) const;
            
          private:
            const Real x_, delta_, nu_;
            const FdmBoundaryConditionSet& bcSet_;
            const ext::shared_ptr<LinearInterpolation>& interpl_;
        };
          
        Disposable<Array> integro(const Array& r) const;  
        
        Array x_, weights_;
        
        const Real lambda_, delta_, nu_, m_;
        GaussHermiteIntegration gaussHermiteIntegration_;
        
        const ext::shared_ptr<FdmMesher> mesher_;
        const FdmBoundaryConditionSet bcSet_;
        const ext::shared_ptr<FdmHestonOp> hestonOp_;
    };

    // inline
    inline Size FdmBatesOp::size() const {
        return hestonOp_->size();
    }
    
    inline void FdmBatesOp::setTime(Time t1, Time t2) {
        hestonOp_->setTime(t1, t2);
    }
    
    inline Disposable<Array> FdmBatesOp::apply(const Array& r) const {
        return hestonOp_->apply(r) + integro(r);
    }
    
    inline Disposable<Array> FdmBatesOp::apply_mixed(const Array& r) const {
        return hestonOp_->apply_mixed(r) + integro(r);
    }

    inline
    Disposable<Array> FdmBatesOp::apply_direction(Size direction,
                                                  const Array& r) const {
        return hestonOp_->apply_direction(direction, r);
    }

    inline Disposable<Array> FdmBatesOp::solve_splitting(Size direction,
                                                         const Array& r,
                                                         Real s) const{
        return hestonOp_->solve_splitting(direction, r, s);
    }
 
    inline Disposable<Array> FdmBatesOp::preconditioner(const Array& r,
                                                 Real s) const {
        return hestonOp_->preconditioner(r, s);
    }
    
}

#endif
]]></document_content>
  </document>
  <document index="34">
    <source>operators/fdmblackscholesop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmblackscholesop.hpp
    \brief Black Scholes linear operator
*/

#ifndef quantlib_fdm_black_scholes_op_hpp
#define quantlib_fdm_black_scholes_op_hpp

#include <ql/payoff.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/methods/finitedifferences/utilities/fdmquantohelper.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>

namespace QuantLib {

    class FdmBlackScholesOp : public FdmLinearOpComposite {
      public:
        FdmBlackScholesOp(
            const ext::shared_ptr<FdmMesher>& mesher,
            const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
            Real strike,
            bool localVol = false,
            Real illegalLocalVolOverwrite = -Null<Real>(),
            Size direction = 0,
            ext::shared_ptr<FdmQuantoHelper> quantoHelper = ext::shared_ptr<FdmQuantoHelper>());

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Disposable<Array> apply(const Array& r) const override;
        Disposable<Array> apply_mixed(const Array& r) const override;
        Disposable<Array> apply_direction(Size direction, const Array& r) const override;
        Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
        Disposable<Array> preconditioner(const Array& r, Real s) const override;

        Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;

      private:
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<YieldTermStructure> rTS_, qTS_;
        const ext::shared_ptr<BlackVolTermStructure> volTS_;
        const ext::shared_ptr<LocalVolTermStructure> localVol_;
        const Array x_;
        const FirstDerivativeOp  dxMap_;
        const TripleBandLinearOp dxxMap_;
        TripleBandLinearOp mapT_;
        const Real strike_;
        const Real illegalLocalVolOverwrite_;
        const Size direction_;
        const ext::shared_ptr<FdmQuantoHelper> quantoHelper_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="35">
    <source>operators/fdmcevop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmcevop.hpp
    \brief FDM operator for the Constant Elasticity of Variance (CEV) model
*/

#ifndef quantlib_fdm_cev_op_hpp
#define quantlib_fdm_cev_op_hpp

#include <ql/methods/finitedifferences/operators/ninepointlinearop.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>

namespace QuantLib {

    //! constant elasticity of variance process (absorbing boundary at f=0)
    /*! \f[
         df_t = \alpha f_t^\beta \mathrm{d}W_t
        \f]
    */

    class FdmMesher;
    class YieldTermStructure;

    class FdmCEVOp : public FdmLinearOpComposite {
      public:

        FdmCEVOp(
            const ext::shared_ptr<FdmMesher>& mesher,
            const ext::shared_ptr<YieldTermStructure>& rTS,
            Real f0, Real alpha, Real beta,
            Size direction);

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Disposable<Array> apply(const Array& r) const override;
        Disposable<Array> apply_mixed(const Array& r) const override;
        Disposable<Array> apply_direction(Size direction, const Array& r) const override;
        Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
        Disposable<Array> preconditioner(const Array& r, Real s) const override;

        Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;

      private:
        const ext::shared_ptr<YieldTermStructure>& rTS_;
        const Size direction_;
        const TripleBandLinearOp dxxMap_;
        TripleBandLinearOp mapT_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="36">
    <source>operators/fdmcirop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Lew Wei Hao

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmcirop.hpp
    \brief CIR linear operator
*/

#ifndef quantlib_fdm_cir_op_hpp
#define quantlib_fdm_cir_op_hpp

#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/ninepointlinearop.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/utilities/fdmquantohelper.hpp>
#include <ql/models/shortrate/onefactormodels/coxingersollross.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/coxingersollrossprocess.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>

namespace QuantLib {

    class FdmCIREquityPart {
      public:
        FdmCIREquityPart(
            const ext::shared_ptr<FdmMesher>& mesher,
            const ext::shared_ptr<GeneralizedBlackScholesProcess> & bsProcess,
            Real strike);

        void setTime(Time t1, Time t2);
        const TripleBandLinearOp& getMap() const;

      protected:
        const FirstDerivativeOp  dxMap_;
        const TripleBandLinearOp dxxMap_;
        TripleBandLinearOp mapT_;

        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<YieldTermStructure> qTS_;
        const Real strike_;
        const ext::shared_ptr<BlackVolTermStructure> sigma1_;
    };

    class FdmCIRRatesPart {
      public:
        FdmCIRRatesPart(
            const ext::shared_ptr<FdmMesher>& mesher,
            Real sigma, Real kappa, Real theta);

        void setTime(Time t1, Time t2);
        const TripleBandLinearOp& getMap() const;

      protected:
        const TripleBandLinearOp dyMap_;
        TripleBandLinearOp mapT_;
        const ext::shared_ptr<FdmMesher> mesher_;
    };

    class FdmCIRMixedPart {
      public:
        FdmCIRMixedPart(const ext::shared_ptr<FdmMesher>& mesher,
                        const ext::shared_ptr<CoxIngersollRossProcess>& cirProcess,
                        const ext::shared_ptr<GeneralizedBlackScholesProcess>& bsProcess,
                        Real rho,
                        Real strike);

        void setTime(Time t1, Time t2);
        const NinePointLinearOp& getMap() const;

      protected:
        const NinePointLinearOp dyMap_;
        NinePointLinearOp mapT_;
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<BlackVolTermStructure> sigma1_;
        const Real strike_;
    };


    class FdmCIROp : public FdmLinearOpComposite {
      public:
        FdmCIROp(const ext::shared_ptr<FdmMesher>& mesher,
                 const ext::shared_ptr<CoxIngersollRossProcess>& cirProcess,
                 const ext::shared_ptr<GeneralizedBlackScholesProcess>& bsProcess,
                 Real rho,
                 Real strike);

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Disposable<Array> apply(const Array& r) const override;
        Disposable<Array> apply_mixed(const Array& r) const override;

        Disposable<Array> apply_direction(Size direction, const Array& r) const override;
        Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
        Disposable<Array> preconditioner(const Array& r, Real s) const override;

        Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;

      private:
        FdmCIREquityPart dxMap_;
        FdmCIRRatesPart dyMap_;
        FdmCIRMixedPart dzMap_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="37">
    <source>operators/fdmg2op.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmhullwhiteop.hpp
    \brief FDM operator for the Hull-White interest rate model
*/

#ifndef quantlib_fdm_g2_op_hpp
#define quantlib_fdm_g2_op_hpp

#include <ql/methods/finitedifferences/operators/ninepointlinearop.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>

namespace QuantLib {

    class G2;
    class FdmMesher;

    class FdmG2Op : public FdmLinearOpComposite {
      public:

        FdmG2Op(
            const ext::shared_ptr<FdmMesher>& mesher,
            const ext::shared_ptr<G2>& model,
            Size direction1, Size direction2);

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Disposable<Array> apply(const Array& r) const override;
        Disposable<Array> apply_mixed(const Array& r) const override;
        Disposable<Array> apply_direction(Size direction, const Array& r) const override;
        Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
        Disposable<Array> preconditioner(const Array& r, Real s) const override;

        Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;

      private:
        const Size direction1_, direction2_;
        const Array x_, y_;
        const TripleBandLinearOp dxMap_, dyMap_;

        NinePointLinearOp corrMap_;
        TripleBandLinearOp mapX_, mapY_;

        const ext::shared_ptr<G2> model_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="38">
    <source>operators/fdmhestonhullwhiteop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmhestonhullwhiteop.hpp
    \brief Heston Hull White linear operator
*/

#ifndef quantlib_fdm_heston_hull_white_op_hpp
#define quantlib_fdm_heston_hull_white_op_hpp

#include <ql/processes/hestonprocess.hpp>
#include <ql/processes/hullwhiteprocess.hpp>
#include <ql/methods/finitedifferences/operators/fdmhullwhiteop.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/ninepointlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>

namespace QuantLib {

    class HullWhite;

    class FdmHestonHullWhiteEquityPart {
      public:
        FdmHestonHullWhiteEquityPart(const ext::shared_ptr<FdmMesher>& mesher,
                                     ext::shared_ptr<HullWhite> hwModel,
                                     ext::shared_ptr<YieldTermStructure> qTS);

        void setTime(Time t1, Time t2);
        const TripleBandLinearOp& getMap() const;

      protected:
        const Array x_;
        Array varianceValues_, volatilityValues_;
        const FirstDerivativeOp  dxMap_;
        const TripleBandLinearOp dxxMap_;
        TripleBandLinearOp mapT_;

        const ext::shared_ptr<HullWhite> hwModel_;
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<YieldTermStructure> qTS_;
    };

    class FdmHestonHullWhiteOp : public FdmLinearOpComposite {
      public:
        FdmHestonHullWhiteOp(
            const ext::shared_ptr<FdmMesher>& mesher,
            const ext::shared_ptr<HestonProcess>& hestonProcess,
            const ext::shared_ptr<HullWhiteProcess>& hwProcess,
            Real equityShortRateCorrelation);

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Disposable<Array> apply(const Array& r) const override;
        Disposable<Array> apply_mixed(const Array& r) const override;

        Disposable<Array> apply_direction(Size direction, const Array& r) const override;
        Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
        Disposable<Array> preconditioner(const Array& r, Real s) const override;

        Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;

      private:
        const Real v0_, kappa_, theta_, sigma_, rho_;
        const ext::shared_ptr<HullWhite> hwModel_;

        NinePointLinearOp hestonCorrMap_;
        NinePointLinearOp equityIrCorrMap_;
        TripleBandLinearOp dyMap_;
        FdmHestonHullWhiteEquityPart dxMap_;
        FdmHullWhiteOp hullWhiteOp_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="39">
    <source>operators/fdmhestonop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008, 2014, 2015 Klaus Spanderen
 Copyright (C) 2015 Johannes GÃ¶ttker-Schnetmann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmhestonop.hpp
    \brief Heston linear operator
*/

#ifndef quantlib_fdm_heston_op_hpp
#define quantlib_fdm_heston_op_hpp

#include <ql/processes/hestonprocess.hpp>
#include <ql/methods/finitedifferences/utilities/fdmquantohelper.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/ninepointlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>

namespace QuantLib {

    class FdmHestonEquityPart {
      public:
        FdmHestonEquityPart(const ext::shared_ptr<FdmMesher>& mesher,
                            ext::shared_ptr<YieldTermStructure> rTS,
                            ext::shared_ptr<YieldTermStructure> qTS,
                            ext::shared_ptr<FdmQuantoHelper> quantoHelper,
                            ext::shared_ptr<LocalVolTermStructure> leverageFct =
                                ext::shared_ptr<LocalVolTermStructure>());

        void setTime(Time t1, Time t2);
        const TripleBandLinearOp& getMap() const;
        const Array& getL() const { return L_; }

      protected:
        Disposable<Array> getLeverageFctSlice(Time t1, Time t2) const;

        Array varianceValues_, volatilityValues_, L_;
        const FirstDerivativeOp  dxMap_;
        const TripleBandLinearOp dxxMap_;
        TripleBandLinearOp mapT_;

        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<YieldTermStructure> rTS_, qTS_;
        const ext::shared_ptr<FdmQuantoHelper> quantoHelper_;
        const ext::shared_ptr<LocalVolTermStructure> leverageFct_;
    };

    class FdmHestonVariancePart {
      public:
        FdmHestonVariancePart(const ext::shared_ptr<FdmMesher>& mesher,
                              ext::shared_ptr<YieldTermStructure> rTS,
                              Real mixedSigma,
                              Real kappa,
                              Real theta);

        void setTime(Time t1, Time t2);
        const TripleBandLinearOp& getMap() const;

      protected:
        const TripleBandLinearOp dyMap_;
        TripleBandLinearOp mapT_;

        const ext::shared_ptr<YieldTermStructure> rTS_;
    };


    class FdmHestonOp : public FdmLinearOpComposite {
      public:
        FdmHestonOp(const ext::shared_ptr<FdmMesher>& mesher,
                    const ext::shared_ptr<HestonProcess>& hestonProcess,
                    const ext::shared_ptr<FdmQuantoHelper>& quantoHelper =
                        ext::shared_ptr<FdmQuantoHelper>(),
                    const ext::shared_ptr<LocalVolTermStructure>& leverageFct =
                        ext::shared_ptr<LocalVolTermStructure>(),
                    Real mixingFactor = 1.0);

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Disposable<Array> apply(const Array& r) const override;
        Disposable<Array> apply_mixed(const Array& r) const override;

        Disposable<Array> apply_direction(Size direction, const Array& r) const override;
        Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
        Disposable<Array> preconditioner(const Array& r, Real s) const override;

        Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;

      private:
        NinePointLinearOp correlationMap_;
        FdmHestonVariancePart dyMap_;
        FdmHestonEquityPart dxMap_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="40">
    <source>operators/fdmhullwhiteop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmhullwhiteop.hpp
    \brief FDM operator for the Hull-White interest rate model
*/

#ifndef quantlib_fdm_hull_white_op_hpp
#define quantlib_fdm_hull_white_op_hpp

#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>

namespace QuantLib {

    class FdmMesher;
    class HullWhite;

    class FdmHullWhiteOp : public FdmLinearOpComposite {
      public:

        FdmHullWhiteOp(
            const ext::shared_ptr<FdmMesher>& mesher,
            const ext::shared_ptr<HullWhite>& model,
            Size direction);

        Size size() const override;

        //! Time \f$t1 <= t2\f$ is required
        void setTime(Time t1, Time t2) override;

        Disposable<Array> apply(const Array& r) const override;
        Disposable<Array> apply_mixed(const Array& r) const override;
        Disposable<Array> apply_direction(Size direction, const Array& r) const override;
        Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
        Disposable<Array> preconditioner(const Array& r, Real s) const override;

        Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;

      private:
        const Size direction_;
        const Array x_;
        const TripleBandLinearOp dzMap_;
        TripleBandLinearOp mapT_;
        const ext::shared_ptr<HullWhite> model_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="41">
    <source>operators/fdmlinearop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmlinearop.hpp
    \brief linear operator to model a multi dimensinal pde system
*/

#ifndef quantlib_fdm_linear_op_hpp
#define quantlib_fdm_linear_op_hpp

#include <ql/math/array.hpp>
#include <ql/math/matrixutilities/sparsematrix.hpp>

namespace QuantLib {

    class FdmLinearOp {
      public:
        typedef Array array_type;
        virtual ~FdmLinearOp() = default;
        virtual Disposable<array_type> apply(const array_type& r) const = 0;

        virtual Disposable<SparseMatrix> toMatrix() const = 0;
    };
}

#endif
]]></document_content>
  </document>
  <document index="42">
    <source>operators/fdmlinearopcomposite.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008, 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmlinearopcomposite.hpp
    \brief composite pattern for linear operators
*/

#ifndef quantlib_fdm_affine_map_composite_hpp
#define quantlib_fdm_affine_map_composite_hpp

#include <ql/math/matrixutilities/sparsematrix.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearop.hpp>
#include <numeric>

namespace QuantLib {

    class FdmLinearOpComposite : public FdmLinearOp {
      public:
        virtual Size size() const = 0;

        //! Time \f$t1 <= t2\f$ is required
        virtual void setTime(Time t1, Time t2) = 0;

        virtual Disposable<Array> apply_mixed(const Array& r) const = 0;
        
        virtual Disposable<Array> 
            apply_direction(Size direction, const Array& r) const = 0;
        virtual Disposable<Array> 
            solve_splitting(Size direction, const Array& r, Real s) const = 0;
        virtual Disposable<Array> 
            preconditioner(const Array& r, Real s) const = 0;

        virtual Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const {
            QL_FAIL(" ublas representation is not implemented");
        }

        Disposable<SparseMatrix> toMatrix() const override {
            const std::vector<SparseMatrix> dcmp = toMatrixDecomp();
            SparseMatrix retVal = std::accumulate(dcmp.begin()+1, dcmp.end(),
                                                  SparseMatrix(dcmp.front()));
            return retVal;
        }

    };
}

#endif
]]></document_content>
  </document>
  <document index="43">
    <source>operators/fdmlinearopiterator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmlinearopiterator.hpp
    \brief iterator for a linear fdm operator
*/

#ifndef quantlib_linear_op_iterator_hpp
#define quantlib_linear_op_iterator_hpp

#include <ql/types.hpp>
#include <ql/utilities/disposable.hpp>
#include <numeric>
#include <utility>
#include <vector>

namespace QuantLib {

    class FdmLinearOpIterator {
      public:
        explicit FdmLinearOpIterator(Size index = 0)
        : index_(index) {}

        explicit FdmLinearOpIterator(const std::vector<Size>& dim)
        : index_(0),
          dim_(dim),
          coordinates_(dim.size(), 0) {}

        FdmLinearOpIterator(std::vector<Size> dim, std::vector<Size> coordinates, Size index)
        : index_(index), dim_(std::move(dim)), coordinates_(std::move(coordinates)) {}

        FdmLinearOpIterator(
            const Disposable<FdmLinearOpIterator> & from) {
            swap(const_cast<Disposable<FdmLinearOpIterator> & >(from));
        }

        void operator++() {
            ++index_;
            for (Size i=0; i < dim_.size(); ++i) {
                if (++coordinates_[i] == dim_[i]) {
                    coordinates_[i] = 0;
                }
                else {
                    break;
                }
            }
        }

        bool operator!=(const FdmLinearOpIterator& iterator) const {
            return index_ != iterator.index_;
        }

        Size index() const {
            return index_;
        }

        const std::vector<Size> & coordinates() const {
            return coordinates_;
        }

        void swap(FdmLinearOpIterator& iter) {
            std::swap(iter.index_, index_);
            dim_.swap(iter.dim_);
            coordinates_.swap(iter.coordinates_);
        }

      private:
        Size index_;
        std::vector<Size> dim_;
        std::vector<Size> coordinates_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="44">
    <source>operators/fdmlinearoplayout.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmlinearoplayout.hpp
    \brief memory layout of a fdm linear operator
*/

#ifndef quantlib_linear_op_layout_hpp
#define quantlib_linear_op_layout_hpp

#include <ql/methods/finitedifferences/operators/fdmlinearopiterator.hpp>
#include <functional>

namespace QuantLib {

    class FdmLinearOpLayout {
      public:
        explicit FdmLinearOpLayout(const std::vector<Size>& dim)
        : dim_(dim), spacing_(dim.size()) {
            spacing_[0] = 1;
            std::partial_sum(dim.begin(), dim.end()-1,
                spacing_.begin()+1, std::multiplies<Size>());

            size_ = spacing_.back()*dim.back();
        }

        FdmLinearOpIterator begin() const {
            return FdmLinearOpIterator(dim_);
        }

        FdmLinearOpIterator end() const {
            return FdmLinearOpIterator(size_);
        }

        const std::vector<Size>& dim() const {
            return dim_;
        }

        const std::vector<Size>& spacing() const {
            return spacing_;
        }

        Size size() const {
            return size_;
        }

        Size index(const std::vector<Size>& coordinates) const {
            return std::inner_product(coordinates.begin(),
                                      coordinates.end(),
                                      spacing_.begin(), Size(0));
        }

        Size neighbourhood(const FdmLinearOpIterator& iterator,
                           Size i, Integer offset) const;

        Size neighbourhood(const FdmLinearOpIterator& iterator,
                           Size i1, Integer offset1,
                           Size i2, Integer offset2) const;

        // smart but sometimes too slow
        Disposable<FdmLinearOpIterator> iter_neighbourhood(
            const FdmLinearOpIterator& iterator, Size i, Integer offset) const;

      private:
        Size size_;
        std::vector<Size> dim_, spacing_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="45">
    <source>operators/fdmlocalvolfwdop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes GÃ¶ttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen


 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmlocalvolfwdop.hpp
    \brief local volatility linear operator for the Fokker-Planck forward equation
*/

#ifndef quantlib_fdm_local_vol_fwd_op_hpp
#define quantlib_fdm_local_vol_fwd_op_hpp

#include <ql/processes/blackscholesprocess.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>

namespace QuantLib {

    class FdmLocalVolFwdOp : public FdmLinearOpComposite {
      public:
        FdmLocalVolFwdOp(const ext::shared_ptr<FdmMesher>& mesher,
                         const ext::shared_ptr<Quote>& spot,
                         ext::shared_ptr<YieldTermStructure> rTS,
                         ext::shared_ptr<YieldTermStructure> qTS,
                         const ext::shared_ptr<LocalVolTermStructure>& localVol,
                         Size direction = 0);

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Disposable<Array> apply(const Array& r) const override;
        Disposable<Array> apply_mixed(const Array& r) const override;
        Disposable<Array> apply_direction(Size direction, const Array& r) const override;
        Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
        Disposable<Array> preconditioner(const Array& r, Real s) const override;

        Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;

      private:
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<YieldTermStructure> rTS_, qTS_;
        const ext::shared_ptr<LocalVolTermStructure> localVol_;
        const Array x_;
        const FirstDerivativeOp  dxMap_;
        const TripleBandLinearOp dxxMap_;
        TripleBandLinearOp mapT_;
        const Size direction_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="46">
    <source>operators/fdmornsteinuhlenbeckop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmornsteinuhlenbeckop.hpp
    \brief Ornstein Uhlenbeck process
*/

#ifndef quantlib_fdm_ornstein_uhlenback_op_hpp
#define quantlib_fdm_ornstein_uhlenback_op_hpp

#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmboundaryconditionset.hpp>


namespace QuantLib {

    class FdmMesher;
    class YieldTermStructure;
    class OrnsteinUhlenbeckProcess;

    class FdmOrnsteinUhlenbeckOp : public FdmLinearOpComposite {
      public:
        FdmOrnsteinUhlenbeckOp(const ext::shared_ptr<FdmMesher>& mesher,
                               ext::shared_ptr<OrnsteinUhlenbeckProcess> p,
                               ext::shared_ptr<YieldTermStructure> rTS,
                               Size direction = 0);

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Disposable<Array> apply(const Array& r) const override;
        Disposable<Array> apply_mixed(const Array& r) const override;

        Disposable<Array> apply_direction(Size direction, const Array& r) const override;
        Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
        Disposable<Array> preconditioner(const Array& r, Real s) const override;

        Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;

      private:
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<OrnsteinUhlenbeckProcess> process_;
        const ext::shared_ptr<YieldTermStructure> rTS_;
        const Size direction_;

        TripleBandLinearOp m_, mapX_;
    };

}
#endif
]]></document_content>
  </document>
  <document index="47">
    <source>operators/fdmsabrop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmsabrop.hpp
    \brief FDM operator for the SABR model
*/

#ifndef quantlib_fdm_sabr_op_hpp
#define quantlib_fdm_sabr_op_hpp

#include <ql/methods/finitedifferences/operators/ninepointlinearop.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>

namespace QuantLib {

    //! SABR model with absorbing boundary at f=0
    /*! \f[
         df_t = \alpha_t f_t^\beta \mathrm{d}W_t  \\
         d\alpha_t = \nu \alpha_t \mathrm{d}Z_t \\
         \rho \mathrm{d}t = < \mathrm{d}W_t, \mathrm{d}Z_t >
        \f]
    */


    class FdmMesher;
    class YieldTermStructure;

    class FdmSabrOp : public FdmLinearOpComposite {
      public:
        FdmSabrOp(const ext::shared_ptr<FdmMesher>& mesher,
                  ext::shared_ptr<YieldTermStructure> rTS,
                  Real f0,
                  Real alpha,
                  Real beta,
                  Real nu,
                  Real rho);

        Size size() const override;
        void setTime(Time t1, Time t2) override;

        Disposable<Array> apply(const Array& r) const override;
        Disposable<Array> apply_mixed(const Array& r) const override;
        Disposable<Array> apply_direction(Size direction, const Array& r) const override;
        Disposable<Array> solve_splitting(Size direction, const Array& r, Real s) const override;
        Disposable<Array> preconditioner(const Array& r, Real s) const override;

        Disposable<std::vector<SparseMatrix> > toMatrixDecomp() const override;

      private:
        const ext::shared_ptr<YieldTermStructure> rTS_;

        const TripleBandLinearOp dffMap_;
        const TripleBandLinearOp dxMap_, dxxMap_;
        const NinePointLinearOp correlationMap_;

        TripleBandLinearOp mapF_, mapA_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="48">
    <source>operators/firstderivativeop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file firstderivativeop.hpp
    \brief first derivative linear operator
*/

#ifndef quantlib_first_derivative_op_hpp
#define quantlib_first_derivative_op_hpp

#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>

namespace QuantLib {

    class FirstDerivativeOp : public TripleBandLinearOp {
      public:
        FirstDerivativeOp(Size direction,
                          const ext::shared_ptr<FdmMesher>& mesher);
    };

}

#endif
]]></document_content>
  </document>
  <document index="49">
    <source>operators/ninepointlinearop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file ninepointlinearop.hpp
    \brief nine point linear operator
*/

#ifndef quantlib_nine_point_linear_op_hpp
#define quantlib_nine_point_linear_op_hpp

#include <ql/math/matrixutilities/sparsematrix.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearop.hpp>
#if !defined(QL_USE_STD_UNIQUE_PTR)
#include <boost/shared_array.hpp>
#endif
#include <memory>

namespace QuantLib {

    class FdmMesher;

    class NinePointLinearOp : public FdmLinearOp {
      public:
        NinePointLinearOp(Size d0, Size d1,
                const ext::shared_ptr<FdmMesher>& mesher);
        NinePointLinearOp(const NinePointLinearOp& m);
        NinePointLinearOp(NinePointLinearOp&& m) QL_NOEXCEPT;
        #ifdef QL_USE_DISPOSABLE
        NinePointLinearOp(const Disposable<NinePointLinearOp>& m);
        #endif
        NinePointLinearOp& operator=(const NinePointLinearOp& m);
        NinePointLinearOp& operator=(NinePointLinearOp&& m) QL_NOEXCEPT;
        #ifdef QL_USE_DISPOSABLE
        NinePointLinearOp& operator=(const Disposable<NinePointLinearOp>& m);
        #endif

        Disposable<Array> apply(const Array& r) const override;
        Disposable<NinePointLinearOp> mult(const Array& u) const;

        void swap(NinePointLinearOp& m);

        Disposable<SparseMatrix> toMatrix() const override;

      protected:
        NinePointLinearOp() = default;

        Size d0_, d1_;
        #if !defined(QL_USE_STD_UNIQUE_PTR)
        boost::shared_array<Size> i00_, i10_, i20_;
        boost::shared_array<Size> i01_, i21_;
        boost::shared_array<Size> i02_, i12_, i22_;
        boost::shared_array<Real> a00_, a10_, a20_;
        boost::shared_array<Real> a01_, a11_, a21_;
        boost::shared_array<Real> a02_, a12_, a22_;
        #else
        std::unique_ptr<Size[]> i00_, i10_, i20_;
        std::unique_ptr<Size[]> i01_, i21_;
        std::unique_ptr<Size[]> i02_, i12_, i22_;
        std::unique_ptr<Real[]> a00_, a10_, a20_;
        std::unique_ptr<Real[]> a01_, a11_, a21_;
        std::unique_ptr<Real[]> a02_, a12_, a22_;
        #endif

        ext::shared_ptr<FdmMesher> mesher_;
    };


    inline NinePointLinearOp::NinePointLinearOp(NinePointLinearOp&& m) QL_NOEXCEPT {
        swap(m);
    }

    inline NinePointLinearOp& NinePointLinearOp::operator=(const NinePointLinearOp& m) {
        NinePointLinearOp temp(m);
        swap(temp);
        return *this;
    }

    inline NinePointLinearOp& NinePointLinearOp::operator=(NinePointLinearOp&& m) QL_NOEXCEPT {
        swap(m);
        return *this;
    }

}

#endif
]]></document_content>
  </document>
  <document index="50">
    <source>operators/nthorderderivativeop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file nthorderderivativeop.hpp
    \brief n-th order derivative linear operator
*/

#ifndef quantlib_nth_order_derivative_op_hpp
#define quantlib_nth_order_derivative_op_hpp

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearop.hpp>

namespace QuantLib {

    class NthOrderDerivativeOp : public FdmLinearOp {
      public:
        NthOrderDerivativeOp(
            Size direction, Size order, Integer nPoints,
            const ext::shared_ptr<FdmMesher>& mesher);

        Disposable<array_type> apply(const array_type& r) const override;
        Disposable<SparseMatrix> toMatrix() const override;

      private:
        SparseMatrix m_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="51">
    <source>operators/numericaldifferentiation.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file numericaldifferentiation.hpp
    \brief numerical differentiation of arbitrary order
           and on irregular grids
*/

#ifndef quantlib_numerical_differentiation_hpp
#define quantlib_numerical_differentiation_hpp

#include <ql/math/array.hpp>
#include <ql/functional.hpp>

namespace QuantLib {

    //! Numerical Differentiation on arbitrarily spaced grids

    /*! References:

        B. Fornberg, 1988. Generation of Finite Difference Formulas
        on Arbitrarily Spaced Grids,
        http://amath.colorado.edu/faculty/fornberg/Docs/MathComp_88_FD_formulas.pdf
    */
    class NumericalDifferentiation {
      public:
        typedef Real argument_type;
        typedef Real result_type;

        enum Scheme { Central, Backward, Forward };

        NumericalDifferentiation(ext::function<Real(Real)> f,
                                 Size orderOfDerivative,
                                 Array x_offsets);

        NumericalDifferentiation(ext::function<Real(Real)> f,
                                 Size orderOfDerivative,
                                 Real stepSize,
                                 Size steps,
                                 Scheme scheme);

        Real operator()(Real x) const;
        const Array& offsets() const;
        const Array& weights() const;

      private:
        const Array offsets_, w_;
        const ext::function<Real(Real)> f_;
    };


    inline Real NumericalDifferentiation::operator()(Real x) const {
        Real s = 0.0;
        for (Size i=0; i < w_.size(); ++i) {
            if (std::fabs(w_[i]) > QL_EPSILON*QL_EPSILON) {
                s += w_[i] * f_(x+offsets_[i]);
            }
        }
        return s;
    }

    inline const Array& NumericalDifferentiation::weights() const {
        return w_;
    }

    inline const Array& NumericalDifferentiation::offsets() const {
        return offsets_;
    }
}


#endif

]]></document_content>
  </document>
  <document index="52">
    <source>operators/secondderivativeop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file secondderivativeop.hpp
    \brief second derivative operator
*/

#ifndef quantlib_second_derivative_op_hpp
#define quantlib_second_derivative_op_hpp

#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>

namespace QuantLib {

    class SecondDerivativeOp : public TripleBandLinearOp {
    public:
        SecondDerivativeOp(Size direction,
            const ext::shared_ptr<FdmMesher>& mesher);
    };
}

#endif
]]></document_content>
  </document>
  <document index="53">
    <source>operators/secondordermixedderivativeop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file secondordermixedderivativeop.hpp
    \brief second order mixed derivative linear operator
*/

#ifndef quantlib_second_order_mixed_derivative_hpp
#define quantlib_second_order_mixed_derivative_hpp

#include <ql/methods/finitedifferences/operators/ninepointlinearop.hpp>

namespace QuantLib {

    class SecondOrderMixedDerivativeOp : public NinePointLinearOp {
    public:
        SecondOrderMixedDerivativeOp(
            Size d0, Size d1, const ext::shared_ptr<FdmMesher>& mesher);
    };
}

#endif
]]></document_content>
  </document>
  <document index="54">
    <source>operators/triplebandlinearop.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen
 Copyright (C) 2014 Johannes GÃ¶ttker-Schnetmann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file triplebandlinearop.hpp
    \brief general triple band linear operator
*/

#ifndef quantlib_triple_band_linear_op_hpp
#define quantlib_triple_band_linear_op_hpp

#include <ql/methods/finitedifferences/operators/fdmlinearop.hpp>
#if !defined(QL_USE_STD_UNIQUE_PTR)
#include <boost/shared_array.hpp>
#endif
#include <memory>

namespace QuantLib {

    class FdmMesher;
    
    class TripleBandLinearOp : public FdmLinearOp {
      public:
        TripleBandLinearOp(Size direction,
                           const ext::shared_ptr<FdmMesher>& mesher);

        TripleBandLinearOp(const TripleBandLinearOp& m);
        TripleBandLinearOp(TripleBandLinearOp&& m) QL_NOEXCEPT;
        #ifdef QL_USE_DISPOSABLE
        TripleBandLinearOp(const Disposable<TripleBandLinearOp>& m);
        #endif
        TripleBandLinearOp& operator=(const TripleBandLinearOp& m);
        TripleBandLinearOp& operator=(TripleBandLinearOp&& m) QL_NOEXCEPT;
        #ifdef QL_USE_DISPOSABLE
        TripleBandLinearOp& operator=(const Disposable<TripleBandLinearOp>& m);
        #endif

        Disposable<Array> apply(const Array& r) const override;
        Disposable<Array> solve_splitting(const Array& r, Real a,
                                          Real b = 1.0) const;

        Disposable<TripleBandLinearOp> mult(const Array& u) const;
        // interpret u as the diagonal of a diagonal matrix, multiplied on LHS
        Disposable<TripleBandLinearOp> multR(const Array& u) const;
        // interpret u as the diagonal of a diagonal matrix, multiplied on RHS
        Disposable<TripleBandLinearOp> add(const TripleBandLinearOp& m) const;
        Disposable<TripleBandLinearOp> add(const Array& u) const;

        // some very basic linear algebra routines
        void axpyb(const Array& a, const TripleBandLinearOp& x,
                   const TripleBandLinearOp& y, const Array& b);

        void swap(TripleBandLinearOp& m);

        Disposable<SparseMatrix> toMatrix() const override;

      protected:
        TripleBandLinearOp() = default;

        Size direction_;
        #if !defined(QL_USE_STD_UNIQUE_PTR)
        boost::shared_array<Size> i0_, i2_;
        boost::shared_array<Size> reverseIndex_;
        boost::shared_array<Real> lower_, diag_, upper_;
        #else
        std::unique_ptr<Size[]> i0_, i2_;
        std::unique_ptr<Size[]> reverseIndex_;
        std::unique_ptr<Real[]> lower_, diag_, upper_;
        #endif

        ext::shared_ptr<FdmMesher> mesher_;
    };


    inline TripleBandLinearOp::TripleBandLinearOp(TripleBandLinearOp&& m) QL_NOEXCEPT {
        swap(m);
    }

    inline TripleBandLinearOp& TripleBandLinearOp::operator=(const TripleBandLinearOp& m) {
        TripleBandLinearOp tmp(m);
        swap(tmp);
        return *this;
    }

    inline TripleBandLinearOp& TripleBandLinearOp::operator=(TripleBandLinearOp&& m) QL_NOEXCEPT {
        swap(m);
        return *this;
    }

}

#endif
]]></document_content>
  </document>
  <document index="55">
    <source>operatortraits.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/*
 Copyright (C) 2005 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file operatortraits.hpp
    \brief Differential operator traits
*/

#ifndef quantlib_operator_traits_hpp
#define quantlib_operator_traits_hpp

#include <ql/methods/finitedifferences/boundarycondition.hpp>
#include <ql/methods/finitedifferences/stepcondition.hpp>
#include <vector>

namespace QuantLib {

    template <class Operator>
    class OperatorTraits {
      public:
        typedef Operator operator_type;
        typedef typename Operator::array_type array_type;
        typedef BoundaryCondition<operator_type> bc_type;
        typedef std::vector<ext::shared_ptr<bc_type> > bc_set;
        typedef StepCondition<array_type> condition_type;
    };

}


#endif

]]></document_content>
  </document>
  <document index="56">
    <source>parallelevolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file parallelevolver.hpp
    \brief Parallel evolver for multiple arrays

    This class takes the evolver class and creates a new class which evolves
    each of the evolvers in parallel.  Part of what this does is to take the 
    types for each evolver class and then wrapper them so that they create
    new types which are sets of the old types.

    This class is intended to be run in situations where there are parallel
    differential equations such as with some convertible bond models.
*/

#ifndef quantlib_system_evolver_hpp
#define quantlib_system_evolver_hpp

#include <ql/methods/finitedifferences/finitedifferencemodel.hpp>
#include <ql/methods/finitedifferences/stepcondition.hpp>
#include <ql/numericalmethod.hpp>
#include <vector>

namespace QuantLib {

    //! Parallel evolver for multiple arrays
    /*! \ingroup findiff */

    template <typename array_type>
    class StepConditionSet {
        typedef ext::shared_ptr<StepCondition<array_type> > itemType;
        std::vector<itemType> stepConditions_;
      public:
        void applyTo(std::vector<array_type>& a, Time t) const {
            //#pragma omp parallel for
            for (Size i=0; i < stepConditions_.size(); i++) {
                stepConditions_[i]->applyTo(a[i], t);
            }
        }
        void push_back(const itemType& a) {
            stepConditions_.push_back(a);
        }
    };

    template <typename bc_set>
    class BoundaryConditionSet {
        std::vector<bc_set> bcSet_;
      public:
        void push_back(const bc_set& a) {
            bcSet_.push_back(a);
        }
        const bc_set& operator[](Size i) const {
            return bcSet_[i];
        }
    };

    template <typename traits>
    class ParallelEvolverTraits {
      public:
        typedef std::vector<typename traits::array_type> array_type;
        typedef std::vector<typename traits::operator_type> operator_type;
        typedef std::vector<typename traits::bc_type> bc_type;
        typedef BoundaryConditionSet<typename traits::bc_set> bc_set;
        typedef StepConditionSet<typename traits::array_type> condition_type;
    };

    template <class Evolver>
    class ParallelEvolver  {
      public:
        // typedefs
        typedef ParallelEvolverTraits<typename Evolver::traits> traits;
        typedef typename traits::operator_type operator_type;
        typedef typename traits::array_type array_type;
        typedef typename traits::bc_set bc_set;
        // constructors
        ParallelEvolver(const operator_type& L,
                        const bc_set& bcs) {
            evolvers_.reserve(L.size());
            for (Size i=0; i < L.size(); i++) {
                evolvers_.push_back(ext::shared_ptr<Evolver>(new
                    Evolver(L[i], bcs[i])));
            }
        }
        void step(array_type& a,
                  Time t) {
            //#pragma omp parallel for
            for (Size i=0; i < evolvers_.size(); i++) {
                evolvers_[i]->step(a[i], t);
            }
        }
        void setStep(Time dt) {
            for (Size i=0; i < evolvers_.size(); i++) {
                evolvers_[i]->setStep(dt);
            }
        }
      private:
        std::vector<ext::shared_ptr<Evolver> > evolvers_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="57">
    <source>pde.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file pde.hpp
    \brief General class for one dimensional PDE's
*/

#ifndef quantlib_pde_hpp
#define quantlib_pde_hpp

#include <ql/math/array.hpp>
#include <ql/methods/finitedifferences/tridiagonaloperator.hpp>
#include <ql/math/transformedgrid.hpp>

namespace QuantLib {
    class PdeSecondOrderParabolic {
    public:
      virtual ~PdeSecondOrderParabolic() = default;
      virtual Real diffusion(Time t, Real x) const = 0;
      virtual Real drift(Time t, Real x) const = 0;
      virtual Real discount(Time t, Real x) const = 0;
      virtual void
      generateOperator(Time t, const TransformedGrid& tg, TridiagonalOperator& L) const {
          for (Size i = 1; i < tg.size() - 1; i++) {
              Real sigma = diffusion(t, tg.grid(i));
              Real nu = drift(t, tg.grid(i));
              Real r = discount(t, tg.grid(i));
              Real sigma2 = sigma * sigma;

              Real pd = -(sigma2 / tg.dxm(i) - nu) / tg.dx(i);
              Real pu = -(sigma2 / tg.dxp(i) + nu) / tg.dx(i);
              Real pm = sigma2 / (tg.dxm(i) * tg.dxp(i)) + r;
              L.setMidRow(i, pd, pm, pu);
          }
        }
    };

    template <class PdeClass>
    class PdeConstantCoeff : public PdeSecondOrderParabolic  {
    public:
        PdeConstantCoeff(const typename PdeClass::argument_type &process,
                         Time t, Real x) {
            PdeClass pde(process);
            diffusion_ = pde.diffusion(t, x);
            drift_ = pde.drift(t, x);
            discount_ = pde.discount(t, x);
        }
        Real diffusion(Time, Real) const override { return diffusion_; }
        Real drift(Time, Real) const override { return drift_; }
        Real discount(Time, Real) const override { return discount_; }

      private:
        Real diffusion_;
        Real drift_;
        Real discount_;
    };

    template <class PdeClass>
    class GenericTimeSetter:public TridiagonalOperator::TimeSetter {
    public:
        template <class T>
        GenericTimeSetter(const Array &grid, T process) :
            grid_(grid), pde_(process) {}
        void setTime(Time t, TridiagonalOperator& L) const override {
            pde_.generateOperator(t, grid_, L);
        }

    private:
        typename PdeClass::grid_type grid_;
        PdeClass pde_;
    };

    template <class PdeClass>
    class PdeOperator:public TridiagonalOperator {
    public:
        template <class T>
        PdeOperator(const Array& grid,
                    T process,
                    Time residualTime = 0.0) :
            TridiagonalOperator(grid.size()) {
            timeSetter_ =
                ext::shared_ptr<GenericTimeSetter<PdeClass> >(
                     new GenericTimeSetter<PdeClass>(grid, process));
            setTime(residualTime);
        }
    };
}


#endif
]]></document_content>
  </document>
  <document index="58">
    <source>pdebsm.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file pdebsm.hpp
    \brief Black-Scholes-Merton PDE
*/

#ifndef quantlib_pdebsm_hpp
#define quantlib_pdebsm_hpp

#include <ql/methods/finitedifferences/pde.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    class PdeBSM : public PdeSecondOrderParabolic {
      public:
        typedef ext::shared_ptr<GeneralizedBlackScholesProcess>
                                                                argument_type;
        typedef LogGrid grid_type;
        PdeBSM(argument_type process) : process_(std::move(process)){};
        Real diffusion(Time t, Real x) const override { return process_->diffusion(t, x); }
        Real drift(Time t, Real x) const override { return process_->drift(t, x); }
        Real discount(Time t, Real) const override {
            if (std::fabs(t) < 1e-8) t = 0;
            return process_->riskFreeRate()->
                forwardRate(t,t,Continuous,NoFrequency,true);
        }

    private:
        const argument_type process_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="59">
    <source>pdeshortrate.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file pdeshortrate.hpp
    \brief adapter to short rate
*/

#ifndef quantlib_pdeshortrate_hpp
#define quantlib_pdeshortrate_hpp

#include <ql/methods/finitedifferences/pde.hpp>
#include <ql/models/shortrate/onefactormodel.hpp>
#include <ql/stochasticprocess.hpp>
#include <utility>

namespace QuantLib {

    class PdeShortRate : public PdeSecondOrderParabolic {
      public:
        typedef ext::shared_ptr<OneFactorModel::ShortRateDynamics>
                                                                argument_type;
        typedef TransformedGrid grid_type;
        PdeShortRate(argument_type d) : dynamics_(std::move(d)) {}
        Real diffusion(Time t, Real x) const override {
            return dynamics_->process()->diffusion(t, x);
        }
        Real drift(Time t, Real x) const override { return dynamics_->process()->drift(t, x); }
        Real discount(Time t, Real x) const override { return dynamics_->shortRate(t, x); }

      private:
        const argument_type dynamics_;
    };

}


#endif

]]></document_content>
  </document>
  <document index="60">
    <source>schemes/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/methods/finitedifferences/schemes/boundaryconditionschemehelper.hpp>
#include <ql/methods/finitedifferences/schemes/craigsneydscheme.hpp>
#include <ql/methods/finitedifferences/schemes/cranknicolsonscheme.hpp>
#include <ql/methods/finitedifferences/schemes/douglasscheme.hpp>
#include <ql/methods/finitedifferences/schemes/expliciteulerscheme.hpp>
#include <ql/methods/finitedifferences/schemes/hundsdorferscheme.hpp>
#include <ql/methods/finitedifferences/schemes/impliciteulerscheme.hpp>
#include <ql/methods/finitedifferences/schemes/methodoflinesscheme.hpp>
#include <ql/methods/finitedifferences/schemes/modifiedcraigsneydscheme.hpp>
#include <ql/methods/finitedifferences/schemes/trbdf2scheme.hpp>

]]></document_content>
  </document>
  <document index="61">
    <source>schemes/boundaryconditionschemehelper.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


/*! \file boundaryconditionschemehelper.hpp
*/

#ifndef quantlib_boundary_condition_scheme_helper_hpp
#define quantlib_boundary_condition_scheme_helper_hpp

#include <ql/methods/finitedifferences/utilities/fdmboundaryconditionset.hpp>
#include <utility>

namespace QuantLib {

    class BoundaryConditionSchemeHelper {
      public:
        typedef OperatorTraits<FdmLinearOp>::array_type array_type;
        typedef OperatorTraits<FdmLinearOp>::operator_type operator_type;

        explicit BoundaryConditionSchemeHelper(OperatorTraits<FdmLinearOp>::bc_set bcSet)
        : bcSet_(std::move(bcSet)) {}

        void applyBeforeApplying(operator_type& op) const {
            for (const auto& i : bcSet_)
                i->applyBeforeApplying(op);
        }
        void applyBeforeSolving(operator_type& op, array_type& a) const {
            for (const auto& i : bcSet_)
                i->applyBeforeSolving(op, a);
        }
        void applyAfterApplying(array_type& a) const {
            for (const auto& i : bcSet_)
                i->applyAfterApplying(a);
        }
        void applyAfterSolving(array_type& a) const {
            for (const auto& i : bcSet_)
                i->applyAfterSolving(a);
        }
        void setTime(Time t) const {
            for (const auto& i : bcSet_)
                i->setTime(t);
        }

      private:
        BoundaryConditionSchemeHelper() = default;
        OperatorTraits<FdmLinearOp>::bc_set bcSet_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="62">
    <source>schemes/craigsneydscheme.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file craigsneydscheme.hpp
    \brief Craig-Sneyd operator splitting
*/

#ifndef quantlib_craig_sneyd_scheme_hpp
#define quantlib_craig_sneyd_scheme_hpp

#include <ql/methods/finitedifferences/operatortraits.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/schemes/boundaryconditionschemehelper.hpp>

namespace QuantLib {

    class CraigSneydScheme  {
      public:
        // typedefs
        typedef OperatorTraits<FdmLinearOp> traits;
        typedef traits::operator_type operator_type;
        typedef traits::array_type array_type;
        typedef traits::bc_set bc_set;
        typedef traits::condition_type condition_type;

        // constructors
        CraigSneydScheme(Real theta,
                         Real mu,
                         ext::shared_ptr<FdmLinearOpComposite> map,
                         const bc_set& bcSet = bc_set());

        void step(array_type& a, Time t);
        void setStep(Time dt);

      protected:
        Time dt_;
        const Real theta_;
        const Real mu_;
        const ext::shared_ptr<FdmLinearOpComposite> map_;
        const BoundaryConditionSchemeHelper bcSet_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="63">
    <source>schemes/cranknicolsonscheme.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2019 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cranknicolsonscheme.hpp
    \brief Crank-Nicolson scheme
*/

#ifndef quantlib_crank_nicolson_scheme_hpp
#define quantlib_crank_nicolson_scheme_hpp

#include <ql/methods/finitedifferences/schemes/impliciteulerscheme.hpp>

namespace QuantLib {

    /*! In one dimension the Crank-Nicolson scheme is equivalent to the
        Douglas scheme and in higher dimensions it is usually inferior to
        operator splitting methods like Craig-Sneyd or Hundsdorfer-Verwer.
    */
    class ExplicitEulerScheme;

    class CrankNicolsonScheme  {
      public:
        // typedefs
        typedef OperatorTraits<FdmLinearOp> traits;
        typedef traits::operator_type operator_type;
        typedef traits::array_type array_type;
        typedef traits::bc_set bc_set;
        typedef traits::condition_type condition_type;

        // constructors
        CrankNicolsonScheme(
            Real theta,
            const ext::shared_ptr<FdmLinearOpComposite>& map,
            const bc_set& bcSet = bc_set(),
            Real relTol = 1e-8,
            ImplicitEulerScheme::SolverType solverType
                = ImplicitEulerScheme::BiCGstab);

        void step(array_type& a, Time t);
        void setStep(Time dt);

        Size numberOfIterations() const;
      protected:
        Real dt_;
        const Real theta_;
        const ext::shared_ptr<ExplicitEulerScheme> explicit_;
        const ext::shared_ptr<ImplicitEulerScheme> implicit_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="64">
    <source>schemes/douglasscheme.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file douglasscheme.hpp
    \brief Douglas operator splitting
*/

#ifndef quantlib_douglas_scheme_hpp
#define quantlib_douglas_scheme_hpp

#include <ql/methods/finitedifferences/operatortraits.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/schemes/boundaryconditionschemehelper.hpp>

namespace QuantLib {

    class DouglasScheme  {
      public:
        // typedefs
        typedef OperatorTraits<FdmLinearOp> traits;
        typedef traits::operator_type operator_type;
        typedef traits::array_type array_type;
        typedef traits::bc_set bc_set;
        typedef traits::condition_type condition_type;

        // constructors
        DouglasScheme(Real theta,
                      ext::shared_ptr<FdmLinearOpComposite> map,
                      const bc_set& bcSet = bc_set());

        void step(array_type& a, Time t);
        void setStep(Time dt);

      protected:
        Time dt_;
        const Real theta_;
        const ext::shared_ptr<FdmLinearOpComposite> map_;
        const BoundaryConditionSchemeHelper bcSet_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="65">
    <source>schemes/expliciteulerscheme.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andreas Gaida
 Copyright (C) 2009 Ralph Schreyer
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file expliciteulerscheme.hpp
    \brief explicit-Euler scheme
*/

#ifndef quantlib_explicit_euler_scheme_hpp
#define quantlib_explicit_euler_scheme_hpp

#include <ql/methods/finitedifferences/operatortraits.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/schemes/boundaryconditionschemehelper.hpp>

namespace QuantLib {

    class ExplicitEulerScheme  {
      public:
        // typedefs
        typedef OperatorTraits<FdmLinearOp> traits;
        typedef traits::operator_type operator_type;
        typedef traits::array_type array_type;
        typedef traits::bc_set bc_set;
        typedef traits::condition_type condition_type;

        // constructors
        explicit ExplicitEulerScheme(ext::shared_ptr<FdmLinearOpComposite> map,
                                     const bc_set& bcSet = bc_set());

        void step(array_type& a, Time t);
        void setStep(Time dt);

      protected:
        friend class CrankNicolsonScheme;
        void step(array_type& a, Time t, Real theta);

        Time dt_;
        const ext::shared_ptr<FdmLinearOpComposite> map_;
        const BoundaryConditionSchemeHelper bcSet_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="66">
    <source>schemes/hundsdorferscheme.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hundsdorferscheme.hpp
    \brief Hundsdorfer operator splitting
*/


#ifndef quantlib_hundsdorfer_scheme_hpp
#define quantlib_hundsdorfer_scheme_hpp

#include <ql/methods/finitedifferences/operatortraits.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/schemes/boundaryconditionschemehelper.hpp>

#include <vector>

namespace QuantLib {

    class HundsdorferScheme  {
      public:
        // typedefs
        typedef OperatorTraits<FdmLinearOp> traits;
        typedef traits::operator_type operator_type;
        typedef traits::array_type array_type;
        typedef traits::bc_set bc_set;
        typedef traits::condition_type condition_type;

        // constructors
        HundsdorferScheme(Real theta,
                          Real mu,
                          ext::shared_ptr<FdmLinearOpComposite> map,
                          const bc_set& bcSet = bc_set());

        void step(array_type& a, Time t);
        void setStep(Time dt);

      protected:
        Time dt_;
        const Real theta_;
        const Real mu_;

        const ext::shared_ptr<FdmLinearOpComposite> map_;
        const BoundaryConditionSchemeHelper bcSet_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="67">
    <source>schemes/impliciteulerscheme.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andreas Gaida
 Copyright (C) 2009 Ralph Schreyer
 Copyright (C) 2009, 2017 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file impliciteulerscheme.hpp
    \brief Implicit-Euler scheme
*/

#ifndef quantlib_implicit_euler_scheme_hpp
#define quantlib_implicit_euler_scheme_hpp

#include <ql/methods/finitedifferences/operatortraits.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/schemes/boundaryconditionschemehelper.hpp>

namespace QuantLib {

    class ImplicitEulerScheme {
      public:
        enum SolverType { BiCGstab, GMRES };

        // typedefs
        typedef OperatorTraits<FdmLinearOp> traits;
        typedef traits::operator_type operator_type;
        typedef traits::array_type array_type;
        typedef traits::bc_set bc_set;
        typedef traits::condition_type condition_type;

        // constructors
        explicit ImplicitEulerScheme(ext::shared_ptr<FdmLinearOpComposite> map,
                                     const bc_set& bcSet = bc_set(),
                                     Real relTol = 1e-8,
                                     SolverType solverType = BiCGstab);

        void step(array_type& a, Time t);
        void setStep(Time dt);

        Size numberOfIterations() const;
      protected:
        friend class CrankNicolsonScheme;
        void step(array_type& a, Time t, Real theta);

        Disposable<Array> apply(const Array& r, Real theta) const;
          
        Time dt_;
        ext::shared_ptr<Size> iterations_;

        const Real relTol_;
        const ext::shared_ptr<FdmLinearOpComposite> map_;
        const BoundaryConditionSchemeHelper bcSet_;
        const SolverType solverType_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="68">
    <source>schemes/methodoflinesscheme.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file methodoflinesscheme.hpp
    \brief Method of Lines  scheme
*/

#ifndef quantlib_method_of_lines_scheme_hpp
#define quantlib_method_of_lines_scheme_hpp

#include <ql/methods/finitedifferences/operatortraits.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/schemes/boundaryconditionschemehelper.hpp>

namespace QuantLib {

    class MethodOfLinesScheme  {
      public:
        // typedefs
        typedef OperatorTraits<FdmLinearOp> traits;
        typedef traits::operator_type operator_type;
        typedef traits::array_type array_type;
        typedef traits::bc_set bc_set;
        typedef traits::condition_type condition_type;

        // constructors
        MethodOfLinesScheme(Real eps,
                            Real relInitStepSize,
                            ext::shared_ptr<FdmLinearOpComposite> map,
                            const bc_set& bcSet = bc_set());

        void step(array_type& a, Time t);
        void setStep(Time dt);

      protected:
        //apply for QuantLib's Runge-Kutta implementation
        Disposable<std::vector<Real> >
            apply(Time, const std::vector<Real>&) const;

        Time dt_;
        const Real eps_, relInitStepSize_;
        const ext::shared_ptr<FdmLinearOpComposite> map_;
        const BoundaryConditionSchemeHelper bcSet_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="69">
    <source>schemes/modifiedcraigsneydscheme.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file modifiedcraigsneydscheme.hpp
    \brief modified Craig-Sneyd operator splitting
*/

#ifndef quantlib_modified_craig_sneyd_scheme_hpp
#define quantlib_modified_craig_sneyd_scheme_hpp

#include <ql/methods/finitedifferences/operatortraits.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/schemes/boundaryconditionschemehelper.hpp>

namespace QuantLib {
    //! modified Craig-Sneyd scheme

    /*! References:
        K. J. in ât Hout and S. Foulon, 
        ADI finite difference schemes for option pricing in the Heston 
        model with correlation, http://arxiv.org/pdf/0811.3427
    */

    class ModifiedCraigSneydScheme  {
      public:
        // typedefs
        typedef OperatorTraits<FdmLinearOp> traits;
        typedef traits::operator_type operator_type;
        typedef traits::array_type array_type;
        typedef traits::bc_set bc_set;
        typedef traits::condition_type condition_type;

        // constructors
        ModifiedCraigSneydScheme(Real theta,
                                 Real mu,
                                 ext::shared_ptr<FdmLinearOpComposite> map,
                                 const bc_set& bcSet = bc_set());

        void step(array_type& a, Time t);
        void setStep(Time dt);

      protected:
        Time dt_;
        const Real theta_;
        const Real mu_;
        const ext::shared_ptr<FdmLinearOpComposite> map_;
        const BoundaryConditionSchemeHelper bcSet_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="70">
    <source>schemes/trbdf2scheme.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file trbdf2scheme.hpp
    \brief trapezoidal BDF2 scheme
*/

#ifndef quantlib_tr_bdf2_scheme_hpp
#define quantlib_tr_bdf2_scheme_hpp

#include <ql/functional.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/matrixutilities/bicgstab.hpp>
#include <ql/math/matrixutilities/gmres.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearopcomposite.hpp>
#include <ql/methods/finitedifferences/operatortraits.hpp>
#include <ql/methods/finitedifferences/schemes/boundaryconditionschemehelper.hpp>
#include <utility>

namespace QuantLib {

    template <class TrapezoidalScheme>
    class TrBDF2Scheme {
      public:
        enum SolverType { BiCGstab, GMRES };

        // typedefs
        typedef OperatorTraits<FdmLinearOp> traits;
        typedef traits::operator_type operator_type;
        typedef traits::array_type array_type;
        typedef traits::bc_set bc_set;
        typedef traits::condition_type condition_type;

        // constructors
        TrBDF2Scheme(Real alpha,
                     ext::shared_ptr<FdmLinearOpComposite> map,
                     const ext::shared_ptr<TrapezoidalScheme>& trapezoidalScheme,
                     const bc_set& bcSet = bc_set(),
                     Real relTol = 1e-8,
                     SolverType solverType = BiCGstab);

        void step(array_type& a, Time t);
        void setStep(Time dt);

        Size numberOfIterations() const;
      protected:
        Disposable<Array> apply(const Array& r) const;

        Time dt_;
        Real beta_;
        ext::shared_ptr<Size> iterations_;

        const Real alpha_;
        const ext::shared_ptr<FdmLinearOpComposite> map_;
        const ext::shared_ptr<TrapezoidalScheme>& trapezoidalScheme_;
        const BoundaryConditionSchemeHelper bcSet_;
        const Real relTol_;
        const SolverType solverType_;
    };

    template <class TrapezoidalScheme>
    inline TrBDF2Scheme<TrapezoidalScheme>::TrBDF2Scheme(
        Real alpha,
        ext::shared_ptr<FdmLinearOpComposite> map,
        const ext::shared_ptr<TrapezoidalScheme>& trapezoidalScheme,
        const bc_set& bcSet,
        Real relTol,
        SolverType solverType)
    : dt_(Null<Real>()), beta_(Null<Real>()), iterations_(ext::make_shared<Size>(0U)),
      alpha_(alpha), map_(std::move(map)), trapezoidalScheme_(trapezoidalScheme), bcSet_(bcSet),
      relTol_(relTol), solverType_(solverType) {}

    template <class TrapezoidalScheme>
    inline void TrBDF2Scheme<TrapezoidalScheme>::setStep(Time dt) {
        dt_=dt;
        beta_= (1.0-alpha_)/(2.0-alpha_)*dt_;
    }

    template <class TrapezoidalScheme>
    inline Size TrBDF2Scheme<TrapezoidalScheme>::numberOfIterations() const {
        return *iterations_;
    }

    template <class TrapezoidalScheme>
    inline Disposable<Array> TrBDF2Scheme<TrapezoidalScheme>::apply(
        const Array& r) const {
        return r - beta_*map_->apply(r);
    }

    template <class TrapezoidalScheme>
    inline void TrBDF2Scheme<TrapezoidalScheme>::step(array_type& fn, Time t) {
        QL_REQUIRE(t-dt_ > -1e-8, "a step towards negative time given");

        const Time intermediateTimeStep = dt_*alpha_;

        array_type fStar = fn;
        trapezoidalScheme_->setStep(intermediateTimeStep);
        trapezoidalScheme_->step(fStar, t);

        bcSet_.setTime(std::max(0.0, t-dt_));
        bcSet_.applyBeforeSolving(*map_, fn);

        const array_type f =
            (1/alpha_*fStar - square<Real>()(1-alpha_)/alpha_*fn)/(2-alpha_);

        if (map_->size() == 1) {
            fn = map_->solve_splitting(0, f, -beta_);
        }
        else {
            auto preconditioner = [&](const Array& _a){ return map_->preconditioner(_a, -beta_); };
            auto applyF = [&](const Array& _a){ return apply(_a); };

            if (solverType_ == BiCGstab) {
                const BiCGStabResult result =
                    QuantLib::BiCGstab(applyF, std::max(Size(10), fn.size()),
                        relTol_, preconditioner).solve(f, f);

                (*iterations_) += result.iterations;
                fn = result.x;
            } else if (solverType_ == GMRES) {
                const GMRESResult result =
                    QuantLib::GMRES(applyF, std::max(Size(10), fn.size() / 10U), relTol_,
                                    preconditioner)
                        .solve(f, f);

                (*iterations_) += result.errors.size();
                fn = result.x;
            }
            else
                QL_FAIL("unknown/illegal solver type");
        }

        bcSet_.applyAfterSolving(fn);
    }
}

#endif
]]></document_content>
  </document>
  <document index="71">
    <source>shoutcondition.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file shoutcondition.hpp
    \brief shout option exercise condition
*/

#ifndef quantlib_fd_shout_condition_hpp
#define quantlib_fd_shout_condition_hpp

#include <ql/discretizedasset.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/methods/finitedifferences/fdtypedefs.hpp>
#include <utility>

namespace QuantLib {

    //! Shout option condition
    /*! A shout option is an option where the holder has the right to
        lock in a minimum value for the payoff at one (shout) time
        during the option's life. The minimum value is the option's
        intrinsic value at the shout time.
    */
    class ShoutCondition : public StandardStepCondition {
      public:
        ShoutCondition(const Array& intrinsicValues,
                       Time resTime,
                       Rate rate)
        : resTime_(resTime), rate_(rate),
          impl_(new ArrayImpl(intrinsicValues)) {}

        /*! \deprecated Use the other constructor.
                        Deprecated in version 1.19.
        */
        QL_DEPRECATED
        ShoutCondition(Option::Type type,
                       Real strike,
                       Time resTime,
                       Rate rate)
        : resTime_(resTime), rate_(rate),
          impl_(new PayoffImpl(type, strike)) {}

        void applyTo(Array& a, Time t) const override {
            DiscountFactor B = std::exp(-rate_ * (t - resTime_));
            //#pragma omp parallel for
            for (Size i = 0; i < a.size(); i++) {
                a[i] = std::max(a[i], B * impl_->getValue(a, i));
            }
        }

      private:
        Time resTime_;
        Rate rate_;

        // This part should be removed and the array-based implementation
        // inlined once the payoff-based constructor is removed.

        class Impl;

        ext::shared_ptr<Impl> impl_;

        class Impl {
          public:
            virtual ~Impl() = default;
            virtual Real getValue(const Array &a,
                                  int i) = 0;
        };

        class ArrayImpl : public Impl {
          private:
            Array intrinsicValues_;
          public:
            explicit ArrayImpl(Array a) : intrinsicValues_(std::move(a)) {}

            Real getValue(const Array&, int i) override { return intrinsicValues_[i]; }
        };

        class PayoffImpl : public Impl {
          private:
            ext::shared_ptr<const Payoff> payoff_;
          public:
            PayoffImpl(Option::Type type, Real strike)
            : payoff_(new PlainVanillaPayoff(type, strike)) {};

            Real getValue(const Array& a, int i) override { return (*payoff_)(std::exp(a[i])); }
        };
    };

}


#endif
]]></document_content>
  </document>
  <document index="72">
    <source>solvers/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/methods/finitedifferences/solvers/fdm2dblackscholessolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdm1dimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdm2dimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdm3dimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbatessolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmblackscholessolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmg2solver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmhestonhullwhitesolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmhestonsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmcirsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmhullwhitesolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmndimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsimple2dbssolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>

]]></document_content>
  </document>
  <document index="73">
    <source>solvers/fdm1dimsolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdm1dimsolver.hpp
*/

#ifndef quantlib_fdm_1_dim_solver_hpp
#define quantlib_fdm_1_dim_solver_hpp

#include <ql/handle.hpp>
#include <ql/math/matrix.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>


namespace QuantLib {

    class CubicInterpolation;
    class FdmSnapshotCondition;

    class Fdm1DimSolver : public LazyObject {
      public:
        Fdm1DimSolver(const FdmSolverDesc& solverDesc,
                      const FdmSchemeDesc& schemeDesc,
                      ext::shared_ptr<FdmLinearOpComposite> op);

        Real interpolateAt(Real x) const;
        Real thetaAt(Real x) const;

        Real derivativeX(Real x) const;
        Real derivativeXX(Real x) const;

      protected:
        void performCalculations() const override;

      private:
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;
        const ext::shared_ptr<FdmLinearOpComposite> op_;

        const ext::shared_ptr<FdmSnapshotCondition> thetaCondition_;
        const ext::shared_ptr<FdmStepConditionComposite> conditions_;

        std::vector<Real> x_, initialValues_;
        mutable Array resultValues_;
        mutable ext::shared_ptr<CubicInterpolation> interpolation_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="74">
    <source>solvers/fdm2dblackscholessolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdm2dblackscholessolver.hpp
*/

#ifndef quantlib_fdm_2d_black_scholes_solver_hpp
#define quantlib_fdm_2d_black_scholes_solver_hpp

#include <ql/handle.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    class Fdm2DimSolver;
    class GeneralizedBlackScholesProcess;

    class Fdm2dBlackScholesSolver : public LazyObject {
      public:
        Fdm2dBlackScholesSolver(Handle<GeneralizedBlackScholesProcess> p1,
                                Handle<GeneralizedBlackScholesProcess> p2,
                                Real correlation,
                                FdmSolverDesc solverDesc,
                                const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer(),
                                bool localVol = false,
                                Real illegalLocalVolOverwrite = -Null<Real>());

        Real valueAt(Real x, Real y) const;
        Real thetaAt(Real x, Real y) const;

        Real deltaXat(Real x, Real y) const;
        Real deltaYat(Real x, Real y) const;
        Real gammaXat(Real x, Real y) const;
        Real gammaYat(Real x, Real y) const;
        Real gammaXYat(Real x, Real y) const;

      protected:
        void performCalculations() const override;

      private:
        const Handle<GeneralizedBlackScholesProcess> p1_;
        const Handle<GeneralizedBlackScholesProcess> p2_;
        const Real correlation_;
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;
        const bool localVol_;
        const Real illegalLocalVolOverwrite_;

        mutable ext::shared_ptr<Fdm2DimSolver> solver_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="75">
    <source>solvers/fdm2dimsolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdm2dimsolver.hpp
*/

#ifndef quantlib_fdm_2_dim_solver_hpp
#define quantlib_fdm_2_dim_solver_hpp

#include <ql/handle.hpp>
#include <ql/math/matrix.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>


namespace QuantLib {

    class BicubicSpline;
    class FdmSnapshotCondition;

    class Fdm2DimSolver : public LazyObject {
      public:
        Fdm2DimSolver(const FdmSolverDesc& solverDesc,
                      const FdmSchemeDesc& schemeDesc,
                      ext::shared_ptr<FdmLinearOpComposite> op);

        Real interpolateAt(Real x, Real y) const;
        Real thetaAt(Real x, Real y) const;

        Real derivativeX(Real x, Real y) const;
        Real derivativeY(Real x, Real y) const;
        Real derivativeXX(Real x, Real y) const;
        Real derivativeYY(Real x, Real y) const;
        Real derivativeXY(Real x, Real y) const;

      protected:
        void performCalculations() const override;

      private:
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;
        const ext::shared_ptr<FdmLinearOpComposite> op_;

        const ext::shared_ptr<FdmSnapshotCondition> thetaCondition_;
        const ext::shared_ptr<FdmStepConditionComposite> conditions_;

        std::vector<Real> x_, y_, initialValues_;
        mutable Matrix resultValues_;
        mutable ext::shared_ptr<BicubicSpline> interpolation_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="76">
    <source>solvers/fdm3dimsolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdm3dimsolver.hpp
*/

#ifndef quantlib_fdm_3_dim_solver_hpp
#define quantlib_fdm_3_dim_solver_hpp

#include <ql/math/matrix.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>


namespace QuantLib {

    class BicubicSpline;
    class FdmSnapshotCondition;

    class Fdm3DimSolver : public LazyObject {
      public:
        Fdm3DimSolver(const FdmSolverDesc& solverDesc,
                      const FdmSchemeDesc& schemeDesc,
                      ext::shared_ptr<FdmLinearOpComposite> op);

        void performCalculations() const override;

        Real interpolateAt(Real x, Real y, Rate z) const;
        Real thetaAt(Real x, Real y, Rate z) const;

      private:
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;
        const ext::shared_ptr<FdmLinearOpComposite> op_;

        const ext::shared_ptr<FdmSnapshotCondition> thetaCondition_;
        const ext::shared_ptr<FdmStepConditionComposite> conditions_;

        std::vector<Real> x_, y_, z_, initialValues_;
        mutable std::vector<Matrix> resultValues_;
        mutable std::vector<ext::shared_ptr<BicubicSpline> > interpolation_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="77">
    <source>solvers/fdmbackwardsolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andreas Gaida
 Copyright (C) 2009 Ralph Schreyer
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmbackwardsolver.hpp
*/

#ifndef quantlib_fdm_backward_solver_hpp
#define quantlib_fdm_backward_solver_hpp

#include <ql/methods/finitedifferences/utilities/fdmboundaryconditionset.hpp>

namespace QuantLib {

    class FdmLinearOpComposite;
    class FdmStepConditionComposite;

    struct FdmSchemeDesc {
        enum FdmSchemeType { HundsdorferType, DouglasType,
                             CraigSneydType, ModifiedCraigSneydType, 
                             ImplicitEulerType, ExplicitEulerType,
                             MethodOfLinesType, TrBDF2Type,
                             CrankNicolsonType };

        FdmSchemeDesc(FdmSchemeType type, Real theta, Real mu);

        const FdmSchemeType type;
        const Real theta, mu;

        // some default scheme descriptions
        static FdmSchemeDesc Douglas(); //same as Crank-Nicolson in 1 dimension
        static FdmSchemeDesc CrankNicolson();
        static FdmSchemeDesc ImplicitEuler();
        static FdmSchemeDesc ExplicitEuler();
        static FdmSchemeDesc CraigSneyd();
        static FdmSchemeDesc ModifiedCraigSneyd(); 
        static FdmSchemeDesc Hundsdorfer();
        static FdmSchemeDesc ModifiedHundsdorfer();
        static FdmSchemeDesc MethodOfLines(
            Real eps=0.001, Real relInitStepSize=0.01);
        static FdmSchemeDesc TrBDF2();
    };
        
    class FdmBackwardSolver {
      public:
        typedef FdmLinearOp::array_type array_type;

        FdmBackwardSolver(ext::shared_ptr<FdmLinearOpComposite> map,
                          FdmBoundaryConditionSet bcSet,
                          const ext::shared_ptr<FdmStepConditionComposite>& condition,
                          const FdmSchemeDesc& schemeDesc);

        void rollback(array_type& a, 
                      Time from, Time to,
                      Size steps, Size dampingSteps);

      protected:
        const ext::shared_ptr<FdmLinearOpComposite> map_;
        const FdmBoundaryConditionSet bcSet_;
        const ext::shared_ptr<FdmStepConditionComposite> condition_;
        const FdmSchemeDesc schemeDesc_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="78">
    <source>solvers/fdmbatessolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmbatessolver.hpp
*/

#ifndef quantlib_fdm_bates_solver_hpp
#define quantlib_fdm_bates_solver_hpp

#include <ql/handle.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/methods/finitedifferences/utilities/fdmquantohelper.hpp>
#include <ql/methods/finitedifferences/solvers/fdmhestonsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdirichletboundary.hpp>

namespace QuantLib {
    
    class BatesProcess;

    class FdmBatesSolver : public LazyObject {
      public:
        FdmBatesSolver(Handle<BatesProcess> process,
                       FdmSolverDesc solverDesc,
                       const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer(),
                       Size integroIntegrationOrder = 12,
                       Handle<FdmQuantoHelper> quantoHelper = Handle<FdmQuantoHelper>());

        Real valueAt(Real s, Real v) const;
        Real thetaAt(Real s, Real v) const;

        // First and second order derivative with respect to S_t.
        // Please note that this is not the "model implied" delta or gamma.
        // E.g. see Fabio Mercurio, Massimo Morini
        // "A Note on Hedging with Local and Stochastic Volatility Models",
        // http://papers.ssrn.com/sol3/papers.cfm?abstract_id=1294284
        Real deltaAt(Real s, Real v) const;
        Real gammaAt(Real s, Real v) const;

      protected:
        void performCalculations() const override;

      private:
        const Handle<BatesProcess> process_;
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;
        const Size integroIntegrationOrder_;
        const Handle<FdmQuantoHelper> quantoHelper_;

        mutable ext::shared_ptr<Fdm2DimSolver> solver_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="79">
    <source>solvers/fdmblackscholessolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmblackscholessolver.hpp
*/

#ifndef quantlib_fdm_black_scholes_solver_hpp
#define quantlib_fdm_black_scholes_solver_hpp

#include <ql/handle.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/utilities/fdmquantohelper.hpp>

namespace QuantLib {

    class Fdm1DimSolver;
    class FdmSnapshotCondition;
    class GeneralizedBlackScholesProcess;

    class FdmBlackScholesSolver : public LazyObject {
      public:
        FdmBlackScholesSolver(Handle<GeneralizedBlackScholesProcess> process,
                              Real strike,
                              FdmSolverDesc solverDesc,
                              const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas(),
                              bool localVol = false,
                              Real illegalLocalVolOverwrite = -Null<Real>(),
                              Handle<FdmQuantoHelper> quantoHelper = Handle<FdmQuantoHelper>());

        Real valueAt(Real s) const;
        Real deltaAt(Real s) const;
        Real gammaAt(Real s) const;
        Real thetaAt(Real s) const;

      protected:
        void performCalculations() const override;

      private:
        Handle<GeneralizedBlackScholesProcess> process_;
        const Real strike_;
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;
        const bool localVol_;
        const Real illegalLocalVolOverwrite_;
        const Handle<FdmQuantoHelper> quantoHelper_;

        mutable ext::shared_ptr<Fdm1DimSolver> solver_;
    };
}

#endif /* quantlib_fdm_black_scholes_solver_hpp */
]]></document_content>
  </document>
  <document index="80">
    <source>solvers/fdmcirsolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Lew Wei Hao

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmcirsolver.hpp
*/

#ifndef quantlib_fdm_cir_solver_hpp
#define quantlib_fdm_cir_solver_hpp

#include <ql/handle.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdirichletboundary.hpp>
#include <ql/methods/finitedifferences/utilities/fdmquantohelper.hpp>
#include <ql/models/shortrate/onefactormodels/coxingersollross.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/coxingersollrossprocess.hpp>
#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>

namespace QuantLib {

    class HestonProcess;
    class Fdm2DimSolver;

    class FdmCIRSolver : public LazyObject {
      public:
        FdmCIRSolver(Handle<CoxIngersollRossProcess> process,
                     Handle<GeneralizedBlackScholesProcess> bsProcess,
                     FdmSolverDesc solverDesc,
                     const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer(),
                     Real rho = 1.0,
                     Real strike = 1.0);

        Real valueAt(Real s, Real v) const;
        Real deltaAt(Real s, Real v) const;
        Real gammaAt(Real s, Real v) const;
        Real thetaAt(Real s, Real v) const;

      protected:
        void performCalculations() const override;

      private:
        const Handle<GeneralizedBlackScholesProcess> bsProcess_;
        const Handle<CoxIngersollRossProcess> cirProcess_;
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;
        const Real rho_;
        const Real strike_;

        mutable ext::shared_ptr<Fdm2DimSolver> solver_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="81">
    <source>solvers/fdmg2solver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmg2solver.hpp
*/

#ifndef quantlib_fdm_g2_solver_hpp
#define quantlib_fdm_g2_solver_hpp

#include <ql/handle.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    class G2;
    class Fdm2DimSolver;

    class FdmG2Solver : public LazyObject {
      public:
        FdmG2Solver(Handle<G2> model,
                    FdmSolverDesc solverDesc,
                    const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

        Real valueAt(Real x, Real y) const;

      protected:
        void performCalculations() const override;

      private:
        const Handle<G2> model_;
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;

        mutable ext::shared_ptr<Fdm2DimSolver> solver_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="82">
    <source>solvers/fdmhestonhullwhitesolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmhestonhullwhitesolver.hpp
*/

#ifndef quantlib_fdm_heston_hull_white_solver_hpp
#define quantlib_fdm_heston_hull_white_solver_hpp

#include <ql/handle.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <ql/processes/hullwhiteprocess.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdirichletboundary.hpp>


namespace QuantLib {

    class Fdm3DimSolver;

    class FdmHestonHullWhiteSolver : public LazyObject {
      public:
        FdmHestonHullWhiteSolver(const Handle<HestonProcess>& hestonProcess,
                                 const Handle<HullWhiteProcess>& hwProcess,
                                 Rate corrEquityShortRate,
                                 FdmSolverDesc solverDesc,
                                 const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

        Real valueAt(Real s, Real v, Rate r) const;
        Real thetaAt(Real s, Real v, Rate r) const;
        
        // First and second order derivative with respect to S_t. 
        // Please note that this is not the "model implied" delta or gamma.
        // E.g. see Fabio Mercurio, Massimo Morini 
        // "A Note on Hedging with Local and Stochastic Volatility Models",
        // http://papers.ssrn.com/sol3/papers.cfm?abstract_id=1294284  
        Real deltaAt(Real s, Real v, Rate r, Real eps) const;
        Real gammaAt(Real s, Real v, Rate r, Real eps) const;
        
      protected:
        void performCalculations() const override;

      private:
        const Handle<HestonProcess> hestonProcess_;  
        const Handle<HullWhiteProcess> hwProcess_;
        const Real corrEquityShortRate_;
        
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;

        mutable ext::shared_ptr<Fdm3DimSolver> solver_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="83">
    <source>solvers/fdmhestonsolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008, 2009, 2011, 2014, 2015 Klaus Spanderen
 Copyright (C) 2015 Johannes GÃ¶ttker-Schnetmann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmhestonsolver.hpp
*/

#ifndef quantlib_fdm_heston_solver_hpp
#define quantlib_fdm_heston_solver_hpp

#include <ql/handle.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/methods/finitedifferences/utilities/fdmquantohelper.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdirichletboundary.hpp>
#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>

namespace QuantLib {

    class HestonProcess;
    class Fdm2DimSolver;

    class FdmHestonSolver : public LazyObject {
      public:
        FdmHestonSolver(Handle<HestonProcess> process,
                        FdmSolverDesc solverDesc,
                        const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer(),
                        Handle<FdmQuantoHelper> quantoHelper = Handle<FdmQuantoHelper>(),
                        ext::shared_ptr<LocalVolTermStructure> leverageFct =
                            ext::shared_ptr<LocalVolTermStructure>(),
                        Real mixingFactor = 1.0);

        Real valueAt(Real s, Real v) const;
        Real thetaAt(Real s, Real v) const;

        // First and second order derivative with respect to S_t.
        // Please note that this is not the "model implied" delta or gamma.
        // E.g. see Fabio Mercurio, Massimo Morini
        // "A Note on Hedging with Local and Stochastic Volatility Models",
        // http://papers.ssrn.com/sol3/papers.cfm?abstract_id=1294284
        Real deltaAt(Real s, Real v) const;
        Real gammaAt(Real s, Real v) const;

        Real meanVarianceDeltaAt(Real s, Real v) const;
        Real meanVarianceGammaAt(Real s, Real v) const;

      protected:
        void performCalculations() const override;

      private:
        const Handle<HestonProcess> process_;
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;
        const Handle<FdmQuantoHelper> quantoHelper_;
        const ext::shared_ptr<LocalVolTermStructure> leverageFct_;
        const Real mixingFactor_;

        mutable ext::shared_ptr<Fdm2DimSolver> solver_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="84">
    <source>solvers/fdmhullwhitesolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmhullwhitesolver.hpp
*/

#ifndef quantlib_fdm_hull_white_solver_hpp
#define quantlib_fdm_hull_white_solver_hpp

#include <ql/handle.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    class HullWhite;
    class Fdm1DimSolver;

    class FdmHullWhiteSolver : public LazyObject {
      public:
        FdmHullWhiteSolver(Handle<HullWhite> model,
                           FdmSolverDesc solverDesc,
                           const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Hundsdorfer());

        Real valueAt(Real r) const;

      protected:
        void performCalculations() const override;

      private:
        const Handle<HullWhite> model_;
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;

        mutable ext::shared_ptr<Fdm1DimSolver> solver_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="85">
    <source>solvers/fdmndimsolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmndimsolver.hpp
*/

#ifndef quantlib_fdm_n_dim_solver_hpp
#define quantlib_fdm_n_dim_solver_hpp

#include <ql/patterns/lazyobject.hpp>
#include <ql/math/interpolations/multicubicspline.hpp>
#include <ql/methods/finitedifferences/finitedifferencemodel.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsnapshotcondition.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>

#include <numeric>

namespace QuantLib {

    template <Size N>
    class FdmNdimSolver : public LazyObject {
      public:
        FdmNdimSolver(const FdmSolverDesc& solverDesc,
                      const FdmSchemeDesc& schemeDesc,
                      ext::shared_ptr<FdmLinearOpComposite> op);

        void performCalculations() const override;

        Real interpolateAt(const std::vector<Real>& x) const;
        Real thetaAt(const std::vector<Real>& x) const;

        // template meta programming
        typedef typename MultiCubicSpline<N>::data_table data_table;
        void static setValue(data_table& f,
                             const std::vector<Size>& x, Real value);

      private:
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;
        const ext::shared_ptr<FdmLinearOpComposite> op_;

        const ext::shared_ptr<FdmSnapshotCondition> thetaCondition_;
        const ext::shared_ptr<FdmStepConditionComposite> conditions_;

        std::vector<std::vector<Real> > x_;
        std::vector<Real> initialValues_;
        const std::vector<bool> extrapolation_;

        mutable ext::shared_ptr<data_table> f_;
        mutable ext::shared_ptr<MultiCubicSpline<N> > interp_;
    };


    template <Size N>
    inline FdmNdimSolver<N>::FdmNdimSolver(const FdmSolverDesc& solverDesc,
                                           const FdmSchemeDesc& schemeDesc,
                                           ext::shared_ptr<FdmLinearOpComposite> op)
    : solverDesc_(solverDesc), schemeDesc_(schemeDesc), op_(std::move(op)),
      thetaCondition_(new FdmSnapshotCondition(
          0.99 * std::min(1.0 / 365.0,
                          solverDesc.condition->stoppingTimes().empty() ?
                              solverDesc.maturity :
                              solverDesc.condition->stoppingTimes().front()))),
      conditions_(FdmStepConditionComposite::joinConditions(thetaCondition_, solverDesc.condition)),
      x_(solverDesc.mesher->layout()->dim().size()),
      initialValues_(solverDesc.mesher->layout()->size()),
      extrapolation_(std::vector<bool>(N, false)) {

        const ext::shared_ptr<FdmMesher> mesher = solverDesc.mesher;
        const ext::shared_ptr<FdmLinearOpLayout> layout = mesher->layout();

        QL_REQUIRE(layout->dim().size() == N, "solver dim " << N
                    << "does not fit to layout dim " << layout->size());

        for (Size i=0; i < N; ++i) {
            x_[i].reserve(layout->dim()[i]);
        }

        const FdmLinearOpIterator endIter = layout->end();
        for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
             ++iter) {

            initialValues_[iter.index()] = solverDesc_.calculator
                                ->avgInnerValue(iter, solverDesc.maturity);

            const std::vector<Size>& c = iter.coordinates();
            for (Size i=0; i < N; ++i) {
                if ((std::accumulate(c.begin(), c.end(), 0UL) - c[i]) == 0U) {
                    x_[i].push_back(mesher->location(iter, i));
                }
            }
        }

        f_ = ext::shared_ptr<data_table>(new data_table(x_));
    }


    template <Size N> inline
    void FdmNdimSolver<N>::performCalculations() const {
        Array rhs(initialValues_.size());
        std::copy(initialValues_.begin(), initialValues_.end(), rhs.begin());

        FdmBackwardSolver(op_, solverDesc_.bcSet, conditions_, schemeDesc_)
                 .rollback(rhs, solverDesc_.maturity, 0.0,
                           solverDesc_.timeSteps, solverDesc_.dampingSteps);

        const ext::shared_ptr<FdmLinearOpLayout> layout
                                               = solverDesc_.mesher->layout();

        const FdmLinearOpIterator endIter = layout->end();
        for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
             ++iter) {
            setValue(*f_, iter.coordinates(), rhs[iter.index()]);
        }

        interp_ = ext::shared_ptr<MultiCubicSpline<N> >(
            new MultiCubicSpline<N>(x_, *f_, extrapolation_));
    }


    template <Size N> inline
    Real FdmNdimSolver<N>::thetaAt(const std::vector<Real>& x) const {
        if (conditions_->stoppingTimes().front() == 0.0)
            return Null<Real>();

        calculate();
        const Array& rhs = thetaCondition_->getValues();
        const ext::shared_ptr<FdmLinearOpLayout> layout
                                            = solverDesc_.mesher->layout();

        data_table f(x_);

        const FdmLinearOpIterator endIter = layout->end();
        for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
             ++iter) {
            setValue(f, iter.coordinates(), rhs[iter.index()]);
        }

        return (MultiCubicSpline<N>(x_, f)(x)
                        - interpolateAt(x)) / thetaCondition_->getTime();
    }

    template <Size N> inline
    Real FdmNdimSolver<N>::interpolateAt(const std::vector<Real>& x) const {
        calculate();

        return (*interp_)(x);
    }

    template <Size N> inline
    void FdmNdimSolver<N>::setValue(data_table& f,
                                    const std::vector<Size>& x, Real value) {
        FdmNdimSolver<N-1>::setValue(f[x[x.size()-N]], x, value);
    }

    template <> inline
    void FdmNdimSolver<1>::setValue(data_table& f,
                                    const std::vector<Size>& x, Real value) {
        f[x.back()] = value;
    }
}

#endif
]]></document_content>
  </document>
  <document index="86">
    <source>solvers/fdmsimple2dbssolver.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Ralph Schreyer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*!
 * \file fdmsimple2dbssolver.hpp
*/

#ifndef quantlib_fdm_simple_2d_bs_solver_hpp
#define quantlib_fdm_simple_2d_bs_solver_hpp

#include <ql/handle.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsolverdesc.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>

namespace QuantLib {

    class Fdm2DimSolver;
    class GeneralizedBlackScholesProcess;

    class FdmSimple2dBSSolver : public LazyObject {
      public:
        FdmSimple2dBSSolver(Handle<GeneralizedBlackScholesProcess> process,
                            Real strike,
                            FdmSolverDesc desc,
                            const FdmSchemeDesc& schemeDesc = FdmSchemeDesc::Douglas());

        Real valueAt(Real s, Real a) const;
        Real deltaAt(Real s, Real a, Real eps) const;
        Real gammaAt(Real s, Real a, Real eps) const;
        Real thetaAt(Real s, Real a) const;

      protected:
        void performCalculations() const override;

      private:
        Handle<GeneralizedBlackScholesProcess> process_;
        const Real strike_;
        const FdmSolverDesc solverDesc_;
        const FdmSchemeDesc schemeDesc_;

        mutable ext::shared_ptr<Fdm2DimSolver> solver_;
    };
}

#endif /* quantlib_fdm_simple_2d_bs_solver_hpp */
]]></document_content>
  </document>
  <document index="87">
    <source>solvers/fdmsolverdesc.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmsolverdesc.hpp
*/

#ifndef quantlib_fdm_solver_desc_hpp
#define quantlib_fdm_solver_desc_hpp

#include <ql/methods/finitedifferences/utilities/fdmboundaryconditionset.hpp>

namespace QuantLib {

    class FdmMesher;
    class FdmInnerValueCalculator;
    class FdmStepConditionComposite;
    class FdmInnerValueCalculator;

    struct FdmSolverDesc {
        const ext::shared_ptr<FdmMesher> mesher;
        const FdmBoundaryConditionSet bcSet;
        const ext::shared_ptr<FdmStepConditionComposite> condition;
        const ext::shared_ptr<FdmInnerValueCalculator> calculator;
        const Time maturity;
        const Size timeSteps;
        const Size dampingSteps;
    };
}

#endif
]]></document_content>
  </document>
  <document index="88">
    <source>stepcondition.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file stepcondition.hpp
    \brief conditions to be applied at every time step
*/

#ifndef quantlib_step_condition_hpp
#define quantlib_step_condition_hpp

#include <ql/math/array.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    //! condition to be applied at every time step
    /*! \ingroup findiff */
    template <class array_type>
    class StepCondition {
      public:
        virtual ~StepCondition() = default;
        virtual void applyTo(array_type& a, Time t) const = 0;
    };

    /*  */
    /*! Abstract base class which allows step conditions to use both
        payoff and array functions.

        \deprecated Inherit from StepCondition directly instead.
                    Deprecated in version 1.19.
    */
    template <class array_type>
    class QL_DEPRECATED CurveDependentStepCondition :
        public StepCondition<array_type> {
      public:
        void applyTo(Array &a, Time) const {
            //#pragma omp parallel for
            for (Size i = 0; i < a.size(); i++) {
                a[i] =
                    applyToValue(a[i], getValue(a,i));
            }
        }
      protected:

#if defined(QL_PATCH_MSVC)
#pragma warning(push)
#pragma warning(disable:4996)
#endif

        CurveDependentStepCondition(Option::Type type, Real strike)
            : curveItem_(new PayoffWrapper(type, strike)) {};
        CurveDependentStepCondition(const Payoff *p)
            : curveItem_(new PayoffWrapper(p)) {};
        CurveDependentStepCondition(const array_type & a)
            : curveItem_(new ArrayWrapper(a)) {};

#if defined(QL_PATCH_MSVC)
#pragma warning(pop)
#endif

        class CurveWrapper;

        ext::shared_ptr<CurveWrapper> curveItem_;
        Real getValue(const array_type &a, Size index) const {
            return curveItem_->getValue(a, index);
        }

        virtual Real applyToValue(Real, Real) const {
            QL_FAIL("not yet implemented");
        }

        class CurveWrapper {
          public:
            virtual ~CurveWrapper() = default;
            virtual Real getValue(const array_type &a,
                                  int i) = 0;
        };

        class ArrayWrapper : public CurveWrapper {
          private:
            array_type value_;
          public:
            ArrayWrapper (const array_type &a)
            : value_(a) {}

            Real getValue(const array_type&, int i) {
                return value_[i];
            }
        };

        class PayoffWrapper : public CurveWrapper {
          private:
            ext::shared_ptr<const Payoff> payoff_;
          public:
            PayoffWrapper (const Payoff * p)
                : payoff_(p) {};
            PayoffWrapper (Option::Type type, Real strike)
                : payoff_(new PlainVanillaPayoff(type, strike)) {};
            Real getValue(const array_type &a,
                          int i) {
                return (*payoff_)(a[i]);
            }
        };
    };


    //! %null step condition
    /*! \ingroup findiff */
    template <class array_type>
    class NullCondition : public StepCondition<array_type> {
      public:
        void applyTo(array_type&, Time) const override {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="89">
    <source>stepconditions/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/methods/finitedifferences/stepconditions/fdmamericanstepcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmarithmeticaveragecondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmbermudanstepcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsimplestoragecondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsimpleswingcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsnapshotcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>

]]></document_content>
  </document>
  <document index="90">
    <source>stepconditions/fdmamericanstepcondition.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmamericanstepcondition.hpp
    \brief american step condition for multi dimensional problems
*/

#ifndef quantlib_fdm_american_step_condition_hpp
#define quantlib_fdm_american_step_condition_hpp

#include <ql/methods/finitedifferences/stepcondition.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>

namespace QuantLib {

    class FdmAmericanStepCondition : public StepCondition<Array> {
      public:
        FdmAmericanStepCondition(ext::shared_ptr<FdmMesher> mesher,
                                 ext::shared_ptr<FdmInnerValueCalculator> calculator);

        void applyTo(Array& a, Time) const override;

      private:
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<FdmInnerValueCalculator> calculator_;
    };
}
#endif
]]></document_content>
  </document>
  <document index="91">
    <source>stepconditions/fdmarithmeticaveragecondition.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Ralph Schreyer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmarithmeticaveragecondition.hpp
    \brief step condition to handle arithmetic average
*/

#ifndef quantlib_fdm_arithmetic_average_condition_hpp
#define quantlib_fdm_arithmetic_average_condition_hpp

#include <ql/methods/finitedifferences/stepcondition.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>

namespace QuantLib {

    class FdmArithmeticAverageCondition : public StepCondition<Array> {
      public:
        FdmArithmeticAverageCondition(std::vector<Time> averageTimes,
                                      Real,
                                      Size pastFixings,
                                      const ext::shared_ptr<FdmMesher>& mesher,
                                      Size equityDirection);

        void applyTo(Array& a, Time t) const override;

      private:
        Array x_; // grid-equity values in physical units
        Array a_; // average values in physical units

        const std::vector<Time> averageTimes_;
        const Size pastFixings_;
        const ext::shared_ptr<FdmMesher> mesher_;
        const Size equityDirection_;
    };
}
#endif
]]></document_content>
  </document>
  <document index="92">
    <source>stepconditions/fdmbermudanstepcondition.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmbermudanstepcondition.hpp
    \brief bermudan step condition for multi dimensional problems
*/

#ifndef quantlib_fdm_bermudan_step_condition_hpp
#define quantlib_fdm_bermudan_step_condition_hpp

#include <ql/time/daycounter.hpp>
#include <ql/methods/finitedifferences/stepcondition.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>

namespace QuantLib {

    class FdmInnerValueCalculator;

    class FdmBermudanStepCondition : public StepCondition<Array> {
      public:
        FdmBermudanStepCondition(const std::vector<Date>& exerciseDates,
                                 const Date& referenceDate,
                                 const DayCounter& dayCounter,
                                 ext::shared_ptr<FdmMesher> mesher,
                                 ext::shared_ptr<FdmInnerValueCalculator> calculator);

        void applyTo(Array& a, Time t) const override;
        const std::vector<Time>& exerciseTimes() const;

      private:
        std::vector<Time> exerciseTimes_;
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<FdmInnerValueCalculator> calculator_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="93">
    <source>stepconditions/fdmsimplestoragecondition.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmsimplestoragecondition.hpp
    \brief simple storage step condition
*/

#ifndef quantlib_fdm_simple_storage_condition_hpp
#define quantlib_fdm_simple_storage_condition_hpp

#include <ql/math/matrix.hpp>
#include <ql/methods/finitedifferences/stepcondition.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>

namespace QuantLib {

    class FdmSimpleStorageCondition : public StepCondition<Array> {
      public:
        FdmSimpleStorageCondition(std::vector<Time> exerciseTimes,
                                  ext::shared_ptr<FdmMesher> mesher,
                                  ext::shared_ptr<FdmInnerValueCalculator> calculator,
                                  Real changeRate);

        void applyTo(Array& a, Time t) const override;

      private:
        const std::vector<Time> exerciseTimes_;
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<FdmInnerValueCalculator> calculator_;
        const Real changeRate_;

        std::vector<Real> x_, y_;
    };
}
#endif
]]></document_content>
  </document>
  <document index="94">
    <source>stepconditions/fdmsimpleswingcondition.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmsimpleswingcondition.hpp
    \brief simple swing step condition
*/

#ifndef quantlib_fdm_simple_swing_condition_hpp
#define quantlib_fdm_simple_swing_condition_hpp

#include <ql/methods/finitedifferences/stepcondition.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>

namespace QuantLib {

    class FdmSimpleSwingCondition : public StepCondition<Array> {
      public:
        FdmSimpleSwingCondition(std::vector<Time> exerciseTimes,
                                ext::shared_ptr<FdmMesher> mesher,
                                ext::shared_ptr<FdmInnerValueCalculator> calculator,
                                Size swingDirection,
                                Size minExercises = 0);

        void applyTo(Array& a, Time t) const override;

      private:
        const std::vector<Time> exerciseTimes_;
        const ext::shared_ptr<FdmMesher> mesher_;
        const ext::shared_ptr<FdmInnerValueCalculator> calculator_;
        const Size minExercises_;
        const Size swingDirection_;
    };
}
#endif
]]></document_content>
  </document>
  <document index="95">
    <source>stepconditions/fdmsnapshotcondition.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmsnapshotcondition.hpp
    \brief step condition for value inspection
*/

#ifndef quantlib_fdm_snapshot_condition_hpp
#define quantlib_fdm_snapshot_condition_hpp

#include <ql/methods/finitedifferences/stepcondition.hpp>

namespace QuantLib {

    class FdmSnapshotCondition : public StepCondition<Array> {
    public:
        explicit FdmSnapshotCondition(Time t);

        void applyTo(Array& a, Time t) const override;
        Time getTime() const;       
        const Array& getValues() const;

    private:
        const Time t_;
        mutable Array values_;
    };
}
#endif
]]></document_content>
  </document>
  <document index="96">
    <source>stepconditions/fdmstepconditioncomposite.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmstepconditioncomposite.hpp
    \brief composite of fdm step conditions
*/

#ifndef quantlib_fdm_step_condition_composite_hpp
#define quantlib_fdm_step_condition_composite_hpp

#include <ql/time/date.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/instruments/dividendschedule.hpp>
#include <ql/methods/finitedifferences/stepcondition.hpp>

#include <list>

namespace QuantLib {

    class FdmMesher;
    class Exercise;
    class FdmSnapshotCondition;
    class FdmInnerValueCalculator;
    
    class FdmStepConditionComposite : public StepCondition<Array> {
    public:
        typedef std::list<ext::shared_ptr<StepCondition<Array> > > Conditions;

        FdmStepConditionComposite(const std::list<std::vector<Time> >& stoppingTimes,
                                  Conditions conditions);

        void applyTo(Array& a, Time t) const override;
        const std::vector<Time>& stoppingTimes() const;
        const Conditions& conditions() const;

        static ext::shared_ptr<FdmStepConditionComposite> joinConditions(
                    const ext::shared_ptr<FdmSnapshotCondition>& c1,
                    const ext::shared_ptr<FdmStepConditionComposite>& c2);

        static ext::shared_ptr<FdmStepConditionComposite> vanillaComposite(
             const DividendSchedule& schedule,
             const ext::shared_ptr<Exercise>& exercise,
             const ext::shared_ptr<FdmMesher>& mesher,
             const ext::shared_ptr<FdmInnerValueCalculator>& calculator,
             const Date& refDate,
             const DayCounter& dayCounter);
        
    private:
        std::vector<Time> stoppingTimes_;
        const Conditions conditions_;
    };
}
#endif
]]></document_content>
  </document>
  <document index="97">
    <source>trbdf2.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Fabien Le Floc'h

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file trbdf2.hpp
    \brief TR-BDF2 scheme for finite difference methods
*/

#ifndef quantlib_trbdf2_hpp
#define quantlib_trbdf2_hpp

#include <ql/methods/finitedifferences/finitedifferencemodel.hpp>

namespace QuantLib {

    //! TR-BDF2 scheme for finite difference methods
    /*! See <http://ssrn.com/abstract=1648878> for details.

        In this implementation, the passed operator must be derived
        from either TimeConstantOperator or TimeDependentOperator.
        Also, it must implement at least the following interface:

        \code
        typedef ... array_type;

        // copy constructor/assignment
        // (these will be provided by the compiler if none is defined)
        Operator(const Operator&);
        Operator& operator=(const Operator&);

        // inspectors
        Size size();

        // modifiers
        void setTime(Time t);

        // operator interface
        array_type applyTo(const array_type&);
        array_type solveFor(const array_type&);
        static Operator identity(Size size);

        // operator algebra
        Operator operator*(Real, const Operator&);
        Operator operator+(const Operator&, const Operator&);
        Operator operator+(const Operator&, const Operator&);
        \endcode

        \warning The differential operator must be linear for
                 this evolver to work.

        \ingroup findiff
    */

    // NOTE: There is room for performance improvement especially in
    // the array manipulation

    template <class Operator>
    class TRBDF2  {
      public:
        // typedefs
        typedef OperatorTraits<Operator> traits;
        typedef typename traits::operator_type operator_type;
        typedef typename traits::array_type array_type;
        typedef typename traits::bc_set bc_set;
        typedef typename traits::condition_type condition_type;
        // constructors
        TRBDF2(const operator_type& L,
               const bc_set& bcs)
        : L_(L), I_(operator_type::identity(L.size())),
          dt_(0.0), bcs_(bcs), alpha_(2.0-sqrt(2.0)) {}
        void step(array_type& a,
                  Time t);
        void setStep(Time dt) {
            dt_ = dt;

            implicitPart_ = I_ + 0.5*alpha_*dt_*L_;
            explicitTrapezoidalPart_ = I_ - 0.5*alpha_*dt_*L_;
            explicitBDF2PartFull_ =
                -(1.0-alpha_)*(1.0-alpha_)/(alpha_*(2.0-alpha_))*I_;
            explicitBDF2PartMid_ = 1.0/(alpha_*(2.0-alpha_))*I_;
        }
      private:
        Real alpha_;
        operator_type L_, I_, explicitTrapezoidalPart_,
            explicitBDF2PartFull_,explicitBDF2PartMid_, implicitPart_;
        Time dt_;
        bc_set bcs_;
        array_type aInit_;
    };


    // inline definitions

    template <class Operator>
    inline void TRBDF2<Operator>::step(array_type& a, Time t) {
        Size i;
        Array aInit(a.size());
        for (i=0; i<a.size();i++) {
            aInit[i] = a[i];
        }
        aInit_ = aInit;
        for (i=0; i<bcs_.size(); i++)
            bcs_[i]->setTime(t);
        //trapezoidal explicit part
        if (L_.isTimeDependent()) {
            L_.setTime(t);
            explicitTrapezoidalPart_ = I_ - 0.5*alpha_*dt_*L_;
        }
        for (i=0; i<bcs_.size(); i++)
            bcs_[i]->applyBeforeApplying(explicitTrapezoidalPart_);
        a = explicitTrapezoidalPart_.applyTo(a);
        for (i=0; i<bcs_.size(); i++)
            bcs_[i]->applyAfterApplying(a);

        // trapezoidal implicit part
        if (L_.isTimeDependent()) {
            L_.setTime(t-dt_);
            implicitPart_ = I_ + 0.5*alpha_*dt_*L_;
        }
        for (i=0; i<bcs_.size(); i++)
            bcs_[i]->applyBeforeSolving(implicitPart_,a);
        a = implicitPart_.solveFor(a);
        for (i=0; i<bcs_.size(); i++)
            bcs_[i]->applyAfterSolving(a);


        // BDF2 explicit part
        if (L_.isTimeDependent()) {
            L_.setTime(t);
        }
        for (i=0; i<bcs_.size(); i++) {
            bcs_[i]->applyBeforeApplying(explicitBDF2PartFull_);
        }
        array_type b0 = explicitBDF2PartFull_.applyTo(aInit_);
        for (i=0; i<bcs_.size(); i++)
            bcs_[i]->applyAfterApplying(b0);

        for (i=0; i<bcs_.size(); i++) {
            bcs_[i]->applyBeforeApplying(explicitBDF2PartMid_);
        }
        array_type b1 = explicitBDF2PartMid_.applyTo(a);
        for (i=0; i<bcs_.size(); i++)
            bcs_[i]->applyAfterApplying(b1);
        a = b0+b1;

        // reuse implicit part - works only for alpha=2-sqrt(2)
        for (i=0; i<bcs_.size(); i++)
            bcs_[i]->applyBeforeSolving(implicitPart_,a);
        a = implicitPart_.solveFor(a);
        for (i=0; i<bcs_.size(); i++)
            bcs_[i]->applyAfterSolving(a);

    }

}

#endif
]]></document_content>
  </document>
  <document index="98">
    <source>tridiagonaloperator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl
 Copyright (C) 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file tridiagonaloperator.hpp
    \brief tridiagonal operator
*/

#ifndef quantlib_tridiagonal_operator_hpp
#define quantlib_tridiagonal_operator_hpp

#include <ql/math/array.hpp>
#include <ql/math/comparison.hpp>
#include <ql/shared_ptr.hpp>

namespace QuantLib {

    //! Base implementation for tridiagonal operator
    /*! \warning to use real time-dependant algebra, you must overload
                 the corresponding operators in the inheriting
                 time-dependent class.

        \ingroup findiff
    */
    class TridiagonalOperator {
        // unary operators
        friend Disposable<TridiagonalOperator>
        operator+(const TridiagonalOperator&);
        friend Disposable<TridiagonalOperator>
        operator-(const TridiagonalOperator&);
        // binary operators
        friend Disposable<TridiagonalOperator>
        operator+(const TridiagonalOperator&,
                  const TridiagonalOperator&);
        friend Disposable<TridiagonalOperator>
        operator-(const TridiagonalOperator&,
                  const TridiagonalOperator&);
        friend Disposable<TridiagonalOperator>
        operator*(Real,
                  const TridiagonalOperator&);
        friend Disposable<TridiagonalOperator>
        operator*(const TridiagonalOperator&,
                  Real);
        friend Disposable<TridiagonalOperator>
        operator/(const TridiagonalOperator&,
                  Real);
      public:
        typedef Array array_type;
        // constructors
        explicit TridiagonalOperator(Size size = 0);
        TridiagonalOperator(const Array& low,
                            const Array& mid,
                            const Array& high);
        TridiagonalOperator(const TridiagonalOperator&) = default;
        TridiagonalOperator(TridiagonalOperator&&) QL_NOEXCEPT;
        #ifdef QL_USE_DISPOSABLE
        TridiagonalOperator(const Disposable<TridiagonalOperator>&);
        #endif
        TridiagonalOperator& operator=(const TridiagonalOperator&);
        TridiagonalOperator& operator=(TridiagonalOperator&&) QL_NOEXCEPT;
        #ifdef QL_USE_DISPOSABLE
        TridiagonalOperator& operator=(const Disposable<TridiagonalOperator>&);
        #endif
        //! \name Operator interface
        //@{
        //! apply operator to a given array
        Disposable<Array> applyTo(const Array& v) const;
        //! solve linear system for a given right-hand side
        Disposable<Array> solveFor(const Array& rhs) const;
        /*! solve linear system for a given right-hand side
            without result Array allocation. The rhs and result parameters
            can be the same Array, in which case rhs will be changed
        */
        void solveFor(const Array& rhs,
                      Array& result) const;
        //! solve linear system with SOR approach
        Disposable<Array> SOR(const Array& rhs,
                              Real tol) const;
        //! identity instance
        static Disposable<TridiagonalOperator> identity(Size size);
        //@}
        //! \name Inspectors
        //@{
        Size size() const { return n_; }
        bool isTimeDependent() const { return !!timeSetter_; }
        const Array& lowerDiagonal() const { return lowerDiagonal_; }
        const Array& diagonal() const { return diagonal_; }
        const Array& upperDiagonal() const { return upperDiagonal_; }
        //@}
        //! \name Modifiers
        //@{
        void setFirstRow(Real, Real);
        void setMidRow(Size, Real, Real, Real);
        void setMidRows(Real, Real, Real);
        void setLastRow(Real, Real);
        void setTime(Time t);
        //@}
        //! \name Utilities
        //@{
        void swap(TridiagonalOperator&);
        //@}
        //! encapsulation of time-setting logic
        class TimeSetter {
          public:
            virtual ~TimeSetter() = default;
            virtual void setTime(Time t,
                                 TridiagonalOperator& L) const = 0;
        };
      protected:
        Size n_;
        Array diagonal_, lowerDiagonal_, upperDiagonal_;
        mutable Array temp_;
        ext::shared_ptr<TimeSetter> timeSetter_;
    };

    /* \relates TridiagonalOperator */
    void swap(TridiagonalOperator&, TridiagonalOperator&);


    // inline definitions

    inline TridiagonalOperator::TridiagonalOperator(TridiagonalOperator&& from) QL_NOEXCEPT {
        swap(from);
    }

    #ifdef QL_USE_DISPOSABLE
    inline TridiagonalOperator::TridiagonalOperator(
                                const Disposable<TridiagonalOperator>& from) {
        swap(const_cast<Disposable<TridiagonalOperator>&>(from));
    }
    #endif

    inline TridiagonalOperator& TridiagonalOperator::operator=(
                                const TridiagonalOperator& from) {
        TridiagonalOperator temp(from);
        swap(temp);
        return *this;
    }

    inline TridiagonalOperator&
    TridiagonalOperator::operator=(TridiagonalOperator&& from) QL_NOEXCEPT {
        swap(from);
        return *this;
    }

    #ifdef QL_USE_DISPOSABLE
    inline TridiagonalOperator& TridiagonalOperator::operator=(
                                const Disposable<TridiagonalOperator>& from) {
        swap(const_cast<Disposable<TridiagonalOperator>&>(from));
        return *this;
    }
    #endif

    inline void TridiagonalOperator::setFirstRow(Real valB,
                                                 Real valC) {
        diagonal_[0]      = valB;
        upperDiagonal_[0] = valC;
    }

    inline void TridiagonalOperator::setMidRow(Size i,
                                               Real valA,
                                               Real valB,
                                               Real valC) {
        QL_REQUIRE(i>=1 && i<=n_-2,
                   "out of range in TridiagonalSystem::setMidRow");
        lowerDiagonal_[i-1] = valA;
        diagonal_[i]        = valB;
        upperDiagonal_[i]   = valC;
    }

    inline void TridiagonalOperator::setMidRows(Real valA,
                                                Real valB,
                                                Real valC) {
        for (Size i=1; i<=n_-2; i++) {
            lowerDiagonal_[i-1] = valA;
            diagonal_[i]        = valB;
            upperDiagonal_[i]   = valC;
        }
    }

    inline void TridiagonalOperator::setLastRow(Real valA,
                                                Real valB) {
        lowerDiagonal_[n_-2] = valA;
        diagonal_[n_-1]      = valB;
    }

    inline void TridiagonalOperator::setTime(Time t) {
        if (timeSetter_ != nullptr)
            timeSetter_->setTime(t, *this);
    }

    inline void TridiagonalOperator::swap(TridiagonalOperator& from) {
        using std::swap;
        swap(n_, from.n_);
        diagonal_.swap(from.diagonal_);
        lowerDiagonal_.swap(from.lowerDiagonal_);
        upperDiagonal_.swap(from.upperDiagonal_);
        temp_.swap(from.temp_);
        swap(timeSetter_, from.timeSetter_);
    }


    // Time constant algebra

    inline Disposable<TridiagonalOperator>
    operator+(const TridiagonalOperator& D) {
        TridiagonalOperator D1 = D;
        return D1;
    }

    inline Disposable<TridiagonalOperator>
    operator-(const TridiagonalOperator& D) {
        Array low = -D.lowerDiagonal_,
            mid = -D.diagonal_,
            high = -D.upperDiagonal_;
        TridiagonalOperator result(low, mid, high);
        return result;
    }

    inline Disposable<TridiagonalOperator>
    operator+(const TridiagonalOperator& D1,
              const TridiagonalOperator& D2) {
        Array low = D1.lowerDiagonal_ + D2.lowerDiagonal_,
            mid = D1.diagonal_ + D2.diagonal_,
            high = D1.upperDiagonal_ + D2.upperDiagonal_;
        TridiagonalOperator result(low, mid, high);
        return result;
    }

    inline Disposable<TridiagonalOperator>
    operator-(const TridiagonalOperator& D1,
              const TridiagonalOperator& D2) {
        Array low = D1.lowerDiagonal_ - D2.lowerDiagonal_,
            mid = D1.diagonal_ - D2.diagonal_,
            high = D1.upperDiagonal_ - D2.upperDiagonal_;
        TridiagonalOperator result(low, mid, high);
        return result;
    }

    inline Disposable<TridiagonalOperator>
    operator*(Real a,
              const TridiagonalOperator& D) {
        Array low = D.lowerDiagonal_ * a,
            mid = D.diagonal_ * a,
            high = D.upperDiagonal_ * a;
        TridiagonalOperator result(low, mid, high);
        return result;
    }

    inline Disposable<TridiagonalOperator>
    operator*(const TridiagonalOperator& D,
              Real a) {
        Array low = D.lowerDiagonal_ * a,
            mid = D.diagonal_ * a,
            high = D.upperDiagonal_ * a;
        TridiagonalOperator result(low, mid, high);
        return result;
    }

    inline Disposable<TridiagonalOperator>
    operator/(const TridiagonalOperator& D,
              Real a) {
        Array low = D.lowerDiagonal_ / a,
            mid = D.diagonal_ / a,
            high = D.upperDiagonal_ / a;
        TridiagonalOperator result(low, mid, high);
        return result;
    }

    inline void swap(TridiagonalOperator& L1,
                     TridiagonalOperator& L2) {
        L1.swap(L2);
    }

}

#endif
]]></document_content>
  </document>
  <document index="99">
    <source>utilities/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/methods/finitedifferences/utilities/bsmrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/cevrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/escroweddividendadjustment.hpp>
#include <ql/methods/finitedifferences/utilities/fdmaffinemodeltermstructure.hpp>
#include <ql/methods/finitedifferences/utilities/fdmaffinemodelswapinnervalue.hpp>
#include <ql/methods/finitedifferences/utilities/fdmboundaryconditionset.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdirichletboundary.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdiscountdirichletboundary.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdividendhandler.hpp>
#include <ql/methods/finitedifferences/utilities/fdmescrowedloginnervaluecalculator.hpp>
#include <ql/methods/finitedifferences/utilities/fdmindicesonboundary.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/methods/finitedifferences/utilities/fdmshoutloginnervaluecalculator.hpp>
#include <ql/methods/finitedifferences/utilities/fdmmesherintegral.hpp>
#include <ql/methods/finitedifferences/utilities/fdmquantohelper.hpp>
#include <ql/methods/finitedifferences/utilities/fdmtimedepdirichletboundary.hpp>
#include <ql/methods/finitedifferences/utilities/gbsmrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/hestonrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/localvolrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/riskneutraldensitycalculator.hpp>
#include <ql/methods/finitedifferences/utilities/squarerootprocessrndcalculator.hpp>

]]></document_content>
  </document>
  <document index="100">
    <source>utilities/bsmrndcalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes GÃ¶ttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bsmrndcalculator.hpp
    \brief risk neutral terminal density calculator for the
           Black-Scholes-Merton model with constant volatility
*/

#ifndef quantlib_bsm_risk_neutral_density_calculator_hpp
#define quantlib_bsm_risk_neutral_density_calculator_hpp

#include <ql/methods/finitedifferences/utilities/riskneutraldensitycalculator.hpp>
#include <ql/shared_ptr.hpp>

namespace QuantLib {
    class GeneralizedBlackScholesProcess;

    class BSMRNDCalculator : public RiskNeutralDensityCalculator {
    public:
      explicit BSMRNDCalculator(ext::shared_ptr<GeneralizedBlackScholesProcess> process);

      // x = ln(S)
      Real pdf(Real x, Time t) const override;
      Real cdf(Real x, Time t) const override;
      Real invcdf(Real q, Time t) const override;

    private:
      std::pair<Real, Volatility> distributionParams(Real x, Time t) const;

      const ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="101">
    <source>utilities/cevrndcalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cevrndcalculator.hpp
    \brief risk neutral density calculator for the
    constant elasticity of variance (CEV) model
*/

#ifndef quantlib_cev_rnd_calculator_hpp
#define quantlib_cev_rnd_calculator_hpp

#include <ql/methods/finitedifferences/utilities/riskneutraldensitycalculator.hpp>

namespace QuantLib {
    //! constant elasticity of variance process (absorbing boundary at f=0)
    /*! \f[
         df_t = \alpha f_t^\beta \mathrm{d}W_t
        \f]
    */

    /*! References:

        D.R. Brecher, A.E. Lindsay, Results on the CEV Process, Past and Present
        https://www.fincad.com/sites/default/files/wysiwyg/Resources-Wiki/cev-process-working-paper.pdf
    */

    class CEVRNDCalculator : public RiskNeutralDensityCalculator {
      public:
        CEVRNDCalculator(Real f0, Real alpha, Real beta);

        Real massAtZero(Time t) const;

        Real pdf(Real f, Time t) const override;
        Real cdf(Real f, Time t) const override;
        Real invcdf(Real q, Time t) const override;

      private:
        Real X(Real f) const;
        Real invX(Real f) const;
        Real sankaranApprox(Real f, Time t, Real x) const;

        const Real f0_, alpha_, beta_, delta_, x0_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="102">
    <source>utilities/escroweddividendadjustment.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file escroweddividendadjustment.hpp
*/

#ifndef quantlib_escrowed_dividend_adjustment_hpp
#define quantlib_escrowed_dividend_adjustment_hpp

#include <ql/handle.hpp>
#include <ql/functional.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/instruments/dividendschedule.hpp>

namespace QuantLib {

    class EscrowedDividendAdjustment {
      public:
        EscrowedDividendAdjustment(
            DividendSchedule dividendSchedule,
            Handle<YieldTermStructure> rTS,
            Handle<YieldTermStructure> qTS,
            ext::function<Real(Date)> toTime,
            Time maturity);

        Real dividendAdjustment(Time t) const;

        const Handle<YieldTermStructure>& riskFreeRate() const;
        const Handle<YieldTermStructure>& dividendYield() const;

      private:
        const DividendSchedule dividendSchedule_;
        const Handle<YieldTermStructure> rTS_, qTS_;
        const ext::function<Real(Date)> toTime_;
        const Time maturity_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="103">
    <source>utilities/fdmaffinemodelswapinnervalue.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmaffinemodelswapinnervalue.hpp
*/

#ifndef quantlib_fdm_affine_model_swap_inner_value_hpp
#define quantlib_fdm_affine_model_swap_inner_value_hpp

#include <ql/cashflows/coupon.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/instruments/vanillaswap.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/utilities/fdmaffinemodeltermstructure.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/models/shortrate/onefactormodels/hullwhite.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <map>
#include <utility>

namespace QuantLib {

    template <class ModelType>
    class FdmAffineModelSwapInnerValue : public FdmInnerValueCalculator {
      public:
        FdmAffineModelSwapInnerValue(ext::shared_ptr<ModelType> disModel,
                                     ext::shared_ptr<ModelType> fwdModel,
                                     const ext::shared_ptr<VanillaSwap>& swap,
                                     std::map<Time, Date> exerciseDates,
                                     ext::shared_ptr<FdmMesher> mesher,
                                     Size direction);

        Real innerValue(const FdmLinearOpIterator& iter, Time t) override;
        Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override;

      private:
        Disposable<Array> getState(
            const ext::shared_ptr<ModelType>& model,
            Time t,
            const FdmLinearOpIterator& iter) const;

        RelinkableHandle<YieldTermStructure> disTs_, fwdTs_;
        const ext::shared_ptr<ModelType> disModel_, fwdModel_;

        const ext::shared_ptr<IborIndex> index_;
        const ext::shared_ptr<VanillaSwap> swap_;
        const std::map<Time, Date> exerciseDates_;
        const ext::shared_ptr<FdmMesher> mesher_;
        const Size direction_;
    };

    template <class ModelType>
    inline FdmAffineModelSwapInnerValue<ModelType>::FdmAffineModelSwapInnerValue(
        ext::shared_ptr<ModelType> disModel,
        ext::shared_ptr<ModelType> fwdModel,
        const ext::shared_ptr<VanillaSwap>& swap,
        std::map<Time, Date> exerciseDates,
        ext::shared_ptr<FdmMesher> mesher,
        Size direction)
    : disModel_(std::move(disModel)), fwdModel_(std::move(fwdModel)), index_(swap->iborIndex()),
      swap_(ext::shared_ptr<VanillaSwap>(new VanillaSwap(swap->type(),
                                                         swap->nominal(),
                                                         swap->fixedSchedule(),
                                                         swap->fixedRate(),
                                                         swap->fixedDayCount(),
                                                         swap->floatingSchedule(),
                                                         swap->iborIndex()->clone(fwdTs_),
                                                         swap->spread(),
                                                         swap->floatingDayCount(),
                                                         swap->paymentConvention()))),
      exerciseDates_(std::move(exerciseDates)), mesher_(std::move(mesher)), direction_(direction) {}

    template <class ModelType> inline
    Real FdmAffineModelSwapInnerValue<ModelType>::innerValue(
        const FdmLinearOpIterator& iter, Time t) {

        const Date& iterExerciseDate = exerciseDates_.find(t)->second;

        const Array disRate(getState(disModel_, t, iter));
        const Array fwdRate(getState(fwdModel_, t, iter));

        if (disTs_.empty() || iterExerciseDate != disTs_->referenceDate()) {

            const Handle<YieldTermStructure> discount
                = disModel_->termStructure();

            disTs_.linkTo(ext::shared_ptr<YieldTermStructure>(
                new FdmAffineModelTermStructure(disRate,
                    discount->calendar(), discount->dayCounter(),
                    iterExerciseDate, discount->referenceDate(),
                    disModel_)));

            const Handle<YieldTermStructure> fwd = fwdModel_->termStructure();

            fwdTs_.linkTo(ext::shared_ptr<YieldTermStructure>(
                new FdmAffineModelTermStructure(fwdRate,
                    fwd->calendar(), fwd->dayCounter(),
                    iterExerciseDate, fwd->referenceDate(),
                    fwdModel_)));

        }
        else {
            ext::dynamic_pointer_cast<FdmAffineModelTermStructure>(
                disTs_.currentLink())->setVariable(disRate);
            ext::dynamic_pointer_cast<FdmAffineModelTermStructure>(
                fwdTs_.currentLink())->setVariable(fwdRate);
        }

        Real npv = 0.0;
        for (Size j = 0; j < 2; j++) {
            for (const auto& i : swap_->leg(j)) {
                npv +=
                    ext::dynamic_pointer_cast<Coupon>(i)->accrualStartDate() >= iterExerciseDate ?
                        i->amount() * disTs_->discount(i->date()) :
                        0.0;
            }
            if (j == 0)
                npv *= -1.0;
        }
        if (swap_->type() == Swap::Receiver)
            npv *= -1.0;

        return std::max(0.0, npv);
    }

    template <class ModelType> inline
    Real FdmAffineModelSwapInnerValue<ModelType>::avgInnerValue(
        const FdmLinearOpIterator& iter, Time t) {
        return innerValue(iter, t);
    }

}
#endif
]]></document_content>
  </document>
  <document index="104">
    <source>utilities/fdmaffinemodeltermstructure.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmaffinemodeltermstructure.hpp
*/

#ifndef quantlib_fdm_affine_model_termstructure_hpp
#define quantlib_fdm_affine_model_termstructure_hpp

#include <ql/math/array.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>

namespace QuantLib {

    class AffineModel;

    class FdmAffineModelTermStructure : public YieldTermStructure {
      public:
        FdmAffineModelTermStructure(Array r,
                                    const Calendar& cal,
                                    const DayCounter& dayCounter,
                                    const Date& referenceDate,
                                    const Date& modelReferenceDate,
                                    ext::shared_ptr<AffineModel> model);

        Date maxDate() const override;
        void setVariable(const Array& r);

      protected:
        DiscountFactor discountImpl(Time) const override;

      private:
        Array r_;
        const Time t_;
        const ext::shared_ptr<AffineModel> model_;
    };
}
#endif
]]></document_content>
  </document>
  <document index="105">
    <source>utilities/fdmboundaryconditionset.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


/*! \file fdmboundaryconditionset.hpp
*/

#ifndef quantlib_fdm_boundary_condition_set_hpp
#define quantlib_fdm_boundary_condition_set_hpp

#include <ql/methods/finitedifferences/operatortraits.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearop.hpp>

namespace QuantLib {

    typedef OperatorTraits<FdmLinearOp>::bc_set FdmBoundaryConditionSet;

}

#endif
]]></document_content>
  </document>
  <document index="106">
    <source>utilities/fdmdirichletboundary.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


/*! \file fdmdirichletboundary.hpp
    \brief Dirichlet boundary conditions for differential operators
*/

#ifndef quantlib_fdm_dirichlet_boundary_hpp
#define quantlib_fdm_dirichlet_boundary_hpp

#include <ql/methods/finitedifferences/boundarycondition.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearop.hpp>

namespace QuantLib {

    class FdmMesher;
    class FdmLinearOpLayout;

    class FdmDirichletBoundary : public BoundaryCondition<FdmLinearOp> {
      public:
        // types and enumerations
        typedef FdmLinearOp operator_type;
        typedef FdmLinearOp::array_type array_type;
        typedef BoundaryCondition<FdmLinearOp>::Side Side;

        FdmDirichletBoundary(const ext::shared_ptr<FdmMesher>& mesher,
                             Real valueOnBoundary, Size direction, Side side);

        void applyBeforeApplying(operator_type&) const override;
        void applyBeforeSolving(operator_type&, array_type&) const override;
        void applyAfterApplying(array_type&) const override;
        void applyAfterSolving(array_type&) const override;
        void setTime(Time) override {}

        Real applyAfterApplying(Real x, Real value) const;

      private:
        const Side side_;  
        const Real valueOnBoundary_;
        const std::vector<Size> indices_;

        Real xExtreme_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="107">
    <source>utilities/fdmdiscountdirichletboundary.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2019 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


/*! \file fdmdiscountdirichletboundary.hpp
    \brief discounted value on Dirichlet boundary conditions
*/

#ifndef quantlib_fdm_discount_dirichlet_boundary_hpp
#define quantlib_fdm_discount_dirichlet_boundary_hpp

#include <ql/methods/finitedifferences/utilities/fdmtimedepdirichletboundary.hpp>

namespace QuantLib {

    class YieldTermStructure;

    class FdmDiscountDirichletBoundary
            : public BoundaryCondition<FdmLinearOp> {
      public:
        typedef FdmLinearOp operator_type;
        typedef FdmLinearOp::array_type array_type;
        typedef BoundaryCondition<FdmLinearOp>::Side Side;

        FdmDiscountDirichletBoundary(
            const ext::shared_ptr<FdmMesher>& mesher,
            const ext::shared_ptr<YieldTermStructure>& rTS,
            Time maturityTime,
            Real valueOnBoundary,
            Size direction, Side side);

        void setTime(Time) override;
        void applyBeforeApplying(operator_type&) const override;
        void applyBeforeSolving(operator_type&, array_type&) const override;
        void applyAfterApplying(array_type&) const override;
        void applyAfterSolving(array_type&) const override;

      private:
        const ext::shared_ptr<FdmTimeDepDirichletBoundary> bc_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="108">
    <source>utilities/fdmdividendhandler.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmdividendhandler.hpp
    \brief dividend handler for fdm method for one equity direction
*/

#ifndef quantlib_fdm_dividend_handler_hpp
#define quantlib_fdm_dividend_handler_hpp

#include <ql/instruments/dividendschedule.hpp>
#include <ql/methods/finitedifferences/stepcondition.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>

namespace QuantLib {
    
    class DayCounter;
    
    class FdmDividendHandler : public StepCondition<Array> {
      public:
        FdmDividendHandler(const DividendSchedule& schedule,
                           const ext::shared_ptr<FdmMesher>& mesher,
                           const Date& referenceDate,
                           const DayCounter& dayCounter,
                           Size equityDirection);

        void applyTo(Array& a, Time t) const override;

        const std::vector<Time>& dividendTimes() const;
        const std::vector<Date>& dividendDates() const;
        const std::vector<Real>& dividends() const;
        
      private:
        Array x_; // grid-equity values in physical units

        std::vector<Time> dividendTimes_;
        std::vector<Date> dividendDates_;
        std::vector<Real> dividends_;
        const ext::shared_ptr<FdmMesher> mesher_;
        const Size equityDirection_;
    };
}
#endif
]]></document_content>
  </document>
  <document index="109">
    <source>utilities/fdmescrowedloginnervaluecalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmescrowedloginnervaluecalculator.hpp
    \brief inner value for a escrowed dividend model
*/

#ifndef quantlib_fdm_escrowed_log_inner_value_calculator_hpp
#define quantlib_fdm_escrowed_log_inner_value_calculator_hpp

#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/methods/finitedifferences/utilities/escroweddividendadjustment.hpp>

namespace QuantLib {

    class Payoff;
    class FdmMesher;

    class FdmEscrowedLogInnerValueCalculator: public FdmInnerValueCalculator {
      public:
        FdmEscrowedLogInnerValueCalculator(
            ext::shared_ptr<EscrowedDividendAdjustment> escrowedDividendAdj,
            ext::shared_ptr<Payoff> payoff,
            ext::shared_ptr<FdmMesher> mesher,
            Size direction);

        Real innerValue(const FdmLinearOpIterator& iter, Time t) override;
        Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override;

      private:
        const ext::shared_ptr<EscrowedDividendAdjustment> escrowedDividendAdj_;
        const ext::shared_ptr<Payoff> payoff_;
        const ext::shared_ptr<FdmMesher> mesher_;
        const Size direction_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="110">
    <source>utilities/fdmindicesonboundary.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmindicesonboundary.hpp
    \brief helper class to extract the indices on a boundary
*/

#ifndef quantlib_fdm_indices_on_boundary_hpp
#define quantlib_fdm_indices_on_boundary_hpp

#include <ql/methods/finitedifferences/utilities/fdmdirichletboundary.hpp>

namespace QuantLib {

    class FdmLinearOpLayout;

    class FdmIndicesOnBoundary {
      public:
        FdmIndicesOnBoundary(const ext::shared_ptr<FdmLinearOpLayout>& l,
                              Size direction, FdmDirichletBoundary::Side side);

        const std::vector<Size>& getIndices() const;
      private:
        std::vector<Size> indices_;
    };
}
#endif

]]></document_content>
  </document>
  <document index="111">
    <source>utilities/fdminnervaluecalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdminnervaluecalculator.hpp
    \brief layer of abstraction to calculate the inner value
*/

#ifndef quantlib_fdm_inner_value_calculator_hpp
#define quantlib_fdm_inner_value_calculator_hpp

#include <ql/types.hpp>
#include <ql/shared_ptr.hpp>
#include <ql/math/functional.hpp>
#include <ql/functional.hpp>
#include <vector>


namespace QuantLib {

    class Payoff;
    class BasketPayoff;
    class FdmMesher;
    class FdmLinearOpIterator;


    class FdmInnerValueCalculator {
      public:
        virtual ~FdmInnerValueCalculator() = default;

        virtual Real innerValue(const FdmLinearOpIterator& iter, Time t) = 0;
        virtual Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) = 0;
    };


    class FdmCellAveragingInnerValue : public FdmInnerValueCalculator {
      public:
        FdmCellAveragingInnerValue(ext::shared_ptr<Payoff> payoff,
                                   ext::shared_ptr<FdmMesher> mesher,
                                   Size direction,
                                   ext::function<Real(Real)> gridMapping = identity<Real>());

        Real innerValue(const FdmLinearOpIterator& iter, Time) override;
        Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override;

      private:
        Real avgInnerValueCalc(const FdmLinearOpIterator& iter, Time t);

        const ext::shared_ptr<Payoff> payoff_;
        const ext::shared_ptr<FdmMesher> mesher_;
        const Size direction_;
        const ext::function<Real(Real)> gridMapping_;

        std::vector<Real> avgInnerValues_;
    };

    class FdmLogInnerValue : public FdmCellAveragingInnerValue {
      public:
        FdmLogInnerValue(const ext::shared_ptr<Payoff>& payoff,
                         const ext::shared_ptr<FdmMesher>& mesher,
                         Size direction);
    };

    class FdmLogBasketInnerValue : public FdmInnerValueCalculator {
      public:
        FdmLogBasketInnerValue(ext::shared_ptr<BasketPayoff> payoff,
                               ext::shared_ptr<FdmMesher> mesher);

        Real innerValue(const FdmLinearOpIterator& iter, Time) override;
        Real avgInnerValue(const FdmLinearOpIterator& iter, Time) override;

      private:
        const ext::shared_ptr<BasketPayoff> payoff_;
        const ext::shared_ptr<FdmMesher> mesher_;
    };

    class FdmZeroInnerValue : public FdmInnerValueCalculator {
      public:
        Real innerValue(const FdmLinearOpIterator&, Time) override { return 0.0; }
        Real avgInnerValue(const FdmLinearOpIterator&, Time) override { return 0.0; }
    };
}

#endif
]]></document_content>
  </document>
  <document index="112">
    <source>utilities/fdmmesherintegral.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmmesherintegral.hpp
    \brief mesher based integral over target function.
*/

#ifndef quantlib_fdm_mesher_integral_hpp
#define quantlib_fdm_mesher_integral_hpp

#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/functional.hpp>

namespace QuantLib {
    class FdmMesherIntegral {
      public:
        FdmMesherIntegral(
            const ext::shared_ptr<FdmMesherComposite>& mesher,
            const ext::function<Real(const Array&, const Array&)>&
                integrator1d);

        Real integrate(const Array& f) const;

      private:
        const std::vector<ext::shared_ptr<Fdm1dMesher> > meshers_;
        const ext::function<Real(const Array&, const Array&)>& integrator1d_;
    };
}
#endif
]]></document_content>
  </document>
  <document index="113">
    <source>utilities/fdmquantohelper.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmquantohelper.hpp
    \brief helper class storing market data needed for the quanto adjustment.
*/

#ifndef quantlib_fdm_quanto_helper_hpp
#define quantlib_fdm_quanto_helper_hpp

#include <ql/math/array.hpp>
#include <ql/patterns/observable.hpp>

namespace QuantLib {

    class YieldTermStructure;
    class BlackVolTermStructure;

    class FdmQuantoHelper : public Observable {
    public:
      FdmQuantoHelper(ext::shared_ptr<YieldTermStructure> rTS,
                      ext::shared_ptr<YieldTermStructure> fTS,
                      ext::shared_ptr<BlackVolTermStructure> fxVolTS,
                      Real equityFxCorrelation,
                      Real exchRateATMlevel);

      Rate quantoAdjustment(Volatility equityVol, Time t1, Time t2) const;
      Disposable<Array> quantoAdjustment(const Array& equityVol, Time t1, Time t2) const;

      const ext::shared_ptr<YieldTermStructure> rTS_, fTS_;
      const ext::shared_ptr<BlackVolTermStructure> fxVolTS_;
      const Real equityFxCorrelation_;
      const Real exchRateATMlevel_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="114">
    <source>utilities/fdmshoutloginnervaluecalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmshoutloginnervaluecalculator.hpp
    \brief inner value for a shout option
*/

#ifndef quantlib_fdm_shout_log_inner_value_calculator_hpp
#define quantlib_fdm_shout_log_inner_value_calculator_hpp

#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/methods/finitedifferences/utilities/escroweddividendadjustment.hpp>

namespace QuantLib {

    class FdmMesher;
    class PlainVanillaPayoff;
    class BlackVolTermStructure;

    class FdmShoutLogInnerValueCalculator: public FdmInnerValueCalculator {
      public:
        FdmShoutLogInnerValueCalculator(
            Handle<BlackVolTermStructure> blackVolatility,
            ext::shared_ptr<EscrowedDividendAdjustment> escrowedDividendAdj,
            Time maturity,
            ext::shared_ptr<PlainVanillaPayoff> payoff,
            ext::shared_ptr<FdmMesher> mesher,
            Size direction);

        Real innerValue(const FdmLinearOpIterator& iter, Time t) override;
        Real avgInnerValue(const FdmLinearOpIterator& iter, Time t) override;

      private:
        const Handle<BlackVolTermStructure> blackVolatility_;
        const ext::shared_ptr<EscrowedDividendAdjustment> escrowedDividendAdj_;
        const Time maturity_;
        const ext::shared_ptr<PlainVanillaPayoff> payoff_;
        const ext::shared_ptr<FdmMesher> mesher_;
        const Size direction_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="115">
    <source>utilities/fdmtimedepdirichletboundary.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


/*! \file fdmtimedepdirichletboundary.hpp
    \brief time dependent Dirichlet boundary conditions
*/

#ifndef quantlib_fdm_time_dep_dirichlet_boundary_hpp
#define quantlib_fdm_time_dep_dirichlet_boundary_hpp

#include <ql/methods/finitedifferences/boundarycondition.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearop.hpp>
#include <ql/functional.hpp>

namespace QuantLib {

    class FdmMesher;
    class FdmLinearOpLayout;

    class FdmTimeDepDirichletBoundary : public BoundaryCondition<FdmLinearOp> {
      public:
        // types and enumerations
        typedef FdmLinearOp operator_type;
        typedef FdmLinearOp::array_type array_type;
        typedef BoundaryCondition<FdmLinearOp>::Side Side;

        FdmTimeDepDirichletBoundary(const ext::shared_ptr<FdmMesher>& mesher,
                                    ext::function<Real(Real)> valueOnBoundary,
                                    Size direction,
                                    Side side);

        FdmTimeDepDirichletBoundary(const ext::shared_ptr<FdmMesher>& mesher,
                                    ext::function<Disposable<Array>(Real)> valueOnBoundary,
                                    Size direction,
                                    Side side);

        void setTime(Time) override;
        void applyBeforeApplying(operator_type&) const override {}
        void applyBeforeSolving(operator_type&, array_type&) const override {}
        void applyAfterApplying(array_type&) const override;
        void applyAfterSolving(array_type&) const override;

      private:
        const std::vector<Size> indices_;
        const ext::function<Real (Real)> valueOnBoundary_;
        const ext::function<Disposable<Array>(Real)> valuesOnBoundary_;

        Array values_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="116">
    <source>utilities/gbsmrndcalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2017 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gbsmrndcalculator.hpp
    \brief risk neutral terminal density calculator for the
           Black-Scholes-Merton model with strike dependent volatility
*/

#ifndef quantlib_gbsm_risk_neutral_density_calculator_hpp
#define quantlib_gbsm_risk_neutral_density_calculator_hpp

#include <ql/methods/finitedifferences/utilities/riskneutraldensitycalculator.hpp>
#include <ql/shared_ptr.hpp>

namespace QuantLib {
    class GeneralizedBlackScholesProcess;

    class GBSMRNDCalculator : public RiskNeutralDensityCalculator {
    public:
      explicit GBSMRNDCalculator(ext::shared_ptr<GeneralizedBlackScholesProcess> process);

      Real pdf(Real s, Time t) const override;
      Real cdf(Real s, Time t) const override;
      Real invcdf(Real q, Time t) const override;

    private:
      const ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="117">
    <source>utilities/hestonrndcalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes GÃ¶ttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hestonrndcalculator.hpp
    \brief risk neutral terminal density calculator for the
           Heston stochastic volatility model
*/

#ifndef quantlib_heston_risk_neutral_density_calculator_hpp
#define quantlib_heston_risk_neutral_density_calculator_hpp

#include <ql/methods/finitedifferences/utilities/riskneutraldensitycalculator.hpp>
#include <ql/shared_ptr.hpp>

namespace QuantLib {
    class HestonProcess;

    //! Risk neutral terminal probability density for the Heston model

    /*! References:

        The formulas are taken from A. Dragulescu, V. Yakovenko, 2002.
        Probability distribution of returns in the Heston model
        with stochastic volatility.
        http://arxiv.org/pdf/cond-mat/0203046.pdf
     */

    class HestonRNDCalculator : public RiskNeutralDensityCalculator {
    public:
      explicit HestonRNDCalculator(ext::shared_ptr<HestonProcess> hestonProcess,
                                   Real integrationEps = 1e-6,
                                   Size maxIntegrationIterations = 10000UL);

      // x=ln(S)
      Real pdf(Real x, Time t) const override;
      Real cdf(Real x, Time t) const override;
      Real invcdf(Real q, Time t) const override;

    private:
        Real x_t(Real x, Time t) const;

        const ext::shared_ptr<HestonProcess> hestonProcess_;
        const Real x0_;
        const Real integrationEps_;
        const Size maxIntegrationIterations_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="118">
    <source>utilities/localvolrndcalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes GÃ¶ttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file localvolrndcalculator.hpp
    \brief local volatility risk neutral terminal density calculation
*/

#ifndef quantlib_local_vol_rnd_calculator_hpp
#define quantlib_local_vol_rnd_calculator_hpp

#include <ql/math/matrix.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/patterns/lazyobject.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/methods/finitedifferences/meshers/fdm1dmesher.hpp>
#include <ql/methods/finitedifferences/utilities/riskneutraldensitycalculator.hpp>

#include <vector>

namespace QuantLib {
	class TimeGrid;
	class Fdm1dMesher;
	class Interpolation;
	class LocalVolTermStructure;

	class LocalVolRNDCalculator : public RiskNeutralDensityCalculator,
								  public LazyObject {
	  public:
            LocalVolRNDCalculator(ext::shared_ptr<Quote> spot,
                                  ext::shared_ptr<YieldTermStructure> rTS,
                                  ext::shared_ptr<YieldTermStructure> qTS,
                                  const ext::shared_ptr<LocalVolTermStructure>& localVol,
                                  Size xGrid = 101,
                                  Size tGrid = 51,
                                  Real x0Density = 0.1,
                                  Real localVolProbEps = 1e-6,
                                  Size maxIter = 10000,
                                  Time gaussianStepSize = -Null<Time>());

            LocalVolRNDCalculator(ext::shared_ptr<Quote> spot,
                                  ext::shared_ptr<YieldTermStructure> rTS,
                                  ext::shared_ptr<YieldTermStructure> qTS,
                                  ext::shared_ptr<LocalVolTermStructure> localVol,
                                  const ext::shared_ptr<TimeGrid>& timeGrid,
                                  Size xGrid = 101,
                                  Real x0Density = 0.1,
                                  Real eps = 1e-6,
                                  Size maxIter = 10000,
                                  Time gaussianStepSize = -Null<Time>());

            Real pdf(Real x, Time t) const override;
            Real cdf(Real x, Time t) const override;
            Real invcdf(Real p, Time t) const override;

            ext::shared_ptr<TimeGrid> timeGrid() const;
            ext::shared_ptr<Fdm1dMesher> mesher(Time t) const;
            Disposable<std::vector<Size> > rescaleTimeSteps() const;

	  protected:
            void performCalculations() const override;

          private:
		Real probabilityInterpolation(Size idx, Real x) const;
		Disposable<Array> rescalePDF(const Array& x, const Array& p) const;


		const Size xGrid_, tGrid_;
		const Real x0Density_;
		const Real localVolProbEps_;
		const Size maxIter_;
		const Time gaussianStepSize_;
		const ext::shared_ptr<Quote> spot_;
		const ext::shared_ptr<LocalVolTermStructure> localVol_;
		const ext::shared_ptr<YieldTermStructure> rTS_;
		const ext::shared_ptr<YieldTermStructure> qTS_;
		const ext::shared_ptr<TimeGrid> timeGrid_;
		mutable std::vector<ext::shared_ptr<Fdm1dMesher> > xm_;
		const ext::shared_ptr<Matrix> pm_;
		mutable std::vector<Size> rescaleTimeSteps_;
		mutable std::vector<ext::shared_ptr<Interpolation> > pFct_;
	};
}

#endif
]]></document_content>
  </document>
  <document index="119">
    <source>utilities/riskneutraldensitycalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes GÃ¶ttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file riskneutraldensitycalculator.hpp
    \brief interface for a single asset risk neutral terminal density calculation
*/

#ifndef quantlib_risk_neutral_density_calculator_hpp
#define quantlib_risk_neutral_density_calculator_hpp

#include <ql/types.hpp>

namespace QuantLib {
    class RiskNeutralDensityCalculator {
      public:
        virtual Real pdf(Real x, Time t) const = 0;
        virtual Real cdf(Real x, Time t) const = 0;
        virtual Real invcdf(Real p, Time t) const = 0;

        virtual ~RiskNeutralDensityCalculator() = default;

      protected:
        class InvCDFHelper {
          public:
            InvCDFHelper(const RiskNeutralDensityCalculator* calculator,
                         Real guess, Real accuracy, Size maxEvaluations,
                         Real stepSize=0.01);

            Real inverseCDF(Real p, Time t) const;
          private:
            const RiskNeutralDensityCalculator* const calculator_;
            const Real guess_;
            const Real accuracy_;
            const Size maxEvaluations_;
            const Real stepSize_;
        };
    };
}

#endif
]]></document_content>
  </document>
  <document index="120">
    <source>utilities/squarerootprocessrndcalculator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes GÃ¶ttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bsmrndcalculator.hpp
    \brief risk neutral terminal density calculator for the square root process
*/

#ifndef quantlib_square_root_process_risk_neutral_density_calculator_hpp
#define quantlib_square_root_process_risk_neutral_density_calculator_hpp

#include <ql/methods/finitedifferences/utilities/riskneutraldensitycalculator.hpp>

namespace QuantLib {
    class SquareRootProcessRNDCalculator : public RiskNeutralDensityCalculator {
      public:
        SquareRootProcessRNDCalculator(
            Real v0, Real kappa, Real theta, Real sigma);

        Real pdf(Real v, Time t) const override;
        Real cdf(Real v, Time t) const override;
        Real invcdf(Real q, Time t) const override;

        Real stationary_pdf(Real v) const;
        Real stationary_cdf(Real v) const;
        Real stationary_invcdf(Real q) const;

      private:
        const Real v0_, kappa_, theta_, d_, df_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="121">
    <source>zerocondition.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file zerocondition.hpp
    \brief zero option exercise condition
*/

#ifndef quantlib_fd_zero_condition_h
#define quantlib_fd_zero_condition_h

#include <ql/methods/finitedifferences/stepcondition.hpp>

namespace QuantLib {

    //! Zero exercise condition.
    /*! Used in CEV models */
    template <class array_type>
    class ZeroCondition :  public StepCondition<array_type> {
    public:
        void applyTo(array_type& a, Time) const {
            for(Size i=0; i < a.size(); i++) {
                a[i] = std::max(a[i], 0.0);
            }
        }
    };
}


#endif
]]></document_content>
  </document>
</documents>