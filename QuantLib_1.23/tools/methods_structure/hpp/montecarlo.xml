<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/methods/montecarlo/brownianbridge.hpp>
#include <ql/methods/montecarlo/earlyexercisepathpricer.hpp>
#include <ql/methods/montecarlo/exercisestrategy.hpp>
#include <ql/methods/montecarlo/genericlsregression.hpp>
#include <ql/methods/montecarlo/longstaffschwartzpathpricer.hpp>
#include <ql/methods/montecarlo/lsmbasissystem.hpp>
#include <ql/methods/montecarlo/mctraits.hpp>
#include <ql/methods/montecarlo/montecarlomodel.hpp>
#include <ql/methods/montecarlo/multipath.hpp>
#include <ql/methods/montecarlo/multipathgenerator.hpp>
#include <ql/methods/montecarlo/nodedata.hpp>
#include <ql/methods/montecarlo/parametricexercise.hpp>
#include <ql/methods/montecarlo/path.hpp>
#include <ql/methods/montecarlo/pathgenerator.hpp>
#include <ql/methods/montecarlo/pathpricer.hpp>
#include <ql/methods/montecarlo/sample.hpp>

]]></document_content>
  </document>
  <document index="2">
    <source>brownianbridge.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2006 StatPro Italia srl
 Copyright (C) 2009 Bojan Nikolic

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file brownianbridge.hpp
    \brief Browian bridge
*/

// ===========================================================================
// NOTE: The following copyright notice applies to the original code,
//
// Copyright (C) 2002 Peter Jï¿½ckel "Monte Carlo Methods in Finance".
// All rights reserved.
//
// Permission to use, copy, modify, and distribute this software is freely
// granted, provided that this notice is preserved.
// ===========================================================================

#ifndef quantlib_brownian_bridge_hpp
#define quantlib_brownian_bridge_hpp

#include <ql/methods/montecarlo/path.hpp>
#include <ql/methods/montecarlo/sample.hpp>

namespace QuantLib {

    //! Builds Wiener process paths using Gaussian variates
    /*! This class generates normalized (i.e., unit-variance) paths as
        sequences of variations. In order to obtain the actual path of
        the underlying, the returned variations must be multiplied by
        the integrated variance (including time) over the
        corresponding time step.

        \ingroup mcarlo
    */
    class BrownianBridge {
      public:
        /*! The constructor generates the time grid so that each step
            is of unit-time length.

            \param steps The number of steps in the path
        */
        BrownianBridge(Size steps);
        /*! The step times are copied from the supplied vector

            \param times A vector containing the times at which the
                         steps occur. This also defines the number of
                         steps that will be generated.

            \note the starting time of the path is assumed to be 0 and
                  must not be included
        */
        BrownianBridge(const std::vector<Time>& times);
        /*! The step times are copied from the TimeGrid object

            \param timeGrid a time grid containing the times at which
                            the steps will occur
        */
        BrownianBridge(const TimeGrid& timeGrid);
        //! \name inspectors
        //@{
        Size size() const { return size_; }
        const std::vector<Time>& times() const { return t_; }
        const std::vector<Size>& bridgeIndex()  const { return bridgeIndex_; }
        const std::vector<Size>& leftIndex()    const { return leftIndex_; }
        const std::vector<Size>& rightIndex()   const { return rightIndex_; }
        const std::vector<Real>& leftWeight()   const { return leftWeight_; }
        const std::vector<Real>& rightWeight()  const { return rightWeight_; }
        const std::vector<Real>& stdDeviation() const { return stdDev_; }
        //@}

        //! Brownian-bridge generator function
        /*! Transforms an input sequence of random variates into a
            sequence of variations in a Brownian bridge path.

            \param begin  The start iterator of the input sequence.
            \param end    The end iterator of the input sequence.
            \param output The start iterator of the output sequence.

            \note To get the canonical Brownian bridge which starts
                  and finishes at the same value, the first element of
                  the input sequence must be zero. Conversely, to get
                  a sloped bridge set the first element to a non-zero
                  value. In this case, the final value in the bridge
                  will be sqrt(last time point)*(first element of
                  input sequence).
        */
        template <class RandomAccessIterator1,
                  class RandomAccessIterator2>
        void transform(RandomAccessIterator1 begin,
                       RandomAccessIterator1 end,
                       RandomAccessIterator2 output) const {
            QL_REQUIRE(end >= begin, "invalid sequence");
            QL_REQUIRE(Size(end-begin) == size_,
                       "incompatible sequence size");
            // We use output to store the path...
            output[size_-1] = stdDev_[0] * begin[0];
            for (Size i=1; i<size_; ++i) {
                Size j = leftIndex_[i];
                Size k = rightIndex_[i];
                Size l = bridgeIndex_[i];
                if (j != 0) {
                    output[l] =
                        leftWeight_[i] * output[j-1] +
                        rightWeight_[i] * output[k]   +
                        stdDev_[i] * begin[i];
                } else {
                    output[l] =
                        rightWeight_[i] * output[k]   +
                        stdDev_[i] * begin[i];
                }
            }
            // ...after which, we calculate the variations and
            // normalize to unit times
            for (Size i=size_-1; i>=1; --i) {
                output[i] -= output[i-1];
                output[i] /= sqrtdt_[i];
            }
            output[0] /= sqrtdt_[0];
        }
      private:
        void initialize();
        Size size_;
        std::vector<Time> t_;
        std::vector<Real> sqrtdt_;
        std::vector<Size> bridgeIndex_, leftIndex_, rightIndex_;
        std::vector<Real> leftWeight_, rightWeight_, stdDev_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="3">
    <source>earlyexercisepathpricer.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file earlyexercisepathpricer.hpp
    \brief base class for early exercise single-path pricers
*/

#ifndef quantlib_early_exercise_path_pricer_hpp
#define quantlib_early_exercise_path_pricer_hpp

#include <ql/math/array.hpp>
#include <ql/methods/montecarlo/path.hpp>
#include <ql/methods/montecarlo/multipath.hpp>
#include <ql/functional.hpp>

namespace QuantLib {

    template <class PathType>
    class EarlyExerciseTraits {
        // dummy definition, will not work
    };

    template <>
    class EarlyExerciseTraits<Path> {
      public:
        typedef Real StateType;
        static Size pathLength(const Path& path) {
            return path.length();
        }
    };

    template <>
    class EarlyExerciseTraits<MultiPath> {
      public:
        typedef Array StateType;
        static Size pathLength(const MultiPath& path) {
            return path.pathSize();
        }
    };

    //! base class for early exercise path pricers
    /*! Returns the value of an option on a given path and given time.

        \ingroup mcarlo
    */
    template<class PathType,
             class TimeType=Size, class ValueType=Real>
    class EarlyExercisePathPricer {
      public:
        typedef typename EarlyExerciseTraits<PathType>::StateType StateType;

        virtual ~EarlyExercisePathPricer() = default;
        virtual ValueType operator()(const PathType& path,
                                     TimeType t) const = 0;

        virtual StateType
            state(const PathType& path, TimeType t) const = 0;
        virtual std::vector<ext::function<ValueType(StateType)> >
            basisSystem() const = 0;
    };
}


#endif
]]></document_content>
  </document>
  <document index="4">
    <source>exercisestrategy.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_exercise_strategy_hpp
#define quantlib_exercise_strategy_hpp

#include <ql/types.hpp>
#include <vector>
#include <memory>

namespace QuantLib {

    template <class State>
    class ExerciseStrategy {
      public:
        virtual ~ExerciseStrategy() = default;
        virtual std::vector<Time> exerciseTimes() const = 0;
        virtual std::vector<Time> relevantTimes() const = 0;
        virtual void reset() = 0;
        virtual bool exercise(const State& currentState) const = 0;
        virtual void nextStep(const State& currentState) = 0;
        #if defined(QL_USE_STD_UNIQUE_PTR)
        virtual std::unique_ptr<ExerciseStrategy<State> > clone() const = 0;
        #else
        virtual std::auto_ptr<ExerciseStrategy<State> > clone() const = 0;
        #endif
    };

}


#endif
]]></document_content>
  </document>
  <document index="5">
    <source>genericlsregression.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_generic_longstaff_schwartz_hpp
#define quantlib_generic_longstaff_schwartz_hpp

#include <ql/methods/montecarlo/nodedata.hpp>

namespace QuantLib {

    //! returns the biased estimate obtained while regressing
    /* TODO document:
       n exercises, n+1 elements in simulationData
       simulationData[0][j] -> cashflows up to first exercise, j-th path
       simulationData[i+1][j] -> i-th exercise, j-th path

       simulationData[0][j].foo unused (unusable?) if foo != cumulatedCashFlows

       basisCoefficients.size() = n
    */
    Real genericLongstaffSchwartzRegression(
        std::vector<std::vector<NodeData> >& simulationData,
        std::vector<std::vector<Real> >& basisCoefficients);

}


#endif

]]></document_content>
  </document>
  <document index="6">
    <source>longstaffschwartzpathpricer.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Klaus Spanderen
 Copyright (C) 2015 Peter Caspers
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file longstaffschwartzpathpricer.hpp
    \brief Longstaff-Schwarz path pricer for early exercise options
*/

#ifndef quantlib_longstaff_schwartz_path_pricer_hpp
#define quantlib_longstaff_schwartz_path_pricer_hpp

#include <ql/functional.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/generallinearleastsquares.hpp>
#include <ql/math/statistics/incrementalstatistics.hpp>
#include <ql/methods/montecarlo/earlyexercisepathpricer.hpp>
#include <ql/methods/montecarlo/pathpricer.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#if !defined(QL_USE_STD_UNIQUE_PTR)
#include <boost/scoped_array.hpp>
#endif
#include <utility>
#include <memory>

namespace QuantLib {

    //! Longstaff-Schwarz path pricer for early exercise options
    /*! References:

        Francis Longstaff, Eduardo Schwartz, 2001. Valuing American Options
        by Simulation: A Simple Least-Squares Approach, The Review of
        Financial Studies, Volume 14, No. 1, 113-147

        \ingroup mcarlo

        \test the correctness of the returned value is tested by
              reproducing results available in web/literature
    */
    template <class PathType>
    class LongstaffSchwartzPathPricer : public PathPricer<PathType> {
      public:
        typedef typename EarlyExerciseTraits<PathType>::StateType StateType;

        LongstaffSchwartzPathPricer(const TimeGrid& times,
                                    ext::shared_ptr<EarlyExercisePathPricer<PathType> >,
                                    const ext::shared_ptr<YieldTermStructure>& termStructure);

        Real operator()(const PathType& path) const override;
        virtual void calibrate();

        Real exerciseProbability() const;

      protected:
        virtual void post_processing(const Size i,
                                     const std::vector<StateType> &state,
                                     const std::vector<Real> &price,
                                     const std::vector<Real> &exercise) {}
        bool  calibrationPhase_;
        const ext::shared_ptr<EarlyExercisePathPricer<PathType> >
            pathPricer_;

        mutable QuantLib::IncrementalStatistics exerciseProbability_;

        #if defined(QL_USE_STD_UNIQUE_PTR)
        std::unique_ptr<Array[]> coeff_;
        std::unique_ptr<DiscountFactor[]> dF_;
        #else
        boost::scoped_array<Array> coeff_;
        boost::scoped_array<DiscountFactor> dF_;
        #endif

        mutable std::vector<PathType> paths_;
        const   std::vector<ext::function<Real(StateType)> > v_;

        const Size len_;
    };

    template <class PathType>
    inline LongstaffSchwartzPathPricer<PathType>::LongstaffSchwartzPathPricer(
        const TimeGrid& times,
        ext::shared_ptr<EarlyExercisePathPricer<PathType> > pathPricer,
        const ext::shared_ptr<YieldTermStructure>& termStructure)
    : calibrationPhase_(true), pathPricer_(std::move(pathPricer)),
      coeff_(new Array[times.size() - 2]), dF_(new DiscountFactor[times.size() - 1]),
      v_(pathPricer_->basisSystem()), len_(times.size()) {

        for (Size i=0; i<times.size()-1; ++i) {
            dF_[i] =   termStructure->discount(times[i+1])
                     / termStructure->discount(times[i]);
        }
    }

    template <class PathType> inline
    Real LongstaffSchwartzPathPricer<PathType>::operator()
        (const PathType& path) const {
        if (calibrationPhase_) {
            // store paths for the calibration
            paths_.push_back(path);
            // result doesn't matter
            return 0.0;
        }

        Real price = (*pathPricer_)(path, len_-1);

        // Initialize with exercise on last date
        bool exercised = (price > 0.0);

        for (Size i=len_-2; i>0; --i) {
            price*=dF_[i];

            const Real exercise = (*pathPricer_)(path, i);
            if (exercise > 0.0) {
                const StateType regValue = pathPricer_->state(path, i);

                Real continuationValue = 0.0;
                for (Size l=0; l<v_.size(); ++l) {
                    continuationValue += coeff_[i-1][l] * v_[l](regValue);
                }

                if (continuationValue < exercise) {
                    price = exercise;

                    // Exercised
                    exercised = true;
                }
            }
        }

        exerciseProbability_.add(exercised ? 1.0 : 0.0);

        return price*dF_[0];
    }

    template <class PathType> inline
    void LongstaffSchwartzPathPricer<PathType>::calibrate() {
        const Size n = paths_.size();
        Array prices(n), exercise(n);
        std::vector<StateType> p_state(n);
        std::vector<Real> p_price(n), p_exercise(n);

        for (Size i=0; i<n; ++i) {
            p_state[i] = pathPricer_->state(paths_[i],len_-1);
            prices[i] = p_price[i] = (*pathPricer_)(paths_[i], len_-1);
            p_exercise[i] = prices[i];
        }

        post_processing(len_ - 1, p_state, p_price, p_exercise);

        std::vector<Real>      y;
        std::vector<StateType> x;
        for (Size i=len_-2; i>0; --i) {
            y.clear();
            x.clear();

            //roll back step
            for (Size j=0; j<n; ++j) {
                exercise[j]=(*pathPricer_)(paths_[j], i);
                if (exercise[j]>0.0) {
                    x.push_back(pathPricer_->state(paths_[j], i));
                    y.push_back(dF_[i]*prices[j]);
                }
            }

            if (v_.size() <=  x.size()) {
                coeff_[i-1] = GeneralLinearLeastSquares(x, y, v_).coefficients();
            }
            else {
            // if number of itm paths is smaller then the number of
            // calibration functions then early exercise if exerciseValue > 0
                coeff_[i-1] = Array(v_.size(), 0.0);
            }

            for (Size j=0, k=0; j<n; ++j) {
                prices[j]*=dF_[i];
                if (exercise[j]>0.0) {
                    Real continuationValue = 0.0;
                    for (Size l=0; l<v_.size(); ++l) {
                        continuationValue += coeff_[i-1][l] * v_[l](x[k]);
                    }
                    if (continuationValue < exercise[j]) {
                        prices[j] = exercise[j];
                    }
                    ++k;
                }
                p_state[j] = pathPricer_->state(paths_[j],i);
                p_price[j] = prices[j];
                p_exercise[j] = exercise[j];
            }

            post_processing(i, p_state, p_price, p_exercise);
        }

        // remove calibration paths and release memory
        std::vector<PathType> empty;
        paths_.swap(empty);
        // entering the calculation phase
        calibrationPhase_ = false;
    }

    template <class PathType> inline
    Real LongstaffSchwartzPathPricer<PathType>::exerciseProbability() const {
        return exerciseProbability_.mean();
    }


}


#endif
]]></document_content>
  </document>
  <document index="7">
    <source>lsmbasissystem.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Klaus Spanderen
 Copyright (C) 2010 Kakhkhor Abdijalilov

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file lsmbasissystem.hpp
    \brief utility classes for Longstaff-Schwartz early-exercise Monte Carlo
*/

// lsmbasissystem.hpp

#ifndef quantlib_lsm_basis_system_hpp
#define quantlib_lsm_basis_system_hpp

#include <ql/qldefines.hpp>
#include <ql/math/array.hpp>
#include <ql/functional.hpp>
#include <vector>

namespace QuantLib {

    class LsmBasisSystem {
      public:
        enum PolynomType { Monomial, Laguerre, Hermite, Hyperbolic,
                           Legendre, Chebyshev, Chebyshev2nd };

        static std::vector<ext::function<Real(Real)> >
            pathBasisSystem(Size order, PolynomType polyType);

        static std::vector<ext::function<Real(Array)> >
            multiPathBasisSystem(Size dim, Size order, PolynomType polyType);
    };


}

#endif
]]></document_content>
  </document>
  <document index="8">
    <source>mctraits.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mctraits.hpp
    \brief Monte Carlo policies
*/

#ifndef quantlib_mc_traits_hpp
#define quantlib_mc_traits_hpp

#include <ql/methods/montecarlo/pathgenerator.hpp>
#include <ql/methods/montecarlo/multipathgenerator.hpp>
#include <ql/methods/montecarlo/pathpricer.hpp>
#include <ql/math/randomnumbers/rngtraits.hpp>

namespace QuantLib {

    // path generation and pricing traits

    //! default Monte Carlo traits for single-variate models
    template <class RNG = PseudoRandom>
    struct SingleVariate {
        typedef RNG rng_traits;
        typedef Path path_type;
        typedef PathPricer<path_type> path_pricer_type;
        typedef typename RNG::rsg_type rsg_type;
        typedef PathGenerator<rsg_type> path_generator_type;
        enum { allowsErrorEstimate = RNG::allowsErrorEstimate };
    };

    //! default Monte Carlo traits for multi-variate models
    template <class RNG = PseudoRandom>
    struct MultiVariate {
        typedef RNG rng_traits;
        typedef MultiPath path_type;
        typedef PathPricer<path_type> path_pricer_type;
        typedef typename RNG::rsg_type rsg_type;
        typedef MultiPathGenerator<rsg_type> path_generator_type;
        enum { allowsErrorEstimate = RNG::allowsErrorEstimate };
    };

}


#endif
]]></document_content>
  </document>
  <document index="9">
    <source>montecarlomodel.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file montecarlomodel.hpp
    \brief General-purpose Monte Carlo model
*/

#ifndef quantlib_montecarlo_model_hpp
#define quantlib_montecarlo_model_hpp

#include <ql/math/statistics/statistics.hpp>
#include <ql/methods/montecarlo/mctraits.hpp>
#include <ql/shared_ptr.hpp>
#include <utility>

namespace QuantLib {

    //! General-purpose Monte Carlo model for path samples
    /*! The template arguments of this class correspond to available
        policies for the particular model to be instantiated---i.e.,
        whether it is single- or multi-asset, or whether it should use
        pseudo-random or low-discrepancy numbers for path
        generation. Such decisions are grouped in trait classes so as
        to be orthogonal---see mctraits.hpp for examples.

        The constructor accepts two safe references, i.e. two smart
        pointers, one to a path generator and the other to a path
        pricer.  In case of control variate technique the user should
        provide the additional control option, namely the option path
        pricer and the option value.

        \ingroup mcarlo
    */
    template <template <class> class MC, class RNG, class S = Statistics>
    class MonteCarloModel {
      public:
        typedef MC<RNG> mc_traits;
        typedef RNG rng_traits;
        typedef typename MC<RNG>::path_generator_type path_generator_type;
        typedef typename MC<RNG>::path_pricer_type path_pricer_type;
        typedef typename path_generator_type::sample_type sample_type;
        typedef typename path_pricer_type::result_type result_type;
        typedef S stats_type;
        // constructor
        MonteCarloModel(
            ext::shared_ptr<path_generator_type> pathGenerator,
            ext::shared_ptr<path_pricer_type> pathPricer,
            stats_type sampleAccumulator,
            bool antitheticVariate,
            ext::shared_ptr<path_pricer_type> cvPathPricer = ext::shared_ptr<path_pricer_type>(),
            result_type cvOptionValue = result_type(),
            ext::shared_ptr<path_generator_type> cvPathGenerator =
                ext::shared_ptr<path_generator_type>())
        : pathGenerator_(std::move(pathGenerator)), pathPricer_(std::move(pathPricer)),
          sampleAccumulator_(std::move(sampleAccumulator)), isAntitheticVariate_(antitheticVariate),
          cvPathPricer_(std::move(cvPathPricer)), cvOptionValue_(cvOptionValue),
          cvPathGenerator_(std::move(cvPathGenerator)) {
            isControlVariate_ = static_cast<bool>(cvPathPricer_);
        }
        void addSamples(Size samples);
        const stats_type& sampleAccumulator() const;
      private:
        ext::shared_ptr<path_generator_type> pathGenerator_;
        ext::shared_ptr<path_pricer_type> pathPricer_;
        stats_type sampleAccumulator_;
        bool isAntitheticVariate_;
        ext::shared_ptr<path_pricer_type> cvPathPricer_;
        result_type cvOptionValue_;
        bool isControlVariate_;
        ext::shared_ptr<path_generator_type> cvPathGenerator_;
    };

    // inline definitions
    template <template <class> class MC, class RNG, class S>
    inline void MonteCarloModel<MC,RNG,S>::addSamples(Size samples) {
        for(Size j = 1; j <= samples; j++) {

            const sample_type& path = pathGenerator_->next();
            result_type price = (*pathPricer_)(path.value);

            if (isControlVariate_) {
                if (!cvPathGenerator_) {
                    price += cvOptionValue_-(*cvPathPricer_)(path.value);
                }
                else {
                    const sample_type& cvPath = cvPathGenerator_->next();
                    price += cvOptionValue_-(*cvPathPricer_)(cvPath.value);
                }
            }

            if (isAntitheticVariate_) {
                const sample_type& atPath = pathGenerator_->antithetic();
                result_type price2 = (*pathPricer_)(atPath.value);
                if (isControlVariate_) {
                    if (!cvPathGenerator_)
                        price2 += cvOptionValue_-(*cvPathPricer_)(atPath.value);
                    else {
                        const sample_type& cvPath = cvPathGenerator_->antithetic();
                        price2 += cvOptionValue_-(*cvPathPricer_)(cvPath.value);
                    }
                }

                sampleAccumulator_.add((price+price2)/2.0, path.weight);
            } else {
                sampleAccumulator_.add(price, path.weight);
            }
        }
    }

    template <template <class> class MC, class RNG, class S>
    inline const typename MonteCarloModel<MC,RNG,S>::stats_type&
    MonteCarloModel<MC,RNG,S>::sampleAccumulator() const {
        return sampleAccumulator_;
    }

}


#endif
]]></document_content>
  </document>
  <document index="10">
    <source>multipath.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file multipath.hpp
    \brief Correlated multiple asset paths
*/

#ifndef quantlib_montecarlo_multi_path_hpp
#define quantlib_montecarlo_multi_path_hpp

#include <ql/methods/montecarlo/path.hpp>
#include <utility>

namespace QuantLib {

    //! Correlated multiple asset paths
    /*! MultiPath contains the list of paths for each asset, i.e.,
        multipath[j] is the path followed by the j-th asset.

        \ingroup mcarlo
    */
    class MultiPath {
      public:
        MultiPath() = default;
        MultiPath(Size nAsset,
                  const TimeGrid& timeGrid);
        MultiPath(std::vector<Path> multiPath);
        //! \name inspectors
        //@{
        Size assetNumber() const { return multiPath_.size(); }
        Size pathSize() const { return multiPath_[0].length(); }
        //@}
        //! \name read/write access to components
        //@{
        const Path& operator[](Size j) const { return multiPath_[j]; }
        const Path& at(Size j) const { return multiPath_.at(j); }
        Path& operator[](Size j) { return multiPath_[j]; }
        Path& at(Size j) { return multiPath_.at(j); }
        //@}
      private:
        std::vector<Path> multiPath_;
    };


    // inline definitions

    inline MultiPath::MultiPath(Size nAsset, const TimeGrid& timeGrid)
    : multiPath_(nAsset,Path(timeGrid)) {
        QL_REQUIRE(nAsset > 0, "number of asset must be positive");
    }

    inline MultiPath::MultiPath(std::vector<Path> multiPath) : multiPath_(std::move(multiPath)) {}
}


#endif
]]></document_content>
  </document>
  <document index="11">
    <source>multipathgenerator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2003, 2004, 2005 StatPro Italia srl
 Copyright (C) 2005 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file multipathgenerator.hpp
    \brief Generates a multi path from a random-array generator
*/

#ifndef quantlib_multi_path_generator_hpp
#define quantlib_multi_path_generator_hpp

#include <ql/methods/montecarlo/multipath.hpp>
#include <ql/methods/montecarlo/sample.hpp>
#include <ql/stochasticprocess.hpp>
#include <utility>

namespace QuantLib {

    //! Generates a multipath from a random number generator.
    /*! RSG is a sample generator which returns a random sequence.
        It must have the minimal interface:
        \code
        RSG {
            Sample<Array> next();
        };
        \endcode

        \ingroup mcarlo

        \test the generated paths are checked against cached results
    */
    template <class GSG>
    class MultiPathGenerator {
      public:
        typedef Sample<MultiPath> sample_type;
        MultiPathGenerator(const ext::shared_ptr<StochasticProcess>&,
                           const TimeGrid&,
                           GSG generator,
                           bool brownianBridge = false);
        const sample_type& next() const;
        const sample_type& antithetic() const;
      private:
        const sample_type& next(bool antithetic) const;
        bool brownianBridge_;
        ext::shared_ptr<StochasticProcess> process_;
        GSG generator_;
        mutable sample_type next_;
    };


    // template definitions

    template <class GSG>
    MultiPathGenerator<GSG>::MultiPathGenerator(const ext::shared_ptr<StochasticProcess>& process,
                                                const TimeGrid& times,
                                                GSG generator,
                                                bool brownianBridge)
    : brownianBridge_(brownianBridge), process_(process), generator_(std::move(generator)),
      next_(MultiPath(process->size(), times), 1.0) {

        QL_REQUIRE(generator_.dimension() ==
                   process->factors()*(times.size()-1),
                   "dimension (" << generator_.dimension()
                   << ") is not equal to ("
                   << process->factors() << " * " << times.size()-1
                   << ") the number of factors "
                   << "times the number of time steps");
        QL_REQUIRE(times.size() > 1,
                   "no times given");
    }

    template <class GSG>
    inline const typename MultiPathGenerator<GSG>::sample_type&
    MultiPathGenerator<GSG>::next() const {
        return next(false);
    }

    template <class GSG>
    inline const typename MultiPathGenerator<GSG>::sample_type&
    MultiPathGenerator<GSG>::antithetic() const {
        return next(true);
    }

    template <class GSG>
    const typename MultiPathGenerator<GSG>::sample_type&
    MultiPathGenerator<GSG>::next(bool antithetic) const {

        if (brownianBridge_) {

            QL_FAIL("Brownian bridge not supported");

        } else {

            typedef typename GSG::sample_type sequence_type;
            const sequence_type& sequence_ =
                antithetic ? generator_.lastSequence()
                           : generator_.nextSequence();

            Size m = process_->size();
            Size n = process_->factors();

            MultiPath& path = next_.value;

            Array asset = process_->initialValues();
            for (Size j=0; j<m; j++)
                path[j].front() = asset[j];

            Array temp(n);
            next_.weight = sequence_.weight;

            const TimeGrid& timeGrid = path[0].timeGrid();
            Time t, dt;
            for (Size i = 1; i < path.pathSize(); i++) {
                Size offset = (i-1)*n;
                t = timeGrid[i-1];
                dt = timeGrid.dt(i-1);
                if (antithetic)
                    std::transform(sequence_.value.begin()+offset,
                                   sequence_.value.begin()+offset+n,
                                   temp.begin(),
                                   std::negate<Real>());
                else
                    std::copy(sequence_.value.begin()+offset,
                              sequence_.value.begin()+offset+n,
                              temp.begin());

                asset = process_->evolve(t, asset, dt, temp);
                for (Size j=0; j<m; j++)
                    path[j][i] = asset[j];
            }
            return next_;
        }
    }

}

#endif
]]></document_content>
  </document>
  <document index="12">
    <source>nodedata.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_monte_carlo_node_data_hpp
#define quantlib_monte_carlo_node_data_hpp

#include <ql/types.hpp>
#include <vector>

namespace QuantLib {

    struct NodeData {
        Real exerciseValue;
        Real cumulatedCashFlows;
        std::vector<Real> values;
        Real controlValue;
        bool isValid;
    };

}


#endif

]]></document_content>
  </document>
  <document index="13">
    <source>parametricexercise.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#ifndef quantlib_parametric_exercise_hpp
#define quantlib_parametric_exercise_hpp

#include <ql/methods/montecarlo/nodedata.hpp>
#include <ql/math/optimization/method.hpp>

namespace QuantLib {

    class ParametricExercise {
      public:
        virtual ~ParametricExercise() = default;
        // possibly different for each exercise
        virtual std::vector<Size> numberOfVariables() const = 0;
        virtual std::vector<Size> numberOfParameters() const = 0;
        virtual bool exercise(Size exerciseNumber,
                              const std::vector<Real>& parameters,
                              const std::vector<Real>& variables) const = 0;
        virtual void guess(Size exerciseNumber,
                           std::vector<Real>& parameters) const = 0;
    };
    

    //! returns the biased estimate obtained while optimizing
    /* TODO document:
       n exercises, n+1 elements in simulationData
       simulationData[0][j] -> cashflows up to first exercise, j-th path
       simulationData[i+1][j] -> i-th exercise, j-th path

       simulationData[0][j].foo unused (unusable?) if foo != cumulatedCashFlows

       parameters.size() = n
    */
    Real genericEarlyExerciseOptimization(
        std::vector<std::vector<NodeData> >& simulationData,
        const ParametricExercise& exercise,
        std::vector<std::vector<Real> >& parameters,
        const EndCriteria& endCriteria,
        OptimizationMethod& method);

}


#endif

]]></document_content>
  </document>
  <document index="14">
    <source>path.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl
 Copyright (C) 2003 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file path.hpp
    \brief single factor random walk
*/

#ifndef quantlib_montecarlo_path_hpp
#define quantlib_montecarlo_path_hpp

#include <ql/math/array.hpp>
#include <ql/timegrid.hpp>
#include <utility>

namespace QuantLib {

    //! single-factor random walk
    /*! \ingroup mcarlo

        \note the path includes the initial asset value as its first point.
    */
    class Path {
      public:
        Path(TimeGrid timeGrid, Array values = Array());
        //! \name inspectors
        //@{
        bool empty() const;
        Size length() const;
        //! asset value at the \f$ i \f$-th point
        Real operator[](Size i) const;
        Real at(Size i) const;
        Real& operator[](Size i);
        Real& at(Size i);
        Real value(Size i) const;
        Real& value(Size i);
        //! time at the \f$ i \f$-th point
        Time time(Size i) const;
        //! initial asset value
        Real front() const;
        Real& front();
        //! final asset value
        Real back() const;
        Real& back();
        //! time grid
        const TimeGrid& timeGrid() const;
        //@}
        //! \name iterators
        //@{
        typedef Array::const_iterator iterator;
        typedef Array::const_reverse_iterator reverse_iterator;
        iterator begin() const;
        iterator end() const;
        reverse_iterator rbegin() const;
        reverse_iterator rend() const;
        //@}
      private:
        TimeGrid timeGrid_;
        Array values_;
    };


    // inline definitions

    inline Path::Path(TimeGrid timeGrid, Array values)
    : timeGrid_(std::move(timeGrid)), values_(std::move(values)) {
        if (values_.empty())
            values_ = Array(timeGrid_.size());
        QL_REQUIRE(values_.size() == timeGrid_.size(),
                   "different number of times and asset values");
    }

    inline bool Path::empty() const {
        return timeGrid_.empty();
    }

    inline Size Path::length() const {
        return timeGrid_.size();
    }

    inline Real Path::operator[](Size i) const {
        return values_[i];
    }

    inline Real Path::at(Size i) const {
        return values_.at(i);
    }

    inline Real& Path::operator[](Size i) {
        return values_[i];
    }

    inline Real& Path::at(Size i) {
        return values_.at(i);
    }

    inline Real Path::value(Size i) const {
        return values_[i];
    }

    inline Real& Path::value(Size i) {
        return values_[i];
    }

    inline Real Path::front() const {
        return values_[0];
    }

    inline Real& Path::front() {
        return values_[0];
    }

    inline Real Path::back() const {
        return values_[values_.size()-1];
    }

    inline Real& Path::back() {
        return values_[values_.size()-1];
    }

    inline Time Path::time(Size i) const {
        return timeGrid_[i];
    }

    inline const TimeGrid& Path::timeGrid() const {
        return timeGrid_;
    }

    inline Path::iterator Path::begin() const {
        return values_.begin();
    }

    inline Path::iterator Path::end() const {
        return values_.end();
    }

    inline Path::reverse_iterator Path::rbegin() const {
        return values_.rbegin();
    }

    inline Path::reverse_iterator Path::rend() const {
        return values_.rend();
    }

}


#endif
]]></document_content>
  </document>
  <document index="15">
    <source>pathgenerator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file pathgenerator.hpp
    \brief Generates random paths using a sequence generator
*/

#ifndef quantlib_montecarlo_path_generator_hpp
#define quantlib_montecarlo_path_generator_hpp

#include <ql/methods/montecarlo/brownianbridge.hpp>
#include <ql/stochasticprocess.hpp>
#include <utility>

namespace QuantLib {
    class StochasticProcess;
    class StochasticProcess1D;
    //! Generates random paths using a sequence generator
    /*! Generates random paths with drift(S,t) and variance(S,t)
        using a gaussian sequence generator

        \ingroup mcarlo

        \test the generated paths are checked against cached results
    */
    template <class GSG>
    class PathGenerator {
      public:
        typedef Sample<Path> sample_type;
        // constructors
        PathGenerator(const ext::shared_ptr<StochasticProcess>&,
                      Time length,
                      Size timeSteps,
                      GSG generator,
                      bool brownianBridge);
        PathGenerator(const ext::shared_ptr<StochasticProcess>&,
                      TimeGrid timeGrid,
                      GSG generator,
                      bool brownianBridge);
        //! \name inspectors
        //@{
        const sample_type& next() const;
        const sample_type& antithetic() const;
        Size size() const { return dimension_; }
        const TimeGrid& timeGrid() const { return timeGrid_; }
        //@}
      private:
        const sample_type& next(bool antithetic) const;
        bool brownianBridge_;
        GSG generator_;
        Size dimension_;
        TimeGrid timeGrid_;
        ext::shared_ptr<StochasticProcess1D> process_;
        mutable sample_type next_;
        mutable std::vector<Real> temp_;
        BrownianBridge bb_;
    };


    // template definitions

    template <class GSG>
    PathGenerator<GSG>::PathGenerator(const ext::shared_ptr<StochasticProcess>& process,
                                      Time length,
                                      Size timeSteps,
                                      GSG generator,
                                      bool brownianBridge)
    : brownianBridge_(brownianBridge), generator_(std::move(generator)),
      dimension_(generator_.dimension()), timeGrid_(length, timeSteps),
      process_(ext::dynamic_pointer_cast<StochasticProcess1D>(process)),
      next_(Path(timeGrid_), 1.0), temp_(dimension_), bb_(timeGrid_) {
        QL_REQUIRE(dimension_==timeSteps,
                   "sequence generator dimensionality (" << dimension_
                   << ") != timeSteps (" << timeSteps << ")");
    }

    template <class GSG>
    PathGenerator<GSG>::PathGenerator(const ext::shared_ptr<StochasticProcess>& process,
                                      TimeGrid timeGrid,
                                      GSG generator,
                                      bool brownianBridge)
    : brownianBridge_(brownianBridge), generator_(std::move(generator)),
      dimension_(generator_.dimension()), timeGrid_(std::move(timeGrid)),
      process_(ext::dynamic_pointer_cast<StochasticProcess1D>(process)),
      next_(Path(timeGrid_), 1.0), temp_(dimension_), bb_(timeGrid_) {
        QL_REQUIRE(dimension_==timeGrid_.size()-1,
                   "sequence generator dimensionality (" << dimension_
                   << ") != timeSteps (" << timeGrid_.size()-1 << ")");
    }

    template <class GSG>
    const typename PathGenerator<GSG>::sample_type&
    PathGenerator<GSG>::next() const {
        return next(false);
    }

    template <class GSG>
    const typename PathGenerator<GSG>::sample_type&
    PathGenerator<GSG>::antithetic() const {
        return next(true);
    }

    template <class GSG>
    const typename PathGenerator<GSG>::sample_type&
    PathGenerator<GSG>::next(bool antithetic) const {

        typedef typename GSG::sample_type sequence_type;
        const sequence_type& sequence_ =
            antithetic ? generator_.lastSequence()
                       : generator_.nextSequence();

        if (brownianBridge_) {
            bb_.transform(sequence_.value.begin(),
                          sequence_.value.end(),
                          temp_.begin());
        } else {
            std::copy(sequence_.value.begin(),
                      sequence_.value.end(),
                      temp_.begin());
        }

        next_.weight = sequence_.weight;

        Path& path = next_.value;
        path.front() = process_->x0();

        for (Size i=1; i<path.length(); i++) {
            Time t = timeGrid_[i-1];
            Time dt = timeGrid_.dt(i-1);
            path[i] = process_->evolve(t, path[i-1], dt,
                                       antithetic ? -temp_[i-1] :
                                                     temp_[i-1]);
        }

        return next_;
    }

}


#endif
]]></document_content>
  </document>
  <document index="16">
    <source>pathpricer.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file pathpricer.hpp
    \brief base class for single-path pricers
*/

#ifndef quantlib_montecarlo_path_pricer_hpp
#define quantlib_montecarlo_path_pricer_hpp

#include <ql/option.hpp>
#include <ql/types.hpp>
#include <functional>

namespace QuantLib {

    //! base class for path pricers
    /*! Returns the value of an option on a given path.

        \ingroup mcarlo
    */
    template<class PathType, class ValueType=Real>
    class PathPricer {
      public:
        typedef PathType argument_type;
        typedef ValueType result_type;

        virtual ~PathPricer() = default;
        virtual ValueType operator()(const PathType& path) const=0;
    };

}


#endif
]]></document_content>
  </document>
  <document index="17">
    <source>sample.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file sample.hpp
    \brief weighted sample
*/

#ifndef quantlib_sample_h
#define quantlib_sample_h

#include <ql/types.hpp>
#include <utility>

namespace QuantLib {

    //! weighted sample
    /*! \ingroup mcarlo */
    template <class T>
    struct Sample {
      public:
        typedef T value_type;
        Sample(T value, Real weight) : value(std::move(value)), weight(weight) {}
        T value;
        Real weight;
    };

}


#endif
]]></document_content>
  </document>
</documents>