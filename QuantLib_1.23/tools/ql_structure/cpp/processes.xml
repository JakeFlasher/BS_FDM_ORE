<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>batesprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/processes/batesprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/distributions/poissondistribution.hpp>


namespace QuantLib {
    BatesProcess::BatesProcess(
                              const Handle<YieldTermStructure>& riskFreeRate,
                              const Handle<YieldTermStructure>& dividendYield,
                              const Handle<Quote>& s0,
                              Real v0, Real kappa,
                              Real theta, Real sigma, Real rho,
                              Real lambda, Real nu, Real delta, 
                              HestonProcess::Discretization d)
    : HestonProcess(riskFreeRate, dividendYield, 
                    s0, v0, kappa, theta, sigma, rho, d),
      lambda_(lambda), delta_(delta), nu_(nu),
      m_(std::exp(nu+0.5*delta*delta)-1) {
    }

    Disposable<Array> BatesProcess::drift(Time t, const Array& x) const {
        Array retVal = HestonProcess::drift(t, x);
        retVal[0] -= lambda_*m_;
        return retVal;
    }

    Disposable<Array> BatesProcess::evolve(Time t0, const Array& x0,
                                           Time dt, const Array& dw) const {

        const Size hestonFactors = HestonProcess::factors();

        Real p = cumNormalDist_(dw[hestonFactors]);
        if (p<0.0)
            p = 0.0;
        else if (p >= 1.0)
            p = 1.0-QL_EPSILON;
        
        const Real n = InverseCumulativePoisson(lambda_*dt)(p);        
        Array retVal = HestonProcess::evolve(t0, x0, dt, dw);
        retVal[0] *= 
            std::exp(-lambda_*m_*dt + nu_*n+delta_*std::sqrt(n)*dw[hestonFactors+1]);

        return retVal;
    }

    Size BatesProcess::factors() const {
        return HestonProcess::factors() + 2;
    }

    Real BatesProcess::lambda() const {
        return lambda_;
    }

    Real BatesProcess::nu() const {
        return nu_;
    }

    Real BatesProcess::delta() const {
        return delta_;
    }
}
]]></document_content>
  </document>
  <document index="2">
    <source>blackscholesprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2005, 2006, 2007 StatPro Italia srl
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/processes/blackscholesprocess.hpp>
#include <ql/termstructures/volatility/equityfx/localconstantvol.hpp>
#include <ql/termstructures/volatility/equityfx/localvolcurve.hpp>
#include <ql/termstructures/volatility/equityfx/localvolsurface.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <utility>


namespace QuantLib {

    GeneralizedBlackScholesProcess::GeneralizedBlackScholesProcess(
        Handle<Quote> x0,
        Handle<YieldTermStructure> dividendTS,
        Handle<YieldTermStructure> riskFreeTS,
        Handle<BlackVolTermStructure> blackVolTS,
        Handle<LocalVolTermStructure> localVolTS)
    : StochasticProcess1D(ext::make_shared<EulerDiscretization>()), x0_(std::move(x0)),
      riskFreeRate_(std::move(riskFreeTS)), dividendYield_(std::move(dividendTS)),
      blackVolatility_(std::move(blackVolTS)), externalLocalVolTS_(std::move(localVolTS)),
      forceDiscretization_(false), hasExternalLocalVol_(true), updated_(false),
      isStrikeIndependent_(false) {
        registerWith(x0_);
        registerWith(riskFreeRate_);
        registerWith(dividendYield_);
        registerWith(blackVolatility_);
        registerWith(externalLocalVolTS_);
    }

    GeneralizedBlackScholesProcess::GeneralizedBlackScholesProcess(
        Handle<Quote> x0,
        Handle<YieldTermStructure> dividendTS,
        Handle<YieldTermStructure> riskFreeTS,
        Handle<BlackVolTermStructure> blackVolTS,
        const ext::shared_ptr<discretization>& disc,
        bool forceDiscretization)
    : StochasticProcess1D(disc), x0_(std::move(x0)), riskFreeRate_(std::move(riskFreeTS)),
      dividendYield_(std::move(dividendTS)), blackVolatility_(std::move(blackVolTS)),
      forceDiscretization_(forceDiscretization), hasExternalLocalVol_(false), updated_(false),
      isStrikeIndependent_(false) {
        registerWith(x0_);
        registerWith(riskFreeRate_);
        registerWith(dividendYield_);
        registerWith(blackVolatility_);
    }

    Real GeneralizedBlackScholesProcess::x0() const {
        return x0_->value();
    }

    Real GeneralizedBlackScholesProcess::drift(Time t, Real x) const {
        Real sigma = diffusion(t,x);
        // we could be more anticipatory if we know the right dt
        // for which the drift will be used
        Time t1 = t + 0.0001;
        return riskFreeRate_->forwardRate(t,t1,Continuous,NoFrequency,true)
             - dividendYield_->forwardRate(t,t1,Continuous,NoFrequency,true)
             - 0.5 * sigma * sigma;
    }

    Real GeneralizedBlackScholesProcess::diffusion(Time t, Real x) const {
        return localVolatility()->localVol(t, x, true);
    }

    Real GeneralizedBlackScholesProcess::apply(Real x0, Real dx) const {
        return x0 * std::exp(dx);
    }

    Real GeneralizedBlackScholesProcess::expectation(Time t0,
                                                     Real x0,
                                                     Time dt) const {
        localVolatility(); // trigger update
        if(isStrikeIndependent_ && !forceDiscretization_) {
            // exact value for curves
            return x0 *
                std::exp(dt * (riskFreeRate_->forwardRate(t0, t0 + dt, Continuous,
                                                          NoFrequency, true) -
                             dividendYield_->forwardRate(
                                 t0, t0 + dt, Continuous, NoFrequency, true)));
        } else {
            QL_FAIL("not implemented");
        }
    }

    Real GeneralizedBlackScholesProcess::stdDeviation(Time t0, Real x0, Time dt) const {
        localVolatility(); // trigger update
        if(isStrikeIndependent_ && !forceDiscretization_) {
            // exact value for curves
            return std::sqrt(variance(t0,x0,dt));
        }
        else{
            return discretization_->diffusion(*this,t0,x0,dt);
        }
    }

    Real GeneralizedBlackScholesProcess::variance(Time t0, Real x0, Time dt) const {
        localVolatility(); // trigger update
        if(isStrikeIndependent_ && !forceDiscretization_) {
            // exact value for curves
            return blackVolatility_->blackVariance(t0 + dt, 0.01) -
                   blackVolatility_->blackVariance(t0, 0.01);
        }
        else{
            return discretization_->variance(*this,t0,x0,dt);
        }
    }

    Real GeneralizedBlackScholesProcess::evolve(Time t0, Real x0,
                                                Time dt, Real dw) const {
        localVolatility(); // trigger update
        if (isStrikeIndependent_ && !forceDiscretization_) {
            // exact value for curves
            Real var = variance(t0, x0, dt);
            Real drift = (riskFreeRate_->forwardRate(t0, t0 + dt, Continuous,
                                                     NoFrequency, true) -
                          dividendYield_->forwardRate(t0, t0 + dt, Continuous,
                                                      NoFrequency, true)) *
                             dt -
                         0.5 * var;
            return apply(x0, std::sqrt(var) * dw + drift);
        } else
            return apply(x0, discretization_->drift(*this, t0, x0, dt) +
                                 stdDeviation(t0, x0, dt) * dw);
    }

    Time GeneralizedBlackScholesProcess::time(const Date& d) const {
        return riskFreeRate_->dayCounter().yearFraction(
                                           riskFreeRate_->referenceDate(), d);
    }

    void GeneralizedBlackScholesProcess::update() {
        updated_ = false;
        StochasticProcess1D::update();
    }

    const Handle<Quote>&
    GeneralizedBlackScholesProcess::stateVariable() const {
        return x0_;
    }

    const Handle<YieldTermStructure>&
    GeneralizedBlackScholesProcess::dividendYield() const {
        return dividendYield_;
    }

    const Handle<YieldTermStructure>&
    GeneralizedBlackScholesProcess::riskFreeRate() const {
        return riskFreeRate_;
    }

    const Handle<BlackVolTermStructure>&
    GeneralizedBlackScholesProcess::blackVolatility() const {
        return blackVolatility_;
    }

    const Handle<LocalVolTermStructure>&
    GeneralizedBlackScholesProcess::localVolatility() const {
        if (hasExternalLocalVol_)
            return externalLocalVolTS_;

        if (!updated_) {
            isStrikeIndependent_=true;

            // constant Black vol?
            ext::shared_ptr<BlackConstantVol> constVol =
                ext::dynamic_pointer_cast<BlackConstantVol>(
                                                          *blackVolatility());
            if (constVol != nullptr) {
                // ok, the local vol is constant too.
                localVolatility_.linkTo(ext::make_shared<LocalConstantVol>(
                    constVol->referenceDate(),
                    constVol->blackVol(0.0, x0_->value()),
                    constVol->dayCounter()));
                updated_ = true;
                return localVolatility_;
            }

            // ok, so it's not constant. Maybe it's strike-independent?
            ext::shared_ptr<BlackVarianceCurve> volCurve =
                ext::dynamic_pointer_cast<BlackVarianceCurve>(
                                                          *blackVolatility());
            if (volCurve != nullptr) {
                // ok, we can use the optimized algorithm
                localVolatility_.linkTo(ext::make_shared<LocalVolCurve>(
                    Handle<BlackVarianceCurve>(volCurve)));
                updated_ = true;
                return localVolatility_;
            }

            // ok, so it's strike-dependent. Never mind.
            localVolatility_.linkTo(
                ext::make_shared<LocalVolSurface>(blackVolatility_, riskFreeRate_,
                                                    dividendYield_, x0_->value()));
            updated_ = true;
            isStrikeIndependent_ = false;
            return localVolatility_;

        } else {
            return localVolatility_;
        }
    }


    // specific models

    BlackScholesProcess::BlackScholesProcess(
                              const Handle<Quote>& x0,
                              const Handle<YieldTermStructure>& riskFreeTS,
                              const Handle<BlackVolTermStructure>& blackVolTS,
                              const ext::shared_ptr<discretization>& d,
                              bool forceDiscretization)
    : GeneralizedBlackScholesProcess(
             x0,
             // no dividend yield
             Handle<YieldTermStructure>(ext::shared_ptr<YieldTermStructure>(
                  new FlatForward(0, NullCalendar(), 0.0, Actual365Fixed()))),
             riskFreeTS,
             blackVolTS,
             d,forceDiscretization) {}


    BlackScholesMertonProcess::BlackScholesMertonProcess(
                              const Handle<Quote>& x0,
                              const Handle<YieldTermStructure>& dividendTS,
                              const Handle<YieldTermStructure>& riskFreeTS,
                              const Handle<BlackVolTermStructure>& blackVolTS,
                              const ext::shared_ptr<discretization>& d,
                              bool forceDiscretization)
    : GeneralizedBlackScholesProcess(x0,dividendTS,riskFreeTS,blackVolTS,d,
                                     forceDiscretization) {}


    BlackProcess::BlackProcess(const Handle<Quote>& x0,
                               const Handle<YieldTermStructure>& riskFreeTS,
                               const Handle<BlackVolTermStructure>& blackVolTS,
                               const ext::shared_ptr<discretization>& d,
                               bool forceDiscretization)
    : GeneralizedBlackScholesProcess(x0,riskFreeTS,riskFreeTS,blackVolTS,d,
                                     forceDiscretization) {}


    GarmanKohlagenProcess::GarmanKohlagenProcess(
                          const Handle<Quote>& x0,
                          const Handle<YieldTermStructure>& foreignRiskFreeTS,
                          const Handle<YieldTermStructure>& domesticRiskFreeTS,
                          const Handle<BlackVolTermStructure>& blackVolTS,
                          const ext::shared_ptr<discretization>& d,
                          bool forceDiscretization)
    : GeneralizedBlackScholesProcess(x0,foreignRiskFreeTS,domesticRiskFreeTS,
                                     blackVolTS,d,forceDiscretization) {}

}
]]></document_content>
  </document>
  <document index="3">
    <source>coxingersollrossprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Lew Wei Hao

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/processes/coxingersollrossprocess.hpp>

namespace QuantLib {

    CoxIngersollRossProcess::CoxIngersollRossProcess(Real speed,
                                                       Volatility vol,
                                                       Real x0,
                                                       Real level)
    : x0_(x0), speed_(speed), level_(level), volatility_(vol) {
        QL_REQUIRE(volatility_ >= 0.0, "negative volatility given");
    }

    Real CoxIngersollRossProcess::variance(Time, Real, Time dt) const {
        Real exponent1 = std::exp(-speed_ * dt);
        Real exponent2 = std::exp(-2 * speed_ * dt);
        Real fraction = (volatility_ * volatility_) / speed_;

        return x0_ * fraction * (exponent1 - exponent2) + level_ * fraction * (1 - exponent1) * (1 - exponent1);
    }

}

]]></document_content>
  </document>
  <document index="4">
    <source>endeulerdiscretization.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Frank HÃ¶vermann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/processes/endeulerdiscretization.hpp>

namespace QuantLib {

    Disposable<Array> EndEulerDiscretization::drift(
                                      const StochasticProcess& process,
                                      Time t0, const Array& x0,
                                      Time dt) const {
        return process.drift(t0+dt, x0)*dt;
    }

    Real EndEulerDiscretization::drift(const StochasticProcess1D& process,
                                       Time t0, Real x0, Time dt) const {
        return process.drift(t0+dt, x0)*dt;
    }

    Disposable<Matrix> EndEulerDiscretization::diffusion(
                                      const StochasticProcess& process,
                                      Time t0, const Array& x0,
                                      Time dt) const {
        return process.diffusion(t0+dt, x0) * std::sqrt(dt);
    }

    Real EndEulerDiscretization::diffusion(const StochasticProcess1D& process,
                                           Time t0, Real x0, Time dt) const {
        return process.diffusion(t0+dt, x0) * std::sqrt(dt);
    }

    Disposable<Matrix> EndEulerDiscretization::covariance(
                                      const StochasticProcess& process,
                                      Time t0, const Array& x0,
                                      Time dt) const {
        Matrix sigma = process.diffusion(t0+dt, x0);
        Matrix result = sigma*transpose(sigma)*dt;
        return result;
    }

    Real EndEulerDiscretization::variance(const StochasticProcess1D& process,
                                          Time t0, Real x0, Time dt) const {
        Real sigma = process.diffusion(t0+dt, x0);
        return sigma*sigma*dt;
    }

}

]]></document_content>
  </document>
  <document index="5">
    <source>eulerdiscretization.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/processes/eulerdiscretization.hpp>

namespace QuantLib {

    Disposable<Array> EulerDiscretization::drift(
                                      const StochasticProcess& process,
                                      Time t0, const Array& x0,
                                      Time dt) const {
        return process.drift(t0, x0)*dt;
    }

    Real EulerDiscretization::drift(const StochasticProcess1D& process,
                                    Time t0, Real x0, Time dt) const {
        return process.drift(t0, x0)*dt;
    }

    Disposable<Matrix> EulerDiscretization::diffusion(
                                      const StochasticProcess& process,
                                      Time t0, const Array& x0,
                                      Time dt) const {
        return process.diffusion(t0, x0) * std::sqrt(dt);
    }

    Real EulerDiscretization::diffusion(const StochasticProcess1D& process,
                                        Time t0, Real x0, Time dt) const {
        return process.diffusion(t0, x0) * std::sqrt(dt);
    }

    Disposable<Matrix> EulerDiscretization::covariance(
                                      const StochasticProcess& process,
                                      Time t0, const Array& x0,
                                      Time dt) const {
        Matrix sigma = process.diffusion(t0, x0);
        Matrix result = sigma*transpose(sigma)*dt;
        return result;
    }

    Real EulerDiscretization::variance(const StochasticProcess1D& process,
                                       Time t0, Real x0, Time dt) const {
        Real sigma = process.diffusion(t0, x0);
        return sigma*sigma*dt;
    }

}

]]></document_content>
  </document>
  <document index="6">
    <source>forwardmeasureprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Banca Profilo S.p.A.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/processes/forwardmeasureprocess.hpp>

namespace QuantLib {

    // base class

    ForwardMeasureProcess::ForwardMeasureProcess(
                                const ext::shared_ptr<discretization>& disc)
    : StochasticProcess(disc) {}

    void ForwardMeasureProcess::setForwardMeasureTime(Time T) {
        T_ = T;
        notifyObservers();
    }

    Time ForwardMeasureProcess::getForwardMeasureTime() const {
        return T_;
    }

    // 1-D specialization

    ForwardMeasureProcess1D::ForwardMeasureProcess1D(
                                const ext::shared_ptr<discretization>& disc)
    : StochasticProcess1D(disc) {}

    void ForwardMeasureProcess1D::setForwardMeasureTime(Time T) {
        T_ = T;
        notifyObservers();
    }

    Time ForwardMeasureProcess1D::getForwardMeasureTime() const {
        return T_;
    }
}

]]></document_content>
  </document>
  <document index="7">
    <source>g2process.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Banca Profilo S.p.A.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/processes/g2process.hpp>
#include <ql/processes/eulerdiscretization.hpp>

namespace QuantLib {

    G2Process::G2Process(Real a, Real sigma, Real b, Real eta, Real rho)
    : x0_(0.0), y0_(0.0), a_(a), sigma_(sigma), b_(b), eta_(eta), rho_(rho),
      xProcess_(new QuantLib::OrnsteinUhlenbeckProcess(a, sigma, 0.0)),
      yProcess_(new QuantLib::OrnsteinUhlenbeckProcess(b, eta, 0.0)) {}

    Size G2Process::size() const {
        return 2;
    }

    Disposable<Array> G2Process::initialValues() const {
        Array tmp(2);
        tmp[0] = x0_;
        tmp[1] = y0_;
        return tmp;
    }

    Disposable<Array> G2Process::drift(Time t, const Array& x) const {
        Array tmp(2);
        tmp[0] = xProcess_->drift(t, x[0]);
        tmp[1] = yProcess_->drift(t, x[1]);
        return tmp;
    }

    Disposable<Matrix> G2Process::diffusion(Time, const Array&) const {
        /* the correlation matrix is
           |  1   rho |
           | rho   1  |
           whose square root (which is used here) is
           |  1          0       |
           | rho   sqrt(1-rho^2) |
        */
        Matrix tmp(2,2);
        Real sigma1 = sigma_;
        Real sigma2 = eta_;
        tmp[0][0] = sigma1;       tmp[0][1] = 0.0;
        tmp[1][0] = rho_*sigma1;  tmp[1][1] = std::sqrt(1.0-rho_*rho_)*sigma2;
        return tmp;
    }

    Disposable<Array> G2Process::expectation(Time t0, const Array& x0,
                                             Time dt) const {
        Array tmp(2);
        tmp[0] = xProcess_->expectation(t0, x0[0], dt);
        tmp[1] = yProcess_->expectation(t0, x0[1], dt);
        return tmp;
    }

    Disposable<Matrix> G2Process::stdDeviation(Time t0, const Array& x0,
                                               Time dt) const {
        /* the correlation matrix is
           |  1   rho |
           | rho   1  |
           whose square root (which is used here) is
           |  1          0       |
           | rho   sqrt(1-rho^2) |
        */
        Matrix tmp(2,2);
        Real sigma1 = xProcess_->stdDeviation(t0, x0[0], dt);
        Real sigma2 = yProcess_->stdDeviation(t0, x0[1], dt);
        Real expa = std::exp(-a_*dt), expb = std::exp(-b_*dt);
        Real H = (rho_*sigma_*eta_)/(a_+b_)*(1-expa*expb);
        Real den =
            (0.5*sigma_*eta_)*std::sqrt((1-expa*expa)*(1-expb*expb)/(a_*b_));
        Real newRho = H/den;
        tmp[0][0] = sigma1;
        tmp[0][1] = 0.0;
        tmp[1][0] = newRho*sigma2;
        tmp[1][1] = std::sqrt(1.0-newRho*newRho)*sigma2;
        return tmp;
    }

    Disposable<Matrix> G2Process::covariance(Time t0, const Array& x0,
                                             Time dt) const {
        Matrix sigma = stdDeviation(t0, x0, dt);
        Matrix result = sigma*transpose(sigma);
        return result;
    }

    Real G2Process::x0() const {
        return x0_;
    }

    Real G2Process::y0() const {
        return y0_;
    }

    Real G2Process::a() const {
        return a_;
    }

    Real G2Process::sigma() const {
        return sigma_;
    }

    Real G2Process::b() const {
        return b_;
    }

    Real G2Process::eta() const {
        return eta_;
    }

    Real G2Process::rho() const {
        return rho_;
    }


    G2ForwardProcess::G2ForwardProcess(Real a, Real sigma, Real b,
                                       Real eta, Real rho)
    : x0_(0.0), y0_(0.0), a_(a), sigma_(sigma), b_(b), eta_(eta), rho_(rho),
      xProcess_(new QuantLib::OrnsteinUhlenbeckProcess(a, sigma, 0.0)),
      yProcess_(new QuantLib::OrnsteinUhlenbeckProcess(b, eta, 0.0)) {}

    Size G2ForwardProcess::size() const {
        return 2;
    }

    Disposable<Array> G2ForwardProcess::initialValues() const {
        Array tmp(2);
        tmp[0] = x0_;
        tmp[1] = y0_;
        return tmp;
    }

    Disposable<Array> G2ForwardProcess::drift(Time t, const Array& x) const {
        Array tmp(2);
        tmp[0] = xProcess_->drift(t, x[0]) + xForwardDrift(t, T_);
        tmp[1] = yProcess_->drift(t, x[1]) + yForwardDrift(t, T_);
        return tmp;
    }

    Disposable<Matrix> G2ForwardProcess::diffusion(Time, const Array&) const {
        Matrix tmp(2,2);
        Real sigma1 = sigma_;
        Real sigma2 = eta_;
        tmp[0][0] = sigma1;       tmp[0][1] = 0.0;
        tmp[1][0] = rho_*sigma1;  tmp[1][1] = std::sqrt(1.0-rho_*rho_)*sigma2;
        return tmp;
    }

    Disposable<Array> G2ForwardProcess::expectation(Time t0, const Array& x0,
                                                    Time dt) const {
        Array tmp(2);
        tmp[0] = xProcess_->expectation(t0, x0[0], dt) - Mx_T(t0, t0+dt, T_);
        tmp[1] = yProcess_->expectation(t0, x0[1], dt) - My_T(t0, t0+dt, T_);
        return tmp;
    }

    Disposable<Matrix> G2ForwardProcess::stdDeviation(Time t0, const Array& x0,
                                                      Time dt) const {
        Matrix tmp(2,2);
        Real sigma1 = xProcess_->stdDeviation(t0, x0[0], dt);
        Real sigma2 = yProcess_->stdDeviation(t0, x0[1], dt);
        Real expa = std::exp(-a_*dt), expb = std::exp(-b_*dt);
        Real H = (rho_*sigma_*eta_)/(a_+b_)*(1-expa*expb);
        Real den =
            (0.5*sigma_*eta_)*std::sqrt((1-expa*expa)*(1-expb*expb)/(a_*b_));
        Real newRho = H/den;
        tmp[0][0] = sigma1;
        tmp[0][1] = 0.0;
        tmp[1][0] = newRho*sigma2;
        tmp[1][1] = std::sqrt(1.0-newRho*newRho)*sigma2;
        return tmp;
    }

    Disposable<Matrix> G2ForwardProcess::covariance(Time t0, const Array& x0,
                                                    Time dt) const {
        Matrix sigma = stdDeviation(t0, x0, dt);
        Matrix result = sigma*transpose(sigma);
        return result;
    }

    Real G2ForwardProcess::xForwardDrift(Time t, Time T) const {
        Real expatT = std::exp(-a_*(T-t));
        Real expbtT = std::exp(-b_*(T-t));

        return -(sigma_*sigma_/a_) * (1-expatT)
              - (rho_*sigma_*eta_/b_) * (1-expbtT);
    }

    Real G2ForwardProcess::yForwardDrift(Time t, Time T) const {
        Real expatT = std::exp(-a_*(T-t));
        Real expbtT = std::exp(-b_*(T-t));

        return -(eta_*eta_/b_) * (1-expbtT)
              - (rho_*sigma_*eta_/a_) * (1-expatT);
    }

    Real G2ForwardProcess::Mx_T(Real s, Real t, Real T) const {
        Real M;
        M = ( (sigma_*sigma_)/(a_*a_) + (rho_*sigma_*eta_)/(a_*b_) )
          * (1-std::exp(-a_*(t-s)));
        M += -(sigma_*sigma_)/(2*a_*a_) *
              (std::exp(-a_*(T-t))-std::exp(-a_*(T+t-2*s)));
        M += -(rho_*sigma_*eta_)/(b_*(a_+b_))
            * (std::exp(-b_*(T-t)) -std::exp(-b_*T-a_*t+(a_+b_)*s));
        return M;
    }

    Real G2ForwardProcess::My_T(Real s, Real t, Real T) const {
        Real M;
        M = ( (eta_*eta_)/(b_*b_) + (rho_*sigma_*eta_)/(a_*b_) )
          * (1-std::exp(-b_*(t-s)));
        M += -(eta_*eta_)/(2*b_*b_) *
              (std::exp(-b_*(T-t))-std::exp(-b_*(T+t-2*s)));
        M += -(rho_*sigma_*eta_)/(a_*(a_+b_))
            * (std::exp(-a_*(T-t))-std::exp(-a_*T-b_*t+(a_+b_)*s));
        return M;
    }

}

]]></document_content>
  </document>
  <document index="8">
    <source>geometricbrownianprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/processes/geometricbrownianprocess.hpp>
#include <ql/processes/eulerdiscretization.hpp>

namespace QuantLib {

    GeometricBrownianMotionProcess::GeometricBrownianMotionProcess(
                                                          double initialValue,
                                                          double mue,
                                                          double sigma)
    : StochasticProcess1D(ext::shared_ptr<discretization>(
                                                    new EulerDiscretization)),
      initialValue_(initialValue), mue_(mue), sigma_(sigma) {}

    Real GeometricBrownianMotionProcess::x0() const {
        return initialValue_;
    }

    Real GeometricBrownianMotionProcess::drift(Time, Real x) const {
        return mue_ * x;
    }

    Real GeometricBrownianMotionProcess::diffusion(Time, Real x) const {
        return sigma_ * x;
    }

}
]]></document_content>
  </document>
  <document index="9">
    <source>gjrgarchprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Yee Man Chan

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/distributions/chisquaredistribution.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/processes/eulerdiscretization.hpp>
#include <ql/processes/gjrgarchprocess.hpp>
#include <ql/quotes/simplequote.hpp>
#include <utility>

namespace QuantLib {

    GJRGARCHProcess::GJRGARCHProcess(Handle<YieldTermStructure> riskFreeRate,
                                     Handle<YieldTermStructure> dividendYield,
                                     Handle<Quote> s0,
                                     Real v0,
                                     Real omega,
                                     Real alpha,
                                     Real beta,
                                     Real gamma,
                                     Real lambda,
                                     Real daysPerYear,
                                     Discretization d)
    : StochasticProcess(ext::shared_ptr<discretization>(new EulerDiscretization)),
      riskFreeRate_(std::move(riskFreeRate)), dividendYield_(std::move(dividendYield)),
      s0_(std::move(s0)), v0_(v0), omega_(omega), alpha_(alpha), beta_(beta), gamma_(gamma),
      lambda_(lambda), daysPerYear_(daysPerYear), discretization_(d) {
        registerWith(riskFreeRate_);
        registerWith(dividendYield_);
        registerWith(s0_);
    }

    Size GJRGARCHProcess::size() const {
        return 2;
    }

    Disposable<Array> GJRGARCHProcess::initialValues() const {
        Array tmp(2);
        tmp[0] = s0_->value();
        tmp[1] = daysPerYear_*v0_;
        return tmp;
    }

    Disposable<Array> GJRGARCHProcess::drift(Time t, const Array& x) const {
        Array tmp(2);
        const Real N = CumulativeNormalDistribution()(lambda_);
        const Real n = std::exp(-lambda_*lambda_/2.0)/std::sqrt(2*M_PI);
        const Real q2 = 1.0 + lambda_*lambda_;
        const Real q3 = lambda_*n + N + lambda_*lambda_*N;
        const Real vol = (x[1] > 0.0) ? std::sqrt(x[1])
                         : (discretization_ == Reflection) ? - std::sqrt(-x[1])
                         : 0.0;

        tmp[0] = riskFreeRate_->forwardRate(t, t, Continuous)
               - dividendYield_->forwardRate(t, t, Continuous)
               - 0.5 * vol * vol;

        tmp[1] = daysPerYear_*daysPerYear_*omega_ + daysPerYear_*(beta_ 
                                             + alpha_*q2 + gamma_*q3 - 1.0) *
           ((discretization_==PartialTruncation) ? x[1] : vol*vol);
        return tmp;
    }

    Disposable<Matrix> GJRGARCHProcess::diffusion(Time, const Array& x) const {
        /* the correlation matrix is
           |  1   rho |
           | rho   1  |
           whose square root (which is used here) is
           |  1          0       |
           | rho   std::sqrt(1-rho^2) |
        */
        Matrix tmp(2,2);
        const Real N = CumulativeNormalDistribution()(lambda_);
        const Real n = std::exp(-lambda_*lambda_/2.0)/std::sqrt(2*M_PI);
        const Real sigma2 = 2.0 + 4.0*lambda_*lambda_;
        const Real q3 = lambda_*n + N + lambda_*lambda_*N;
        const Real Eml_e4 = lambda_*lambda_*lambda_*n + 5.0*lambda_*n 
            + 3.0*N + lambda_*lambda_*lambda_*lambda_*N 
            + 6.0*lambda_*lambda_*N;
        const Real sigma3 = Eml_e4 - q3*q3;
        const Real sigma12 = -2.0*lambda_;
        const Real sigma13 = -2.0*n - 2*lambda_*N;
        const Real sigma23 = 2.0*N + sigma12*sigma13;
        const Real vol = (x[1] > 0.0) ? std::sqrt(x[1])
                         : (discretization_ == Reflection) ? - std::sqrt(-x[1])
                         : 1e-8; // set vol to (almost) zero but still
                                 // expose some correlation information
        const Real rho1 = std::sqrt(daysPerYear_)*(alpha_*sigma12 
                                            + gamma_*sigma13) * vol * vol;
        const Real rho2 = vol*vol*std::sqrt(daysPerYear_)
            *std::sqrt(alpha_*alpha_*(sigma2 - sigma12*sigma12) 
                       + gamma_*gamma_*(sigma3 - sigma13*sigma13) 
                       + 2.0*alpha_*gamma_*(sigma23 - sigma12*sigma13)); 

            // tmp[0][0], tmp[0][1] are the coefficients of dW_1 and dW_2 
            // in asset return stochastic process
        tmp[0][0] = vol;  tmp[0][1] = 0.0;
        tmp[1][0] = rho1; tmp[1][1] = rho2;
        return tmp;
    }

    Disposable<Array> GJRGARCHProcess::apply(const Array& x0,
                                           const Array& dx) const {
        Array tmp(2);
        tmp[0] = x0[0] * std::exp(dx[0]);
        tmp[1] = x0[1] + dx[1];
        return tmp;
    }

    Disposable<Array> GJRGARCHProcess::evolve(Time t0, const Array& x0,
                                            Time dt, const Array& dw) const {
        Array retVal(2);
        Real vol, mu, nu;

        const Real sdt = std::sqrt(dt);
        const Real N = CumulativeNormalDistribution()(lambda_);
        const Real n = std::exp(-lambda_*lambda_/2.0)/std::sqrt(2*M_PI);
        const Real sigma2 = 2.0 + 4.0*lambda_*lambda_;
        const Real q2 = 1.0 + lambda_*lambda_;
        const Real q3 = lambda_*n + N + lambda_*lambda_*N;
        const Real Eml_e4 = lambda_*lambda_*lambda_*n + 5.0*lambda_*n 
            + 3.0*N + lambda_*lambda_*lambda_*lambda_*N 
            + 6.0*lambda_*lambda_*N;
        const Real sigma3 = Eml_e4 - q3*q3;
        const Real sigma12 = -2.0*lambda_;
        const Real sigma13 = -2.0*n - 2*lambda_*N;
        const Real sigma23 = 2.0*N + sigma12*sigma13;
        const Real rho1 = std::sqrt(daysPerYear_)*(alpha_*sigma12 + gamma_*sigma13);
        const Real rho2 = std::sqrt(daysPerYear_)
            *std::sqrt(alpha_*alpha_*(sigma2 - sigma12*sigma12) 
                       + gamma_*gamma_*(sigma3 - sigma13*sigma13) 
                       + 2.0*alpha_*gamma_*(sigma23 - sigma12*sigma13));

        switch (discretization_) {
          // For the definition of PartialTruncation, FullTruncation
          // and Reflection  see Lord, R., R. Koekkoek and D. van Dijk (2006),
          // "A Comparison of biased simulation schemes for
          //  stochastic volatility models",
          // Working Paper, Tinbergen Institute
          case PartialTruncation:
            vol = (x0[1] > 0.0) ? std::sqrt(x0[1]) : 0.0;
            mu =    riskFreeRate_->forwardRate(t0, t0+dt, Continuous)
                  - dividendYield_->forwardRate(t0, t0+dt, Continuous)
                    - 0.5 * vol * vol;
            nu = daysPerYear_*daysPerYear_*omega_ 
                + daysPerYear_*(beta_ + alpha_*q2 + gamma_*q3 - 1.0) * x0[1];

            retVal[0] = x0[0] * std::exp(mu*dt+vol*dw[0]*sdt);
            retVal[1] = x0[1] + nu*dt + sdt*vol*vol*(rho1*dw[0] + rho2*dw[1]);
            break;
          case FullTruncation:
            vol = (x0[1] > 0.0) ? std::sqrt(x0[1]) : 0.0;
            mu =    riskFreeRate_->forwardRate(t0, t0+dt, Continuous)
                  - dividendYield_->forwardRate(t0, t0+dt, Continuous)
                    - 0.5 * vol * vol;
            nu = daysPerYear_*daysPerYear_*omega_ 
                + daysPerYear_*(beta_ + alpha_*q2 + gamma_*q3 - 1.0) * vol *vol;

            retVal[0] = x0[0] * std::exp(mu*dt+vol*dw[0]*sdt);
            retVal[1] = x0[1] + nu*dt + sdt*vol*vol*(rho1*dw[0] + rho2*dw[1]);
            break;
          case Reflection:
            vol = std::sqrt(std::fabs(x0[1]));
            mu =    riskFreeRate_->forwardRate(t0, t0+dt, Continuous)
                  - dividendYield_->forwardRate(t0, t0+dt, Continuous)
                    - 0.5 * vol*vol;
            nu = daysPerYear_*daysPerYear_*omega_ 
                + daysPerYear_*(beta_ + alpha_*q2 + gamma_*q3 - 1.0) * vol * vol;

            retVal[0] = x0[0]*std::exp(mu*dt+vol*dw[0]*sdt);
            retVal[1] = vol*vol
                        +nu*dt + sdt*vol*vol*(rho1*dw[0] + rho2*dw[1]);
            break;
          default:
            QL_FAIL("unknown discretization schema");
        }

        return retVal;
    }

    const Handle<Quote>& GJRGARCHProcess::s0() const {
        return s0_;
    }

    const Handle<YieldTermStructure>& GJRGARCHProcess::dividendYield() const {
        return dividendYield_;
    }

    const Handle<YieldTermStructure>& GJRGARCHProcess::riskFreeRate() const {
        return riskFreeRate_;
    }

    Time GJRGARCHProcess::time(const Date& d) const {
        return riskFreeRate_->dayCounter().yearFraction(
                                           riskFreeRate_->referenceDate(), d);
    }

}
]]></document_content>
  </document>
  <document index="10">
    <source>gsrprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/processes/gsrprocess.hpp>
#include <cmath>
#include <utility>

namespace QuantLib {

    GsrProcess::GsrProcess(const Array& times,
                           const Array& vols,
                           const Array& reversions,
                           const Real T,
                           const Date& referenceDate,
                           DayCounter dc)
    : ForwardMeasureProcess1D(T), core_(times, vols, reversions, T), referenceDate_(referenceDate),
      dc_(std::move(dc)) {
        flushCache();
    }

    void GsrProcess::checkT(const Time t) const {
        QL_REQUIRE(t <= getForwardMeasureTime() && t >= 0.0,
                   "t (" << t
                         << ") must not be greater than forward measure time ("
                         << getForwardMeasureTime() << ") and non-negative");
    }

    Real GsrProcess::time(const Date &d) const {
        QL_REQUIRE(
            referenceDate_ != Null<Date>() && dc_ != DayCounter(),
            "time can not be computed without reference date and day counter");
        return dc_.yearFraction(referenceDate_, d);
    }

    Real GsrProcess::x0() const { return 0.0; }

    Real GsrProcess::drift(Time t, Real x) const {
        return core_.y(t) -
               core_.G(t, getForwardMeasureTime()) * sigma(t) * sigma(t) -
               reversion(t) * x;
    }

    Real GsrProcess::diffusion(Time t, Real) const {
        checkT(t);
        return sigma(t);
    }

    Real GsrProcess::expectation(Time w, Real xw, Time dt) const {
        checkT(w + dt);
        return core_.expectation_x0dep_part(w, xw, dt) +
               core_.expectation_rn_part(w, dt) +
               core_.expectation_tf_part(w, dt);
    }



    Real GsrProcess::stdDeviation(Time t0, Real x0, Time dt) const {
        return std::sqrt(variance(t0, x0, dt));
    }

    Real GsrProcess::variance(Time w, Real, Time dt) const {
        checkT(w + dt);
        return core_.variance(w,dt);
    }

    Real GsrProcess::sigma(Time t) const { return core_.sigma(t); }

    Real GsrProcess::reversion(Time t) const { return core_.reversion(t); }

    Real GsrProcess::y(Time t) const {
        checkT(t);
        return core_.y(t);
    }

    Real GsrProcess::G(Time t, Time w, Real) const {
        QL_REQUIRE(w >= t, "G(t,w) should be called with w ("
                               << w << ") not lesser than t (" << t << ")");
        QL_REQUIRE(t >= 0.0 && w <= getForwardMeasureTime(),
                   "G(t,w) should be called with (t,w)=("
                       << t << "," << w << ") in Range [0,"
                       << getForwardMeasureTime() << "].");

        return core_.G(t,w);
    }


}
]]></document_content>
  </document>
  <document index="11">
    <source>gsrprocesscore.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/processes/gsrprocesscore.hpp>
#include <cmath>

using std::exp;
using std::pow;

namespace QuantLib {

namespace detail {

GsrProcessCore::GsrProcessCore(const Array &times, const Array &vols,
                               const Array &reversions, const Real T)
    : times_(times), vols_(vols), reversions_(reversions),
      T_(T), revZero_(reversions.size(), false) {

    QL_REQUIRE(times.size() == vols.size() - 1,
               "number of volatilities ("
                   << vols.size() << ") compared to number of times ("
                   << times_.size() << " must be bigger by one");
    QL_REQUIRE(times.size() == reversions.size() - 1 || reversions.size() == 1,
               "number of reversions ("
                   << vols.size() << ") compared to number of times ("
                   << times_.size() << " must be bigger by one, or exactly "
                                       "1 reversion must be given");
    for (int i = 0; i < ((int)times.size()) - 1; i++)
        QL_REQUIRE(times[i] < times[i + 1], "times must be increasing ("
                                                << times[i] << "@" << i << " , "
                                                << times[i + 1] << "@" << i + 1
                                                << ")");
    flushCache();
}

void GsrProcessCore::flushCache() const {
    for (int i = 0; i < (int)reversions_.size(); i++)
        // small reversions cause numerical problems, so we keep them
        // away from zero
        if (std::fabs(reversions_[i]) < 1E-4)
            revZero_[i] = true;
        else
            revZero_[i] = false;
    cache1_.clear();
    cache2a_.clear();
    cache2b_.clear();
    cache3_.clear();
    cache4_.clear();
    cache5_.clear();
}

Real GsrProcessCore::expectation_x0dep_part(const Time w, const Real xw,
                                            const Time dt) const {
    Real t = w + dt;
    std::pair<Real, Real> key;
    key = std::make_pair(w, t);
    std::map<std::pair<Real, Real>, Real>::const_iterator k = cache1_.find(key);
    if (k != cache1_.end())
        return xw * (k->second);
    // A(w,t)x(w)
    Real res2 = 1.0;
    for (int i = lowerIndex(w); i <= upperIndex(t) - 1; i++) {
        res2 *= exp(-rev(i) * (cappedTime(i + 1, t) - flooredTime(i, w)));
    }
    cache1_.insert(std::make_pair(key, res2));
    return res2 * xw;
}

Real GsrProcessCore::expectation_rn_part(const Time w,
                                         const Time dt) const {

    Real t = w + dt;

    std::pair<Real, Real> key;
    key = std::make_pair(w, t);
    std::map<std::pair<Real, Real>, Real>::const_iterator k =
        cache2a_.find(key);
    if (k != cache2a_.end())
        return k->second;

    Real res = 0.0;

    // \int A(s,t)y(s)
    for (int k = lowerIndex(w); k <= upperIndex(t) - 1; k++) {
        // l<k
        for (int l = 0; l <= k - 1; l++) {
            Real res2 = 1.0;
            // alpha_l
            res2 *= revZero(l) ? vol(l) * vol(l) * (time2(l + 1) - time2(l))
                               : vol(l) * vol(l) / (2.0 * rev(l)) *
                                     (1.0 - exp(-2.0 * rev(l) *
                                                (time2(l + 1) - time2(l))));
            // zeta_i (i>k)
            for (int i = k + 1; i <= upperIndex(t) - 1; i++)
                res2 *= exp(-rev(i) * (cappedTime(i + 1, t) - time2(i)));
            // beta_j (j<k)
            for (int j = l + 1; j <= k - 1; j++)
                res2 *= exp(-2.0 * rev(j) * (time2(j + 1) - time2(j)));
            // zeta_k beta_k
            res2 *=
                revZero(k)
                    ? 2.0 * time2(k) - flooredTime(k, w) -
                          cappedTime(k + 1, t) -
                          2.0 * (time2(k) - cappedTime(k + 1, t))
                    : (exp(rev(k) * (2.0 * time2(k) - flooredTime(k, w) -
                                     cappedTime(k + 1, t))) -
                       exp(2.0 * rev(k) * (time2(k) - cappedTime(k + 1, t)))) /
                          rev(k);
            // add to sum
            res += res2;
        }
        // l=k
        Real res2 = 1.0;
        // alpha_k zeta_k
        res2 *=
            revZero(k)
                ? vol(k) * vol(k) / 4.0 *
                      (4.0 * pow(cappedTime(k + 1, t) - time2(k), 2.0) -
                       (pow(flooredTime(k, w) - 2.0 * time2(k) +
                                cappedTime(k + 1, t),
                            2.0) +
                        pow(cappedTime(k + 1, t) - flooredTime(k, w), 2.0)))
                : vol(k) * vol(k) / (2.0 * rev(k) * rev(k)) *
                      (exp(-2.0 * rev(k) * (cappedTime(k + 1, t) - time2(k))) +
                       1.0 -
                       (exp(-rev(k) * (flooredTime(k, w) - 2.0 * time2(k) +
                                       cappedTime(k + 1, t))) +
                        exp(-rev(k) *
                            (cappedTime(k + 1, t) - flooredTime(k, w)))));
        // zeta_i (i>k)
        for (int i = k + 1; i <= upperIndex(t) - 1; i++)
            res2 *= exp(-rev(i) * (cappedTime(i + 1, t) - time2(i)));
        // no beta_j in this case ...
        res += res2;
    }

    cache2a_.insert(std::make_pair(key, res));

    return res;
} // expectation_rn_part

Real GsrProcessCore::expectation_tf_part(const Time w,
                                         const Time dt) const {

    Real t = w + dt;

    std::pair<Real, Real> key;
    key = std::make_pair(w, t);
    std::map<std::pair<Real, Real>, Real>::const_iterator k =
        cache2b_.find(key);
    if (k != cache2b_.end())
        return k->second;

    Real res = 0.0;
    // int -A(s,t) \sigma^2 G(s,T)
    for (int k = lowerIndex(w); k <= upperIndex(t) - 1; k++) {
        Real res2 = 0.0;
        // l>k
        for (int l = k + 1; l <= upperIndex(T_) - 1; l++) {
            Real res3 = 1.0;
            // eta_l
            res3 *= revZero(l)
                        ? cappedTime(l + 1, T_) - time2(l)
                        : (1.0 -
                           exp(-rev(l) * (cappedTime(l + 1, T_) - time2(l)))) /
                              rev(l);
            // zeta_i (i>k)
            for (int i = k + 1; i <= upperIndex(t) - 1; i++)
                res3 *= exp(-rev(i) * (cappedTime(i + 1, t) - time2(i)));
            // gamma_j (j>k)
            for (int j = k + 1; j <= l - 1; j++)
                res3 *= exp(-rev(j) * (time2(j + 1) - time2(j)));
            // zeta_k gamma_k
            res3 *=
                revZero(k)
                    ? (cappedTime(k + 1, t) - time2(k + 1) -
                       (2.0 * flooredTime(k, w) - cappedTime(k + 1, t) -
                        time2(k + 1))) /
                          2.0
                    : (exp(rev(k) * (cappedTime(k + 1, t) - time2(k + 1))) -
                       exp(rev(k) * (2.0 * flooredTime(k, w) -
                                     cappedTime(k + 1, t) - time2(k + 1)))) /
                          (2.0 * rev(k));
            // add to sum
            res2 += res3;
        }
        // l=k
        Real res3 = 1.0;
        // eta_k zeta_k
        res3 *=
            revZero(k)
                ? (-pow(cappedTime(k + 1, t) - cappedTime(k + 1, T_), 2.0) -
                   2.0 * pow(cappedTime(k + 1, t) - flooredTime(k, w), 2.0) +
                   pow(2.0 * flooredTime(k, w) - cappedTime(k + 1, T_) -
                           cappedTime(k + 1, t),
                       2.0)) /
                      4.0
                : (2.0 - exp(rev(k) *
                             (cappedTime(k + 1, t) - cappedTime(k + 1, T_))) -
                   (2.0 * exp(-rev(k) *
                              (cappedTime(k + 1, t) - flooredTime(k, w))) -
                    exp(rev(k) *
                        (2.0 * flooredTime(k, w) - cappedTime(k + 1, T_) -
                         cappedTime(k + 1, t))))) /
                      (2.0 * rev(k) * rev(k));
        // zeta_i (i>k)
        for (int i = k + 1; i <= upperIndex(t) - 1; i++)
            res3 *= exp(-rev(i) * (cappedTime(i + 1, t) - time2(i)));
        // no gamma_j in this case ...
        res2 += res3;
        // add to main accumulator
        res += -vol(k) * vol(k) * res2;
    }

    cache2b_.insert(std::make_pair(key, res));

    return res;
} // expectation_tf_part

Real GsrProcessCore::variance(const Time w, const Time dt) const {

    Real t = w + dt;

    std::pair<Real, Real> key;
    key = std::make_pair(w, t);
    std::map<std::pair<Real, Real>, Real>::const_iterator k = cache3_.find(key);
    if (k != cache3_.end())
        return k->second;

    Real res = 0.0;
    for (int k = lowerIndex(w); k <= upperIndex(t) - 1; k++) {
        Real res2 = vol(k) * vol(k);
        // zeta_k^2
        res2 *= revZero(k)
                    ? -(flooredTime(k, w) - cappedTime(k + 1, t))
                    : (1.0 - exp(2.0 * rev(k) *
                                 (flooredTime(k, w) - cappedTime(k + 1, t)))) /
                          (2.0 * rev(k));
        // zeta_i (i>k)
        for (int i = k + 1; i <= upperIndex(t) - 1; i++) {
            res2 *= exp(-2.0 * rev(i) * (cappedTime(i + 1, t) - time2(i)));
        }
        res += res2;
    }

    cache3_.insert(std::make_pair(key, res));
    return res;
}

Real GsrProcessCore::y(const Time t) const {
    Real key;
    key = t;
    std::map<Real, Real>::const_iterator k = cache4_.find(key);
    if (k != cache4_.end())
        return k->second;

    Real res = 0.0;
    for (int i = 0; i <= upperIndex(t) - 1; i++) {
        Real res2 = 1.0;
        for (int j = i + 1; j <= upperIndex(t) - 1; j++) {
            res2 *= exp(-2.0 * rev(j) * (cappedTime(j + 1, t) - time2(j)));
        }
        res2 *= revZero(i) ? vol(i) * vol(i) * (cappedTime(i + 1, t) - time2(i))
                           : (vol(i) * vol(i) / (2.0 * rev(i)) *
                              (1.0 - exp(-2.0 * rev(i) *
                                         (cappedTime(i + 1, t) - time2(i)))));
        res += res2;
    }

    cache4_.insert(std::make_pair(key, res));
    return res;
}

Real GsrProcessCore::G(const Time t, const Time w) const {
    std::pair<Real, Real> key;
    key = std::make_pair(w, t);
    std::map<std::pair<Real, Real>, Real>::const_iterator k = cache5_.find(key);
    if (k != cache5_.end())
        return k->second;

    Real res = 0.0;
    for (int i = lowerIndex(t); i <= upperIndex(w) - 1; i++) {
        Real res2 = 1.0;
        for (int j = lowerIndex(t); j <= i - 1; j++) {
            res2 *= exp(-rev(j) * (time2(j + 1) - flooredTime(j, t)));
        }
        res2 *= revZero(i) ? cappedTime(i + 1, w) - flooredTime(i, t)
                           : (1.0 - exp(-rev(i) * (cappedTime(i + 1, w) -
                                                   flooredTime(i, t)))) /
                                 rev(i);
        res += res2;
    }

    cache5_.insert(std::make_pair(key, res));
    return res;
}

int GsrProcessCore::lowerIndex(const Time t) const {
    return static_cast<int>(std::upper_bound(times_.begin(), times_.end(), t) -
                            times_.begin());
}

int GsrProcessCore::upperIndex(const Time t) const {
    if (t < QL_MIN_POSITIVE_REAL)
        return 0;
    return static_cast<int>(
               std::upper_bound(times_.begin(), times_.end(), t - QL_EPSILON) -
               times_.begin()) +
           1;
}

Real GsrProcessCore::cappedTime(const Size index, const Real cap) const {
    return cap != Null<Real>() ? std::min(cap, time2(index)) : time2(index);
}

Real GsrProcessCore::flooredTime(const Size index,
                                 const Real floor) const {
    return floor != Null<Real>() ? std::max(floor, time2(index)) : time2(index);
}

Real GsrProcessCore::time2(const Size index) const {
    if (index == 0)
        return 0.0;
    if (index > times_.size())
        return T_; // FIXME how to ensure that forward
                   // measure time is geq all times
                   // given
    return times_[index - 1];
}

Real GsrProcessCore::vol(const Size index) const {
    if (index >= vols_.size())
        return vols_.back();
    return vols_[index];
}

Real GsrProcessCore::rev(const Size index) const {
    if (index >= reversions_.size())
        return reversions_.back();
    return reversions_[index];
}

bool GsrProcessCore::revZero(const Size index) const {
    if (index >= revZero_.size())
        return revZero_.back();
    return revZero_[index];
}

} // namespace detail

} // namesapce QuantLib
]]></document_content>
  </document>
  <document index="12">
    <source>hestonprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2007, 2009, 2014 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/distributions/chisquaredistribution.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/math/integrals/gausslobattointegral.hpp>
#include <ql/math/integrals/segmentintegral.hpp>
#include <ql/math/modifiedbessel.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/processes/eulerdiscretization.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <ql/quotes/simplequote.hpp>
#include <boost/math/distributions/non_central_chi_squared.hpp>
#include <complex>
#include <utility>

namespace QuantLib {

    HestonProcess::HestonProcess(Handle<YieldTermStructure> riskFreeRate,
                                 Handle<YieldTermStructure> dividendYield,
                                 Handle<Quote> s0,
                                 Real v0,
                                 Real kappa,
                                 Real theta,
                                 Real sigma,
                                 Real rho,
                                 Discretization d)
    : StochasticProcess(ext::shared_ptr<discretization>(new EulerDiscretization)),
      riskFreeRate_(std::move(riskFreeRate)), dividendYield_(std::move(dividendYield)),
      s0_(std::move(s0)), v0_(v0), kappa_(kappa), theta_(theta), sigma_(sigma), rho_(rho),
      discretization_(d) {

        registerWith(riskFreeRate_);
        registerWith(dividendYield_);
        registerWith(s0_);
    }

    Size HestonProcess::size() const {
        return 2;
    }

    Size HestonProcess::factors() const {
        return (   discretization_ == BroadieKayaExactSchemeLobatto
                || discretization_ == BroadieKayaExactSchemeTrapezoidal
                || discretization_ == BroadieKayaExactSchemeLaguerre) ? 3 : 2;
    }

    Disposable<Array> HestonProcess::initialValues() const {
        Array tmp(2);
        tmp[0] = s0_->value();
        tmp[1] = v0_;
        return tmp;
    }

    Disposable<Array> HestonProcess::drift(Time t, const Array& x) const {
        Array tmp(2);
        const Real vol = (x[1] > 0.0) ? std::sqrt(x[1])
                         : (discretization_ == Reflection) ? - std::sqrt(-x[1])
                         : 0.0;

        tmp[0] = riskFreeRate_->forwardRate(t, t, Continuous)
               - dividendYield_->forwardRate(t, t, Continuous)
               - 0.5 * vol * vol;

        tmp[1] = kappa_*
           (theta_-((discretization_==PartialTruncation) ? x[1] : vol*vol));
        return tmp;
    }

    Disposable<Matrix> HestonProcess::diffusion(Time, const Array& x) const {
        /* the correlation matrix is
           |  1   rho |
           | rho   1  |
           whose square root (which is used here) is
           |  1          0       |
           | rho   sqrt(1-rho^2) |
        */
        Matrix tmp(2,2);
        const Real vol = (x[1] > 0.0) ? std::sqrt(x[1])
                         : (discretization_ == Reflection) ? -std::sqrt(-x[1])
                         : 1e-8; // set vol to (almost) zero but still
                                 // expose some correlation information
        const Real sigma2 = sigma_ * vol;
        const Real sqrhov = std::sqrt(1.0 - rho_*rho_);

        tmp[0][0] = vol;          tmp[0][1] = 0.0;
        tmp[1][0] = rho_*sigma2;  tmp[1][1] = sqrhov*sigma2;
        return tmp;
    }

    Disposable<Array> HestonProcess::apply(const Array& x0,
                                           const Array& dx) const {
        Array tmp(2);
        tmp[0] = x0[0] * std::exp(dx[0]);
        tmp[1] = x0[1] + dx[1];
        return tmp;
    }

    namespace {
        // This is the continuous version of a characteristic function
        // for the exact sampling of the Heston process, s. page 8, formula 13,
        // M. Broadie, O. Kaya, Exact Simulation of Stochastic Volatility and
        // other Affine Jump Diffusion Processes
        // http://finmath.stanford.edu/seminars/documents/Broadie.pdf
        //
        // This version does not need a branch correction procedure.
        // For details please see:
        // Roger Lord, "Efficient Pricing Algorithms for exotic Derivatives",
        // http://repub.eur.nl/pub/13917/LordR-Thesis.pdf
        std::complex<Real> Phi(const HestonProcess& process,
                               const std::complex<Real>& a,
                               Real nu_0, Real nu_t, Time dt) {
            const Real theta = process.theta();
            const Real kappa = process.kappa();
            const Real sigma = process.sigma();

            const Volatility sigma2 = sigma*sigma;
            const std::complex<Real> ga = std::sqrt(
                    kappa*kappa - 2*sigma2*a*std::complex<Real>(0.0, 1.0));
            const Real d = 4*theta*kappa/sigma2;

            const Real nu = 0.5*d-1;
            const std::complex<Real> z
                = ga*std::exp(-0.5*ga*dt)/(1.0-std::exp(-ga*dt));
            const std::complex<Real> log_z
                = -0.5*ga*dt + std::log(ga/(1.0-std::exp(-ga*dt)));

            const std::complex<Real> alpha
                = 4.0*ga*std::exp(-0.5*ga*dt)/(sigma2*(1.0-std::exp(-ga*dt)));
            const std::complex<Real> beta = 4.0*kappa*std::exp(-0.5*kappa*dt)
                                           /(sigma2*(1.0-std::exp(-kappa*dt)));

            return ga*std::exp(-0.5*(ga-kappa)*dt)*(1-std::exp(-kappa*dt))
                    / (kappa*(1.0-std::exp(-ga*dt)))
                   *std::exp((nu_0+nu_t)/sigma2 * (
                      kappa*(1.0+std::exp(-kappa*dt))/(1.0-std::exp(-kappa*dt))
                        - ga*(1.0+std::exp(-ga*dt))/(1.0-std::exp(-ga*dt))))
                   *std::exp(nu*log_z)/std::pow(z, nu)
                   *((nu_t > 1e-8)
                           ?   modifiedBesselFunction_i(
                                   nu, std::sqrt(nu_0*nu_t)*alpha)
                             / modifiedBesselFunction_i(
                                   nu, std::sqrt(nu_0*nu_t)*beta)
                           : std::pow(alpha/beta, nu)
                     );
        }

        Real ch(const HestonProcess& process,
                Real x, Real u, Real nu_0, Real nu_t, Time dt) {
            return M_2_PI*std::sin(u*x)/u
                    * Phi(process, u, nu_0, nu_t, dt).real();
        }

        Real ph(const HestonProcess& process,
                Real x, Real u, Real nu_0, Real nu_t, Time dt) {
            return M_2_PI*std::cos(u*x)*Phi(process, u, nu_0, nu_t, dt).real();
        }

        Real int_ph(const HestonProcess& process,
                    Real a, Real x, Real y, Real nu_0, Real nu_t, Time t) {
            static const GaussLaguerreIntegration gaussLaguerreIntegration(128);

            const Real rho   = process.rho();
            const Real kappa = process.kappa();
            const Real sigma = process.sigma();
            const Real x0    = std::log(process.s0()->value());

            return gaussLaguerreIntegration(
                [&](Real u){ return ph(process, y, u, nu_0, nu_t, t); })
                / std::sqrt(2*M_PI*(1-rho*rho)*y)
                * std::exp(-0.5*square<Real>()(  x - x0 - a
                                               + y*(0.5-rho*kappa/sigma))
                           /(y*(1-rho*rho)));
        }


        Real pade(Real x, const Real* nominator, const Real* denominator, Size m) {
            Real n=0.0, d=0.0;
            for (Integer i=m-1; i >= 0; --i) {
                n = (n+nominator[i])*x;
                d = (d+denominator[i])*x;
            }
            return (1+n)/(1+d);
        }

        // For the definition of the Pade approximation please see e.g.
        // http://wikipedia.org/wiki/Sine_integral#Sine_integral
        Real Si(Real x) {
            if (x <=4.0) {
                const Real n[] =
                    { -4.54393409816329991e-2,1.15457225751016682e-3,
                      -1.41018536821330254e-5,9.43280809438713025e-8,
                      -3.53201978997168357e-10,7.08240282274875911e-13,
                      -6.05338212010422477e-16 };
                const Real d[] =
                    {  1.01162145739225565e-2,4.99175116169755106e-5,
                       1.55654986308745614e-7,3.28067571055789734e-10,
                       4.5049097575386581e-13,3.21107051193712168e-16,
                       0.0 };

                return x*pade(x*x, n, d, sizeof(n)/sizeof(Real));
            }
            else {
                const Real y = 1/(x*x);
                const Real fn[] =
                    { 7.44437068161936700618e2,1.96396372895146869801e5,
                      2.37750310125431834034e7,1.43073403821274636888e9,
                      4.33736238870432522765e10,6.40533830574022022911e11,
                      4.20968180571076940208e12,1.00795182980368574617e13,
                      4.94816688199951963482e12,-4.94701168645415959931e11 };
                const Real fd[] =
                    { 7.46437068161927678031e2,1.97865247031583951450e5,
                      2.41535670165126845144e7,1.47478952192985464958e9,
                      4.58595115847765779830e10,7.08501308149515401563e11,
                      5.06084464593475076774e12,1.43468549171581016479e13,
                      1.11535493509914254097e13, 0.0 };
                const Real f = pade(y, fn, fd, 10)/x;

                const Real gn[] =
                    { 8.1359520115168615e2,2.35239181626478200e5,
                      3.12557570795778731e7,2.06297595146763354e9,
                      6.83052205423625007e10,1.09049528450362786e12,
                      7.57664583257834349e12,1.81004487464664575e13,
                      6.43291613143049485e12,-1.36517137670871689e12 };
                const Real gd[] =
                    { 8.19595201151451564e2,2.40036752835578777e5,
                      3.26026661647090822e7,2.23355543278099360e9,
                      7.87465017341829930e10,1.39866710696414565e12,
                      1.17164723371736605e13,4.01839087307656620e13,
                      3.99653257887490811e13, 0.0};
                const Real g = y*pade(y, gn, gd, 10);

                return M_PI_2 - f*std::cos(x)-g*std::sin(x);
            }
        }

        Real cornishFisherEps(const HestonProcess& process,
                              Real nu_0, Real nu_t, Time dt, Real eps) {
            // use moment generating function to get the
            // first,second, third and fourth moment of the distribution
            const Real d = 1e-2;
            const Real p2 = Phi(process, std::complex<Real>(0, -2*d),
                                                nu_0, nu_t, dt).real();
            const Real p1 = Phi(process, std::complex<Real>(0, -d),
                                                nu_0, nu_t, dt).real();
            const Real p0 = Phi(process, std::complex<Real>(0, 0),
                                                nu_0, nu_t, dt).real();
            const Real pm1= Phi(process, std::complex<Real>(0, d),
                                                 nu_0, nu_t, dt).real();
            const Real pm2= Phi(process, std::complex<Real>(0, 2*d),
                                                 nu_0, nu_t, dt).real();

            const Real avg    = (pm2-8*pm1+8*p1-p2)/(12*d);
            const Real m2     = (-pm2+16*pm1-30*p0+16*p1-p2)/(12*d*d);
            const Real var    = m2 - avg*avg;
            const Real stdDev = std::sqrt(var);

            const Real m3 = (-0.5*pm2 + pm1 - p1 + 0.5*p2)/(d*d*d);
            const Real skew
                = (m3 - 3*var*avg - avg*avg*avg) / (var*stdDev);

            const Real m4 = (pm2 - 4*pm1 + 6*p0 - 4*p1 + p2)/(d*d*d*d);
            const Real kurt
                 =  (m4 - 4*m3*avg + 6*m2*avg*avg - 3*avg*avg*avg*avg)
                   /(var*var);

            // Cornish-Fisher relation to come up with an improved
            // estimate of 1-F(u_\eps) < \eps
            const Real q = InverseCumulativeNormal()(1-eps);
            const Real w =  q + (q*q-1)/6*skew + (q*q*q-3*q)/24*(kurt-3)
                          - (2*q*q*q-5*q)/36*skew*skew;

            return avg + w*stdDev;
        }

        Real cdf_nu_ds(const HestonProcess& process,
                       Real x, Real nu_0, Real nu_t, Time dt,
                       HestonProcess::Discretization discretization) {
            const Real eps = 1e-4;
            const Real u_eps = std::min(100.0,
                std::max(0.1, cornishFisherEps(process, nu_0, nu_t, dt, eps)));

            switch (discretization) {
              case HestonProcess::BroadieKayaExactSchemeLaguerre:
              {
                  static const GaussLaguerreIntegration
                      gaussLaguerreIntegration(128);

                // get the upper bound for the integration
                Real upper = u_eps/2.0;
                while (std::abs(Phi(process,upper,nu_0,nu_t,dt)/upper)
                        > eps) upper*=2.0;

                return (x < upper)
                    ? std::max(0.0, std::min(1.0,
                        gaussLaguerreIntegration(
                            [&](Real u){ return ch(process, x, u, nu_0, nu_t, dt); })))
                    : 1.0;
              }
              case HestonProcess::BroadieKayaExactSchemeLobatto:
              {
                // get the upper bound for the integration
                Real upper = u_eps/2.0;
                while (std::abs(Phi(process, upper,nu_0,nu_t,dt)/upper)
                        >  eps) upper*=2.0;

                return (x < upper)
                    ? std::max(0.0, std::min(1.0,
                        GaussLobattoIntegral(Null<Size>(), eps)(
                            [&](Real xi){ return ch(process, x, xi, nu_0, nu_t, dt); },
                            QL_EPSILON, upper)))
                    : 1.0;
              }
              case HestonProcess::BroadieKayaExactSchemeTrapezoidal:
              {
                const Real h = 0.05;

                Real si = Si(0.5*h*x);
                Real s = M_2_PI*si;
                std::complex<Real> f;
                Size j = 0;
                do {
                    ++j;
                    const Real u = h*j;
                    const Real si_n = Si(x*(u+0.5*h));

                    f = Phi(process, u, nu_0, nu_t, dt);
                    s+= M_2_PI*f.real()*(si_n-si);
                    si = si_n;
                }
                while (M_2_PI*std::abs(f)/j > eps);

                return s;
              }
              default:
                QL_FAIL("unknown integration method");
            }
        }
    }

    Real cdf_nu_ds_minus_x(const HestonProcess &process, Real x, Real nu_0,
                           Real nu_t, Time dt,
                           HestonProcess::Discretization discretization,
                           Real x0) {
        return cdf_nu_ds(process, x, nu_0, nu_t, dt, discretization) - x0;
    }

    Real HestonProcess::pdf(Real x, Real v, Time t, Real eps) const {
         const Real k = sigma_*sigma_*(1-std::exp(-kappa_*t))/(4*kappa_);
         const Real a = std::log(  dividendYield_->discount(t)
                                   / riskFreeRate_->discount(t))
                      + rho_/sigma_*(v - v0_ - kappa_*theta_*t);

         const Real x0 = std::log(s0()->value());
         Real upper = std::max(0.1, -(x-x0-a)/(0.5-rho_*kappa_/sigma_)), f=0, df=1;

         while (df > 0.0 || f > 0.1*eps) {
             const Real f1 = x-x0-a+upper*(0.5-rho_*kappa_/sigma_);
             const Real f2 = -0.5*f1*f1/(upper*(1-rho_*rho_));

             df = 1/std::sqrt(2*M_PI*(1-rho_*rho_))
                 * ( -0.5/(upper*std::sqrt(upper))*std::exp(f2)
                    + 1/std::sqrt(upper)*std::exp(f2)*(-0.5/(1-rho_*rho_))
                           *(-1/(upper*upper)*f1*f1
                             + 2/upper*f1*(0.5-rho_*kappa_/sigma_)));

             f = std::exp(f2)/ std::sqrt(2*M_PI*(1-rho_*rho_)*upper);
             upper*=1.5;
         }

         upper = 2.0*cornishFisherEps(*this, v0_, v, t,1e-3);

         return SegmentIntegral(100)(
               [&](Real xi){ return int_ph(*this, a, x, xi, v0_, v, t); },
               QL_EPSILON, upper)
               * boost::math::pdf(
                     boost::math::non_central_chi_squared_distribution<Real>(
                         4*theta_*kappa_/(sigma_*sigma_),
                         4*kappa_*std::exp(-kappa_*t)
                         /((sigma_*sigma_)*(1-std::exp(-kappa_*t)))*v0_),
                     v/k) / k;
     }

    Disposable<Array> HestonProcess::evolve(Time t0, const Array& x0,
                                            Time dt, const Array& dw) const {
        Array retVal(2);
        Real vol, vol2, mu, nu, dy;

        const Real sdt = std::sqrt(dt);
        const Real sqrhov = std::sqrt(1.0 - rho_*rho_);

        switch (discretization_) {
          // For the definition of PartialTruncation, FullTruncation
          // and Reflection  see Lord, R., R. Koekkoek and D. van Dijk (2006),
          // "A Comparison of biased simulation schemes for
          //  stochastic volatility models",
          // Working Paper, Tinbergen Institute
          case PartialTruncation:
            vol = (x0[1] > 0.0) ? std::sqrt(x0[1]) : 0.0;
            vol2 = sigma_ * vol;
            mu =    riskFreeRate_->forwardRate(t0, t0+dt, Continuous)
                  - dividendYield_->forwardRate(t0, t0+dt, Continuous)
                    - 0.5 * vol * vol;
            nu = kappa_*(theta_ - x0[1]);

            retVal[0] = x0[0] * std::exp(mu*dt+vol*dw[0]*sdt);
            retVal[1] = x0[1] + nu*dt + vol2*sdt*(rho_*dw[0] + sqrhov*dw[1]);
            break;
          case FullTruncation:
            vol = (x0[1] > 0.0) ? std::sqrt(x0[1]) : 0.0;
            vol2 = sigma_ * vol;
            mu =    riskFreeRate_->forwardRate(t0, t0+dt, Continuous)
                  - dividendYield_->forwardRate(t0, t0+dt, Continuous)
                    - 0.5 * vol * vol;
            nu = kappa_*(theta_ - vol*vol);

            retVal[0] = x0[0] * std::exp(mu*dt+vol*dw[0]*sdt);
            retVal[1] = x0[1] + nu*dt + vol2*sdt*(rho_*dw[0] + sqrhov*dw[1]);
            break;
          case Reflection:
            vol = std::sqrt(std::fabs(x0[1]));
            vol2 = sigma_ * vol;
            mu =    riskFreeRate_->forwardRate(t0, t0+dt, Continuous)
                  - dividendYield_->forwardRate(t0, t0+dt, Continuous)
                    - 0.5 * vol*vol;
            nu = kappa_*(theta_ - vol*vol);

            retVal[0] = x0[0]*std::exp(mu*dt+vol*dw[0]*sdt);
            retVal[1] = vol*vol
                        +nu*dt + vol2*sdt*(rho_*dw[0] + sqrhov*dw[1]);
            break;
          case NonCentralChiSquareVariance:
            // use Alan Lewis trick to decorrelate the equity and the variance
            // process by using y(t)=x(t)-\frac{rho}{sigma}\nu(t)
            // and Ito's Lemma. Then use exact sampling for the variance
            // process. For further details please read the Wilmott thread
            // "QuantLib code is very high quality"
            vol = (x0[1] > 0.0) ? std::sqrt(x0[1]) : 0.0;
            mu =   riskFreeRate_->forwardRate(t0, t0+dt, Continuous)
                 - dividendYield_->forwardRate(t0, t0+dt, Continuous)
                   - 0.5 * vol*vol;

            retVal[1] = varianceDistribution(x0[1], dw[1], dt);
            dy = (mu - rho_/sigma_*kappa_
                          *(theta_-vol*vol)) * dt + vol*sqrhov*dw[0]*sdt;

            retVal[0] = x0[0]*std::exp(dy + rho_/sigma_*(retVal[1]-x0[1]));
            break;
          case QuadraticExponential:
          case QuadraticExponentialMartingale:
          {
            // for details of the quadratic exponential discretization scheme
            // see Leif Andersen,
            // Efficient Simulation of the Heston Stochastic Volatility Model
            const Real ex = std::exp(-kappa_*dt);

            const Real m  =  theta_+(x0[1]-theta_)*ex;
            const Real s2 =  x0[1]*sigma_*sigma_*ex/kappa_*(1-ex)
                           + theta_*sigma_*sigma_/(2*kappa_)*(1-ex)*(1-ex);
            const Real psi = s2/(m*m);

            const Real g1 =  0.5;
            const Real g2 =  0.5;
                  Real k0 = -rho_*kappa_*theta_*dt/sigma_;
            const Real k1 =  g1*dt*(kappa_*rho_/sigma_-0.5)-rho_/sigma_;
            const Real k2 =  g2*dt*(kappa_*rho_/sigma_-0.5)+rho_/sigma_;
            const Real k3 =  g1*dt*(1-rho_*rho_);
            const Real k4 =  g2*dt*(1-rho_*rho_);
            const Real A  =  k2+0.5*k4;

            if (psi < 1.5) {
                const Real b2 = 2/psi-1+std::sqrt(2/psi*(2/psi-1));
                const Real b  = std::sqrt(b2);
                const Real a  = m/(1+b2);

                if (discretization_ == QuadraticExponentialMartingale) {
                    // martingale correction
                    QL_REQUIRE(A < 1/(2*a), "illegal value");
                    k0 = -A*b2*a/(1-2*A*a)+0.5*std::log(1-2*A*a)
                         -(k1+0.5*k3)*x0[1];
                }
                retVal[1] = a*(b+dw[1])*(b+dw[1]);
            }
            else {
                const Real p = (psi-1)/(psi+1);
                const Real beta = (1-p)/m;

                const Real u = CumulativeNormalDistribution()(dw[1]);

                if (discretization_ == QuadraticExponentialMartingale) {
                    // martingale correction
                    QL_REQUIRE(A < beta, "illegal value");
                    k0 = -std::log(p+beta*(1-p)/(beta-A))-(k1+0.5*k3)*x0[1];
                }
                retVal[1] = ((u <= p) ? 0.0 : std::log((1-p)/(1-u))/beta);
            }

            mu =   riskFreeRate_->forwardRate(t0, t0+dt, Continuous)
                 - dividendYield_->forwardRate(t0, t0+dt, Continuous);

            retVal[0] = x0[0]*std::exp(mu*dt + k0 + k1*x0[1] + k2*retVal[1]
                                       +std::sqrt(k3*x0[1]+k4*retVal[1])*dw[0]);
          }
          break;
          case BroadieKayaExactSchemeLobatto:
          case BroadieKayaExactSchemeLaguerre:
          case BroadieKayaExactSchemeTrapezoidal:
          {
            const Real nu_0 = x0[1];
            const Real nu_t = varianceDistribution(nu_0, dw[1], dt);

            const Real x = std::min(1.0-QL_EPSILON,
                std::max(0.0, CumulativeNormalDistribution()(dw[2])));

            const Real vds = Brent().solve(
                [&](Real xi){ return cdf_nu_ds_minus_x(*this, xi, nu_0, nu_t, dt, discretization_, x); },
                1e-5, theta_*dt, 0.1*theta_*dt);

            const Real vdw
                = (nu_t - nu_0 - kappa_*theta_*dt + kappa_*vds)/sigma_;

            mu = ( riskFreeRate_->forwardRate(t0, t0+dt, Continuous)
                  -dividendYield_->forwardRate(t0, t0+dt, Continuous))*dt
                - 0.5*vds + rho_*vdw;

            const Volatility sig = std::sqrt((1-rho_*rho_)*vds);
            const Real s = x0[0]*std::exp(mu + sig*dw[0]);

            retVal[0] = s;
            retVal[1] = nu_t;
          }
          break;
          default:
            QL_FAIL("unknown discretization schema");
        }

        return retVal;
    }

    const Handle<Quote>& HestonProcess::s0() const {
        return s0_;
    }

    const Handle<YieldTermStructure>& HestonProcess::dividendYield() const {
        return dividendYield_;
    }

    const Handle<YieldTermStructure>& HestonProcess::riskFreeRate() const {
        return riskFreeRate_;
    }

    Time HestonProcess::time(const Date& d) const {
        return riskFreeRate_->dayCounter().yearFraction(
                                           riskFreeRate_->referenceDate(), d);
    }

    Real HestonProcess::varianceDistribution(Real v, Real dw, Time dt) const {
        const Real df  = 4*theta_*kappa_/(sigma_*sigma_);
        const Real ncp = 4*kappa_*std::exp(-kappa_*dt)
            /(sigma_*sigma_*(1-std::exp(-kappa_*dt)))*v;

        const Real p = std::min(1.0-QL_EPSILON,
            std::max(0.0, CumulativeNormalDistribution()(dw)));

        return sigma_*sigma_*(1-std::exp(-kappa_*dt))/(4*kappa_)
            *InverseNonCentralCumulativeChiSquareDistribution(df, ncp, 100)(p);
    }
}
]]></document_content>
  </document>
  <document index="13">
    <source>hullwhiteprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Banca Profilo S.p.A.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/processes/hullwhiteprocess.hpp>

namespace QuantLib {

    HullWhiteProcess::HullWhiteProcess(const Handle<YieldTermStructure>& h,
                                       Real a,
                                       Real sigma)
    : process_(new OrnsteinUhlenbeckProcess(
                   a, sigma, h->forwardRate(0.0,0.0,Continuous,NoFrequency))),
      h_(h), a_(a), sigma_(sigma) {
        QL_REQUIRE(a_ >= 0.0, "negative a given");
        QL_REQUIRE(sigma_ >= 0.0, "negative sigma given");
    }

    Real HullWhiteProcess::x0() const {
        return process_->x0();
    }

    Real HullWhiteProcess::drift(Time t, Real x) const {
        Real alpha_drift = sigma_*sigma_/(2*a_)*(1-std::exp(-2*a_*t));
        Real shift = 0.0001;
        Real f = h_->forwardRate(t, t, Continuous, NoFrequency);
        Real fup = h_->forwardRate(t+shift, t+shift, Continuous, NoFrequency);
        Real f_prime = (fup-f)/shift;
        alpha_drift += a_*f+f_prime;
        return process_->drift(t, x) + alpha_drift;
    }

    Real HullWhiteProcess::diffusion(Time t, Real x) const{
        return process_->diffusion(t, x);
    }

    Real HullWhiteProcess::expectation(Time t0, Real x0, Time dt) const {
        return process_->expectation(t0, x0, dt)
             + alpha(t0 + dt) - alpha(t0)*std::exp(-a_*dt);
    }

    Real HullWhiteProcess::stdDeviation(Time t0, Real x0, Time dt) const{
        return process_->stdDeviation(t0, x0, dt);
    }

    Real HullWhiteProcess::variance(Time t0, Real x0, Time dt) const{
        return process_->variance(t0, x0, dt);
    }

    Real HullWhiteProcess::alpha(Time t) const {
        Real alfa = a_ > QL_EPSILON ?
                    (sigma_/a_)*(1 - std::exp(-a_*t)) :
                    sigma_*t;
        alfa *= 0.5*alfa;
        alfa += h_->forwardRate(t, t, Continuous, NoFrequency);
        return alfa;
    }

    Real HullWhiteProcess::a() const {
        return a_;
    }

    Real HullWhiteProcess::sigma() const {
        return sigma_;
    }

    HullWhiteForwardProcess::HullWhiteForwardProcess(
                                          const Handle<YieldTermStructure>& h,
                                          Real a,
                                          Real sigma)
    : process_(new OrnsteinUhlenbeckProcess(
                   a, sigma, h->forwardRate(0.0,0.0,Continuous,NoFrequency))),
      h_(h), a_(a), sigma_(sigma) {}

    Real HullWhiteForwardProcess::x0() const {
        return process_->x0();
    }

    Real HullWhiteForwardProcess::drift(Time t, Real x) const {
        Real alpha_drift = sigma_*sigma_/(2*a_)*(1-std::exp(-2*a_*t));
        Real shift = 0.0001;
        Real f = h_->forwardRate(t, t, Continuous, NoFrequency);
        Real fup = h_->forwardRate(t+shift, t+shift, Continuous, NoFrequency);
        Real f_prime = (fup-f)/shift;
        alpha_drift += a_*f+f_prime;
        return process_->drift(t, x) + alpha_drift - B(t, T_)*sigma_*sigma_;
    }

    Real HullWhiteForwardProcess::diffusion(Time t, Real x) const{
        return process_->diffusion(t, x);
    }

    Real HullWhiteForwardProcess::expectation(Time t0, Real x0,
                                              Time dt) const {
        return process_->expectation(t0, x0, dt)
             + alpha(t0 + dt) - alpha(t0)*std::exp(-a_*dt)
             - M_T(t0, t0+dt, T_);
    }

    Real HullWhiteForwardProcess::stdDeviation(Time t0, Real x0,
                                               Time dt) const {
        return process_->stdDeviation(t0, x0, dt);
    }

    Real HullWhiteForwardProcess::variance(Time t0, Real x0, Time dt) const{
        return process_->variance(t0, x0, dt);
    }

    Real HullWhiteForwardProcess::alpha(Time t) const {
        Real alfa = a_ > QL_EPSILON ?
                    (sigma_/a_)*(1 - std::exp(-a_*t)) :
                    sigma_*t;
        alfa *= 0.5*alfa;
        alfa += h_->forwardRate(t, t, Continuous, NoFrequency);

        return alfa;
    }

    Real HullWhiteForwardProcess::M_T(Real s, Real t, Real T) const {
        if (a_ > QL_EPSILON) {
            Real coeff = (sigma_*sigma_)/(a_*a_);
            Real exp1 = std::exp(-a_*(t-s));
            Real exp2 = std::exp(-a_*(T-t));
            Real exp3 = std::exp(-a_*(T+t-2.0*s));
            return coeff*(1-exp1)-0.5*coeff*(exp2-exp3);
        } else {
            // low-a algebraic limit
            Real coeff = (sigma_*sigma_)/2.0;
            return coeff*(t-s)*(2.0*T-t-s);
        }
    }

    Real HullWhiteForwardProcess::B(Time t, Time T) const {
        return a_ > QL_EPSILON ?
               1/a_ * (1-std::exp(-a_*(T-t))) :
               T-t;
    }

    Real HullWhiteForwardProcess::a() const {
        return a_;
    }

    Real HullWhiteForwardProcess::sigma() const {
        return sigma_;
    }
}

]]></document_content>
  </document>
  <document index="14">
    <source>hybridhestonhullwhiteprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file hybridhestonhullwhiteprocess.hpp
    \brief hybrid equity (heston model)
           with stochastic interest rates (hull white model)
*/

#include <ql/termstructures/yield/flatforward.hpp>
#include <ql/processes/hybridhestonhullwhiteprocess.hpp>

namespace QuantLib {

    HybridHestonHullWhiteProcess::HybridHestonHullWhiteProcess(
        const ext::shared_ptr<HestonProcess> & hestonProcess,
        const ext::shared_ptr<HullWhiteForwardProcess> & hullWhiteProcess,
        Real corrEquityShortRate,
        HybridHestonHullWhiteProcess::Discretization discretization)
    : hestonProcess_(hestonProcess),
      hullWhiteProcess_(hullWhiteProcess),
      hullWhiteModel_(new HullWhite(hestonProcess->riskFreeRate(),
                                    hullWhiteProcess->a(),
                                    hullWhiteProcess->sigma())),
      corrEquityShortRate_(corrEquityShortRate),
      discretization_(discretization),
      maxRho_(std::sqrt(1-hestonProcess->rho()*hestonProcess->rho()) 
              - std::sqrt(QL_EPSILON) /* reserve for rounding errors */),

      T_(hullWhiteProcess->getForwardMeasureTime()),
      endDiscount_(hestonProcess->riskFreeRate()->discount(T_)) {

        QL_REQUIRE(  corrEquityShortRate*corrEquityShortRate
                    +hestonProcess->rho()*hestonProcess->rho() <= 1.0,
                    "correlation matrix is not positive definite");
        
        QL_REQUIRE(hullWhiteProcess->sigma() > 0.0, 
                   "positive vol of Hull White process is required");
    }
        
    Size HybridHestonHullWhiteProcess::size() const {
        return 3;
    }

    Disposable<Array> HybridHestonHullWhiteProcess::initialValues() const {
        Array retVal(3);
        retVal[0] = hestonProcess_->s0()->value();
        retVal[1] = hestonProcess_->v0();
        retVal[2] = hullWhiteProcess_->x0();
        
        return retVal;
    }

    Disposable<Array> 
    HybridHestonHullWhiteProcess::drift(Time t, const Array& x) const {
        Array retVal(3), x0(2);
        
        x0[0] = x[0]; x0[1] = x[1];
        Array y0 = hestonProcess_->drift(t, x0);
        
        retVal[0] = y0[0]; retVal[1] = y0[1];
        retVal[2] = hullWhiteProcess_->drift(t, x[2]);
        
        return retVal;
    }

    Disposable<Array> 
    HybridHestonHullWhiteProcess::apply(const Array& x0,const Array& dx) const {
        Array retVal(3), xt(2), dxt(2);
        
        xt[0]  = x0[0]; xt[1]  = x0[1];
        dxt[0] = dx[0]; dxt[1] = dx[1];

        Array yt = hestonProcess_->apply(xt, dxt);
        
        retVal[0] = yt[0]; retVal[1] = yt[1];
        retVal[2] = hullWhiteProcess_->apply(x0[2], dx[2]);
        
        return retVal;
    }
    
    Disposable<Matrix> 
    HybridHestonHullWhiteProcess::diffusion(Time t, const Array& x) const {
        Matrix retVal(3,3);

        Array xt(2); xt[0] = x[0]; xt[1] = x[1];
        Matrix m = hestonProcess_->diffusion(t, xt);
        retVal[0][0] = m[0][0]; retVal[0][1] = 0.0;     retVal[0][2] = 0.0;
        retVal[1][0] = m[1][0]; retVal[1][1] = m[1][1]; retVal[1][2] = 0.0;
        
        const Real sigma = hullWhiteProcess_->sigma();
        retVal[2][0] = corrEquityShortRate_ * sigma;
        retVal[2][1] = - retVal[2][0]*retVal[1][0] / retVal[1][1];
        retVal[2][2] = std::sqrt( sigma*sigma - retVal[2][1]*retVal[2][1] 
                                              - retVal[2][0]*retVal[2][0] );
        
        return retVal;
    }

    Disposable<Array> 
    HybridHestonHullWhiteProcess::evolve(Time t0, const Array& x0,
                                         Time dt, const Array& dw) const {

        const Rate r         = x0[2];
        const Real a         = hullWhiteProcess_->a();
        const Real sigma     = hullWhiteProcess_->sigma();
        const Real rho       = corrEquityShortRate_;
        const Real xi        = hestonProcess_->rho();
        const Volatility eta = (x0[1] > 0.0) ? std::sqrt(x0[1]) : 0.0;
        const Time s = t0;
        const Time t = t0 + dt;
        const Time T = T_;
        const Rate dy
            = hestonProcess_->dividendYield()->forwardRate(s, t, Continuous,
                                                           NoFrequency);

        const Real df
            = std::log(  hestonProcess_->riskFreeRate()->discount(t)
                       / hestonProcess_->riskFreeRate()->discount(s));

        const Real eaT=std::exp(-a*T);
        const Real eat=std::exp(-a*t);
        const Real eas=std::exp(-a*s);
        const Real iat=1.0/eat;
        const Real ias=1.0/eas;

        const Real m1 = -(dy+0.5*eta*eta)*dt - df;

        const Real m2 = -rho*sigma*eta/a*(dt-1/a*eaT*(iat-ias));

        const Real m3 = (r - hullWhiteProcess_->alpha(s))
                       *hullWhiteProcess_->B(s,t);

        const Real m4 = sigma*sigma/(2*a*a)
            *(dt + 2/a*(eat-eas) - 1/(2*a)*(eat*eat-eas*eas));

        const Real m5 = -sigma*sigma/(a*a)
            *(dt - 1/a*(1-eat*ias) - 1/(2*a)*eaT*(iat-2*ias+eat*ias*ias));

        const Real mu = m1 + m2 + m3 + m4 + m5;

        Array retVal(3);
        
        const Real eta2 = hestonProcess_->sigma() * eta;
        const Real nu
            = hestonProcess_->kappa()*(hestonProcess_->theta() - eta*eta);

        retVal[1] = x0[1] + nu*dt + eta2*std::sqrt(dt)
                                          *(xi*dw[0]+std::sqrt(1-xi*xi)*dw[1]);

        if (discretization_ == BSMHullWhite) {
            const Real v1 = eta*eta*dt 
                + sigma*sigma/(a*a)*(dt - 2/a*(1 - eat*ias) 
                                        + 1/(2*a)*(1 - eat*eat*ias*ias))
                + 2*sigma*eta/a*rho*(dt - 1/a*(1 - eat*ias));
            const Real v2 = hullWhiteProcess_->variance(t0, r, dt);
            const Real v12 = (1-eat*ias)*(sigma*eta/a*rho + sigma*sigma/(a*a))
                            - sigma*sigma/(2*a*a)*(1 - eat*eat*ias*ias);
    
            QL_REQUIRE(v1 > 0.0 && v2 > 0.0, "zero or negative variance given");
            
            // terminal rho must be between -maxRho and +maxRho
            const Real rhoT 
                = std::min(maxRho_, std::max(-maxRho_, v12/std::sqrt(v1*v2)));
            QL_REQUIRE(    rhoT <= 1.0 && rhoT >= -1.0
                       && 1-rhoT*rhoT/(1-xi*xi) >= 0.0, 
                       "invalid terminal correlation");
            
            const Real dw_0 =  dw[0];
            const Real dw_2 =  rhoT*dw[0]- rhoT*xi/std::sqrt(1-xi*xi)*dw[1] 
                             + std::sqrt(1 - rhoT*rhoT/(1-xi*xi))*dw[2];        
    
            retVal[2] = hullWhiteProcess_->evolve(t0, r, dt, dw_2);
    
            const Real vol = std::sqrt(v1)*dw_0;
            retVal[0] = x0[0]*std::exp(mu + vol);
        }
        else if (discretization_ == Euler) {
            const Real dw_2 =  rho*dw[0]- rho*xi/std::sqrt(1-xi*xi)*dw[1] 
                             + std::sqrt(1 - rho*rho/(1-xi*xi))*dw[2];        
    
            retVal[2] = hullWhiteProcess_->evolve(t0, r, dt, dw_2);
    
            const Real vol = eta*std::sqrt(dt)*dw[0];
            retVal[0] = x0[0]*std::exp(mu + vol);            
        }
        else
            QL_FAIL("unknown discretization scheme");

        return retVal;
    }
    
    DiscountFactor
    HybridHestonHullWhiteProcess::numeraire(Time t, const Array& x) const {

        return hullWhiteModel_->discountBond(t, T_, x[2]) / endDiscount_;
    }

    Real HybridHestonHullWhiteProcess::eta() const {
        return corrEquityShortRate_;
    }

    const ext::shared_ptr<HestonProcess>& 
    HybridHestonHullWhiteProcess::hestonProcess() const {
        return hestonProcess_;
    }
    
    const ext::shared_ptr<HullWhiteForwardProcess>& 
    HybridHestonHullWhiteProcess::hullWhiteProcess() const {
        return hullWhiteProcess_;
    }

    HybridHestonHullWhiteProcess::Discretization 
    HybridHestonHullWhiteProcess::discretization() const {
        return discretization_;
    }
    
    Time HybridHestonHullWhiteProcess::time(const Date& date) const {
        return hestonProcess_->time(date);
    }

    void HybridHestonHullWhiteProcess::update() {
        endDiscount_ = hestonProcess_->riskFreeRate()->discount(T_);
    }
}
]]></document_content>
  </document>
  <document index="15">
    <source>jointstochasticprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file jointstochasticprocess.cpp
    \brief multi model process for hybrid products
*/

#include <ql/math/functional.hpp>
#include <ql/math/matrixutilities/pseudosqrt.hpp>
#include <ql/math/matrixutilities/svd.hpp>
#include <ql/processes/jointstochasticprocess.hpp>
#include <utility>

namespace QuantLib {

    JointStochasticProcess::JointStochasticProcess(
        std::vector<ext::shared_ptr<StochasticProcess> > l, Size factors)
    : l_(std::move(l)), size_(0), factors_(factors), modelFactors_(0) {

        for (const auto& iter : l_) {
            registerWith(iter);
        }

        vsize_.reserve   (l_.size()+1);
        vfactors_.reserve(l_.size()+1);

        for (const auto& iter : l_) {
            vsize_.push_back(size_);
            size_ += iter->size();

            vfactors_.push_back(modelFactors_);
            modelFactors_ += iter->factors();
        }

        vsize_.push_back(size_);
        vfactors_.push_back(modelFactors_);

        if (factors_ == Null<Size>()) {
            factors_ = modelFactors_;
        } else {
            QL_REQUIRE(factors_ <= size_, "too many factors given");
        }
    }

    Size JointStochasticProcess::size() const {
        return size_;
    }

    Size JointStochasticProcess::factors() const {
        return factors_;
    }

    Disposable<Array> JointStochasticProcess::slice(const Array& x,
                                                    Size i) const {
        // cut out the ith process' variables
        Size n = vsize_[i+1]-vsize_[i];
        Array y(n);
        std::copy(x.begin()+vsize_[i], x.begin()+vsize_[i+1], y.begin());
        return y;
    }

    Disposable<Array> JointStochasticProcess::initialValues() const {
        Array retVal(size());

        for (auto iter = l_.begin(); iter != l_.end(); ++iter) {
            const Array& pInitValues = (*iter)->initialValues();

            std::copy(pInitValues.begin(), pInitValues.end(),
                      retVal.begin()+vsize_[iter - l_.begin()]);
        }

        return retVal;
    }


    Disposable<Array> JointStochasticProcess::drift(Time t,
                                                    const Array& x) const {
        Array retVal(size());

        for (Size i=0; i < l_.size(); ++i) {

            const Array& pDrift = l_[i]->drift(t, slice(x,i));

            std::copy(pDrift.begin(), pDrift.end(),
                      retVal.begin()+vsize_[i]);
        }

        return retVal;
    }

    Disposable<Array> JointStochasticProcess::expectation(Time t0,
                                                          const Array& x0,
                                                          Time dt) const {
        Array retVal(size());

        for (Size i=0; i < l_.size(); ++i) {

            const Array& pExpectation = l_[i]->expectation(t0, slice(x0,i), dt);

            std::copy(pExpectation.begin(), pExpectation.end(),
                      retVal.begin()+ vsize_[i]);
        }

        return retVal;
    }


    Disposable<Matrix> JointStochasticProcess::diffusion(
                                               Time t, const Array& x) const {
        // might need some improvement in the future
        const Time dt = 0.001;
        return pseudoSqrt(covariance(t, x, dt)/dt);
    }


    Disposable<Matrix> JointStochasticProcess::covariance(Time t0,
                                                          const Array& x0,
                                                          Time dt) const {

        // get the model intrinsic covariance matrix
        Matrix retVal(size(), size(), 0.0);

        for (Size j=0; j < l_.size(); ++j) {

            const Size vs = vsize_[j];
            const Matrix& pCov = l_[j]->covariance(t0, slice(x0,j), dt);

            for (Size i=0; i < pCov.rows(); ++i) {
                std::copy(pCov.row_begin(i), pCov.row_end(i),
                          retVal.row_begin(vs+i) + vs);
            }
        }

        // add the cross model covariance matrix
        const Array& volatility = Sqrt(retVal.diagonal());
        Matrix crossModelCovar = this->crossModelCorrelation(t0, x0);

        for (Size i=0; i < size(); ++i) {
            for (Size j=0; j < size(); ++j) {
                crossModelCovar[i][j] *= volatility[i]*volatility[j];
            }
        }

        retVal += crossModelCovar;

        return retVal;
    }


    Disposable<Matrix> JointStochasticProcess::stdDeviation(Time t0,
                                                            const Array& x0,
                                                            Time dt) const {
        return pseudoSqrt(covariance(t0, x0, dt));
    }


    Disposable<Array> JointStochasticProcess::apply(const Array& x0,
                                                    const Array& dx) const {
        Array retVal(size());

        for (Size i=0; i < l_.size(); ++i) {
            const Array& pApply = l_[i]->apply(slice(x0,i), slice(dx,i));

            std::copy(pApply.begin(), pApply.end(),
                      retVal.begin()+vsize_[i]);
        }

        return retVal;
    }

    Disposable<Array> JointStochasticProcess::evolve(
        Time t0, const Array& x0, Time dt, const Array& dw) const {
        Array dv(modelFactors_);

        if (   correlationIsStateDependent()
            || correlationCache_.count(CachingKey(t0, dt)) == 0) {
            Matrix cov  = covariance(t0, x0, dt);

            const Array& sqrtDiag = Sqrt(cov.diagonal());
            for (Size i=0; i < cov.rows(); ++i) {
                for (Size j=i; j < cov.columns(); ++j) {
                    const Real div = sqrtDiag[i]*sqrtDiag[j];

                    cov[i][j] = cov[j][i] = ( div > 0) ? cov[i][j]/div : 0.0;
                }
            }

            Matrix diff(size(), modelFactors_, 0.0);

            for (Size j = 0; j < l_.size(); ++j) {
                const Size vs = vsize_   [j];
                const Size vf = vfactors_[j];

                Matrix stdDev = l_[j]->stdDeviation(t0, slice(x0,j), dt);

                for (Size i=0; i < stdDev.rows(); ++i) {
                    const Volatility vol = std::sqrt(
                        std::inner_product(stdDev.row_begin(i),
                                           stdDev.row_end(i),
                                           stdDev.row_begin(i), 0.0));
                    if (vol > 0.0) {
                        std::transform(stdDev.row_begin(i), stdDev.row_end(i),
                                       stdDev.row_begin(i),
                                       divide_by<Real>(vol));
                    }
                    else {
                        // keep the svd happy
                        std::fill(stdDev.row_begin(i), stdDev.row_end(i),
                                  100*i*QL_EPSILON);
                    }
                }

                SVD svd(stdDev);
                const Array& s = svd.singularValues();
                Matrix w(s.size(), s.size(), 0.0);
                for (Size i=0; i < s.size(); ++i) {
                    if (std::fabs(s[i]) > std::sqrt(QL_EPSILON)) {
                        w[i][i] = 1.0/s[i];
                    }
                }

                const Matrix inv = svd.U() * w * transpose(svd.V());

                for (Size i=0; i < stdDev.rows(); ++i) {
                    std::copy(inv.row_begin(i), inv.row_end(i),
                              diff.row_begin(i+vs)+vf);
                }
            }

            Matrix rs = rankReducedSqrt(cov, factors_, 1.0,
                                        SalvagingAlgorithm::Spectral);

            if (rs.columns() < factors_) {
                // less eigenvalues than expected factors.
                // fill the rest with zero's.
                Matrix tmp = Matrix(cov.rows(), factors_, 0.0);
                for (Size i=0; i < cov.rows(); ++i) {
                    std::copy(rs.row_begin(i), rs.row_end(i),
                              tmp.row_begin(i));
                }
                rs = tmp;
            }

            const Matrix m = transpose(diff) * rs;

            if (!correlationIsStateDependent()) {
                correlationCache_[CachingKey(t0,dt)] = m;
            }
            dv = m*dw;
        }
        else {
            if (!correlationIsStateDependent()) {
                dv = correlationCache_[CachingKey(t0,dt)] * dw;
            }
        }

        this->preEvolve(t0, x0, dt, dv);


        Array retVal(size());
        for (auto iter = l_.begin(); iter != l_.end(); ++iter) {
            const Size i = iter - l_.begin();

            Array dz((*iter)->factors());
            std::copy(dv.begin()+vfactors_[i],
                      dv.begin()+vfactors_[i] + (*iter)->factors(),
                      dz.begin());
            Array x((*iter)->size());
            std::copy(x0.begin()+vsize_[i],
                      x0.begin()+vsize_[i] + (*iter)->size(),
                      x.begin());
            const Array r = (*iter)->evolve(t0, x, dt, dz);
            std::copy(r.begin(), r.end(), retVal.begin()+vsize_[i]);
        }

        return this->postEvolve(t0, x0, dt, dv, retVal);
    }

    const std::vector<ext::shared_ptr<StochasticProcess> > &
                          JointStochasticProcess::constituents() const {
        return l_;
    }

    Time JointStochasticProcess::time(const Date& date) const {
        QL_REQUIRE(!l_.empty(), "process list is empty");

        return l_[0]->time(date);
    }

    void JointStochasticProcess::update() {
        // clear all caches
        correlationCache_.clear();

        this->StochasticProcess::update();
    }
}
]]></document_content>
  </document>
  <document index="16">
    <source>merton76process.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/processes/merton76process.hpp>
#include <utility>

namespace QuantLib {

    Merton76Process::Merton76Process(const Handle<Quote>& stateVariable,
                                     const Handle<YieldTermStructure>& dividendTS,
                                     const Handle<YieldTermStructure>& riskFreeTS,
                                     const Handle<BlackVolTermStructure>& blackVolTS,
                                     Handle<Quote> jumpInt,
                                     Handle<Quote> logJMean,
                                     Handle<Quote> logJVol,
                                     const ext::shared_ptr<discretization>& disc)
    : blackProcess_(
          new BlackScholesMertonProcess(stateVariable, dividendTS, riskFreeTS, blackVolTS, disc)),
      jumpIntensity_(std::move(jumpInt)), logMeanJump_(std::move(logJMean)),
      logJumpVolatility_(std::move(logJVol)) {
        registerWith(blackProcess_);
        registerWith(jumpIntensity_);
        registerWith(logMeanJump_);
        registerWith(logJumpVolatility_);
    }

    Real Merton76Process::x0() const {
        return blackProcess_->x0();
    }

    Time Merton76Process::time(const Date& d) const {
        return blackProcess_->time(d);
    }

    const Handle<Quote>& Merton76Process::stateVariable() const {
        return blackProcess_->stateVariable();
    }

    const Handle<YieldTermStructure>& Merton76Process::dividendYield() const {
        return blackProcess_->dividendYield();
    }

    const Handle<YieldTermStructure>& Merton76Process::riskFreeRate() const {
        return blackProcess_->riskFreeRate();
    }

    const Handle<BlackVolTermStructure>&
    Merton76Process::blackVolatility() const {
        return blackProcess_->blackVolatility();
    }

    const Handle<Quote>& Merton76Process::jumpIntensity() const {
        return jumpIntensity_;
    }

    const Handle<Quote>& Merton76Process::logMeanJump() const {
        return logMeanJump_;
    }

    const Handle<Quote>& Merton76Process::logJumpVolatility() const {
        return logJumpVolatility_;
    }

}
]]></document_content>
  </document>
  <document index="17">
    <source>mfstateprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/processes/mfstateprocess.hpp>

namespace QuantLib {

    MfStateProcess::MfStateProcess(Real reversion, const Array &times,
                                   const Array &vols)
        : reversion_(reversion), reversionZero_(false), times_(times),
          vols_(vols) {
        if (reversion_ < QL_EPSILON && -reversion_ < QL_EPSILON)
            reversionZero_ = true;
        QL_REQUIRE(times.size() == vols.size() - 1,
                   "number of volatilities ("
                       << vols.size() << ") compared to number of times ("
                       << times_.size() << " must be bigger by one");
        for (int i = 0; i < ((int)times.size()) - 1; i++)
            QL_REQUIRE(times[i] < times[i + 1], "times must be increasing ("
                                                    << times[i] << "@" << i
                                                    << " , " << times[i + 1]
                                                    << "@" << i + 1 << ")");
        for (Size i = 0; i < vols.size(); i++)
            QL_REQUIRE(vols[i] >= 0.0, "volatilities must be non negative ("
                                           << vols[i] << "@" << i << ")");
    }

    Real MfStateProcess::x0() const { return 0.0; }

    Real MfStateProcess::drift(Time, Real) const { return 0.0; }

    Real MfStateProcess::diffusion(Time t, Real) const {
        Size i =
            std::upper_bound(times_.begin(), times_.end(), t) - times_.begin();
        return vols_[i];
    }

    Real MfStateProcess::expectation(Time, Real x0, Time dt) const {
        return x0;
    }

    Real MfStateProcess::stdDeviation(Time t, Real x0, Time dt) const {
        return std::sqrt(variance(t, x0, dt));
    }

    Real MfStateProcess::variance(Time t, Real, Time dt) const {

        if (dt < QL_EPSILON)
            return 0.0;
        if (times_.empty())
            return reversionZero_ ? dt
                                  : 1.0 / (2.0 * reversion_) *
                                        (std::exp(2.0 * reversion_ * (t + dt)) -
                                         std::exp(2.0 * reversion_ * t));

        Size i =
            std::upper_bound(times_.begin(), times_.end(), t) - times_.begin();
        Size j = std::upper_bound(times_.begin(), times_.end(), t + dt) -
                 times_.begin();

        Real v = 0.0;

        for (Size k = i; k < j; k++) {
            if (reversionZero_)
                v += vols_[k] * vols_[k] *
                     (times_[k] - std::max(k > 0 ? times_[k - 1] : 0.0, t));
            else
                v += 1.0 / (2.0 * reversion_) * vols_[k] * vols_[k] *
                     (std::exp(2.0 * reversion_ * times_[k]) -
                      std::exp(2.0 * reversion_ *
                               std::max(k > 0 ? times_[k - 1] : 0.0, t)));
        }

        if (reversionZero_)
            v += vols_[j] * vols_[j] *
                 (t + dt - std::max(j > 0 ? times_[j - 1] : 0.0, t));
        else
            v += 1.0 / (2.0 * reversion_) * vols_[j] * vols_[j] *
                 (std::exp(2.0 * reversion_ * (t + dt)) -
                  std::exp(2.0 * reversion_ *
                           (std::max(j > 0 ? times_[j - 1] : 0.0, t))));

        return v;
    }
}
]]></document_content>
  </document>
  <document index="18">
    <source>ornsteinuhlenbeckprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2004, 2005, 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/processes/ornsteinuhlenbeckprocess.hpp>

namespace QuantLib {

    OrnsteinUhlenbeckProcess::OrnsteinUhlenbeckProcess(Real speed,
                                                       Volatility vol,
                                                       Real x0,
                                                       Real level)
    : x0_(x0), speed_(speed), level_(level), volatility_(vol) {
        QL_REQUIRE(volatility_ >= 0.0, "negative volatility given");
    }

    Real OrnsteinUhlenbeckProcess::variance(Time, Real, Time dt) const {
        if (std::fabs(speed_) < std::sqrt(QL_EPSILON)) {
             // algebraic limit for small speed
            return volatility_*volatility_*dt;
        } else {
            return 0.5*volatility_*volatility_/speed_*
                (1.0 - std::exp(-2.0*speed_*dt));
        }
    }

}

]]></document_content>
  </document>
  <document index="19">
    <source>squarerootprocess.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2004, 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/processes/squarerootprocess.hpp>

namespace QuantLib {

    SquareRootProcess::SquareRootProcess(
             Real b, Real a, Volatility sigma, Real x0,
             const ext::shared_ptr<discretization>& disc)
    : StochasticProcess1D(disc), x0_(x0), mean_(b), speed_(a),
      volatility_(sigma) {}

    Real SquareRootProcess::x0() const {
        return x0_;
    }

    Real SquareRootProcess::drift(Time, Real x) const {
        return speed_*(mean_ - x);
    }

    Real SquareRootProcess::diffusion(Time, Real x) const {
        return volatility_*std::sqrt(x);
    }

}
]]></document_content>
  </document>
  <document index="20">
    <source>stochasticprocessarray.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Klaus Spanderen
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/processes/stochasticprocessarray.hpp>
#include <ql/math/matrixutilities/pseudosqrt.hpp>
#include <ql/math/functional.hpp>

namespace QuantLib {

    StochasticProcessArray::StochasticProcessArray(
        const std::vector<ext::shared_ptr<StochasticProcess1D> >& processes,
        const Matrix& correlation)
    : processes_(processes),
      sqrtCorrelation_(pseudoSqrt(correlation,SalvagingAlgorithm::Spectral)) {

        QL_REQUIRE(!processes.empty(), "no processes given");
        QL_REQUIRE(correlation.rows() == processes.size(),
                   "mismatch between number of processes "
                   "and size of correlation matrix");
        for (auto& processe : processes_)
            registerWith(processe);
    }

    Size StochasticProcessArray::size() const {
        return processes_.size();
    }

    Disposable<Array> StochasticProcessArray::initialValues() const {
        Array tmp(size());
        for (Size i=0; i<size(); ++i)
            tmp[i] = processes_[i]->x0();
        return tmp;
    }

    Disposable<Array> StochasticProcessArray::drift(Time t,
                                                    const Array& x) const {
        Array tmp(size());
        for (Size i=0; i<size(); ++i)
            tmp[i] = processes_[i]->drift(t, x[i]);
        return tmp;
    }

    Disposable<Matrix> StochasticProcessArray::diffusion(
                                               Time t, const Array& x) const {
        Matrix tmp = sqrtCorrelation_;
        for (Size i=0; i<size(); ++i) {
            Real sigma = processes_[i]->diffusion(t, x[i]);
            std::transform(tmp.row_begin(i), tmp.row_end(i),
                           tmp.row_begin(i),
                           multiply_by<Real>(sigma));
        }
        return tmp;
    }

    Disposable<Array> StochasticProcessArray::expectation(Time t0,
                                                          const Array& x0,
                                                          Time dt) const {
        Array tmp(size());
        for (Size i=0; i<size(); ++i)
            tmp[i] = processes_[i]->expectation(t0, x0[i], dt);
        return tmp;
    }

    Disposable<Matrix> StochasticProcessArray::stdDeviation(Time t0,
                                                            const Array& x0,
                                                            Time dt) const {
        Matrix tmp = sqrtCorrelation_;
        for (Size i=0; i<size(); ++i) {
            Real sigma = processes_[i]->stdDeviation(t0, x0[i], dt);
            std::transform(tmp.row_begin(i), tmp.row_end(i),
                           tmp.row_begin(i),
                           multiply_by<Real>(sigma));
        }
        return tmp;
    }

    Disposable<Matrix> StochasticProcessArray::covariance(Time t0,
                                                          const Array& x0,
                                                          Time dt) const {
        Matrix tmp = stdDeviation(t0, x0, dt);
        return tmp*transpose(tmp);
    }

    Disposable<Array> StochasticProcessArray::evolve(
                  Time t0, const Array& x0, Time dt, const Array& dw) const {
        const Array dz = sqrtCorrelation_ * dw;

        Array tmp(size());
        for (Size i=0; i<size(); ++i)
            tmp[i] = processes_[i]->evolve(t0, x0[i], dt, dz[i]);
        return tmp;
    }

    Disposable<Array> StochasticProcessArray::apply(const Array& x0,
                                                    const Array& dx) const {
        Array tmp(size());
        for (Size i=0; i<size(); ++i)
            tmp[i] = processes_[i]->apply(x0[i],dx[i]);
        return tmp;
    }

    Time StochasticProcessArray::time(const Date& d) const {
        return processes_[0]->time(d);
    }

    const ext::shared_ptr<StochasticProcess1D>&
    StochasticProcessArray::process(Size i) const {
        return processes_[i];
    }

    Disposable<Matrix> StochasticProcessArray::correlation() const {
        return sqrtCorrelation_ * transpose(sqrtCorrelation_);
    }

}
]]></document_content>
  </document>
</documents>