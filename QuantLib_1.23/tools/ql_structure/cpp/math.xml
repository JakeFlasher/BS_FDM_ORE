<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>abcdmathfunction.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007, 2015 Ferdinando Ametrano
 Copyright (C) 2006 Cristina Duminuco
 Copyright (C) 2005, 2006 Klaus Spanderen
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2015 Paolo Mazzocchi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/abcdmathfunction.hpp>
#include <utility>

namespace QuantLib {

    void AbcdMathFunction::validate(Real a,
                                    Real b,
                                    Real c,
                                    Real d) {
        QL_REQUIRE(c>0, "c (" << c << ") must be positive");
        QL_REQUIRE(d>=0, "d (" << d << ") must be non negative");
        QL_REQUIRE(a+d>=0,
                   "a+d (" << a << "+" << d << ") must be non negative");

        if (b>=0.0)
            return;

        // the one and only stationary point...
        Time zeroFirstDerivative = 1.0/c-a/b;
        if (zeroFirstDerivative>=0.0) {
            // ... is a minimum
            // must be abcd(zeroFirstDerivative)>=0
            QL_REQUIRE(b>=-(d*c)/std::exp(c*a/b-1.0),
                       "b (" << b << ") less than " <<
                       -(d*c)/std::exp(c*a/b-1.0) << ": negative function"
                       " value at stationary point " << zeroFirstDerivative);
        }

    }

    void AbcdMathFunction::initialize_() {
        validate(a_, b_, c_, d_);
        da_ = b_ - c_*a_;
        db_ = -c_*b_;
        dabcd_[0]=da_;
        dabcd_[1]=db_;
        dabcd_[2]=c_;
        dabcd_[3]=0.0;

        pa_ = -(a_ + b_/c_)/c_;
        pb_ = -b_/c_;
        K_ = 0.0;

        dibc_ = b_/c_;
        diacplusbcc_ = a_/c_ + dibc_/c_;
    }

    AbcdMathFunction::AbcdMathFunction(Real aa, Real bb, Real cc, Real dd)
    : a_(aa), b_(bb), c_(cc), d_(dd), abcd_(4), dabcd_(4) {
        abcd_[0]=a_;
        abcd_[1]=b_;
        abcd_[2]=c_;
        abcd_[3]=d_;
        initialize_();
    }

    AbcdMathFunction::AbcdMathFunction(std::vector<Real> abcd) : abcd_(std::move(abcd)), dabcd_(4) {
        a_=abcd_[0];
        b_=abcd_[1];
        c_=abcd_[2];
        d_=abcd_[3];
        initialize_();
    }

    Time AbcdMathFunction::maximumLocation() const {
        if (b_==0.0) {
            if (a_>=0.0)
                return 0.0;
            else
                return QL_MAX_REAL;
        }

        // stationary point
        // TODO check if minimum
        // TODO check if maximum at +inf
        Real zeroFirstDerivative = 1.0/c_-a_/b_;
        return (zeroFirstDerivative>0.0 ? zeroFirstDerivative : 0.0);
    }

    Real AbcdMathFunction::definiteIntegral(Time t1,
                                            Time t2) const {
        return primitive(t2)-primitive(t1);
    }

    std::vector<Real>
    AbcdMathFunction::definiteIntegralCoefficients(Time t,
                                                   Time t2) const {
        Time dt = t2 - t;
        Real expcdt = std::exp(-c_*dt);
        std::vector<Real> result(4);
        result[0] = diacplusbcc_ - (diacplusbcc_ + dibc_*dt)*expcdt;
        result[1] = dibc_ * (1.0 - expcdt);
        result[2] = c_;
        result[3] = d_*dt;
        return result;
    }

    std::vector<Real>
    AbcdMathFunction::definiteDerivativeCoefficients(Time t,
                                                     Time t2) const {
        Time dt = t2 - t;
        Real expcdt = std::exp(-c_*dt);
        std::vector<Real> result(4);
        result[1] = b_*c_/(1.0-expcdt);
        result[0] = a_*c_ - b_ + result[1]*dt*expcdt;
        result[0] /= 1.0-expcdt;
        result[2] = c_;
        result[3] = d_/dt;
        return result;
    }

}
]]></document_content>
  </document>
  <document index="2">
    <source>bernsteinpolynomial.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/bernsteinpolynomial.hpp>
#include <ql/math/factorial.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    Real BernsteinPolynomial::get(Natural i,
                                  Natural n,
                                  Real x) {

        Real coeff = Factorial::get(n) /
            (Factorial::get(n-i) * Factorial::get(i));

        return coeff * std::pow(x,int(i)) * std::pow(1.0-x, int(n-i));
    }

}

]]></document_content>
  </document>
  <document index="3">
    <source>beta.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/beta.hpp>

namespace QuantLib {

    /*
      The implementation of the algorithm was inspired by
      "Numerical Recipes in C", 2nd edition,
      Press, Teukolsky, Vetterling, Flannery, chapter 6
    */
    Real betaContinuedFraction(Real a, Real  b, Real  x,
                               Real accuracy, Integer maxIteration) {

        Real aa, del;
        Real qab = a+b;
        Real qap = a+1.0;
        Real qam = a-1.0;
        Real c = 1.0;
        Real d = 1.0-qab*x/qap;
        if (std::fabs(d) < QL_EPSILON)
            d = QL_EPSILON;
        d = 1.0/d;
        Real result = d;

        Integer m, m2;
        for (m=1; m<=maxIteration; m++) {
            m2=2*m;
            aa=m*(b-m)*x/((qam+m2)*(a+m2));
            d=1.0+aa*d;
            if (std::fabs(d) < QL_EPSILON) d=QL_EPSILON;
            c=1.0+aa/c;
            if (std::fabs(c) < QL_EPSILON) c=QL_EPSILON;
            d=1.0/d;
            result *= d*c;
            aa = -(a+m)*(qab+m)*x/((a+m2)*(qap+m2));
            d=1.0+aa*d;
            if (std::fabs(d) < QL_EPSILON) d=QL_EPSILON;
            c=1.0+aa/c;
            if (std::fabs(c) < QL_EPSILON) c=QL_EPSILON;
            d=1.0/d;
            del=d*c;
            result *= del;
            if (std::fabs(del-1.0) < accuracy)
                return result;
        }
        QL_FAIL("a or b too big, or maxIteration too small in betacf");
    }

    Real incompleteBetaFunction(Real a, Real b,
                                Real x, Real accuracy,
                                Integer maxIteration) {

    QL_REQUIRE(a > 0.0, "a must be greater than zero");
    QL_REQUIRE(b > 0.0, "b must be greater than zero");


    if (x == 0.0)
        return 0.0;
    else if (x == 1.0)
        return 1.0;
    else
        QL_REQUIRE(x>0.0 && x<1.0, "x must be in [0,1]");

    Real result = std::exp(GammaFunction().logValue(a+b) -
        GammaFunction().logValue(a) - GammaFunction().logValue(b) +
        a*std::log(x) + b*std::log(1.0-x));

    if (x < (a+1.0)/(a+b+2.0))
        return result *
            betaContinuedFraction(a, b, x, accuracy, maxIteration)/a;
    else
        return 1.0 - result *
            betaContinuedFraction(b, a, 1.0-x, accuracy, maxIteration)/b;
    }

}
]]></document_content>
  </document>
  <document index="4">
    <source>bspline.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/bspline.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    BSpline::BSpline(Natural p,
                     Natural n,
                     const std::vector<Real>& knots)
    : p_(p), n_(n), knots_(knots) {

        QL_REQUIRE(p >= 1, "lowest degree B-spline has p = 1");
        QL_REQUIRE(n >= 1, "number of control points n+1 >= 2");
        QL_REQUIRE(p <= n, "must have p <= n");

        QL_REQUIRE(knots.size() == p+n+2,"number of knots must equal p+n+2");

        for (Size i=0; i<knots.size()-1; ++i) {
            QL_REQUIRE(knots[i] <= knots[i+1],
                       "knots points must be nondecreasing");
        }
    }


    Real BSpline::operator()(Natural i, Real x) const {
        QL_REQUIRE(i <= n_, "i must not be greater than n");
        return N(i,p_,x);
    }


    Real BSpline::N(Natural i, Natural p, Real x) const {

        if (p==0) {
            return (knots_[i] <= x && x < knots_[i+1]) ? 1.0 : 0.0;
        } else {
            return ((x - knots_[i])/(knots_[i+p] - knots_[i]))*N(i,p-1,x) +
                ((knots_[i+p+1]-x)/(knots_[i+p+1]-knots_[i+1]))* N(i+1,p-1,x);
        }
    }

}

]]></document_content>
  </document>
  <document index="5">
    <source>copulas/alimikhailhaqcopula.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Hachemi Benyahia
 Copyright (C) 2010 DeriveXperts SAS

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/copulas/alimikhailhaqcopula.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    AliMikhailHaqCopula::AliMikhailHaqCopula(Real theta) : theta_(theta)
    {
        QL_REQUIRE(theta >= -1.0 && theta <= 1.0 ,
                   "theta (" << theta << ") must be in [-1,1]");
    }

    Real AliMikhailHaqCopula::operator()(Real x, Real y) const
    {
        QL_REQUIRE(x >= 0.0 && x <=1.0 ,
                   "1st argument (" << x << ") must be in [0,1]");
        QL_REQUIRE(y >= 0.0 && y <=1.0 ,
                   "2nd argument (" << y << ") must be in [0,1]");
        return (x*y)/(1.0-theta_*(1.0-x)*(1.0-y));
    }

}
]]></document_content>
  </document>
  <document index="6">
    <source>copulas/claytoncopula.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Marek Glowacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/copulas/claytoncopula.hpp>
#include <ql/errors.hpp>
#include <algorithm>

using std::max;
using std::pow;

namespace QuantLib {

    ClaytonCopula::ClaytonCopula(Real theta): theta_(theta)
    {
        QL_REQUIRE(theta >= -1.0,
                   "theta (" << theta << ") must be greater or equal to -1");
        QL_REQUIRE(theta != 0.0,
                   "theta (" << theta << ") must be different from 0");
    }
    
    Real ClaytonCopula::operator()(Real x, Real y) const 
    {
        QL_REQUIRE(x >= 0.0 && x <=1.0 ,
                   "1st argument (" << x << ") must be in [0,1]");
        QL_REQUIRE(y >= 0.0 && y <=1.0 ,
                   "2nd argument (" << y << ") must be in [0,1]");
        using namespace std;
        return max( pow( pow(x,-theta_)+pow(y,-theta_)-1.0  , -1.0/theta_) , 0.0);
    }

}
]]></document_content>
  </document>
  <document index="7">
    <source>copulas/farliegumbelmorgensterncopula.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Marek Glowacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/copulas/farliegumbelmorgensterncopula.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    FarlieGumbelMorgensternCopula::FarlieGumbelMorgensternCopula(Real theta): theta_(theta)
    {
        QL_REQUIRE(theta >= -1.0 && theta <= 1.00,
                   "theta (" << theta << ") must be in [-1,1]");
    }
    
    Real FarlieGumbelMorgensternCopula::operator()(Real x, Real y) const 
    {
        QL_REQUIRE(x >= 0.0 && x <=1.0 ,
                   "1st argument (" << x << ") must be in [0,1]");
        QL_REQUIRE(y >= 0.0 && y <=1.0 ,
                   "2nd argument (" << y << ") must be in [0,1]");
        return x*y + theta_*x*y*(1.0 - x)*(1.0 - y);
    }

}
]]></document_content>
  </document>
  <document index="8">
    <source>copulas/frankcopula.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Marek Glowacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/copulas/frankcopula.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    FrankCopula::FrankCopula(Real theta): theta_(theta)
    {
        QL_REQUIRE(theta != 0.0,
                   "theta (" << theta << ") must be different from 0");
    }
    
    Real FrankCopula::operator()(Real x, Real y) const 
    {
        QL_REQUIRE(x >= 0.0 && x <=1.0 ,
                   "1st argument (" << x << ") must be in [0,1]");
        QL_REQUIRE(y >= 0.0 && y <=1.0 ,
                   "2nd argument (" << y << ") must be in [0,1]");
        using namespace std;
        return -1.0/theta_  *  log(1 + (exp(-theta_*x) -1) * (exp(-theta_*y) -1) / (exp(-theta_)- 1)   );
    }

}
]]></document_content>
  </document>
  <document index="9">
    <source>copulas/galamboscopula.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Hachemi Benyahia
 Copyright (C) 2010 DeriveXperts SAS

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/copulas/galamboscopula.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    GalambosCopula::GalambosCopula(Real theta) : theta_(theta)
    {
        QL_REQUIRE(theta >= 0.0,
                   "theta (" << theta << ") must be greater or equal to 0");
    }

    Real GalambosCopula::operator()(Real x, Real y) const
    {
        QL_REQUIRE(x >= 0.0 && x <=1.0 ,
                   "1st argument (" << x << ") must be in [0,1]");
        QL_REQUIRE(y >= 0.0 && y <=1.0 ,
                   "2nd argument (" << y << ") must be in [0,1]");
        using namespace std;
        return x*y*exp(pow(pow(-log(x),-theta_)+pow(-log(y),-theta_),-1/theta_));
    }

}
]]></document_content>
  </document>
  <document index="10">
    <source>copulas/gaussiancopula.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Marek Glowacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/copulas/gaussiancopula.hpp>

namespace QuantLib {

    GaussianCopula::GaussianCopula(Real rho)
    : rho_(rho), bivariate_normal_cdf_(rho_)
    {
        QL_REQUIRE(rho>=-1.0 && rho<= 1.00,
                   "rho (" << rho << ") must be in [-1,1]");
    }
    
    Real GaussianCopula::operator()(Real x, Real y) const 
    {
        QL_REQUIRE(x >= 0.0 && x <=1.0 ,
                   "1st argument (" << x << ") must be in [0,1]");
        QL_REQUIRE(y >= 0.0 && y <=1.0 ,
                   "2nd argument (" << y << ") must be in [0,1]");
        return bivariate_normal_cdf_(invCumNormal_(x), invCumNormal_(y));
    }

}
]]></document_content>
  </document>
  <document index="11">
    <source>copulas/gumbelcopula.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Marek Glowacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/copulas/gumbelcopula.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    GumbelCopula::GumbelCopula(Real theta) : theta_(theta)
    {
        QL_REQUIRE(theta >= 1.0,
                   "theta (" << theta << ") must be greater or equal to 1");
    }
    
    Real GumbelCopula::operator()(Real x, Real y) const 
    {
        QL_REQUIRE(x >= 0.0 && x <=1.0 ,
                   "1st argument (" << x << ") must be in [0,1]");
        QL_REQUIRE(y >= 0.0 && y <=1.0 ,
                   "2nd argument (" << y << ") must be in [0,1]");
        using namespace std;
        return exp(-pow( pow( -log(x), theta_)+pow( -log(y), theta_),1/theta_));
    }

}
]]></document_content>
  </document>
  <document index="12">
    <source>copulas/huslerreisscopula.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Hachemi Benyahia
 Copyright (C) 2010 DeriveXperts SAS

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/copulas/huslerreisscopula.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    HuslerReissCopula::HuslerReissCopula(Real theta)
    : theta_(theta)
    {
        QL_REQUIRE(theta >= 0.0,
                   "theta (" << theta << ") must be greater or equal to 0");
    }

    Real HuslerReissCopula::operator()(Real x, Real y) const
    {
        QL_REQUIRE(x >= 0.0 && x <=1.0 ,
                   "1st argument (" << x << ") must be in [0,1]");
        QL_REQUIRE(y >= 0.0 && y <=1.0 ,
                   "2nd argument (" << y << ") must be in [0,1]");
        using namespace std;
        return pow(x,cumNormal_(1.0/theta_+0.5*theta_*log(-log(x)/-log(y))))*pow(y,cumNormal_(1.0/theta_+0.5*theta_*log(-log(y)/-log(x))));
    }

}
]]></document_content>
  </document>
  <document index="13">
    <source>copulas/independentcopula.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Marek Glowacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/copulas/independentcopula.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    Real IndependentCopula::operator()(Real x, Real y) const 
    {
        QL_REQUIRE(x >= 0.0 && x <=1.0 ,
                   "1st argument (" << x << ") must be in [0,1]");
        QL_REQUIRE(y >= 0.0 && y <=1.0 ,
                   "2nd argument (" << y << ") must be in [0,1]");
        return x*y;
    }

}
]]></document_content>
  </document>
  <document index="14">
    <source>copulas/marshallolkincopula.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Marek Glowacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/copulas/marshallolkincopula.hpp>
#include <ql/errors.hpp>
#include <algorithm>

namespace QuantLib {

    MarshallOlkinCopula::MarshallOlkinCopula(Real a1,Real a2)
    : a1_(1.0-a1), a2_(1.0-a2)
    {
        QL_REQUIRE(a1 >= 0.0,
                   "1st parameter (" << a1 << ") must be non-negative");
        QL_REQUIRE(a2 >= 0.0,
                   "2nd parameter (" << a2 << ") must be non-negative");
    }
    
    Real MarshallOlkinCopula::operator()(Real x, Real y) const 
    {
        QL_REQUIRE(x >= 0.0 && x <=1.0 ,
                   "1st argument (" << x << ") must be in [0,1]");
        QL_REQUIRE(y >= 0.0 && y <=1.0 ,
                   "2nd argument (" << y << ") must be in [0,1]");
        return std::min(  y*std::pow(x, a1_)  ,  x*std::pow(y, a2_)  );
    }

}
]]></document_content>
  </document>
  <document index="15">
    <source>copulas/maxcopula.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Marek Glowacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/copulas/maxcopula.hpp>
#include <ql/errors.hpp>
#include <algorithm>

namespace QuantLib {

    Real MaxCopula::operator()(Real x, Real y) const 
    {
        QL_REQUIRE(x >= 0.0 && x <=1.0 ,
                   "1st argument (" << x << ") must be in [0,1]");
        QL_REQUIRE(y >= 0.0 && y <=1.0 ,
                   "2nd argument (" << y << ") must be in [0,1]");
        return std::min(x, y);
    }

}
]]></document_content>
  </document>
  <document index="16">
    <source>copulas/mincopula.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Marek Glowacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/copulas/mincopula.hpp>
#include <ql/errors.hpp>
#include <algorithm>

namespace QuantLib {

    Real MinCopula::operator()(Real x, Real y) const 
    {
        QL_REQUIRE(x >= 0.0 && x <=1.0 ,
                   "1st argument (" << x << ") must be in [0,1]");
        QL_REQUIRE(y >= 0.0 && y <=1.0 ,
                   "2nd argument (" << y << ") must be in [0,1]");
        return std::max(x+y-1.0, 0.0);
    }

}
]]></document_content>
  </document>
  <document index="17">
    <source>copulas/plackettcopula.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Hachemi Benyahia
 Copyright (C) 2010 DeriveXperts SAS

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/copulas/plackettcopula.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    PlackettCopula::PlackettCopula(Real theta) : theta_(theta)
    {
        QL_REQUIRE(theta >= 0.0,
                   "theta (" << theta << ") must be greater or equal to 0");
        QL_REQUIRE(theta != 1.0,
                   "theta (" << theta << ") must be different from 1");
    }

    Real PlackettCopula::operator()(Real x, Real y) const
    {
        QL_REQUIRE(x >= 0.0 && x <=1.0 ,
                   "1st argument (" << x << ") must be in [0,1]");
        QL_REQUIRE(y >= 0.0 && y <=1.0 ,
                   "2nd argument (" << y << ") must be in [0,1]");
        using namespace std;
        return ((1.0+(theta_-1.0)*(x+y))-sqrt(std::pow(1.0+(theta_-1.0)*(x+y),2.0)-4.0*x*y*theta_*(theta_-1.0)))/(2.0*(theta_-1.0));
    }

}
]]></document_content>
  </document>
  <document index="18">
    <source>distributions/bivariatenormaldistribution.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003 StatPro Italia srl
 Copyright (C) 2005 Gary Kennedy

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/distributions/bivariatenormaldistribution.hpp>
#include <ql/math/integrals/gaussianquadratures.hpp>

namespace QuantLib {

    // Drezner 1978

    const Real BivariateCumulativeNormalDistributionDr78::x_[] = {
        0.24840615,
        0.39233107,
        0.21141819,
        0.03324666,
        0.00082485334
    };

    const Real BivariateCumulativeNormalDistributionDr78::y_[] = {
        0.10024215,
        0.48281397,
        1.06094980,
        1.77972940,
        2.66976040000
    };

    BivariateCumulativeNormalDistributionDr78::
    BivariateCumulativeNormalDistributionDr78(Real rho)
    : rho_(rho), rho2_(rho*rho) {

        QL_REQUIRE(rho>=-1.0,
                   "rho must be >= -1.0 (" << rho << " not allowed)");
        QL_REQUIRE(rho<=1.0,
                   "rho must be <= 1.0 (" << rho << " not allowed)");
    }

    Real BivariateCumulativeNormalDistributionDr78::operator()(Real a,
                                                               Real b) const {

        CumulativeNormalDistribution cumNormalDist;
        Real CumNormDistA = cumNormalDist(a);
        Real CumNormDistB = cumNormalDist(b);
        Real MaxCumNormDistAB = std::max(CumNormDistA, CumNormDistB);
        Real MinCumNormDistAB = std::min(CumNormDistA, CumNormDistB);

        if (1.0-MaxCumNormDistAB<1e-15)
            return MinCumNormDistAB;

        if (MinCumNormDistAB<1e-15)
            return MinCumNormDistAB;

        Real a1 = a / std::sqrt(2.0 * (1.0 - rho2_));
        Real b1 = b / std::sqrt(2.0 * (1.0 - rho2_));

        Real result=-1.0;

        if (a<=0.0 && b<=0 && rho_<=0) {
            Real sum=0.0;
            for (Size i=0; i<5; i++) {
                for (Size j=0;j<5; j++) {
                    sum += x_[i]*x_[j]*
                        std::exp(a1*(2.0*y_[i]-a1)+b1*(2.0*y_[j]-b1)
                                 +2.0*rho_*(y_[i]-a1)*(y_[j]-b1));
                }
            }
            result = std::sqrt(1.0 - rho2_)/M_PI*sum;
        } else if (a<=0 && b>=0 && rho_>=0) {
            BivariateCumulativeNormalDistributionDr78 bivCumNormalDist(-rho_);
            result= CumNormDistA - bivCumNormalDist(a, -b);
        } else if (a>=0.0 && b<=0.0 && rho_>=0.0) {
            BivariateCumulativeNormalDistributionDr78 bivCumNormalDist(-rho_);
            result= CumNormDistB - bivCumNormalDist(-a, b);
        } else if (a>=0.0 && b>=0.0 && rho_<=0.0) {
            result= CumNormDistA + CumNormDistB -1.0 + (*this)(-a, -b);
        } else if (a*b*rho_>0.0) {
            Real rho1 = (rho_*a-b)*(a>0.0 ? 1.0: -1.0)/
                std::sqrt(a*a-2.0*rho_*a*b+b*b);
            BivariateCumulativeNormalDistributionDr78 bivCumNormalDist(rho1);

            Real rho2 = (rho_*b-a)*(b>0.0 ? 1.0: -1.0)/
                std::sqrt(a*a-2.0*rho_*a*b+b*b);
            BivariateCumulativeNormalDistributionDr78 CBND2(rho2);

            Real delta = (1.0-(a>0.0 ? 1.0: -1.0)*(b>0.0 ? 1.0: -1.0))/4.0;

            result= bivCumNormalDist(a, 0.0) + CBND2(b, 0.0) - delta;
        } else {
            QL_FAIL("case not handled");
        }

        return result;
    }


    // West 2004

    namespace {

        class eqn3 { /* Relates to eqn3 Genz 2004 */
          public:
            eqn3(Real h, Real k, Real asr)
            : hk_(h * k), asr_(asr), hs_((h * h + k * k) / 2) {}

            Real operator()(Real x) const {
                Real sn = std::sin(asr_ * (-x + 1) * 0.5);
                return std::exp((sn * hk_ - hs_) / (1.0 - sn * sn));
            }
          private:
            Real hk_, asr_, hs_;
        };

        class eqn6 { /* Relates to eqn6 Genz 2004 */
          public:
            eqn6(Real a, Real c, Real d, Real bs, Real hk)
            : a_(a), c_(c), d_(d), bs_(bs), hk_(hk) {}
            Real operator()(Real x) const {
                Real xs = a_ * (-x + 1);
                xs = std::fabs(xs*xs);
                Real rs = std::sqrt(1 - xs);
                Real asr = -(bs_ / xs + hk_) / 2;
                if (asr > -100.0) {
                    return (a_ * std::exp(asr) *
                            (std::exp(-hk_ * (1 - rs) / (2 * (1 + rs))) / rs -
                             (1 + c_ * xs * (1 + d_ * xs))));
                } else {
                    return 0.0;
                }
            }
          private:
            Real a_, c_, d_, bs_, hk_;
        };

    }

    BivariateCumulativeNormalDistributionWe04DP::
    BivariateCumulativeNormalDistributionWe04DP(Real rho)
    : correlation_(rho) {

        QL_REQUIRE(rho>=-1.0,
                   "rho must be >= -1.0 (" << rho << " not allowed)");
        QL_REQUIRE(rho<=1.0,
                   "rho must be <= 1.0 (" << rho << " not allowed)");
    }


    Real BivariateCumulativeNormalDistributionWe04DP::operator()(
                                                       Real x, Real y) const {

        /* The implementation is described at section 2.4 "Hybrid
           Numerical Integration Algorithms" of "Numerical Computation
           of Rectangular Bivariate an Trivariate Normal and t
           Probabilities", Genz (2004), Statistics and Computing 14,
           151-160. (available at
           www.sci.wsu.edu/math/faculty/henz/homepage)

           The Gauss-Legendre quadrature have been extracted to
           TabulatedGaussLegendre (x,w zero-based)

           Tthe functions ot be integrated numerically have been moved
           to classes eqn3 and eqn6

           Change some magic numbers to M_PI */

        TabulatedGaussLegendre gaussLegendreQuad(20);
        if (std::fabs(correlation_) < 0.3) {
            gaussLegendreQuad.order(6);
        } else if (std::fabs(correlation_) < 0.75) {
            gaussLegendreQuad.order(12);
        }

        Real h = -x;
        Real k = -y;
        Real hk = h * k;
        Real BVN = 0.0;

        if (std::fabs(correlation_) < 0.925)
        {
            if (std::fabs(correlation_) > 0)
            {
                Real asr = std::asin(correlation_);
                eqn3 f(h,k,asr);
                BVN = gaussLegendreQuad(f);
                BVN *= asr * (0.25 / M_PI);
            }
            BVN += cumnorm_(-h) * cumnorm_(-k);
        }
        else
        {
            if (correlation_ < 0)
            {
                k *= -1;
                hk *= -1;
            }
            if (std::fabs(correlation_) < 1)
            {
                Real Ass = (1 - correlation_) * (1 + correlation_);
                Real a = std::sqrt(Ass);
                Real bs = (h-k)*(h-k);
                Real c = (4 - hk) / 8;
                Real d = (12 - hk) / 16;
                Real asr = -(bs / Ass + hk) / 2;
                if (asr > -100)
                {
                    BVN = a * std::exp(asr) *
                        (1 - c * (bs - Ass) * (1 - d * bs / 5) / 3 +
                         c * d * Ass * Ass / 5);
                }
                if (-hk < 100)
                {
                    Real B = std::sqrt(bs);
                    BVN -= std::exp(-hk / 2) * 2.506628274631 *
                        cumnorm_(-B / a) * B *
                        (1 - c * bs * (1 - d * bs / 5) / 3);
                }
                a /= 2;
                eqn6 f(a,c,d,bs,hk);
                BVN += gaussLegendreQuad(f);
                BVN /= (-2.0 * M_PI);
            }

            if (correlation_ > 0) {
                BVN += cumnorm_(-std::max(h, k));
            } else {
                BVN *= -1;
                if (k > h) {
                    // evaluate cumnorm where it is most precise, that
                    // is in the lower tail because of double accuracy
                    // around 0.0 vs around 1.0
                    if (h >= 0) {
                        BVN += cumnorm_(-h) - cumnorm_(-k);
                    } else {
                        BVN += cumnorm_(k) - cumnorm_(h);
                    }
                }
            }
        }
        return BVN;
    }

}
]]></document_content>
  </document>
  <document index="19">
    <source>distributions/bivariatestudenttdistribution.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Michal Kaut

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/distributions/bivariatestudenttdistribution.hpp>

namespace QuantLib {

    namespace {

        Real epsilon = 1.0e-8;

        Real sign(Real val) {
            return val == 0.0 ? 0.0
                : (val < 0.0 ? -1.0 : 1.0);
        }

        /* unlike the atan2 function in C++ that gives results in
           [-pi,pi], this returns a value in [0, 2*pi]
        */
        Real arctan(Real x, Real y) {
            Real res = std::atan2(x, y);
            return res >= 0.0 ? res : res + 2 * M_PI;
        }

        // function x(m,h,k) defined on top of page 155
        Real f_x(Real m, Real h, Real k, Real rho) {
            Real unCor = 1 - rho*rho;
            Real sub = std::pow(h - rho * k, 2);
            Real denom = sub + unCor * (m + k*k);
            if (denom < epsilon)
                return 0.0; // limit case for rho = +/-1.0
            return sub / (sub + unCor * (m + k*k));
        }

        // this calculates the cdf
        Real P_n(Real h, Real k, Natural n, Real rho) {
            Real unCor = 1.0 - rho*rho;

            Real div = 4 * std::sqrt(n * M_PI);
            Real xHK = f_x(n, h, k, rho);
            Real xKH = f_x(n, k, h, rho);
            Real divH = 1 + h*h / n;
            Real divK = 1 + k*k / n;
            Real sgnHK = sign(h - rho * k);
            Real sgnKH = sign(k - rho * h);

            if (n % 2 == 0) { // n is even, equation (10)
                // first line of (10)
                Real res = arctan(std::sqrt(unCor), -rho) / M_TWOPI;

                // second line of (10)
                Real dgM = 2 * (1 - xHK);  // multiplier for dgj
                Real gjM = sgnHK * 2 / M_PI; // multiplier for g_j
                // initializations for j = 1:
                Real f_j = std::sqrt(M_PI / divK);
                Real g_j = 1 + gjM * arctan(std::sqrt(xHK), std::sqrt(1 - xHK));
                Real sum = f_j * g_j;
                if (n >= 4) {
                    // different formulas for j = 2:
                    f_j *= 0.5 / divK; // (2 - 1.5) / (Real) (2 - 1) / divK;
                    Real dgj = gjM * std::sqrt(xHK * (1 - xHK));
                    g_j += dgj;
                    sum += f_j * g_j;
                    // and then the loop for the rest of the j's:
                    for (Natural j = 3; j <= n / 2; ++j) {
                        f_j *= (j - 1.5) / (Real) (j - 1) / divK;
                        dgj *= (Real) (j - 2) / (2 * j - 3) * dgM;
                        g_j += dgj;
                        sum += f_j * g_j;
                    }
                }
                res += k / div * sum;

                // third line of (10)
                dgM = 2 * (1 - xKH);
                gjM = sgnKH * 2 / M_PI;
                // initializations for j = 1:
                f_j = std::sqrt(M_PI / divH);
                g_j = 1 + gjM * arctan(std::sqrt(xKH), std::sqrt(1 - xKH));
                sum = f_j * g_j;
                if (n >= 4) {
                    // different formulas for j = 2:
                    f_j *= 0.5 / divH; // (2 - 1.5) / (Real) (2 - 1) / divK;
                    Real dgj = gjM * std::sqrt(xKH * (1 - xKH));
                    g_j += dgj;
                    sum += f_j * g_j;
                    // and then the loop for the rest of the j's:
                    for (Natural j = 3; j <= n / 2; ++j) {
                        f_j *= (j - 1.5) / (Real) (j - 1) / divH;
                        dgj *= (Real) (j - 2) / (2 * j - 3) * dgM;
                        g_j += dgj;
                        sum += f_j * g_j;
                    }
                }
                res += h / div * sum;
                return res;

            } else { // n is odd, equation (11)
                // first line of (11)
                Real hk = h * k;
                Real hkcn = hk + rho * n;
                Real sqrtExpr = std::sqrt(h*h - 2 * rho * hk + k*k + n * unCor);
                Real res = arctan(std::sqrt(Real(n)) * (-(h + k) * hkcn - (hk - n) * sqrtExpr),
                                  (hk - n) * hkcn - n * (h + k) * sqrtExpr ) / M_TWOPI;

                if (n > 1) {
                    // second line of (11)
                    Real mult = (1 - xHK) / 2;
                    // initializations for j = 1:
                    Real f_j = 2 / std::sqrt(M_PI) / divK;
                    Real dgj = sgnHK * std::sqrt(xHK);
                    Real g_j = 1 + dgj;
                    Real sum = f_j * g_j;
                    // and then the loop for the rest of the j's:
                    for (Natural j = 2; j <= (n - 1) / 2; ++j) {
                        f_j *= (Real) (j - 1) / (j - 0.5) / divK;
                        dgj *= (Real) (2 * j - 3) / (j - 1) * mult;
                        g_j += dgj;
                        sum += f_j * g_j;
                    }
                    res += k / div * sum;

                    // third line of (11)
                    mult = (1 - xKH) / 2;
                    // initializations for j = 1:
                    f_j = 2 / std::sqrt(M_PI) / divH;
                    dgj = sgnKH * std::sqrt(xKH);
                    g_j = 1 + dgj;
                    sum = f_j * g_j;
                    // and then the loop for the rest of the j's:
                    for (Natural j = 2; j <= (n - 1) / 2; ++j) {
                        f_j *= (Real) (j - 1) / (j - 0.5) / divH;
                        dgj *= (Real) (2 * j - 3) / (j - 1) * mult;
                        g_j += dgj;
                        sum += f_j * g_j;
                    }
                    res += h / div * sum;
                }
                return res;
            }
        }

    }


    BivariateCumulativeStudentDistribution::
    BivariateCumulativeStudentDistribution(Natural n,
                                           Real rho)
    : n_(n), rho_(rho) {}

    Real BivariateCumulativeStudentDistribution::operator()(Real x,
                                                            Real y) const {
        return P_n(x, y, n_, rho_);
    }

}
]]></document_content>
  </document>
  <document index="20">
    <source>distributions/chisquaredistribution.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2007 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/solvers1d/brent.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/distributions/chisquaredistribution.hpp>
#include <ql/math/distributions/gammadistribution.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {

    Real CumulativeChiSquareDistribution::operator()(Real x) const {
        return CumulativeGammaDistribution(0.5*df_)(0.5*x);
    }

    Real NonCentralCumulativeChiSquareDistribution::operator()(Real x) const {
        if (x <= 0.0)
            return 0.0;

        const Real errmax = 1e-12;
        const Size itrmax = 10000;
        Real lam = 0.5*ncp_;

        Real u = std::exp(-lam);
        Real v = u;
        Real x2 = 0.5*x;
        Real f2 = 0.5*df_;
        Real f_x_2n = df_ - x;

        Real t = 0.0;
        if (f2*QL_EPSILON > 0.125 &&
            std::fabs(x2-f2) < std::sqrt(QL_EPSILON)*f2) {
            t = std::exp((1 - t) *
                         (2 - t/(f2+1)))/std::sqrt(2.0*M_PI*(f2 + 1.0));
        }
        else {
            t = std::exp(f2*std::log(x2) - x2 -
                         GammaFunction().logValue(f2 + 1));
        }

        Real ans = v*t;

        bool flag = false;
        Size n = 1;
        Real f_2n = df_ + 2.0;
        f_x_2n += 2.0;

        Real bound;
        for (;;) {
            if (f_x_2n > 0) {
                flag = true;
                goto L10;
            }
            for (;;) {
                u *= lam / n;
                v += u;
                t *= x / f_2n;
                ans += v*t;
                n++;
                f_2n += 2.0;
                f_x_2n += 2.0;
                if (!flag && n <= itrmax)
                    break;
            L10:
                bound = t * x / f_x_2n;
                if (bound <= errmax || n > itrmax)
                    goto L_End;
            }
        }
    L_End:
        if (bound > errmax) QL_FAIL("didn't converge");
        return (ans);

    }

    Real NonCentralCumulativeChiSquareSankaranApprox::operator()(Real x) const {

        const Real h = 1-2*(df_+ncp_)*(df_+3*ncp_)/(3*square<Real>()(df_+2*ncp_));
        const Real p = (df_+2*ncp_)/square<Real>()(df_+ncp_);
        const Real m = (h-1)*(1-3*h);

        const Real u= (std::pow(x/(df_+ncp_), h) - (1 + h*p*(h-1-0.5*(2-h)*m*p)))/
            (h*std::sqrt(2*p)*(1+0.5*m*p));

        return CumulativeNormalDistribution()(u);
    }

    InverseNonCentralCumulativeChiSquareDistribution::
      InverseNonCentralCumulativeChiSquareDistribution(Real df, Real ncp, 
                                             Size maxEvaluations, 
                                             Real accuracy)
    : nonCentralDist_(df, ncp),
      guess_(df+ncp),
      maxEvaluations_(maxEvaluations),
      accuracy_(accuracy) {
    }

    Real InverseNonCentralCumulativeChiSquareDistribution::operator()(Real x) const {

        // first find the right side of the interval
        Real upper = guess_;
        Size evaluations = maxEvaluations_;
        while (nonCentralDist_(upper) < x && evaluations > 0) {
            upper*=2.0;
            --evaluations;
        }

        // use a Brent solver for the rest
        Brent solver;
        solver.setMaxEvaluations(evaluations);
        return solver.solve(compose(subtract<Real>(x),
                                    nonCentralDist_),
                            accuracy_, 0.75*upper, 
                            (evaluations == maxEvaluations_)? 0.0: 0.5*upper,
                            upper);
    }
}
]]></document_content>
  </document>
  <document index="21">
    <source>distributions/gammadistribution.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Sadruddin Rejeb

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/distributions/gammadistribution.hpp>

namespace QuantLib {

    Real CumulativeGammaDistribution::operator()(Real x) const {
        if (x <= 0.0) return 0.0;

        Real gln = GammaFunction().logValue(a_);

        if (x<(a_+1.0)) {
            Real ap = a_;
            Real del = 1.0/a_;
            Real sum = del;
            for (Size n=1; n<=100; n++) {
                ap += 1.0;
                del *= x/ap;
                sum += del;
                if (std::fabs(del) < std::fabs(sum)*3.0e-7)
                    return sum*std::exp(-x + a_*std::log(x) - gln);
            }
        } else {
            Real b = x + 1.0 - a_;
            Real c = QL_MAX_REAL;
            Real d = 1.0/b;
            Real h = d;
            for (Size n=1; n<=100; n++) {
                Real an = -1.0*n*(n-a_);
                b += 2.0;
                d = an*d + b;
                if (std::fabs(d) < QL_EPSILON) d = QL_EPSILON;
                c = b + an/c;
                if (std::fabs(c) < QL_EPSILON) c = QL_EPSILON;
                d = 1.0/d;
                Real del = d*c;
                h *= del;
                if (std::fabs(del - 1.0)<QL_EPSILON)
                    return 1.0-h*std::exp(-x + a_*std::log(x) - gln);
            }
        }
        QL_FAIL("too few iterations");
    }

    const Real GammaFunction::c1_ = 76.18009172947146;
    const Real GammaFunction::c2_ = -86.50532032941677;
    const Real GammaFunction::c3_ = 24.01409824083091;
    const Real GammaFunction::c4_ = -1.231739572450155;
    const Real GammaFunction::c5_ = 0.1208650973866179e-2;
    const Real GammaFunction::c6_ = -0.5395239384953e-5;

    Real GammaFunction::logValue(Real x) const {
        QL_REQUIRE(x>0.0, "positive argument required");
        Real temp = x + 5.5;
        temp -= (x + 0.5)*std::log(temp);
        Real ser=1.000000000190015;
        ser += c1_/(x + 1.0);
        ser += c2_/(x + 2.0);
        ser += c3_/(x + 3.0);
        ser += c4_/(x + 4.0);
        ser += c5_/(x + 5.0);
        ser += c6_/(x + 6.0);

        return -temp+std::log(2.5066282746310005*ser/x);
    }

    Real GammaFunction::value(Real x) const {
        if (x >= 1.0) {
            return std::exp(logValue(x));
        }
        else {
            if (x > -20.0) {
                // \Gamma(x) = \frac{\Gamma(x+1)}{x}
                return value(x+1.0)/x;
            }
            else {
                // \Gamma(-x) = -\frac{\pi}{\Gamma(x)\sin(\pi x) x}
                return -M_PI/(value(-x)*x*std::sin(M_PI*x));
            }
        }
    }
}
]]></document_content>
  </document>
  <document index="22">
    <source>distributions/normaldistribution.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2002, 2003 Ferdinando Ametrano
 Copyright (C) 2008 StatPro Italia srl
 Copyright (C) 2010 Kakhkhor Abdijalilov

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/comparison.hpp>

#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#endif

#include <boost/math/distributions/normal.hpp>

#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic pop
#endif

namespace QuantLib {

    Real CumulativeNormalDistribution::operator()(Real z) const {
        //QL_REQUIRE(!(z >= average_ && 2.0*average_-z > average_),
        //           "not a real number. ");
        z = (z - average_) / sigma_;

        Real result = 0.5 * ( 1.0 + errorFunction_( z*M_SQRT_2 ) );
        if (result<=1e-8) { //todo: investigate the threshold level
            // Asymptotic expansion for very negative z following (26.2.12)
            // on page 408 in M. Abramowitz and A. Stegun,
            // Pocketbook of Mathematical Functions, ISBN 3-87144818-4.
            Real sum=1.0, zsqr=z*z, i=1.0, g=1.0, x, y,
                 a=QL_MAX_REAL, lasta;
            do {
                lasta=a;
                x = (4.0*i-3.0)/zsqr;
                y = x*((4.0*i-1)/zsqr);
                a = g*(x-y);
                sum -= a;
                g *= y;
                ++i;
                a = std::fabs(a);
            } while (lasta>a && a>=std::fabs(sum*QL_EPSILON));
            result = -gaussian_(z)/z*sum;
        }
        return result;
    }

    #if !defined(QL_PATCH_SOLARIS)
    const CumulativeNormalDistribution InverseCumulativeNormal::f_;
    #endif

    // Coefficients for the rational approximation.
    const Real InverseCumulativeNormal::a1_ = -3.969683028665376e+01;
    const Real InverseCumulativeNormal::a2_ =  2.209460984245205e+02;
    const Real InverseCumulativeNormal::a3_ = -2.759285104469687e+02;
    const Real InverseCumulativeNormal::a4_ =  1.383577518672690e+02;
    const Real InverseCumulativeNormal::a5_ = -3.066479806614716e+01;
    const Real InverseCumulativeNormal::a6_ =  2.506628277459239e+00;

    const Real InverseCumulativeNormal::b1_ = -5.447609879822406e+01;
    const Real InverseCumulativeNormal::b2_ =  1.615858368580409e+02;
    const Real InverseCumulativeNormal::b3_ = -1.556989798598866e+02;
    const Real InverseCumulativeNormal::b4_ =  6.680131188771972e+01;
    const Real InverseCumulativeNormal::b5_ = -1.328068155288572e+01;

    const Real InverseCumulativeNormal::c1_ = -7.784894002430293e-03;
    const Real InverseCumulativeNormal::c2_ = -3.223964580411365e-01;
    const Real InverseCumulativeNormal::c3_ = -2.400758277161838e+00;
    const Real InverseCumulativeNormal::c4_ = -2.549732539343734e+00;
    const Real InverseCumulativeNormal::c5_ =  4.374664141464968e+00;
    const Real InverseCumulativeNormal::c6_ =  2.938163982698783e+00;

    const Real InverseCumulativeNormal::d1_ =  7.784695709041462e-03;
    const Real InverseCumulativeNormal::d2_ =  3.224671290700398e-01;
    const Real InverseCumulativeNormal::d3_ =  2.445134137142996e+00;
    const Real InverseCumulativeNormal::d4_ =  3.754408661907416e+00;

    // Limits of the approximation regions
    const Real InverseCumulativeNormal::x_low_ = 0.02425;
    const Real InverseCumulativeNormal::x_high_= 1.0 - x_low_;

    Real InverseCumulativeNormal::tail_value(Real x) {
        if (x <= 0.0 || x >= 1.0) {
            // try to recover if due to numerical error
            if (close_enough(x, 1.0)) {
                return QL_MAX_REAL; // largest value available
            } else if (std::fabs(x) < QL_EPSILON) {
                return QL_MIN_REAL; // largest negative value available
            } else {
                QL_FAIL("InverseCumulativeNormal(" << x
                        << ") undefined: must be 0 < x < 1");
            }
        }

        Real z;
        if (x < x_low_) {
            // Rational approximation for the lower region 0<x<u_low
            z = std::sqrt(-2.0*std::log(x));
            z = (((((c1_*z+c2_)*z+c3_)*z+c4_)*z+c5_)*z+c6_) /
                ((((d1_*z+d2_)*z+d3_)*z+d4_)*z+1.0);
        } else {
            // Rational approximation for the upper region u_high<x<1
            z = std::sqrt(-2.0*std::log(1.0-x));
            z = -(((((c1_*z+c2_)*z+c3_)*z+c4_)*z+c5_)*z+c6_) /
                ((((d1_*z+d2_)*z+d3_)*z+d4_)*z+1.0);
        }

        return z;
    }

    const Real MoroInverseCumulativeNormal::a0_ =  2.50662823884;
    const Real MoroInverseCumulativeNormal::a1_ =-18.61500062529;
    const Real MoroInverseCumulativeNormal::a2_ = 41.39119773534;
    const Real MoroInverseCumulativeNormal::a3_ =-25.44106049637;

    const Real MoroInverseCumulativeNormal::b0_ = -8.47351093090;
    const Real MoroInverseCumulativeNormal::b1_ = 23.08336743743;
    const Real MoroInverseCumulativeNormal::b2_ =-21.06224101826;
    const Real MoroInverseCumulativeNormal::b3_ =  3.13082909833;

    const Real MoroInverseCumulativeNormal::c0_ = 0.3374754822726147;
    const Real MoroInverseCumulativeNormal::c1_ = 0.9761690190917186;
    const Real MoroInverseCumulativeNormal::c2_ = 0.1607979714918209;
    const Real MoroInverseCumulativeNormal::c3_ = 0.0276438810333863;
    const Real MoroInverseCumulativeNormal::c4_ = 0.0038405729373609;
    const Real MoroInverseCumulativeNormal::c5_ = 0.0003951896511919;
    const Real MoroInverseCumulativeNormal::c6_ = 0.0000321767881768;
    const Real MoroInverseCumulativeNormal::c7_ = 0.0000002888167364;
    const Real MoroInverseCumulativeNormal::c8_ = 0.0000003960315187;

    Real MoroInverseCumulativeNormal::operator()(Real x) const {
        QL_REQUIRE(x > 0.0 && x < 1.0,
                   "MoroInverseCumulativeNormal(" << x
                   << ") undefined: must be 0<x<1");

        Real result;
        Real temp=x-0.5;

        if (std::fabs(temp) < 0.42) {
            // Beasley and Springer, 1977
            result=temp*temp;
            result=temp*
                (((a3_*result+a2_)*result+a1_)*result+a0_) /
                ((((b3_*result+b2_)*result+b1_)*result+b0_)*result+1.0);
        } else {
            // improved approximation for the tail (Moro 1995)
            if (x<0.5)
                result = x;
            else
                result=1.0-x;
            result = std::log(-std::log(result));
            result = c0_+result*(c1_+result*(c2_+result*(c3_+result*
                                   (c4_+result*(c5_+result*(c6_+result*
                                                       (c7_+result*c8_)))))));
            if (x<0.5)
                result=-result;
        }

        return average_ + result*sigma_;
    }

    MaddockInverseCumulativeNormal::MaddockInverseCumulativeNormal(
        Real average, Real sigma)
    : average_(average), sigma_(sigma) {}

    Real MaddockInverseCumulativeNormal::operator()(Real x) const {
        return boost::math::quantile(
            boost::math::normal_distribution<Real>(average_, sigma_), x);
    }

    MaddockCumulativeNormal::MaddockCumulativeNormal(
        Real average, Real sigma)
    : average_(average), sigma_(sigma) {}

    Real MaddockCumulativeNormal::operator()(Real x) const {
        return boost::math::cdf(
            boost::math::normal_distribution<Real>(average_, sigma_), x);
    }
}
]]></document_content>
  </document>
  <document index="23">
    <source>distributions/studenttdistribution.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/distributions/studenttdistribution.hpp>
#include <ql/math/distributions/gammadistribution.hpp>
#include <ql/math/beta.hpp>

namespace QuantLib {

    Real StudentDistribution::operator()(Real x) const {
        static GammaFunction G;
        Real g1 = std::exp (G.logValue(0.5 * (n_ + 1)));
        Real g2 = std::exp (G.logValue(0.5 * n_));

        Real power = std::pow (1. + x*x / n_, 0.5 * (n_ + 1));

        return g1 / (g2 * power * std::sqrt (M_PI * n_));
    }

    Real CumulativeStudentDistribution::operator()(Real x) const {
        Real xx = 1.0 * n_ / (x*x + n_);
        Real sig = (x > 0 ? 1.0 : - 1.0);

        return 0.5 + 0.5 * sig * ( incompleteBetaFunction (0.5 * n_, 0.5, 1.0)
                                   -incompleteBetaFunction (0.5 * n_, 0.5, xx));
    }

    Real InverseCumulativeStudent::operator()(Real y) const {
        QL_REQUIRE (y >= 0 && y <= 1, "argument out of range [0, 1]");

        Real x = 0;
        Size count = 0;

        // do a few newton steps to find x
        do {
            x -= (f_(x) - y) / d_(x);
            count++;
        }
        while (std::fabs(f_(x) - y) > accuracy_ && count < maxIterations_);

        QL_REQUIRE (count < maxIterations_,
                    "maximum number of iterations " << maxIterations_
                    << " reached in InverseCumulativeStudent, "
                    << "y=" << y << ", x=" << x);

        return x;
    }

}

]]></document_content>
  </document>
  <document index="24">
    <source>errorfunction.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

// NOTE: The following copyright notice
// applies only to the (modified) code of erff.
//

// erff
// ====
//
// Based on code from the gnu C library, originally written by Sun.
// Modified to remove reliance on features of gcc and 64-bit width
// of doubles. No doubt this results in some slight deterioration
// of efficiency, but this is not really noticeable in testing.
//

//
// ====================================================
// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
//
// Developed at SunPro, a Sun Microsystems, Inc. business.
// Permission to use, copy, modify, and distribute this
// software is freely granted, provided that this notice
// is preserved.
// ====================================================


#include <ql/math/errorfunction.hpp>
#include <cfloat>

namespace QuantLib {

    //                 x
    //              2      |
    //     erf(x)  =  ---------  | exp(-t*t)dt
    //           sqrt(pi) \|
    //                 0
    //
    //     erfc(x) =  1-erf(x)
    //  Note that
    //      erf(-x) = -erf(x)
    //      erfc(-x) = 2 - erfc(x)
    //
    // Method:
    //  1. For |x| in [0, 0.84375]
    //      erf(x)  = x + x*R(x^2)
    //          erfc(x) = 1 - erf(x)           if x in [-.84375,0.25]
    //                  = 0.5 + ((0.5-x)-x*R)  if x in [0.25,0.84375]
    //     where R = P/Q where P is an odd poly of degree 8 and
    //     Q is an odd poly of degree 10.
    //                       -57.90
    //          | R - (erf(x)-x)/x | <= 2
    //
    //
    //     Remark. The formula is derived by noting
    //          erf(x) = (2/sqrt(pi))*(x - x^3/3 + x^5/10 - x^7/42 + ....)
    //     and that
    //          2/sqrt(pi) = 1.128379167095512573896158903121545171688
    //     is close to one. The interval is chosen because the fix
    //     point of erf(x) is near 0.6174 (i.e., erf(x)=x when x is
    //     near 0.6174), and by some experiment, 0.84375 is chosen to
    //     guarantee the error is less than one ulp for erf.
    //
    //      2. For |x| in [0.84375,1.25], let s = |x| - 1, and
    //         c = 0.84506291151 rounded to single (24 bits)
    //  erf(x)  = sign(x) * (c  + P1(s)/Q1(s))
    //  erfc(x) = (1-c)  - P1(s)/Q1(s) if x > 0
    //            1+(c+P1(s)/Q1(s))    if x < 0
    //  |P1/Q1 - (erf(|x|)-c)| <= 2**-59.06
    //     Remark: here we use the taylor series expansion at x=1.
    //      erf(1+s) = erf(1) + s*Poly(s)
    //           = 0.845.. + P1(s)/Q1(s)
    //     That is, we use rational approximation to approximate
    //          erf(1+s) - (c = (single)0.84506291151)
    //     Note that |P1/Q1|< 0.078 for x in [0.84375,1.25]
    //     where
    //      P1(s) = degree 6 poly in s
    //      Q1(s) = degree 6 poly in s
    //
    //      3. For x in [1.25,1/0.35(~2.857143)],
    //  erfc(x) = (1/x)*exp(-x*x-0.5625+R1/S1)
    //  erf(x)  = 1 - erfc(x)
    //     where
    //      R1(z) = degree 7 poly in z, (z=1/x^2)
    //      S1(z) = degree 8 poly in z
    //
    //      4. For x in [1/0.35,28]
    //  erfc(x) = (1/x)*exp(-x*x-0.5625+R2/S2) if x > 0
    //          = 2.0 - (1/x)*exp(-x*x-0.5625+R2/S2) if -6<x<0
    //          = 2.0 - tiny        (if x <= -6)
    //  erf(x)  = sign(x)*(1.0 - erfc(x)) if x < 6, else
    //  erf(x)  = sign(x)*(1.0 - tiny)
    //     where
    //      R2(z) = degree 6 poly in z, (z=1/x^2)
    //      S2(z) = degree 7 poly in z
    //
    //      Note1:
    //     To compute exp(-x*x-0.5625+R/S), let s be a single
    //     precision number and s := x; then
    //      -x*x = -s*s + (s-x)*(s+x)
    //          exp(-x*x-0.5626+R/S) =
    //          exp(-s*s-0.5625)*exp((s-x)*(s+x)+R/S);
    //      Note2:
    //     Here 4 and 5 make use of the asymptotic series
    //            exp(-x*x)
    //      erfc(x) ~ ---------- * ( 1 + Poly(1/x^2) )
    //            x*sqrt(pi)
    //     We use rational approximation to approximate
    //  g(s)=f(1/x^2) = log(erfc(x)*x) - x*x + 0.5625
    //     Here is the error bound for R1/S1 and R2/S2
    //  |R1/S1 - f(x)|  < 2**(-62.57)
    //  |R2/S2 - f(x)|  < 2**(-61.52)
    //
    //      5. For inf > x >= 28
    //  erf(x)  = sign(x) *(1 - tiny)  (raise inexact)
    //  erfc(x) = tiny*tiny (raise underflow) if x > 0
    //          = 2 - tiny if x<0
    //
    //      7. Special case:
    //  erf(0)  = 0, erf(inf)  = 1, erf(-inf) = -1,
    //  erfc(0) = 1, erfc(inf) = 0, erfc(-inf) = 2,
    //      erfc/erf(NaN) is NaN

    const Real
    ErrorFunction::tiny =  QL_EPSILON,
        ErrorFunction::one =  1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */
        /* c = (float)0.84506291151 */
        ErrorFunction::erx =  8.45062911510467529297e-01, /* 0x3FEB0AC1, 0x60000000 */
        //
        // Coefficients for approximation to  erf on [0,0.84375]
        //
        ErrorFunction::efx  =  1.28379167095512586316e-01, /* 0x3FC06EBA, 0x8214DB69 */
        ErrorFunction::efx8 =  1.02703333676410069053e+00, /* 0x3FF06EBA, 0x8214DB69 */
        ErrorFunction::pp0  =  1.28379167095512558561e-01, /* 0x3FC06EBA, 0x8214DB68 */
        ErrorFunction::pp1  = -3.25042107247001499370e-01, /* 0xBFD4CD7D, 0x691CB913 */
        ErrorFunction::pp2  = -2.84817495755985104766e-02, /* 0xBF9D2A51, 0xDBD7194F */
        ErrorFunction::pp3  = -5.77027029648944159157e-03, /* 0xBF77A291, 0x236668E4 */
        ErrorFunction::pp4  = -2.37630166566501626084e-05, /* 0xBEF8EAD6, 0x120016AC */
        ErrorFunction::qq1  =  3.97917223959155352819e-01, /* 0x3FD97779, 0xCDDADC09 */
        ErrorFunction::qq2  =  6.50222499887672944485e-02, /* 0x3FB0A54C, 0x5536CEBA */
        ErrorFunction::qq3  =  5.08130628187576562776e-03, /* 0x3F74D022, 0xC4D36B0F */
        ErrorFunction::qq4  =  1.32494738004321644526e-04, /* 0x3F215DC9, 0x221C1A10 */
        ErrorFunction::qq5  = -3.96022827877536812320e-06, /* 0xBED09C43, 0x42A26120 */
        //
        // Coefficients for approximation to  erf  in [0.84375,1.25]
        //
        ErrorFunction::pa0  = -2.36211856075265944077e-03, /* 0xBF6359B8, 0xBEF77538 */
        ErrorFunction::pa1  =  4.14856118683748331666e-01, /* 0x3FDA8D00, 0xAD92B34D */
        ErrorFunction::pa2  = -3.72207876035701323847e-01, /* 0xBFD7D240, 0xFBB8C3F1 */
        ErrorFunction::pa3  =  3.18346619901161753674e-01, /* 0x3FD45FCA, 0x805120E4 */
        ErrorFunction::pa4  = -1.10894694282396677476e-01, /* 0xBFBC6398, 0x3D3E28EC */
        ErrorFunction::pa5  =  3.54783043256182359371e-02, /* 0x3FA22A36, 0x599795EB */
        ErrorFunction::pa6  = -2.16637559486879084300e-03, /* 0xBF61BF38, 0x0A96073F */
        ErrorFunction::qa1  =  1.06420880400844228286e-01, /* 0x3FBB3E66, 0x18EEE323 */
        ErrorFunction::qa2  =  5.40397917702171048937e-01, /* 0x3FE14AF0, 0x92EB6F33 */
        ErrorFunction::qa3  =  7.18286544141962662868e-02, /* 0x3FB2635C, 0xD99FE9A7 */
        ErrorFunction::qa4  =  1.26171219808761642112e-01, /* 0x3FC02660, 0xE763351F */
        ErrorFunction::qa5  =  1.36370839120290507362e-02, /* 0x3F8BEDC2, 0x6B51DD1C */
        ErrorFunction::qa6  =  1.19844998467991074170e-02, /* 0x3F888B54, 0x5735151D */
        //
        // Coefficients for approximation to  erfc in [1.25,1/0.35]
        //
        ErrorFunction::ra0  = -9.86494403484714822705e-03, /* 0xBF843412, 0x600D6435 */
        ErrorFunction::ra1  = -6.93858572707181764372e-01, /* 0xBFE63416, 0xE4BA7360 */
        ErrorFunction::ra2  = -1.05586262253232909814e+01, /* 0xC0251E04, 0x41B0E726 */
        ErrorFunction::ra3  = -6.23753324503260060396e+01, /* 0xC04F300A, 0xE4CBA38D */
        ErrorFunction::ra4  = -1.62396669462573470355e+02, /* 0xC0644CB1, 0x84282266 */
        ErrorFunction::ra5  = -1.84605092906711035994e+02, /* 0xC067135C, 0xEBCCABB2 */
        ErrorFunction::ra6  = -8.12874355063065934246e+01, /* 0xC0545265, 0x57E4D2F2 */
        ErrorFunction::ra7  = -9.81432934416914548592e+00, /* 0xC023A0EF, 0xC69AC25C */
        ErrorFunction::sa1  =  1.96512716674392571292e+01, /* 0x4033A6B9, 0xBD707687 */
        ErrorFunction::sa2  =  1.37657754143519042600e+02, /* 0x4061350C, 0x526AE721 */
        ErrorFunction::sa3  =  4.34565877475229228821e+02, /* 0x407B290D, 0xD58A1A71 */
        ErrorFunction::sa4  =  6.45387271733267880336e+02, /* 0x40842B19, 0x21EC2868 */
        ErrorFunction::sa5  =  4.29008140027567833386e+02, /* 0x407AD021, 0x57700314 */
        ErrorFunction::sa6  =  1.08635005541779435134e+02, /* 0x405B28A3, 0xEE48AE2C */
        ErrorFunction::sa7  =  6.57024977031928170135e+00, /* 0x401A47EF, 0x8E484A93 */
        ErrorFunction::sa8  = -6.04244152148580987438e-02, /* 0xBFAEEFF2, 0xEE749A62 */
        //
        // Coefficients for approximation to  erfc in [1/.35,28]
        //
        ErrorFunction::rb0  = -9.86494292470009928597e-03, /* 0xBF843412, 0x39E86F4A */
        ErrorFunction::rb1  = -7.99283237680523006574e-01, /* 0xBFE993BA, 0x70C285DE */
        ErrorFunction::rb2  = -1.77579549177547519889e+01, /* 0xC031C209, 0x555F995A */
        ErrorFunction::rb3  = -1.60636384855821916062e+02, /* 0xC064145D, 0x43C5ED98 */
        ErrorFunction::rb4  = -6.37566443368389627722e+02, /* 0xC083EC88, 0x1375F228 */
        ErrorFunction::rb5  = -1.02509513161107724954e+03, /* 0xC0900461, 0x6A2E5992 */
        ErrorFunction::rb6  = -4.83519191608651397019e+02, /* 0xC07E384E, 0x9BDC383F */
        ErrorFunction::sb1  =  3.03380607434824582924e+01, /* 0x403E568B, 0x261D5190 */
        ErrorFunction::sb2  =  3.25792512996573918826e+02, /* 0x40745CAE, 0x221B9F0A */
        ErrorFunction::sb3  =  1.53672958608443695994e+03, /* 0x409802EB, 0x189D5118 */
        ErrorFunction::sb4  =  3.19985821950859553908e+03, /* 0x40A8FFB7, 0x688C246A */
        ErrorFunction::sb5  =  2.55305040643316442583e+03, /* 0x40A3F219, 0xCEDF3BE6 */
        ErrorFunction::sb6  =  4.74528541206955367215e+02, /* 0x407DA874, 0xE79FE763 */
        ErrorFunction::sb7  = -2.24409524465858183362e+01; /* 0xC03670E2, 0x42712D62 */

    Real ErrorFunction::operator()(Real x) const {

        Real R,S,P,Q,s,y,z,r, ax;

        if (!std::isfinite(x)) {
            if (std::isnan(x))
                return x;
            else
                return ( x > 0 ? 1 : -1);
        }

        ax = std::fabs(x);

        if(ax < 0.84375) {      /* |x|<0.84375 */
            if(ax < 3.7252902984e-09) { /* |x|<2**-28 */
                if (ax < DBL_MIN*16)
                    return 0.125*(8.0*x+efx8*x);  /*avoid underflow */
                return x + efx*x;
            }
            z = x*x;
            r = pp0+z*(pp1+z*(pp2+z*(pp3+z*pp4)));
            s = one+z*(qq1+z*(qq2+z*(qq3+z*(qq4+z*qq5))));
            y = r/s;
            return x + x*y;
        }
        if(ax <1.25) {      /* 0.84375 <= |x| < 1.25 */
            s = ax-one;
            P = pa0+s*(pa1+s*(pa2+s*(pa3+s*(pa4+s*(pa5+s*pa6)))));
            Q = one+s*(qa1+s*(qa2+s*(qa3+s*(qa4+s*(qa5+s*qa6)))));
            if(x>=0) return erx + P/Q; else return -erx - P/Q;
        }
        if (ax >= 6) {      /* inf>|x|>=6 */
            if(x>=0) return one-tiny; else return tiny-one;
        }

        /* Starts to lose accuracy when ax~5 */
        s = one/(ax*ax);

        if(ax < 2.85714285714285) { /* |x| < 1/0.35 */
            R = ra0+s*(ra1+s*(ra2+s*(ra3+s*(ra4+s*(ra5+s*(ra6+s*ra7))))));
            S=one+s*(sa1+s*(sa2+s*(sa3+s*(sa4+s*(sa5+s*(sa6+s*(sa7+s*sa8)))))));
        } else {    /* |x| >= 1/0.35 */
            R=rb0+s*(rb1+s*(rb2+s*(rb3+s*(rb4+s*(rb5+s*rb6)))));
            S=one+s*(sb1+s*(sb2+s*(sb3+s*(sb4+s*(sb5+s*(sb6+s*sb7))))));
        }
        r = std::exp( -ax*ax-0.5625 +R/S);
        if(x>=0) return one-r/ax; else return  r/ax-one;

    }

}
]]></document_content>
  </document>
  <document index="25">
    <source>factorial.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/factorial.hpp>
#include <ql/math/distributions/gammadistribution.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    namespace {

        const Real firstFactorials[] = {
                                   1.0,                                   1.0,
                                   2.0,                                   6.0,
                                  24.0,                                 120.0,
                                 720.0,                                5040.0,
                               40320.0,                              362880.0,
                             3628800.0,                            39916800.0,
                           479001600.0,                          6227020800.0,
                         87178291200.0,                       1307674368000.0,
                      20922789888000.0,                     355687428096000.0,
                    6402373705728000.0,                  121645100408832000.0,
                 2432902008176640000.0,                51090942171709440000.0,
              1124000727777607680000.0,             25852016738884976640000.0,
            620448401733239439360000.0,          15511210043330985984000000.0,
         403291461126605635584000000.0,       10888869450418352160768000000.0
        };

        const Size tabulated =
            sizeof(firstFactorials)/sizeof(firstFactorials[0])-1;

    }

    Real Factorial::get(Natural i) {
        if (i<=tabulated) {
            return firstFactorials[i];
        } else {
            return std::exp(GammaFunction().logValue(i+1));
        }
    }

    Real Factorial::ln(Natural i) {
        if (i<=tabulated) {
            return std::log(firstFactorials[i]);
        } else {
            return GammaFunction().logValue(i+1);
        }
    }

}
]]></document_content>
  </document>
  <document index="26">
    <source>incompletegamma.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*
    The implementation of the algorithm was inspired by
    "Numerical Recipes in C", 2nd edition,
    Press, Teukolsky, Vetterling, Flannery, chapter 6
*/

#include <ql/math/incompletegamma.hpp>
#include <ql/math/distributions/gammadistribution.hpp>

namespace QuantLib {


    Real incompleteGammaFunction(Real a, Real x, Real accuracy,
                                 Integer maxIteration) {

        QL_REQUIRE(a>0.0, "non-positive a is not allowed");

        QL_REQUIRE(x>=0.0, "negative x non allowed");

        if (x < (a+1.0)) {
            // Use the series representation
            return incompleteGammaFunctionSeriesRepr(a, x,
                accuracy, maxIteration);
        } else {
            // Use the continued fraction representation
            return 1.0-incompleteGammaFunctionContinuedFractionRepr(a, x,
                accuracy, maxIteration);
        }

    }


    Real incompleteGammaFunctionSeriesRepr(Real a, Real x, Real accuracy,
                                           Integer maxIteration) {

        if (x==0.0) return 0.0;

        Real gln = GammaFunction().logValue(a);
        Real ap=a;
        Real del=1.0/a;
        Real sum=del;
        for (Integer n=1; n<=maxIteration; n++) {
            ++ap;
            del *= x/ap;
            sum += del;
            if (std::fabs(del) < std::fabs(sum)*accuracy) {
                return sum*std::exp(-x+a*std::log(x)-gln);
            }
        }
        QL_FAIL("accuracy not reached");
    }

    Real incompleteGammaFunctionContinuedFractionRepr(Real a, Real x,
                                                      Real accuracy,
                                                      Integer maxIteration) {

        Integer i;
        Real an, b, c, d, del, h;
        Real gln = GammaFunction().logValue(a);
        b=x+1.0-a;
        c=1.0/QL_EPSILON;
        d=1.0/b;
        h=d;
        for (i=1; i<=maxIteration; i++) {
            an = -i*(i-a);
            b += 2.0;
            d=an*d+b;
            if (std::fabs(d) < QL_EPSILON) d=QL_EPSILON;
            c=b+an/c;
            if (std::fabs(c) < QL_EPSILON) c=QL_EPSILON;
            d=1.0/d;
            del=d*c;
            h *= del;
            if (std::fabs(del-1.0) < accuracy) {
                return std::exp(-x+a*std::log(x)-gln)*h;
            }
        }

        QL_FAIL("accuracy not reached");
    }



}
]]></document_content>
  </document>
  <document index="27">
    <source>integrals/discreteintegrals.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/integrals/discreteintegrals.hpp>
#include <boost/accumulators/accumulators.hpp>
#include <boost/accumulators/statistics/sum.hpp>

using namespace boost::accumulators;

namespace QuantLib {

    Real DiscreteTrapezoidIntegral::operator()(
        const Array& x, const Array& f)    const {

        const Size n = f.size();
        QL_REQUIRE(n == x.size(), "inconsistent size");

        accumulator_set<Real, features<tag::sum> > acc;

        for (Size i=0; i < n-1; ++i) {
            acc((x[i+1]-x[i])*(f[i]+f[i+1]));
        }

        return 0.5*sum(acc);
    }

    Real DiscreteSimpsonIntegral::operator()(
        const Array& x, const Array& f)    const {

        const Size n = f.size();
        QL_REQUIRE(n == x.size(), "inconsistent size");

        accumulator_set<Real, features<tag::sum> > acc;

        for (Size j=0; j < n-2; j+=2) {
            const Real dxj   = x[j+1]-x[j];
            const Real dxjp1 = x[j+2]-x[j+1];

            const Real alpha = -dxjp1*(2*x[j]-3*x[j+1]+x[j+2]);
            const Real dd = x[j+2]-x[j];
            const Real k = dd/(6*dxjp1*dxj);
            const Real beta = dd*dd;
            const Real gamma = dxj*(x[j]-3*x[j+1]+2*x[j+2]);

            acc(k*alpha*f[j]+k*beta*f[j+1]+k*gamma*f[j+2]);
        }
        if ((n & 1) == 0U) {
            acc(0.5*(x[n-1]-x[n-2])*(f[n-1]+f[n-2]));
        }

        return sum(acc);
    }


    Real DiscreteTrapezoidIntegrator::integrate(
        const ext::function<Real (Real)>& f, Real a, Real b) const {
            const Array x(maxEvaluations(), a, (b-a)/(maxEvaluations()-1));
            Array fv(x.size());
            std::transform(x.begin(), x.end(), fv.begin(), f);

            increaseNumberOfEvaluations(maxEvaluations());
            return DiscreteTrapezoidIntegral()(x, fv);
    }

    Real DiscreteSimpsonIntegrator::integrate(
        const ext::function<Real (Real)>& f, Real a, Real b) const {
            const Array x(maxEvaluations(), a, (b-a)/(maxEvaluations()-1));
            Array fv(x.size());
            std::transform(x.begin(), x.end(), fv.begin(), f);

            increaseNumberOfEvaluations(maxEvaluations());
            return DiscreteSimpsonIntegral()(x, fv);
    }
}
]]></document_content>
  </document>
  <document index="28">
    <source>integrals/exponentialintegrals.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file exponentialintegrals.cpp
*/


#include <ql/errors.hpp>
#include <ql/mathconstants.hpp>
#include <ql/math/integrals/exponentialintegrals.hpp>

#include <cmath>

#ifndef M_EULER_MASCHERONI
    #define M_EULER_MASCHERONI 0.5772156649015328606065121
#endif

namespace QuantLib {
    namespace exponential_integrals_helper {

        // Reference:
        // Rowe et al: GALSIM: The modular galaxy image simulation toolkit
        // https://arxiv.org/abs/1407.7676

        Real f(Real x) {
            const Real x2 = 1.0/(x*x);

            return (
                1 + x2*(7.44437068161936700618e2 + x2*(1.96396372895146869801e5
                  + x2*(2.37750310125431834034e7 + x2*(1.43073403821274636888e9
                  + x2*(4.33736238870432522765e10 + x2*(6.40533830574022022911e11
                  + x2*(4.20968180571076940208e12 + x2*(1.00795182980368574617e13
                  + x2*(4.94816688199951963482e12 - x2*4.94701168645415959931e11)))))))))
                )/(x *(
                1 + x2*(7.46437068161927678031e2 + x2*(1.97865247031583951450e5
                  + x2*(2.41535670165126845144e7 + x2*(1.47478952192985464958e9
                  + x2*(4.58595115847765779830e10 + x2*(7.08501308149515401563e11
                  + x2*(5.06084464593475076774e12 + x2*(1.43468549171581016479e13
                  + x2*1.11535493509914254097e13))))))))
                ) );
        }

        Real g(Real x) {
            const Real x2 = 1.0/(x*x);

            return x2*(
                1 + x2*(8.1359520115168615e2 + x2*(2.35239181626478200e5
                  + x2*(3.12557570795778731e7 + x2*(2.06297595146763354e9
                  + x2*(6.83052205423625007e10 + x2*(1.09049528450362786e12
                  + x2*(7.57664583257834349e12 + x2*(1.81004487464664575e13
                  + x2*(6.43291613143049485e12 - x2*1.36517137670871689e12)))))))))
                )/(
                1 + x2*(8.19595201151451564e2 + x2*(2.40036752835578777e5
                  + x2*(3.26026661647090822e7 + x2*(2.23355543278099360e9
                  + x2*(7.87465017341829930e10 + x2*(1.39866710696414565e12
                  + x2*(1.17164723371736605e13 + x2*(4.01839087307656620e13
                  + x2*3.99653257887490811e13))))))))
                );
        }
    }

    namespace ExponentialIntegral {
        Real Si(Real x) {
            if (x < 0)
                return -Si(-x);
            else if (x <= 4.0) {
                const Real x2 = x*x;

                return x*
                    ( 1 + x2*(-4.54393409816329991e-2 + x2*(1.15457225751016682e-3
                        + x2*(-1.41018536821330254e-5 + x2*(9.43280809438713025e-8
                        + x2*(-3.53201978997168357e-10 + x2*(7.08240282274875911e-13
                        - x2*6.05338212010422477e-16))))))
                    ) / (
                      1 + x2*(1.01162145739225565e-2 + x2*(4.99175116169755106e-5
                        + x2*(1.55654986308745614e-7 + x2*(3.28067571055789734e-10
                        + x2*(4.5049097575386581e-13 + x2*3.21107051193712168e-16)))))
                    );
            }
            else {
                using namespace exponential_integrals_helper;
                return M_PI_2 - f(x)*std::cos(x) - g(x)*std::sin(x);
            }
        }

        Real Ci(Real x) {
            QL_REQUIRE(x >= 0, "x < 0 => Ci(x) = Ci(-x) + i*pi");

            if (x <= 4.0) {
                const Real x2 = x*x;

                return M_EULER_MASCHERONI + std::log(x) +
                    x2* ( -0.25 + x2*(7.51851524438898291e-3 +x2*(-1.27528342240267686e-4
                                + x2*(1.05297363846239184e-6 +x2*(-4.68889508144848019e-9
                                + x2*(1.06480802891189243e-11 - x2*9.93728488857585407e-15)))))
                    ) / (
                         1 + x2*(1.1592605689110735e-2 + x2*(6.72126800814254432e-5
                           + x2*(2.55533277086129636e-7 + x2*(6.97071295760958946e-10
                           + x2*(1.38536352772778619e-12 + x2*(1.89106054713059759e-15
                           + x2*1.39759616731376855e-18))))))
                    );
            }
            else {
                using namespace exponential_integrals_helper;
                return f(x)*std::sin(x) - g(x)*std::cos(x);
            }
        }


        std::complex<Real> E1(std::complex<Real> z) {
            QL_REQUIRE(std::abs(z) <= 25.0, "Insufficient precision for |z| > 25.0");

            std::complex<Real> s(0.0), sn(-z);

            Size n;
            for (n=2; n < 1000 && s + sn/Real(n-1) != s; ++n) {
                s+=sn/Real(n-1);
                sn *= -z/Real(n);
            }

            QL_REQUIRE(n < 1000, "series conversion issue");

            return -M_EULER_MASCHERONI - std::log(z) -s;
        }

        std::complex<Real> Ei(std::complex<Real> z) {
            QL_REQUIRE(std::abs(z) <= 25.0, "Insufficient precision for |z| > 25.0");

            std::complex<Real> s(0.0), sn=z;

            Real nn=1.0;

            Size n;
            for (n=2; n < 1000 && s+sn*nn != s; ++n) {
                s+=sn*nn;

                if ((n & 1) != 0U)
                    nn += 1/(2.0*(n/2) + 1); // NOLINT(bugprone-integer-division)

                sn *= -z / Real(2*n);
            }

            QL_REQUIRE(n < 1000, "series conversion issue");

            return M_EULER_MASCHERONI + std::log(z) + std::exp(0.5*z)*s;
        }

        // Reference:
        // https://functions.wolfram.com/GammaBetaErf/ExpIntegralEi/introductions/ExpIntegrals/ShowAll.html
        std::complex<Real> Si(std::complex<Real> z) {
            const std::complex<Real> i(0.0, 1.0);

            return 0.25*i*(2.0*(Ei(-i*z) - Ei(i*z))
                    + std::log(i/z) - std::log(-i/z) - std::log(-i*z)
                    + std::log(i*z));
        }

        std::complex<Real> Ci(std::complex<Real> z) {
            const std::complex<Real> i(0.0, 1.0);

            return 0.25*(2.0*(Ei(-i*z) + Ei(i*z))
                    + std::log(i/z) + std::log(-i/z) - std::log(-i*z)
                    - std::log(i*z)) + std::log(z);
        }
    }
}
]]></document_content>
  </document>
  <document index="29">
    <source>integrals/filonintegral.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file filonintegral.cpp
    \brief Filon's formulae for sine and cosine Integrals
*/

#include <ql/errors.hpp>
#include <ql/utilities/null.hpp>
#include <ql/math/array.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/integrals/filonintegral.hpp>

#include <cmath>

namespace QuantLib {
    FilonIntegral::FilonIntegral(Type type, Real t, Size intervals)
    : Integrator(Null<Real>(), intervals+1),
      type_(type),
      t_(t),
      intervals_(intervals),
      n_        (intervals/2){
        QL_REQUIRE( !(intervals_ & 1), "number of intervals must be even");
    }

    Real FilonIntegral::integrate(const ext::function<Real (Real)>& f,
                                  Real a, Real b) const {
        const Real h = (b-a)/(2*n_);
        Array x(2*n_+1, a, h);

        const Real theta = t_*h;
        const Real theta2 = theta*theta;
        const Real theta3 = theta2*theta;

        const Real alpha = 1/theta + std::sin(2*theta)/(2*theta2)
            - 2*square<Real>()(std::sin(theta))/theta3;
        const Real beta = 2*( (1+square<Real>()(std::cos(theta)))/theta2
            - std::sin(2*theta)/theta3);
        const Real gamma = 4*(std::sin(theta)/theta3 - std::cos(theta)/theta2);

        Array v(x.size());
        std::transform(x.begin(), x.end(), v.begin(), f);

        ext::function<Real(Real)> f1, f2;
        switch(type_) {
          case Cosine:
            f1 = static_cast<Real(*)(Real)>(std::sin);
            f2 = static_cast<Real(*)(Real)>(std::cos);
            break;
          case Sine:
            f1 = static_cast<Real(*)(Real)>(std::cos);
            f2 = static_cast<Real(*)(Real)>(std::sin);
            break;
          default:
            QL_FAIL("unknown integration type");
        }

        Real c_2n_1 = 0.0;
        Real c_2n = v[0]*f2(t_*a)
            - 0.5*(v[2*n_]*f2(t_*b) + v[0]*f2(t_*a));

        for (Size i=1; i <= n_; ++i) {
            c_2n   += v[2*i]  *f2(t_*x[2*i]);
            c_2n_1 += v[2*i-1]*f2(t_*x[2*i-1]);
        }

        return h*(alpha*(v[2*n_]*f1(t_*x[2*n_]) - v[0]*f1(t_*x[0]))
                  *((type_ == Cosine) ? 1.0 : -1.0)
                 + beta*c_2n + gamma*c_2n_1);
    }
}
]]></document_content>
  </document>
  <document index="30">
    <source>integrals/gaussianorthogonalpolynomial.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gaussianquadratures.hpp
    \brief Integral of a 1-dimensional function using the Gauss quadratures
*/

#include <ql/math/integrals/gaussianorthogonalpolynomial.hpp>
#include <ql/math/distributions/gammadistribution.hpp>
#include <ql/math/comparison.hpp>
#include <ql/errors.hpp>
#include <cmath>

namespace QuantLib {

    Real GaussianOrthogonalPolynomial::value(Size n, Real x) const {
        if (n > 1) {
            return  (x-alpha(n-1)) * value(n-1, x)
                       - beta(n-1) * value(n-2, x);
        }
        else if (n == 1) {
            return x-alpha(0);
        }

        return 1;
    }

    Real GaussianOrthogonalPolynomial::weightedValue(Size n, Real x) const {
        return std::sqrt(w(x))*value(n, x);
    }


    GaussLaguerrePolynomial::GaussLaguerrePolynomial(Real s)
    : s_(s) {
        QL_REQUIRE(s > -1.0, "s must be bigger than -1");
    }

    Real GaussLaguerrePolynomial::mu_0() const {
        return std::exp(GammaFunction().logValue(s_+1));
    }

    Real GaussLaguerrePolynomial::alpha(Size i) const {
        return 2*i+1+s_;
    }

    Real GaussLaguerrePolynomial::beta(Size i) const {
        return i*(i+s_);
    }

    Real GaussLaguerrePolynomial::w(Real x) const {
        return std::pow(x, s_)*std::exp(-x);
    }


    GaussHermitePolynomial::GaussHermitePolynomial(Real mu)
    : mu_(mu) {
        QL_REQUIRE(mu > -0.5, "mu must be bigger than -0.5");
    }

    Real GaussHermitePolynomial::mu_0() const {
        return std::exp(GammaFunction().logValue(mu_+0.5));
    }

    Real GaussHermitePolynomial::alpha(Size) const {
        return 0.0;
    }

    Real GaussHermitePolynomial::beta(Size i) const {
        return (i % 2) != 0U ? i / 2.0 + mu_ : i / 2.0;
    }

    Real GaussHermitePolynomial::w(Real x) const {
        return std::pow(std::fabs(x), 2*mu_)*std::exp(-x*x);
    }

    GaussJacobiPolynomial::GaussJacobiPolynomial(Real alpha, Real beta)
    : alpha_(alpha), beta_ (beta) {
        QL_REQUIRE(alpha_+beta_ > -2.0,"alpha+beta must be bigger than -2");
        QL_REQUIRE(alpha_       > -1.0,"alpha must be bigger than -1");
        QL_REQUIRE(beta_        > -1.0,"beta  must be bigger than -1");
    }

    Real GaussJacobiPolynomial::mu_0() const {
        return std::pow(2.0, alpha_+beta_+1)
            * std::exp( GammaFunction().logValue(alpha_+1)
                        +GammaFunction().logValue(beta_ +1)
                        -GammaFunction().logValue(alpha_+beta_+2));
    }

    Real GaussJacobiPolynomial::alpha(Size i) const {
        Real num = beta_*beta_ - alpha_*alpha_;
        Real denom = (2.0*i+alpha_+beta_)*(2.0*i+alpha_+beta_+2);

        if (close_enough(denom,0.0)) {
            if (!close_enough(num,0.0)) {
                QL_FAIL("can't compute a_k for jacobi integration\n");
            }
            else {
                // l'Hospital
                num  = 2*beta_;
                denom= 2*(2.0*i+alpha_+beta_+1);

                QL_ASSERT(!close_enough(denom,0.0), "can't compute a_k for jacobi integration\n");
            }
        }

        return num / denom;
    }

    Real GaussJacobiPolynomial::beta(Size i) const {
        Real num = 4.0*i*(i+alpha_)*(i+beta_)*(i+alpha_+beta_);
        Real denom = (2.0*i+alpha_+beta_)*(2.0*i+alpha_+beta_)
                   * ((2.0*i+alpha_+beta_)*(2.0*i+alpha_+beta_)-1);

        if (close_enough(denom,0.0)) {
            if (!close_enough(num,0.0)) {
                QL_FAIL("can't compute b_k for jacobi integration\n");
            } else {
                // l'Hospital
                num  = 4.0*i*(i+beta_)* (2.0*i+2*alpha_+beta_);
                denom= 2.0*(2.0*i+alpha_+beta_);
                denom*=denom-1;
                QL_ASSERT(!close_enough(denom,0.0), "can't compute b_k for jacobi integration\n");
            }
        }
        return num / denom;
    }

    Real GaussJacobiPolynomial::w(Real x) const {
        return std::pow(1-x, alpha_)*std::pow(1+x, beta_);
    }


    GaussLegendrePolynomial::GaussLegendrePolynomial()
    : GaussJacobiPolynomial(0.0, 0.0) {
    }

    GaussChebyshev2ndPolynomial::GaussChebyshev2ndPolynomial()
    : GaussJacobiPolynomial(0.5, 0.5) {
    }

    GaussChebyshevPolynomial::GaussChebyshevPolynomial()
    : GaussJacobiPolynomial(-0.5, -0.5) {
    }

    GaussGegenbauerPolynomial::GaussGegenbauerPolynomial(Real lambda)
    : GaussJacobiPolynomial(lambda-0.5, lambda-0.5){
    }

    Real GaussHyperbolicPolynomial::mu_0() const {
        return M_PI;
    }

    Real GaussHyperbolicPolynomial::alpha(Size) const {
        return 0.0;
    }

    Real GaussHyperbolicPolynomial::beta(Size i) const {
        return i != 0U ? M_PI_2 * M_PI_2 * i * i : M_PI;
    }

    Real GaussHyperbolicPolynomial::w(Real x) const {
        return 1/std::cosh(x);
    }

}

]]></document_content>
  </document>
  <document index="31">
    <source>integrals/gaussianquadratures.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Klaus Spanderen
 Copyright (C) 2005 Gary Kennedy

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gaussianquadratures.hpp
    \brief Integral of a 1-dimensional function using the Gauss quadratures
*/

#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/math/matrixutilities/tqreigendecomposition.hpp>
#include <ql/math/matrixutilities/symmetricschurdecomposition.hpp>

namespace QuantLib {

    GaussianQuadrature::GaussianQuadrature(
                                Size n,
                                const GaussianOrthogonalPolynomial& orthPoly)
    : x_(n), w_(n) {

        // set-up matrix to compute the roots and the weights
        Array e(n-1);

        Size i;
        for (i=1; i < n; ++i) {
            x_[i] = orthPoly.alpha(i);
            e[i-1] = std::sqrt(orthPoly.beta(i));
        }
        x_[0] = orthPoly.alpha(0);

        TqrEigenDecomposition tqr(
                               x_, e,
                               TqrEigenDecomposition::OnlyFirstRowEigenVector,
                               TqrEigenDecomposition::Overrelaxation);

        x_ = tqr.eigenvalues();
        const Matrix& ev = tqr.eigenvectors();

        Real mu_0 = orthPoly.mu_0();
        for (i=0; i<n; ++i) {
            w_[i] = mu_0*ev[0][i]*ev[0][i] / orthPoly.w(x_[i]);
        }
    }


    void TabulatedGaussLegendre::order(Size order) {
        switch(order) {
          case(6):
            order_=order; x_=x6; w_=w6; n_=n6;
            break;
          case(7):
            order_=order; x_=x7; w_=w7; n_=n7;
            break;
          case(12):
            order_=order; x_=x12; w_=w12; n_=n12;
            break;
          case(20):
            order_=order; x_=x20; w_=w20; n_=n20;
            break;
          default:
            QL_FAIL("order " << order << " not supported");
        }
    }


    // Abscissas and Weights from Abramowitz and Stegun

    /* order 6 */
    const Real TabulatedGaussLegendre::x6[3] = { 0.238619186083197,
                                                 0.661209386466265,
                                                 0.932469514203152 };

    const Real TabulatedGaussLegendre::w6[3] = { 0.467913934572691,
                                                 0.360761573048139,
                                                 0.171324492379170 };

    const Size TabulatedGaussLegendre::n6 = 3;

    /* order 7 */
    const Real TabulatedGaussLegendre::x7[4] = { 0.000000000000000,
                                                 0.405845151377397,
                                                 0.741531185599394,
                                                 0.949107912342759 };

    const Real TabulatedGaussLegendre::w7[4] = { 0.417959183673469,
                                                 0.381830050505119,
                                                 0.279705391489277,
                                                 0.129484966168870 };

    const Size TabulatedGaussLegendre::n7 = 4;

    /* order 12 */
    const Real TabulatedGaussLegendre::x12[6] = { 0.125233408511469,
                                                  0.367831498998180,
                                                  0.587317954286617,
                                                  0.769902674194305,
                                                  0.904117256370475,
                                                  0.981560634246719 };

    const Real TabulatedGaussLegendre::w12[6] = { 0.249147045813403,
                                                  0.233492536538355,
                                                  0.203167426723066,
                                                  0.160078328543346,
                                                  0.106939325995318,
                                                  0.047175336386512 };

    const Size TabulatedGaussLegendre::n12 = 6;

    /* order 20 */
    const Real TabulatedGaussLegendre::x20[10] = { 0.076526521133497,
                                                   0.227785851141645,
                                                   0.373706088715420,
                                                   0.510867001950827,
                                                   0.636053680726515,
                                                   0.746331906460151,
                                                   0.839116971822219,
                                                   0.912234428251326,
                                                   0.963971927277914,
                                                   0.993128599185095 };

    const Real TabulatedGaussLegendre::w20[10] = { 0.152753387130726,
                                                   0.149172986472604,
                                                   0.142096109318382,
                                                   0.131688638449177,
                                                   0.118194531961518,
                                                   0.101930119817240,
                                                   0.083276741576704,
                                                   0.062672048334109,
                                                   0.040601429800387,
                                                   0.017614007139152 };

    const Size TabulatedGaussLegendre::n20 = 10;

}
]]></document_content>
  </document>
  <document index="32">
    <source>integrals/gausslobattointegral.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gausslabottointegral.cpp
    \brief integral of a one-dimensional function using the adaptive 
    Gauss-Lobatto integral
*/

#include <ql/math/integrals/gausslobattointegral.hpp>

namespace QuantLib {

    const Real GaussLobattoIntegral::alpha_ = std::sqrt(2.0/3.0); 
    const Real GaussLobattoIntegral::beta_  = 1.0/std::sqrt(5.0);
    const Real GaussLobattoIntegral::x1_    = 0.94288241569547971906; 
    const Real GaussLobattoIntegral::x2_    = 0.64185334234578130578;
    const Real GaussLobattoIntegral::x3_    = 0.23638319966214988028;

    GaussLobattoIntegral::GaussLobattoIntegral(Size maxIterations,
                                               Real absAccuracy,
                                               Real relAccuracy,
                                               bool useConvergenceEstimate)
    : Integrator(absAccuracy, maxIterations),
      relAccuracy_(relAccuracy),
      useConvergenceEstimate_(useConvergenceEstimate) {
    }

    Real GaussLobattoIntegral::integrate(
                                     const ext::function<Real (Real)>& f, 
                                     Real a, Real b) const {

        setNumberOfEvaluations(0);
        const Real calcAbsTolerance = calculateAbsTolerance(f, a, b);

        increaseNumberOfEvaluations(2);
        return adaptivGaussLobattoStep(f, a, b, f(a), f(b), calcAbsTolerance);
    }

    Real GaussLobattoIntegral::calculateAbsTolerance(
                                     const ext::function<Real (Real)>& f, 
                                     Real a, Real b) const {
        

        Real relTol = std::max(relAccuracy_, QL_EPSILON);
        
        const Real m = (a+b)/2; 
        const Real h = (b-a)/2;
        const Real y1 = f(a);
        const Real y3 = f(m-alpha_*h);
        const Real y5 = f(m-beta_*h);
        const Real y7 = f(m);
        const Real y9 = f(m+beta_*h);
        const Real y11= f(m+alpha_*h);
        const Real y13= f(b);

        const Real f1 = f(m-x1_*h);
        const Real f2 = f(m+x1_*h);
        const Real f3 = f(m-x2_*h);
        const Real f4 = f(m+x2_*h);
        const Real f5 = f(m-x3_*h);
        const Real f6 = f(m+x3_*h);

        Real acc=h*(0.0158271919734801831*(y1+y13)
                  +0.0942738402188500455*(f1+f2)
                  +0.1550719873365853963*(y3+y11)
                  +0.1888215739601824544*(f3+f4)
                  +0.1997734052268585268*(y5+y9) 
                  +0.2249264653333395270*(f5+f6)
                  +0.2426110719014077338*y7);  
        
        increaseNumberOfEvaluations(13);
        if (acc == 0.0 && (   f1 != 0.0 || f2 != 0.0 || f3 != 0.0
                           || f4 != 0.0 || f5 != 0.0 || f6 != 0.0)) {
            QL_FAIL("can not calculate absolute accuracy "
                    "from relative accuracy");
        }

        Real r = 1.0;
        if (useConvergenceEstimate_) {
            const Real integral2 = (h/6)*(y1+y13+5*(y5+y9));
            const Real integral1 = (h/1470)*(77*(y1+y13)+432*(y3+y11)+
                                             625*(y5+y9)+672*y7);
        
            if (std::fabs(integral2-acc) != 0.0) 
                r = std::fabs(integral1-acc)/std::fabs(integral2-acc);
            if (r == 0.0 || r > 1.0)
                r = 1.0;
        }

        if (relAccuracy_ != Null<Real>())
            return std::min(absoluteAccuracy(), acc*relTol)/(r*QL_EPSILON);
        else {
            return absoluteAccuracy()/(r*QL_EPSILON);
        }
    }
    
    Real GaussLobattoIntegral::adaptivGaussLobattoStep(
                                     const ext::function<Real (Real)>& f,
                                     Real a, Real b, Real fa, Real fb,
                                     Real acc) const {
        QL_REQUIRE(numberOfEvaluations() < maxEvaluations(),
                   "max number of iterations reached");
        
        const Real h=(b-a)/2; 
        const Real m=(a+b)/2;
        
        const Real mll=m-alpha_*h; 
        const Real ml =m-beta_*h; 
        const Real mr =m+beta_*h; 
        const Real mrr=m+alpha_*h;
        
        const Real fmll= f(mll);
        const Real fml = f(ml);
        const Real fm  = f(m);
        const Real fmr = f(mr);
        const Real fmrr= f(mrr);
        increaseNumberOfEvaluations(5);
        
        const Real integral2=(h/6)*(fa+fb+5*(fml+fmr));
        const Real integral1=(h/1470)*(77*(fa+fb)
                                       +432*(fmll+fmrr)+625*(fml+fmr)+672*fm);
        
        // avoid 80 bit logic on x86 cpu
        volatile Real dist = acc + (integral1-integral2);
        if(Real(dist)==acc || mll<=a || b<=mrr) {
            QL_REQUIRE(m>a && b>m,"Interval contains no more machine number");
            return integral1;
        }
        else {
            return  adaptivGaussLobattoStep(f,a,mll,fa,fmll,acc)  
                  + adaptivGaussLobattoStep(f,mll,ml,fmll,fml,acc)
                  + adaptivGaussLobattoStep(f,ml,m,fml,fm,acc)
                  + adaptivGaussLobattoStep(f,m,mr,fm,fmr,acc)
                  + adaptivGaussLobattoStep(f,mr,mrr,fmr,fmrr,acc)
                  + adaptivGaussLobattoStep(f,mrr,b,fmrr,fb,acc);
        }
    }
}
]]></document_content>
  </document>
  <document index="33">
    <source>integrals/integral.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Franois du Vignaud

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/integrals/integral.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    Integrator::Integrator(Real absoluteAccuracy,
                          Size maxEvaluations)
    : absoluteAccuracy_(absoluteAccuracy),
      maxEvaluations_(maxEvaluations) {
        QL_REQUIRE(absoluteAccuracy > QL_EPSILON,
                   std::scientific << "required tolerance (" <<
                   absoluteAccuracy << ") not allowed. It must be > " <<
                   QL_EPSILON);
    }

    void Integrator::setAbsoluteAccuracy(Real accuracy) {
        absoluteAccuracy_= accuracy;
    }

    void Integrator::setMaxEvaluations(Size maxEvaluations) {
        maxEvaluations_ = maxEvaluations;
    }

    Real Integrator::absoluteAccuracy() const {
        return absoluteAccuracy_;
    }

    Size Integrator::maxEvaluations() const {
        return maxEvaluations_;
    }

    Real Integrator::absoluteError() const {
        return absoluteError_;
    }

    void Integrator::setAbsoluteError(Real error) const {
        absoluteError_ = error;
    }

    Size Integrator::numberOfEvaluations() const {
        return evaluations_;
    }

    void Integrator::setNumberOfEvaluations(Size evaluations) const {
        evaluations_ = evaluations;
    }

    void Integrator::increaseNumberOfEvaluations(Size increase) const {
        evaluations_ += increase;
    }

    bool Integrator::integrationSuccess() const {
        return evaluations_ <= maxEvaluations_
            && absoluteError_ <= absoluteAccuracy_;
    }

    Real Integrator::operator()(const ext::function<Real (Real)>& f,
                                Real a,
                                Real b) const {
        evaluations_ = 0;
        if (a == b)
            return 0.0;
        if (b > a)
            return integrate(f, a, b);
        else
            return -integrate(f, b, a);
    }

}
]]></document_content>
  </document>
  <document index="34">
    <source>integrals/kronrodintegral.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Franois du Vignaud

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/integrals/kronrodintegral.hpp>
#include <ql/types.hpp>

namespace QuantLib {

    static Real rescaleError(Real err,
                             const Real resultAbs,
                             const Real resultAsc) {
        err = std::fabs(err) ;
        if (resultAsc != 0 && err != 0){
            Real scale = std::pow((200 * err / resultAsc), 1.5) ;
            if (scale < 1)
                err = resultAsc * scale ;
            else
                err = resultAsc ;
            }
        if (resultAbs > QL_MIN_POSITIVE_REAL / (50 * QL_EPSILON )){
            Real min_err = 50 * QL_EPSILON  * resultAbs ;
            if (min_err > err)
                err = min_err ;
            }
        return err ;
    }

    /* Gauss-Kronrod-Patterson quadrature coefficients for use in
    quadpack routine qng. These coefficients were calculated with
    101 decimal digit arithmetic by L. W. Fullerton, Bell Labs, Nov
    1981. */

    /* x1, abscissae common to the 10-, 21-, 43- and 87-point rule */
    static const Real x1[5] = {
        0.973906528517171720077964012084452,
        0.865063366688984510732096688423493,
        0.679409568299024406234327365114874,
        0.433395394129247190799265943165784,
        0.148874338981631210884826001129720
        } ;

    /* w10, weights of the 10-point formula */
    static const Real w10[5] = {
        0.066671344308688137593568809893332,
        0.149451349150580593145776339657697,
        0.219086362515982043995534934228163,
        0.269266719309996355091226921569469,
        0.295524224714752870173892994651338
        } ;

    /* x2, abscissae common to the 21-, 43- and 87-point rule */
    static const Real x2[5] = {
        0.995657163025808080735527280689003,
        0.930157491355708226001207180059508,
        0.780817726586416897063717578345042,
        0.562757134668604683339000099272694,
        0.294392862701460198131126603103866
        } ;

    /* w21a, weights of the 21-point formula for abscissae x1 */
    static const Real w21a[5] = {
        0.032558162307964727478818972459390,
        0.075039674810919952767043140916190,
        0.109387158802297641899210590325805,
        0.134709217311473325928054001771707,
        0.147739104901338491374841515972068
        } ;

    /* w21b, weights of the 21-point formula for abscissae x2 */
    static const Real w21b[6] = {
        0.011694638867371874278064396062192,
        0.054755896574351996031381300244580,
        0.093125454583697605535065465083366,
        0.123491976262065851077958109831074,
        0.142775938577060080797094273138717,
        0.149445554002916905664936468389821
        } ;

    /* x3, abscissae common to the 43- and 87-point rule */
    static const Real x3[11] = {
        0.999333360901932081394099323919911,
        0.987433402908088869795961478381209,
        0.954807934814266299257919200290473,
        0.900148695748328293625099494069092,
        0.825198314983114150847066732588520,
        0.732148388989304982612354848755461,
        0.622847970537725238641159120344323,
        0.499479574071056499952214885499755,
        0.364901661346580768043989548502644,
        0.222254919776601296498260928066212,
        0.074650617461383322043914435796506
        } ;

    /* w43a, weights of the 43-point formula for abscissae x1, x3 */
    static const Real w43a[10] = {
        0.016296734289666564924281974617663,
        0.037522876120869501461613795898115,
        0.054694902058255442147212685465005,
        0.067355414609478086075553166302174,
        0.073870199632393953432140695251367,
        0.005768556059769796184184327908655,
        0.027371890593248842081276069289151,
        0.046560826910428830743339154433824,
        0.061744995201442564496240336030883,
        0.071387267268693397768559114425516
        } ;

    /* w43b, weights of the 43-point formula for abscissae x3 */
    static const Real w43b[12] = {
        0.001844477640212414100389106552965,
        0.010798689585891651740465406741293,
        0.021895363867795428102523123075149,
        0.032597463975345689443882222526137,
        0.042163137935191811847627924327955,
        0.050741939600184577780189020092084,
        0.058379395542619248375475369330206,
        0.064746404951445885544689259517511,
        0.069566197912356484528633315038405,
        0.072824441471833208150939535192842,
        0.074507751014175118273571813842889,
        0.074722147517403005594425168280423
        } ;

    /* x4, abscissae of the 87-point rule */
    static const Real x4[22] = {
        0.999902977262729234490529830591582,
        0.997989895986678745427496322365960,
        0.992175497860687222808523352251425,
        0.981358163572712773571916941623894,
        0.965057623858384619128284110607926,
        0.943167613133670596816416634507426,
        0.915806414685507209591826430720050,
        0.883221657771316501372117548744163,
        0.845710748462415666605902011504855,
        0.803557658035230982788739474980964,
        0.757005730685495558328942793432020,
        0.706273209787321819824094274740840,
        0.651589466501177922534422205016736,
        0.593223374057961088875273770349144,
        0.531493605970831932285268948562671,
        0.466763623042022844871966781659270,
        0.399424847859218804732101665817923,
        0.329874877106188288265053371824597,
        0.258503559202161551802280975429025,
        0.185695396568346652015917141167606,
        0.111842213179907468172398359241362,
        0.037352123394619870814998165437704
        } ;

    /* w87a, weights of the 87-point formula for abscissae x1, x2, x3 */
    static const Real w87a[21] = {
        0.008148377384149172900002878448190,
        0.018761438201562822243935059003794,
        0.027347451050052286161582829741283,
        0.033677707311637930046581056957588,
        0.036935099820427907614589586742499,
        0.002884872430211530501334156248695,
        0.013685946022712701888950035273128,
        0.023280413502888311123409291030404,
        0.030872497611713358675466394126442,
        0.035693633639418770719351355457044,
        0.000915283345202241360843392549948,
        0.005399280219300471367738743391053,
        0.010947679601118931134327826856808,
        0.016298731696787335262665703223280,
        0.021081568889203835112433060188190,
        0.025370969769253827243467999831710,
        0.029189697756475752501446154084920,
        0.032373202467202789685788194889595,
        0.034783098950365142750781997949596,
        0.036412220731351787562801163687577,
        0.037253875503047708539592001191226
        } ;

    /* w87b, weights of the 87-point formula for abscissae x4    */
    static const Real w87b[23] = {
        0.000274145563762072350016527092881,
        0.001807124155057942948341311753254,
        0.004096869282759164864458070683480,
        0.006758290051847378699816577897424,
        0.009549957672201646536053581325377,
        0.012329447652244853694626639963780,
        0.015010447346388952376697286041943,
        0.017548967986243191099665352925900,
        0.019938037786440888202278192730714,
        0.022194935961012286796332102959499,
        0.024339147126000805470360647041454,
        0.026374505414839207241503786552615,
        0.028286910788771200659968002987960,
        0.030052581128092695322521110347341,
        0.031646751371439929404586051078883,
        0.033050413419978503290785944862689,
        0.034255099704226061787082821046821,
        0.035262412660156681033782717998428,
        0.036076989622888701185500318003895,
        0.036698604498456094498018047441094,
        0.037120549269832576114119958413599,
        0.037334228751935040321235449094698,
        0.037361073762679023410321241766599
        } ;

    Real GaussKronrodNonAdaptive::relativeAccuracy() const {
        return relativeAccuracy_;
    }

    GaussKronrodNonAdaptive::GaussKronrodNonAdaptive(Real absoluteAccuracy,
                                                     Size maxEvaluations,
                                                     Real relativeAccuracy)
    : Integrator(absoluteAccuracy, maxEvaluations),
      relativeAccuracy_(relativeAccuracy) {}

    Real
    GaussKronrodNonAdaptive::integrate(const ext::function<Real (Real)>& f,
                                       Real a,
                                       Real b) const {
        Real result;
        //Size neval;
        Real fv1[5], fv2[5], fv3[5], fv4[5];
        Real savfun[21];  /* array of function values which have been computed */
        Real res10, res21, res43, res87;    /* 10, 21, 43 and 87 point results */
        Real err;
        Real resAbs; /* approximation to the integral of abs(f) */
        Real resasc; /* approximation to the integral of abs(f-i/(b-a)) */
        int k ;

        QL_REQUIRE(a<b, "b must be greater than a)");

        const Real halfLength = 0.5 * (b - a);
        const Real center = 0.5 * (b + a);
        const Real fCenter = f(center);

        // Compute the integral using the 10- and 21-point formula.

        res10 = 0;
        res21 = w21b[5] * fCenter;
        resAbs = w21b[5] * std::fabs(fCenter);

        for (k = 0; k < 5; k++) {
            Real abscissa = halfLength * x1[k];
            Real fval1 = f(center + abscissa);
            Real fval2 = f(center - abscissa);
            Real fval = fval1 + fval2;
            res10 += w10[k] * fval;
            res21 += w21a[k] * fval;
            resAbs += w21a[k] * (std::fabs(fval1) + std::fabs(fval2));
            savfun[k] = fval;
            fv1[k] = fval1;
            fv2[k] = fval2;
        }

        for (k = 0; k < 5; k++) {
            Real abscissa = halfLength * x2[k];
            Real fval1 = f(center + abscissa);
            Real fval2 = f(center - abscissa);
            Real fval = fval1 + fval2;
            res21 += w21b[k] * fval;
            resAbs += w21b[k] * (std::fabs(fval1) + std::fabs(fval2));
            savfun[k + 5] = fval;
            fv3[k] = fval1;
            fv4[k] = fval2;
        }

        result = res21 * halfLength;
        resAbs *= halfLength ;
        Real mean = 0.5 * res21;
        resasc = w21b[5] * std::fabs(fCenter - mean);

        for (k = 0; k < 5; k++)
            resasc += (w21a[k] * (std::fabs(fv1[k] - mean)
                        + std::fabs(fv2[k] - mean))
                        + w21b[k] * (std::fabs(fv3[k] - mean)
                        + std::fabs(fv4[k] - mean)));

        err = rescaleError ((res21 - res10) * halfLength, resAbs, resasc) ;
        resasc *= halfLength ;

        // test for convergence.
        if (err < absoluteAccuracy() || err < relativeAccuracy() * std::fabs(result)){
            setAbsoluteError(err);
            setNumberOfEvaluations(21);
            return result;
        }

        /* compute the integral using the 43-point formula. */

        res43 = w43b[11] * fCenter;

        for (k = 0; k < 10; k++)
            res43 += savfun[k] * w43a[k];

        for (k = 0; k < 11; k++){
            Real abscissa = halfLength * x3[k];
            Real fval = (f(center + abscissa)
                + f(center - abscissa));
            res43 += fval * w43b[k];
            savfun[k + 10] = fval;
            }

        // test for convergence.

        result = res43 * halfLength;
        err = rescaleError ((res43 - res21) * halfLength, resAbs, resasc);

       if (err < absoluteAccuracy() || err < relativeAccuracy() * std::fabs(result)){
            setAbsoluteError(err);
            setNumberOfEvaluations(43);
            return result;
        }

        /* compute the integral using the 87-point formula. */

        res87 = w87b[22] * fCenter;

        for (k = 0; k < 21; k++)
            res87 += savfun[k] * w87a[k];

        for (k = 0; k < 22; k++){
            Real abscissa = halfLength * x4[k];
            res87 += w87b[k] * (f(center + abscissa)
                + f(center - abscissa));
        }

        // test for convergence.
        result = res87 * halfLength ;
        err = rescaleError ((res87 - res43) * halfLength, resAbs, resasc);

        setAbsoluteError(err);
        setNumberOfEvaluations(87);
        return result;
    }

    Real
    GaussKronrodAdaptive::integrate(const ext::function<Real (Real)>& f,
                                    Real a,
                                    Real b) const {
        return integrateRecursively(f, a, b, absoluteAccuracy());
    }

    // weights for 7-point Gauss-Legendre integration
    // (only 4 values out of 7 are given as they are symmetric)
    static const Real g7w[] = { 0.417959183673469,
                                0.381830050505119,
                                0.279705391489277,
                                0.129484966168870 };
    // weights for 15-point Gauss-Kronrod integration
    static const Real k15w[] = { 0.209482141084728,
                                 0.204432940075298,
                                 0.190350578064785,
                                 0.169004726639267,
                                 0.140653259715525,
                                 0.104790010322250,
                                 0.063092092629979,
                                 0.022935322010529 };
    // abscissae (evaluation points)
    // for 15-point Gauss-Kronrod integration
    static const Real k15t[] = { 0.000000000000000,
                                 0.207784955007898,
                                 0.405845151377397,
                                 0.586087235467691,
                                 0.741531185599394,
                                 0.864864423359769,
                                 0.949107912342758,
                                 0.991455371120813 };

    Real GaussKronrodAdaptive::integrateRecursively(
                                    const ext::function<Real (Real)>& f,
                                    Real a,
                                    Real b,
                                    Real tolerance) const {

            Real halflength = (b - a) / 2;
            Real center = (a + b) / 2;

            Real g7; // will be result of G7 integral
            Real k15; // will be result of K15 integral

            Real t, fsum; // t (abscissa) and f(t)
            Real fc = f(center);
            g7 = fc * g7w[0];
            k15 = fc * k15w[0];

            // calculate g7 and half of k15
            Integer j, j2;
            for (j = 1, j2 = 2; j < 4; j++, j2 += 2) {
                t = halflength * k15t[j2];
                fsum = f(center - t) + f(center + t);
                g7  += fsum * g7w[j];
                k15 += fsum * k15w[j2];
            }

            // calculate other half of k15
            for (j2 = 1; j2 < 8; j2 += 2) {
                t = halflength * k15t[j2];
                fsum = f(center - t) + f(center + t);
                k15 += fsum * k15w[j2];
            }

            // multiply by (a - b) / 2
            g7 = halflength * g7;
            k15 = halflength * k15;

            // 15 more function evaluations have been used
            increaseNumberOfEvaluations(15);

            // error is <= k15 - g7
            // if error is larger than tolerance then split the interval
            // in two and integrate recursively
            if (std::fabs(k15 - g7) < tolerance) {
                return k15;
            } else {
                QL_REQUIRE(numberOfEvaluations()+30 <=
                           maxEvaluations(),
                           "maximum number of function evaluations "
                           "exceeded");
                return integrateRecursively(f, a, center, tolerance/2)
                    + integrateRecursively(f, center, b, tolerance/2);
            }
        }


    GaussKronrodAdaptive::GaussKronrodAdaptive(Real absoluteAccuracy,
                                               Size maxEvaluations)
    : Integrator(absoluteAccuracy, maxEvaluations) {
        QL_REQUIRE(maxEvaluations >= 15,
                   "required maxEvaluations (" << maxEvaluations <<
                   ") not allowed. It must be >= 15");
    }
}
]]></document_content>
  </document>
  <document index="35">
    <source>integrals/segmentintegral.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/integrals/segmentintegral.hpp>

namespace QuantLib {

    SegmentIntegral::SegmentIntegral(Size intervals)
    : Integrator(1, 1), intervals_(intervals) {
        QL_REQUIRE(intervals > 0, "at least 1 interval needed, 0 given");
    }

}
]]></document_content>
  </document>
  <document index="36">
    <source>matrix.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file matrix.hpp
    \brief matrix used in linear algebra.
*/

#include <ql/math/matrix.hpp>
#if defined(QL_PATCH_MSVC)
#pragma warning(push)
#pragma warning(disable:4180)
#pragma warning(disable:4127)
#endif

#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#endif

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"
#endif

#if BOOST_VERSION == 106400
#include <boost/serialization/array_wrapper.hpp>
#endif
#include <boost/numeric/ublas/vector_proxy.hpp>
#include <boost/numeric/ublas/triangular.hpp>
#include <boost/numeric/ublas/lu.hpp>

#if defined(QL_PATCH_MSVC)
#pragma warning(pop)
#endif

#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic pop
#endif

#if defined(__clang__)
#pragma clang diagnostic pop
#endif


namespace QuantLib {

    Disposable<Matrix> inverse(const Matrix& m) {
        QL_REQUIRE(m.rows() == m.columns(), "matrix is not square");

        boost::numeric::ublas::matrix<Real> a(m.rows(), m.columns());

        std::copy(m.begin(), m.end(), a.data().begin());

        boost::numeric::ublas::permutation_matrix<Size> pert(m.rows());

        // lu decomposition
        Size singular = 1;
        try {
            singular = lu_factorize(a, pert);
        } catch (const boost::numeric::ublas::internal_logic& e) {
            QL_FAIL("lu_factorize error: " << e.what());
        } catch (const boost::numeric::ublas::external_logic& e) {
            QL_FAIL("lu_factorize error: " << e.what());
        }
        QL_REQUIRE(singular == 0, "singular matrix given");

        boost::numeric::ublas::matrix<Real>
            inverse = boost::numeric::ublas::identity_matrix<Real>(m.rows());

        // backsubstitution
        try {
            boost::numeric::ublas::lu_substitute(a, pert, inverse);
        } catch (const boost::numeric::ublas::internal_logic& e) {
            QL_FAIL("lu_substitute error: " << e.what());
        }

        Matrix retVal(m.rows(), m.columns());
        std::copy(inverse.data().begin(), inverse.data().end(),
                  retVal.begin());

        return retVal;
    }

    Real determinant(const Matrix& m) {
        QL_REQUIRE(m.rows() == m.columns(), "matrix is not square");

        boost::numeric::ublas::matrix<Real> a(m.rows(), m.columns());
        std::copy(m.begin(), m.end(), a.data().begin());


        // lu decomposition
        boost::numeric::ublas::permutation_matrix<Size> pert(m.rows());
        /* const Size singular = */ lu_factorize(a, pert);

        Real retVal = 1.0;

        for (Size i=0; i < m.rows(); ++i) {
            if (pert[i] != i)
                retVal *= -a(i,i);
            else
                retVal *=  a(i,i);
        }
        return retVal;
    }

}
]]></document_content>
  </document>
  <document index="37">
    <source>matrixutilities/basisincompleteordered.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2007, 2008 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/matrixutilities/basisincompleteordered.hpp>
#include <algorithm>

namespace QuantLib {

    BasisIncompleteOrdered::BasisIncompleteOrdered(Size euclideanDimension)
        : euclideanDimension_(euclideanDimension) {}

    bool BasisIncompleteOrdered::addVector(const Array& newVector1) {

        QL_REQUIRE(newVector1.size() == euclideanDimension_,
            "missized vector passed to "
            "BasisIncompleteOrdered::addVector");

        newVector_ = newVector1;

        if (currentBasis_.size()==euclideanDimension_)
            return false;

        for (auto& currentBasi : currentBasis_) {
            Real innerProd =
                std::inner_product(newVector_.begin(), newVector_.end(), currentBasi.begin(), 0.0);

            for (Size k=0; k<euclideanDimension_; ++k)
                newVector_[k] -= innerProd * currentBasi[k];
        }

        Real norm = std::sqrt(std::inner_product(newVector_.begin(),
            newVector_.end(),
            newVector_.begin(), 0.0));

        if (norm<1e-12) // maybe this should be a tolerance
            return false;

        for (Size l=0; l<euclideanDimension_; ++l)
            newVector_[l]/=norm;

        currentBasis_.push_back(newVector_);

        return true;
    }

    Size BasisIncompleteOrdered::basisSize() const {
        return currentBasis_.size();
    }

    Size BasisIncompleteOrdered::euclideanDimension() const {
        return euclideanDimension_;
    }


    Matrix BasisIncompleteOrdered::getBasisAsRowsInMatrix() const {
        Matrix basis(currentBasis_.size(), euclideanDimension_);
        for (Size i=0; i<basis.rows(); ++i)
            for (Size j=0; j<basis.columns(); ++j)
                basis[i][j] = currentBasis_[i][j];

        return basis;
    }

    namespace
    {
        Real normSquared(const Matrix& v, Size row)
        {
            Real x=0.0;
            for (Size i=0; i < v.columns(); ++i)
                x += v[row][i]*v[row][i];

            return x;
        }


        Real norm(const Matrix& v, Size row)
        {
            return std::sqrt(normSquared( v,  row));
        }

        Real innerProduct(const Matrix& v, Size row1, const Matrix& w, Size row2)
        {

            Real x=0.0;
            for (Size i=0; i < v.columns(); ++i)
                x += v[row1][i]*w[row2][i];

            return x;
        }

    }



    OrthogonalProjections::OrthogonalProjections(const Matrix& originalVectors,
                                                 Real multiplierCutoff,
                                                 Real tolerance)
    : originalVectors_(originalVectors),
      multiplierCutoff_(multiplierCutoff),
      numberVectors_(originalVectors.rows()),
      dimension_(originalVectors.columns()),
      validVectors_(true,originalVectors.rows()), // opposite way round from vector constructor
      orthoNormalizedVectors_(originalVectors.rows(),
                              originalVectors.columns())
    {
        std::vector<Real> currentVector(dimension_);
        for (Size j=0; j < numberVectors_; ++j)
        {

            if (validVectors_[j])
            {
                for (Size k=0; k< numberVectors_; ++k) // create an orthormal basis not containing j
                {
                    for (Size m=0; m < dimension_; ++m)
                        orthoNormalizedVectors_[k][m] = originalVectors_[k][m];

                    if ( k !=j && validVectors_[k])
                    {


                        for (Size l=0; l < k; ++l)
                        {
                            if (validVectors_[l] && l !=j)
                            {
                                Real dotProduct = innerProduct(orthoNormalizedVectors_, k, orthoNormalizedVectors_,l);
                                for (Size n=0; n < dimension_; ++n)
                                    orthoNormalizedVectors_[k][n] -=  dotProduct*orthoNormalizedVectors_[l][n];
                            }

                        }

                        Real normBeforeScaling= norm(orthoNormalizedVectors_,k);

                        if (normBeforeScaling < tolerance)
                        {
                            validVectors_[k] = false;
                        }
                        else
                        {
                            Real normBeforeScalingRecip = 1.0/normBeforeScaling;
                            for (Size m=0; m < dimension_; ++m)
                                orthoNormalizedVectors_[k][m] *= normBeforeScalingRecip;

                        } // end of else (norm < tolerance)

                    } // end of if k !=j && validVectors_[k])

                }// end of  for (Size k=0; k< numberVectors_; ++k)

                // we now have an o.n. basis for everything except  j

                Real prevNormSquared = normSquared(originalVectors_, j);


                for (Size r=0; r < numberVectors_; ++r)
                    if (validVectors_[r] && r != j)
                    {
                        Real dotProduct = innerProduct(orthoNormalizedVectors_, j, orthoNormalizedVectors_,r);

                        for (Size s=0; s < dimension_; ++s)
                           orthoNormalizedVectors_[j][s] -= dotProduct*orthoNormalizedVectors_[r][s];

                    }

               Real projectionOnOriginalDirection = innerProduct(originalVectors_,j,orthoNormalizedVectors_,j);
               Real sizeMultiplier = prevNormSquared/projectionOnOriginalDirection;

               if (std::fabs(sizeMultiplier) < multiplierCutoff_)
               {
                    for (Size t=0; t < dimension_; ++t)
                        currentVector[t] = orthoNormalizedVectors_[j][t]*sizeMultiplier;

               }
               else
                   validVectors_[j] = false;


            } // end of  if (validVectors_[j])

            projectedVectors_.push_back(currentVector);


        } //end of j loop

        numberValidVectors_ =0;
        for (Size i=0; i < numberVectors_; ++i)
            numberValidVectors_ +=  validVectors_[i] ? 1 : 0;


    } // end of constructor

    const std::valarray<bool>& OrthogonalProjections::validVectors() const
    {
        return validVectors_;

    }

    const std::vector<Real>& OrthogonalProjections::GetVector(Size index) const
    {
        return projectedVectors_[index];
    }


  Size OrthogonalProjections::numberValidVectors() const
  {
        return numberValidVectors_;
  }




}
]]></document_content>
  </document>
  <document index="38">
    <source>matrixutilities/bicgstab.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Ralph Schreyer
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bicgstab.cpp
    \brief bi-conjugated gradient stableized algorithm
*/


#include <ql/math/matrixutilities/bicgstab.hpp>
#include <utility>

namespace QuantLib {

    BiCGstab::BiCGstab(BiCGstab::MatrixMult A,
                       Size maxIter,
                       Real relTol,
                       BiCGstab::MatrixMult preConditioner)
    : A_(std::move(A)), M_(std::move(preConditioner)), maxIter_(maxIter), relTol_(relTol) {}

    BiCGStabResult BiCGstab::solve(const Array& b, const Array& x0) const {
        Real bnorm2 = Norm2(b);
        if (bnorm2 == 0.0) {
            BiCGStabResult result = { 0, 0.0, b};
            return result;
        }

        Array x = ((!x0.empty()) ? x0 : Array(b.size(), 0.0));
        Array r = b - A_(x);

        Array rTld = r;
        Array p, pTld, v, s, sTld, t;
        Real omega = 1.0;
        Real rho, rhoTld=1.0;
        Real alpha = 0.0, beta;
        Real error = Norm2(r)/bnorm2;

        Size i;
        for (i=0; i < maxIter_ && error >= relTol_; ++i) {
           rho = DotProduct(rTld, r);
           if  (rho == 0.0 || omega == 0.0)
               break;

           if (i != 0U) {
               beta = (rho / rhoTld) * (alpha / omega);
               p = r + beta * (p - omega * v);
           } else {
               p = r;
           }

           pTld = (M_ == QL_NULL_FUNCTION ? p : M_(p));
           v     = A_(pTld);

           alpha = rho/DotProduct(rTld, v);
           s     = r-alpha*v;
           if (Norm2(s) < relTol_*bnorm2) {
              x += alpha*pTld;
              error = Norm2(s)/bnorm2;
              break;
           }

           sTld = (M_ == QL_NULL_FUNCTION ? s : M_(s));
           t = A_(sTld);
           omega = DotProduct(t,s)/DotProduct(t,t);
           x += alpha*pTld + omega*sTld;
           r = s - omega*t;
           error = Norm2(r)/bnorm2;
           rhoTld = rho;
        }

        QL_REQUIRE(i < maxIter_, "max number of iterations exceeded");
        QL_REQUIRE(error < relTol_, "could not converge");

        BiCGStabResult result = { i, error, x};
        return result;
    }

}
]]></document_content>
  </document>
  <document index="39">
    <source>matrixutilities/choleskydecomposition.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2016 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/matrixutilities/choleskydecomposition.hpp>
#include <ql/math/comparison.hpp>

namespace QuantLib {

    Disposable<Matrix> CholeskyDecomposition(const Matrix& S, bool flexible) {
        Size i, j, size = S.rows();

        QL_REQUIRE(size == S.columns(),
                   "input matrix is not a square matrix");
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        for (i=0; i<S.rows(); i++)
            for (j=0; j<i; j++)
                QL_REQUIRE(S[i][j] == S[j][i],
                           "input matrix is not symmetric");
        #endif

        Matrix result(size, size, 0.0);
        Real sum;
        for (i=0; i<size; i++) {
            for (j=i; j<size; j++) {
                sum = S[i][j];
                for (Integer k=0; k<=Integer(i)-1; k++) {
                    sum -= result[i][k]*result[j][k];
                }
                if (i == j) {
                    QL_REQUIRE(flexible || sum > 0.0,
                               "input matrix is not positive definite");
                    // To handle positive semi-definite matrices take the
                    // square root of sum if positive, else zero.
                    result[i][i] = std::sqrt(std::max<Real>(sum, 0.0));
                } else {
                    // With positive semi-definite matrices is possible
                    // to have result[i][i]==0.0
                    // In this case sum happens to be zero as well
                    result[j][i] = close_enough(result[i][i], 0.0)
                                       ? 0.0
                                       : sum / result[i][i];
                }
            }
        }
        return result;
    }
}
]]></document_content>
  </document>
  <document index="40">
    <source>matrixutilities/factorreduction.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Jose Aparicio

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/matrixutilities/factorreduction.hpp>
#include <ql/math/matrixutilities/symmetricschurdecomposition.hpp>
#include <vector>

namespace QuantLib {

    Disposable<std::vector<Real> >
    factorReduction(Matrix mtrx,
                    Size maxIters) {
        static Real tolerance = 1.e-6;

        QL_REQUIRE(mtrx.rows() == mtrx.columns(),
                   "Input matrix is not square");

        const Size n = mtrx.columns();

        #if defined(QL_EXTRA_SAFETY_CHECKS)
        // check symmetry
        for (Size iRow=0; iRow<mtrx.rows(); iRow++)
            for (Size iCol=0; iCol<iRow; iCol++)
                QL_REQUIRE(mtrx[iRow][iCol] == mtrx[iCol][iRow],
                           "input matrix is not symmetric");
        QL_REQUIRE(*std::max_element(mtrx.begin(), mtrx.end()) <=1 &&
            *std::min_element(mtrx.begin(), mtrx.end()) >=-1,
                    "input matrix data is not correlation data");
        #endif

        // Initial guess value
        std::vector<Real> previousCorrels(n, 0.);
        for(Size iCol=0; iCol<n; iCol++) {
            for(Size iRow=0; iRow<n; iRow++)
                previousCorrels[iCol] +=
                    mtrx[iRow][iCol] * mtrx[iRow][iCol];
            previousCorrels[iCol] =
                std::sqrt((previousCorrels[iCol]-1.)/(n-1.));
        }

        // iterative solution
        Size iteration = 0;
        Real distance;
        do {
            // patch Matrix diagonal
            for(Size iCol=0; iCol<n; iCol++)
                mtrx[iCol][iCol] =
                    previousCorrels[iCol];
            // compute eigenvector decomposition
            SymmetricSchurDecomposition ssDec(mtrx);
            //const Matrix& eigenVect = ssDec.eigenvectors();
            const Array&  eigenVals = ssDec.eigenvalues();
            Array::const_iterator itMaxEval =
                std::max_element(eigenVals.begin(), eigenVals.end());
            // We do not need the max value, only the position of the
            //   corresponding eigenvector
            Size iMax = std::distance(eigenVals.begin(), itMaxEval);
            std::vector<Real> newCorrels, distances;
            for(Size iCol=0; iCol<n; iCol++) {
                Real thisCorrel = mtrx[iMax][iCol];
                newCorrels.push_back(thisCorrel);
                // strictly is:
                // abs(\sqrt{\rho}- \sqrt{\rho_{old}})/\sqrt{\rho_{old}}
                distances.push_back(
                    std::abs(thisCorrel - previousCorrels[iCol])/
                        previousCorrels[iCol]);
            }
            previousCorrels = newCorrels;
            distance = *std::max_element(distances.begin(), distances.end());
        }while(distance > tolerance && ++iteration <= maxIters );

        // test it did not go up to the max iteration and the matrix can
        //   be reduced to one factor.
        QL_REQUIRE(iteration < maxIters,
                   "convergence not reached after " <<
                   iteration << " iterations");

        #if defined(QL_EXTRA_SAFETY_CHECKS)
        QL_REQUIRE(*std::max_element(previousCorrels.begin(),
                                     previousCorrels.end()) <=1 &&
                   *std::min_element(previousCorrels.begin(),
                                     previousCorrels.end()) >=-1,
                "matrix can not be decomposed to a single factor dependence");
        #endif

        return previousCorrels;
    }

}
]]></document_content>
  </document>
  <document index="41">
    <source>matrixutilities/getcovariance.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2004, 2007, 2009 Ferdinando Ametrano

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/matrixutilities/getcovariance.hpp>

namespace QuantLib {

    CovarianceDecomposition::CovarianceDecomposition(const Matrix& cov,
                                                     Real tolerance)
    : variances_(cov.diagonal()), stdDevs_(Array(cov.rows())),
      correlationMatrix_(Matrix(cov.rows(), cov.rows()))
    {
        Size size = cov.rows();
        QL_REQUIRE(size==cov.columns(),
                   "input covariance matrix must be square, it is [" <<
                   size << "x" << cov.rows() << "]");

        for (Size i=0; i<size; ++i)
        {
            stdDevs_[i] = std::sqrt(variances_[i]);
            correlationMatrix_[i][i] = 1.0;
            for (Size j=0; j<i; ++j)
            {
                QL_REQUIRE(std::fabs(cov[i][j]-cov[j][i]) <= tolerance,
                           "invalid covariance matrix:" <<
                           "\nc[" << i << ", " << j << "] = " <<
                           cov[i][j] << "\nc[" << j << ", " << i <<
                           "] = " << cov[j][i]);
                correlationMatrix_[i][j] = correlationMatrix_[j][i] =
                    cov[i][j]/(stdDevs_[i]*stdDevs_[j]);
            }
        }
    }
}
]]></document_content>
  </document>
  <document index="42">
    <source>matrixutilities/gmres.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2017 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license0/0 iee along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gmres.cpp
    \brief generalized minimal residual method
*/


#include <ql/math/functional.hpp>
#include <ql/math/matrixutilities/gmres.hpp>
#include <ql/math/matrixutilities/qrdecomposition.hpp>
#include <numeric>
#include <utility>

namespace QuantLib {

    GMRES::GMRES(GMRES::MatrixMult A, Size maxIter, Real relTol, GMRES::MatrixMult preConditioner)
    : A_(std::move(A)), M_(std::move(preConditioner)), maxIter_(maxIter), relTol_(relTol) {

        QL_REQUIRE(maxIter_ > 0, "maxIter must be greater than zero");
    }

    GMRESResult GMRES::solve(const Array& b, const Array& x0) const {
        GMRESResult result = solveImpl(b, x0);

        QL_REQUIRE(result.errors.back() < relTol_, "could not converge");

        return result;
    }

    GMRESResult GMRES::solveWithRestart(
        Size restart, const Array& b, const Array& x0) const {

        GMRESResult result = solveImpl(b, x0);

        std::list<Real> errors = result.errors;

        for (Size i=0; i < restart-1 && result.errors.back() >= relTol_;++i) {
            result = solveImpl(b, result.x);
            errors.insert(
                errors.end(), result.errors.begin(), result.errors.end());
        }

        QL_REQUIRE(errors.back() < relTol_, "could not converge");

        result.errors = errors;
        return result;
    }

    GMRESResult GMRES::solveImpl(const Array& b, const Array& x0) const {
        const Real bn = Norm2(b);
        if (bn == 0.0) {
            GMRESResult result = { std::list<Real>(1, 0.0), b };
            return result;
        }

        Array x = ((!x0.empty()) ? x0 : Array(b.size(), 0.0));
        Array r = b - A_(x);

        const Real g = Norm2(r);
        if (g/bn < relTol_) {
            GMRESResult result = { std::list<Real>(1, g/bn), x };
            return result;
        }

        std::vector<Array> v(1, r/g);
        std::vector<Array> h(1, Array(maxIter_, 0.0));
        std::vector<Real>  c(maxIter_+1), s(maxIter_+1), z(maxIter_+1);

        z[0] = g;

        std::list<Real> errors(1, g/bn);

        for (Size j=0; j < maxIter_ && errors.back() >= relTol_; ++j) {
            h.emplace_back(maxIter_, 0.0);
            Array w = A_(M_ == QL_NULL_FUNCTION ? v[j] : M_(v[j]));

            for (Size i=0; i <= j; ++i) {
                h[i][j] = DotProduct(w, v[i]);
                w -= h[i][j] * v[i];
            }

            h[j+1][j] = Norm2(w);

            if (h[j+1][j] < QL_EPSILON*QL_EPSILON)
                break;

            v.push_back(w / h[j+1][j]);

            for (Size i=0; i < j; ++i) {
                const Real h0 = c[i]*h[i][j] + s[i]*h[i+1][j];
                const Real h1 =-s[i]*h[i][j] + c[i]*h[i+1][j];

                h[i][j]   = h0;
                h[i+1][j] = h1;
            }

            const Real nu = std::sqrt(  square<Real>()(h[j][j])
                                      + square<Real>()(h[j+1][j]));

            c[j] = h[j][j]/nu;
            s[j] = h[j+1][j]/nu;

            h[j][j]   = nu;
            h[j+1][j] = 0.0;

            z[j+1] = -s[j]*z[j];
            z[j] = c[j] * z[j];

            errors.push_back(std::fabs(z[j+1]/bn));
        }

        const Size k = v.size()-1;

        Array y(k, 0.0);
        y[k-1]=z[k-1]/h[k-1][k-1];

        for (Integer i=k-2; i >= 0; --i) {
            y[i] = (z[i] - std::inner_product(
                 h[i].begin()+i+1, h[i].begin()+k, y.begin()+i+1, 0.0))/h[i][i];
        }

        Array xm = std::inner_product(
            v.begin(), v.begin()+k, y.begin(), Array(x.size(), 0.0));

        xm = x + (M_ == QL_NULL_FUNCTION ? xm : M_(xm));

        GMRESResult result = { errors, xm };
        return result;
    }

}
]]></document_content>
  </document>
  <document index="43">
    <source>matrixutilities/pseudosqrt.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004, 2007 Ferdinando Ametrano
 Copyright (C) 2006 Yiping Chen
 Copyright (C) 2007 Neil Firth

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/comparison.hpp>
#include <ql/math/matrixutilities/choleskydecomposition.hpp>
#include <ql/math/matrixutilities/pseudosqrt.hpp>
#include <ql/math/matrixutilities/symmetricschurdecomposition.hpp>
#include <ql/math/optimization/conjugategradient.hpp>
#include <ql/math/optimization/constraint.hpp>
#include <ql/math/optimization/problem.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        #if defined(QL_EXTRA_SAFETY_CHECKS)
        void checkSymmetry(const Matrix& matrix) {
            Size size = matrix.rows();
            QL_REQUIRE(size == matrix.columns(),
                       "non square matrix: " << size << " rows, " <<
                       matrix.columns() << " columns");
            for (Size i=0; i<size; ++i)
                for (Size j=0; j<i; ++j)
                    QL_REQUIRE(close(matrix[i][j], matrix[j][i]),
                               "non symmetric matrix: " <<
                               "[" << i << "][" << j << "]=" << matrix[i][j] <<
                               ", [" << j << "][" << i << "]=" << matrix[j][i]);
        }
        #endif

        void normalizePseudoRoot(const Matrix& matrix,
                                 Matrix& pseudo) {
            Size size = matrix.rows();
            QL_REQUIRE(size == pseudo.rows(),
                       "matrix/pseudo mismatch: matrix rows are " << size <<
                       " while pseudo rows are " << pseudo.columns());
            Size pseudoCols = pseudo.columns();

            // row normalization
            for (Size i=0; i<size; ++i) {
                Real norm = 0.0;
                for (Size j=0; j<pseudoCols; ++j)
                    norm += pseudo[i][j]*pseudo[i][j];
                if (norm>0.0) {
                    Real normAdj = std::sqrt(matrix[i][i]/norm);
                    for (Size j=0; j<pseudoCols; ++j)
                        pseudo[i][j] *= normAdj;
                }
            }


        }

        //cost function for hypersphere and lower-diagonal algorithm
        class HypersphereCostFunction : public CostFunction {
          private:
            Size size_;
            bool lowerDiagonal_;
            Matrix targetMatrix_;
            Array targetVariance_;
            mutable Matrix currentRoot_, tempMatrix_, currentMatrix_;
          public:
            HypersphereCostFunction(const Matrix& targetMatrix,
                                    Array targetVariance,
                                    bool lowerDiagonal)
            : size_(targetMatrix.rows()), lowerDiagonal_(lowerDiagonal),
              targetMatrix_(targetMatrix), targetVariance_(std::move(targetVariance)),
              currentRoot_(size_, size_), tempMatrix_(size_, size_), currentMatrix_(size_, size_) {}
            Disposable<Array> values(const Array&) const override {
                QL_FAIL("values method not implemented");
            }
            Real value(const Array& x) const override {
                Size i,j,k;
                std::fill(currentRoot_.begin(), currentRoot_.end(), 1.0);
                if (lowerDiagonal_) {
                    for (i=0; i<size_; i++) {
                        for (k=0; k<size_; k++) {
                            if (k>i) {
                                currentRoot_[i][k]=0;
                            } else {
                                for (j=0; j<=k; j++) {
                                    if (j == k && k!=i)
                                        currentRoot_[i][k] *=
                                            std::cos(x[i*(i-1)/2+j]);
                                    else if (j!=i)
                                        currentRoot_[i][k] *=
                                            std::sin(x[i*(i-1)/2+j]);
                                }
                            }
                        }
                    }
                } else {
                    for (i=0; i<size_; i++) {
                        for (k=0; k<size_; k++) {
                            for (j=0; j<=k; j++) {
                                if (j == k && k!=size_-1)
                                    currentRoot_[i][k] *=
                                        std::cos(x[j*size_+i]);
                                else if (j!=size_-1)
                                    currentRoot_[i][k] *=
                                        std::sin(x[j*size_+i]);
                            }
                        }
                    }
                }
                Real temp, error=0;
                tempMatrix_ = transpose(currentRoot_);
                currentMatrix_ = currentRoot_ * tempMatrix_;
                for (i=0;i<size_;i++) {
                    for (j=0;j<size_;j++) {
                        temp = currentMatrix_[i][j]*targetVariance_[i]
                          *targetVariance_[j]-targetMatrix_[i][j];
                        error += temp*temp;
                    }
                }
                return error;
            }
        };

        // Optimization function for hypersphere and lower-diagonal algorithm
        Disposable<Matrix> hypersphereOptimize(const Matrix& targetMatrix,
                                               const Matrix& currentRoot,
                                               const bool lowerDiagonal) {
            Size i,j,k,size = targetMatrix.rows();
            Matrix result(currentRoot);
            Array variance(size, 0);
            for (i=0; i<size; i++){
                variance[i]=std::sqrt(targetMatrix[i][i]);
            }
            if (lowerDiagonal) {
                Matrix approxMatrix(result*transpose(result));
                result = CholeskyDecomposition(approxMatrix, true);
                for (i=0; i<size; i++) {
                    for (j=0; j<size; j++) {
                        result[i][j]/=std::sqrt(approxMatrix[i][i]);
                    }
                }
            } else {
                for (i=0; i<size; i++) {
                    for (j=0; j<size; j++) {
                        result[i][j]/=variance[i];
                    }
                }
            }

            ConjugateGradient optimize;
            EndCriteria endCriteria(100, 10, 1e-8, 1e-8, 1e-8);
            HypersphereCostFunction costFunction(targetMatrix, variance,
                                                 lowerDiagonal);
            NoConstraint constraint;

            // hypersphere vector optimization

            if (lowerDiagonal) {
                Array theta(size * (size-1)/2);
                const Real eps=1e-16;
                for (i=1; i<size; i++) {
                    for (j=0; j<i; j++) {
                        theta[i*(i-1)/2+j]=result[i][j];
                        if (theta[i*(i-1)/2+j]>1-eps)
                            theta[i*(i-1)/2+j]=1-eps;
                        if (theta[i*(i-1)/2+j]<-1+eps)
                            theta[i*(i-1)/2+j]=-1+eps;
                        for (k=0; k<j; k++) {
                            theta[i*(i-1)/2+j] /= std::sin(theta[i*(i-1)/2+k]);
                            if (theta[i*(i-1)/2+j]>1-eps)
                                theta[i*(i-1)/2+j]=1-eps;
                            if (theta[i*(i-1)/2+j]<-1+eps)
                                theta[i*(i-1)/2+j]=-1+eps;
                        }
                        theta[i*(i-1)/2+j] = std::acos(theta[i*(i-1)/2+j]);
                        if (j==i-1) {
                            if (result[i][i]<0)
                                theta[i*(i-1)/2+j]=-theta[i*(i-1)/2+j];
                        }
                    }
                }
                Problem p(costFunction, constraint, theta);
                optimize.minimize(p, endCriteria);
                theta = p.currentValue();
                std::fill(result.begin(),result.end(),1.0);
                for (i=0; i<size; i++) {
                    for (k=0; k<size; k++) {
                        if (k>i) {
                            result[i][k]=0;
                        } else {
                            for (j=0; j<=k; j++) {
                                if (j == k && k!=i)
                                    result[i][k] *=
                                        std::cos(theta[i*(i-1)/2+j]);
                                else if (j!=i)
                                    result[i][k] *=
                                        std::sin(theta[i*(i-1)/2+j]);
                            }
                        }
                    }
                }
            } else {
                Array theta(size * (size-1));
                const Real eps=1e-16;
                for (i=0; i<size; i++) {
                    for (j=0; j<size-1; j++) {
                        theta[j*size+i]=result[i][j];
                        if (theta[j*size+i]>1-eps)
                            theta[j*size+i]=1-eps;
                        if (theta[j*size+i]<-1+eps)
                            theta[j*size+i]=-1+eps;
                        for (k=0;k<j;k++) {
                            theta[j*size+i] /= std::sin(theta[k*size+i]);
                            if (theta[j*size+i]>1-eps)
                                theta[j*size+i]=1-eps;
                            if (theta[j*size+i]<-1+eps)
                                theta[j*size+i]=-1+eps;
                        }
                        theta[j*size+i] = std::acos(theta[j*size+i]);
                        if (j==size-2) {
                            if (result[i][j+1]<0)
                                theta[j*size+i]=-theta[j*size+i];
                        }
                    }
                }
                Problem p(costFunction, constraint, theta);
                optimize.minimize(p, endCriteria);
                theta=p.currentValue();
                std::fill(result.begin(),result.end(),1.0);
                for (i=0; i<size; i++) {
                    for (k=0; k<size; k++) {
                        for (j=0; j<=k; j++) {
                            if (j == k && k!=size-1)
                                result[i][k] *= std::cos(theta[j*size+i]);
                            else if (j!=size-1)
                                result[i][k] *= std::sin(theta[j*size+i]);
                        }
                    }
                }
            }

            for (i=0; i<size; i++) {
                for (j=0; j<size; j++) {
                    result[i][j]*=variance[i];
                }
            }
            return result;
        }

        // Matrix infinity norm. See Golub and van Loan (2.3.10) or
        // <http://en.wikipedia.org/wiki/Matrix_norm>
        Real normInf(const Matrix& M) {
            Size rows = M.rows();
            Size cols = M.columns();
            Real norm = 0.0;
            for (Size i=0; i<rows; ++i) {
                Real colSum = 0.0;
                for (Size j=0; j<cols; ++j)
                    colSum += std::fabs(M[i][j]);
                norm = std::max(norm, colSum);
            }
            return norm;
        }

        // Take a matrix and make all the diagonal entries 1.
        Disposable<Matrix> projectToUnitDiagonalMatrix(const Matrix& M) {
            Size size = M.rows();
            QL_REQUIRE(size == M.columns(),
                       "matrix not square");

            Matrix result(M);
            for (Size i=0; i<size; ++i)
                result[i][i] = 1.0;

            return result;
        }

        // Take a matrix and make all the eigenvalues non-negative
        Disposable<Matrix> projectToPositiveSemidefiniteMatrix(Matrix& M) {
            Size size = M.rows();
            QL_REQUIRE(size == M.columns(),
                       "matrix not square");

            Matrix diagonal(size, size, 0.0);
            SymmetricSchurDecomposition jd(M);
            for (Size i=0; i<size; ++i)
                diagonal[i][i] = std::max<Real>(jd.eigenvalues()[i], 0.0);

            Matrix result =
                jd.eigenvectors()*diagonal*transpose(jd.eigenvectors());
            return result;
        }

        // implementation of the Higham algorithm to find the nearest
        // correlation matrix.
        Disposable<Matrix>
        highamImplementation(const Matrix& A, const Size maxIterations, const Real& tolerance) {

            Size size = A.rows();
            Matrix R, Y(A), X(A), deltaS(size, size, 0.0);

            Matrix lastX(X);
            Matrix lastY(Y);

            for (Size i=0; i<maxIterations; ++i) {
                R = Y - deltaS;
                X = projectToPositiveSemidefiniteMatrix(R);
                deltaS = X - R;
                Y = projectToUnitDiagonalMatrix(X);

                // convergence test
                if (std::max(normInf(X-lastX)/normInf(X),
                        std::max(normInf(Y-lastY)/normInf(Y),
                                normInf(Y-X)/normInf(Y)))
                        <= tolerance)
                {
                    break;
                }
                lastX = X;
                lastY = Y;
            }

            // ensure we return a symmetric matrix
            for (Size i=0; i<size; ++i)
                for (Size j=0; j<i; ++j)
                    Y[i][j] = Y[j][i];

            return Y;
        }
    }


    Disposable<Matrix> pseudoSqrt(const Matrix& matrix, SalvagingAlgorithm::Type sa) {
        Size size = matrix.rows();

        #if defined(QL_EXTRA_SAFETY_CHECKS)
        checkSymmetry(matrix);
        #else
        QL_REQUIRE(size == matrix.columns(),
                   "non square matrix: " << size << " rows, " <<
                   matrix.columns() << " columns");
        #endif

        // spectral (a.k.a Principal Component) analysis
        SymmetricSchurDecomposition jd(matrix);
        Matrix diagonal(size, size, 0.0);

        // salvaging algorithm
        Matrix result(size, size);
        bool negative;
        switch (sa) {
          case SalvagingAlgorithm::None:
            // eigenvalues are sorted in decreasing order
            QL_REQUIRE(jd.eigenvalues()[size-1]>=-1e-16,
                       "negative eigenvalue(s) ("
                       << std::scientific << jd.eigenvalues()[size-1]
                       << ")");
            result = CholeskyDecomposition(matrix, true);
            break;
          case SalvagingAlgorithm::Spectral:
            // negative eigenvalues set to zero
            for (Size i=0; i<size; i++)
                diagonal[i][i] =
                    std::sqrt(std::max<Real>(jd.eigenvalues()[i], 0.0));

            result = jd.eigenvectors() * diagonal;
            normalizePseudoRoot(matrix, result);
            break;
          case SalvagingAlgorithm::Hypersphere:
            // negative eigenvalues set to zero
            negative=false;
            for (Size i=0; i<size; ++i){
                diagonal[i][i] =
                    std::sqrt(std::max<Real>(jd.eigenvalues()[i], 0.0));
                if (jd.eigenvalues()[i]<0.0) negative=true;
            }
            result = jd.eigenvectors() * diagonal;
            normalizePseudoRoot(matrix, result);

            if (negative)
                result = hypersphereOptimize(matrix, result, false);
            break;
          case SalvagingAlgorithm::LowerDiagonal:
            // negative eigenvalues set to zero
            negative=false;
            for (Size i=0; i<size; ++i){
                diagonal[i][i] =
                    std::sqrt(std::max<Real>(jd.eigenvalues()[i], 0.0));
                if (jd.eigenvalues()[i]<0.0) negative=true;
            }
            result = jd.eigenvectors() * diagonal;

            normalizePseudoRoot(matrix, result);

            if (negative)
                result = hypersphereOptimize(matrix, result, true);
            break;
          case SalvagingAlgorithm::Higham: {
              int maxIterations = 40;
              Real tol = 1e-6;
              result = highamImplementation(matrix, maxIterations, tol);
              result = CholeskyDecomposition(result, true);
            }
            break;
          default:
            QL_FAIL("unknown salvaging algorithm");
        }

        return result;
    }


    Disposable<Matrix> rankReducedSqrt(const Matrix& matrix,
                                       Size maxRank,
                                       Real componentRetainedPercentage,
                                       SalvagingAlgorithm::Type sa) {
        Size size = matrix.rows();

        #if defined(QL_EXTRA_SAFETY_CHECKS)
        checkSymmetry(matrix);
        #else
        QL_REQUIRE(size == matrix.columns(),
                   "non square matrix: " << size << " rows, " <<
                   matrix.columns() << " columns");
        #endif

        QL_REQUIRE(componentRetainedPercentage>0.0,
                   "no eigenvalues retained");

        QL_REQUIRE(componentRetainedPercentage<=1.0,
                   "percentage to be retained > 100%");

        QL_REQUIRE(maxRank>=1,
                   "max rank required < 1");

        // spectral (a.k.a Principal Component) analysis
        SymmetricSchurDecomposition jd(matrix);
        Array eigenValues = jd.eigenvalues();

        // salvaging algorithm
        switch (sa) {
          case SalvagingAlgorithm::None:
            // eigenvalues are sorted in decreasing order
            QL_REQUIRE(eigenValues[size-1]>=-1e-16,
                       "negative eigenvalue(s) ("
                       << std::scientific << eigenValues[size-1]
                       << ")");
            break;
          case SalvagingAlgorithm::Spectral:
            // negative eigenvalues set to zero
            for (Size i=0; i<size; ++i)
                eigenValues[i] = std::max<Real>(eigenValues[i], 0.0);
            break;
          case SalvagingAlgorithm::Higham:
              {
                  int maxIterations = 40;
                  Real tolerance = 1e-6;
                  Matrix adjustedMatrix = highamImplementation(matrix, maxIterations, tolerance);
                  jd = SymmetricSchurDecomposition(adjustedMatrix);
                  eigenValues = jd.eigenvalues();
              }
              break;
          default:
            QL_FAIL("unknown or invalid salvaging algorithm");
        }

        // factor reduction
        Real enough = componentRetainedPercentage *
                      std::accumulate(eigenValues.begin(),
                                      eigenValues.end(), Real(0.0));
        if (componentRetainedPercentage == 1.0) {
            // numerical glitches might cause some factors to be discarded
            enough *= 1.1;
        }
        // retain at least one factor
        Real components = eigenValues[0];
        Size retainedFactors = 1;
        for (Size i=1; components<enough && i<size; ++i) {
            components += eigenValues[i];
            retainedFactors++;
        }
        // output is granted to have a rank<=maxRank
        retainedFactors=std::min(retainedFactors, maxRank);

        Matrix diagonal(size, retainedFactors, 0.0);
        for (Size i=0; i<retainedFactors; ++i)
            diagonal[i][i] = std::sqrt(eigenValues[i]);
        Matrix result = jd.eigenvectors() * diagonal;

        normalizePseudoRoot(matrix, result);
        return result;
    }
}
]]></document_content>
  </document>
  <document index="44">
    <source>matrixutilities/qrdecomposition.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file qrdecomposition.cpp
    \brief QR decomposition
*/

#include <ql/math/optimization/lmdif.hpp>
#include <ql/math/matrixutilities/qrdecomposition.hpp>
#include <memory>

namespace QuantLib {

    Disposable<std::vector<Size> > qrDecomposition(const Matrix& M,
                                                   Matrix& q, Matrix& r,
                                                   bool pivot) {
        Matrix mT = transpose(M);
        const Size m = M.rows();
        const Size n = M.columns();

        std::unique_ptr<int[]> lipvt(new int[n]);
        std::unique_ptr<Real[]> rdiag(new Real[n]);
        std::unique_ptr<Real[]> wa(new Real[n]);

        MINPACK::qrfac(m, n, mT.begin(), 0, (pivot)?1:0,
                       lipvt.get(), n, rdiag.get(), rdiag.get(), wa.get());
        if (r.columns() != n || r.rows() !=n)
            r = Matrix(n, n);

        for (Size i=0; i < n; ++i) {
            std::fill(r.row_begin(i), r.row_begin(i)+i, 0.0);
            r[i][i] = rdiag[i];
            if (i < m) {
                std::copy(mT.column_begin(i)+i+1, mT.column_end(i),
                          r.row_begin(i)+i+1);
            }
            else {
                std::fill(r.row_begin(i)+i+1, r.row_end(i), 0.0);
            }
        }

        if (q.rows() != m || q.columns() != n)
            q = Matrix(m, n);

        if (m > n) {
            std::fill(q.begin(), q.end(), 0.0);

            Integer u = std::min(n,m);
            for (Integer i=0; i < u; ++i)
                q[i][i] = 1.0;

            Array v(m);
            for (Integer i=u-1; i >=0; --i) {
                if (std::fabs(mT[i][i]) > QL_EPSILON) {
                    const Real tau = 1.0/mT[i][i];

                    std::fill(v.begin(), v.begin()+i, 0.0);
                    std::copy(mT.row_begin(i)+i, mT.row_end(i), v.begin()+i);

                    Array w(n, 0.0);
                    for (Size l=0; l < n; ++l)
                        w[l] += std::inner_product(
                            v.begin()+i, v.end(), q.column_begin(l)+i, 0.0);

                    for (Size k=i; k < m; ++k) {
                        const Real a = tau*v[k];
                        for (Size l=0; l < n; ++l)
                            q[k][l] -= a*w[l];
                    }
                }
            }
        }
        else {
            Array w(m);
            for (Size k=0; k < m; ++k) {
                std::fill(w.begin(), w.end(), 0.0);
                w[k] = 1.0;

                for (Size j=0; j < std::min(n, m); ++j) {
                    const Real t3 = mT[j][j];
                    if (t3 != 0.0) {
                        const Real t
                            = std::inner_product(mT.row_begin(j)+j, mT.row_end(j),
                                                 w.begin()+j, 0.0)/t3;
                        for (Size i=j; i<m; ++i) {
                            w[i]-=mT[j][i]*t;
                        }
                    }
                    q[k][j] = w[j];
                }
                std::fill(q.row_begin(k) + std::min(n, m), q.row_end(k), 0.0);
            }
        }

        std::vector<Size> ipvt(n);

        if (pivot) {
            std::copy(lipvt.get(), lipvt.get()+n, ipvt.begin());
        }
        else {
            for (Size i=0; i < n; ++i)
                ipvt[i] = i;
        }

        return ipvt;
    }

    Disposable<Array> qrSolve(const Matrix& a, const Array& b,
                              bool pivot, const Array& d) {
        const Size m = a.rows();
        const Size n = a.columns();

        QL_REQUIRE(b.size() == m, "dimensions of A and b don't match");
        QL_REQUIRE(d.size() == n || d.empty(),
                   "dimensions of A and d don't match");

        Matrix q(m, n), r(n, n);

        std::vector<Size> lipvt = qrDecomposition(a, q, r, pivot);

        std::unique_ptr<int[]> ipvt(new int[n]);
        std::copy(lipvt.begin(), lipvt.end(), ipvt.get());

        Matrix rT = transpose(r);

        std::unique_ptr<Real[]> sdiag(new Real[n]);
        std::unique_ptr<Real[]> wa(new Real[n]);

        Array ld(n, 0.0);
        if (!d.empty()) {
            std::copy(d.begin(), d.end(), ld.begin());
        }

        Array x(n);
        Array qtb = transpose(q)*b;

        MINPACK::qrsolv(n, rT.begin(), n, ipvt.get(),
                        ld.begin(), qtb.begin(),
                        x.begin(), sdiag.get(), wa.get());

        return x;
    }
}
]]></document_content>
  </document>
  <document index="45">
    <source>matrixutilities/sparseilupreconditioner.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2009 Ralph Schreyer

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/matrixutilities/sparseilupreconditioner.hpp>
#include <ql/math/matrix.hpp>

#include <set>

namespace QuantLib {

    using namespace boost::numeric::ublas;

    SparseILUPreconditioner::SparseILUPreconditioner(const SparseMatrix& A,
                                                     Integer lfil)
    : L_(A.size1(),A.size2()),
      U_(A.size1(),A.size2()) {

        QL_REQUIRE(A.size1() == A.size2(),
                   "sparse ILU preconditioner works only with square matrices");

        for (SparseMatrix::size_type i=0; i < L_.size1(); ++i)
            L_(i,i) = 1.0;

        const Integer n = A.size1();
        std::set<Integer> lBandSet, uBandSet;

        compressed_matrix<Integer> levs(n,n);
        Integer lfilp = lfil + 1;

        for (Integer ii=0; ii<n; ++ii) {
            Array w(n);
            for(Integer k=0; k<n; ++k) {
                w[k] = A(ii,k);
            }

            std::vector<Integer> levii(n, 0);
            for (Integer i=0; i<n; ++i) {
                if(   w[i] > QL_EPSILON
                      || w[i] < -1.0*QL_EPSILON) levii[i] = 1;
            }
            Integer jj = -1;
            while (jj < ii) {
                for (Integer k=jj+1; k<n; ++k) {
                    if (levii[k] != 0) {
                        jj = k;
                        break;
                    }
                }
                if (jj >= ii) {
                    break;
                }
                Integer jlev = levii[jj];
                if (jlev <= lfilp) {
                    std::vector<Integer> nonZeros;
                    std::vector<Real> nonZeroEntries;
                    nonZeros.reserve(uBandSet.size()+1);
                    nonZeroEntries.reserve(uBandSet.size()+1);
                    const Real entry = U_(jj,jj);
                    if(entry > QL_EPSILON || entry < -1.0*QL_EPSILON) {
                        nonZeros.push_back(jj);
                        nonZeroEntries.push_back(entry);
                    }
                    auto iter = uBandSet.begin();
                    auto end = uBandSet.end();
                    for (; iter != end; ++iter) {
                        const Real entry = U_(jj,jj+*iter);
                        if(entry > QL_EPSILON || entry < -1.0*QL_EPSILON) {
                            nonZeros.push_back(jj+*iter);
                            nonZeroEntries.push_back(entry);
                        }
                    }
                    Real fact = w[jj];
                    if(!nonZeroEntries.empty()) {
                        fact /= nonZeroEntries[0];
                    }
                    for (Size k=0; k<nonZeros.size(); ++k) {
                        const Integer j = nonZeros[k] ;
                        const Integer temp = levs(jj,j) + jlev ;
                        if (levii[j] == 0) {
                            if (temp <= lfilp) {
                                w[j] =  - fact*nonZeroEntries[k];
                                levii[j] = temp;
                            }
                        }
                        else {
                            w[j] -= fact*nonZeroEntries[k];
                            levii[j] = std::min(levii[j],temp);
                        }
                    }
                    w[jj] = fact;
                }
            }
            std::vector<Integer> wNonZeros;
            std::vector<Real> wNonZeroEntries;
            wNonZeros.reserve(w.size());
            wNonZeroEntries.reserve(w.size());
            for (Size i=0; i<w.size(); ++i) {
                const Real entry = w[i];
                if(entry > QL_EPSILON || entry < -1.0*QL_EPSILON) {
                    wNonZeros.push_back(i);
                    wNonZeroEntries.push_back(entry);
                }
            }
            std::vector<Integer> leviiNonZeroEntries;
            leviiNonZeroEntries.reserve(levii.size());
            for (int entry : levii) {
                if (entry > QL_EPSILON || entry < -1.0 * QL_EPSILON) {
                    leviiNonZeroEntries.push_back(entry);
                }
            }
            for (Size k=0; k<wNonZeros.size(); ++k) {
                Integer j = wNonZeros[k];
                if (j < ii) {
                    L_(ii,j) = wNonZeroEntries[k];
                    lBandSet.insert(ii-j);
                }
                else {
                    U_(ii,j) = wNonZeroEntries[k];
                    levs(ii,j) = leviiNonZeroEntries[k];
                    if(j-ii > 0) {
                        uBandSet.insert(j-ii);
                    }
                }
            }
        }
        lBands_.resize(lBandSet.size());
        uBands_.resize(uBandSet.size());
        std::copy(lBandSet.begin(), lBandSet.end(), lBands_.begin());
        std::copy(uBandSet.begin(), uBandSet.end(), uBands_.begin());
    }

    const SparseMatrix& SparseILUPreconditioner::L() const {
        return L_;
    }

    const SparseMatrix& SparseILUPreconditioner::U() const {
        return U_;
    }

    Disposable<Array> SparseILUPreconditioner::apply(const Array& b) const {
        return backwardSolve(forwardSolve(b));
    }

    Disposable<Array> SparseILUPreconditioner::forwardSolve(
                                                       const Array& b) const {
        Integer n = b.size();
        Array y(n, 0.0);
        y[0]=b[0]/L_(0,0);
        for (Integer i=1; i<=n-1; ++i) {
            y[i] = b[i]/L_(i,i);
            for (Integer j=lBands_.size()-1;
                 j>=0 && i-Integer(lBands_[j]) <= i-1; --j) {
                const Integer k = i-Integer(lBands_[j]);
                if (k >= 0)
                    y[i]-=L_(i,k)*y[k]/L_(i,i);
            }
        }
        return y;
    }

    Disposable<Array> SparseILUPreconditioner::backwardSolve(
                                                       const Array& y) const {
        Size n = y.size();
        Array x(n, 0.0);
        x[n-1] = y[n-1]/U_(n-1,n-1);
        for (Integer i=n-2; i>=0; --i) {
            x[i] = y[i]/U_(i,i);
            for (Size j=0; j<uBands_.size() && i+uBands_[j] <= n-1; ++j) {
                x[i] -= U_(i,i+uBands_[j])*x[i+uBands_[j]]/U_(i,i);
            }
        }
        return x;
    }

}

]]></document_content>
  </document>
  <document index="46">
    <source>matrixutilities/svd.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Neil Firth

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.

        Adapted from the TNT project
        http://math.nist.gov/tnt/download.html

        This software was developed at the National Institute of Standards
        and Technology (NIST) by employees of the Federal Government in the
        course of their official duties. Pursuant to title 17 Section 105
        of the United States Code this software is not subject to copyright
        protection and is in the public domain. NIST assumes no responsibility
        whatsoever for its use by other parties, and makes no guarantees,
        expressed or implied, about its quality, reliability, or any other
        characteristic.

        We would appreciate acknowledgement if the software is incorporated in
        redistributable libraries or applications.
*/


#include <ql/math/matrixutilities/svd.hpp>

namespace QuantLib {

    namespace {

        /*  returns hypotenuse of real (non-complex) scalars a and b by
            avoiding underflow/overflow
            using (a * sqrt( 1 + (b/a) * (b/a))), rather than
            sqrt(a*a + b*b).
        */
        Real hypot(const Real &a, const Real &b) {
            if (a == 0) {
                return std::fabs(b);
            } else {
                Real c = b/a;
                return std::fabs(a) * std::sqrt(1 + c*c);
            }
        }

    }


    SVD::SVD(const Matrix& M) {

        using std::swap;

        Matrix A;

        /* The implementation requires that rows > columns.
           If this is not the case, we decompose M^T instead.
           Swapping the resulting U and V gives the desired
           result for M as

           M^T = U S V^T           (decomposition of M^T)

           M = (U S V^T)^T         (transpose)

           M = (V^T^T S^T U^T)     ((AB)^T = B^T A^T)

           M = V S U^T             (idempotence of transposition,
                                    symmetry of diagonal matrix S)

        */

        if (M.rows() >= M.columns()) {
            A = M;
            transpose_ = false;
        } else {
            A = transpose(M);
            transpose_ = true;
        }

        m_ = A.rows();
        n_ = A.columns();

        // we're sure that m_ >= n_

        s_ = Array(n_);
        U_ = Matrix(m_,n_, 0.0);
        V_ = Matrix(n_,n_);
        Array e(n_);
        Array work(m_);
        Integer i, j, k;

        // Reduce A to bidiagonal form, storing the diagonal elements
        // in s and the super-diagonal elements in e.

        Integer nct = std::min(m_-1,n_);
        Integer nrt = std::max(0,n_-2);
        for (k = 0; k < std::max(nct,nrt); k++) {
            if (k < nct) {

                // Compute the transformation for the k-th column and
                // place the k-th diagonal in s[k].
                // Compute 2-norm of k-th column without under/overflow.
                s_[k] = 0;
                for (i = k; i < m_; i++) {
                    s_[k] = hypot(s_[k],A[i][k]);
                }
                if (s_[k] != 0.0) {
                    if (A[k][k] < 0.0) {
                        s_[k] = -s_[k];
                    }
                    for (i = k; i < m_; i++) {
                        A[i][k] /= s_[k];
                    }
                    A[k][k] += 1.0;
                }
                s_[k] = -s_[k];
            }
            for (j = k+1; j < n_; j++) {
                if ((k < nct) && (s_[k] != 0.0))  {

                    // Apply the transformation.

                    Real t = 0;
                    for (i = k; i < m_; i++) {
                        t += A[i][k]*A[i][j];
                    }
                    t = -t/A[k][k];
                    for (i = k; i < m_; i++) {
                        A[i][j] += t*A[i][k];
                    }
                }

                // Place the k-th row of A into e for the
                // subsequent calculation of the row transformation.

                e[j] = A[k][j];
            }
            if (k < nct) {

                // Place the transformation in U for subsequent back
                // multiplication.

                for (i = k; i < m_; i++) {
                    U_[i][k] = A[i][k];
                }
            }
            if (k < nrt) {

                // Compute the k-th row transformation and place the
                // k-th super-diagonal in e[k].
                // Compute 2-norm without under/overflow.
                e[k] = 0;
                for (i = k+1; i < n_; i++) {
                    e[k] = hypot(e[k],e[i]);
                }
                if (e[k] != 0.0) {
                    if (e[k+1] < 0.0) {
                        e[k] = -e[k];
                    }
                    for (i = k+1; i < n_; i++) {
                        e[i] /= e[k];
                    }
                    e[k+1] += 1.0;
                }
                e[k] = -e[k];
                if ((k+1 < m_) && (e[k] != 0.0)) {

                    // Apply the transformation.

                    for (i = k+1; i < m_; i++) {
                        work[i] = 0.0;
                    }
                    for (j = k+1; j < n_; j++) {
                        for (i = k+1; i < m_; i++) {
                            work[i] += e[j]*A[i][j];
                        }
                    }
                    for (j = k+1; j < n_; j++) {
                        Real t = -e[j]/e[k+1];
                        for (i = k+1; i < m_; i++) {
                            A[i][j] += t*work[i];
                        }
                    }
                }

                // Place the transformation in V for subsequent
                // back multiplication.

                for (i = k+1; i < n_; i++) {
                    V_[i][k] = e[i];
                }
            }
        }

        // Set up the final bidiagonal matrix or order n.

        if (nct < n_) {
            s_[nct] = A[nct][nct];
        }
        if (nrt+1 < n_) {
            e[nrt] = A[nrt][n_-1];
        }
        e[n_-1] = 0.0;

        // generate U

        for (j = nct; j < n_; j++) {
            for (i = 0; i < m_; i++) {
                U_[i][j] = 0.0;
            }
            U_[j][j] = 1.0;
        }
        for (k = nct-1; k >= 0; --k) {
            if (s_[k] != 0.0) {
                for (j = k+1; j < n_; ++j) {
                    Real t = 0;
                    for (i = k; i < m_; i++) {
                        t += U_[i][k]*U_[i][j];
                    }
                    t = -t/U_[k][k];
                    for (i = k; i < m_; i++) {
                        U_[i][j] += t*U_[i][k];
                    }
                }
                for (i = k; i < m_; i++ ) {
                    U_[i][k] = -U_[i][k];
                }
                U_[k][k] = 1.0 + U_[k][k];
                for (i = 0; i < k-1; i++) {
                    U_[i][k] = 0.0;
                }
            } else {
                for (i = 0; i < m_; i++) {
                    U_[i][k] = 0.0;
                }
                U_[k][k] = 1.0;
            }
        }

        // generate V

        for (k = n_-1; k >= 0; --k) {
            if ((k < nrt) && (e[k] != 0.0)) {
                for (j = k+1; j < n_; ++j) {
                    Real t = 0;
                    for (i = k+1; i < n_; i++) {
                        t += V_[i][k]*V_[i][j];
                    }
                    t = -t/V_[k+1][k];
                    for (i = k+1; i < n_; i++) {
                        V_[i][j] += t*V_[i][k];
                    }
                }
            }
            for (i = 0; i < n_; i++) {
                V_[i][k] = 0.0;
            }
            V_[k][k] = 1.0;
        }

        // Main iteration loop for the singular values.

        Integer p = n_, pp = p-1;
        Integer iter = 0;
        Real eps = std::pow(2.0,-52.0);
        while (p > 0) {
            Integer k;
            Integer kase;

            // Here is where a test for too many iterations would go.

            // This section of the program inspects for
            // negligible elements in the s and e arrays.  On
            // completion the variables kase and k are set as follows.

            // kase = 1     if s(p) and e[k-1] are negligible and k<p
            // kase = 2     if s(k) is negligible and k<p
            // kase = 3     if e[k-1] is negligible, k<p, and
            //              s(k), ..., s(p) are not negligible (qr step).
            // kase = 4     if e(p-1) is negligible (convergence).

            for (k = p-2; k >= -1; --k) {
                if (k == -1) {
                    break;
                }
                if (std::fabs(e[k]) <= eps*(std::fabs(s_[k]) +
                                            std::fabs(s_[k+1]))) {
                    e[k] = 0.0;
                    break;
                }
            }
            if (k == p-2) {
                kase = 4;
            } else {
                Integer ks;
                for (ks = p-1; ks >= k; --ks) {
                    if (ks == k) {
                        break;
                    }
                    Real t = (ks != p ? std::fabs(e[ks]) : 0.) +
                        (ks != k+1 ? std::fabs(e[ks-1]) : 0.);
                    if (std::fabs(s_[ks]) <= eps*t)  {
                        s_[ks] = 0.0;
                        break;
                    }
                }
                if (ks == k) {
                    kase = 3;
                } else if (ks == p-1) {
                    kase = 1;
                } else {
                    kase = 2;
                    k = ks;
                }
            }
            k++;

            // Perform the task indicated by kase.

            switch (kase) {

                // Deflate negligible s(p).

              case 1: {
                  Real f = e[p-2];
                  e[p-2] = 0.0;
                  for (j = p-2; j >= k; --j) {
                      Real t = hypot(s_[j],f);
                      Real cs = s_[j]/t;
                      Real sn = f/t;
                      s_[j] = t;
                      if (j != k) {
                          f = -sn*e[j-1];
                          e[j-1] = cs*e[j-1];
                      }
                      for (i = 0; i < n_; i++) {
                          t = cs*V_[i][j] + sn*V_[i][p-1];
                          V_[i][p-1] = -sn*V_[i][j] + cs*V_[i][p-1];
                          V_[i][j] = t;
                      }
                  }
              }
                break;

                // Split at negligible s(k).

              case 2: {
                  Real f = e[k-1];
                  e[k-1] = 0.0;
                  for (j = k; j < p; j++) {
                      Real t = hypot(s_[j],f);
                      Real cs = s_[j]/t;
                      Real sn = f/t;
                      s_[j] = t;
                      f = -sn*e[j];
                      e[j] = cs*e[j];
                      for (i = 0; i < m_; i++) {
                          t = cs*U_[i][j] + sn*U_[i][k-1];
                          U_[i][k-1] = -sn*U_[i][j] + cs*U_[i][k-1];
                          U_[i][j] = t;
                      }
                  }
              }
                break;

                // Perform one qr step.

              case 3: {

                  // Calculate the shift.
                  Real scale = std::max(
                                     std::max(
                                         std::max(
                                             std::max(std::fabs(s_[p-1]),
                                                    std::fabs(s_[p-2])),
                                             std::fabs(e[p-2])),
                                         std::fabs(s_[k])),
                                     std::fabs(e[k]));
                  Real sp = s_[p-1]/scale;
                  Real spm1 = s_[p-2]/scale;
                  Real epm1 = e[p-2]/scale;
                  Real sk = s_[k]/scale;
                  Real ek = e[k]/scale;
                  Real b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;
                  Real c = (sp*epm1)*(sp*epm1);
                  Real shift = 0.0;
                  if ((b != 0.0) || (c != 0.0)) {
                      shift = std::sqrt(b*b + c);
                      if (b < 0.0) {
                          shift = -shift;
                      }
                      shift = c/(b + shift);
                  }
                  Real f = (sk + sp)*(sk - sp) + shift;
                  Real g = sk*ek;

                  // Chase zeros.

                  for (j = k; j < p-1; j++) {
                      Real t = hypot(f,g);
                      Real cs = f/t;
                      Real sn = g/t;
                      if (j != k) {
                          e[j-1] = t;
                      }
                      f = cs*s_[j] + sn*e[j];
                      e[j] = cs*e[j] - sn*s_[j];
                      g = sn*s_[j+1];
                      s_[j+1] = cs*s_[j+1];
                      for (i = 0; i < n_; i++) {
                          t = cs*V_[i][j] + sn*V_[i][j+1];
                          V_[i][j+1] = -sn*V_[i][j] + cs*V_[i][j+1];
                          V_[i][j] = t;
                      }
                      t = hypot(f,g);
                      cs = f/t;
                      sn = g/t;
                      s_[j] = t;
                      f = cs*e[j] + sn*s_[j+1];
                      s_[j+1] = -sn*e[j] + cs*s_[j+1];
                      g = sn*e[j+1];
                      e[j+1] = cs*e[j+1];
                      if (j < m_-1) {
                          for (i = 0; i < m_; i++) {
                              t = cs*U_[i][j] + sn*U_[i][j+1];
                              U_[i][j+1] = -sn*U_[i][j] + cs*U_[i][j+1];
                              U_[i][j] = t;
                          }
                      }
                  }
                  e[p-2] = f;
                  iter = iter + 1;
              }
                break;

                // Convergence.

              case 4: {

                  // Make the singular values positive.

                  if (s_[k] <= 0.0) {
                      s_[k] = (s_[k] < 0.0 ? -s_[k] : 0.0);
                      for (i = 0; i <= pp; i++) {
                          V_[i][k] = -V_[i][k];
                      }
                  }

                  // Order the singular values.

                  while (k < pp) {
                      if (s_[k] >= s_[k+1]) {
                          break;
                      }
                      swap(s_[k], s_[k+1]);
                      if (k < n_-1) {
                          for (i = 0; i < n_; i++) {
                              swap(V_[i][k], V_[i][k+1]);
                          }
                      }
                      if (k < m_-1) {
                          for (i = 0; i < m_; i++) {
                              swap(U_[i][k], U_[i][k+1]);
                          }
                      }
                      k++;
                  }
                  iter = 0;
                  --p;
              }
                break;
            }
        }
    }

    const Matrix& SVD::U() const {
        return (transpose_ ? V_ : U_);
    }

    const Matrix& SVD::V() const {
        return (transpose_ ? U_ : V_);
    }

    const Array& SVD::singularValues() const {
        return s_;
    }

    Disposable<Matrix> SVD::S() const {
        Matrix S(n_,n_);
        for (Size i = 0; i < Size(n_); i++) {
            for (Size j = 0; j < Size(n_); j++) {
                S[i][j] = 0.0;
            }
            S[i][i] = s_[i];
        }
        return S;
    }

    Real SVD::norm2() const {
        return s_[0];
    }

    Real SVD::cond() const {
        return s_[0]/s_[n_-1];
    }

    Size SVD::rank() const {
        Real eps = QL_EPSILON;
        Real tol = m_*s_[0]*eps;
        Size r = 0;
        for (double i : s_) {
            if (i > tol) {
                r++;
            }
        }
        return r;
    }

    Disposable<Array> SVD::solveFor(const Array& b) const{
        Matrix W(n_, n_, 0.0);
        const Size numericalRank = this->rank();
        for (Size i=0; i<numericalRank; i++)
            W[i][i] = 1./s_[i];

        Matrix inverse = V()* W * transpose(U());
        Array result = inverse * b;
        return result;
    }

}

]]></document_content>
  </document>
  <document index="47">
    <source>matrixutilities/symmetricschurdecomposition.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/matrixutilities/symmetricschurdecomposition.hpp>
#include <vector>

namespace QuantLib {

    SymmetricSchurDecomposition::SymmetricSchurDecomposition(const Matrix & s)
    : diagonal_(s.rows()), eigenVectors_(s.rows(), s.columns(), 0.0) {

        QL_REQUIRE(s.rows() > 0 && s.columns() > 0, "null matrix given");
        QL_REQUIRE(s.rows()==s.columns(), "input matrix must be square");

        Size size = s.rows();
        for (Size q=0; q<size; q++) {
            diagonal_[q] = s[q][q];
            eigenVectors_[q][q] = 1.0;
        }
        Matrix ss = s;

        std::vector<Real> tmpDiag(diagonal_.begin(), diagonal_.end());
        std::vector<Real> tmpAccumulate(size, 0.0);
        Real threshold, epsPrec = 1e-15;
        bool keeplooping = true;
        Size maxIterations = 100, ite = 1;
        do {
            //main loop
            Real sum = 0;
            for (Size a=0; a<size-1; a++) {
                for (Size b=a+1; b<size; b++) {
                    sum += std::fabs(ss[a][b]);
                }
            }

            if (sum==0) {
                keeplooping = false;
            } else {
                /* To speed up computation a threshold is introduced to
                   make sure it is worthy to perform the Jacobi rotation
                */
                if (ite<5) threshold = 0.2*sum/(size*size);
                else       threshold = 0.0;

                Size j, k, l;
                for (j=0; j<size-1; j++) {
                    for (k=j+1; k<size; k++) {
                        Real sine, rho, cosin, heig, tang, beta;
                        Real smll = std::fabs(ss[j][k]);
                        if(ite> 5 &&
                           smll<epsPrec*std::fabs(diagonal_[j]) &&
                           smll<epsPrec*std::fabs(diagonal_[k])) {
                                ss[j][k] = 0;
                        } else if (std::fabs(ss[j][k])>threshold) {
                            heig = diagonal_[k]-diagonal_[j];
                            if (smll<epsPrec*std::fabs(heig)) {
                                tang = ss[j][k]/heig;
                            } else {
                                beta = 0.5*heig/ss[j][k];
                                tang = 1.0/(std::fabs(beta)+
                                    std::sqrt(1+beta*beta));
                                if (beta<0)
                                    tang = -tang;
                            }
                            cosin = 1/std::sqrt(1+tang*tang);
                            sine = tang*cosin;
                            rho = sine/(1+cosin);
                            heig = tang*ss[j][k];
                            tmpAccumulate[j] -= heig;
                            tmpAccumulate[k] += heig;
                            diagonal_[j] -= heig;
                            diagonal_[k] += heig;
                            ss[j][k] = 0.0;
                            for (l=0; l+1<=j; l++)
                                jacobiRotate_(ss, rho, sine, l, j, l, k);
                            for (l=j+1; l<=k-1; l++)
                                jacobiRotate_(ss, rho, sine, j, l, l, k);
                            for (l=k+1; l<size; l++)
                                jacobiRotate_(ss, rho, sine, j, l, k, l);
                            for (l=0;   l<size; l++)
                                jacobiRotate_(eigenVectors_,
                                                  rho, sine, l, j, l, k);
                        }
                    }
                }
                for (k=0; k<size; k++) {
                    tmpDiag[k] += tmpAccumulate[k];
                    diagonal_[k] = tmpDiag[k];
                    tmpAccumulate[k] = 0.0;
                }
            }
        } while (++ite<=maxIterations && keeplooping);

        QL_ENSURE(ite<=maxIterations,
                  "Too many iterations (" << maxIterations << ") reached");


        // sort (eigenvalues, eigenvectors)
        std::vector<std::pair<Real, std::vector<Real> > > temp(size);
        std::vector<Real> eigenVector(size);
        Size row, col;
        for (col=0; col<size; col++) {
            std::copy(eigenVectors_.column_begin(col),
                      eigenVectors_.column_end(col), eigenVector.begin());
            temp[col] = std::make_pair(diagonal_[col], eigenVector);
        }
        std::sort(temp.begin(), temp.end(),
            std::greater<std::pair<Real, std::vector<Real> > >());
        Real maxEv = temp[0].first;
        for (col=0; col<size; col++) {
            // check for round-off errors
            diagonal_[col] =
                (std::fabs(temp[col].first/maxEv)<1e-16 ? 0.0 :
                                                          temp[col].first);
            Real sign = 1.0;
            if (temp[col].second[0]<0.0)
                sign = -1.0;
            for (row=0; row<size; row++) {
                eigenVectors_[row][col] = sign * temp[col].second[row];
            }
        }
    }

}
]]></document_content>
  </document>
  <document index="48">
    <source>matrixutilities/tapcorrelations.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Franois du Vignaud

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/matrixutilities/tapcorrelations.hpp>
#include <cmath>

namespace QuantLib {

    Disposable<Matrix> triangularAnglesParametrization(const Array& angles,
                                                       Size matrixSize,
                                                       Size rank) {

        // what if rank == 1?
        QL_REQUIRE((rank-1) * (2*matrixSize - rank) == 2*angles.size(),
                    "rank-1) * (matrixSize - rank/2) == angles.size()");
        Matrix m(matrixSize, matrixSize);

        // first row filling
        m[0][0] = 1.0;
        for (Size j=1; j<matrixSize; ++j)
            m[0][j] = 0.0;

        // next ones...
        Size k = 0; //angles index
        for (Size i=1; i<m.rows(); ++i) {
            Real sinProduct = 1.0;
            Size bound = std::min(i,rank-1);
            for (Size j=0; j<bound; ++j) {
                m[i][j] = std::cos(angles[k]);
                m[i][j] *= sinProduct;
                sinProduct *= std::sin(angles[k]);
                ++k;
            }
            m[i][bound] = sinProduct;
            for (Size j=bound+1; j<m.rows(); ++j)
                m[i][j] = 0;
        }
        return m;
    }

    Disposable<Matrix> lmmTriangularAnglesParametrization(const Array& angles,
                                                          Size matrixSize,
                                                          Size) {
        Matrix m(matrixSize, matrixSize);
        for (Size i=0; i<m.rows(); ++i) {
            Real cosPhi, sinPhi;
            if (i>0) {
                cosPhi = std::cos(angles[i-1]);
                sinPhi = std::sin(angles[i-1]);
            } else {
                cosPhi = 1.0;
                sinPhi = 0.0;
            }

            for (Size j=0; j<i; ++j)
                m[i][j] = sinPhi * m[i-1][j];

            m[i][i] = cosPhi;

            for (Size j=i+1; j<m.rows(); ++j)
                m[i][j] = 0.0;
        }
        return m;
    }

    Disposable<Matrix> triangularAnglesParametrizationUnconstrained(
                                                            const Array& x,
                                                            Size matrixSize,
                                                            Size rank) {
        Array angles(x.size());
        //we convert the unconstrained parameters in angles
        for (Size i = 0; i < x.size(); ++i)
            angles[i] = M_PI*.5 - std::atan(x[i]);
        return triangularAnglesParametrization(angles, matrixSize, rank);
    }

    Disposable<Matrix> lmmTriangularAnglesParametrizationUnconstrained(
                                                            const Array& x,
                                                            Size matrixSize,
                                                            Size rank) {
        Array angles(x.size());
        //we convert the unconstrained parameters in angles
        for (Size i = 0; i < x.size(); ++i)
            angles[i] = M_PI*.5 - std::atan(x[i]);
        return lmmTriangularAnglesParametrization(angles, matrixSize, rank);
    }

    Disposable<Matrix> triangularAnglesParametrizationRankThree(
                                            Real alpha, Real t0,
                                            Real epsilon, Size matrixSize) {
        Matrix m(matrixSize, 3);
        for (Size i=0; i<m.rows(); ++i) {
            Real t = t0 * (1 - std::exp(epsilon*Real(i)));
            Real phi = std::atan(alpha * t);
            m[i][0] = std::cos(t)*std::cos(phi);
            m[i][1] = std::sin(t)*std::cos(phi);
            m[i][2] = -std::sin(phi);
        }
        return m;
    }

    Disposable<Matrix> triangularAnglesParametrizationRankThreeVectorial(
                                                    const Array& parameters,
                                                    Size nbRows) {
        QL_REQUIRE(parameters.size() == 3,
                   "the parameter array must contain exactly 3 values" );
        return triangularAnglesParametrizationRankThree(parameters[0],
                                                        parameters[1],
                                                        parameters[2],
                                                        nbRows);

    }

    Real FrobeniusCostFunction::value(const Array& x) const {
        Array temp = values(x);
        return DotProduct(temp, temp);
    }

    Disposable<Array> FrobeniusCostFunction::values(const Array& x) const {
        Array result((target_.rows()*(target_.columns()-1))/2);
        Matrix pseudoRoot = f_(x, matrixSize_, rank_);
        Matrix differences = pseudoRoot * transpose(pseudoRoot) - target_;
        Size k = 0;
        // then we store the elementwise differences in a vector.
        for (Size i=0; i<target_.rows(); ++i) {
            for (Size j=0; j<i; ++j){
                result[k] = differences[i][j];
                ++k;
            }
        }
        return result;
    }
}
]]></document_content>
  </document>
  <document index="49">
    <source>matrixutilities/tqreigendecomposition.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file tqreigendecomposition.hpp
    \brief tridiag. QR eigen decompositions with implicit shift
*/

#include <ql/math/matrixutilities/tqreigendecomposition.hpp>
#include <vector>

namespace QuantLib {

    TqrEigenDecomposition::TqrEigenDecomposition(const Array& diag,
                                                 const Array& sub,
                                                 EigenVectorCalculation calc,
                                                 ShiftStrategy strategy)
    : iter_(0), d_(diag),
      ev_((calc == WithEigenVector)? d_.size() :
          (calc == WithoutEigenVector)? 0 : 1, d_.size(), 0)
    {
        Size n = diag.size();

        QL_REQUIRE(n == sub.size()+1, "Wrong dimensions");

        Array e(n, 0.0);
        std::copy(sub.begin(),sub.end(),e.begin()+1);
        for (Size i=0; i < ev_.rows(); ++i) {
            ev_[i][i] = 1.0;
        }

        for (Size k=n-1; k >=1; --k) {
            while (!offDiagIsZero(k, e)) {
                Size l = k;
                while (--l > 0 && !offDiagIsZero(l,e));
                iter_++;

                Real q = d_[l];
                if (strategy != NoShift) {
                    // calculated eigenvalue of 2x2 sub matrix of
                    // [ d_[k-1] e_[k] ]
                    // [  e_[k]  d_[k] ]
                    // which is closer to d_[k+1].
                    // FLOATING_POINT_EXCEPTION
                    const Real t1 = std::sqrt(
                                          0.25*(d_[k]*d_[k] + d_[k-1]*d_[k-1])
                                          - 0.5*d_[k-1]*d_[k] + e[k]*e[k]);
                    const Real t2 = 0.5*(d_[k]+d_[k-1]);

                    const Real lambda =
                        (std::fabs(t2+t1 - d_[k]) < std::fabs(t2-t1 - d_[k]))?
                        t2+t1 : t2-t1;

                    if (strategy == CloseEigenValue) {
                        q-=lambda;
                    } else {
                        q-=((k==n-1)? 1.25 : 1.0)*lambda;
                    }
                }

                // the QR transformation
                Real sine = 1.0;
                Real cosine = 1.0;
                Real u = 0.0;

                bool recoverUnderflow = false;
                for (Size i=l+1; i <= k && !recoverUnderflow; ++i) {
                    const Real h = cosine*e[i];
                    const Real p = sine*e[i];

                    e[i-1] = std::sqrt(p*p+q*q);
                    if (e[i-1] != 0.0) {
                        sine = p/e[i-1];
                        cosine = q/e[i-1];

                        const Real g = d_[i-1]-u;
                        const Real t = (d_[i]-g)*sine+2*cosine*h;

                        u = sine*t;
                        d_[i-1] = g + u;
                        q = cosine*t - h;

                        for (Size j=0; j < ev_.rows(); ++j) {
                            const Real tmp = ev_[j][i-1];
                            ev_[j][i-1] = sine*ev_[j][i] + cosine*tmp;
                            ev_[j][i] = cosine*ev_[j][i] - sine*tmp;
                        }
                    } else {
                        // recover from underflow
                        d_[i-1] -= u;
                        e[l] = 0.0;
                        recoverUnderflow = true;
                    }
                }

                if (!recoverUnderflow) {
                    d_[k] -= u;
                    e[k] = q;
                    e[l] = 0.0;
                }
            }
        }

        // sort (eigenvalues, eigenvectors),
        // code taken from symmetricSchureDecomposition.cpp
        std::vector<std::pair<Real, std::vector<Real> > > temp(n);
        std::vector<Real> eigenVector(ev_.rows());
        for (Size i=0; i<n; i++) {
            if (ev_.rows() > 0)
                std::copy(ev_.column_begin(i),
                          ev_.column_end(i), eigenVector.begin());
            temp[i] = std::make_pair(d_[i], eigenVector);
        }
        std::sort(temp.begin(), temp.end(),
                  std::greater<std::pair<Real, std::vector<Real> > >());
        // first element is positive
        for (Size i=0; i<n; i++) {
            d_[i] = temp[i].first;
            Real sign = 1.0;
            if (ev_.rows() > 0 && temp[i].second[0]<0.0)
                sign = -1.0;
            for (Size j=0; j<ev_.rows(); ++j) {
                ev_[j][i] = sign * temp[i].second[j];
            }
        }
    }

    // see NR for abort assumption as it is
    // not part of the original Wilkinson algorithm
    bool TqrEigenDecomposition::offDiagIsZero(Size k, Array& e) {
        return std::fabs(d_[k-1])+std::fabs(d_[k])
            == std::fabs(d_[k-1])+std::fabs(d_[k])+std::fabs(e[k]);
    }

}
]]></document_content>
  </document>
  <document index="50">
    <source>modifiedbessel.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file modifiedbessel.cpp
    \brief modified Bessel functions of first and second kind
*/

#include <ql/math/modifiedbessel.hpp>
#include <ql/math/distributions/gammadistribution.hpp>

#include <cmath>

namespace QuantLib {

    namespace {

        template <class T>  struct I {};
        template <> struct I<Real> { Real value() { return 0.0;} };
        template <> struct I<std::complex<Real> > {
            std::complex<Real> value() { return std::complex<Real>(0.0,1.0);}
        };
        template <class T> struct Unweighted {
            T weightSmallX(const T& x) { return 1.0; }
            T weight1LargeX(const T& x) { return std::exp(x); }
            T weight2LargeX(const T& x) { return std::exp(-x); }
        };
        template <class T> struct ExponentiallyWeighted {
            T weightSmallX(const T& x) { return std::exp(-x); }
            T weight1LargeX(const T& x) { return 1.0; }
            T weight2LargeX(const T& x) { return std::exp(-2.0*x); }
        };

        template <class T, template <class> class W>
        T modifiedBesselFunction_i_impl(Real nu, const T& x) {
            if (std::abs(x) < 13.0) {
                const T alpha = std::pow(0.5*x, nu)
                               /GammaFunction().value(1.0+nu);
                const T Y = 0.25*x*x;
                Size k=1;
                T sum=alpha, B_k=alpha;

                while (std::abs(B_k*=Y/(k*(k+nu)))>std::abs(sum)*QL_EPSILON) {
                    sum += B_k;
                    QL_REQUIRE(++k < 1000, "max iterations exceeded");
                }
                return sum * W<T>().weightSmallX(x);
            }
            else {
                Real na_k=1.0, sign=1.0;
                T da_k=T(1.0);

                T s1=T(1.0), s2=T(1.0);
                for (Size k=1; k < 30; ++k) {
                    sign*=-1;
                    na_k *= (4.0 * nu * nu -
                             (2.0 * static_cast<Real>(k) - 1.0) *
                                 (2.0 * static_cast<Real>(k) - 1.0));
                    da_k *= (8.0 * k) * x;
                    const T a_k = na_k/da_k;

                    s2+=a_k;
                    s1+=sign*a_k;
                }

                const T i = I<T>().value();
                return 1.0 / std::sqrt(2 * M_PI * x) *
                    (W<T>().weight1LargeX(x) * s1 +
                     i * std::exp(i * nu * M_PI) * W<T>().weight2LargeX(x) * s2);
            }
        }

        template <class T, template <class> class W>
        T modifiedBesselFunction_k_impl(Real nu, const T& x) {
            return M_PI_2 * (modifiedBesselFunction_i_impl<T,W>(-nu, x) -
                             modifiedBesselFunction_i_impl<T,W>(nu, x)) /
                             std::sin(M_PI * nu);
        }
    }

    Real modifiedBesselFunction_i(Real nu, Real x) {
        QL_REQUIRE(x >= 0.0, "negative argument requires complex version of "
                             "modifiedBesselFunction");
        return modifiedBesselFunction_i_impl<Real, Unweighted>(nu, x);
    }

    std::complex<Real> modifiedBesselFunction_i(Real nu,
                                                const std::complex<Real> &z) {
        return modifiedBesselFunction_i_impl<
            std::complex<Real>, Unweighted>(nu, z);
    }

    Real modifiedBesselFunction_k(Real nu, Real x) {
        return modifiedBesselFunction_k_impl<Real, Unweighted>(nu, x);
    }

    std::complex<Real> modifiedBesselFunction_k(Real nu,
                                                const std::complex<Real> &z) {
        return modifiedBesselFunction_k_impl<
            std::complex<Real>, Unweighted>(nu, z);
    }

    Real modifiedBesselFunction_i_exponentiallyWeighted(Real nu, Real x) {
        QL_REQUIRE(x >= 0.0, "negative argument requires complex version of "
                             "modifiedBesselFunction");
        return modifiedBesselFunction_i_impl<Real, ExponentiallyWeighted>(
            nu, x);
    }

    std::complex<Real> modifiedBesselFunction_i_exponentiallyWeighted(
        Real nu, const std::complex<Real> &z) {
        return modifiedBesselFunction_i_impl<
            std::complex<Real>, ExponentiallyWeighted>(nu, z);
    }

    Real modifiedBesselFunction_k_exponentiallyWeighted(Real nu, Real x) {
        return modifiedBesselFunction_k_impl<Real, ExponentiallyWeighted>(
            nu, x);
    }

    std::complex<Real> modifiedBesselFunction_k_exponentiallyWeighted(
        Real nu, const std::complex<Real> &z) {
        return modifiedBesselFunction_k_impl<
            std::complex<Real>, ExponentiallyWeighted>(nu, z);
    }

}
]]></document_content>
  </document>
  <document index="51">
    <source>optimization/armijo.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Nicolas Di Csar

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/optimization/armijo.hpp>
#include <ql/math/optimization/method.hpp>
#include <ql/math/optimization/problem.hpp>

namespace QuantLib {

    Real ArmijoLineSearch::operator()(Problem& P,
                                      EndCriteria::Type& ecType,
                                      const EndCriteria& endCriteria,
                                      const Real t_ini)
    {
        //OptimizationMethod& method = P.method();
        Constraint& constraint = P.constraint();
        succeed_=true;
        bool maxIter = false;
        Real qtold, t = t_ini;
        Size loopNumber = 0;

        Real q0 = P.functionValue();
        Real qp0 = P.gradientNormValue();

        qt_ = q0;
        qpt_ = (gradient_.empty()) ? qp0 : -DotProduct(gradient_,searchDirection_);

        // Initialize gradient
        gradient_ = Array(P.currentValue().size());
        // Compute new point
        xtd_ = P.currentValue();
        t = update(xtd_, searchDirection_, t, constraint);
        // Compute function value at the new point
        qt_ = P.value (xtd_);

        // Enter in the loop if the criterion is not satisfied
        if ((qt_-q0) > -alpha_*t*qpt_) {
            do {
                loopNumber++;
                // Decrease step
                t *= beta_;
                // Store old value of the function
                qtold = qt_;
                // New point value
                xtd_ = P.currentValue();
                t = update(xtd_, searchDirection_, t, constraint);

                // Compute function value at the new point
                qt_ = P.value (xtd_);
                P.gradient (gradient_, xtd_);
                // and it squared norm
                maxIter = endCriteria.checkMaxIterations(loopNumber, ecType);
            } while (
                     (((qt_ - q0) > (-alpha_ * t * qpt_)) ||
                      ((qtold - q0) <= (-alpha_ * t * qpt_ / beta_))) &&
                     (!maxIter));
        }

        if (maxIter)
            succeed_ = false;

        // Compute new gradient
        P.gradient(gradient_, xtd_);
        // and it squared norm
        qpt_ = DotProduct(gradient_, gradient_);

        // Return new step value
        return t;
    }

}
]]></document_content>
  </document>
  <document index="52">
    <source>optimization/bfgs.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

 /*
 Copyright (C) 2009 Frdric Degraeve

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/optimization/bfgs.hpp>
#include <ql/math/optimization/problem.hpp>
#include <ql/math/optimization/linesearch.hpp>

namespace QuantLib {

    Disposable<Array> BFGS::getUpdatedDirection(const Problem& P,
                                                Real,
                                                const Array& oldGradient) {
        if (inverseHessian_.rows() == 0)
        {
            // first time in this update, we create needed structures
            inverseHessian_ = Matrix(P.currentValue().size(),
                                     P.currentValue().size(), 0.);
            for (Size i = 0; i < P.currentValue().size(); ++i)
                inverseHessian_[i][i] = 1.;
        }

        Array diffGradient;
        Array diffGradientWithHessianApplied(P.currentValue().size(), 0.);

        diffGradient = lineSearch_->lastGradient() - oldGradient;
        for (Size i = 0; i < P.currentValue().size(); ++i)
            for (Size j = 0; j < P.currentValue().size(); ++j)
                diffGradientWithHessianApplied[i] += inverseHessian_[i][j] * diffGradient[j];

        Real fac, fae, fad;
        Real sumdg, sumxi;

        fac = fae = sumdg = sumxi = 0.;
        for (Size i = 0; i < P.currentValue().size(); ++i)
        {
            fac += diffGradient[i] * lineSearch_->searchDirection()[i];
            fae += diffGradient[i] * diffGradientWithHessianApplied[i];
            sumdg += std::pow(diffGradient[i], 2.);
            sumxi += std::pow(lineSearch_->searchDirection()[i], 2.);
        }

        if (fac > std::sqrt(1e-8 * sumdg * sumxi))  // skip update if fac not sufficiently positive
        {
            fac = 1.0 / fac;
            fad = 1.0 / fae;

            for (Size i = 0; i < P.currentValue().size(); ++i)
                diffGradient[i] = fac * lineSearch_->searchDirection()[i] - fad * diffGradientWithHessianApplied[i];

            for (Size i = 0; i < P.currentValue().size(); ++i)
                for (Size j = 0; j < P.currentValue().size(); ++j)
                {
                    inverseHessian_[i][j] += fac * lineSearch_->searchDirection()[i] * lineSearch_->searchDirection()[j];
                    inverseHessian_[i][j] -= fad * diffGradientWithHessianApplied[i] * diffGradientWithHessianApplied[j];
                    inverseHessian_[i][j] += fae * diffGradient[i] * diffGradient[j];
                }
        }
        //else
        //  throw "BFGS: FAC not sufficiently positive";


        Array direction(P.currentValue().size());
        for (Size i = 0; i < P.currentValue().size(); ++i)
        {
            direction[i] = 0.0;
            for (Size j = 0; j < P.currentValue().size(); ++j)
                direction[i] -= inverseHessian_[i][j] * lineSearch_->lastGradient()[j];
        }

        return direction;
    }

}
]]></document_content>
  </document>
  <document index="53">
    <source>optimization/conjugategradient.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

 /*
 Copyright (C) 2001, 2002, 2003 Nicolas Di Csar
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2007 Franois du Vignaud
 Copyright (C) 2009 Frdric Degraeve

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/optimization/conjugategradient.hpp>
#include <ql/math/optimization/problem.hpp>
#include <ql/math/optimization/linesearch.hpp>

namespace QuantLib {

    Disposable<Array> ConjugateGradient::getUpdatedDirection(const Problem& P,
                                                             Real gold2,
                                                             const Array&) {
        return -lineSearch_->lastGradient() +
            (P.gradientNormValue() / gold2) * lineSearch_->searchDirection();
    }

}
]]></document_content>
  </document>
  <document index="54">
    <source>optimization/constraint.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/optimization/constraint.hpp>
#include <utility>

namespace QuantLib {

    Constraint::Constraint(ext::shared_ptr<Constraint::Impl> impl) : impl_(std::move(impl)) {}

    Real Constraint::update(Array& params, const Array& direction, Real beta) const {

        Real diff=beta;
        Array newParams = params + diff*direction;
        bool valid = test(newParams);
        Integer icount = 0;
        while (!valid) {
            if (icount > 200)
                QL_FAIL("can't update parameter vector");
            diff *= 0.5;
            icount ++;
            newParams = params + diff*direction;
            valid = test(newParams);
        }
        params += diff*direction;
        return diff;
    }
}
]]></document_content>
  </document>
  <document index="55">
    <source>optimization/differentialevolution.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Ralph Schreyer
 Copyright (C) 2012 Mateusz Kapturski

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/optimization/differentialevolution.hpp>
#include <algorithm>
#include <cmath>

namespace QuantLib {

    namespace {

        struct sort_by_cost {
            bool operator()(const DifferentialEvolution::Candidate& left,
                            const DifferentialEvolution::Candidate& right) {
                return left.cost < right.cost;
            }
        };

        template <class I>
        void randomize(I begin, I end,
                       const MersenneTwisterUniformRng& rng) {
            Size n = static_cast<Size>(end-begin);
            for (Size i=n-1; i>0; --i) {
                std::swap(begin[i], begin[rng.nextInt32() % (i+1)]);
            }
        }

    }

    EndCriteria::Type DifferentialEvolution::minimize(Problem& p, const EndCriteria& endCriteria) {
        EndCriteria::Type ecType;
        p.reset();

        if (configuration().upperBound.empty()) {
            upperBound_ = p.constraint().upperBound(p.currentValue());
        } else {
            QL_REQUIRE(configuration().upperBound.size() == p.currentValue().size(),
                       "wrong upper bound size in differential evolution configuration");
            upperBound_ = configuration().upperBound;
        }
        if (configuration().lowerBound.empty()) {
            lowerBound_ = p.constraint().lowerBound(p.currentValue());
        } else {
            QL_REQUIRE(configuration().lowerBound.size() == p.currentValue().size(),
                       "wrong lower bound size in differential evolution configuration");
            lowerBound_ = configuration().lowerBound;
        }
        currGenSizeWeights_ =
            Array(configuration().populationMembers, configuration().stepsizeWeight);
        currGenCrossover_ = Array(configuration().populationMembers,
                                  configuration().crossoverProbability);

        std::vector<Candidate> population;
        if (!configuration().initialPopulation.empty()) {
            population.resize(configuration().initialPopulation.size());
            for (Size i = 0; i < population.size(); ++i) {
                population[i].values = configuration().initialPopulation[i];
                QL_REQUIRE(population[i].values.size() == p.currentValue().size(),
                           "wrong values size in initial population");
                population[i].cost = p.costFunction().value(population[i].values);
            }
        } else {
            population = std::vector<Candidate>(configuration().populationMembers,
                                                Candidate(p.currentValue().size()));
            fillInitialPopulation(population, p);
        }

        std::partial_sort(population.begin(), population.begin() + 1, population.end(),
                          sort_by_cost());
        bestMemberEver_ = population.front();
        Real fxOld = population.front().cost;
        Size iteration = 0, stationaryPointIteration = 0;

        // main loop - calculate consecutive emerging populations
        while (!endCriteria.checkMaxIterations(iteration++, ecType)) {
            calculateNextGeneration(population, p);
            std::partial_sort(population.begin(), population.begin() + 1, population.end(),
                              sort_by_cost());
            if (population.front().cost < bestMemberEver_.cost)
                bestMemberEver_ = population.front();
            Real fxNew = population.front().cost;
            if (endCriteria.checkStationaryFunctionValue(fxOld, fxNew, stationaryPointIteration,
                                                         ecType))
                break;
            fxOld = fxNew;
        };
        p.setCurrentValue(bestMemberEver_.values);
        p.setFunctionValue(bestMemberEver_.cost);
        return ecType;
    }

    void DifferentialEvolution::calculateNextGeneration(
                                     std::vector<Candidate>& population,
                                     Problem& p) const {

        std::vector<Candidate> mirrorPopulation;
        std::vector<Candidate> oldPopulation = population;

        switch (configuration().strategy) {

          case Rand1Standard: {
              randomize(population.begin(), population.end(), rng_);
              std::vector<Candidate> shuffledPop1 = population;
              randomize(population.begin(), population.end(), rng_);
              std::vector<Candidate> shuffledPop2 = population;
              randomize(population.begin(), population.end(), rng_);
              mirrorPopulation = shuffledPop1;

              for (Size popIter = 0; popIter < population.size(); popIter++) {
                  population[popIter].values = population[popIter].values
                      + configuration().stepsizeWeight
                      * (shuffledPop1[popIter].values - shuffledPop2[popIter].values);
              }
          }
            break;

          case BestMemberWithJitter: {
              randomize(population.begin(), population.end(), rng_);
              std::vector<Candidate> shuffledPop1 = population;
              randomize(population.begin(), population.end(), rng_);
              Array jitter(population[0].values.size(), 0.0);

              for (Size popIter = 0; popIter < population.size(); popIter++) {
                  for (double& jitterIter : jitter) {
                      jitterIter = rng_.nextReal();
                  }
                  population[popIter].values = bestMemberEver_.values
                      + (shuffledPop1[popIter].values - population[popIter].values)
                      * (0.0001 * jitter + configuration().stepsizeWeight);
              }
              mirrorPopulation = std::vector<Candidate>(population.size(),
                                                        bestMemberEver_);
          }
            break;

          case CurrentToBest2Diffs: {
              randomize(population.begin(), population.end(), rng_);
              std::vector<Candidate> shuffledPop1 = population;
              randomize(population.begin(), population.end(), rng_);

              for (Size popIter = 0; popIter < population.size(); popIter++) {
                  population[popIter].values = oldPopulation[popIter].values
                      + configuration().stepsizeWeight
                      * (bestMemberEver_.values - oldPopulation[popIter].values)
                      + configuration().stepsizeWeight
                      * (population[popIter].values - shuffledPop1[popIter].values);
              }
              mirrorPopulation = shuffledPop1;
          }
            break;

          case Rand1DiffWithPerVectorDither: {
              randomize(population.begin(), population.end(), rng_);
              std::vector<Candidate> shuffledPop1 = population;
              randomize(population.begin(), population.end(), rng_);
              std::vector<Candidate> shuffledPop2 = population;
              randomize(population.begin(), population.end(), rng_);
              mirrorPopulation = shuffledPop1;
              Array FWeight = Array(population.front().values.size(), 0.0);
              for (double& fwIter : FWeight)
                  fwIter = (1.0 - configuration().stepsizeWeight) * rng_.nextReal() +
                           configuration().stepsizeWeight;
              for (Size popIter = 0; popIter < population.size(); popIter++) {
                  population[popIter].values = population[popIter].values
                      + FWeight * (shuffledPop1[popIter].values - shuffledPop2[popIter].values);
              }
          }
            break;

          case Rand1DiffWithDither: {
              randomize(population.begin(), population.end(), rng_);
              std::vector<Candidate> shuffledPop1 = population;
              randomize(population.begin(), population.end(), rng_);
              std::vector<Candidate> shuffledPop2 = population;
              randomize(population.begin(), population.end(), rng_);
              mirrorPopulation = shuffledPop1;
              Real FWeight = (1.0 - configuration().stepsizeWeight) * rng_.nextReal()
                  + configuration().stepsizeWeight;
              for (Size popIter = 0; popIter < population.size(); popIter++) {
                  population[popIter].values = population[popIter].values
                      + FWeight * (shuffledPop1[popIter].values - shuffledPop2[popIter].values);
              }
          }
            break;

          case EitherOrWithOptimalRecombination: {
              randomize(population.begin(), population.end(), rng_);
              std::vector<Candidate> shuffledPop1 = population;
              randomize(population.begin(), population.end(), rng_);
              std::vector<Candidate> shuffledPop2 = population;
              randomize(population.begin(), population.end(), rng_);
              mirrorPopulation = shuffledPop1;
              Real probFWeight = 0.5;
              if (rng_.nextReal() < probFWeight) {
                  for (Size popIter = 0; popIter < population.size(); popIter++) {
                      population[popIter].values = oldPopulation[popIter].values
                          + configuration().stepsizeWeight
                          * (shuffledPop1[popIter].values - shuffledPop2[popIter].values);
                  }
              } else {
                  Real K = 0.5 * (configuration().stepsizeWeight + 1); // invariant with respect to probFWeight used
                  for (Size popIter = 0; popIter < population.size(); popIter++) {
                      population[popIter].values = oldPopulation[popIter].values
                          + K
                          * (shuffledPop1[popIter].values - shuffledPop2[popIter].values
                             - 2.0 * population[popIter].values);
                  }
              }
          }
            break;

          case Rand1SelfadaptiveWithRotation: {
              randomize(population.begin(), population.end(), rng_);
              std::vector<Candidate> shuffledPop1 = population;
              randomize(population.begin(), population.end(), rng_);
              std::vector<Candidate> shuffledPop2 = population;
              randomize(population.begin(), population.end(), rng_);
              mirrorPopulation = shuffledPop1;

              adaptSizeWeights();

              for (Size popIter = 0; popIter < population.size(); popIter++) {
                  if (rng_.nextReal() < 0.1){
                      population[popIter].values = rotateArray(bestMemberEver_.values);
                  }else {
                      population[popIter].values = bestMemberEver_.values
                          + currGenSizeWeights_[popIter]
                          * (shuffledPop1[popIter].values - shuffledPop2[popIter].values);
                  }
              }
          }
            break;

          default:
            QL_FAIL("Unknown strategy ("
                    << Integer(configuration().strategy) << ")");
        }
        // in order to avoid unnecessary copying we use the same population object for mutants
        crossover(oldPopulation, population, population, mirrorPopulation, p);
    }

    void DifferentialEvolution::crossover(
                               const std::vector<Candidate>& oldPopulation,
                               std::vector<Candidate>& population,
                               const std::vector<Candidate>& mutantPopulation,
                               const std::vector<Candidate>& mirrorPopulation,
                               Problem& p) const {

        if (configuration().crossoverIsAdaptive) {
            adaptCrossover();
        }

        Array mutationProbabilities = getMutationProbabilities(population);

        std::vector<Array> crossoverMask(population.size(),
                                         Array(population.front().values.size(), 1.0));
        std::vector<Array> invCrossoverMask = crossoverMask;
        getCrossoverMask(crossoverMask, invCrossoverMask, mutationProbabilities);

        // crossover of the old and mutant population
        for (Size popIter = 0; popIter < population.size(); popIter++) {
            population[popIter].values = oldPopulation[popIter].values * invCrossoverMask[popIter]
                + mutantPopulation[popIter].values * crossoverMask[popIter];
            // immediately apply bounds if specified
            if (configuration().applyBounds) {
                for (Size memIter = 0; memIter < population[popIter].values.size(); memIter++) {
                    if (population[popIter].values[memIter] > upperBound_[memIter])
                        population[popIter].values[memIter] = upperBound_[memIter]
                            + rng_.nextReal()
                            * (mirrorPopulation[popIter].values[memIter]
                               - upperBound_[memIter]);
                    if (population[popIter].values[memIter] < lowerBound_[memIter])
                        population[popIter].values[memIter] = lowerBound_[memIter]
                            + rng_.nextReal()
                            * (mirrorPopulation[popIter].values[memIter]
                               - lowerBound_[memIter]);
                }
            }
            // evaluate objective function as soon as possible to avoid unnecessary loops
            try {
                population[popIter].cost = p.value(population[popIter].values);
            } catch (Error&) {
                population[popIter].cost = QL_MAX_REAL;
            }
            if (!std::isfinite(population[popIter].cost))
                population[popIter].cost = QL_MAX_REAL;

        }
    }

    void DifferentialEvolution::getCrossoverMask(
                                  std::vector<Array> & crossoverMask,
                                  std::vector<Array> & invCrossoverMask,
                                  const Array & mutationProbabilities) const {
        for (Size cmIter = 0; cmIter < crossoverMask.size(); cmIter++) {
            for (Size memIter = 0; memIter < crossoverMask[cmIter].size(); memIter++) {
                if (rng_.nextReal() < mutationProbabilities[cmIter]) {
                    invCrossoverMask[cmIter][memIter] = 0.0;
                } else {
                    crossoverMask[cmIter][memIter] = 0.0;
                }
            }
        }
    }

    Array DifferentialEvolution::getMutationProbabilities(
                            const std::vector<Candidate> & population) const {
        Array mutationProbabilities = currGenCrossover_;
        switch (configuration().crossoverType) {
          case Normal:
            break;
          case Binomial:
            mutationProbabilities = currGenCrossover_
                * (1.0 - 1.0 / population.front().values.size())
                + 1.0 / population.front().values.size();
            break;
          case Exponential:
            for (Size coIter = 0;coIter< currGenCrossover_.size(); coIter++){
                mutationProbabilities[coIter] =
                    (1.0 - std::pow(currGenCrossover_[coIter],
                                    (int) population.front().values.size()))
                    / (population.front().values.size()
                       * (1.0 - currGenCrossover_[coIter]));
            }
            break;
          default:
            QL_FAIL("Unknown crossover type ("
                    << Integer(configuration().crossoverType) << ")");
            break;
        }
        return mutationProbabilities;
    }

    Array DifferentialEvolution::rotateArray(Array a) const {
        randomize(a.begin(), a.end(), rng_);
        return a;
    }

    void DifferentialEvolution::adaptSizeWeights() const {
        // [=Fl & =Fu] respectively see Brest, J. et al., 2006,
        // "Self-Adapting Control Parameters in Differential
        // Evolution"
        Real sizeWeightLowerBound = 0.1, sizeWeightUpperBound = 0.9;
         // [=tau1] A Comparative Study on Numerical Benchmark
         // Problems." page 649 for reference
        Real sizeWeightChangeProb = 0.1;
        for (double& currGenSizeWeight : currGenSizeWeights_) {
            if (rng_.nextReal() < sizeWeightChangeProb)
                currGenSizeWeight = sizeWeightLowerBound + rng_.nextReal() * sizeWeightUpperBound;
        }
    }

    void DifferentialEvolution::adaptCrossover() const {
        Real crossoverChangeProb = 0.1; // [=tau2]
        for (double& coIter : currGenCrossover_) {
            if (rng_.nextReal() < crossoverChangeProb)
                coIter = rng_.nextReal();
        }
    }

    void DifferentialEvolution::fillInitialPopulation(
                                          std::vector<Candidate> & population,
                                          const Problem& p) const {

        // use initial values provided by the user
        population.front().values = p.currentValue();
        population.front().cost = p.costFunction().value(population.front().values);
        // rest of the initial population is random
        for (Size j = 1; j < population.size(); ++j) {
            for (Size i = 0; i < p.currentValue().size(); ++i) {
                Real l = lowerBound_[i], u = upperBound_[i];
                population[j].values[i] = l + (u-l)*rng_.nextReal();
            }
            population[j].cost = p.costFunction().value(population[j].values);
            if (!std::isfinite(population[j].cost))
                population[j].cost = QL_MAX_REAL;
        }
    }

}
]]></document_content>
  </document>
  <document index="56">
    <source>optimization/endcriteria.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2001, 2002, 2003 Nicolas Di Csar

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/optimization/endcriteria.hpp>
#include <ql/errors.hpp>
#include <algorithm>

namespace QuantLib {
    

    EndCriteria::EndCriteria(Size maxIterations,
                             Size maxStationaryStateIterations,
                             Real rootEpsilon,
                             Real functionEpsilon,
                             Real gradientNormEpsilon)
    : maxIterations_(maxIterations),
      maxStationaryStateIterations_(maxStationaryStateIterations),
      rootEpsilon_(rootEpsilon),
      functionEpsilon_(functionEpsilon),
      gradientNormEpsilon_(gradientNormEpsilon) {

        if (maxStationaryStateIterations_ == Null<Size>())
            maxStationaryStateIterations_ = std::min(static_cast<Size>(maxIterations/2),
                                                     static_cast<Size>(100));
        QL_REQUIRE(maxStationaryStateIterations_>1,
                   "maxStationaryStateIterations_ (" <<
                   maxStationaryStateIterations_ <<
                   ") must be greater than one");
        QL_REQUIRE(maxStationaryStateIterations_<maxIterations_,
                   "maxStationaryStateIterations_ (" <<
                   maxStationaryStateIterations_ <<
                   ") must be less than maxIterations_ (" <<
                   maxIterations_ << ")");
        if (gradientNormEpsilon_ == Null<Real>())
            gradientNormEpsilon_ = functionEpsilon_;
    }

    bool EndCriteria::checkMaxIterations(const Size iteration,
                                         EndCriteria::Type& ecType) const{
        if (iteration < maxIterations_)
            return false;
        ecType = MaxIterations;
        return true;
    }

    bool EndCriteria::checkStationaryPoint(const Real xOld,
                                           const Real xNew,
                                           Size& statStateIterations,
                                           EndCriteria::Type& ecType) const {
        if (std::fabs(xNew-xOld) >= rootEpsilon_) {
            statStateIterations = 0;
            return false;
        }
        ++statStateIterations;
        if (statStateIterations <= maxStationaryStateIterations_)
            return false;
        ecType = StationaryPoint;
        return true;
    }

    bool EndCriteria::checkStationaryFunctionValue(
                                            const Real fxOld,
                                            const Real fxNew,
                                            Size& statStateIterations,
                                            EndCriteria::Type& ecType) const {
        if (std::fabs(fxNew-fxOld) >= functionEpsilon_) {
            statStateIterations = 0;
            return false;
        }
        ++statStateIterations;
        if (statStateIterations <= maxStationaryStateIterations_)
            return false;
        ecType = StationaryFunctionValue;
        return true;
    }

    bool EndCriteria::checkStationaryFunctionAccuracy(
                                            const Real f,
                                            const bool positiveOptimization,
                                            EndCriteria::Type& ecType) const {
        if (!positiveOptimization)
            return false;
        if (f >= functionEpsilon_)
            return false;
        ecType = StationaryFunctionAccuracy;
        return true;
    }

    //bool EndCriteria::checkZerGradientNormValue(
    //                                        const Real gNormOld,
    //                                        const Real gNormNew,
    //                                        EndCriteria::Type& ecType) const {
    //    if (std::fabs(gNormNew-gNormOld) >= gradientNormEpsilon_)
    //        return false;
    //    ecType = StationaryGradient;
    //    return true;
    //}

    bool EndCriteria::checkZeroGradientNorm(const Real gradientNorm,
                                            EndCriteria::Type& ecType) const {
        if (gradientNorm >= gradientNormEpsilon_)
            return false;
        ecType = ZeroGradientNorm;
        return true;
    }

    bool EndCriteria::operator()(const Size iteration,
                                 Size& statStateIterations,
                                 const bool positiveOptimization,
                                 const Real fold,
                                 const Real, //normgold,
                                 const Real fnew,
                                 const Real normgnew,
                                 EndCriteria::Type& ecType) const {
        return
            checkMaxIterations(iteration, ecType) ||
            checkStationaryFunctionValue(fold, fnew, statStateIterations, ecType) ||
            checkStationaryFunctionAccuracy(fnew, positiveOptimization, ecType) ||
            checkZeroGradientNorm(normgnew, ecType);
    }

    // Inspectors
    Size EndCriteria::maxIterations() const {
        return maxIterations_;
    }

    Size EndCriteria::maxStationaryStateIterations() const {
        return maxStationaryStateIterations_;
    }

    Real EndCriteria::rootEpsilon() const {
        return rootEpsilon_;
    }

    Real EndCriteria::functionEpsilon() const {
        return functionEpsilon_;
    }

    Real EndCriteria::gradientNormEpsilon() const {
        return gradientNormEpsilon_;
    }

    std::ostream& operator<<(std::ostream& out, EndCriteria::Type ec) {
        switch (ec) {
        case QuantLib::EndCriteria::None:
            return out << "None";
        case QuantLib::EndCriteria::MaxIterations:
            return out << "MaxIterations";
        case QuantLib::EndCriteria::StationaryPoint:
            return out << "StationaryPoint";
        case QuantLib::EndCriteria::StationaryFunctionValue:
            return out << "StationaryFunctionValue";
        case QuantLib::EndCriteria::StationaryFunctionAccuracy:
            return out << "StationaryFunctionAccuracy";
        case QuantLib::EndCriteria::ZeroGradientNorm:
            return out << "ZeroGradientNorm";
        case QuantLib::EndCriteria::Unknown:
            return out << "Unknown";
        default:
            QL_FAIL("unknown EndCriteria::Type (" << Integer(ec) << ")");
        }
    }

}
]]></document_content>
  </document>
  <document index="57">
    <source>optimization/goldstein.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Cheng Li
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/optimization/goldstein.hpp>
#include <ql/math/optimization/method.hpp>
#include <ql/math/optimization/problem.hpp>
#include <ql/math/comparison.hpp>

namespace QuantLib {

    Real GoldsteinLineSearch::operator()(Problem& P, 
                                         EndCriteria::Type& ecType, 
                                         const EndCriteria& endCriteria, 
                                         const Real t_ini) 
    {
        Constraint& constraint = P.constraint();
        succeed_=true;
        bool maxIter = false;
        Real t = t_ini;
        Size loopNumber = 0;

        Real q0 = P.functionValue();
        Real qp0 = P.gradientNormValue();
        
        Real tl = 0.0;
        Real tr = 0.0;

        qt_ = q0;
        qpt_ = (gradient_.empty()) ? qp0 : -DotProduct(gradient_,searchDirection_);

        // Initialize gradient
        gradient_ = Array(P.currentValue().size());
        // Compute new point
        xtd_ = P.currentValue();
        t = update(xtd_, searchDirection_, t, constraint);
        // Compute function value at the new point
        qt_ = P.value (xtd_);

        while ((qt_ - q0) < -beta_*t*qpt_ || (qt_ - q0) > -alpha_*t*qpt_) {
            if ((qt_ - q0) > -alpha_*t*qpt_)
                tr = t;
            else
                tl = t;
            ++loopNumber;
            
            // calculate the new step
            if (close_enough(tr, 0.0))
                t *= extrapolation_;
            else
                t = (tl + tr) / 2.0;

            // New point value
            xtd_ = P.currentValue();
            t = update(xtd_, searchDirection_, t, constraint);

            // Compute function value at the new point
            qt_ = P.value (xtd_);
            P.gradient (gradient_, xtd_);
            // and it squared norm
            maxIter = endCriteria.checkMaxIterations(loopNumber, ecType);

            if (maxIter)
                break;
        }

        if (maxIter)
            succeed_ = false;

        // Compute new gradient
        P.gradient(gradient_, xtd_);
        // and it squared norm
        qpt_ = DotProduct(gradient_, gradient_);

        // Return new step value
        return t;
    }

}
]]></document_content>
  </document>
  <document index="58">
    <source>optimization/leastsquare.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Nicolas Di Csar
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/optimization/conjugategradient.hpp>
#include <ql/math/optimization/leastsquare.hpp>
#include <ql/math/optimization/problem.hpp>
#include <utility>

namespace QuantLib {

    Real LeastSquareFunction::value(const Array & x) const {
        // size of target and function to fit vectors
        Array target(lsp_.size()), fct2fit(lsp_.size());
        // compute its values
        lsp_.targetAndValue(x, target, fct2fit);
        // do the difference
        Array diff = target - fct2fit;
        // and compute the scalar product (square of the norm)
        return DotProduct(diff, diff);
    }

    Disposable<Array> LeastSquareFunction::values(const Array& x) const {
        // size of target and function to fit vectors
        Array target(lsp_.size()), fct2fit(lsp_.size());
        // compute its values
        lsp_.targetAndValue(x, target, fct2fit);
        // do the difference
        Array diff = target - fct2fit;
        return diff*diff;
    }

    void LeastSquareFunction::gradient(Array& grad_f,
                                       const Array& x) const {
        // size of target and function to fit vectors
        Array target (lsp_.size ()), fct2fit (lsp_.size ());
        // size of gradient matrix
        Matrix grad_fct2fit (lsp_.size (), x.size ());
        // compute its values
        lsp_.targetValueAndGradient(x, grad_fct2fit, target, fct2fit);
        // do the difference
        Array diff = target - fct2fit;
        // compute derivative
        grad_f = -2.0*(transpose(grad_fct2fit)*diff);
    }

    Real LeastSquareFunction::valueAndGradient(Array& grad_f,
                                               const Array& x) const {
        // size of target and function to fit vectors
        Array target(lsp_.size()), fct2fit(lsp_.size());
        // size of gradient matrix
        Matrix grad_fct2fit(lsp_.size(), x.size());
        // compute its values
        lsp_.targetValueAndGradient(x, grad_fct2fit, target, fct2fit);
        // do the difference
        Array diff = target - fct2fit;
        // compute derivative
        grad_f = -2.0*(transpose(grad_fct2fit)*diff);
        // and compute the scalar product (square of the norm)
        return DotProduct(diff, diff);
    }

    NonLinearLeastSquare::NonLinearLeastSquare(Constraint& c,
                                               Real accuracy,
                                               Size maxiter)
    : exitFlag_(-1), accuracy_ (accuracy), maxIterations_ (maxiter),
      om_ (ext::shared_ptr<OptimizationMethod>(new ConjugateGradient())),
      c_(c)
    {}

    NonLinearLeastSquare::NonLinearLeastSquare(Constraint& c,
                                               Real accuracy,
                                               Size maxiter,
                                               ext::shared_ptr<OptimizationMethod> om)
    : exitFlag_(-1), accuracy_(accuracy), maxIterations_(maxiter), om_(std::move(om)), c_(c) {}

    Array& NonLinearLeastSquare::perform(LeastSquareProblem& lsProblem) {
        Real eps = accuracy_;

        // wrap the least square problem in an optimization function
        LeastSquareFunction lsf(lsProblem);

        // define optimization problem
        Problem P(lsf, c_, initialValue_);

        // minimize
        EndCriteria ec(maxIterations_,
            std::min(static_cast<Size>(maxIterations_/2), static_cast<Size>(100)),
            eps, eps, eps);
        exitFlag_ = om_->minimize(P, ec);

        // summarize results of minimization
        //        nbIterations_ = om_->iterationNumber();

        results_ = P.currentValue();
        resnorm_ = P.functionValue();
        bestAccuracy_ = P.functionValue();

        return results_;
    }

}
]]></document_content>
  </document>
  <document index="59">
    <source>optimization/levenbergmarquardt.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Klaus Spanderen
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/optimization/constraint.hpp>
#include <ql/math/optimization/lmdif.hpp>
#include <ql/math/optimization/levenbergmarquardt.hpp>
#include <ql/functional.hpp>
#include <memory>

namespace QuantLib {

    LevenbergMarquardt::LevenbergMarquardt(Real epsfcn,
                                           Real xtol,
                                           Real gtol,
                                           bool useCostFunctionsJacobian)
    : epsfcn_(epsfcn), xtol_(xtol), gtol_(gtol),
      useCostFunctionsJacobian_(useCostFunctionsJacobian) {}

    Integer LevenbergMarquardt::getInfo() const {
        return info_;
    }

    EndCriteria::Type LevenbergMarquardt::minimize(Problem& P,
                                                   const EndCriteria& endCriteria) {
        using namespace ext::placeholders;

        EndCriteria::Type ecType = EndCriteria::None;
        P.reset();
        Array x_ = P.currentValue();
        currentProblem_ = &P;
        initCostValues_ = P.costFunction().values(x_);
        int m = initCostValues_.size();
        int n = x_.size();
        if(useCostFunctionsJacobian_) {
            initJacobian_ = Matrix(m,n);
            P.costFunction().jacobian(initJacobian_, x_);
        }
        std::unique_ptr<Real[]> xx(new Real[n]);
        std::copy(x_.begin(), x_.end(), xx.get());
        std::unique_ptr<Real[]> fvec(new Real[m]);
        std::unique_ptr<Real[]> diag(new Real[n]);
        int mode = 1;
        Real factor = 1;
        int nprint = 0;
        int info = 0;
        int nfev =0;
        std::unique_ptr<Real[]> fjac(new Real[m*n]);
        int ldfjac = m;
        std::unique_ptr<int[]> ipvt(new int[n]);
        std::unique_ptr<Real[]> qtf(new Real[n]);
        std::unique_ptr<Real[]> wa1(new Real[n]);
        std::unique_ptr<Real[]> wa2(new Real[n]);
        std::unique_ptr<Real[]> wa3(new Real[n]);
        std::unique_ptr<Real[]> wa4(new Real[m]);
        // requirements; check here to get more detailed error messages.
        QL_REQUIRE(n > 0, "no variables given");
        QL_REQUIRE(m >= n,
                   "less functions (" << m <<
                   ") than available variables (" << n << ")");
        QL_REQUIRE(endCriteria.functionEpsilon() >= 0.0,
                   "negative f tolerance");
        QL_REQUIRE(xtol_ >= 0.0, "negative x tolerance");
        QL_REQUIRE(gtol_ >= 0.0, "negative g tolerance");
        QL_REQUIRE(endCriteria.maxIterations() > 0,
                   "null number of evaluations");

        // call lmdif to minimize the sum of the squares of m functions
        // in n variables by the Levenberg-Marquardt algorithm.
        MINPACK::LmdifCostFunction lmdifCostFunction =
            ext::bind(&LevenbergMarquardt::fcn, this, _1, _2, _3, _4, _5);
        MINPACK::LmdifCostFunction lmdifJacFunction =
            useCostFunctionsJacobian_
                ? ext::bind(&LevenbergMarquardt::jacFcn, this, _1, _2, _3, _4, _5)
                : MINPACK::LmdifCostFunction();
        MINPACK::lmdif(m, n, xx.get(), fvec.get(),
                       endCriteria.functionEpsilon(),
                       xtol_,
                       gtol_,
                       endCriteria.maxIterations(),
                       epsfcn_,
                       diag.get(), mode, factor,
                       nprint, &info, &nfev, fjac.get(),
                       ldfjac, ipvt.get(), qtf.get(),
                       wa1.get(), wa2.get(), wa3.get(), wa4.get(),
                       lmdifCostFunction,
                       lmdifJacFunction);
        info_ = info;
        // check requirements & endCriteria evaluation
        QL_REQUIRE(info != 0, "MINPACK: improper input parameters");
        //QL_REQUIRE(info != 6, "MINPACK: ftol is too small. no further "
        //                               "reduction in the sum of squares "
        //                               "is possible.");
        if (info != 6) ecType = QuantLib::EndCriteria::StationaryFunctionValue;
        //QL_REQUIRE(info != 5, "MINPACK: number of calls to fcn has "
        //                               "reached or exceeded maxfev.");
        endCriteria.checkMaxIterations(nfev, ecType);
        QL_REQUIRE(info != 7, "MINPACK: xtol is too small. no further "
                                       "improvement in the approximate "
                                       "solution x is possible.");
        QL_REQUIRE(info != 8, "MINPACK: gtol is too small. fvec is "
                                       "orthogonal to the columns of the "
                                       "jacobian to machine precision.");
        // set problem
        std::copy(xx.get(), xx.get()+n, x_.begin());
        P.setCurrentValue(x_);
        P.setFunctionValue(P.costFunction().value(x_));

        return ecType;
    }

    void LevenbergMarquardt::fcn(int, int n, Real* x, Real* fvec, int*) {
        Array xt(n);
        std::copy(x, x+n, xt.begin());
        // constraint handling needs some improvement in the future:
        // starting point should not be close to a constraint violation
        if (currentProblem_->constraint().test(xt)) {
            const Array& tmp = currentProblem_->values(xt);
            std::copy(tmp.begin(), tmp.end(), fvec);
        } else {
            std::copy(initCostValues_.begin(), initCostValues_.end(), fvec);
        }
    }

    void LevenbergMarquardt::jacFcn(int m, int n, Real* x, Real* fjac, int*) {
        Array xt(n);
        std::copy(x, x+n, xt.begin());
        // constraint handling needs some improvement in the future:
        // starting point should not be close to a constraint violation
        if (currentProblem_->constraint().test(xt)) {
            Matrix tmp(m,n);
            currentProblem_->costFunction().jacobian(tmp, xt);
            Matrix tmpT = transpose(tmp);
            std::copy(tmpT.begin(), tmpT.end(), fjac);
        } else {
            Matrix tmpT = transpose(initJacobian_);
            std::copy(tmpT.begin(), tmpT.end(), fjac);
        }
    }

}
]]></document_content>
  </document>
  <document index="60">
    <source>optimization/linesearch.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Nicolas Di Csar

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/optimization/linesearch.hpp>
#include <ql/math/optimization/problem.hpp>
#include <ql/math/optimization/constraint.hpp>

namespace QuantLib {

    Real LineSearch::update(Array& params,
                            const Array& direction,
                            Real beta,
                            const Constraint& constraint) {

        Real diff=beta;
        Array newParams = params + diff*direction;
        bool valid = constraint.test(newParams);
        Integer icount = 0;
        while (!valid) {
            if (icount > 200)
                QL_FAIL("can't update linesearch");
            diff *= 0.5;
            icount ++;
            newParams = params + diff*direction;
            valid = constraint.test(newParams);
        }
        params += diff*direction;
        return diff;
    }

}
]]></document_content>
  </document>
  <document index="61">
    <source>optimization/linesearchbasedmethod.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2009 Frdric Degraeve

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/optimization/armijo.hpp>
#include <ql/math/optimization/linesearch.hpp>
#include <ql/math/optimization/linesearchbasedmethod.hpp>
#include <ql/math/optimization/problem.hpp>
#include <utility>

namespace QuantLib {

    LineSearchBasedMethod::LineSearchBasedMethod(ext::shared_ptr<LineSearch> lineSearch)
    : lineSearch_(std::move(lineSearch)) {
        if (!lineSearch_)
           lineSearch_ = ext::shared_ptr<LineSearch>(new ArmijoLineSearch);
    }

    EndCriteria::Type
    LineSearchBasedMethod::minimize(Problem& P,
                                    const EndCriteria& endCriteria) {
        // Initializations
        Real ftol = endCriteria.functionEpsilon();
        Size maxStationaryStateIterations_
            = endCriteria.maxStationaryStateIterations();
        EndCriteria::Type ecType = EndCriteria::None;   // reset end criteria
        P.reset();                                      // reset problem
        Array x_ = P.currentValue();              // store the starting point
        Size iterationNumber_ = 0;
        // dimension line search
        lineSearch_->searchDirection() = Array(x_.size());
        bool done = false;

        // function and squared norm of gradient values;
        Real fnew, fold, gold2;
        Real fdiff;
        // classical initial value for line-search step
        Real t = 1.0;
        // Set gradient g at the size of the optimization problem
        // search direction
        Size sz = lineSearch_->searchDirection().size();
        Array prevGradient(sz), d(sz), sddiff(sz), direction(sz);
        // Initialize cost function, gradient prevGradient and search direction
        P.setFunctionValue(P.valueAndGradient(prevGradient, x_));
        P.setGradientNormValue(DotProduct(prevGradient, prevGradient));
        lineSearch_->searchDirection() = -prevGradient;

        bool first_time = true;
        // Loop over iterations
        do {
            // Linesearch
            if (!first_time)
                prevGradient = lineSearch_->lastGradient();
            t = (*lineSearch_)(P, ecType, endCriteria, t);
            // don't throw: it can fail just because maxIterations exceeded
            //QL_REQUIRE(lineSearch_->succeed(), "line-search failed!");
            if (lineSearch_->succeed())
            {
                // Updates

                // New point
                x_ = lineSearch_->lastX();
                // New function value
                fold = P.functionValue();
                P.setFunctionValue(lineSearch_->lastFunctionValue());
                // New gradient and search direction vectors

                // orthogonalization coef
                gold2 = P.gradientNormValue();
                P.setGradientNormValue(lineSearch_->lastGradientNorm2());

                // conjugate gradient search direction
                direction = getUpdatedDirection(P, gold2, prevGradient);

                sddiff = direction - lineSearch_->searchDirection();
                lineSearch_->searchDirection() = direction;
                // Now compute accuracy and check end criteria
                // Numerical Recipes exit strategy on fx (see NR in C++, p.423)
                fnew = P.functionValue();
                fdiff = 2.0*std::fabs(fnew-fold) /
                        (std::fabs(fnew) + std::fabs(fold) + QL_EPSILON);
                if (fdiff < ftol ||
                    endCriteria.checkMaxIterations(iterationNumber_, ecType)) {
                    endCriteria.checkStationaryFunctionValue(0.0, 0.0,
                        maxStationaryStateIterations_, ecType);
                    endCriteria.checkMaxIterations(iterationNumber_, ecType);
                    return ecType;
                }
                P.setCurrentValue(x_);      // update problem current value
                ++iterationNumber_;         // Increase iteration number
                first_time = false;
            } else {
                done = true;
            }
        } while (!done);
        P.setCurrentValue(x_);
        return ecType;
    }

}
]]></document_content>
  </document>
  <document index="62">
    <source>optimization/lmdif.cpp</source>
    <document_content><![CDATA[/************************lmdif*************************/

/*
The original Fortran version is Copyright (C) 1999 University of Chicago.
All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, are permitted provided that the
following conditions are met:

1. Redistributions of source code must retain the above
copyright notice, this list of conditions and the following
disclaimer.

2. Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials
provided with the distribution.

3. The end-user documentation included with the
redistribution, if any, must include the following
acknowledgment:

   "This product includes software developed by the
   University of Chicago, as Operator of Argonne National
   Laboratory.

Alternately, this acknowledgment may appear in the software
itself, if and wherever such third-party acknowledgments
normally appear.

4. WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS"
WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
BE CORRECTED.

5. LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
(INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
POSSIBILITY OF SUCH LOSS OR DAMAGES.


C translation Copyright (C) Steve Moshier

What you see here may be used freely but it comes with no support
or guarantee.
*/

#include <ql/math/optimization/lmdif.hpp>
#include <cmath>
#include <cstdio>

namespace QuantLib {
  namespace MINPACK {
#define BUG 0
/* resolution of arithmetic */
double MACHEP = 1.2e-16;
/* smallest nonzero number */
double DWARF = 1.0e-38;





Real enorm(int n,Real* x)
{
/*
*     **********
*
*     function enorm
*
*     given an n-vector x, this function calculates the
*     euclidean norm of x.
*
*     the euclidean norm is computed by accumulating the sum of
*     squares in three different sums. the sums of squares for the
*     small and large components are scaled so that no overflows
*     occur. non-destructive underflows are permitted. underflows
*     and overflows do not occur in the computation of the unscaled
*     sum of squares for the intermediate components.
*     the definitions of small, intermediate and large components
*     depend on two constants, rdwarf and rgiant. the main
*     restrictions on these constants are that rdwarf**2 not
*     underflow and rgiant**2 not overflow. the constants
*     given here are suitable for every known computer.
*
*     the function statement is
*
*   double precision function enorm(n,x)
*
*     where
*
*   n is a positive integer input variable.
*
*   x is an input array of length n.
*
*     subprograms called
*
*   fortran-supplied ... dabs,dsqrt
*
*     argonne national laboratory. minpack project. march 1980.
*     burton s. garbow, kenneth e. hillstrom, jorge j. more
*
*     **********
*/
int i;
Real agiant,floatn,s1,s2,s3,xabs,x1max,x3max;
Real ans, temp;
static double rdwarf = 3.834e-20;
static double rgiant = 1.304e19;
static double zero = 0.0;
static double one = 1.0;

s1 = zero;
s2 = zero;
s3 = zero;
x1max = zero;
x3max = zero;
floatn = n;
agiant = rgiant/floatn;

for( i=0; i<n; i++ )
{
xabs = std::fabs(x[i]);
if( (xabs > rdwarf) && (xabs < agiant) )
    {
/*
*       sum for intermediate components.
*/
    s2 += xabs*xabs;
    continue;
    }

if(xabs > rdwarf)
    {
/*
*          sum for large components.
*/
    if(xabs > x1max)
        {
        temp = x1max/xabs;
        s1 = one + s1*temp*temp;
        x1max = xabs;
        }
    else
        {
        temp = xabs/x1max;
        s1 += temp*temp;
        }
    continue;
    }
/*
*          sum for small components.
*/
if(xabs > x3max)
    {
    temp = x3max/xabs;
    s3 = one + s3*temp*temp;
    x3max = xabs;
    }
else
    {
    if(xabs != zero)
        {
        temp = xabs/x3max;
        s3 += temp*temp;
        }
    }
}
/*
*     calculation of norm.
*/
if(s1 != zero)
    {
    temp = s1 + (s2/x1max)/x1max;
    ans = x1max*std::sqrt(temp);
    return(ans);
    }
if(s2 != zero)
    {
    if(s2 >= x3max)
        temp = s2*(one+(x3max/s2)*(x3max*s3));
    else
        temp = x3max*((s2/x3max)+(x3max*s3));
    ans = std::sqrt(temp);
    }
else
    {
    ans = x3max*std::sqrt(s3);
    }
return(ans);
/*
*     last card of function enorm.
*/
}
/************************lmmisc.c*************************/

Real dmax1(Real a,Real b)
{
if( a >= b )
    return(a);
else
    return(b);
}

Real dmin1(Real a,Real b)
{
if( a <= b )
    return(a);
else
    return(b);
}

int min0(int a,int b)

{
if( a <= b )
    return(a);
else
    return(b);
}

int mod( int k, int m )
{
return( k % m );
}


/***********Sample of user supplied function****************
 * m = number of functions
 * n = number of variables
 * x = vector of function arguments
 * fvec = vector of function values
 * iflag = error return variable
 */
//void fcn(int m,int n, Real* x, Real* fvec,int *iflag)
//{
//  QuantLib::LevenbergMarquardt::fcn(m, n, x, fvec, iflag);
//}

void fdjac2(int m,
            int n,
            Real* x,
            const Real* fvec,
            Real* fjac,
            int,
            int* iflag,
            Real epsfcn,
            Real* wa,
            const QuantLib::MINPACK::LmdifCostFunction& fcn) {
    /*
     *     **********
     *
     *     subroutine fdjac2
     *
     *     this subroutine computes a forward-difference approximation
     *     to the m by n jacobian matrix associated with a specified
     *     problem of m functions in n variables.
     *
     *     the subroutine statement is
     *
     *   subroutine fdjac2(fcn,m,n,x,fvec,fjac,ldfjac,iflag,epsfcn,wa)
     *
     *     where
     *
     *   fcn is the name of the user-supplied subroutine which
     *     calculates the functions. fcn must be declared
     *     in an external statement in the user calling
     *     program, and should be written as follows.
     *
     *     subroutine fcn(m,n,x,fvec,iflag)
     *     integer m,n,iflag
     *     double precision x(n),fvec(m)
     *     ----------
     *     calculate the functions at x and
     *     return this vector in fvec.
     *     ----------
     *     return
     *     end
     *
     *     the value of iflag should not be changed by fcn unless
     *     the user wants to terminate execution of fdjac2.
     *     in this case set iflag to a negative integer.
     *
     *   m is a positive integer input variable set to the number
     *     of functions.
     *
     *   n is a positive integer input variable set to the number
     *     of variables. n must not exceed m.
     *
     *   x is an input array of length n.
     *
     *   fvec is an input array of length m which must contain the
     *     functions evaluated at x.
     *
     *   fjac is an output m by n array which contains the
     *     approximation to the jacobian matrix evaluated at x.
     *
     *   ldfjac is a positive integer input variable not less than m
     *     which specifies the leading dimension of the array fjac.
     *
     *   iflag is an integer variable which can be used to terminate
     *     the execution of fdjac2. see description of fcn.
     *
     *   epsfcn is an input variable used in determining a suitable
     *     step length for the forward-difference approximation. this
     *     approximation assumes that the relative errors in the
     *     functions are of the order of epsfcn. if epsfcn is less
     *     than the machine precision, it is assumed that the relative
     *     errors in the functions are of the order of the machine
     *     precision.
     *
     *   wa is a work array of length m.
     *
     *     subprograms called
     *
     *   user-supplied ...... fcn
     *
     *   minpack-supplied ... dpmpar
     *
     *   fortran-supplied ... dabs,dmax1,dsqrt
     *
     *     argonne national laboratory. minpack project. march 1980.
     *     burton s. garbow, kenneth e. hillstrom, jorge j. more
     *
     **********
     */
    int i, j, ij;
    Real eps, h, temp;
    static double zero = 0.0;


    temp = dmax1(epsfcn, MACHEP);
    eps = std::sqrt(temp);
    ij = 0;
    for (j = 0; j < n; j++) {
        temp = x[j];
        h = eps * std::fabs(temp);
        if (h == zero)
            h = eps;
        x[j] = temp + h;
        fcn(m, n, x, wa, iflag);
        if (*iflag < 0)
            return;
        x[j] = temp;
        for (i = 0; i < m; i++) {
            fjac[ij] = (wa[i] - fvec[i]) / h;
            ij += 1; /* fjac[i+m*j] */
        }
    }
/*
*     last card of subroutine fdjac2.
*/
}
/************************qrfac.c*************************/


void
qrfac(int m,int n,Real* a,int,int pivot,int* ipvt,
      int,Real* rdiag,Real* acnorm,Real* wa)
{
/*
*     **********
*
*     subroutine qrfac
*
*     this subroutine uses householder transformations with column
*     pivoting (optional) to compute a qr factorization of the
*     m by n matrix a. that is, qrfac determines an orthogonal
*     matrix q, a permutation matrix p, and an upper trapezoidal
*     matrix r with diagonal elements of nonincreasing magnitude,
*     such that a*p = q*r. the householder transformation for
*     column k, k = 1,2,...,min(m,n), is of the form
*
*               t
*       i - (1/u(k))*u*u
*
*     where u has zeros in the first k-1 positions. the form of
*     this transformation and the method of pivoting first
*     appeared in the corresponding linpack subroutine.
*
*     the subroutine statement is
*
*   subroutine qrfac(m,n,a,lda,pivot,ipvt,lipvt,rdiag,acnorm,wa)
*
*     where
*
*   m is a positive integer input variable set to the number
*     of rows of a.
*
*   n is a positive integer input variable set to the number
*     of columns of a.
*
*   a is an m by n array. on input a contains the matrix for
*     which the qr factorization is to be computed. on output
*     the strict upper trapezoidal part of a contains the strict
*     upper trapezoidal part of r, and the lower trapezoidal
*     part of a contains a factored form of q (the non-trivial
*     elements of the u vectors described above).
*
*   lda is a positive integer input variable not less than m
*     which specifies the leading dimension of the array a.
*
*   pivot is a logical input variable. if pivot is set true,
*     then column pivoting is enforced. if pivot is set false,
*     then no column pivoting is done.
*
*   ipvt is an integer output array of length lipvt. ipvt
*     defines the permutation matrix p such that a*p = q*r.
*     column j of p is column ipvt(j) of the identity matrix.
*     if pivot is false, ipvt is not referenced.
*
*   lipvt is a positive integer input variable. if pivot is false,
*     then lipvt may be as small as 1. if pivot is true, then
*     lipvt must be at least n.
*
*   rdiag is an output array of length n which contains the
*     diagonal elements of r.
*
*   acnorm is an output array of length n which contains the
*     norms of the corresponding columns of the input matrix a.
*     if this information is not needed, then acnorm can coincide
*     with rdiag.
*
*   wa is a work array of length n. if pivot is false, then wa
*     can coincide with rdiag.
*
*     subprograms called
*
*   minpack-supplied ... dpmpar,enorm
*
*   fortran-supplied ... dmax1,dsqrt,min0
*
*     argonne national laboratory. minpack project. march 1980.
*     burton s. garbow, kenneth e. hillstrom, jorge j. more
*
*     **********
*/
int i,ij,jj,j,jp1,k,kmax,minmn;
Real ajnorm,sum,temp;
static double zero = 0.0;
static double one = 1.0;
static double p05 = 0.05;

/*
*     compute the initial column norms and initialize several arrays.
*/
ij = 0;
for( j=0; j<n; j++ )
    {
    acnorm[j] = enorm(m,&a[ij]);
    rdiag[j] = acnorm[j];
    wa[j] = rdiag[j];
    if(pivot != 0)
        ipvt[j] = j;
    ij += m; /* m*j */
    }
/*
*     reduce a to r with householder transformations.
*/
minmn = min0(m,n);
for( j=0; j<minmn; j++ )
{
if(pivot == 0)
    goto L40;
/*
*    bring the column of largest norm into the pivot position.
*/
kmax = j;
for( k=j; k<n; k++ )
    {
    if(rdiag[k] > rdiag[kmax])
        kmax = k;
    }
if(kmax == j)
    goto L40;

ij = m * j;
jj = m * kmax;
for( i=0; i<m; i++ )
    {
    temp = a[ij]; /* [i+m*j] */
    a[ij] = a[jj]; /* [i+m*kmax] */
    a[jj] = temp;
    ij += 1;
    jj += 1;
    }
rdiag[kmax] = rdiag[j];
wa[kmax] = wa[j];
k = ipvt[j];
ipvt[j] = ipvt[kmax];
ipvt[kmax] = k;

L40:
/*
*    compute the householder transformation to reduce the
*    j-th column of a to a multiple of the j-th unit vector.
*/
jj = j + m*j;
ajnorm = enorm(m-j,&a[jj]);
if(ajnorm == zero)
    goto L100;
if(a[jj] < zero)
    ajnorm = -ajnorm;
ij = jj;
for( i=j; i<m; i++ )
    {
    a[ij] /= ajnorm;
    ij += 1; /* [i+m*j] */
    }
a[jj] += one;
/*
*    apply the transformation to the remaining columns
*    and update the norms.
*/
jp1 = j + 1;
if(jp1 < n )
{
for( k=jp1; k<n; k++ )
    {
    sum = zero;
    ij = j + m*k;
    jj = j + m*j;
    for( i=j; i<m; i++ )
        {
        sum += a[jj]*a[ij];
        ij += 1; /* [i+m*k] */
        jj += 1; /* [i+m*j] */
        }
    temp = sum/a[j+m*j];
    ij = j + m*k;
    jj = j + m*j;
    for( i=j; i<m; i++ )
        {
        a[ij] -= temp*a[jj];
        ij += 1; /* [i+m*k] */
        jj += 1; /* [i+m*j] */
        }
    if( (pivot != 0) && (rdiag[k] != zero) )
        {
        temp = a[j+m*k]/rdiag[k];
        temp = dmax1( zero, one-temp*temp );
        rdiag[k] *= std::sqrt(temp);
        temp = rdiag[k]/wa[k];
        if( (p05*temp*temp) <= MACHEP)
            {
            rdiag[k] = enorm(m-j-1,&a[jp1+m*k]);
            wa[k] = rdiag[k];
            }
        }
    }
}

L100:
    rdiag[j] = -ajnorm;
}
/*
*     last card of subroutine qrfac.
*/
}

/************************qrsolv.c*************************/


void qrsolv(int n,
            Real* r,
            int ldr,
            const int* ipvt,
            const Real* diag,
            const Real* qtb,
            Real* x,
            Real* sdiag,
            Real* wa) {
    /*
     *     **********
     *
     *     subroutine qrsolv
     *
     *     given an m by n matrix a, an n by n diagonal matrix d,
     *     and an m-vector b, the problem is to determine an x which
     *     solves the system
     *
     *       a*x = b ,     d*x = 0 ,
     *
     *     in the least squares sense.
     *
     *     this subroutine completes the solution of the problem
     *     if it is provided with the necessary information from the
     *     qr factorization, with column pivoting, of a. that is, if
     *     a*p = q*r, where p is a permutation matrix, q has orthogonal
     *     columns, and r is an upper triangular matrix with diagonal
     *     elements of nonincreasing magnitude, then qrsolv expects
     *     the full upper triangle of r, the permutation matrix p,
     *     and the first n components of (q transpose)*b. the system
     *     a*x = b, d*x = 0, is then equivalent to
     *
     *          t       t
     *       r*z = q *b ,  p *d*p*z = 0 ,
     *
     *     where x = p*z. if this system does not have full rank,
     *     then a least squares solution is obtained. on output qrsolv
     *     also provides an upper triangular matrix s such that
     *
     *        t   t       t
     *       p *(a *a + d*d)*p = s *s .
     *
     *     s is computed within qrsolv and may be of separate interest.
     *
     *     the subroutine statement is
     *
     *   subroutine qrsolv(n,r,ldr,ipvt,diag,qtb,x,sdiag,wa)
     *
     *     where
     *
     *   n is a positive integer input variable set to the order of r.
     *
     *   r is an n by n array. on input the full upper triangle
     *     must contain the full upper triangle of the matrix r.
     *     on output the full upper triangle is unaltered, and the
     *     strict lower triangle contains the strict upper triangle
     *     (transposed) of the upper triangular matrix s.
     *
     *   ldr is a positive integer input variable not less than n
     *     which specifies the leading dimension of the array r.
     *
     *   ipvt is an integer input array of length n which defines the
     *     permutation matrix p such that a*p = q*r. column j of p
     *     is column ipvt(j) of the identity matrix.
     *
     *   diag is an input array of length n which must contain the
     *     diagonal elements of the matrix d.
     *
     *   qtb is an input array of length n which must contain the first
     *     n elements of the vector (q transpose)*b.
     *
     *   x is an output array of length n which contains the least
     *     squares solution of the system a*x = b, d*x = 0.
     *
     *   sdiag is an output array of length n which contains the
     *     diagonal elements of the upper triangular matrix s.
     *
     *   wa is a work array of length n.
     *
     *     subprograms called
     *
     *   fortran-supplied ... dabs,dsqrt
     *
     *     argonne national laboratory. minpack project. march 1980.
     *     burton s. garbow, kenneth e. hillstrom, jorge j. more
     *
     *     **********
     */
    int i, ij, ik, kk, j, jp1, k, kp1, l, nsing;
    Real cos, cotan, qtbpj, sin, sum, tan, temp;
    static double zero = 0.0;
    static double p25 = 0.25;
    static double p5 = 0.5;

    /*
     *     copy r and (q transpose)*b to preserve input and initialize s.
     *     in particular, save the diagonal elements of r in x.
     */
    kk = 0;
    for (j = 0; j < n; j++) {
        ij = kk;
        ik = kk;
        for (i = j; i < n; i++) {
            r[ij] = r[ik];
            ij += 1;   /* [i+ldr*j] */
            ik += ldr; /* [j+ldr*i] */
        }
    x[j] = r[kk];
    wa[j] = qtb[j];
    kk += ldr+1; /* j+ldr*j */
    }
/*
*     eliminate the diagonal matrix d using a givens rotation.
*/
for( j=0; j<n; j++ )
{
/*
*    prepare the row of d to be eliminated, locating the
*    diagonal element using p from the qr factorization.
*/
l = ipvt[j];
if(diag[l] == zero)
    goto L90;
for( k=j; k<n; k++ )
    sdiag[k] = zero;
sdiag[j] = diag[l];
/*
*    the transformations to eliminate the row of d
*    modify only a single element of (q transpose)*b
*    beyond the first n, which is initially zero.
*/
qtbpj = zero;
for( k=j; k<n; k++ )
    {
/*
*       determine a givens rotation which eliminates the
*       appropriate element in the current row of d.
*/
    if(sdiag[k] == zero)
        continue;
    kk = k + ldr * k;
    if(std::fabs(r[kk]) < std::fabs(sdiag[k]))
        {
        cotan = r[kk]/sdiag[k];
        sin = p5/std::sqrt(p25+p25*cotan*cotan);
        cos = sin*cotan;
        }
    else
        {
        tan = sdiag[k]/r[kk];
        cos = p5/std::sqrt(p25+p25*tan*tan);
        sin = cos*tan;
        }
/*
*       compute the modified diagonal element of r and
*       the modified element of ((q transpose)*b,0).
*/
    r[kk] = cos*r[kk] + sin*sdiag[k];
    temp = cos*wa[k] + sin*qtbpj;
    qtbpj = -sin*wa[k] + cos*qtbpj;
    wa[k] = temp;
/*
*       accumulate the tranformation in the row of s.
*/
    kp1 = k + 1;
    if( n > kp1 )
        {
        ik = kk + 1;
        for( i=kp1; i<n; i++ )
            {
            temp = cos*r[ik] + sin*sdiag[i];
            sdiag[i] = -sin*r[ik] + cos*sdiag[i];
            r[ik] = temp;
            ik += 1; /* [i+ldr*k] */
            }
        }
    }
L90:
/*
*    store the diagonal element of s and restore
*    the corresponding diagonal element of r.
*/
    kk = j + ldr*j;
    sdiag[j] = r[kk];
    r[kk] = x[j];
}
/*
*     solve the triangular system for z. if the system is
*     singular, then obtain a least squares solution.
*/
nsing = n;
for( j=0; j<n; j++ )
    {
    if( (sdiag[j] == zero) && (nsing == n) )
        nsing = j;
    if(nsing < n)
        wa[j] = zero;
    }
if(nsing < 1)
    goto L150;

for( k=0; k<nsing; k++ )
    {
    j = nsing - k - 1;
    sum = zero;
    jp1 = j + 1;
    if(nsing > jp1)
        {
        ij = jp1 + ldr * j;
        for( i=jp1; i<nsing; i++ )
            {
            sum += r[ij]*wa[i];
            ij += 1; /* [i+ldr*j] */
            }
        }
    wa[j] = (wa[j] - sum)/sdiag[j];
    }
L150:
/*
*     permute the components of z back to components of x.
*/
for( j=0; j<n; j++ )
    {
    l = ipvt[j];
    x[l] = wa[j];
    }
/*
*     last card of subroutine qrsolv.
*/
}

/************************lmpar.c*************************/


void lmpar(int n,
           Real* r,
           int ldr,
           int* ipvt,
           const Real* diag,
           Real* qtb,
           Real delta,
           Real* par,
           Real* x,
           Real* sdiag,
           Real* wa1,
           Real* wa2) {
    /*     **********
     *
     *     subroutine lmpar
     *
     *     given an m by n matrix a, an n by n nonsingular diagonal
     *     matrix d, an m-vector b, and a positive number delta,
     *     the problem is to determine a value for the parameter
     *     par such that if x solves the system
     *
     *       a*x = b ,     sqrt(par)*d*x = 0 ,
     *
     *     in the least squares sense, and dxnorm is the euclidean
     *     norm of d*x, then either par is zero and
     *
     *       (dxnorm-delta) .le. 0.1*delta ,
     *
     *     or par is positive and
     *
     *       abs(dxnorm-delta) .le. 0.1*delta .
     *
     *     this subroutine completes the solution of the problem
     *     if it is provided with the necessary information from the
     *     qr factorization, with column pivoting, of a. that is, if
     *     a*p = q*r, where p is a permutation matrix, q has orthogonal
     *     columns, and r is an upper triangular matrix with diagonal
     *     elements of nonincreasing magnitude, then lmpar expects
     *     the full upper triangle of r, the permutation matrix p,
     *     and the first n components of (q transpose)*b. on output
     *     lmpar also provides an upper triangular matrix s such that
     *
     *        t   t           t
     *       p *(a *a + par*d*d)*p = s *s .
     *
     *     s is employed within lmpar and may be of separate interest.
     *
     *     only a few iterations are generally needed for convergence
     *     of the algorithm. if, however, the limit of 10 iterations
     *     is reached, then the output par will contain the best
     *     value obtained so far.
     *
     *     the subroutine statement is
     *
     *   subroutine lmpar(n,r,ldr,ipvt,diag,qtb,delta,par,x,sdiag,
     *            wa1,wa2)
     *
     *     where
     *
     *   n is a positive integer input variable set to the order of r.
     *
     *   r is an n by n array. on input the full upper triangle
     *     must contain the full upper triangle of the matrix r.
     *     on output the full upper triangle is unaltered, and the
     *     strict lower triangle contains the strict upper triangle
     *     (transposed) of the upper triangular matrix s.
     *
     *   ldr is a positive integer input variable not less than n
     *     which specifies the leading dimension of the array r.
     *
     *   ipvt is an integer input array of length n which defines the
     *     permutation matrix p such that a*p = q*r. column j of p
     *     is column ipvt(j) of the identity matrix.
     *
     *   diag is an input array of length n which must contain the
     *     diagonal elements of the matrix d.
     *
     *   qtb is an input array of length n which must contain the first
     *     n elements of the vector (q transpose)*b.
     *
     *   delta is a positive input variable which specifies an upper
     *     bound on the euclidean norm of d*x.
     *
     *   par is a nonnegative variable. on input par contains an
     *     initial estimate of the levenberg-marquardt parameter.
     *     on output par contains the final estimate.
     *
     *   x is an output array of length n which contains the least
     *     squares solution of the system a*x = b, sqrt(par)*d*x = 0,
     *     for the output par.
     *
     *   sdiag is an output array of length n which contains the
     *     diagonal elements of the upper triangular matrix s.
     *
     *   wa1 and wa2 are work arrays of length n.
     *
     *     subprograms called
     *
     *   minpack-supplied ... dpmpar,enorm,qrsolv
     *
     *   fortran-supplied ... dabs,dmax1,dmin1,dsqrt
     *
     *     argonne national laboratory. minpack project. march 1980.
     *     burton s. garbow, kenneth e. hillstrom, jorge j. more
     *
     *     **********
     */
    int i, iter, ij, jj, j, jm1, jp1, k, l, nsing;
    Real dxnorm, fp, gnorm, parc, parl, paru;
    Real sum, temp;
    static double zero = 0.0;
    static double p1 = 0.1;
    static double p001 = 0.001;


    /*
     *     compute and store in x the gauss-newton direction. if the
     *     jacobian is rank-deficient, obtain a least squares solution.
     */
    nsing = n;
    jj = 0;
    for (j = 0; j < n; j++) {
        wa1[j] = qtb[j];
        if ((r[jj] == zero) && (nsing == n))
            nsing = j;
        if (nsing < n)
            wa1[j] = zero;
        jj += ldr + 1; /* [j+ldr*j] */
    }
if(nsing >= 1)
    {
    for( k=0; k<nsing; k++ )
        {
        j = nsing - k - 1;
        wa1[j] = wa1[j]/r[j+ldr*j];
        temp = wa1[j];
        jm1 = j - 1;
        if(jm1 >= 0)
            {
            ij = ldr * j;
            for( i=0; i<=jm1; i++ )
                {
                wa1[i] -= r[ij]*temp;
                ij += 1;
                }
            }
        }
    }

for( j=0; j<n; j++ )
    {
    l = ipvt[j];
    x[l] = wa1[j];
    }
/*
*     initialize the iteration counter.
*     evaluate the function at the origin, and test
*     for acceptance of the gauss-newton direction.
*/
iter = 0;
for( j=0; j<n; j++ )
    wa2[j] = diag[j]*x[j];
dxnorm = enorm(n,wa2);
fp = dxnorm - delta;
if(fp <= p1*delta)
    {
    goto L220;
    }
/*
*     if the jacobian is not rank deficient, the newton
*     step provides a lower bound, parl, for the zero of
*     the function. otherwise set this bound to zero.
*/
parl = zero;
if(nsing >= n)
    {
    for( j=0; j<n; j++ )
        {
        l = ipvt[j];
        wa1[j] = diag[l]*(wa2[l]/dxnorm);
        }
    jj = 0;
    for( j=0; j<n; j++ )
        {
        sum = zero;
        jm1 = j - 1;
        if(jm1 >= 0)
            {
            ij = jj;
            for( i=0; i<=jm1; i++ )
                {
                sum += r[ij]*wa1[i];
                ij += 1;
                }
            }
        wa1[j] = (wa1[j] - sum)/r[j+ldr*j];
        jj += ldr; /* [i+ldr*j] */
        }
    temp = enorm(n,wa1);
    parl = ((fp/delta)/temp)/temp;
    }
/*
*     calculate an upper bound, paru, for the zero of the function.
*/
jj = 0;
for( j=0; j<n; j++ )
    {
    sum = zero;
    ij = jj;
    for( i=0; i<=j; i++ )
        {
        sum += r[ij]*qtb[i];
        ij += 1;
        }
    l = ipvt[j];
    wa1[j] = sum/diag[l];
    jj += ldr; /* [i+ldr*j] */
    }
gnorm = enorm(n,wa1);
paru = gnorm/delta;
if(paru == zero)
    paru = DWARF/dmin1(delta,p1);
/*
*     if the input par lies outside of the interval (parl,paru),
*     set par to the closer endpoint.
*/
*par = dmax1( *par,parl);
*par = dmin1( *par,paru);
if( *par == zero)
    *par = gnorm/dxnorm;
/*
*     beginning of an iteration.
*/
L150:
iter += 1;
/*
*    evaluate the function at the current value of par.
*/
if( *par == zero)
    *par = dmax1(DWARF,p001*paru);
temp = std::sqrt( *par );
for( j=0; j<n; j++ )
    wa1[j] = temp*diag[j];
qrsolv(n,r,ldr,ipvt,wa1,qtb,x,sdiag,wa2);
for( j=0; j<n; j++ )
    wa2[j] = diag[j]*x[j];
dxnorm = enorm(n,wa2);
temp = fp;
fp = dxnorm - delta;
/*
*    if the function is small enough, accept the current value
*    of par. also test for the exceptional cases where parl
*    is zero or the number of iterations has reached 10.
*/
if( (std::fabs(fp) <= p1*delta)
 || ((parl == zero) && (fp <= temp) && (temp < zero))
 || (iter == 10) )
    goto L220;
/*
*    compute the newton correction.
*/
for( j=0; j<n; j++ )
    {
    l = ipvt[j];
    wa1[j] = diag[l]*(wa2[l]/dxnorm);
    }
jj = 0;
for( j=0; j<n; j++ )
    {
    wa1[j] = wa1[j]/sdiag[j];
    temp = wa1[j];
    jp1 = j + 1;
    if(jp1 < n)
        {
        ij = jp1 + jj;
        for( i=jp1; i<n; i++ )
            {
            wa1[i] -= r[ij]*temp;
            ij += 1; /* [i+ldr*j] */
            }
        }
    jj += ldr; /* ldr*j */
    }
temp = enorm(n,wa1);
parc = ((fp/delta)/temp)/temp;
/*
*    depending on the sign of the function, update parl or paru.
*/
if(fp > zero)
    parl = dmax1(parl, *par);
if(fp < zero)
    paru = dmin1(paru, *par);
/*
*    compute an improved estimate for par.
*/
*par = dmax1(parl, *par + parc);
/*
*    end of an iteration.
*/
goto L150;

L220:
/*
*     termination.
*/
if(iter == 0)
    *par = zero;
/*
*     last card of subroutine lmpar.
*/
}

/*********************** lmdif.c ****************************/




void lmdif(int m,int n,Real* x,Real* fvec,Real ftol,
      Real xtol,Real gtol,int maxfev,Real epsfcn,
      Real* diag, int mode, Real factor,
      int nprint, int* info,int* nfev,Real* fjac,
      int ldfjac,int* ipvt,Real* qtf,
      Real* wa1,Real* wa2,Real* wa3,Real* wa4,
      const QuantLib::MINPACK::LmdifCostFunction& fcn,
      const QuantLib::MINPACK::LmdifCostFunction& jacFcn)
{
/*
*     **********
*
*     subroutine lmdif
*
*     the purpose of lmdif is to minimize the sum of the squares of
*     m nonlinear functions in n variables by a modification of
*     the levenberg-marquardt algorithm. the user must provide a
*     subroutine which calculates the functions. the jacobian is
*     then calculated by a forward-difference approximation.
*
*     the subroutine statement is
*
*   subroutine lmdif(fcn,m,n,x,fvec,ftol,xtol,gtol,maxfev,epsfcn,
*            diag,mode,factor,nprint,info,nfev,fjac,
*            ldfjac,ipvt,qtf,wa1,wa2,wa3,wa4)
*
*     where
*
*   fcn is the name of the user-supplied subroutine which
*     calculates the functions. fcn must be declared
*     in an external statement in the user calling
*     program, and should be written as follows.
*
*     subroutine fcn(m,n,x,fvec,iflag)
*     integer m,n,iflag
*     double precision x(n),fvec(m)
*     ----------
*     calculate the functions at x and
*     return this vector in fvec.
*     ----------
*     return
*     end
*
*     the value of iflag should not be changed by fcn unless
*     the user wants to terminate execution of lmdif.
*     in this case set iflag to a negative integer.
*
*   m is a positive integer input variable set to the number
*     of functions.
*
*   n is a positive integer input variable set to the number
*     of variables. n must not exceed m.
*
*   x is an array of length n. on input x must contain
*     an initial estimate of the solution vector. on output x
*     contains the final estimate of the solution vector.
*
*   fvec is an output array of length m which contains
*     the functions evaluated at the output x.
*
*   ftol is a nonnegative input variable. termination
*     occurs when both the actual and predicted relative
*     reductions in the sum of squares are at most ftol.
*     therefore, ftol measures the relative error desired
*     in the sum of squares.
*
*   xtol is a nonnegative input variable. termination
*     occurs when the relative error between two consecutive
*     iterates is at most xtol. therefore, xtol measures the
*     relative error desired in the approximate solution.
*
*   gtol is a nonnegative input variable. termination
*     occurs when the cosine of the angle between fvec and
*     any column of the jacobian is at most gtol in absolute
*     value. therefore, gtol measures the orthogonality
*     desired between the function vector and the columns
*     of the jacobian.
*
*   maxfev is a positive integer input variable. termination
*     occurs when the number of calls to fcn is at least
*     maxfev by the end of an iteration.
*
*   epsfcn is an input variable used in determining a suitable
*     step length for the forward-difference approximation. this
*     approximation assumes that the relative errors in the
*     functions are of the order of epsfcn. if epsfcn is less
*     than the machine precision, it is assumed that the relative
*     errors in the functions are of the order of the machine
*     precision.
*
*   diag is an array of length n. if mode = 1 (see
*     below), diag is internally set. if mode = 2, diag
*     must contain positive entries that serve as
*     multiplicative scale factors for the variables.
*
*   mode is an integer input variable. if mode = 1, the
*     variables will be scaled internally. if mode = 2,
*     the scaling is specified by the input diag. other
*     values of mode are equivalent to mode = 1.
*
*   factor is a positive input variable used in determining the
*     initial step bound. this bound is set to the product of
*     factor and the euclidean norm of diag*x if nonzero, or else
*     to factor itself. in most cases factor should lie in the
*     interval (.1,100.). 100. is a generally recommended value.
*
*   nprint is an integer input variable that enables controlled
*     printing of iterates if it is positive. in this case,
*     fcn is called with iflag = 0 at the beginning of the first
*     iteration and every nprint iterations thereafter and
*     immediately prior to return, with x and fvec available
*     for printing. if nprint is not positive, no special calls
*     of fcn with iflag = 0 are made.
*
*   info is an integer output variable. if the user has
*     terminated execution, info is set to the (negative)
*     value of iflag. see description of fcn. otherwise,
*     info is set as follows.
*
*     info = 0  improper input parameters.
*
*     info = 1  both actual and predicted relative reductions
*           in the sum of squares are at most ftol.
*
*     info = 2  relative error between two consecutive iterates
*           is at most xtol.
*
*     info = 3  conditions for info = 1 and info = 2 both hold.
*
*     info = 4  the cosine of the angle between fvec and any
*           column of the jacobian is at most gtol in
*           absolute value.
*
*     info = 5  number of calls to fcn has reached or
*           exceeded maxfev.
*
*     info = 6  ftol is too small. no further reduction in
*           the sum of squares is possible.
*
*     info = 7  xtol is too small. no further improvement in
*           the approximate solution x is possible.
*
*     info = 8  gtol is too small. fvec is orthogonal to the
*           columns of the jacobian to machine precision.
*
*   nfev is an integer output variable set to the number of
*     calls to fcn.
*
*   fjac is an output m by n array. the upper n by n submatrix
*     of fjac contains an upper triangular matrix r with
*     diagonal elements of nonincreasing magnitude such that
*
*        t     t       t
*       p *(jac *jac)*p = r *r,
*
*     where p is a permutation matrix and jac is the final
*     calculated jacobian. column j of p is column ipvt(j)
*     (see below) of the identity matrix. the lower trapezoidal
*     part of fjac contains information generated during
*     the computation of r.
*
*   ldfjac is a positive integer input variable not less than m
*     which specifies the leading dimension of the array fjac.
*
*   ipvt is an integer output array of length n. ipvt
*     defines a permutation matrix p such that jac*p = q*r,
*     where jac is the final calculated jacobian, q is
*     orthogonal (not stored), and r is upper triangular
*     with diagonal elements of nonincreasing magnitude.
*     column j of p is column ipvt(j) of the identity matrix.
*
*   qtf is an output array of length n which contains
*     the first n elements of the vector (q transpose)*fvec.
*
*   wa1, wa2, and wa3 are work arrays of length n.
*
*   wa4 is a work array of length m.
*
*     subprograms called
*
*   user-supplied ...... fcn, jacFcn
*
*   minpack-supplied ... dpmpar,enorm,fdjac2,lmpar,qrfac
*
*   fortran-supplied ... dabs,dmax1,dmin1,dsqrt,mod
*
*     argonne national laboratory. minpack project. march 1980.
*     burton s. garbow, kenneth e. hillstrom, jorge j. more
*
*     **********
*/
int i,iflag,ij,jj,iter,j,l;
Real actred,delta=0,dirder,fnorm,fnorm1,gnorm;
Real par,pnorm,prered,ratio;
Real sum,temp,temp1,temp2,temp3,xnorm=0;
static double one = 1.0;
static double p1 = 0.1;
static double p5 = 0.5;
static double p25 = 0.25;
static double p75 = 0.75;
static double p0001 = 1.0e-4;
static double zero = 0.0;

*info = 0;
iflag = 0;
*nfev = 0;
/*
*     check the input parameters for errors.
*/
if( (n <= 0) || (m < n) || (ldfjac < m) || (ftol < zero)
    || (xtol < zero) || (gtol < zero) || (maxfev <= 0)
    || (factor <= zero) )
    goto L300;

if( mode == 2 )
    { /* scaling by diag[] */
    for( j=0; j<n; j++ )
        {
        if( diag[j] <= 0.0 )
            goto L300;
        }
    }
/*
*     evaluate the function at the starting point
*     and calculate its norm.
*/
iflag = 1;
fcn(m,n,x,fvec,&iflag);
*nfev = 1;
if(iflag < 0)
    goto L300;
fnorm = enorm(m,fvec);
/*
*     initialize levenberg-marquardt parameter and iteration counter.
*/
par = zero;
iter = 1;
/*
*     beginning of the outer loop.
*/

L30:

/*
*    calculate the jacobian matrix.
*/
iflag = 2;
if (jacFcn == QL_NULL_FUNCTION) // use user supplied jacobian calculation
    fdjac2(m,n,x,fvec,fjac,ldfjac,&iflag,epsfcn,wa4, fcn);
else
    jacFcn(m,n,x,fjac,&iflag);
*nfev += n;
if(iflag < 0)
    goto L300;
/*
*    if requested, call fcn to enable printing of iterates.
*/
if( nprint > 0 )
    {
    iflag = 0;
    if(mod(iter-1,nprint) == 0)
        {
        fcn(m,n,x,fvec,&iflag);
        if(iflag < 0)
            goto L300;
        }
    }
/*
*    compute the qr factorization of the jacobian.
*/
qrfac(m,n,fjac,ldfjac,1,ipvt,n,wa1,wa2,wa3);
/*
*    on the first iteration and if mode is 1, scale according
*    to the norms of the columns of the initial jacobian.
*/
if(iter == 1)
    {
    if(mode != 2)
        {
        for( j=0; j<n; j++ )
            {
            diag[j] = wa2[j];
            if( wa2[j] == zero )
                diag[j] = one;
            }
        }

/*
*    on the first iteration, calculate the norm of the scaled x
*    and initialize the step bound delta.
*/
    for( j=0; j<n; j++ )
        wa3[j] = diag[j] * x[j];

    xnorm = enorm(n,wa3);
    delta = factor*xnorm;
    if(delta == zero)
        delta = factor;
    }

/*
*    form (q transpose)*fvec and store the first n components in
*    qtf.
*/
for( i=0; i<m; i++ )
    wa4[i] = fvec[i];
jj = 0;
for( j=0; j<n; j++ )
    {
    temp3 = fjac[jj];
    if(temp3 != zero)
        {
        sum = zero;
        ij = jj;
        for( i=j; i<m; i++ )
            {
            sum += fjac[ij] * wa4[i];
            ij += 1;    /* fjac[i+m*j] */
            }
        temp = -sum / temp3;
        ij = jj;
        for( i=j; i<m; i++ )
            {
            wa4[i] += fjac[ij] * temp;
            ij += 1;    /* fjac[i+m*j] */
            }
        }
    fjac[jj] = wa1[j];
    jj += m+1;  /* fjac[j+m*j] */
    qtf[j] = wa4[j];
    }

/*
*    compute the norm of the scaled gradient.
*/
 gnorm = zero;
 if(fnorm != zero)
    {
    jj = 0;
    for( j=0; j<n; j++ )
        {
        l = ipvt[j];
        if(wa2[l] != zero)
            {
            sum = zero;
            ij = jj;
            for( i=0; i<=j; i++ )
                {
                sum += fjac[ij]*(qtf[i]/fnorm);
                ij += 1; /* fjac[i+m*j] */
                }
            gnorm = dmax1(gnorm,std::fabs(sum/wa2[l]));
            }
        jj += m;
        }
    }

/*
*    test for convergence of the gradient norm.
*/
 if(gnorm <= gtol)
    *info = 4;
 if( *info != 0)
    goto L300;
/*
*    rescale if necessary.
*/
 if(mode != 2)
    {
    for( j=0; j<n; j++ )
        diag[j] = dmax1(diag[j],wa2[j]);
    }

/*
*    beginning of the inner loop.
*/
L200:
/*
*       determine the levenberg-marquardt parameter.
*/
lmpar(n,fjac,ldfjac,ipvt,diag,qtf,delta,&par,wa1,wa2,wa3,wa4);
/*
*       store the direction p and x + p. calculate the norm of p.
*/
for( j=0; j<n; j++ )
    {
       wa1[j] = -wa1[j];
       wa2[j] = x[j] + wa1[j];
       wa3[j] = diag[j]*wa1[j];
    }
pnorm = enorm(n,wa3);
/*
*       on the first iteration, adjust the initial step bound.
*/
if(iter == 1)
    delta = dmin1(delta,pnorm);
/*
*       evaluate the function at x + p and calculate its norm.
*/
iflag = 1;
fcn(m,n,wa2,wa4,&iflag);
*nfev += 1;
if(iflag < 0)
    goto L300;
fnorm1 = enorm(m,wa4);
/*
*       compute the scaled actual reduction.
*/
actred = -one;
if( (p1*fnorm1) < fnorm)
    {
    temp = fnorm1/fnorm;
    actred = one - temp * temp;
    }
/*
*       compute the scaled predicted reduction and
*       the scaled directional derivative.
*/
jj = 0;
for( j=0; j<n; j++ )
    {
    wa3[j] = zero;
    l = ipvt[j];
    temp = wa1[l];
    ij = jj;
    for( i=0; i<=j; i++ )
        {
        wa3[i] += fjac[ij]*temp;
        ij += 1; /* fjac[i+m*j] */
        }
    jj += m;
    }
temp1 = enorm(n,wa3)/fnorm;
temp2 = (std::sqrt(par)*pnorm)/fnorm;
prered = temp1*temp1 + (temp2*temp2)/p5;
dirder = -(temp1*temp1 + temp2*temp2);
/*
*       compute the ratio of the actual to the predicted
*       reduction.
*/
ratio = zero;
if(prered != zero)
    ratio = actred/prered;
/*
*       update the step bound.
*/
if(ratio <= p25)
    {
    if(actred >= zero)
        temp = p5;
    else
        temp = p5*dirder/(dirder + p5*actred);
    if( ((p1*fnorm1) >= fnorm)
    || (temp < p1) )
        temp = p1;
       delta = temp*dmin1(delta,pnorm/p1);
       par = par/temp;
    }
else
    {
    if( (par == zero) || (ratio >= p75) )
        {
        delta = pnorm/p5;
        par = p5*par;
        }
    }
/*
*       test for successful iteration.
*/
if(ratio >= p0001)
    {
/*
*       successful iteration. update x, fvec, and their norms.
*/
    for( j=0; j<n; j++ )
        {
        x[j] = wa2[j];
        wa2[j] = diag[j]*x[j];
        }
    for( i=0; i<m; i++ )
        fvec[i] = wa4[i];
    xnorm = enorm(n,wa2);
    fnorm = fnorm1;
    iter += 1;
    }
/*
*       tests for convergence.
*/
if( (std::fabs(actred) <= ftol)
  && (prered <= ftol)
  && (p5*ratio <= one) )
    *info = 1;
if(delta <= xtol*xnorm)
    *info = 2;
if( (std::fabs(actred) <= ftol)
  && (prered <= ftol)
  && (p5*ratio <= one)
  && ( *info == 2) )
    *info = 3;
if( *info != 0)
    goto L300;
/*
*       tests for termination and stringent tolerances.
*/
if( *nfev >= maxfev)
    *info = 5;
if( (std::fabs(actred) <= MACHEP)
  && (prered <= MACHEP)
  && (p5*ratio <= one) )
    *info = 6;
if(delta <= MACHEP*xnorm)
    *info = 7;
if(gnorm <= MACHEP)
    *info = 8;
if( *info != 0)
    goto L300;
/*
*       end of the inner loop. repeat if iteration unsuccessful.
*/
if(ratio < p0001)
    goto L200;
/*
*    end of the outer loop.
*/
goto L30;

L300:
/*
*     termination, either normal or user imposed.
*/
if(iflag < 0)
    *info = iflag;
iflag = 0;
if(nprint > 0)
    fcn(m,n,x,fvec,&iflag);
/*
      last card of subroutine lmdif.
*/
}
}
}

/************************fdjac2.c*************************/

]]></document_content>
  </document>
  <document index="63">
    <source>optimization/projectedcostfunction.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Franois du Vignaud
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/optimization/projectedcostfunction.hpp>

namespace QuantLib {

    ProjectedCostFunction::ProjectedCostFunction(
                const CostFunction& costFunction,
                const Array& parameterValues,
                const std::vector<bool>& fixParameters)
        : Projection(parameterValues, fixParameters), costFunction_(costFunction) {}

    ProjectedCostFunction::ProjectedCostFunction(
                const CostFunction& costFunction,
                const Projection& projection)
        : Projection(projection), costFunction_(costFunction) {}

    Real ProjectedCostFunction::value(const Array& freeParameters) const {
        mapFreeParameters(freeParameters);
        return costFunction_.value(actualParameters_);
    }

    Disposable<Array> ProjectedCostFunction::values(
                                        const Array& freeParameters) const{
        mapFreeParameters(freeParameters);
        return costFunction_.values(actualParameters_);
    }

}
]]></document_content>
  </document>
  <document index="64">
    <source>optimization/projection.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Franois du Vignaud
 Copyright (C) 2007 Giorgio Facchinetti
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/optimization/projection.hpp>
#include <utility>

namespace QuantLib {

    Projection::Projection(const Array& parameterValues, std::vector<bool> fixParameters)
    : numberOfFreeParameters_(0), fixedParameters_(parameterValues),
      actualParameters_(parameterValues), fixParameters_(std::move(fixParameters)) {

        if (fixParameters_.empty())
            fixParameters_ =
                std::vector<bool>(actualParameters_.size(), false);

        QL_REQUIRE(fixedParameters_.size() == fixParameters_.size(),
                   "fixedParameters_.size()!=parametersFreedoms_.size()");
        for (auto&& fixParameter : fixParameters_)
            if (!fixParameter)
                numberOfFreeParameters_++;
        QL_REQUIRE(numberOfFreeParameters_ > 0, "numberOfFreeParameters==0");
    }

    void Projection::mapFreeParameters(const Array &parameterValues) const {

        QL_REQUIRE(parameterValues.size() == numberOfFreeParameters_,
                   "parameterValues.size()!=numberOfFreeParameters");
        Size i = 0;
        for (Size j = 0; j < actualParameters_.size(); j++)
            if (!fixParameters_[j])
                actualParameters_[j] = parameterValues[i++];

    }

    Disposable<Array> Projection::project(const Array &parameters) const {

        QL_REQUIRE(parameters.size() == fixParameters_.size(),
                   "parameters.size()!=parametersFreedoms_.size()");
        Array projectedParameters(numberOfFreeParameters_);
        Size i = 0;
        for (Size j = 0; j < fixParameters_.size(); j++)
            if (!fixParameters_[j])
                projectedParameters[i++] = parameters[j];
        return projectedParameters;

    }

    Disposable<Array>
    Projection::include(const Array &projectedParameters) const {

        QL_REQUIRE(projectedParameters.size() == numberOfFreeParameters_,
                   "projectedParameters.size()!=numberOfFreeParameters");
        Array y(fixedParameters_);
        Size i = 0;
        for (Size j = 0; j < y.size(); j++)
            if (!fixParameters_[j])
                y[j] = projectedParameters[i++];
        return y;

    }
}
]]></document_content>
  </document>
  <document index="65">
    <source>optimization/simplex.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2006 Ferdinando Ametrano
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2007 Franois du Vignaud

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/* The implementation of the algorithm was highly inspired by
 * "Numerical Recipes in C", 2nd edition, Press, Teukolsky, Vetterling,
 * Flannery, chapter 10.
 * Modified may 2007: end criteria set on x instead on fx,
 * inspired by bad behaviour found with test function fx=x*x+x+1,
 * xStart = -100, lambda = 1.0, ftol = 1.e-16
 * (it reports x=0 as the minimum!)
 * and by GSL implementation, v. 1.9 (http://www.gnu.org/software/gsl/)
 */

#include <ql/math/optimization/simplex.hpp>
#include <ql/math/optimization/constraint.hpp>

#if !defined(__GNUC__) || __GNUC__ > 3 || __GNUC_MINOR__ > 4
#define QL_ARRAY_EXPRESSIONS
#endif

namespace QuantLib {

    namespace {
    // Computes the size of the simplex
        Real computeSimplexSize (const std::vector<Array>& vertices) {
            Array center(vertices.front().size(),0);
            for (const auto& vertice : vertices)
                center += vertice;
            center *=1/Real(vertices.size());
            Real result = 0;
            for (const auto& vertice : vertices) {
                Array temp = vertice - center;
                result += Norm2(temp);
            }
            return result/Real(vertices.size());
        }
    }

    Real Simplex::extrapolate(Problem& P,
                              Size iHighest,
                              Real &factor) const {

        Array pTry;
        do {
            Size dimensions = values_.size() - 1;
            Real factor1 = (1.0 - factor)/dimensions;
            Real factor2 = factor1 - factor;
            #if defined(QL_ARRAY_EXPRESSIONS)
            pTry = sum_*factor1 - vertices_[iHighest]*factor2;
            #else
            // composite expressions fail to compile with gcc 3.4 on windows
            pTry = sum_*factor1;
            pTry -= vertices_[iHighest]*factor2;
            #endif
            factor *= 0.5;
        } while (!P.constraint().test(pTry) && std::fabs(factor) > QL_EPSILON);
        if (std::fabs(factor) <= QL_EPSILON) {
            return values_[iHighest];
        }
        factor *= 2.0;
        Real vTry = P.value(pTry);
        if (vTry < values_[iHighest]) {
            values_[iHighest] = vTry;
            #if defined(QL_ARRAY_EXPRESSIONS)
            sum_ += pTry - vertices_[iHighest];
            #else
            sum_ += pTry;
            sum_ -= vertices_[iHighest];
            #endif
            vertices_[iHighest] = pTry;
        }
        return vTry;

    }


    EndCriteria::Type Simplex::minimize(Problem& P,
                                        const EndCriteria& endCriteria) {
        // set up of the problem
        //Real ftol = endCriteria.functionEpsilon();    // end criteria on f(x) (see Numerical Recipes in C++, p.410)
        Real xtol = endCriteria.rootEpsilon();          // end criteria on x (see GSL v. 1.9, http://www.gnu.org/software/gsl/)
        Size maxStationaryStateIterations_
            = endCriteria.maxStationaryStateIterations();
        EndCriteria::Type ecType = EndCriteria::None;
        P.reset();

        Array x_ = P.currentValue();
        if (!P.constraint().test(x_))
            QL_FAIL("Initial guess " << x_ << " is not in the feasible region.");

        Integer iterationNumber_=0;

        // Initialize vertices of the simplex
        Size n = x_.size();
        vertices_ = std::vector<Array>(n+1, x_);
        for (Size i=0; i<n; ++i) {
            Array direction(n, 0.0);
            direction[i] = 1.0;
            P.constraint().update(vertices_[i+1], direction, lambda_);
        }
        // Initialize function values at the vertices of the simplex
        values_ = Array(n+1, 0.0);
        for (Size i=0; i<=n; ++i)
            values_[i] = P.value(vertices_[i]);
        // Loop looking for minimum
        do {
            sum_ = Array(n, 0.0);
            Size i;
            for (i=0; i<=n; i++)
                sum_ += vertices_[i];
            // Determine the best (iLowest), worst (iHighest)
            // and 2nd worst (iNextHighest) vertices
            Size iLowest = 0;
            Size iHighest, iNextHighest;
            if (values_[0]<values_[1]) {
                iHighest = 1;
                iNextHighest = 0;
            } else {
                iHighest = 0;
                iNextHighest = 1;
            }
            for (i=1;i<=n; i++) {
                if (values_[i]>values_[iHighest]) {
                    iNextHighest = iHighest;
                    iHighest = i;
                } else {
                    if ((values_[i]>values_[iNextHighest]) && i!=iHighest)
                        iNextHighest = i;
                }
                if (values_[i]<values_[iLowest])
                    iLowest = i;
            }
            // Now compute accuracy, update iteration number and check end criteria
            //// Numerical Recipes exit strategy on fx (see NR in C++, p.410)
            //Real low = values_[iLowest];
            //Real high = values_[iHighest];
            //Real rtol = 2.0*std::fabs(high - low)/
            //    (std::fabs(high) + std::fabs(low) + QL_EPSILON);
            //++iterationNumber_;
            //if (rtol < ftol ||
            //    endCriteria.checkMaxIterations(iterationNumber_, ecType)) {
            // GSL exit strategy on x (see GSL v. 1.9, http://www.gnu.org/software/gsl
            Real simplexSize = computeSimplexSize(vertices_);
            ++iterationNumber_;
            if (simplexSize < xtol ||
                endCriteria.checkMaxIterations(iterationNumber_, ecType)) {
                endCriteria.checkStationaryPoint(0.0, 0.0,
                    maxStationaryStateIterations_, ecType);
                endCriteria.checkMaxIterations(iterationNumber_, ecType);
                x_ = vertices_[iLowest];
                Real low = values_[iLowest];
                P.setFunctionValue(low);
                P.setCurrentValue(x_);
                return ecType;
            }
            // If end criteria is not met, continue
            Real factor = -1.0;
            Real vTry = extrapolate(P, iHighest, factor);
            if ((vTry <= values_[iLowest]) && (factor == -1.0)) {
                factor = 2.0;
                extrapolate(P, iHighest, factor);
            } else if (std::fabs(factor) > QL_EPSILON) {
                if (vTry >= values_[iNextHighest]) {
                    Real vSave = values_[iHighest];
                    factor = 0.5;
                    vTry = extrapolate(P, iHighest, factor);
                    if (vTry >= vSave && std::fabs(factor) > QL_EPSILON) {
                        for (Size i=0; i<=n; i++) {
                            if (i!=iLowest) {
                                #if defined(QL_ARRAY_EXPRESSIONS)
                                vertices_[i] =
                                    0.5*(vertices_[i] + vertices_[iLowest]);
                                #else
                                vertices_[i] += vertices_[iLowest];
                                vertices_[i] *= 0.5;
                                #endif
                                values_[i] = P.value(vertices_[i]);
                            }
                        }
                    }
                }
            }
            // If can't extrapolate given the constraints, exit
            if (std::fabs(factor) <= QL_EPSILON) {
                x_ = vertices_[iLowest];
                Real low = values_[iLowest];
                P.setFunctionValue(low);
                P.setCurrentValue(x_);
                return EndCriteria::StationaryFunctionValue;
            }
        } while (true);
        QL_FAIL("optimization failed: unexpected behaviour");
    }
}
]]></document_content>
  </document>
  <document index="66">
    <source>optimization/spherecylinder.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/optimization/spherecylinder.hpp>
#include <ql/errors.hpp>
#include <algorithm>

namespace QuantLib {

    namespace {

        template<class F>
        Real BrentMinimize(Real low,
                           Real mid,
                           Real high,
                           Real tolerance,
                           Size maxIt,
                           const F& objectiveFunction) {
            Real W = 0.5*(3.0-std::sqrt(5.0));
            Real x = W*low+(1-W)*high;
            if (mid > low && mid < high)
                x = mid;

            Real midValue = objectiveFunction(x);

            Size iterations = 0;
            while (high-low > tolerance && iterations < maxIt) {
                if (x - low > high -x) { // left interval is bigger
                    Real tentativeNewMid = W*low+(1-W)*x;
                    Real tentativeNewMidValue =
                        objectiveFunction(tentativeNewMid);

                    if (tentativeNewMidValue < midValue) { // go left
                        high =x;
                        x = tentativeNewMid;
                        midValue = tentativeNewMidValue;
                    } else { // go right
                        low = tentativeNewMid;
                    }
                } else {
                    Real tentativeNewMid = W*x+(1-W)*high;
                    Real tentativeNewMidValue =
                        objectiveFunction(tentativeNewMid);

                    if (tentativeNewMidValue < midValue) { // go right
                        low =x;
                        x = tentativeNewMid;
                        midValue = tentativeNewMidValue;
                    } else { // go left
                        high = tentativeNewMid;
                    }
                }
                ++iterations;
            }
            return x;
        }
    }

    SphereCylinderOptimizer::SphereCylinderOptimizer(Real r,
                                                     Real s,
                                                     Real alpha,
                                                     Real z1,
                                                     Real z2,
                                                     Real z3,
                                                     Real zweight)
    : r_(r), s_(s), alpha_(alpha), z1_(z1), z2_(z2), z3_(z3), zweight_(zweight)
    {

        QL_REQUIRE(r > 0, "sphere must have positive radius");

        s = std::max(s, 0.0);
        QL_REQUIRE(alpha > 0, "cylinder centre must have positive coordinate");

        nonEmpty_ = std::fabs(alpha - s) <= r;

        Real cylinderInside = r * r - (s + alpha) * (s + alpha);

        if (cylinderInside > 0.0) {
            topValue_ = alpha + s;
            bottomValue_ = alpha - s;
        } else {
            bottomValue_ = alpha - s;
            Real tmp = r * r - (s * s + alpha * alpha);

            if (tmp <= 0) { // max to left of maximum
                Real topValue2 = std::sqrt(s * s - tmp * tmp / (4 * alpha * alpha));
                topValue_ = alpha - std::sqrt(s * s - topValue2 * topValue2);
            } else {
                topValue_ = alpha + tmp / (2.0 * alpha);
            }
        }
    }

    bool SphereCylinderOptimizer::isIntersectionNonEmpty() const {
        return nonEmpty_;
    }

    void SphereCylinderOptimizer::findClosest(Size maxIterations,
                                              Real tolerance,
                                              Real& y1,
                                              Real& y2,
                                              Real& y3) const
    {
         Real x1,x2,x3;
         findByProjection(x1,x2,x3);

         y1 = BrentMinimize(
                bottomValue_, x1, topValue_,tolerance, maxIterations,
                [&](Real x){ return objectiveFunction(x); });
         y2 =std::sqrt(s_*s_ - (y1-alpha_)*(y1-alpha_));
         y3= std::sqrt(r_*r_ - y1*y1-y2*y2);
    }

    Real SphereCylinderOptimizer::objectiveFunction(Real x1) const
    {
   //     Real x1 = alpha_ - std::sqrt(s_*s_-x2*x2);

        Real x2sq = s_*s_ - (x1-alpha_)*(x1-alpha_);
         // a negative number will be minuscule and a result of rounding error
        Real x2 = x2sq >= 0.0 ? std::sqrt(x2sq) : 0.0;
        Real x3= std::sqrt(r_*r_ - x1*x1-x2*x2);

        Real err=0.0;
        err+= (x1-z1_)*(x1-z1_);
        err+= (x2-z2_)*(x2-z2_);
        err+= (x3-z3_)*(x3-z3_)*zweight_;

        return err;
    }

    bool SphereCylinderOptimizer::findByProjection(Real& y1,
                                                   Real& y2,
                                                   Real& y3) const {
        Real z1moved = z1_-alpha_;
        Real distance = std::sqrt( z1moved*z1moved + z2_*z2_);
        Real scale = s_/distance;
        Real y1moved = z1moved*scale;
        y1 = alpha_+ y1moved;
        y2 = scale*z2_;
        Real residual = r_*r_ - y1*y1 -y2*y2;
        if (residual >=0.0) {
            y3 = std::sqrt(residual);
            return true;
        }
        // we are outside the sphere
        if (!isIntersectionNonEmpty()) {
            y3=0.0;
            return false;
        }

       // intersection is non-empty but projection point is outside sphere
       // so take rightmost point
       y3 = 0.0;
       y1 = topValue_;
       y2 = std::sqrt(r_*r_ -y1*y1);

       return true;
    }

    std::vector<Real> sphereCylinderOptimizerClosest(Real r,
                                                     Real s,
                                                     Real alpha,
                                                     Real z1,
                                                     Real z2,
                                                     Real z3,
                                                     Natural maxIterations,
                                                     Real tolerance,
                                                     Real zweight)
    {

        SphereCylinderOptimizer optimizer(r, s, alpha, z1, z2, z3, zweight);
        std::vector<Real> y(3);

        QL_REQUIRE(optimizer.isIntersectionNonEmpty(),
                   "intersection empty so no solution");

        if (maxIterations ==0)
            optimizer.findByProjection(y[0], y[1], y[2]);
        else
            optimizer.findClosest(maxIterations, tolerance, y[0], y[1], y[2]);

        return y;
     }

}
]]></document_content>
  </document>
  <document index="67">
    <source>optimization/steepestdescent.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Nicolas Di Csar
 Copyright (C) 2009 Frdric Degraeve

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/optimization/steepestdescent.hpp>
#include <ql/math/optimization/problem.hpp>
#include <ql/math/optimization/linesearch.hpp>

namespace QuantLib {

    Disposable<Array> SteepestDescent::getUpdatedDirection(const Problem&,
                                                           Real,
                                                           const Array&) {
        return -lineSearch_->lastGradient();
    }

}
]]></document_content>
  </document>
  <document index="68">
    <source>pascaltriangle.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Ferdinando Ametrano
 Copyright (C) 2015 Paolo Mazzocchi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/pascaltriangle.hpp>
#include <iterator>

namespace QuantLib {

    std::vector<std::vector<BigNatural> > PascalTriangle::coefficients_;

    const std::vector<BigNatural>& PascalTriangle::get(Size order) {
        if (coefficients_.empty()) {
            // order zero mandatory for bootstrap
            coefficients_.emplace_back(1, 1);

            coefficients_.emplace_back(2, 1);
            coefficients_.emplace_back(3, 1);
            coefficients_[2][1] = 2;
            coefficients_.emplace_back(4, 1);
            coefficients_[3][1] = coefficients_[3][2] = 3;
        }
        while (coefficients_.size()<=order)
            nextOrder();
        return coefficients_[order];
    }

    void PascalTriangle::nextOrder() {
        Size order = coefficients_.size();
        coefficients_.emplace_back(order + 1);
        coefficients_[order][0] = coefficients_[order][order] = 1;
        for (Size i=1; i<order/2+1; ++i) {
            coefficients_[order][i] = coefficients_[order][order-i] =
                coefficients_[order-1][i-1] + coefficients_[order-1][i];
        }
    }

}
]]></document_content>
  </document>
  <document index="69">
    <source>polynomialmathfunction.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Ferdinando Ametrano
 Copyright (C) 2015 Paolo Mazzocchi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/polynomialmathfunction.hpp>
#include <ql/math/pascaltriangle.hpp>

namespace QuantLib {

    PolynomialFunction::PolynomialFunction(const std::vector<Real>& coeff) {

        QL_REQUIRE(!coeff.empty(), "empty coefficient vector");
        order_ = coeff.size();
        c_ = coeff;
        derC_ = std::vector<Real>(order_-1);
        prC_ = std::vector<Real>(order_);
        K_ = 0.0;
        eqs_ = Matrix(order_, order_, 0.0);

        Size i;
        for (i=0; i<order_-1; ++i) {
            prC_[i] = c_[i]/(i+1);
            derC_[i] = c_[i+1]*(i+1);
        }
        prC_[i] = c_[i]/(i + 1);
    }

    Real PolynomialFunction::operator()(Time t) const {
        Real result=0.0, tPower=1.0;
        for (Size i=0; i<order_; ++i) {
            result += c_[i] * tPower;
            tPower *= t;
        }
        return result;
    }

    Real PolynomialFunction::derivative(Time t) const {
        Real result=0.0, tPower=1.0;
        for (Size i=0; i<order_-1; ++i) {
            result += derC_[i] * tPower;
            tPower *= t;
        }
        return result;
    }

    Real PolynomialFunction::primitive(Time t) const {
        Real result=K_, tPower=t;
        for (Size i=0; i<order_; ++i) {
            result += prC_[i] * tPower;
            tPower *= t;
        }
        return result;
    }

    Real PolynomialFunction::definiteIntegral(Time t1,
                                              Time t2) const {
        return primitive(t2)-primitive(t1);
    }

    void PolynomialFunction::initializeEqs_(Time t,
                                            Time t2) const {
        Time dt = t2 - t;
        Real tau;
        for (Size i=0; i<order_; ++i) {
            tau = 1.0;
            for (Size j=i; j<order_; ++j) {
                tau *= dt;
                eqs_[i][j] = (tau * PascalTriangle::get(j + 1)[i]) / (j + 1);
            }
        }
    }

    std::vector<Real> 
         PolynomialFunction::definiteIntegralCoefficients(Time t,
                                                          Time t2) const {
        Array k(c_.begin(), c_.end());
        initializeEqs_(t, t2);
        Array coeff = eqs_ * k;
        std::vector<Real> result(coeff.begin(), coeff.end());
        return result; 
    }

    std::vector<Real>
        PolynomialFunction::definiteDerivativeCoefficients(Time t,
                                                           Time t2) const {
        Array k(c_.begin(), c_.end());
        initializeEqs_(t, t2);
        Array coeff = inverse(eqs_) * k;
        std::vector<Real> result(coeff.begin(), coeff.end());
        return result;
    }

}
]]></document_content>
  </document>
  <document index="70">
    <source>primenumbers.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

// ===========================================================================
// NOTE: The following copyright notice applies to the original code,
//
// Copyright (C) 2002 Peter Jckel "Monte Carlo Methods in Finance".
// All rights reserved.
//
// Permission to use, copy, modify, and distribute this software is freely
// granted, provided that this notice is preserved.
// ===========================================================================

#include <ql/math/primenumbers.hpp>
#include <iterator>

namespace QuantLib {

    namespace {

        const BigNatural firstPrimes[] = {
            // the first two primes are mandatory for bootstrapping
            2,  3,
            // optional additional precomputed primes
            5,  7, 11, 13, 17, 19, 23, 29,
            31, 37, 41, 43, 47 };
    }

    std::vector<BigNatural> PrimeNumbers::primeNumbers_;

    BigNatural PrimeNumbers::get(Size absoluteIndex) {
        if (primeNumbers_.empty()) {
            Size n = sizeof(firstPrimes)/sizeof(firstPrimes[0]);
            primeNumbers_.insert(primeNumbers_.end(),
                                 firstPrimes, firstPrimes+n);
        }
        while (primeNumbers_.size()<=absoluteIndex)
            nextPrimeNumber();
        return primeNumbers_[absoluteIndex];
    }

    BigNatural PrimeNumbers::nextPrimeNumber() {
        BigNatural p, n, m = primeNumbers_.back();
        do {
            // skip the even numbers
            m += 2;
            n = static_cast<BigNatural>(std::sqrt(Real(m)));
            // i=1 since the even numbers have already been skipped
            Size i = 1;
            do {
                p = primeNumbers_[i];
                ++i;
            } while (((m % p) != 0U) && p <= n);
        } while ( p<=n );
        primeNumbers_.push_back(m);
        return m;
    }

}
]]></document_content>
  </document>
  <document index="71">
    <source>quadratic.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/quadratic.hpp>

namespace QuantLib
{

    quadratic::quadratic(Real a, Real b, Real c) : a_(a), b_(b), c_(c) {}

    Real quadratic::turningPoint() const {
        return -b_/(2.0*a_);
    }

    Real quadratic::valueAtTurningPoint() const {
        return (*this)(turningPoint());
    }

    Real quadratic::operator()(Real x) const {
        return x*(x*a_+b_)+c_;
    }

    Real quadratic::discriminant() const {
        return b_*b_-4*a_*c_;
    }

    // return false if roots not real, and give turning point instead
    bool quadratic::roots(Real& x, Real& y) const {
        Real d = discriminant();
        if (d<0) {
            x = y = turningPoint();
            return false;
        }
        d = std::sqrt(d);
        x = (-b_ -  d)/(2*a_);
        y = (-b_ + d)/(2*a_);
        return true;

    }
}
]]></document_content>
  </document>
  <document index="72">
    <source>randomnumbers/faurersg.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano
 Copyright (C) 2004 Gianni Piolanti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/randomnumbers/faurersg.hpp>
#include <ql/math/primenumbers.hpp>

namespace QuantLib {

    FaureRsg::FaureRsg(Size dimensionality)
    : dimensionality_(dimensionality),
//      sequenceCounter_(0),
      sequence_(std::vector<Real> (dimensionality), 1.0),
      integerSequence_(dimensionality, 0) {

        QL_REQUIRE(dimensionality>0, 
                   "dimensionality must be greater than 0");

        // base is the lowest prime number >= dimensionality_
        Size i, j, k=1;
        base_=2;
        while (base_<dimensionality_) {
            base_ = (Size)PrimeNumbers::get(k);
            k++;
        }


        mbit_=(Size)(std::log((double)std::numeric_limits<long int>::max())/
            std::log((double)base_));
        gray_ = std::vector<std::vector<long int> >(dimensionality_,
            std::vector<long int>(mbit_+1, 0));
        bary_ = std::vector<long int>(mbit_+1, 0);


        //setMatrixValues();
        powBase_ = std::vector<std::vector<long int> >(mbit_,
            std::vector<long int>(2*base_-1, 0));
        powBase_[mbit_-1][base_] = 1;
        for (int i2=mbit_-2; i2>=0; --i2)
            powBase_[i2][base_] = powBase_[i2+1][base_] * base_;
        for (int ii=0; ii<(int)mbit_; ii++) {
            for (int j1=base_+1; j1<2*(int)base_-1; j1++ )
                powBase_[ii][j1] = powBase_[ii][j1-1] + powBase_[ii][base_];
            for (int j2=base_-1; j2>=0; --j2)
                powBase_[ii][j2] = powBase_[ii][j2+1] - powBase_[ii][base_];
        }

        addOne_.resize(base_);
        for (j=0; j<base_ ; j++)
            addOne_[j] = (j+1) % base_;


        //setPascalMatrix();
        for (k=0; k<mbit_; k++) {
            std::vector<std::vector<long int> > mm(dimensionality_+1,
                std::vector<long int>(k+1, 0));
            pascal3D.push_back(mm);
            pascal3D[k][0][k] = 1;
            pascal3D[k][1][0] = 1;
            pascal3D[k][1][k] = 1;
        }

        long int p1, p2;
        for (k=2; k<mbit_ ; k++) {
            for (i=1; i<k ; i++) {
                p1 = pascal3D[k-1][1][i-1];
                p2 = pascal3D[k-1][1][i];
                pascal3D[k][1][i] = (p1+p2) % base_;
            }
        }

        long int fact = 1, diag;
        for (j=2; j<dimensionality_; j++) {
          for (long int kk=mbit_-1; kk>=0 ; --kk) {
              diag = mbit_ - kk - 1;
              if (diag==0)
                  fact = 1;
              else
                  fact = (fact*j) % base_;
              for (long int ii=0; ii<=kk; ii++)
                  pascal3D[diag+ii][j][ii] = (fact*
                    pascal3D[diag+ii][1][ii]) % base_;
          }
        }


        normalizationFactor_ = (double)base_ * (double)powBase_[0][base_];
        // std::cout << IntegerFormatter::toString(dimensionality_) << ", " ;
        // std::cout << IntegerFormatter::toString(normalizationFactor_);
        // std::cout << std::endl;
  }

    void FaureRsg::generateNextIntSequence() const {
        // sequenceCounter_++;

        Size bit = 0;
        bary_[bit] = addOne_[bary_[bit]];
        while (bary_[bit] == 0) {
            bit++;
            bary_[bit] = addOne_[bary_[bit]];
        };
        QL_REQUIRE(bit != mbit_,
            "Error processing Faure sequence." );

        long int tmp, g1, g2;
        for (Size i=0; i<dimensionality_ ; i++) {
            for (Size j=0; j<=bit ; j++) {
                tmp = gray_[i][j];
                gray_[i][j] = (pascal3D[bit][i][j] + tmp) % base_;
                g1 = gray_[i][j];
                g2 = base_ - 1 + g1 - tmp;
                integerSequence_[i] += powBase_[j][g2];
            }
        }
    }

}


]]></document_content>
  </document>
  <document index="73">
    <source>randomnumbers/haltonrsg.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

// ===========================================================================
// NOTE: The following copyright notice applies to the original code,
//
// Copyright (C) 2002 Peter Jckel "Monte Carlo Methods in Finance".
// All rights reserved.
//
// Permission to use, copy, modify, and distribute this software is freely
// granted, provided that this notice is preserved.
// ===========================================================================

#include <ql/math/randomnumbers/haltonrsg.hpp>
#include <ql/math/randomnumbers/rngtraits.hpp>
#include <ql/math/primenumbers.hpp>

namespace QuantLib {

    HaltonRsg::HaltonRsg(Size dimensionality, unsigned long seed,
                         bool randomStart, bool randomShift)
    : dimensionality_(dimensionality), sequenceCounter_(0),
      sequence_(std::vector<Real> (dimensionality), 1.0),
      randomStart_(dimensionality, 0UL),
      randomShift_(dimensionality, 0.0) {

        QL_REQUIRE(dimensionality>0, 
                   "dimensionality must be greater than 0");

        if (randomStart || randomShift) {
            RandomSequenceGenerator<MersenneTwisterUniformRng>
                uniformRsg(dimensionality_, seed);
            if (randomStart)
                randomStart_ = uniformRsg.nextInt32Sequence();
            if (randomShift)
                randomShift_ = uniformRsg.nextSequence().value;
        }

    }

    const HaltonRsg::sample_type& HaltonRsg::nextSequence() const {
        ++sequenceCounter_;
        for (Size i=0; i<dimensionality_; ++i) {
            double h = 0.0;
            unsigned long b = PrimeNumbers::get(i);
            double f = 1.0;
            unsigned long k = sequenceCounter_+randomStart_[i];
            while (k != 0U) {
                f /= b;
                h += (k%b)*f;
                k /= b;
            }
            sequence_.value[i] = h+randomShift_[i];
            sequence_.value[i] -= long(sequence_.value[i]);
        }
        return sequence_;
    }

}

]]></document_content>
  </document>
  <document index="74">
    <source>randomnumbers/knuthuniformrng.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/randomnumbers/knuthuniformrng.hpp>
#include <ql/math/randomnumbers/seedgenerator.hpp>

namespace QuantLib {

    const int KnuthUniformRng::KK = 100;
    const int KnuthUniformRng::LL = 37;
    const int KnuthUniformRng::TT = 70;
    const int KnuthUniformRng::QUALITY = 1009;

    KnuthUniformRng::KnuthUniformRng(long seed)
    : ranf_arr_buf(QUALITY), ran_u(QUALITY) {
        ranf_arr_ptr = ranf_arr_sentinel = ranf_arr_buf.size();
        ranf_start(seed != 0 ? seed : SeedGenerator::instance().get());
    }

    void KnuthUniformRng::ranf_start(long seed) {
        int t,s,j;
        std::vector<double> u(KK+KK-1),ul(KK+KK-1);
        double ulp=(1.0/(1L<<30))/(1L<<22);                // 2 to the -52
        double ss=2.0*ulp*((seed&0x3fffffff)+2);

        for (j=0;j<KK;j++) {
            u[j]=ss; ul[j]=0.0;                    // bootstrap the buffer
            ss+=ss; if (ss>=1.0) ss-=1.0-2*ulp; // cyclic shift of 51 bits
        }
        for (;j<KK+KK-1;j++) u[j]=ul[j]=0.0;
        u[1]+=ulp;ul[1]=ulp;            // make u[1] (and only u[1]) "odd"
        s=seed&0x3fffffff;
        t=TT-1;
        while (t != 0) {
            for (j=KK-1;j>0;--j) ul[j+j]=ul[j],u[j+j]=u[j];    // "square"
            for (j=KK+KK-2;j>KK-LL;j-=2)
                ul[KK+KK-1-j]=0.0,u[KK+KK-1-j]=u[j]-ul[j];
            for (j=KK+KK-2;j>=KK;--j)
                if (ul[j] != 0.0) {
                    ul[j - (KK - LL)] = ulp - ul[j - (KK - LL)],
                                 u[j - (KK - LL)] = mod_sum(u[j - (KK - LL)], u[j]);
                    ul[j - KK] = ulp - ul[j - KK], u[j - KK] = mod_sum(u[j - KK], u[j]);
            }
            if (is_odd(s)) {                            // "multiply by z"
                for (j=KK;j>0;--j)  ul[j]=ul[j-1],u[j]=u[j-1];
                ul[0]=ul[KK],u[0]=u[KK];    // shift the buffer cyclically
                if (ul[KK] != 0.0)
                    ul[LL] = ulp - ul[LL], u[LL] = mod_sum(u[LL], u[KK]);
            }
            if (s != 0)
                s >>= 1;
            else
                t--;
        }
        for (j=0;j<LL;j++) ran_u[j+KK-LL]=u[j];
        for (;j<KK;j++) ran_u[j-LL]=u[j];
    }

    void KnuthUniformRng::ranf_array(std::vector<double>& aa,
                                     int n) const {
        int i,j;
        for (j=0;j<KK;j++) aa[j]=ran_u[j];
        for (;j<n;j++) aa[j]=mod_sum(aa[j-KK],aa[j-LL]);
        for (i=0;i<LL;i++,j++) ran_u[i]=mod_sum(aa[j-KK],aa[j-LL]);
        for (;i<KK;i++,j++) ran_u[i]=mod_sum(aa[j-KK],ran_u[i-LL]);
    }

    double KnuthUniformRng::ranf_arr_cycle() const {
        ranf_array(ranf_arr_buf,QUALITY);
        ranf_arr_ptr = 1;
        ranf_arr_sentinel = 100;
        return ranf_arr_buf[0];
    }

}
]]></document_content>
  </document>
  <document index="75">
    <source>randomnumbers/latticersg.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2007 Mark Joshi

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file latticersg.cpp
\brief lattice rule code for low discrepancy numbers
*/

#include <ql/math/randomnumbers/latticersg.hpp>
#include <utility>
namespace QuantLib {

    LatticeRsg::LatticeRsg(Size dimensionality, std::vector<Real> z, Size N)
    : dimensionality_(dimensionality), N_(N), i_(0), z_(std::move(z)),
      sequence_(std::vector<Real>(dimensionality), 1.0) {}
    /*! skip to the n-th sample in the low-discrepancy sequence */
    void LatticeRsg::skipTo(unsigned long n)
    {
        i_+=n;
    }

    const LatticeRsg::sample_type& LatticeRsg::nextSequence()
    {
        for (Size j=0; j < dimensionality_; ++j)
        {
            Real theta = i_*z_[j]/N_;
            sequence_.value[j]= std::fmod(theta,1.0);
        }
        ++i_;

        return sequence_;
    
    }

}
]]></document_content>
  </document>
  <document index="76">
    <source>randomnumbers/lecuyeruniformrng.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/randomnumbers/lecuyeruniformrng.hpp>
#include <ql/math/randomnumbers/seedgenerator.hpp>

namespace QuantLib {

    const long LecuyerUniformRng::m1 = 2147483563L;
    const long LecuyerUniformRng::a1 = 40014L;
    const long LecuyerUniformRng::q1 = 53668L;
    const long LecuyerUniformRng::r1 = 12211L;

    const long LecuyerUniformRng::m2 = 2147483399L;
    const long LecuyerUniformRng::a2 = 40692L;
    const long LecuyerUniformRng::q2 = 52774L;
    const long LecuyerUniformRng::r2 = 3791L;

    const int LecuyerUniformRng::bufferSize = 32;

    // int(1+m1/bufferSize) = int(1+(m1-1)/bufferSize)
    const long LecuyerUniformRng::bufferNormalizer = 67108862L;

    const long double LecuyerUniformRng::maxRandom = 1.0-QL_EPSILON;

    LecuyerUniformRng::LecuyerUniformRng(long seed)
    : buffer(LecuyerUniformRng::bufferSize) {
        // Need to prevent seed=0, so use seed=0 to have a "random" seed
        temp2 = temp1 = (seed != 0 ? seed : SeedGenerator::instance().get());
        // Load the shuffle table (after 8 warm-ups)
        for (int j=bufferSize+7; j>=0; j--) {
            long k = temp1/q1;
            temp1 = a1*(temp1-k*q1)-k*r1;
            if (temp1 < 0)
                temp1 += m1;
            if (j < bufferSize)
                buffer[j] = temp1;
        }
        y = buffer[0];
    }

    LecuyerUniformRng::sample_type LecuyerUniformRng::next() const {
        long k = temp1/q1;
        // Compute temp1=(a1*temp1) % m1
        // without overflows (Schrage's method)
        temp1 = a1*(temp1-k*q1)-k*r1;
        if (temp1 < 0)
            temp1 += m1;
        k = temp2/q2;
        // Compute temp2=(a2*temp2) % m2
        // without overflows (Schrage's method)
        temp2 = a2*(temp2-k*q2)-k*r2;
        if (temp2 < 0)
            temp2 += m2;
        // Will be in the range 0..bufferSize-1
        int j = y/bufferNormalizer;
        // Here temp1 is shuffled, temp1 and temp2 are
        // combined to generate output
        y = buffer[j]-temp2;
        buffer[j] = temp1;
        if (y < 1)
            y += m1-1;
        double result = y/double(m1);
        // users don't expect endpoint values
        if (result > maxRandom)
            result = (double) maxRandom;
        return {result, 1.0};
    }

}
]]></document_content>
  </document>
  <document index="77">
    <source>randomnumbers/mt19937uniformrng.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2010 Kakhkhor Abdijalilov

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


// NOTE: The following copyright notice applies to
// the original C implementation that has been used for this class

/*
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using init_genrand(seed)
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote
        products derived from this software without specific prior written
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
   email: matumoto@math.keio.ac.jp
*/


#include <ql/math/randomnumbers/seedgenerator.hpp>
#include <ql/math/randomnumbers/mt19937uniformrng.hpp>

namespace QuantLib {

    // constant vector a
    const unsigned long MersenneTwisterUniformRng::MATRIX_A = 0x9908b0dfUL;
    // most significant w-r bits
    const unsigned long MersenneTwisterUniformRng::UPPER_MASK=0x80000000UL;
    // least significant r bits
    const unsigned long MersenneTwisterUniformRng::LOWER_MASK=0x7fffffffUL;


    MersenneTwisterUniformRng::MersenneTwisterUniformRng(unsigned long seed) {
        seedInitialization(seed);
    }

    void MersenneTwisterUniformRng::seedInitialization(unsigned long seed) {
        /* initializes mt with a seed */
        unsigned long s = (seed != 0 ? seed : SeedGenerator::instance().get());
        mt[0]= s & 0xffffffffUL;
        for (mti=1; mti<N; mti++) {
            mt[mti] =
                (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);
            /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
            /* In the previous versions, MSBs of the seed affect   */
            /* only MSBs of the array mt[].                        */
            /* 2002/01/09 modified by Makoto Matsumoto             */
            mt[mti] &= 0xffffffffUL;
            /* for >32 bit machines */
        }
    }

    MersenneTwisterUniformRng::MersenneTwisterUniformRng(
                                      const std::vector<unsigned long>& seeds) {
        seedInitialization(19650218UL);
        Size i=1, j=0, k = (N>seeds.size() ? N : seeds.size());
        for (; k != 0U; k--) {
            mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
                + seeds[j] + j; /* non linear */
            mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
            i++; j++;
            if (i>=N) { mt[0] = mt[N-1]; i=1; }
            if (j>=seeds.size()) j=0;
        }
        for (k = N - 1; k != 0U; k--) {
            mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))
                - i; /* non linear */
            mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
            i++;
            if (i>=N) { mt[0] = mt[N-1]; i=1; }
        }

        mt[0] = UPPER_MASK; /*MSB is 1; assuring non-zero initial array*/
    }

    void MersenneTwisterUniformRng::twist() const {
        static const unsigned long mag01[2]={0x0UL, MATRIX_A};
        /* mag01[x] = x * MATRIX_A  for x=0,1 */
        Size kk;
        unsigned long y;

        for (kk=0;kk<N-M;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        for (;kk<N-1;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[(kk+M)-N] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];

        mti = 0;
    }

}
]]></document_content>
  </document>
  <document index="78">
    <source>randomnumbers/seedgenerator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/randomnumbers/seedgenerator.hpp>
#include <ctime>
#if defined(BOOST_NO_STDC_NAMESPACE)
    namespace std { using ::time; }
#endif

namespace QuantLib {

    // we need to prevent rng from being default-initialized
    SeedGenerator::SeedGenerator() : rng_(42UL) {
        initialize();
    }

    void SeedGenerator::initialize() {

        // firstSeed is chosen based on clock() and used for the first rng
        auto firstSeed = (unsigned long)(std::time(nullptr));
        MersenneTwisterUniformRng first(firstSeed);

        // secondSeed is as random as it could be
        // feel free to suggest improvements
        unsigned long secondSeed = first.nextInt32();

        MersenneTwisterUniformRng second(secondSeed);

        // use the second rng to initialize the final one
        unsigned long skip = second.nextInt32() % 1000;
        std::vector<unsigned long> init(4);
        init[0]=second.nextInt32();
        init[1]=second.nextInt32();
        init[2]=second.nextInt32();
        init[3]=second.nextInt32();

        rng_ = MersenneTwisterUniformRng(init);

        for (unsigned long i=0; i<skip ; i++)
            rng_.nextInt32();
    }

    unsigned long SeedGenerator::get() {
        return rng_.nextInt32();
    }

}
]]></document_content>
  </document>
  <document index="79">
    <source>randomnumbers/sobolbrownianbridgersg.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file brownianbridgersg.hpp
    \brief interface class to map the functionality of SobolBrownianGenerator
           to the "conventional" sequence generator interface
*/

#include <ql/math/randomnumbers/sobolbrownianbridgersg.hpp>

namespace QuantLib {
    SobolBrownianBridgeRsg::SobolBrownianBridgeRsg(
        Size factors, Size steps,
        SobolBrownianGenerator::Ordering ordering,
        unsigned long seed,
        SobolRsg::DirectionIntegers directionIntegers)
    : factors_(factors), steps_(steps), dim_(factors*steps),
      seq_(sample_type::value_type(factors*steps), 1.0),
      gen_(factors, steps, ordering, seed, directionIntegers) {
    }

    const SobolBrownianBridgeRsg::sample_type&
    SobolBrownianBridgeRsg::nextSequence() const {
        gen_.nextPath();
        std::vector<Real> output(factors_);
        for (Size i=0; i < steps_; ++i) {
            gen_.nextStep(output);
            std::copy(output.begin(), output.end(),
                      seq_.value.begin()+i*factors_);
        }

        return seq_;
    }

    const SobolBrownianBridgeRsg::sample_type&
    SobolBrownianBridgeRsg::lastSequence() const {
        return seq_;
    }

    Size SobolBrownianBridgeRsg::dimension() const {
        return dim_;
    }
}
]]></document_content>
  </document>
  <document index="80">
    <source>randomnumbers/stochasticcollocationinvcdf.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*

 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file stochasticcollationcdf.cpp
*/

#include <ql/mathconstants.hpp>
#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/math/randomnumbers/stochasticcollocationinvcdf.hpp>

namespace QuantLib {

    namespace {
        Disposable<Array> g(Real sigma, const Array& x,
                            const ext::function<Real(Real)>& invCDF) {

            Array y(x.size());
            const CumulativeNormalDistribution normalCDF;

            for (Size i=0, n=x.size(); i < n; ++i) {
                y[i] = invCDF(normalCDF(x[i]/sigma));
            }

            return y;
        }
    }

    StochasticCollocationInvCDF::StochasticCollocationInvCDF(
        const ext::function<Real(Real)>& invCDF,
        Size lagrangeOrder, Real pMax, Real pMin)
    : x_(M_SQRT2*GaussHermiteIntegration(lagrangeOrder).x()),
      sigma_( (pMax != Null<Real>())
              ? x_.back() / InverseCumulativeNormal()(pMax)
              : (pMin != Null<Real>())
                  ? x_.front() / InverseCumulativeNormal()(pMin)
                  : 1.0),
      y_(g(sigma_, x_, invCDF)),
      interpl_(x_.begin(), x_.end(), y_.begin()) {
    }

    Real StochasticCollocationInvCDF::value(Real x) const {
        return interpl_(x*sigma_, true);
    }
    Real StochasticCollocationInvCDF::operator()(Real u) const {
        return value(InverseCumulativeNormal()(u));
    }
}
]]></document_content>
  </document>
  <document index="81">
    <source>richardsonextrapolation.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file richardsonextrapolation.cpp
*/

#include <ql/errors.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/math/richardsonextrapolation.hpp>

#include <cmath>

namespace QuantLib {
    namespace {
        class RichardsonEqn {
          public:
            RichardsonEqn(Real fh, Real ft, Real fs, Real t, Real s)
            : fdelta_h_(fh), ft_(ft), fs_(fs), t_(t), s_(s) { }

            Real operator()(Real k) const {
                return      ft_ + (ft_-fdelta_h_)/(std::pow(t_, k)-1.0)
                        - ( fs_ + (fs_-fdelta_h_)/(std::pow(s_, k)-1.0));
            }
          private:
            const Real fdelta_h_, ft_, fs_, t_, s_;
        };

    }

    RichardsonExtrapolation::RichardsonExtrapolation(
        const ext::function<Real (Real)>& f, Real delta_h, Real n)
    : delta_h_(delta_h),
      fdelta_h_(f(delta_h)),
      n_(n),
      f_(f) {
    }


    Real RichardsonExtrapolation::operator()(Real t) const {

        QL_REQUIRE(t > 1, "scaling factor must be greater than 1");
        QL_REQUIRE(n_ != Null<Real>(), "order of convergence must be known");

        const Real tk = std::pow(t, n_);

        return (tk*f_(delta_h_/t)-fdelta_h_)/(tk-1.0);
    }

    Real RichardsonExtrapolation::operator()(Real t, Real s)
    const {
        QL_REQUIRE(t > 1 && s > 1, "scaling factors must be greater than 1");
        QL_REQUIRE(t > s, "t must be greater than s");

        const Real ft = f_(delta_h_/t);
        const Real fs = f_(delta_h_/s);

        const RichardsonEqn eqn(fdelta_h_, ft, fs, t, s);

        const Real step = 0.1;
        Real left = 0.05;
        Real fr = eqn(left + step), fl = eqn(left);
        while (fr*fl > 0.0 && left < 15.1) {
            left+=step;
            fl = fr;
            fr = eqn(left + step);
        }

        QL_REQUIRE(left < 15.1,"could not estimate the order of convergence");

        const Real k = Brent().solve(eqn, 1e-8, left+0.5*step, left, left+step);

        const Real ts = std::pow(s, k);

        return (ts*fs-fdelta_h_)/(ts-1.0);
    }
}
]]></document_content>
  </document>
  <document index="82">
    <source>rounding.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Decillion Pty(Ltd)

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file rounding.hpp
    \brief Rounding implementation
*/

#include <ql/math/rounding.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    Decimal Rounding::operator()(Decimal value) const {

        if (type_ == None)
            return value;

        Real mult = std::pow(10.0,precision_);
        bool neg = (value < 0.0);
        Real lvalue = std::fabs(value)*mult;
        Real integral = 0.0;
        Real modVal = std::modf(lvalue,&integral);
        lvalue -= modVal;
        switch (type_) {
          case Down:
            break;
          case Up:
            if (modVal != 0.0)
                lvalue += 1.0;
            break;
          case Closest:
            if (modVal >= (digit_/10.0))
                lvalue += 1.0;
            break;
          case Floor:
            if (!neg) {
                if (modVal >= (digit_/10.0))
                    lvalue += 1.0;
            }
            break;
          case Ceiling:
            if (neg) {
                if (modVal >= (digit_/10.0))
                    lvalue += 1.0;
            }
            break;
          default:
            QL_FAIL("unknown rounding method");
        }
        return (neg) ? -(lvalue/mult) : lvalue/mult;
    }

}
]]></document_content>
  </document>
  <document index="83">
    <source>sampledcurve.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/sampledcurve.hpp>

namespace QuantLib {

    Real SampledCurve::valueAtCenter() const {
        QL_REQUIRE(!empty(), "empty sampled curve");
        Size jmid = size()/2;
        if (size() % 2 == 1)
            return values_[jmid];
        else
            return (values_[jmid]+values_[jmid-1])/2.0;
    }

    Real SampledCurve::firstDerivativeAtCenter() const {
        QL_REQUIRE(size()>=3,
                   "the size of the curve must be at least 3");
        Size jmid = size()/2;
        if (size() % 2 == 1) {
            return (values_[jmid+1]-values_[jmid-1])/
                (grid_[jmid+1]-grid_[jmid-1]);
        } else {
            return (values_[jmid]-values_[jmid-1])/
                (grid_[jmid]-grid_[jmid-1]);
        }
    }

    Real SampledCurve::secondDerivativeAtCenter() const {
        QL_REQUIRE(size()>=4,
                   "the size of the curve must be at least 4");
        Size jmid = size()/2;
        if (size() % 2 == 1) {
            Real deltaPlus = (values_[jmid+1]-values_[jmid])/
                (grid_[jmid+1]-grid_[jmid]);
            Real deltaMinus = (values_[jmid]-values_[jmid-1])/
                (grid_[jmid]-grid_[jmid-1]);
            Real dS = (grid_[jmid+1]-grid_[jmid-1])/2.0;
            return (deltaPlus-deltaMinus)/dS;
        } else {
            Real deltaPlus = (values_[jmid+1]-values_[jmid-1])/
                (grid_[jmid+1]-grid_[jmid-1]);
            Real deltaMinus = (values_[jmid]-values_[jmid-2])/
                (grid_[jmid]-grid_[jmid-2]);
            return (deltaPlus-deltaMinus)/
                (grid_[jmid]-grid_[jmid-1]);
        }
    }

    void SampledCurve::regrid(const Array &new_grid) {
        CubicInterpolation priceSpline(grid_.begin(), grid_.end(),
                                       values_.begin(),
                                       CubicInterpolation::Spline, false,
                                       CubicInterpolation::SecondDerivative, 0.0,
                                       CubicInterpolation::SecondDerivative, 0.0);
        priceSpline.update();
        Array newValues(new_grid.size());
        Array::iterator val;
        Array::const_iterator grid;
        for (val = newValues.begin(), grid = new_grid.begin() ;
             grid != new_grid.end();
             ++val, ++grid) {
            *val = priceSpline(*grid, true);
        }
        values_.swap(newValues);
        grid_ = new_grid;
    }

}

]]></document_content>
  </document>
  <document index="84">
    <source>statistics/discrepancystatistics.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/statistics/discrepancystatistics.hpp>

namespace QuantLib {

    Real DiscrepancyStatistics::discrepancy() const {
        Size N = samples();
        /*
        Size i;
        Real r_ik, r_jk, cdiscr = adiscr = 0.0, temp = 1.0;

        for (i=0; i<N; i++) {
            Real temp = 1.0;
            for (Size k=0; k<dimension_; k++) {
                r_ik = stats_[k].sampleData()[i].first;
                temp *= (1.0 - r_ik*r_ik);
            }
            cdiscr += temp;
        }

        for (i=0; i<N; i++) {
            for (Size j=0; j<N; j++) {
                Real temp = 1.0;
                for (Size k=0; k<dimension_; k++) {
                    r_jk = stats_[k].sampleData()[j].first;
                    r_ik = stats_[k].sampleData()[i].first;
                    temp *= (1.0 - std::max(r_ik, r_jk));
                }
                adiscr += temp;
            }
        }
        */
        return std::sqrt(adiscr_/(N*N)-bdiscr_/N*cdiscr_+ddiscr_);
    }

}


]]></document_content>
  </document>
  <document index="85">
    <source>statistics/generalstatistics.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/statistics/generalstatistics.hpp>
#include <ql/math/functional.hpp>

namespace QuantLib {

    Real GeneralStatistics::weightSum() const {
        Real result = 0.0;
        std::vector<std::pair<Real,Real> >::const_iterator it;
        for (it=samples_.begin(); it!=samples_.end(); ++it) {
            result += it->second;
        }
        return result;
    }

    Real GeneralStatistics::mean() const {
        Size N = samples();
        QL_REQUIRE(N != 0, "empty sample set");
        // eat our own dog food
        return expectationValue(identity<Real>(),
                                everywhere()).first;
    }

    Real GeneralStatistics::variance() const {
        Size N = samples();
        QL_REQUIRE(N > 1,
                   "sample number <=1, unsufficient");
        // Subtract the mean and square. Repeat on the whole range.
        // Hopefully, the whole thing will be inlined in a single loop.
        Real s2 = expectationValue(compose(square<Real>(),
                                           subtract<Real>(mean())),
                                   everywhere()).first;
        return s2*N/(N-1.0);
    }

    Real GeneralStatistics::skewness() const {
        Size N = samples();
        QL_REQUIRE(N > 2,
                   "sample number <=2, unsufficient");

        Real x = expectationValue(compose(cube<Real>(),
                                          subtract<Real>(mean())),
                                  everywhere()).first;
        Real sigma = standardDeviation();

        return (x/(sigma*sigma*sigma))*(N/(N-1.0))*(N/(N-2.0));
    }

    Real GeneralStatistics::kurtosis() const {
        Size N = samples();
        QL_REQUIRE(N > 3,
                   "sample number <=3, unsufficient");

        Real x = expectationValue(compose(fourth_power<Real>(),
                                          subtract<Real>(mean())),
                                  everywhere()).first;
        Real sigma2 = variance();

        Real c1 = (N/(N-1.0)) * (N/(N-2.0)) * ((N+1.0)/(N-3.0));
        Real c2 = 3.0 * ((N-1.0)/(N-2.0)) * ((N-1.0)/(N-3.0));

        return c1*(x/(sigma2*sigma2))-c2;
    }

    Real GeneralStatistics::percentile(Real percent) const {

        QL_REQUIRE(percent > 0.0 && percent <= 1.0,
                   "percentile (" << percent << ") must be in (0.0, 1.0]");

        Real sampleWeight = weightSum();
        QL_REQUIRE(sampleWeight>0.0,
                   "empty sample set");

        sort();

        std::vector<std::pair<Real,Real> >::iterator k, l;
        k = samples_.begin();
        l = samples_.end()-1;
        /* the sum of weight is non null, therefore there's
           at least one sample */
        Real integral = k->second, target = percent*sampleWeight;
        while (integral < target && k != l) {
            ++k;
            integral += k->second;
        }
        return k->first;
    }

    Real GeneralStatistics::topPercentile(Real percent) const {

        QL_REQUIRE(percent > 0.0 && percent <= 1.0,
                   "percentile (" << percent << ") must be in (0.0, 1.0]");

        Real sampleWeight = weightSum();
        QL_REQUIRE(sampleWeight > 0.0,
                   "empty sample set");

        sort();

        std::vector<std::pair<Real,Real> >::reverse_iterator k, l;
        k = samples_.rbegin();
        l = samples_.rend()-1;
        /* the sum of weight is non null, therefore there's
           at least one sample */
        Real integral = k->second, target = percent*sampleWeight;
        while (integral < target && k != l) {
            ++k;
            integral += k->second;
        }
        return k->first;
    }

}
]]></document_content>
  </document>
  <document index="86">
    <source>statistics/histogram.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Gang Liang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/statistics/histogram.hpp>
#include <ql/math/statistics/incrementalstatistics.hpp>
#include <ql/math/comparison.hpp>
#include <algorithm>

namespace QuantLib {

    namespace {

        /* The discontinuous quantiles use the method (type 8) as
           recommended by Hyndman and Fan (1996). The resulting
           quantile estimates are approximately median-unbiased
           regardless of the distribution of 'samples'.

           If quantile function is called multiple times for the same
           dataset, it is recommended to pre-sort the sample vector.
        */
        Real quantile(const std::vector<Real>& samples, Real prob) {
            Size nsample = samples.size();
            QL_REQUIRE(prob >= 0.0 && prob <= 1.0,
                       "Probability has to be in [0,1].");
            QL_REQUIRE(nsample > 0, "The sample size has to be positive." );

            if (nsample == 1)
                return samples[0];

            // two special cases: close to boundaries
            const Real a = 1. / 3, b = 2*a / (nsample+a);
            if (prob < b)
                return *std::min_element(samples.begin(), samples.end());
            else if (prob > 1-b)
                return *std::max_element(samples.begin(), samples.end());

            // general situation: middle region and nsample >= 2
            Size index = static_cast<Size>(std::floor((nsample+a)*prob+a));
            std::vector<Real> sorted(index+1);
            std::partial_sort_copy(samples.begin(), samples.end(),
                                   sorted.begin(), sorted.end());

            // use "index & index+1"th elements to interpolate the quantile
            Real weight = nsample*prob + a - index;
            return (1-weight) * sorted[index-1] + weight * sorted[index];
        }

    }


    Size Histogram::bins() const {
        return bins_;
    }

    const std::vector<Real>& Histogram::breaks() const {
        return breaks_;
    }

    Histogram::Algorithm Histogram::algorithm() const {
        return algorithm_;
    }

    bool Histogram::empty() const {
        return bins_ == 0;
    }

    Size Histogram::counts(Size i) const {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        return counts_.at(i);
        #else
        return counts_[i];
        #endif
    }

    Real Histogram::frequency(Size i) const {
        #if defined(QL_EXTRA_SAFETY_CHECKS)
        return frequency_.at(i);
        #else
        return frequency_[i];
        #endif
    }

    void Histogram::calculate() {
        QL_REQUIRE(!data_.empty(), "no data given");

        Real min = *std::min_element(data_.begin(), data_.end());
        Real max = *std::max_element(data_.begin(), data_.end());

        // calculate number of bins if necessary
        if (bins_ == Null<Size>()) {
            switch (algorithm_) {
              case Sturges: {
                  bins_ = static_cast<Size>(
                           std::ceil(std::log(static_cast<Real>(data_.size()))
                                     /std::log(2.0) + 1));
                  break;
              }
              case FD: {
                  Real r1 = quantile(data_, 0.25);
                  Real r2 = quantile(data_, 0.75);
                  Real h = 2.0 * (r2-r1) * std::pow(static_cast<Real>(data_.size()), -1.0/3.0);
                  bins_ = static_cast<Size>(std::ceil((max-min)/h));
                  break;
              }
              case Scott: {
                  IncrementalStatistics summary;
                  summary.addSequence(data_.begin(), data_.end());
                  Real variance = summary.variance();
                  Real h = 3.5 * std::sqrt(variance)
                         * std::pow(static_cast<Real>(data_.size()), -1.0/3.0);
                  bins_ = static_cast<Size>(std::ceil((max-min)/h));
                  break;
              }
              case None:
                QL_FAIL("a bin-partition algorithm is required");
              default:
                QL_FAIL("unknown bin-partition algorithm");
            };
            bins_ = std::max<Size>(bins_,1);
        }

        if (breaks_.empty()) {
            // set breaks if not provided
            breaks_.resize(bins_-1);

            // ensure breaks_ evenly span over the range of data_
            // TODO: borrow the idea of pretty in R.
            Real h = (max-min)/bins_;
            for (Size i=0; i<breaks_.size(); ++i) {
                breaks_[i] = min + (i+1)*h;
            }
        } else {
            // or ensure they're sorted if given
            std::sort(breaks_.begin(), breaks_.end());
            auto end = std::unique(breaks_.begin(), breaks_.end(),
                                   static_cast<bool (*)(Real, Real)>(close_enough));
            breaks_.resize(end - breaks_.begin());
        }

        // finally, calculate counts and frequencies
        counts_.resize(bins_);
        std::fill(counts_.begin(), counts_.end(), 0);

        for (double p : data_) {
            bool processed = false;
            for (Size i=0; i<breaks_.size(); ++i) {
                if (p < breaks_[i]) {
                    ++counts_[i];
                    processed = true;
                    break;
                }
            }
            if (!processed)
                ++counts_[bins_-1];
        }

        frequency_.resize(bins_);

        Size totalCounts = data_.size();
        for (Size i=0; i<bins_; ++i)
            frequency_[i] = static_cast<Real>(counts_[i])/totalCounts;
    }

}
]]></document_content>
  </document>
  <document index="87">
    <source>statistics/incrementalstatistics.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/statistics/incrementalstatistics.hpp>
#include <iomanip>

namespace QuantLib {

    IncrementalStatistics::IncrementalStatistics() {
        reset();
    }

    Size IncrementalStatistics::samples() const {
        return boost::accumulators::extract_result<
            boost::accumulators::tag::count>(acc_);
    }

    Real IncrementalStatistics::weightSum() const {
        return boost::accumulators::extract_result<
            boost::accumulators::tag::sum_of_weights>(acc_);
    }

    Real IncrementalStatistics::mean() const {
        QL_REQUIRE(weightSum() > 0.0, "sampleWeight_= 0, unsufficient");
        return boost::accumulators::extract_result<
            boost::accumulators::tag::weighted_mean>(acc_);
    }

    Real IncrementalStatistics::variance() const {
        QL_REQUIRE(weightSum() > 0.0, "sampleWeight_= 0, unsufficient");
        QL_REQUIRE(samples() > 1, "sample number <= 1, unsufficient");
        Real n = static_cast<Real>(samples());
        return n / (n - 1.0) *
               boost::accumulators::extract_result<
                   boost::accumulators::tag::weighted_variance>(acc_);
    }

    Real IncrementalStatistics::standardDeviation() const {
        return std::sqrt(variance());
    }

    Real IncrementalStatistics::errorEstimate() const {
        return std::sqrt(variance() / (samples()));
    }

    Real IncrementalStatistics::skewness() const {
        QL_REQUIRE(samples() > 2, "sample number <= 2, unsufficient");
        Real n = static_cast<Real>(samples());
        Real r1 = n / (n - 2.0);
        Real r2 = (n - 1.0) / (n - 2.0);
        return std::sqrt(r1 * r2) * 
               boost::accumulators::extract_result<
                   boost::accumulators::tag::weighted_skewness>(acc_);
    }

    Real IncrementalStatistics::kurtosis() const {
        QL_REQUIRE(samples() > 3,
                   "sample number <= 3, unsufficient");
        boost::accumulators::extract_result<
            boost::accumulators::tag::weighted_kurtosis>(acc_);
        Real n = static_cast<Real>(samples());
        Real r1 = (n - 1.0) / (n - 2.0);
        Real r2 = (n + 1.0) / (n - 3.0);
        Real r3 = (n - 1.0) / (n - 3.0);
        return ((3.0 + boost::accumulators::extract_result<
                           boost::accumulators::tag::weighted_kurtosis>(acc_)) *
                    r2 -
                3.0 * r3) *
               r1;
    }

    Real IncrementalStatistics::min() const {
        QL_REQUIRE(samples() > 0, "empty sample set");
        return boost::accumulators::extract_result<
            boost::accumulators::tag::min>(acc_);
    }

    Real IncrementalStatistics::max() const {
        QL_REQUIRE(samples() > 0, "empty sample set");
        return boost::accumulators::extract_result<
            boost::accumulators::tag::max>(acc_);
    }

    Size IncrementalStatistics::downsideSamples() const {
        return boost::accumulators::extract_result<
            boost::accumulators::tag::count>(downsideAcc_);
    }

    Real IncrementalStatistics::downsideWeightSum() const {
        return boost::accumulators::extract_result<
            boost::accumulators::tag::sum_of_weights>(downsideAcc_);
    }

    Real IncrementalStatistics::downsideVariance() const {
        QL_REQUIRE(downsideWeightSum() > 0.0, "sampleWeight_= 0, unsufficient");
        QL_REQUIRE(downsideSamples() > 1, "sample number <= 1, unsufficient");
        Real n = static_cast<Real>(downsideSamples());
        Real r1 = n / (n - 1.0);
        return r1 *
               boost::accumulators::extract_result<
                   boost::accumulators::tag::moment<2> >(downsideAcc_);
    }

    Real IncrementalStatistics::downsideDeviation() const {
        return std::sqrt(downsideVariance());
    }

    void IncrementalStatistics::add(Real value, Real valueWeight) {
        QL_REQUIRE(valueWeight >= 0.0, "negative weight (" << valueWeight
                                                           << ") not allowed");
        acc_(value, boost::accumulators::weight = valueWeight);
        if(value < 0.0)
            downsideAcc_(value, boost::accumulators::weight = valueWeight);
    }

    void IncrementalStatistics::reset() {
        acc_ = accumulator_set();
        downsideAcc_ = downside_accumulator_set();
    }

}
]]></document_content>
  </document>
</documents>