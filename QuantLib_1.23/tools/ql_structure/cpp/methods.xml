<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>finitedifferences/boundarycondition.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/boundarycondition.hpp>

namespace QuantLib {

    NeumannBC::NeumannBC(Real value, NeumannBC::Side side)
    : value_(value), side_(side) {}

    void NeumannBC::applyBeforeApplying(TridiagonalOperator& L) const {
        switch (side_) {
          case Lower:
            L.setFirstRow(-1.0,1.0);
            break;
          case Upper:
            L.setLastRow(-1.0,1.0);
            break;
          default:
            QL_FAIL("unknown side for Neumann boundary condition");
        }
    }

    void NeumannBC::applyAfterApplying(Array& u) const {
        switch (side_) {
          case Lower:
            u[0] = u[1] - value_;
            break;
          case Upper:
            u[u.size()-1] = u[u.size()-2] + value_;
            break;
          default:
            QL_FAIL("unknown side for Neumann boundary condition");
        }
    }

    void NeumannBC::applyBeforeSolving(TridiagonalOperator& L,
                                       Array& rhs) const {
        switch (side_) {
          case Lower:
            L.setFirstRow(-1.0,1.0);
            rhs[0] = value_;
            break;
          case Upper:
            L.setLastRow(-1.0,1.0);
            rhs[rhs.size()-1] = value_;
            break;
          default:
            QL_FAIL("unknown side for Neumann boundary condition");
        }
    }

    void NeumannBC::applyAfterSolving(Array&) const {}



    DirichletBC::DirichletBC(Real value, DirichletBC::Side side)
    : value_(value), side_(side) {}

    void DirichletBC::applyBeforeApplying(TridiagonalOperator& L) const {
        switch (side_) {
          case Lower:
            L.setFirstRow(1.0,0.0);
            break;
          case Upper:
            L.setLastRow(0.0,1.0);
            break;
          default:
            QL_FAIL("unknown side for Neumann boundary condition");
        }
    }

    void DirichletBC::applyAfterApplying(Array& u) const {
        switch (side_) {
          case Lower:
            u[0] = value_;
            break;
          case Upper:
            u[u.size()-1] = value_;
            break;
          default:
            QL_FAIL("unknown side for Neumann boundary condition");
        }
    }

    void DirichletBC::applyBeforeSolving(TridiagonalOperator& L,
                                         Array& rhs) const {
        switch (side_) {
          case Lower:
            L.setFirstRow(1.0,0.0);
            rhs[0] = value_;
            break;
          case Upper:
            L.setLastRow(0.0,1.0);
            rhs[rhs.size()-1] = value_;
            break;
          default:
            QL_FAIL("unknown side for Neumann boundary condition");
        }
    }

    void DirichletBC::applyAfterSolving(Array&) const {}

}
]]></document_content>
  </document>
  <document index="2">
    <source>finitedifferences/bsmoperator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/bsmoperator.hpp>
#include <ql/math/transformedgrid.hpp>
#include <ql/methods/finitedifferences/pdebsm.hpp>

namespace QuantLib {

    BSMOperator::BSMOperator(Size size, Real dx, Rate r,
                             Rate q, Volatility sigma)
    : TridiagonalOperator(size) {
        Real sigma2 = sigma*sigma;
        Real nu = r-q-sigma2/2;
        Real pd = -(sigma2/dx-nu)/(2*dx);
        Real pu = -(sigma2/dx+nu)/(2*dx);
        Real pm = sigma2/(dx*dx)+r;
        setMidRows(pd,pm,pu);
    }

    BSMOperator::BSMOperator(const Array& grid,
                             Rate r, Rate q, Volatility sigma)
    : TridiagonalOperator(grid.size()) {
        PdeBSM::grid_type logGrid(grid);
        Real sigma2 = sigma*sigma;
        Real nu = r-q-sigma2/2;
        for (Size i=1; i<logGrid.size()-1; ++i) {
            Real pd = -(sigma2/logGrid.dxm(i)-nu)/logGrid.dx(i);
            Real pu = -(sigma2/logGrid.dxp(i)+nu)/logGrid.dx(i);
            Real pm = sigma2/(logGrid.dxm(i)*logGrid.dxp(i)) + r;
            setMidRow(i,pd,pm,pu);
        }
    }

}
]]></document_content>
  </document>
  <document index="3">
    <source>finitedifferences/meshers/concentrating1dmesher.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Ralph Schreyer
 Copyright (C) 2014 Johannes GÃ¶ttker-Schnetmann
 Copyright (C) 2014 Klaus Spanderen
 Copyright (C) 2015 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file concentrating1dmesher.cpp
    \brief One-dimensional grid mesher concentrating around critical points
*/ 

#include <ql/errors.hpp>
#include <ql/timegrid.hpp>
#include <ql/utilities/null.hpp>
#include <ql/math/array.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/comparison.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/math/ode/adaptiverungekutta.hpp>
#include <ql/methods/finitedifferences/meshers/concentrating1dmesher.hpp>
#include <cmath>

namespace QuantLib {

    Concentrating1dMesher::Concentrating1dMesher(
        Real start, Real end, Size size, const std::pair<Real, Real>& cPoints,
        const bool requireCPoint)
        : Fdm1dMesher(size) {

        QL_REQUIRE(end > start, "end must be larger than start");

        const Real cPoint = cPoints.first;
        const Real density = cPoints.second == Null<Real>() ?
            Null<Real>() : cPoints.second*(end - start);

        QL_REQUIRE(cPoint == Null<Real>() || (cPoint >= start && cPoint <= end),
            "cPoint must be between start and end");
        QL_REQUIRE(density == Null<Real>() || density > 0.0,
            "density > 0 required");
        QL_REQUIRE(cPoint == Null<Real>() || density != Null<Real>(),
            "density must be given if cPoint is given");
        QL_REQUIRE(!requireCPoint || cPoint != Null<Real>(),
            "cPoint is required in grid but not given");

        const Real dx = 1.0 / (size - 1);

        if (cPoint != Null<Real>()) {
            std::vector<Real> u, z;
            ext::shared_ptr<Interpolation> transform;
            const Real c1 = std::asinh((start - cPoint) / density);
            const Real c2 = std::asinh((end - cPoint) / density);
            if (requireCPoint) {
                u.push_back(0.0);
                z.push_back(0.0);
                if (!close(cPoint, start) && !close(cPoint, end)) {
                    const Real z0 = -c1 / (c2 - c1);
                    const Real u0 =
                        std::max(std::min(std::lround(z0 * (size - 1)),
                                          static_cast<long>(size) - 2),
                                 1L) /
                        ((Real)(size - 1));
                    u.push_back(u0);
                    z.push_back(z0);
                }
                u.push_back(1.0);
                z.push_back(1.0);
                transform = ext::shared_ptr<Interpolation>(
                    new LinearInterpolation(u.begin(), u.end(), z.begin()));
            }

            for (Size i = 1; i < size - 1; ++i) {
                const Real li = requireCPoint ? (*transform)(i*dx) : i*dx;
                locations_[i] = cPoint
                    + density*std::sinh(c1*(1.0 - li) + c2*li);
            }
        }
        else {
            for (Size i = 1; i < size - 1; ++i) {
                locations_[i] = start + i*dx*(end - start);
            }
        }

        locations_.front() = start;
        locations_.back() = end;

        for (Size i = 0; i < size - 1; ++i) {
            dplus_[i] = dminus_[i + 1] = locations_[i + 1] - locations_[i];
        }
        dplus_.back() = dminus_.front() = Null<Real>();
    }

    namespace {
        class OdeIntegrationFct {
          public:
            OdeIntegrationFct(const std::vector<Real>& points,
                              const std::vector<Real>& betas,
                              Real tol)
          : rk_(tol), points_(points), betas_(betas) {}

            Real solve(Real a, Real y0, Real x0, Real x1) {
                AdaptiveRungeKutta<>::OdeFct1d odeFct([&](Real x, Real y){ return jac(a, x, y); });
                return rk_(odeFct, y0, x0, x1);
            }

          private:
            Real jac(Real a, Real, Real y) const {
                Real s=0.0;
                for (Size i=0; i < points_.size(); ++i) {
                    s+=1.0/(betas_[i] + square<Real>()(y - points_[i]));
                }
                return a/std::sqrt(s);
            }

            AdaptiveRungeKutta<> rk_;
            const std::vector<Real> &points_, &betas_;
        };

        bool equal_on_first(const std::pair<Real, Real>& p1,
                            const std::pair<Real, Real>& p2) {
            return close_enough(p1.first, p2.first, 1000);
        }
    }


    Concentrating1dMesher::Concentrating1dMesher(
        Real start, Real end, Size size,
        const std::vector<ext::tuple<Real, Real, bool> >& cPoints,
        Real tol)
    : Fdm1dMesher(size) {

        QL_REQUIRE(end > start, "end must be larger than start");

        std::vector<Real> points, betas;
        for (const auto& cPoint : cPoints) {
            points.push_back(ext::get<0>(cPoint));
            betas.push_back(square<Real>()(ext::get<1>(cPoint) * (end - start)));
        }

        // get scaling factor a so that y(1) = end
        Real aInit = 0.0;
        for (Size i=0; i < points.size(); ++i) {
            const Real c1 = std::asinh((start-points[i])/betas[i]);
            const Real c2 = std::asinh((end-points[i])/betas[i]);
            aInit+=(c2-c1)/points.size();
        }

        OdeIntegrationFct fct(points, betas, tol);
        const Real a = Brent().solve(
            [&](Real x) { return fct.solve(x, start, 0.0, 1.0) - end; },
            tol, aInit, 0.1*aInit);

        // solve ODE for all grid points
        Array x(size), y(size);
        x[0] = 0.0; y[0] = start;
        const Real dx = 1.0/(size-1);
        for (Size i=1; i < size; ++i) {
            x[i] = i*dx;
            y[i] = fct.solve(a, y[i-1], x[i-1], x[i]);
        }

        // eliminate numerical noise and ensure y(1) = end
        const Real dy = y.back() - end;
        for (Size i=1; i < size; ++i) {
            y[i] -= i*dx*dy;
        }

        LinearInterpolation odeSolution(x.begin(), x.end(), y.begin());

        // ensure required points are part of the grid
        std::vector<std::pair<Real, Real> > w(1, std::make_pair(0.0, 0.0));

        for (Size i=0; i < points.size(); ++i) {
            if (ext::get<2>(cPoints[i]) && points[i] > start && points[i] < end) {

                const Size j = std::distance(y.begin(),
                        std::lower_bound(y.begin(), y.end(), points[i]));

                const Real e = Brent().solve(
                    [&](Real x){ return odeSolution(x, true) - points[i]; },
                    QL_EPSILON, x[j], 0.5/size);

                w.emplace_back(std::min(x[size - 2], x[j]), e);
            }
        }
        w.emplace_back(1.0, 1.0);
        std::sort(w.begin(), w.end());
        w.erase(std::unique(w.begin(), w.end(), equal_on_first), w.end());

        std::vector<Real> u(w.size()), z(w.size());
        for (Size i=0; i < w.size(); ++i) {
            u[i] = w[i].first;
            z[i] = w[i].second;
        }
        LinearInterpolation transform(u.begin(), u.end(), z.begin());

        for (Size i=0; i < size; ++i) {
            locations_[i] = odeSolution(transform(i*dx));
        }

        for (Size i=0; i < size-1; ++i) {
            dplus_[i] = dminus_[i+1] = locations_[i+1] - locations_[i];
        }
        dplus_.back() = dminus_.front() = Null<Real>();
    }
}
]]></document_content>
  </document>
  <document index="4">
    <source>finitedifferences/meshers/exponentialjump1dmesher.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file exponentialjump1dmesher.cpp
    \brief mesher for a exponential jump mesher with high 
           mean reversion rate and low jump intensity
*/

#include <ql/math/incompletegamma.hpp>
#include <ql/math/integrals/gausslobattointegral.hpp>
#include <ql/math/distributions/gammadistribution.hpp>
#include <ql/methods/finitedifferences/meshers/exponentialjump1dmesher.hpp>

namespace QuantLib {
    ExponentialJump1dMesher::ExponentialJump1dMesher(
          Size steps, Real beta, Real jumpIntensity, Real eta, Real eps)
    : Fdm1dMesher(steps),
      beta_(beta), jumpIntensity_(jumpIntensity), eta_(eta)
   {
        QL_REQUIRE(eps > 0.0 && eps < 1.0, "eps > 0.0 and eps < 1.0");
        QL_REQUIRE(steps > 1, "minimum number of steps is two");
        
        const Real start = 0.0;
        const Real end   = 1.0-eps;
        const Real dx    = (end-start)/(steps-1);
        const Real scale = 1/(1-std::exp(-beta/jumpIntensity));

        for (Size i=0; i < steps; ++i) {
            const Real p = start + i*dx;
            locations_[i] = scale*(-1.0/eta*std::log(1.0-p));
        }

        for (Size i=0; i < steps-1; ++i) {
            dminus_[i+1] = dplus_[i] = locations_[i+1]-locations_[i];
        }
        dplus_.back() = dminus_.front() = Null<Real>();
    }
                                    
                                    
    Real ExponentialJump1dMesher::jumpSizeDensity(Real x, Time t) const {
        const Real a    = 1.0-jumpIntensity_/beta_;
        const Real norm = 1.0-std::exp(-jumpIntensity_*t);
        const Real gammaValue 
            = std::exp(GammaFunction().logValue(1.0-jumpIntensity_/beta_));
        return jumpIntensity_*gammaValue/norm
                    *( incompleteGammaFunction(a, x*std::exp(beta_*t)*eta_)
                      -incompleteGammaFunction(a, x*eta_))
                    *std::pow(eta_, jumpIntensity_/beta_)
                    /(beta_*std::pow(x, a));
    }
    
    Real ExponentialJump1dMesher::jumpSizeDensity(Real x) const {
        const Real a = 1.0-jumpIntensity_/beta_;
        const Real gammaValue 
                = std::exp(GammaFunction().logValue(jumpIntensity_/beta_));
        return std::exp(-x*eta_)*std::pow(x, -a) * std::pow(eta_, 1.0-a) 
                / gammaValue;
    }

    Real ExponentialJump1dMesher::jumpSizeDistribution(Real x, Time t) const {
        const Real xmin = std::min(x, 1.0e-100);

        return GaussLobattoIntegral(1000000, 1e-12)(
            [&](Real _x){ return jumpSizeDensity(_x, t); },
            xmin, std::max(x, xmin));
    }

    Real ExponentialJump1dMesher::jumpSizeDistribution(Real x) const {
        const Real a    = jumpIntensity_/beta_;
        const Real xmin = std::min(x, QL_EPSILON);
        const Real gammaValue 
                = std::exp(GammaFunction().logValue(jumpIntensity_/beta_));
        
        const Real lowerEps = 
            (std::pow(xmin, a)/a - std::pow(xmin, a+1)/(a+1))/gammaValue;
        
        return lowerEps + GaussLobattoIntegral(10000, 1e-12)(
            [&](Real _x){ return jumpSizeDensity(_x); },
            xmin/eta_, std::max(x, xmin/eta_));
    }
}
]]></document_content>
  </document>
  <document index="5">
    <source>finitedifferences/meshers/fdmblackscholesmesher.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmblackscholesmesher.cpp
    \brief 1-d mesher for the Black-Scholes process (in ln(S))
*/

#include <ql/processes/blackscholesprocess.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/termstructures/yield/quantotermstructure.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/methods/finitedifferences/utilities/fdmquantohelper.hpp>
#include <ql/methods/finitedifferences/meshers/uniform1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/concentrating1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmblackscholesmesher.hpp>

namespace QuantLib {

    FdmBlackScholesMesher::FdmBlackScholesMesher(
        Size size,
        const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
        Time maturity, Real strike,
        Real xMinConstraint, Real xMaxConstraint,
        Real eps, Real scaleFactor,
        const std::pair<Real, Real>& cPoint,
        const DividendSchedule& dividendSchedule,
        const ext::shared_ptr<FdmQuantoHelper>& fdmQuantoHelper,
        Real spotAdjustment)
    : Fdm1dMesher(size) {

        const Real S = process->x0();
        QL_REQUIRE(S > 0.0, "negative or null underlying given");

        std::vector<std::pair<Time, Real> > intermediateSteps;
        for (const auto& i : dividendSchedule) {
            const Time t = process->time(i->date());
            if (t <= maturity && t >= 0.0)
                intermediateSteps.emplace_back(process->time(i->date()), i->amount());
        }

        const Size intermediateTimeSteps = std::max<Size>(2, Size(24.0*maturity));
        for (Size i=0; i < intermediateTimeSteps; ++i)
            intermediateSteps.emplace_back((i + 1) * (maturity / intermediateTimeSteps), 0.0);

        std::sort(intermediateSteps.begin(), intermediateSteps.end());

        const Handle<YieldTermStructure> rTS = process->riskFreeRate();

        const Handle<YieldTermStructure> qTS =
            (fdmQuantoHelper) != nullptr ?
                Handle<YieldTermStructure>(ext::make_shared<QuantoTermStructure>(
                    process->dividendYield(), process->riskFreeRate(),
                    Handle<YieldTermStructure>(fdmQuantoHelper->fTS_), process->blackVolatility(),
                    strike, Handle<BlackVolTermStructure>(fdmQuantoHelper->fxVolTS_),
                    fdmQuantoHelper->exchRateATMlevel_, fdmQuantoHelper->equityFxCorrelation_)) :
                process->dividendYield();

        Time lastDivTime = 0.0;
        Real fwd = S + spotAdjustment;
        Real mi = fwd, ma = fwd;

        for (auto& intermediateStep : intermediateSteps) {
            const Time divTime = intermediateStep.first;
            const Real divAmount = intermediateStep.second;

            fwd = fwd / rTS->discount(divTime) * rTS->discount(lastDivTime)
                      * qTS->discount(divTime) / qTS->discount(lastDivTime);

            mi  = std::min(mi, fwd); ma = std::max(ma, fwd);

            fwd-= divAmount;

            mi  = std::min(mi, fwd); ma = std::max(ma, fwd);

            lastDivTime = divTime;
        }

        // Set the grid boundaries
        const Real normInvEps = InverseCumulativeNormal()(1-eps);
        const Real sigmaSqrtT 
            = process->blackVolatility()->blackVol(maturity, strike)
                                                        *std::sqrt(maturity);
        
        Real xMin = std::log(mi) - sigmaSqrtT*normInvEps*scaleFactor;
        Real xMax = std::log(ma) + sigmaSqrtT*normInvEps*scaleFactor;

        if (xMinConstraint != Null<Real>()) {
            xMin = xMinConstraint;
        }
        if (xMaxConstraint != Null<Real>()) {
            xMax = xMaxConstraint;
        }

        ext::shared_ptr<Fdm1dMesher> helper;
        if (   cPoint.first != Null<Real>() 
            && std::log(cPoint.first) >=xMin && std::log(cPoint.first) <=xMax) {
            
            helper = ext::shared_ptr<Fdm1dMesher>(
                new Concentrating1dMesher(xMin, xMax, size, 
                    std::pair<Real,Real>(std::log(cPoint.first),
                                         cPoint.second)));
        }
        else {
            helper = ext::shared_ptr<Fdm1dMesher>(
                                        new Uniform1dMesher(xMin, xMax, size));
            
        }
        
        locations_ = helper->locations();
        for (Size i=0; i < locations_.size(); ++i) {
            dplus_[i]  = helper->dplus(i);
            dminus_[i] = helper->dminus(i);
        }
    }
            
    ext::shared_ptr<GeneralizedBlackScholesProcess> 
    FdmBlackScholesMesher::processHelper(const Handle<Quote>& s0,
                                         const Handle<YieldTermStructure>& rTS,
                                         const Handle<YieldTermStructure>& qTS,
                                         Volatility vol) {
        
        return ext::make_shared<GeneralizedBlackScholesProcess>(
            
                s0, qTS, rTS,
                Handle<BlackVolTermStructure>(
                    ext::shared_ptr<BlackVolTermStructure>(
                        new BlackConstantVol(rTS->referenceDate(),
                                             Calendar(),
                                             vol,
                                             rTS->dayCounter()))));
    }
}

]]></document_content>
  </document>
  <document index="6">
    <source>finitedifferences/meshers/fdmblackscholesmultistrikemesher.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmblackscholesmultistrikemesher.cpp
    \brief 1-d mesher for the Black-Scholes process (in ln(S))
*/

#include <ql/processes/blackscholesprocess.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/methods/finitedifferences/meshers/uniform1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/concentrating1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmblackscholesmultistrikemesher.hpp>

namespace QuantLib {

    FdmBlackScholesMultiStrikeMesher::FdmBlackScholesMultiStrikeMesher(
            Size size,
            const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
            Time maturity, const std::vector<Real>& strikes,
            Real eps, Real scaleFactor,
            const std::pair<Real, Real>& cPoint)
    : Fdm1dMesher(size) {

        const Real spot = process->x0();
        QL_REQUIRE(spot > 0.0, "negative or null underlying given");

        const DiscountFactor d =   process->dividendYield()->discount(maturity)
                                 / process->riskFreeRate()->discount(maturity);
        const Real minStrike= *std::min_element(strikes.begin(), strikes.end());
        const Real maxStrike= *std::max_element(strikes.begin(), strikes.end());
                
        const Real Fmin = spot*spot/maxStrike*d;
        const Real Fmax = spot*spot/minStrike*d;
        
        QL_REQUIRE(Fmin > 0.0, "negative forward given");

        // Set the grid boundaries
        const Real normInvEps = InverseCumulativeNormal()(1-eps);
        const Real sigmaSqrtTmin 
            = process->blackVolatility()->blackVol(maturity, minStrike)
                                                        *std::sqrt(maturity);
        const Real sigmaSqrtTmax 
            = process->blackVolatility()->blackVol(maturity, maxStrike)
                                                        *std::sqrt(maturity);
        
        const Real xMin
            = std::min(0.8*std::log(0.8*spot*spot/maxStrike),
                       std::log(Fmin) - sigmaSqrtTmin*normInvEps*scaleFactor
                                      - sigmaSqrtTmin*sigmaSqrtTmin/2.0);
        const Real xMax
            = std::max(1.2*std::log(0.8*spot*spot/minStrike),
                       std::log(Fmax) + sigmaSqrtTmax*normInvEps*scaleFactor
                                      - sigmaSqrtTmax*sigmaSqrtTmax/2.0);

        ext::shared_ptr<Fdm1dMesher> helper;
        if (   cPoint.first != Null<Real>() 
            && std::log(cPoint.first) >=xMin && std::log(cPoint.first) <=xMax) {
            
            helper = ext::shared_ptr<Fdm1dMesher>(
                new Concentrating1dMesher(xMin, xMax, size, 
                    std::pair<Real,Real>(std::log(cPoint.first),cPoint.second)));
        }
        else {
            helper = ext::shared_ptr<Fdm1dMesher>(
                                        new Uniform1dMesher(xMin, xMax, size));
            
        }

        locations_ = helper->locations();
        for (Size i=0; i < locations_.size(); ++i) {
            dplus_[i]  = helper->dplus(i);
            dminus_[i] = helper->dminus(i);
        }
    }            
}
]]></document_content>
  </document>
  <document index="7">
    <source>finitedifferences/meshers/fdmcev1dmesher.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmcev1dmesher.cpp */

#include <ql/shared_ptr.hpp>
#include <ql/methods/finitedifferences/meshers/fdmcev1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/uniform1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/concentrating1dmesher.hpp>

#include <ql/methods/finitedifferences/utilities/cevrndcalculator.hpp>


namespace QuantLib {

    FdmCEV1dMesher::FdmCEV1dMesher(
            Size size,
            Real f0, Real alpha, Real beta,
            Time maturity, Real eps,Real scaleFactor,
            const std::pair<Real, Real>& cPoint)

    : Fdm1dMesher(size) {

        const CEVRNDCalculator rndCalculator(f0, alpha, beta);

        const Real upperBound =
            scaleFactor*rndCalculator.invcdf(1-eps, maturity);

        const Real massAtZero = rndCalculator.massAtZero(maturity);

        const Real lowerBound = (massAtZero > eps)
            ? ((beta < 0)? QL_EPSILON : 0.0)
            : rndCalculator.invcdf(eps, maturity)/scaleFactor;


        ext::shared_ptr<Fdm1dMesher> helper;
        if (   cPoint.first != Null<Real>()
            && cPoint.first >= lowerBound && cPoint.first <= upperBound) {

            helper = ext::make_shared<Concentrating1dMesher>(
                lowerBound, upperBound,size, cPoint);
        }
        else {
            helper = ext::make_shared<Uniform1dMesher>(
                lowerBound, upperBound, size );
        }

        std::copy(helper->locations().begin(),
                  helper->locations().end(),
                  locations_.begin());

        for (Size i=0; i < locations_.size(); ++i) {
            dplus_[i]  = helper->dplus(i);
            dminus_[i] = helper->dminus(i);
        }
    }
}

]]></document_content>
  </document>
  <document index="8">
    <source>finitedifferences/meshers/fdmhestonvariancemesher.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008, 2019 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/functional.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/distributions/chisquaredistribution.hpp>
#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/math/integrals/gausslobattointegral.hpp>
#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>
#include <ql/methods/finitedifferences/meshers/fdmhestonvariancemesher.hpp>
#include <boost/accumulators/accumulators.hpp>
#include <boost/accumulators/statistics/mean.hpp>
#include <boost/accumulators/statistics/stats.hpp>
#include <set>
#include <algorithm>

namespace QuantLib {

    namespace {
        struct interpolated_volatility {
            interpolated_volatility(const std::vector<Real>& pGrid,
                                    const std::vector<Real>& vGrid)
            : variance(pGrid.begin(), pGrid.end(), vGrid.begin()) {}
            Real operator()(Real x) const {
                return std::sqrt(variance(x, true));
            }
            LinearInterpolation variance;
        };
    }

    FdmHestonVarianceMesher::FdmHestonVarianceMesher(
        Size size,
        const ext::shared_ptr<HestonProcess> & process,
        Time maturity, Size tAvgSteps, Real epsilon,
        Real mixingFactor)
        : Fdm1dMesher(size) {

        std::vector<Real> vGrid(size, 0.0), pGrid(size, 0.0);
        const Real mixedSigma = process->sigma()*mixingFactor;
        const Real df  = 4*process->theta()*process->kappa()/
                            square<Real>()(mixedSigma);
        try {
            std::multiset<std::pair<Real, Real> > grid;
            
            for (Size l=1; l<=tAvgSteps; ++l) {
                const Real t = (maturity*l)/tAvgSteps;
                const Real ncp = 4*process->kappa()*std::exp(-process->kappa()*t)
                    /(square<Real>()(mixedSigma)
                    *(1-std::exp(-process->kappa()*t)))*process->v0();
                const Real k = square<Real>()(mixedSigma)
                    *(1-std::exp(-process->kappa()*t))/(4*process->kappa());

                const Real qMin = 0.0; // v_min = 0.0;
                const Real qMax = std::max(process->v0(),
                    k*InverseNonCentralCumulativeChiSquareDistribution(
                                            df, ncp, 100, 1e-8)(1-epsilon));

                const Real minVStep=(qMax-qMin)/(50*size);
                Real ps,p = 0.0;

                Real vTmp = qMin;
                grid.insert(std::pair<Real, Real>(qMin, epsilon));
                
                for (Size i=1; i < size; ++i) {
                    ps = (1 - epsilon - p)/(size-i);
                    p += ps;
                    const Real tmp = k*InverseNonCentralCumulativeChiSquareDistribution(
                        df, ncp, 100, 1e-8)(p);

                    const Real vx = std::max(vTmp+minVStep, tmp);
                    p = NonCentralCumulativeChiSquareDistribution(df, ncp)(vx/k);
                    vTmp=vx;
                    grid.insert(std::pair<Real, Real>(vx, p));
                }
            }
            QL_REQUIRE(grid.size() == size*tAvgSteps, 
                       "something wrong with the grid size");
            
            const std::vector<std::pair<Real, Real> > tp(grid.begin(), grid.end());

            for (Size i=0; i < size; ++i) {
                const Size b = (i*tp.size())/size;
                const Size e = ((i+1)*tp.size())/size;
                for (Size j=b; j < e; ++j) {
                    vGrid[i]+=tp[j].first/(e-b);
                    pGrid[i]+=tp[j].second/(e-b);
                }
            }
        } 
        catch (const Error&) {
            // use default mesh
            const Real vol = mixedSigma*
                std::sqrt(process->theta()/(2*process->kappa()));

            const Real mean = process->theta();
            const Real upperBound = std::max(process->v0()+4*vol, mean+4*vol);
            const Real lowerBound
                = std::max(0.0, std::min(process->v0()-4*vol, mean-4*vol));

            for (Size i=0; i < size; ++i) {
                pGrid[i] = i/(size-1.0);
                vGrid[i] = lowerBound + i*(upperBound-lowerBound)/(size-1.0);
            }
        }

        Real skewHint = ((process->kappa() != 0.0) 
                ? std::max(1.0, mixedSigma/process->kappa()) : 1.0);

        std::sort(pGrid.begin(), pGrid.end());
        volaEstimate_ = GaussLobattoIntegral(100000, 1e-4)(
            interpolated_volatility(pGrid, vGrid),
                pGrid.front(), pGrid.back())*std::pow(skewHint, 1.5);

        const Real v0 = process->v0();
        for (Size i=1; i<vGrid.size(); ++i) {
            if (vGrid[i-1] <= v0 && vGrid[i] >= v0) {
                if (std::fabs(vGrid[i-1] - v0) < std::fabs(vGrid[i] - v0))
                    vGrid[i-1] = v0;
                else
                    vGrid[i] = v0;
            }
        }

        std::copy(vGrid.begin(), vGrid.end(), locations_.begin());

        for (Size i=0; i < size-1; ++i) {
            dminus_[i+1] = dplus_[i] = vGrid[i+1] - vGrid[i];
        }
        dplus_.back() = dminus_.front() = Null<Real>();
    }


    FdmHestonLocalVolatilityVarianceMesher::FdmHestonLocalVolatilityVarianceMesher(
        Size size,
        const ext::shared_ptr<HestonProcess>& process,
        const ext::shared_ptr<LocalVolTermStructure>& leverageFct,
        Time maturity, Size tAvgSteps, Real epsilon,
        Real mixingFactor)
     : Fdm1dMesher(size) {

        const FdmHestonVarianceMesher mesher(
            size, process, maturity, tAvgSteps, epsilon, mixingFactor);

        for (Size i=0; i < size; ++i) {
            dplus_[i] = mesher.dplus(i);
            dminus_[i] = mesher.dminus(i);
            locations_[i] = mesher.location(i);
        }

        volaEstimate_ = mesher.volaEstimate();

        if (leverageFct != nullptr) {
            typedef boost::accumulators::accumulator_set<
                Real, boost::accumulators::stats<
                    boost::accumulators::tag::mean> >
                accumulator_set;

            accumulator_set acc;

            const Real s0 = process->s0()->value();

            acc(leverageFct->localVol(0, s0, true));

            const Handle<YieldTermStructure> rTS = process->riskFreeRate();
            const Handle<YieldTermStructure> qTS = process->dividendYield();

            for (Size l=1; l <= tAvgSteps; ++l) {
                const Real t = (maturity*l)/tAvgSteps;
                const Real vol = volaEstimate_ * boost::accumulators::mean(acc);

                const Real fwd = s0*qTS->discount(t)/rTS->discount(t);

                const Size sAvgSteps = 50;

                std::vector<Real> u(sAvgSteps), sig(sAvgSteps);

                for (Size i=0; i < sAvgSteps; ++i) {
                    u[i] = epsilon + ((1-2*epsilon)/(sAvgSteps-1))*i;
                    const Real x = InverseCumulativeNormal()(u[i]);

                    const Real gf = x*vol*std::sqrt(t);
                    const Real f = fwd*std::exp(gf);

                    sig[i] = square<Real>()(leverageFct->localVol(t, f, true));
                }

                const Real leverageAvg =
                    GaussLobattoIntegral(10000, 1e-4)(
                        interpolated_volatility(u, sig), u.front(), u.back())
                    / (1-2*epsilon);

                acc(leverageAvg);
            }
            volaEstimate_ *= boost::accumulators::mean(acc);
        }
    }
}
]]></document_content>
  </document>
  <document index="9">
    <source>finitedifferences/meshers/fdmmeshercomposite.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>

namespace QuantLib {

    namespace {
        typedef ext::shared_ptr<Fdm1dMesher> T;

        ext::shared_ptr<FdmLinearOpLayout> getLayoutFromMeshers(
                 const std::vector<ext::shared_ptr<Fdm1dMesher> > & meshers) {
            std::vector<Size> dim(meshers.size());
            for (Size i=0; i < dim.size(); ++i) {
                dim[i] = meshers[i]->size();
            }
            return ext::make_shared<FdmLinearOpLayout>(dim);
        }
    }

    FdmMesherComposite::FdmMesherComposite(
        const ext::shared_ptr<Fdm1dMesher>& mesher)
    : FdmMesher(getLayoutFromMeshers({mesher})),
      mesher_({mesher}) {
    }


    FdmMesherComposite::FdmMesherComposite(
        const ext::shared_ptr<Fdm1dMesher>& m1,
        const ext::shared_ptr<Fdm1dMesher>& m2)
    : FdmMesher(getLayoutFromMeshers({m1, m2})),
      mesher_({m1, m2}) {
    }

    FdmMesherComposite::FdmMesherComposite(
        const ext::shared_ptr<Fdm1dMesher>& m1,
        const ext::shared_ptr<Fdm1dMesher>& m2,
        const ext::shared_ptr<Fdm1dMesher>& m3)
    : FdmMesher(getLayoutFromMeshers({m1, m2, m3})),
      mesher_({m1, m2, m3}) {
    }

    FdmMesherComposite::FdmMesherComposite(
        const ext::shared_ptr<Fdm1dMesher>& m1,
        const ext::shared_ptr<Fdm1dMesher>& m2,
        const ext::shared_ptr<Fdm1dMesher>& m3,
        const ext::shared_ptr<Fdm1dMesher>& m4)
    : FdmMesher(getLayoutFromMeshers({m1, m2, m3, m4})),
      mesher_({m1, m2, m3, m4}) {
    }

    FdmMesherComposite::FdmMesherComposite(
        const std::vector<ext::shared_ptr<Fdm1dMesher> > & mesher)
    : FdmMesher(getLayoutFromMeshers(mesher)), mesher_(mesher) {
    }

    FdmMesherComposite::FdmMesherComposite(
        const ext::shared_ptr<FdmLinearOpLayout>& layout,
        const std::vector<ext::shared_ptr<Fdm1dMesher> > & mesher)
    : FdmMesher(layout), mesher_(mesher) {
        for (Size i=0; i < mesher.size(); ++i) {
            QL_REQUIRE(mesher[i]->size() == layout->dim()[i],
                       "size of 1d mesher " << i << " does not fit to layout");
        }
    }

    Real FdmMesherComposite::dplus(const FdmLinearOpIterator& iter,
                                   Size direction) const {
        return mesher_[direction]->dplus(iter.coordinates()[direction]);
    }

    Real FdmMesherComposite::dminus(const FdmLinearOpIterator& iter,
                                    Size direction) const {
        return mesher_[direction]->dminus(iter.coordinates()[direction]);
    }

    Real FdmMesherComposite::location(const FdmLinearOpIterator& iter,
                                      Size direction) const {
        return mesher_[direction]->location(iter.coordinates()[direction]);
    }

    Disposable<Array> FdmMesherComposite::locations(Size direction) const {
        Array retVal(layout_->size());

        const FdmLinearOpIterator endIter = layout_->end();
        for (FdmLinearOpIterator iter = layout_->begin();
             iter != endIter; ++iter) {
            retVal[iter.index()] =
                mesher_[direction]->locations()[iter.coordinates()[direction]];
        }

        return retVal;
    }

    const std::vector<ext::shared_ptr<Fdm1dMesher> >&
        FdmMesherComposite::getFdm1dMeshers() const {
        return  mesher_;
    }
}
]]></document_content>
  </document>
  <document index="10">
    <source>finitedifferences/meshers/fdmsimpleprocess1dmesher.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009, 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/functional.hpp>
#include <ql/stochasticprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/methods/finitedifferences/meshers/fdmsimpleprocess1dmesher.hpp>

namespace QuantLib {

    FdmSimpleProcess1dMesher::FdmSimpleProcess1dMesher(
        Size size,
        const ext::shared_ptr<StochasticProcess1D>& process,
        Time maturity, Size tAvgSteps, Real eps, Real mandatoryPoint)
        : Fdm1dMesher(size) {
            
        std::fill(locations_.begin(), locations_.end(), 0.0);    
        for (Size l=1; l<=tAvgSteps; ++l) {
            const Real t = (maturity*l)/tAvgSteps;
            
            const Real mp = (mandatoryPoint != Null<Real>()) ? mandatoryPoint
                                                             : process->x0();

            const Real qMin = std::min(std::min(mp, process->x0()),
                process->evolve(0, process->x0(), t, 
                                InverseCumulativeNormal()(eps)));
            const Real qMax = std::max(std::max(mp, process->x0()),
                process->evolve(0, process->x0(), t,
                                InverseCumulativeNormal()(1-eps)));
            
            const Real dp = (1-2*eps)/(size-1);
            Real p = eps;
            locations_[0] += qMin;
            
            for (Size i=1; i < size-1; ++i) {
                p += dp;
                locations_[i] += process->evolve(0, process->x0(), t, 
                                                 InverseCumulativeNormal()(p));
            }
            locations_.back() += qMax;
        }
        std::transform(locations_.begin(), locations_.end(), locations_.begin(),
                       divide_by<Real>(Real(tAvgSteps)));
        for (Size i=0; i < size-1; ++i) {
            dminus_[i+1] = dplus_[i] = locations_[i+1] - locations_[i];
        }
        dplus_.back() = dminus_.front() = Null<Real>();        
    }
}
]]></document_content>
  </document>
  <document index="11">
    <source>finitedifferences/meshers/uniformgridmesher.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/meshers/uniformgridmesher.hpp>

namespace QuantLib {

    UniformGridMesher::UniformGridMesher(
        const ext::shared_ptr<FdmLinearOpLayout> & layout,
        const std::vector<std::pair<Real, Real> > & boundaries)
    : FdmMesher (layout),
      dx_       (new Real[layout->dim().size()]),
      locations_(layout->dim().size()) {

        QL_REQUIRE(boundaries.size() == layout->dim().size(),
                   "inconsistent boundaries given");

        for (Size i=0; i < layout->dim().size(); ++i) {
            dx_[i] = (boundaries[i].second - boundaries[i].first)
                / (layout->dim()[i]-1);

            locations_[i] = std::vector<Real>(layout->dim()[i]);
            for (Size j=0; j < layout->dim()[i]; ++j) {
                locations_[i][j] = boundaries[i].first + j*dx_[i];
            }
        }
    }

    Disposable<Array> UniformGridMesher::locations(Size d) const {
        Array retVal(layout_->size());

        const FdmLinearOpIterator endIter = layout_->end();
        for (FdmLinearOpIterator iter = layout_->begin();
            iter != endIter; ++iter) {
            retVal[iter.index()] = locations_[d][iter.coordinates()[d]];
        }

        return retVal;
    }
}
]]></document_content>
  </document>
  <document index="12">
    <source>finitedifferences/operators/fdm2dblackscholesop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdm2dblackscholesop.cpp
*/


#include <ql/processes/blackscholesprocess.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/fdm2dblackscholesop.hpp>
#include <ql/methods/finitedifferences/operators/secondordermixedderivativeop.hpp>
#include <boost/numeric/ublas/matrix.hpp>

namespace QuantLib {

    Fdm2dBlackScholesOp::Fdm2dBlackScholesOp(
            const ext::shared_ptr<FdmMesher>& mesher,
            const ext::shared_ptr<GeneralizedBlackScholesProcess>& p1,
            const ext::shared_ptr<GeneralizedBlackScholesProcess>& p2,
            Real correlation,
            Time /*maturity*/,
            bool localVol,
            Real illegalLocalVolOverwrite)
    : mesher_(mesher),
      p1_(p1),
      p2_(p2),
      
      localVol1_((localVol) ? p1->localVolatility().currentLink()
                            : ext::shared_ptr<LocalVolTermStructure>()),
      localVol2_((localVol) ? p2->localVolatility().currentLink()
                            : ext::shared_ptr<LocalVolTermStructure>()),
                            
      x_((localVol) ? Array(Exp(mesher->locations(0))) : Array()),
      y_((localVol) ? Array(Exp(mesher->locations(1))) : Array()),

      opX_(mesher, p1, p1->x0(), localVol, illegalLocalVolOverwrite, 0),
      opY_(mesher, p2, p2->x0(), localVol, illegalLocalVolOverwrite, 1),
      
      corrMapT_(0, 1, mesher),
      corrMapTemplate_(SecondOrderMixedDerivativeOp(0, 1, mesher)
                      .mult(Array(mesher->layout()->size(), correlation))),
                      
      illegalLocalVolOverwrite_(illegalLocalVolOverwrite) { 
    }
           
    Size Fdm2dBlackScholesOp::size() const {
        return 2;
    }
    
    void Fdm2dBlackScholesOp::setTime(Time t1, Time t2) {
        opX_.setTime(t1, t2);
        opY_.setTime(t1, t2);

        if (localVol1_ != nullptr) {
            const ext::shared_ptr<FdmLinearOpLayout> layout=mesher_->layout();
            const FdmLinearOpIterator endIter = layout->end();

            Array vol1(layout->size()), vol2(layout->size());
            for (FdmLinearOpIterator iter = layout->begin();
                 iter!=endIter; ++iter) {
                const Size i = iter.index();

                if (illegalLocalVolOverwrite_ < 0.0) {
                    vol1[i] = localVol1_->localVol(0.5*(t1+t2), x_[i], true);
                    vol2[i] = localVol2_->localVol(0.5*(t1+t2), y_[i], true);
                }
                else {
                    try {
                        vol1[i] = localVol1_->localVol(0.5*(t1+t2), x_[i],true);
                    } catch (Error&) {
                        vol1[i] = illegalLocalVolOverwrite_;
                    }
                    try {
                        vol2[i] = localVol2_->localVol(0.5*(t1+t2), y_[i],true);
                    } catch (Error&) {
                        vol2[i] = illegalLocalVolOverwrite_;
                    }

                }
            }
            corrMapT_ = corrMapTemplate_.mult(vol1*vol2);
        } else {
            const Real vol1 = p1_
                    ->blackVolatility()->blackForwardVol(t1, t2, p1_->x0());
    
            const Real vol2 = p2_
                    ->blackVolatility()->blackForwardVol(t1, t2, p2_->x0());
            
            corrMapT_ = corrMapTemplate_
                      .mult(Array(mesher_->layout()->size(), vol1*vol2));
        }

        currentForwardRate_ = p1_->riskFreeRate()
                                 ->forwardRate(t1, t2, Continuous).rate();
    }

    Disposable<Array> Fdm2dBlackScholesOp::apply(const Array& x) const {
        return opX_.apply(x) + opY_.apply(x) + apply_mixed(x);
    }
    
    Disposable<Array> Fdm2dBlackScholesOp::apply_mixed(const Array& x) const {
        return corrMapT_.apply(x) + currentForwardRate_*x;
    }
    
    Disposable<Array> Fdm2dBlackScholesOp::apply_direction(
                                       Size direction, const Array& x) const {
        if (direction == 0) {
            return opX_.apply(x);
        }
        else if (direction == 1) {
            return opY_.apply(x);
        }
        else {
            QL_FAIL("direction is too large");
        }
    }
    
    Disposable<Array> Fdm2dBlackScholesOp::solve_splitting(Size direction,
                                               const Array& x, Real s) const {
        if (direction == 0) {
            return opX_.solve_splitting(direction, x, s);
        }
        else if (direction == 1) {
            return opY_.solve_splitting(direction, x, s);
        }
        else
            QL_FAIL("direction is too large");
    }
    
    Disposable<Array> Fdm2dBlackScholesOp::preconditioner(const Array& r, 
                                                          Real dt) const {
        return solve_splitting(0, r, dt);
    }

    Disposable<std::vector<SparseMatrix> >
    Fdm2dBlackScholesOp::toMatrixDecomp() const {
        std::vector<SparseMatrix> retVal(3);
        retVal[0] = opX_.toMatrix();
        retVal[1] = opY_.toMatrix();
        retVal[2] = corrMapT_.toMatrix() +
            currentForwardRate_*boost::numeric::ublas::identity_matrix<Real>(
                    mesher_->layout()->size());

        return retVal;
    }

}
]]></document_content>
  </document>
  <document index="13">
    <source>finitedifferences/operators/fdmbatesop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmbatesop.cpp
    \brief Bates linear operator
*/

#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/math/matrix.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmbatesop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdirichletboundary.hpp>
#include <ql/processes/batesprocess.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/yield/zerospreadedtermstructure.hpp>
#include <utility>

namespace QuantLib {

    FdmBatesOp::FdmBatesOp(const ext::shared_ptr<FdmMesher>& mesher,
                           const ext::shared_ptr<BatesProcess>& batesProcess,
                           FdmBoundaryConditionSet bcSet,
                           const Size integroIntegrationOrder,
                           const ext::shared_ptr<FdmQuantoHelper>& quantoHelper)
    : lambda_(batesProcess->lambda()), delta_(batesProcess->delta()), nu_(batesProcess->nu()),
      m_(std::exp(nu_ + 0.5 * delta_ * delta_) - 1.0),
      gaussHermiteIntegration_(integroIntegrationOrder), mesher_(mesher), bcSet_(std::move(bcSet)),
      hestonOp_(new FdmHestonOp(
          mesher,
          ext::make_shared<HestonProcess>(
              batesProcess->riskFreeRate(),
              Handle<YieldTermStructure>(ext::make_shared<ZeroSpreadedTermStructure>(
                  batesProcess->dividendYield(),
                  Handle<Quote>(ext::shared_ptr<Quote>(new SimpleQuote(lambda_ * m_))),
                  Continuous,
                  NoFrequency,
                  batesProcess->dividendYield()->dayCounter())),
              batesProcess->s0(),
              batesProcess->v0(),
              batesProcess->kappa(),
              batesProcess->theta(),
              batesProcess->sigma(),
              batesProcess->rho()),
          quantoHelper)) {}

    FdmBatesOp::IntegroIntegrand::IntegroIntegrand(
                    const ext::shared_ptr<LinearInterpolation>& interpl,
                    const FdmBoundaryConditionSet& bcSet,
                    Real x, Real delta, Real nu)
    : x_(x), delta_(delta), nu_(nu), 
      bcSet_(bcSet), interpl_(interpl) { }
                    
    Real FdmBatesOp::IntegroIntegrand::operator()(Real y) const {
        const Real x = x_ + M_SQRT2*delta_*y + nu_;
        Real valueOfDerivative = (*interpl_)(x, true);

        for (auto iter = bcSet_.begin(); iter < bcSet_.end(); ++iter) {

            const ext::shared_ptr<FdmDirichletBoundary> dirichlet
                = ext::dynamic_pointer_cast<FdmDirichletBoundary>(*iter);

            QL_REQUIRE(dirichlet, "FdmBatesOp can only deal with Dirichlet "
                                  "boundary conditions.");

            valueOfDerivative
                = dirichlet->applyAfterApplying(x, valueOfDerivative);
        }

        return std::exp(-y*y)*valueOfDerivative;
    }
    
    Disposable<Array> FdmBatesOp::integro(const Array& r) const {
        const ext::shared_ptr<FdmLinearOpLayout> layout = mesher_->layout();
        
        QL_REQUIRE(layout->dim().size() == 2, "invalid layout dimension");

        Array x(layout->dim()[0]);
        Matrix f(layout->dim()[1], layout->dim()[0]);
        
        const FdmLinearOpIterator endIter = layout->end();
        for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
            ++iter) {
            const Size i = iter.coordinates()[0];
            const Size j = iter.coordinates()[1];
            
            x[i]    = mesher_->location(iter, 0);
            f[j][i] = r[iter.index()];
            
        }
        std::vector<ext::shared_ptr<LinearInterpolation> > interpl(f.rows());
        for (Size i=0; i < f.rows(); ++i) {
            interpl[i] = ext::make_shared<LinearInterpolation>(
                x.begin(), x.end(), f.row_begin(i));
        }
        
        Array integral(r.size());
        for (FdmLinearOpIterator iter=layout->begin(); iter!=endIter; ++iter) {
            const Size i = iter.coordinates()[0];
            const Size j = iter.coordinates()[1];

            integral[iter.index()] = M_1_SQRTPI* 
                gaussHermiteIntegration_(
                      IntegroIntegrand(interpl[j], bcSet_, x[i], delta_, nu_));
        }

        return lambda_*(integral-r);
    }

    Disposable<std::vector<SparseMatrix> > FdmBatesOp::toMatrixDecomp() const {
        QL_FAIL("not implemented");
    }

}
]]></document_content>
  </document>
  <document index="14">
    <source>finitedifferences/operators/fdmblackscholesop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/payoffs.hpp>
#include <ql/math/functional.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmblackscholesop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>
#include <utility>

namespace QuantLib {

    FdmBlackScholesOp::FdmBlackScholesOp(
        const ext::shared_ptr<FdmMesher>& mesher,
        const ext::shared_ptr<GeneralizedBlackScholesProcess>& bsProcess,
        Real strike,
        bool localVol,
        Real illegalLocalVolOverwrite,
        Size direction,
        ext::shared_ptr<FdmQuantoHelper> quantoHelper)
    : mesher_(mesher), rTS_(bsProcess->riskFreeRate().currentLink()),
      qTS_(bsProcess->dividendYield().currentLink()),
      volTS_(bsProcess->blackVolatility().currentLink()),
      localVol_((localVol) ? bsProcess->localVolatility().currentLink() :
                             ext::shared_ptr<LocalVolTermStructure>()),
      x_((localVol) ? Array(Exp(mesher->locations(direction))) : Array()),
      dxMap_(FirstDerivativeOp(direction, mesher)), dxxMap_(SecondDerivativeOp(direction, mesher)),
      mapT_(direction, mesher), strike_(strike),
      illegalLocalVolOverwrite_(illegalLocalVolOverwrite), direction_(direction),
      quantoHelper_(std::move(quantoHelper)) {}

    void FdmBlackScholesOp::setTime(Time t1, Time t2) {
        const Rate r = rTS_->forwardRate(t1, t2, Continuous).rate();
        const Rate q = qTS_->forwardRate(t1, t2, Continuous).rate();

        if (localVol_ != nullptr) {
            const ext::shared_ptr<FdmLinearOpLayout> layout=mesher_->layout();
            const FdmLinearOpIterator endIter = layout->end();

            Array v(layout->size());
            for (FdmLinearOpIterator iter = layout->begin();
                 iter!=endIter; ++iter) {
                const Size i = iter.index();

                if (illegalLocalVolOverwrite_ < 0.0) {
                    v[i] = square<Real>()(
                        localVol_->localVol(0.5*(t1+t2), x_[i], true));
                }
                else {
                    try {
                        v[i] = square<Real>()(
                            localVol_->localVol(0.5*(t1+t2), x_[i], true));
                    } catch (Error&) {
                        v[i] = square<Real>()(illegalLocalVolOverwrite_);
                    }

                }
            }

            if (quantoHelper_ != nullptr) {
                mapT_.axpyb(r - q - 0.5*v
                    - quantoHelper_->quantoAdjustment(Sqrt(v), t1, t2),
                    dxMap_, dxxMap_.mult(0.5*v), Array(1, -r));
            } else {
                mapT_.axpyb(r - q - 0.5*v, dxMap_,
                            dxxMap_.mult(0.5*v), Array(1, -r));
            }
        } else {
            const Real v
                = volTS_->blackForwardVariance(t1, t2, strike_)/(t2-t1);

            if (quantoHelper_ != nullptr) {
                mapT_.axpyb(
                    Array(1, r - q - 0.5*v)
                        - quantoHelper_->quantoAdjustment(
                            Array(1, std::sqrt(v)), t1, t2),
                    dxMap_,
                    dxxMap_.mult(0.5*Array(mesher_->layout()->size(), v)),
                    Array(1, -r));
            } else {
                mapT_.axpyb(Array(1, r - q - 0.5*v), dxMap_,
                    dxxMap_.mult(0.5*Array(mesher_->layout()->size(), v)),
                    Array(1, -r));
            }
        }
    }

    Size FdmBlackScholesOp::size() const { return 1U; }

    Disposable<Array> FdmBlackScholesOp::apply(const Array& u) const {
        return mapT_.apply(u);
    }

    Disposable<Array> FdmBlackScholesOp::apply_direction(Size direction,
                                                    const Array& r) const {
        if (direction == direction_)
            return mapT_.apply(r);
        else {
            Array retVal(r.size(), 0.0);
            return retVal;
        }
    }

    Disposable<Array> FdmBlackScholesOp::apply_mixed(const Array& r) const {
        Array retVal(r.size(), 0.0);
        return retVal;
    }

    Disposable<Array> FdmBlackScholesOp::solve_splitting(Size direction,
                                                const Array& r, Real dt) const {
        if (direction == direction_)
            return mapT_.solve_splitting(r, dt, 1.0);
        else {
            Array retVal(r);
            return retVal;
        }
    }

    Disposable<Array> FdmBlackScholesOp::preconditioner(const Array& r,
                                                        Real dt) const {
        return solve_splitting(direction_, r, dt);
    }

    Disposable<std::vector<SparseMatrix> >
    FdmBlackScholesOp::toMatrixDecomp() const {
        std::vector<SparseMatrix> retVal(1, mapT_.toMatrix());
        return retVal;
    }

}
]]></document_content>
  </document>
  <document index="15">
    <source>finitedifferences/operators/fdmcevop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmcevop.cpp */

#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/fdmcevop.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>


namespace QuantLib {

    FdmCEVOp::FdmCEVOp(
        const ext::shared_ptr<FdmMesher>& mesher,
        const ext::shared_ptr<YieldTermStructure>& rTS,
        Real f0, Real alpha, Real beta,
        Size direction)
    : rTS_(rTS),
      direction_(direction),
      dxxMap_(SecondDerivativeOp(0, mesher)
              .mult(0.5 * alpha * alpha *
                    Pow(mesher->locations(direction), 2.0 * beta))),
      mapT_(direction, mesher) {
    }

    Size FdmCEVOp::size() const { return 1U; }

    void FdmCEVOp::setTime(Time t1, Time t2) {
        const Rate r = rTS_->forwardRate(t1, t2, Continuous).rate();
        mapT_.axpyb(Array(), dxxMap_, dxxMap_, Array(1, -r));
    }

    Disposable<Array> FdmCEVOp::apply(const Array& r) const {
        return mapT_.apply(r);
    }

    Disposable<Array> FdmCEVOp::apply_mixed(const Array& r) const {
        Array retVal(r.size(), 0.0);
        return retVal;
    }

    Disposable<Array>
    FdmCEVOp::apply_direction(Size direction, const Array& r) const {
        if (direction == direction_) {
            return mapT_.apply(r);
        }
        else {
            Array retVal(r.size(), 0.0);
            return retVal;
        }
    }

    Disposable<Array>
    FdmCEVOp::solve_splitting(Size direction, const Array& r, Real a) const {
        if (direction == direction_) {
            return mapT_.solve_splitting(r, a, 1.0);
        }
        else {
            Array retVal(r.size(), 0.0);
            return retVal;
        }
    }

    Disposable<Array>
    FdmCEVOp::preconditioner(const Array& r, Real dt) const {
        return solve_splitting(direction_, r, dt);
    }

    Disposable<std::vector<SparseMatrix> > FdmCEVOp::toMatrixDecomp() const {
        std::vector<SparseMatrix> retVal(1, mapT_.toMatrix());
        return retVal;
    }

}

]]></document_content>
  </document>
  <document index="16">
    <source>finitedifferences/operators/fdmcirop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Lew Wei Hao

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmcirop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/secondordermixedderivativeop.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    FdmCIREquityPart::FdmCIREquityPart(
        const ext::shared_ptr<FdmMesher>& mesher,
        const ext::shared_ptr<GeneralizedBlackScholesProcess>& bsProcess,
        Real strike)
    : dxMap_ (FirstDerivativeOp(0, mesher)),
      dxxMap_(SecondDerivativeOp(0, mesher)),
      mapT_ (0, mesher),
      mesher_(mesher),
      qTS_(bsProcess->dividendYield().currentLink()),
      strike_(strike),
      sigma1_(bsProcess->blackVolatility().currentLink()){
    }

    void FdmCIREquityPart::setTime(Time t1, Time t2) {
        const Rate q = qTS_->forwardRate(t1, t2, Continuous).rate();

        const Real v = sigma1_->blackForwardVariance(t1, t2, strike_)/(t2-t1);

        mapT_.axpyb(mesher_->locations(1) - q - 0.5*v, dxMap_,
                        dxxMap_.mult(Array(mesher_->layout()->size(), v/2)), -0.5*mesher_->locations(1));
    }

    const TripleBandLinearOp& FdmCIREquityPart::getMap() const {
        return mapT_;
    }

    FdmCIRRatesPart::FdmCIRRatesPart(
        const ext::shared_ptr<FdmMesher>& mesher,
        Real sigma, Real kappa, Real theta)
    : dyMap_(SecondDerivativeOp(1, mesher)
                   .mult(sigma*sigma*mesher->locations(1))
                   .add(FirstDerivativeOp(1, mesher)
                   .mult(kappa*(theta - mesher->locations(1))))),
      mapT_(1, mesher),
      mesher_(mesher){
    }

    void FdmCIRRatesPart::setTime(Time t1, Time t2) {
        mapT_.axpyb(Array(), dyMap_, dyMap_, -0.5*mesher_->locations(1));
    }

    const TripleBandLinearOp& FdmCIRRatesPart::getMap() const {
        return mapT_;
    }

    FdmCIRMixedPart::FdmCIRMixedPart(
        const ext::shared_ptr<FdmMesher>& mesher,
        const ext::shared_ptr<CoxIngersollRossProcess> & cirProcess,
        const ext::shared_ptr<GeneralizedBlackScholesProcess> & bsProcess,
        const Real rho,
        const Real strike)
        : dyMap_(SecondOrderMixedDerivativeOp(0, 1, mesher)
                     .mult(Array(mesher->layout()->size(), 2*rho*cirProcess->volatility()))),
          mapT_(0, 1, mesher),
          mesher_(mesher),
          sigma1_(bsProcess->blackVolatility().currentLink()),
          strike_(strike){
    }

    void FdmCIRMixedPart::setTime(Time t1, Time t2) {
        const Real v = std::sqrt(sigma1_->blackForwardVariance(t1, t2, strike_)/(t2-t1));
        NinePointLinearOp op(dyMap_.mult(Array(mesher_->layout()->size(), v)));
        mapT_.swap(op);
    }

    const NinePointLinearOp& FdmCIRMixedPart::getMap() const {
        return mapT_;
    }

    FdmCIROp::FdmCIROp(
        const ext::shared_ptr<FdmMesher>& mesher,
        const ext::shared_ptr<CoxIngersollRossProcess> & cirProcess,
        const ext::shared_ptr<GeneralizedBlackScholesProcess> & bsProcess,
        const Real rho,
        const Real strike)
    : dxMap_(mesher,
             bsProcess,
             strike),
      dyMap_(mesher,
             cirProcess->volatility(),
             cirProcess->speed(),
             cirProcess->level()),
      dzMap_(mesher,
             cirProcess,
             bsProcess,
             rho,
             strike){
    }


    void FdmCIROp::setTime(Time t1, Time t2) {
        dxMap_.setTime(t1, t2);
        dyMap_.setTime(t1, t2);
        dzMap_.setTime(t1, t2);
    }

    Size FdmCIROp::size() const {
        return 2;
    }

    Disposable<Array> FdmCIROp::apply(const Array& u) const {
        Array dx = dxMap_.getMap().apply(u);
        Array dy = dyMap_.getMap().apply(u);
        Array dz = dzMap_.getMap().apply(u);

        return (dy + dx + dz);
    }

    Disposable<Array> FdmCIROp::apply_direction(Size direction,
                                                   const Array& r) const {
        if (direction == 0)
            return dxMap_.getMap().apply(r);
        else if (direction == 1)
            return dyMap_.getMap().apply(r);
        else
            QL_FAIL("direction too large");
    }

    Disposable<Array> FdmCIROp::apply_mixed(const Array& r) const {
        return dzMap_.getMap().apply(r);
    }

    Disposable<Array>
        FdmCIROp::solve_splitting(Size direction,
                                     const Array& r, Real a) const {

        if (direction == 0) {
            return dxMap_.getMap().solve_splitting(r, a, 1.0);
        }
        else if (direction == 1) {
            return dyMap_.getMap().solve_splitting(r, a, 1.0);
        }
        else
            QL_FAIL("direction too large");
    }

    Disposable<Array>
        FdmCIROp::preconditioner(const Array& r, Real dt) const {

        return solve_splitting(1, solve_splitting(0, r, dt), dt) ;
    }

    Disposable<std::vector<SparseMatrix> >
    FdmCIROp::toMatrixDecomp() const {
        std::vector<SparseMatrix> retVal(3);

        retVal[0] = dxMap_.getMap().toMatrix();
        retVal[1] = dyMap_.getMap().toMatrix();
        retVal[2] = dzMap_.getMap().toMatrix();

        return retVal;
    }

}
]]></document_content>
  </document>
  <document index="17">
    <source>finitedifferences/operators/fdmg2op.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmg2op.cpp */


#include <ql/models/shortrate/twofactormodels/g2.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/fdmg2op.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/secondordermixedderivativeop.hpp>


namespace QuantLib {

    FdmG2Op::FdmG2Op(
        const ext::shared_ptr<FdmMesher>& mesher,
        const ext::shared_ptr<G2>& model,
        Size direction1, Size direction2)
    : direction1_(direction1),
      direction2_(direction2),
      x_(mesher->locations(direction1)),
      y_(mesher->locations(direction2)),
      dxMap_(FirstDerivativeOp(direction1, mesher).mult(-x_*model->a()).add(
                SecondDerivativeOp(direction1, mesher)
                    .mult(0.5*model->sigma()*model->sigma()
                          *Array(mesher->layout()->size(), 1.0)))),
      dyMap_(FirstDerivativeOp(direction2, mesher).mult(-y_*model->b()).add(
                SecondDerivativeOp(direction2, mesher)
                    .mult(0.5*model->eta()*model->eta()
                          *Array(mesher->layout()->size(), 1.0)))),
      corrMap_(SecondOrderMixedDerivativeOp(direction1, direction2, mesher)
              .mult(Array(mesher->layout()->size(),
                          model->rho()*model->sigma()*model->eta()))),
      mapX_(direction1, mesher),
      mapY_(direction2, mesher),
      model_(model) {
    }

    Size FdmG2Op::size() const { return 2U; }

    void FdmG2Op::setTime(Time t1, Time t2) {

        const ext::shared_ptr<TwoFactorModel::ShortRateDynamics> dynamics =
            model_->dynamics();

        const Real phi = 0.5*(  dynamics->shortRate(t1, 0.0, 0.0)
                              + dynamics->shortRate(t2, 0.0, 0.0));

        const Array hr = -0.5*(x_ + y_ + phi);
        mapX_.axpyb(Array(), dxMap_, dxMap_, hr);
        mapY_.axpyb(Array(), dyMap_, dyMap_, hr);
    }

    Disposable<Array> FdmG2Op::apply(const Array& r) const {
        return mapX_.apply(r) + mapY_.apply(r) + apply_mixed(r);
    }

    Disposable<Array> FdmG2Op::apply_mixed(const Array& r) const {
        return corrMap_.apply(r);
    }

    Disposable<Array>
    FdmG2Op::apply_direction(Size direction, const Array& r) const {
        if (direction == direction1_) {
            return mapX_.apply(r);
        }
        else if (direction == direction2_) {
            return mapY_.apply(r);
        }
        else {
            Array retVal(r.size(), 0.0);
            return retVal;
        }
    }

    Disposable<Array>
    FdmG2Op::solve_splitting(Size direction, const Array& r, Real a) const {
        if (direction == direction1_) {
            return mapX_.solve_splitting(r, a, 1.0);
        }
        else if (direction == direction2_) {
            return mapY_.solve_splitting(r, a, 1.0);
        }
        else {
            Array retVal(r.size(), 0.0);
            return retVal;
        }
    }

    Disposable<Array>
    FdmG2Op::preconditioner(const Array& r, Real dt) const {
        return solve_splitting(direction1_, r, dt);
    }

    Disposable<std::vector<SparseMatrix> > FdmG2Op::toMatrixDecomp() const {
        std::vector<SparseMatrix> retVal(3);
        retVal[0] = mapX_.toMatrix();
        retVal[1] = mapY_.toMatrix();
        retVal[2] = corrMap_.toMatrix();

        return retVal;
    }

}

]]></document_content>
  </document>
  <document index="18">
    <source>finitedifferences/operators/fdmhestonhullwhiteop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008, 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmhestonhullwhiteop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/secondordermixedderivativeop.hpp>
#include <ql/models/shortrate/onefactormodels/hullwhite.hpp>
#include <utility>

namespace QuantLib {

    FdmHestonHullWhiteEquityPart::FdmHestonHullWhiteEquityPart(
        const ext::shared_ptr<FdmMesher>& mesher,
        ext::shared_ptr<HullWhite> hwModel,
        ext::shared_ptr<YieldTermStructure> qTS)
    : x_(mesher->locations(2)), varianceValues_(0.5 * mesher->locations(1)),
      dxMap_(FirstDerivativeOp(0, mesher)),
      dxxMap_(SecondDerivativeOp(0, mesher).mult(0.5 * mesher->locations(1))), mapT_(0, mesher),
      hwModel_(std::move(hwModel)), mesher_(mesher), qTS_(std::move(qTS)) {

        // on the boundary s_min and s_max the second derivative
        // dÂ²V/dSÂ² is zero and due to Ito's Lemma the variance term
        // in the drift should vanish.
        const ext::shared_ptr<FdmLinearOpLayout> layout = mesher_->layout();
        const FdmLinearOpIterator endIter = layout->end();
        for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
            ++iter) {
            if (   iter.coordinates()[0] == 0
                || iter.coordinates()[0] == layout->dim()[0]-1) {
                varianceValues_[iter.index()] = 0.0;
            }
        }
        volatilityValues_ = Sqrt(2*varianceValues_);
    }

    void FdmHestonHullWhiteEquityPart::setTime(Time t1, Time t2) {
        const ext::shared_ptr<OneFactorModel::ShortRateDynamics> dynamics =
            hwModel_->dynamics();

        const Real phi = 0.5*(  dynamics->shortRate(t1, 0.0)
                              + dynamics->shortRate(t2, 0.0));

        const Rate q = qTS_->forwardRate(t1, t2, Continuous).rate();

        mapT_.axpyb(x_+phi-varianceValues_-q, dxMap_, dxxMap_, Array());
    }

    const TripleBandLinearOp& FdmHestonHullWhiteEquityPart::getMap() const {
        return mapT_;
    }

    FdmHestonHullWhiteOp::FdmHestonHullWhiteOp(const ext::shared_ptr<FdmMesher>& mesher,
                                               const ext::shared_ptr<HestonProcess>& hestonProcess,
                                               const ext::shared_ptr<HullWhiteProcess>& hwProcess,
                                               Real equityShortRateCorrelation)
    : v0_(hestonProcess->v0()), kappa_(hestonProcess->kappa()), theta_(hestonProcess->theta()),
      sigma_(hestonProcess->sigma()), rho_(hestonProcess->rho()),
      hwModel_(ext::make_shared<HullWhite>(
          hestonProcess->riskFreeRate(), hwProcess->a(), hwProcess->sigma())),
      hestonCorrMap_(
          SecondOrderMixedDerivativeOp(0, 1, mesher).mult(rho_ * sigma_ * mesher->locations(1))),
      equityIrCorrMap_(
          SecondOrderMixedDerivativeOp(0, 2, mesher)
              .mult(Sqrt(mesher->locations(1)) * hwProcess->sigma() * equityShortRateCorrelation)),
      dyMap_(SecondDerivativeOp(1U, mesher)
                 .mult(0.5 * sigma_ * sigma_ * mesher->locations(1))
                 .add(FirstDerivativeOp(1, mesher).mult(kappa_ * (theta_ - mesher->locations(1))))),
      dxMap_(mesher, hwModel_, hestonProcess->dividendYield().currentLink()),
      hullWhiteOp_(mesher, hwModel_, 2) {

        QL_REQUIRE(  equityShortRateCorrelation*equityShortRateCorrelation
                   + hestonProcess->rho()*hestonProcess->rho() <= 1.0,
                   "correlation matrix has negative eigenvalues");
    }

    void FdmHestonHullWhiteOp::setTime(Time t1, Time t2) {
        dxMap_.setTime(t1, t2);
        hullWhiteOp_.setTime(t1, t2);
    }

    Size FdmHestonHullWhiteOp::size() const {
        return 3;
    }

    Disposable<Array> FdmHestonHullWhiteOp::apply(const Array& u) const {
        return  dyMap_.apply(u) + dxMap_.getMap().apply(u)
              + hullWhiteOp_.apply(u)
              + hestonCorrMap_.apply(u) + equityIrCorrMap_.apply(u);
    }

    Disposable<Array>
    FdmHestonHullWhiteOp::apply_direction(Size direction,
                                          const Array& r) const {
        if (direction == 0)
            return dxMap_.getMap().apply(r);
        else if (direction == 1)
            return dyMap_.apply(r);
        else if (direction == 2)
            return hullWhiteOp_.apply(r);
        else
            QL_FAIL("direction too large");
    }

    Disposable<Array> FdmHestonHullWhiteOp::apply_mixed(const Array& r) const {
        return hestonCorrMap_.apply(r) + equityIrCorrMap_.apply(r);
    }

    Disposable<Array>
    FdmHestonHullWhiteOp::solve_splitting(Size direction, const Array& r,
                                          Real a) const {
        if (direction == 0) {
            return dxMap_.getMap().solve_splitting(r, a, 1.0);
        }
        else if (direction == 1) {
            return dyMap_.solve_splitting(r, a, 1.0);
        }
        else if (direction == 2) {
            return hullWhiteOp_.solve_splitting(2, r, a);
        }
        else
            QL_FAIL("direction too large");
    }
    
    Disposable<Array> FdmHestonHullWhiteOp::preconditioner(const Array& r, 
                                                           Real dt) const {
        return solve_splitting(0, r, dt);
    }

    Disposable<std::vector<SparseMatrix> >
    FdmHestonHullWhiteOp::toMatrixDecomp() const {
        std::vector<SparseMatrix> retVal(4);
        retVal[0] = dxMap_.getMap().toMatrix();
        retVal[1] = dyMap_.toMatrix();
        retVal[2] = hullWhiteOp_.toMatrixDecomp().front();
        retVal[3] = hestonCorrMap_.toMatrix() + equityIrCorrMap_.toMatrix();

        return retVal;
    }

}
]]></document_content>
  </document>
  <document index="19">
    <source>finitedifferences/operators/fdmhestonop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008, 2014, 2015 Klaus Spanderen
 Copyright (C) 2015 Johannes GÃ¶ttker-Schnetmann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmhestonop.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/secondordermixedderivativeop.hpp>
#include <utility>

namespace QuantLib {

    FdmHestonEquityPart::FdmHestonEquityPart(const ext::shared_ptr<FdmMesher>& mesher,
                                             ext::shared_ptr<YieldTermStructure> rTS,
                                             ext::shared_ptr<YieldTermStructure> qTS,
                                             ext::shared_ptr<FdmQuantoHelper> quantoHelper,
                                             ext::shared_ptr<LocalVolTermStructure> leverageFct)
    : varianceValues_(0.5 * mesher->locations(1)), dxMap_(FirstDerivativeOp(0, mesher)),
      dxxMap_(SecondDerivativeOp(0, mesher).mult(0.5 * mesher->locations(1))), mapT_(0, mesher),
      mesher_(mesher), rTS_(std::move(rTS)), qTS_(std::move(qTS)),
      quantoHelper_(std::move(quantoHelper)), leverageFct_(std::move(leverageFct)) {

        // on the boundary s_min and s_max the second derivative
        // d^2V/dS^2 is zero and due to Ito's Lemma the variance term
        // in the drift should vanish.
        ext::shared_ptr<FdmLinearOpLayout> layout = mesher_->layout();
        FdmLinearOpIterator endIter = layout->end();
        for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
            ++iter) {
            if (   iter.coordinates()[0] == 0
                || iter.coordinates()[0] == layout->dim()[0]-1) {
                varianceValues_[iter.index()] = 0.0;
            }
        }
        volatilityValues_ = Sqrt(2*varianceValues_);
    }

    void FdmHestonEquityPart::setTime(Time t1, Time t2) {
        const Rate r = rTS_->forwardRate(t1, t2, Continuous).rate();
        const Rate q = qTS_->forwardRate(t1, t2, Continuous).rate();

        L_ = getLeverageFctSlice(t1, t2);
        const Array Lsquare = L_*L_;

        if (quantoHelper_ != nullptr) {
            mapT_.axpyb(r - q - varianceValues_*Lsquare
                - quantoHelper_->quantoAdjustment(
                    volatilityValues_*L_, t1, t2),
                dxMap_, dxxMap_.mult(Lsquare), Array(1, -0.5*r));
        } else {
            mapT_.axpyb(r - q - varianceValues_*Lsquare, dxMap_,
                        dxxMap_.mult(Lsquare), Array(1, -0.5*r));
        }
    }

    Disposable<Array> FdmHestonEquityPart::getLeverageFctSlice(Time t1, Time t2)
    const {
        const ext::shared_ptr<FdmLinearOpLayout> layout=mesher_->layout();
        Array v(layout->size(), 1.0);

        if (!leverageFct_) {
            return v;
        }
        const Real t = 0.5*(t1+t2);
        const Time time = std::min(leverageFct_->maxTime(), t);

        const FdmLinearOpIterator endIter = layout->end();
        for (FdmLinearOpIterator iter = layout->begin();
             iter!=endIter; ++iter) {
            const Size nx = iter.coordinates()[0];

            if (iter.coordinates()[1] == 0) {
                const Real x = std::exp(mesher_->location(iter, 0));
                const Real spot = std::min(leverageFct_->maxStrike(),
                                           std::max(leverageFct_->minStrike(), x));
                v[nx] = std::max(0.01, leverageFct_->localVol(time, spot, true));
            }
            else {
                v[iter.index()] = v[nx];
            }
        }
        return v;
    }


    const TripleBandLinearOp& FdmHestonEquityPart::getMap() const {
        return mapT_;
    }

    FdmHestonVariancePart::FdmHestonVariancePart(const ext::shared_ptr<FdmMesher>& mesher,
                                                 ext::shared_ptr<YieldTermStructure> rTS,
                                                 Real mixedSigma,
                                                 Real kappa,
                                                 Real theta)
    : dyMap_(SecondDerivativeOp(1, mesher)
                 .mult(0.5 * mixedSigma * mixedSigma * mesher->locations(1))
                 .add(FirstDerivativeOp(1, mesher).mult(kappa * (theta - mesher->locations(1))))),
      mapT_(1, mesher), rTS_(std::move(rTS)) {}

    void FdmHestonVariancePart::setTime(Time t1, Time t2) {
        const Rate r = rTS_->forwardRate(t1, t2, Continuous).rate();
        mapT_.axpyb(Array(), dyMap_, dyMap_, Array(1,-0.5*r));
    }

    const TripleBandLinearOp& FdmHestonVariancePart::getMap() const {
        return mapT_;
    }

    FdmHestonOp::FdmHestonOp(
        const ext::shared_ptr<FdmMesher>& mesher,
        const ext::shared_ptr<HestonProcess> & hestonProcess,
        const ext::shared_ptr<FdmQuantoHelper>& quantoHelper,
        const ext::shared_ptr<LocalVolTermStructure>& leverageFct,
        const Real mixingFactor)
    : correlationMap_(SecondOrderMixedDerivativeOp(0, 1, mesher)
                        .mult(hestonProcess->rho()*hestonProcess->sigma()
                                *mixingFactor
                                *mesher->locations(1))),
      dyMap_(mesher, hestonProcess->riskFreeRate().currentLink(),
              hestonProcess->sigma()*mixingFactor,
              hestonProcess->kappa(), 
              hestonProcess->theta()),
      dxMap_(mesher,
             hestonProcess->riskFreeRate().currentLink(), 
             hestonProcess->dividendYield().currentLink(),
             quantoHelper, leverageFct) {
    }


    void FdmHestonOp::setTime(Time t1, Time t2) {
        dxMap_.setTime(t1, t2);
        dyMap_.setTime(t1, t2);
    }

    Size FdmHestonOp::size() const {
        return 2;
    }

    Disposable<Array> FdmHestonOp::apply(const Array& u) const {
        return dyMap_.getMap().apply(u) + dxMap_.getMap().apply(u)
              + dxMap_.getL()*correlationMap_.apply(u);
    }

    Disposable<Array> FdmHestonOp::apply_direction(Size direction,
                                                   const Array& r) const {
        if (direction == 0)
            return dxMap_.getMap().apply(r);
        else if (direction == 1)
            return dyMap_.getMap().apply(r);
        else
            QL_FAIL("direction too large");
    }

    Disposable<Array> FdmHestonOp::apply_mixed(const Array& r) const {
        return dxMap_.getL()*correlationMap_.apply(r);
    }

    Disposable<Array>
        FdmHestonOp::solve_splitting(Size direction,
                                     const Array& r, Real a) const {

        if (direction == 0) {
            return dxMap_.getMap().solve_splitting(r, a, 1.0);
        }
        else if (direction == 1) {
            return dyMap_.getMap().solve_splitting(r, a, 1.0);
        }
        else
            QL_FAIL("direction too large");
    }

    Disposable<Array>
        FdmHestonOp::preconditioner(const Array& r, Real dt) const {

        return solve_splitting(1, solve_splitting(0, r, dt), dt) ;
    }

    Disposable<std::vector<SparseMatrix> >
    FdmHestonOp::toMatrixDecomp() const {
        std::vector<SparseMatrix> retVal(3);

        retVal[0] = dxMap_.getMap().toMatrix();
        retVal[1] = dyMap_.getMap().toMatrix();
        retVal[2] = correlationMap_.toMatrix();

        return retVal;
    }

}
]]></document_content>
  </document>
  <document index="20">
    <source>finitedifferences/operators/fdmhullwhiteop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmhullwhiteop.cpp */


#include <ql/models/shortrate/onefactormodels/hullwhite.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/fdmhullwhiteop.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>

namespace QuantLib {

    FdmHullWhiteOp::FdmHullWhiteOp(
        const ext::shared_ptr<FdmMesher>& mesher,
        const ext::shared_ptr<HullWhite>& model,
        Size direction)
    : direction_(direction),
      x_(mesher->locations(direction)),
      dzMap_(FirstDerivativeOp(direction, mesher).mult(-x_*model->a()).add(
                SecondDerivativeOp(direction, mesher)
                    .mult(0.5*model->sigma()*model->sigma()
                          *Array(mesher->layout()->size(), 1.0)))),
      mapT_(direction, mesher),
      model_(model) {
    }

    Size FdmHullWhiteOp::size() const { return 1U; }

    void FdmHullWhiteOp::setTime(Time t1, Time t2) {

        const ext::shared_ptr<OneFactorModel::ShortRateDynamics> dynamics =
            model_->dynamics();

        const Real phi = 0.5*(  dynamics->shortRate(t1, 0.0)
                              + dynamics->shortRate(t2, 0.0));

        mapT_.axpyb(Array(), dzMap_, dzMap_, -(x_+phi));
    }

    Disposable<Array> FdmHullWhiteOp::apply(const Array& r) const {
        return mapT_.apply(r);
    }

    Disposable<Array> FdmHullWhiteOp::apply_mixed(const Array& r) const {
        Array retVal(r.size(), 0.0);
        return retVal;
    }

    Disposable<Array>
    FdmHullWhiteOp::apply_direction(Size direction, const Array& r) const {
        if (direction == direction_)
            return mapT_.apply(r);
        else {
            Array retVal(r.size(), 0.0);
            return retVal;
        }
    }

    Disposable<Array> FdmHullWhiteOp::solve_splitting(
        Size direction, const Array& r, Real a) const {

        if (direction == direction_) {
            return mapT_.solve_splitting(r, a, 1.0);
        }
        else {
            Array retVal(r.size(), 0.0);
            return retVal;
        }
    }

    Disposable<Array>
    FdmHullWhiteOp::preconditioner(const Array& r, Real dt) const {
        return solve_splitting(direction_, r, dt);
    }

    Disposable<std::vector<SparseMatrix> >
    FdmHullWhiteOp::toMatrixDecomp() const {
        std::vector<SparseMatrix> retVal(1, mapT_.toMatrix());
        return retVal;
    }

}

]]></document_content>
  </document>
  <document index="21">
    <source>finitedifferences/operators/fdmlinearoplayout.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>

namespace QuantLib {

    Size FdmLinearOpLayout::neighbourhood(const FdmLinearOpIterator& iterator,
                                          Size i, Integer offset) const {
        Size myIndex = iterator.index()
            - iterator.coordinates()[i]*spacing_[i];

        Integer coorOffset = Integer(iterator.coordinates()[i])+offset;
        if (coorOffset < 0) {
            coorOffset=-coorOffset;
        }
        else if (Size(coorOffset) >= dim_[i]) {
            coorOffset = 2*(dim_[i]-1) - coorOffset;
        }
        return myIndex + coorOffset*spacing_[i];
    }

    Size FdmLinearOpLayout::neighbourhood(const FdmLinearOpIterator& iterator,
                                          Size i1, Integer offset1,
                                          Size i2, Integer offset2) const {

        Size myIndex = iterator.index()
            - iterator.coordinates()[i1]*spacing_[i1]
            - iterator.coordinates()[i2]*spacing_[i2];

        Integer coorOffset1 = Integer(iterator.coordinates()[i1])+offset1;
        if (coorOffset1 < 0) {
            coorOffset1=-coorOffset1;
        }
        else if (Size(coorOffset1) >= dim_[i1]) {
            coorOffset1 = 2*(dim_[i1]-1) - coorOffset1;
        }

        Integer coorOffset2 = Integer(iterator.coordinates()[i2])+offset2;
        if (coorOffset2 < 0) {
            coorOffset2=-coorOffset2;
        }
        else if (Size(coorOffset2) >= dim_[i2]) {
            coorOffset2 = 2*(dim_[i2]-1) - coorOffset2;
        }

        return myIndex + coorOffset1*spacing_[i1]+coorOffset2*spacing_[i2];
    }

    // smart but sometimes too slow
    Disposable<FdmLinearOpIterator> FdmLinearOpLayout::iter_neighbourhood(
        const FdmLinearOpIterator& iterator, Size i, Integer offset) const {

        std::vector<Size> coordinates = iterator.coordinates();

        Integer coorOffset = Integer(coordinates[i])+offset;
        if (coorOffset < 0) {
            coorOffset=-coorOffset;
        }
        else if (Size(coorOffset) >= dim_[i]) {
            coorOffset = 2*(dim_[i]-1) - coorOffset;
        }
        coordinates[i] = Size(coorOffset);

        FdmLinearOpIterator retVal(dim_, coordinates,
                                   index(coordinates));

        return retVal;
    }
}
]]></document_content>
  </document>
  <document index="22">
    <source>finitedifferences/operators/fdmlocalvolfwdop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes GÃ¶ttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/functional.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/fdmlocalvolfwdop.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>
#include <utility>

namespace QuantLib {

    FdmLocalVolFwdOp::FdmLocalVolFwdOp(const ext::shared_ptr<FdmMesher>& mesher,
                                       const ext::shared_ptr<Quote>& spot,
                                       ext::shared_ptr<YieldTermStructure> rTS,
                                       ext::shared_ptr<YieldTermStructure> qTS,
                                       const ext::shared_ptr<LocalVolTermStructure>& localVol,
                                       Size direction)
    : mesher_(mesher), rTS_(std::move(rTS)), qTS_(std::move(qTS)), localVol_(localVol),
      x_((localVol) != nullptr ? Array(Exp(mesher->locations(direction))) : Array()),
      dxMap_(FirstDerivativeOp(direction, mesher)), dxxMap_(SecondDerivativeOp(direction, mesher)),
      mapT_(direction, mesher), direction_(direction) {}

    void FdmLocalVolFwdOp::setTime(Time t1, Time t2) {
        const Rate r = rTS_->forwardRate(t1, t2, Continuous).rate();
        const Rate q = qTS_->forwardRate(t1, t2, Continuous).rate();

        const ext::shared_ptr<FdmLinearOpLayout> layout=mesher_->layout();
        const FdmLinearOpIterator endIter = layout->end();

        Array v(layout->size());
        for (FdmLinearOpIterator iter = layout->begin();
            iter != endIter; ++iter) {
            const Size i = iter.index();

            v[i] = square<Real>()(
                localVol_->localVol(0.5*(t1+t2), x_[i], true));
        }
        mapT_.axpyb(Array(1, 1.0), dxMap_.multR(- r + q + 0.5*v),
                    dxxMap_.multR(0.5*v), Array(1, 0.0));
    }

    Size FdmLocalVolFwdOp::size() const { return 1U; }

    Disposable<Array> FdmLocalVolFwdOp::apply(const Array& u) const {
        return mapT_.apply(u);
    }

    Disposable<Array> FdmLocalVolFwdOp::apply_direction(
        Size direction, const Array& r) const {
        if (direction == direction_)
            return mapT_.apply(r);
        else {
            Array retVal(r.size(), 0.0);
            return retVal;
        }
    }

    Disposable<Array> FdmLocalVolFwdOp::apply_mixed(const Array& r) const {
        Array retVal(r.size(), 0.0);
        return retVal;
    }

    Disposable<Array> FdmLocalVolFwdOp::solve_splitting(
        Size direction, const Array& r, Real dt) const {
        if (direction == direction_)
            return mapT_.solve_splitting(r, dt, 1.0);
        else {
            Array retVal(r);
            return retVal;
        }
    }

    Disposable<Array> FdmLocalVolFwdOp::preconditioner(
        const Array& r, Real dt) const {
        return solve_splitting(direction_, r, dt);
    }

    Disposable<std::vector<SparseMatrix> >
    FdmLocalVolFwdOp::toMatrixDecomp() const {
        std::vector<SparseMatrix> retVal(1, mapT_.toMatrix());
        return retVal;
    }

}
]]></document_content>
  </document>
  <document index="23">
    <source>finitedifferences/operators/fdmornsteinuhlenbeckop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmornsteinuhlenbeckop.cpp
*/

#include <ql/math/functional.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/fdmornsteinuhlenbeckop.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>
#include <ql/processes/ornsteinuhlenbeckprocess.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    FdmOrnsteinUhlenbeckOp::FdmOrnsteinUhlenbeckOp(
        const ext::shared_ptr<FdmMesher>& mesher,
        ext::shared_ptr<OrnsteinUhlenbeckProcess> process,
        ext::shared_ptr<YieldTermStructure> rTS,
        Size direction)
    : mesher_(mesher), process_(std::move(process)), rTS_(std::move(rTS)), direction_(direction),
      m_(direction, mesher), mapX_(direction, mesher) {

        const ext::shared_ptr<FdmLinearOpLayout> layout=mesher_->layout();

        Array drift(layout->size());
        const Array x(mesher_->locations(direction));

        for (FdmLinearOpIterator iter=layout->begin(), endIter=layout->end();
             iter!=endIter; ++iter) {
            const Size i = iter.index();
            drift[i] = process_->drift(0.0, x[i]);
        }

        m_.axpyb(drift, FirstDerivativeOp(direction, mesher),
            SecondDerivativeOp(direction, mesher)
                .mult(0.5*square<Real>()(process_->volatility())
                      *Array(mesher->layout()->size(), 1.0)), Array());
    }

    Size FdmOrnsteinUhlenbeckOp::size() const {
        return mesher_->layout()->dim().size();;
    }

    void FdmOrnsteinUhlenbeckOp::setTime(Time t1, Time t2) {
        const Rate r = rTS_->forwardRate(t1, t2, Continuous).rate();

        mapX_.axpyb(Array(), m_, m_, Array(1, -r));
    }

    Disposable<Array> FdmOrnsteinUhlenbeckOp::apply(const Array& r) const {
        return mapX_.apply(r);
    }

    Disposable<Array> FdmOrnsteinUhlenbeckOp::apply_mixed(
        const Array& r) const {

        Array retVal(r.size(), 0.0);
        return retVal;
    }

    Disposable<Array> FdmOrnsteinUhlenbeckOp::apply_direction(
        Size direction, const Array& r) const {

        if (direction == direction_) {
            return mapX_.apply(r);
        }
        else {
            Array retVal(r.size(), 0.0);
            return retVal;
        }
    }

    Disposable<Array> FdmOrnsteinUhlenbeckOp::solve_splitting(
        Size direction, const Array& r, Real a) const {

        if (direction == direction_) {
            return mapX_.solve_splitting(r, a, 1.0);
        }
        else {
            Array retVal(r);
            return retVal;
        }
    }

    Disposable<Array> FdmOrnsteinUhlenbeckOp::preconditioner(
        const Array& r, Real dt) const {
        return solve_splitting(direction_, r, dt);
    }

    Disposable<std::vector<SparseMatrix> >
    FdmOrnsteinUhlenbeckOp::toMatrixDecomp() const {
        std::vector<SparseMatrix> retVal(1, mapX_.toMatrix());
        return retVal;
    }

}
]]></document_content>
  </document>
  <document index="24">
    <source>finitedifferences/operators/fdmsabrop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmsabrop.cpp
    \brief FDM operator for the SABR model
*/

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/fdmsabrop.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>
#include <ql/methods/finitedifferences/operators/secondordermixedderivativeop.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {
    FdmSabrOp::FdmSabrOp(const ext::shared_ptr<FdmMesher>& mesher,
                         ext::shared_ptr<YieldTermStructure> rTS,
                         Real f0,
                         Real alpha,
                         Real beta,
                         Real nu,
                         Real rho)
    : rTS_(std::move(rTS)),
      dffMap_(SecondDerivativeOp(0, mesher).mult(0.5 * Exp(2.0 * mesher->locations(1)) *
                                                 Pow(mesher->locations(0), 2.0 * beta))),
      dxMap_(FirstDerivativeOp(1, mesher).mult(Array(mesher->layout()->size(), -0.5 * nu * nu))),
      dxxMap_(SecondDerivativeOp(1, mesher).mult(Array(mesher->layout()->size(), 0.5 * nu * nu))),
      correlationMap_(
          SecondOrderMixedDerivativeOp(0, 1, mesher)
              .mult(rho * nu * Exp(mesher->locations(1)) * Pow(mesher->locations(0), beta))),
      mapF_(0, mesher), mapA_(1, mesher) {}

    void FdmSabrOp::setTime(Time t1, Time t2) {
        const Rate r = rTS_->forwardRate(t1, t2, Continuous).rate();

        mapF_.axpyb(Array(), dffMap_, dffMap_, Array(1, -0.5*r));
        mapA_.axpyb(Array(1, 1.0), dxMap_, dxxMap_, Array(1, -0.5*r));
    }

    Size FdmSabrOp::size() const {
        return 2;
    }

    Disposable<Array> FdmSabrOp::apply(const Array& u) const {
        return mapF_.apply(u) + mapA_.apply(u) + correlationMap_.apply(u);
    }

    Disposable<Array> FdmSabrOp::apply_mixed(const Array& r) const {
        return correlationMap_.apply(r);
    }

    Disposable<Array> FdmSabrOp::apply_direction(
        Size direction, const Array& r) const {
        if (direction == 0)
            return mapF_.apply(r);
        else if (direction == 1)
            return mapA_.apply(r);
        else
            QL_FAIL("direction too large");
    }

    Disposable<Array> FdmSabrOp::solve_splitting(
       Size direction, const Array& r, Real a) const {

        if (direction == 0) {
            return mapF_.solve_splitting(r, a, 1.0);
        }
        else if (direction == 1) {
            return mapA_.solve_splitting(r, a, 1.0);
        }
        else
            QL_FAIL("direction too large");
    }

    Disposable<Array> FdmSabrOp::preconditioner(
        const Array& r, Real dt) const {

        return solve_splitting(1, solve_splitting(0, r, dt), dt) ;
    }

    Disposable<std::vector<SparseMatrix> > FdmSabrOp::toMatrixDecomp() const {
        std::vector<SparseMatrix> retVal(3);

        retVal[0] = mapA_.toMatrix();
        retVal[1] = mapF_.toMatrix();
        retVal[2] = correlationMap_.toMatrix();

        return retVal;
    }

}
]]></document_content>
  </document>
  <document index="25">
    <source>finitedifferences/operators/firstderivativeop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/firstderivativeop.hpp>

namespace QuantLib {

    FirstDerivativeOp::FirstDerivativeOp(
                                Size direction,
                                const ext::shared_ptr<FdmMesher>& mesher)
    : TripleBandLinearOp(direction, mesher) {

        const ext::shared_ptr<FdmLinearOpLayout> layout = mesher->layout();
        const FdmLinearOpIterator endIter = layout->end();

        for (FdmLinearOpIterator iter = layout->begin(); iter!=endIter; ++iter) {
            const Size i = iter.index();
            const Real hm = mesher->dminus(iter, direction_);
            const Real hp = mesher->dplus(iter, direction_);

            const Real zetam1 = hm*(hm+hp);
            const Real zeta0  = hm*hp;
            const Real zetap1 = hp*(hm+hp);

            if (iter.coordinates()[direction_] == 0) {
                //upwinding scheme
                lower_[i] = 0.0;
                diag_[i]  = -(upper_[i] = 1/hp);
            }
            else if (   iter.coordinates()[direction_]
                     == layout->dim()[direction]-1) {
                 // downwinding scheme
                lower_[i] = -(diag_[i] = 1/hm);
                upper_[i] = 0.0;
            }
            else {
                lower_[i] = -hp/zetam1;
                diag_[i]  = (hp-hm)/zeta0;
                upper_[i] = hm/zetap1;
            }
        }
    }
}

]]></document_content>
  </document>
  <document index="26">
    <source>finitedifferences/operators/ninepointlinearop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/ninepointlinearop.hpp>

namespace QuantLib {

    NinePointLinearOp::NinePointLinearOp(
        Size d0, Size d1,
        const ext::shared_ptr<FdmMesher>& mesher)
    : d0_(d0), d1_(d1),
      i00_(new Size[mesher->layout()->size()]),
      i10_(new Size[mesher->layout()->size()]),
      i20_(new Size[mesher->layout()->size()]),
      i01_(new Size[mesher->layout()->size()]),
      i21_(new Size[mesher->layout()->size()]),
      i02_(new Size[mesher->layout()->size()]),
      i12_(new Size[mesher->layout()->size()]),
      i22_(new Size[mesher->layout()->size()]),
      a00_(new Real[mesher->layout()->size()]),
      a10_(new Real[mesher->layout()->size()]),
      a20_(new Real[mesher->layout()->size()]),
      a01_(new Real[mesher->layout()->size()]),
      a11_(new Real[mesher->layout()->size()]),
      a21_(new Real[mesher->layout()->size()]),
      a02_(new Real[mesher->layout()->size()]),
      a12_(new Real[mesher->layout()->size()]),
      a22_(new Real[mesher->layout()->size()]),
      mesher_(mesher) {

        QL_REQUIRE(   d0_ != d1_
            && d0_ < mesher->layout()->dim().size()
            && d1_ < mesher->layout()->dim().size(),
            "inconsistent derivative directions");

        const ext::shared_ptr<FdmLinearOpLayout> layout = mesher->layout();
        const FdmLinearOpIterator endIter = layout->end();

        for (FdmLinearOpIterator iter = layout->begin(); iter!=endIter; ++iter) {
            const Size i = iter.index();

            i10_[i] = layout->neighbourhood(iter, d1_, -1);
            i01_[i] = layout->neighbourhood(iter, d0_, -1);
            i21_[i] = layout->neighbourhood(iter, d0_,  1);
            i12_[i] = layout->neighbourhood(iter, d1_,  1);
            i00_[i] = layout->neighbourhood(iter, d0_, -1, d1_, -1);
            i20_[i] = layout->neighbourhood(iter, d0_,  1, d1_, -1);
            i02_[i] = layout->neighbourhood(iter, d0_, -1, d1_,  1);
            i22_[i] = layout->neighbourhood(iter, d0_,  1, d1_,  1);
        }
    }

    NinePointLinearOp::NinePointLinearOp(const NinePointLinearOp& m)
    : i00_(new Size[m.mesher_->layout()->size()]),
      i10_(new Size[m.mesher_->layout()->size()]),
      i20_(new Size[m.mesher_->layout()->size()]),
      i01_(new Size[m.mesher_->layout()->size()]),
      i21_(new Size[m.mesher_->layout()->size()]),
      i02_(new Size[m.mesher_->layout()->size()]),
      i12_(new Size[m.mesher_->layout()->size()]),
      i22_(new Size[m.mesher_->layout()->size()]),
      a00_(new Real[m.mesher_->layout()->size()]),
      a10_(new Real[m.mesher_->layout()->size()]),
      a20_(new Real[m.mesher_->layout()->size()]),
      a01_(new Real[m.mesher_->layout()->size()]),
      a11_(new Real[m.mesher_->layout()->size()]),
      a21_(new Real[m.mesher_->layout()->size()]),
      a02_(new Real[m.mesher_->layout()->size()]),
      a12_(new Real[m.mesher_->layout()->size()]),
      a22_(new Real[m.mesher_->layout()->size()]),
      mesher_(m.mesher_) {

        const Size size = mesher_->layout()->size();
        std::copy(m.i00_.get(), m.i00_.get()+size, i00_.get());
        std::copy(m.i10_.get(), m.i10_.get()+size, i10_.get());
        std::copy(m.i20_.get(), m.i20_.get()+size, i20_.get());
        std::copy(m.i01_.get(), m.i01_.get()+size, i01_.get());
        std::copy(m.i21_.get(), m.i21_.get()+size, i21_.get());
        std::copy(m.i02_.get(), m.i02_.get()+size, i02_.get());
        std::copy(m.i12_.get(), m.i12_.get()+size, i12_.get());
        std::copy(m.i22_.get(), m.i22_.get()+size, i22_.get());
        std::copy(m.a00_.get(), m.a00_.get()+size, a00_.get());
        std::copy(m.a10_.get(), m.a10_.get()+size, a10_.get());
        std::copy(m.a20_.get(), m.a20_.get()+size, a20_.get());
        std::copy(m.a01_.get(), m.a01_.get()+size, a01_.get());
        std::copy(m.a11_.get(), m.a11_.get()+size, a11_.get());
        std::copy(m.a21_.get(), m.a21_.get()+size, a21_.get());
        std::copy(m.a02_.get(), m.a02_.get()+size, a02_.get());
        std::copy(m.a12_.get(), m.a12_.get()+size, a12_.get());
        std::copy(m.a22_.get(), m.a22_.get()+size, a22_.get());
    }

    #ifdef QL_USE_DISPOSABLE
    NinePointLinearOp::NinePointLinearOp(
        const Disposable<NinePointLinearOp>& from) {
        swap(const_cast<Disposable<NinePointLinearOp>&>(from));
    }

    NinePointLinearOp& NinePointLinearOp::operator=(
        const Disposable<NinePointLinearOp>& m) {
        swap(const_cast<Disposable<NinePointLinearOp>&>(m));
        return *this;
    }
    #endif

    Disposable<Array> NinePointLinearOp::apply(const Array& u)
        const {

        const ext::shared_ptr<FdmLinearOpLayout> index=mesher_->layout();
        QL_REQUIRE(u.size() == index->size(),"inconsistent length of r "
                    << u.size() << " vs " << index->size());

        Array retVal(u.size());
        // direct access to make the following code faster.
        const Real *a00(a00_.get()), *a01(a01_.get()), *a02(a02_.get());
        const Real *a10(a10_.get()), *a11(a11_.get()), *a12(a12_.get());
        const Real *a20(a20_.get()), *a21(a21_.get()), *a22(a22_.get());
        const Size *i00(i00_.get()), *i01(i01_.get()), *i02(i02_.get());
        const Size *i10(i10_.get()),                   *i12(i12_.get());
        const Size *i20(i20_.get()), *i21(i21_.get()), *i22(i22_.get());

        //#pragma omp parallel for
        for (Size i=0; i < retVal.size(); ++i) {
            retVal[i] =   a00[i]*u[i00[i]]
                        + a01[i]*u[i01[i]]
                        + a02[i]*u[i02[i]]
                        + a10[i]*u[i10[i]]
                        + a11[i]*u[i]
                        + a12[i]*u[i12[i]]
                        + a20[i]*u[i20[i]]
                        + a21[i]*u[i21[i]]
                        + a22[i]*u[i22[i]];
        }
        return retVal;
    }

    Disposable<SparseMatrix> NinePointLinearOp::toMatrix() const {
        const ext::shared_ptr<FdmLinearOpLayout> index = mesher_->layout();
        const Size n = index->size();

        SparseMatrix retVal(n, n, 9*n);
        for (Size i=0; i < index->size(); ++i) {
            retVal(i, i00_[i]) += a00_[i];
            retVal(i, i01_[i]) += a01_[i];
            retVal(i, i02_[i]) += a02_[i];
            retVal(i, i10_[i]) += a10_[i];
            retVal(i, i      ) += a11_[i];
            retVal(i, i12_[i]) += a12_[i];
            retVal(i, i20_[i]) += a20_[i];
            retVal(i, i21_[i]) += a21_[i];
            retVal(i, i22_[i]) += a22_[i];
        }

        return retVal;
    }


    Disposable<NinePointLinearOp>
        NinePointLinearOp::mult(const Array & u) const {

        NinePointLinearOp retVal(d0_, d1_, mesher_);
        const Size size = mesher_->layout()->size();

        //#pragma omp parallel for
        for (Size i=0; i < size; ++i) {
            const Real s = u[i];
            retVal.a11_[i]=a11_[i]*s; retVal.a00_[i]=a00_[i]*s;
            retVal.a01_[i]=a01_[i]*s; retVal.a02_[i]=a02_[i]*s;
            retVal.a10_[i]=a10_[i]*s; retVal.a20_[i]=a20_[i]*s;
            retVal.a21_[i]=a21_[i]*s; retVal.a12_[i]=a12_[i]*s;
            retVal.a22_[i]=a22_[i]*s;
        }

        return retVal;
    }

    void NinePointLinearOp::swap(NinePointLinearOp& m) {
        std::swap(d0_, m.d0_);
        std::swap(d1_, m.d1_);

        i00_.swap(m.i00_); i10_.swap(m.i10_); i20_.swap(m.i20_);
        i01_.swap(m.i01_); i21_.swap(m.i21_); i02_.swap(m.i02_);
        i12_.swap(m.i12_); i22_.swap(m.i22_);
        a00_.swap(m.a00_); a10_.swap(m.a10_); a20_.swap(m.a20_);
        a01_.swap(m.a01_); a21_.swap(m.a21_); a02_.swap(m.a02_);
        a12_.swap(m.a12_); a22_.swap(m.a22_); a11_.swap(m.a11_);

        std::swap(mesher_, m.mesher_);
    }
}
]]></document_content>
  </document>
  <document index="27">
    <source>finitedifferences/operators/nthorderderivativeop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file NthOrderDerivativeOp.cpp
    \brief n-th order derivative linear operator
*/

#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/numericaldifferentiation.hpp>
#include <ql/methods/finitedifferences/operators/nthorderderivativeop.hpp>

#include <set>

namespace QuantLib {

    NthOrderDerivativeOp::NthOrderDerivativeOp(
        Size direction, Size order, Integer nPoints,
        const ext::shared_ptr<FdmMesher>& mesher)
    : m_(mesher->layout()->size(), mesher->layout()->size()) {

        const Integer hPoints = nPoints/2;
        const bool isEven = (nPoints == 2*hPoints);

        const ext::shared_ptr<FdmLinearOpLayout> layout = mesher->layout();
        const FdmLinearOpIterator endIter = layout->end();

        Array xValues = mesher->locations(direction);
        std::set<Real> tmp(xValues.begin(), xValues.end());
        xValues = Array(tmp.begin(), tmp.end()); //unique vector

        const Integer nx(layout->dim()[direction]);

        QL_REQUIRE(Integer(xValues.size()) == nx,
            "inconsistent set of grid values in direction " << direction);

        QL_REQUIRE(nPoints > 1 && Integer(nPoints) <= nx,
             "inconsistent number of points");

        Array xOffsets(nPoints);
        const ext::function<Real(Real)> emptyFct;

        for (FdmLinearOpIterator iter = layout->begin(); iter!=endIter; ++iter) {
            const auto ix = Integer(iter.coordinates()[direction]);
            const Integer offset = std::max(0, hPoints - ix)
                - std::max(0, hPoints - (nx-((isEven)? 0 : 1) - ix));

            const Integer ilx = ix - hPoints + offset;

            for (Integer j=0; j < nPoints; ++j) {
                const Integer idx = ilx + j;
                xOffsets[j] = xValues[idx] - xValues[ix];
            }

            const Array weights =
                NumericalDifferentiation(emptyFct, order, xOffsets).weights();

            const Size i = iter.index();
            for (Integer j=0; j < nPoints; ++j) {
                const Size k = layout->neighbourhood(iter, direction, ilx - ix + j);

                m_(i, k) = weights[j];
            }
        }
    }

    Disposable<NthOrderDerivativeOp::array_type>
    NthOrderDerivativeOp::apply(const array_type& r) const {
        return prod(m_, r);
    }


    Disposable<SparseMatrix> NthOrderDerivativeOp::toMatrix() const {
        SparseMatrix tmp(m_);
        return tmp;
    }

}

]]></document_content>
  </document>
  <document index="28">
    <source>finitedifferences/operators/numericaldifferentiation.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file numericaldifferentiation.cpp */

#include <ql/methods/finitedifferences/operators/numericaldifferentiation.hpp>

#ifndef QL_EXTRA_SAFETY_CHECKS
#define BOOST_DISABLE_ASSERTS 1
#endif
#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#endif
#include <boost/multi_array.hpp>
#include <utility>
#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#    pragma GCC diagnostic pop
#endif

namespace QuantLib {

    namespace {
        Disposable<Array> calcOffsets(
            Real h, Size n, NumericalDifferentiation::Scheme scheme) {
            QL_REQUIRE(n > 1, "number of steps must be greater than one");

            Array retVal(n);
            switch (scheme) {
              case NumericalDifferentiation::Central:
                QL_REQUIRE(n > 2 && (n % 2),
                    "number of steps must be an odd number greater than two");
                for (Integer i=0; i < Integer(n); ++i)
                    retVal[i] = (i-Integer(n/2))*h;
                break;
              case NumericalDifferentiation::Backward:
                for (Size i=0; i < n; ++i)
                    retVal[i]=-(i*h);
                break;
              case NumericalDifferentiation::Forward:
                for (Size i=0; i < n; ++i)
                    retVal[i]=i*h;
                break;
              default:
                QL_FAIL("unknown numerical differentiation scheme");
            }

            return retVal;
        }

        // This is a C++ implementation of the algorithm/pseudo code in
        // B. Fornberg, 1998. Calculation of Weights
        //                    in Finite Difference Formulas
        // https://amath.colorado.edu/faculty/fornberg/Docs/sirev_cl.pdf
        Disposable<Array> calcWeights(const Array& x, Size M) {
            const Size N = x.size();
            QL_REQUIRE(N > M, "number of points must be greater "
                               "than the order of the derivative");

            boost::multi_array<Real, 3>  d(boost::extents[M+1][N][N]);
            d[0][0][0] = 1.0;
            Real c1 = 1.0;

            for (Size n=1; n < N; ++n) {
                Real c2 = 1.0;
                for (Size nu=0; nu < n; ++nu) {
                    const Real c3 = x[n] - x[nu];
                    c2*=c3;

                    for (Size m=0; m <= std::min(n, M); ++m) {
                        d[m][n][nu] = (x[n]*d[m][n-1][nu]
                             - ((m > 0)? m*d[m-1][n-1][nu] : 0.0))/c3;
                    }
                }

                for (Size m=0; m <= M; ++m) {
                    d[m][n][n] = c1/c2*( ((m > 0)? m*d[m-1][n-1][n-1] : 0.0) -
                        x[n-1]*d[m][n-1][n-1] );
                }
                c1=c2;
            }


            Array retVal(N);
            for (Size i=0; i < N; ++i) {
                retVal[i] = d[M][N-1][i];
            }
            return retVal;
        }
    }

    NumericalDifferentiation::NumericalDifferentiation(ext::function<Real(Real)> f,
                                                       Size orderOfDerivative,
                                                       Array x_offsets)
    : offsets_(std::move(x_offsets)), w_(calcWeights(offsets_, orderOfDerivative)),
      f_(std::move(f)) {}


    NumericalDifferentiation::NumericalDifferentiation(ext::function<Real(Real)> f,
                                                       Size orderOfDerivative,
                                                       Real stepSize,
                                                       Size steps,
                                                       Scheme scheme)
    : offsets_(calcOffsets(stepSize, steps, scheme)), w_(calcWeights(offsets_, orderOfDerivative)),
      f_(std::move(f)) {}
}
]]></document_content>
  </document>
  <document index="29">
    <source>finitedifferences/operators/secondderivativeop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/secondderivativeop.hpp>

namespace QuantLib {

    SecondDerivativeOp::SecondDerivativeOp(
        Size direction,
        const ext::shared_ptr<FdmMesher>& mesher)
    : TripleBandLinearOp(direction, mesher) {

        const ext::shared_ptr<FdmLinearOpLayout> layout = mesher->layout();
        const FdmLinearOpIterator endIter = layout->end();

        for (FdmLinearOpIterator iter = layout->begin(); iter!=endIter; ++iter) {
            const Size i = iter.index();
            const Real hm = mesher->dminus(iter, direction_);
            const Real hp = mesher->dplus(iter, direction_);

            const Real zetam1 = hm*(hm+hp);
            const Real zeta0  = hm*hp;
            const Real zetap1 = hp*(hm+hp);

            const Size co = iter.coordinates()[direction_];
            if (co == 0 || co == layout->dim()[direction]-1) {
                lower_[i] = diag_[i] = upper_[i] = 0.0;
            }
            else {
                lower_[i] =  2.0/zetam1;
                diag_[i]  = -2.0/zeta0;
                upper_[i] =  2.0/zetap1;
            }
        }
    }
}
]]></document_content>
  </document>
  <document index="30">
    <source>finitedifferences/operators/secondordermixedderivativeop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/secondordermixedderivativeop.hpp>

namespace QuantLib {
    SecondOrderMixedDerivativeOp::SecondOrderMixedDerivativeOp(
        Size d0, Size d1,
        const ext::shared_ptr<FdmMesher>& mesher)
    : NinePointLinearOp(d0, d1, mesher) {

        const ext::shared_ptr<FdmLinearOpLayout> layout = mesher->layout();
        const FdmLinearOpIterator endIter = layout->end();

        for (FdmLinearOpIterator iter = layout->begin(); iter!=endIter; ++iter) {
            const Size i = iter.index();
            const Real hm_d0 = mesher->dminus(iter, d0_);
            const Real hp_d0 = mesher->dplus(iter, d0_);
            const Real hm_d1 = mesher->dminus(iter, d1_);
            const Real hp_d1 = mesher->dplus(iter, d1_);

            const Real zetam1 = hm_d0*(hm_d0+hp_d0);
            const Real zeta0  = hm_d0*hp_d0;
            const Real zetap1 = hp_d0*(hm_d0+hp_d0);
            const Real phim1  = hm_d1*(hm_d1+hp_d1);
            const Real phi0   = hm_d1*hp_d1;
            const Real phip1  = hp_d1*(hm_d1+hp_d1);

            const Size c0 = iter.coordinates()[d0_];
            const Size c1 = iter.coordinates()[d1_];
            if (c0 == 0 && c1 == 0) {
                // lower left corner
                a00_[i] = a01_[i] = a02_[i] = a10_[i] = a20_[i] = 0.0;
                a21_[i] = a12_[i] = -(a11_[i] = a22_[i] = 1.0/(hp_d0*hp_d1));
            }
            else if (c0 == layout->dim()[d0_]-1 && c1 == 0) {
                // upper left corner
                a22_[i] = a21_[i] = a20_[i] = a10_[i] = a00_[i] = 0.0;
                a11_[i] = a02_[i] = -(a01_[i] = a12_[i] = 1.0/(hm_d0*hp_d1));
            }
            else if (c0 == 0 && c1 == layout->dim()[d1_]-1) {
                // lower right corner
                a00_[i] = a01_[i] = a02_[i] = a12_[i] = a22_[i] = 0.0;
                a20_[i] = a11_[i] = -(a10_[i] = a21_[i] = 1.0/(hp_d0*hm_d1));
            }
            else if (c0 == layout->dim()[d0_]-1 && c1 == layout->dim()[d1_]-1) {
                // upper right corner
                a20_[i] = a21_[i] = a22_[i] = a12_[i] = a02_[i] = 0.0;
                a10_[i] = a01_[i] = -(a00_[i] = a11_[i] = 1.0/(hm_d0*hm_d1));
            }
            else if (c0 == 0) {
                // lower side
                a00_[i] = a01_[i] = a02_[i] = 0.0;

                a20_[i] = -(a10_[i] = hp_d1/(hp_d0*phim1));
                a11_[i] = -(a21_[i] = (hp_d1-hm_d1)/(hp_d0*phi0));
                a12_[i] = -(a22_[i] = hm_d1/(hp_d0*phip1));
            }
            else if (c0 == layout->dim()[d0_]-1) {
                // upper side
                a20_[i] = a21_[i] = a22_[i] = 0.0;

                a10_[i] = -(a00_[i] = hp_d1/(hm_d0*phim1));
                a01_[i] = -(a11_[i] = (hp_d1-hm_d1)/(hm_d0*phi0));
                a02_[i] = -(a12_[i] = hm_d1/(hm_d0*phip1));
            }
            else if (c1 == 0) {
                // left side
                a00_[i] = a10_[i] = a20_[i] = 0.0;

                a02_[i] = -(a01_[i] = hp_d0/(zetam1*hp_d1));
                a11_[i] = -(a12_[i] = (hp_d0-hm_d0)/(zeta0*hp_d1));
                a21_[i] = -(a22_[i] = hm_d0/(zetap1*hp_d1));
            }
            else if (c1 == layout->dim()[d1_]-1) {
                // right side
                a22_[i] = a12_[i] = a02_[i] = 0.0;

                a01_[i] = -(a00_[i] = hp_d0/(zetam1*hm_d1));
                a10_[i] = -(a11_[i] = (hp_d0-hm_d0)/(zeta0*hm_d1));
                a20_[i] = -(a21_[i] = hm_d0/(zetap1*hm_d1));
            }
            else {
                a00_[i] =  hp_d0*hp_d1/(zetam1*phim1);
                a10_[i] = -(hp_d0-hm_d0)*hp_d1/(zeta0*phim1);
                a20_[i] = -hm_d0*hp_d1/(zetap1*phim1);
                a01_[i] = -hp_d0*(hp_d1-hm_d1)/(zetam1*phi0);
                a11_[i] = (hp_d0-hm_d0)*(hp_d1-hm_d1)/(zeta0*phi0);
                a21_[i] =  hm_d0*(hp_d1-hm_d1)/(zetap1*phi0);
                a02_[i] = -hp_d0*hm_d1/(zetam1*phip1);
                a12_[i] =  hm_d1*(hp_d0-hm_d0)/(zeta0*phip1);
                a22_[i] =  hm_d0*hm_d1/(zetap1*phip1);
            }
        }
    }
}
]]></document_content>
  </document>
  <document index="31">
    <source>finitedifferences/operators/triplebandlinearop.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen
 Copyright (C) 2014 Johannes GÃ¶ttker-Schnetmann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/tridiagonaloperator.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/operators/triplebandlinearop.hpp>

namespace QuantLib {

    TripleBandLinearOp::TripleBandLinearOp(
        Size direction,
        const ext::shared_ptr<FdmMesher>& mesher)
    : direction_(direction),
      i0_       (new Size[mesher->layout()->size()]),
      i2_       (new Size[mesher->layout()->size()]),
      reverseIndex_ (new Size[mesher->layout()->size()]),
      lower_    (new Real[mesher->layout()->size()]),
      diag_     (new Real[mesher->layout()->size()]),
      upper_    (new Real[mesher->layout()->size()]),
      mesher_(mesher) {

        const ext::shared_ptr<FdmLinearOpLayout> layout = mesher->layout();
        const FdmLinearOpIterator endIter = layout->end();

        std::vector<Size> newDim(layout->dim());
        std::iter_swap(newDim.begin(), newDim.begin()+direction_);
        std::vector<Size> newSpacing = FdmLinearOpLayout(newDim).spacing();
        std::iter_swap(newSpacing.begin(), newSpacing.begin()+direction_);

        for (FdmLinearOpIterator iter = layout->begin(); iter!=endIter; ++iter) {
            const Size i = iter.index();

            i0_[i] = layout->neighbourhood(iter, direction, -1);
            i2_[i] = layout->neighbourhood(iter, direction,  1);

            const std::vector<Size>& coordinates = iter.coordinates();
            const Size newIndex =
                  std::inner_product(coordinates.begin(), coordinates.end(),
                                     newSpacing.begin(), Size(0));
            reverseIndex_[newIndex] = i;
        }
    }

    TripleBandLinearOp::TripleBandLinearOp(const TripleBandLinearOp& m)
    : direction_(m.direction_),
      i0_   (new Size[m.mesher_->layout()->size()]),
      i2_   (new Size[m.mesher_->layout()->size()]),
      reverseIndex_(new Size[m.mesher_->layout()->size()]),
      lower_(new Real[m.mesher_->layout()->size()]),
      diag_ (new Real[m.mesher_->layout()->size()]),
      upper_(new Real[m.mesher_->layout()->size()]),
      mesher_(m.mesher_) {
        const Size len = m.mesher_->layout()->size();
        std::copy(m.i0_.get(), m.i0_.get() + len, i0_.get());
        std::copy(m.i2_.get(), m.i2_.get() + len, i2_.get());
        std::copy(m.reverseIndex_.get(), m.reverseIndex_.get()+len,
                  reverseIndex_.get());
        std::copy(m.lower_.get(), m.lower_.get() + len, lower_.get());
        std::copy(m.diag_.get(),  m.diag_.get() + len,  diag_.get());
        std::copy(m.upper_.get(), m.upper_.get() + len, upper_.get());
    }


    #ifdef QL_USE_DISPOSABLE
    TripleBandLinearOp::TripleBandLinearOp(
        const Disposable<TripleBandLinearOp>& from) {
        swap(const_cast<Disposable<TripleBandLinearOp>&>(from));
    }

    TripleBandLinearOp& TripleBandLinearOp::operator=(
        const Disposable<TripleBandLinearOp>& m) {
        swap(const_cast<Disposable<TripleBandLinearOp>&>(m));
        return *this;
    }
    #endif

    void TripleBandLinearOp::swap(TripleBandLinearOp& m) {
        std::swap(mesher_, m.mesher_);
        std::swap(direction_, m.direction_);

        i0_.swap(m.i0_); i2_.swap(m.i2_);
        reverseIndex_.swap(m.reverseIndex_);
        lower_.swap(m.lower_); diag_.swap(m.diag_); upper_.swap(m.upper_);
    }

    void TripleBandLinearOp::axpyb(const Array& a,
                                   const TripleBandLinearOp& x,
                                   const TripleBandLinearOp& y,
                                   const Array& b) {
        const Size size = mesher_->layout()->size();

        Real *diag(diag_.get());
        Real *lower(lower_.get());
        Real *upper(upper_.get());

        const Real *y_diag (y.diag_.get());
        const Real *y_lower(y.lower_.get());
        const Real *y_upper(y.upper_.get());

        if (a.empty()) {
            if (b.empty()) {
                //#pragma omp parallel for
                for (Size i=0; i < size; ++i) {
                    diag[i]  = y_diag[i];
                    lower[i] = y_lower[i];
                    upper[i] = y_upper[i];
                }
            }
            else {
                Array::const_iterator bptr(b.begin());
                const Size binc = (b.size() > 1) ? 1 : 0;
                //#pragma omp parallel for
                for (Size i=0; i < size; ++i) {
                    diag[i]  = y_diag[i] + bptr[i*binc];
                    lower[i] = y_lower[i];
                    upper[i] = y_upper[i];
                }
            }
        }
        else if (b.empty()) {
            Array::const_iterator aptr(a.begin());
            const Size ainc = (a.size() > 1) ? 1 : 0;

            const Real *x_diag (x.diag_.get());
            const Real *x_lower(x.lower_.get());
            const Real *x_upper(x.upper_.get());

            //#pragma omp parallel for
            for (Size i=0; i < size; ++i) {
                const Real s = aptr[i*ainc];
                diag[i]  = y_diag[i]  + s*x_diag[i];
                lower[i] = y_lower[i] + s*x_lower[i];
                upper[i] = y_upper[i] + s*x_upper[i];
            }
        }
        else {
            Array::const_iterator bptr(b.begin());
            const Size binc = (b.size() > 1) ? 1 : 0;

            Array::const_iterator aptr(a.begin());
            const Size ainc = (a.size() > 1) ? 1 : 0;

            const Real *x_diag (x.diag_.get());
            const Real *x_lower(x.lower_.get());
            const Real *x_upper(x.upper_.get());

            //#pragma omp parallel for
            for (Size i=0; i < size; ++i) {
                const Real s = aptr[i*ainc];
                diag[i]  = y_diag[i]  + s*x_diag[i] + bptr[i*binc];
                lower[i] = y_lower[i] + s*x_lower[i];
                upper[i] = y_upper[i] + s*x_upper[i];
            }
        }
    }

    Disposable<TripleBandLinearOp>
    TripleBandLinearOp::add(const TripleBandLinearOp& m) const {

        TripleBandLinearOp retVal(direction_, mesher_);
        const Size size = mesher_->layout()->size();
        //#pragma omp parallel for
        for (Size i=0; i < size; ++i) {
            retVal.lower_[i]= lower_[i] + m.lower_[i];
            retVal.diag_[i] = diag_[i]  + m.diag_[i];
            retVal.upper_[i]= upper_[i] + m.upper_[i];
        }

        return retVal;
    }


    Disposable<TripleBandLinearOp> TripleBandLinearOp::mult(const Array& u) const {

        TripleBandLinearOp retVal(direction_, mesher_);

        const Size size = mesher_->layout()->size();
        //#pragma omp parallel for
        for (Size i=0; i < size; ++i) {
            const Real s = u[i];
            retVal.lower_[i]= lower_[i]*s;
            retVal.diag_[i] = diag_[i]*s;
            retVal.upper_[i]= upper_[i]*s;
        }

        return retVal;
    }

    Disposable<TripleBandLinearOp> TripleBandLinearOp::multR(const Array& u) const {
        const ext::shared_ptr<FdmLinearOpLayout> layout = mesher_->layout();
        const Size size = layout->size();
        QL_REQUIRE(u.size() == size, "inconsistent size of rhs");
        TripleBandLinearOp retVal(direction_, mesher_);

        #pragma omp parallel for
        for (long i=0; i < (long)size; ++i) {
            const Real sm1 = i > 0? u[i-1] : 1.0;
            const Real s0 = u[i];
            const Real sp1 = i < (long)size-1? u[i+1] : 1.0;
            retVal.lower_[i]= lower_[i]*sm1;
            retVal.diag_[i] = diag_[i]*s0;
            retVal.upper_[i]= upper_[i]*sp1;
        }

        return retVal;
    }

    Disposable<TripleBandLinearOp> TripleBandLinearOp::add(const Array& u) const {

        TripleBandLinearOp retVal(direction_, mesher_);

        const Size size = mesher_->layout()->size();
        //#pragma omp parallel for
        for (Size i=0; i < size; ++i) {
            retVal.lower_[i]= lower_[i];
            retVal.upper_[i]= upper_[i];
            retVal.diag_[i] = diag_[i]+u[i];
        }

        return retVal;
    }

    Disposable<Array> TripleBandLinearOp::apply(const Array& r) const {
        const ext::shared_ptr<FdmLinearOpLayout> index = mesher_->layout();

        QL_REQUIRE(r.size() == index->size(), "inconsistent length of r");

        const Real* lptr = lower_.get();
        const Real* dptr = diag_.get();
        const Real* uptr = upper_.get();
        const Size* i0ptr = i0_.get();
        const Size* i2ptr = i2_.get();

        array_type retVal(r.size());
        //#pragma omp parallel for
        for (Size i=0; i < index->size(); ++i) {
            retVal[i] = r[i0ptr[i]]*lptr[i]+r[i]*dptr[i]+r[i2ptr[i]]*uptr[i];
        }

        return retVal;
    }

    Disposable<SparseMatrix> TripleBandLinearOp::toMatrix() const {
        const ext::shared_ptr<FdmLinearOpLayout> index = mesher_->layout();
        const Size n = index->size();

        SparseMatrix retVal(n, n, 3*n);
        for (Size i=0; i < n; ++i) {
            retVal(i, i0_[i]) += lower_[i];
            retVal(i, i     ) += diag_[i];
            retVal(i, i2_[i]) += upper_[i];
        }

        return retVal;
    }


    Disposable<Array>
    TripleBandLinearOp::solve_splitting(const Array& r, Real a, Real b) const {
        const ext::shared_ptr<FdmLinearOpLayout> layout = mesher_->layout();
        QL_REQUIRE(r.size() == layout->size(), "inconsistent size of rhs");

#ifdef QL_EXTRA_SAFETY_CHECKS
        for (FdmLinearOpIterator iter = layout->begin();
             iter!=layout->end(); ++iter) {
            const std::vector<Size>& coordinates = iter.coordinates();
            QL_REQUIRE(   coordinates[direction_] != 0
                       || lower_[iter.index()] == 0,"removing non zero entry!");
            QL_REQUIRE(   coordinates[direction_] != layout->dim()[direction_]-1
                       || upper_[iter.index()] == 0,"removing non zero entry!");
        }
#endif

        Array retVal(r.size()), tmp(r.size());

        const Real* lptr = lower_.get();
        const Real* dptr = diag_.get();
        const Real* uptr = upper_.get();

        // Thomson algorithm to solve a tridiagonal system.
        // Example code taken from Tridiagonalopertor and
        // changed to fit for the triple band operator.
        Size rim1 = reverseIndex_[0];
        Real bet=1.0/(a*dptr[rim1]+b);
        QL_REQUIRE(bet != 0.0, "division by zero");
        retVal[reverseIndex_[0]] = r[rim1]*bet;

        for (Size j=1; j<=layout->size()-1; j++){
            const Size ri = reverseIndex_[j];
            tmp[j] = a*uptr[rim1]*bet;

            bet=b+a*(dptr[ri]-tmp[j]*lptr[ri]);
            QL_ENSURE(bet != 0.0, "division by zero");
            bet=1.0/bet;

            retVal[ri] = (r[ri]-a*lptr[ri]*retVal[rim1])*bet;
            rim1 = ri;
        }
        // cannot be j>=0 with Size j
        for (Size j=layout->size()-2; j>0; --j)
            retVal[reverseIndex_[j]] -= tmp[j+1]*retVal[reverseIndex_[j+1]];
        retVal[reverseIndex_[0]] -= tmp[1]*retVal[reverseIndex_[1]];

        return retVal;
    }
}
]]></document_content>
  </document>
  <document index="32">
    <source>finitedifferences/schemes/craigsneydscheme.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/schemes/craigsneydscheme.hpp>
#include <utility>

namespace QuantLib {

    CraigSneydScheme::CraigSneydScheme(Real theta,
                                       Real mu,
                                       ext::shared_ptr<FdmLinearOpComposite> map,
                                       const bc_set& bcSet)
    : dt_(Null<Real>()), theta_(theta), mu_(mu), map_(std::move(map)), bcSet_(bcSet) {}

    void CraigSneydScheme::step(array_type& a, Time t) {
        QL_REQUIRE(t-dt_ > -1e-8, "a step towards negative time given");

        map_->setTime(std::max(0.0, t-dt_), t);
        bcSet_.setTime(std::max(0.0, t-dt_));

        bcSet_.applyBeforeApplying(*map_);
        Array y = a + dt_*map_->apply(a);
        bcSet_.applyAfterApplying(y);

        Array y0 = y;

        for (Size i=0; i < map_->size(); ++i) {
            Array rhs = y - theta_*dt_*map_->apply_direction(i, a);
            y = map_->solve_splitting(i, rhs, -theta_*dt_);
        }

        bcSet_.applyBeforeApplying(*map_);
        Array yt = y0 + mu_*dt_*map_->apply_mixed(y-a);
        bcSet_.applyAfterApplying(yt);

        for (Size i=0; i < map_->size(); ++i) {
            Array rhs = yt - theta_*dt_*map_->apply_direction(i, a);
            yt = map_->solve_splitting(i, rhs, -theta_*dt_);
        }
        bcSet_.applyAfterSolving(yt);

        a = yt;
    }

    void CraigSneydScheme::setStep(Time dt) {
        dt_=dt;
    }
}
]]></document_content>
  </document>
  <document index="33">
    <source>finitedifferences/schemes/cranknicolsonscheme.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2019 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/schemes/expliciteulerscheme.hpp>
#include <ql/methods/finitedifferences/schemes/cranknicolsonscheme.hpp>

namespace QuantLib {
    CrankNicolsonScheme::CrankNicolsonScheme(
        Real theta,
        const ext::shared_ptr<FdmLinearOpComposite> & map,
        const bc_set& bcSet,
        Real relTol,
        ImplicitEulerScheme::SolverType solverType)
    : dt_(Null<Real>()),
      theta_(theta),
      explicit_(ext::make_shared<ExplicitEulerScheme>(map, bcSet)),
      implicit_(ext::make_shared<ImplicitEulerScheme>(
          map, bcSet, relTol, solverType)) {
    }

    void CrankNicolsonScheme::step(array_type& a, Time t) {
        QL_REQUIRE(t-dt_ > -1e-8, "a step towards negative time given");

        if (theta_ != 1.0)
            explicit_->step(a, t, 1.0-theta_);

        if (theta_ != 0.0)
            implicit_->step(a, t, theta_);
    }

    void CrankNicolsonScheme::setStep(Time dt) {
        dt_ = dt;
        explicit_->setStep(dt_);
        implicit_->setStep(dt_);
    }

    Size CrankNicolsonScheme::numberOfIterations() const {
        return implicit_->numberOfIterations();
    }
}
]]></document_content>
  </document>
  <document index="34">
    <source>finitedifferences/schemes/douglasscheme.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/schemes/douglasscheme.hpp>
#include <utility>

namespace QuantLib {
    DouglasScheme::DouglasScheme(Real theta,
                                 ext::shared_ptr<FdmLinearOpComposite> map,
                                 const bc_set& bcSet)
    : dt_(Null<Real>()), theta_(theta), map_(std::move(map)), bcSet_(bcSet) {}

    void DouglasScheme::step(array_type& a, Time t) {
        QL_REQUIRE(t-dt_ > -1e-8, "a step towards negative time given");
        map_->setTime(std::max(0.0, t-dt_), t);
        bcSet_.setTime(std::max(0.0, t-dt_));

        bcSet_.applyBeforeApplying(*map_);
        Array y = a + dt_*map_->apply(a);
        bcSet_.applyAfterApplying(y);

        for (Size i=0; i < map_->size(); ++i) {
            Array rhs = y - theta_*dt_*map_->apply_direction(i, a);
            y = map_->solve_splitting(i, rhs, -theta_*dt_);
        }
        bcSet_.applyAfterSolving(y);

        a = y;
    }

    void DouglasScheme::setStep(Time dt) {
        dt_=dt;
    }
}
]]></document_content>
  </document>
  <document index="35">
    <source>finitedifferences/schemes/expliciteulerscheme.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andreas Gaida
 Copyright (C) 2009 Ralph Schreyer
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/methods/finitedifferences/schemes/expliciteulerscheme.hpp>
#include <utility>

namespace QuantLib {
    ExplicitEulerScheme::ExplicitEulerScheme(ext::shared_ptr<FdmLinearOpComposite> map,
                                             const bc_set& bcSet)
    : dt_(Null<Real>()), map_(std::move(map)), bcSet_(bcSet) {}

    void ExplicitEulerScheme::step(array_type& a, Time t) {
        step(a, t, 1.0);
    }

    void ExplicitEulerScheme::step(array_type& a, Time t, Real theta) {
        QL_REQUIRE(t-dt_ > -1e-8, "a step towards negative time given");
        map_->setTime(std::max(0.0, t - dt_), t);
        bcSet_.setTime(std::max(0.0, t-dt_));

        bcSet_.applyBeforeApplying(*map_);
        a += (theta*dt_) * map_->apply(a);
        bcSet_.applyAfterApplying(a);
    }

    void ExplicitEulerScheme::setStep(Time dt) {
        dt_ = dt;
    }
}
]]></document_content>
  </document>
  <document index="36">
    <source>finitedifferences/schemes/hundsdorferscheme.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/schemes/hundsdorferscheme.hpp>
#include <utility>

namespace QuantLib {

    HundsdorferScheme::HundsdorferScheme(Real theta,
                                         Real mu,
                                         ext::shared_ptr<FdmLinearOpComposite> map,
                                         const bc_set& bcSet)
    : dt_(Null<Real>()), theta_(theta), mu_(mu), map_(std::move(map)), bcSet_(bcSet) {}

    void HundsdorferScheme::step(array_type& a, Time t) {
        QL_REQUIRE(t-dt_ > -1e-8, "a step towards negative time given");

        map_->setTime(std::max(0.0, t-dt_), t);
        bcSet_.setTime(std::max(0.0, t-dt_));

        bcSet_.applyBeforeApplying(*map_);
        Array y = a + dt_*map_->apply(a);
        bcSet_.applyAfterApplying(y);

        Array y0 = y;

        for (Size i=0; i < map_->size(); ++i) {
            Array rhs = y - theta_*dt_*map_->apply_direction(i, a);
            y = map_->solve_splitting(i, rhs, -theta_*dt_);
        }

        bcSet_.applyBeforeApplying(*map_);
        Array yt = y0 + mu_*dt_*map_->apply(y-a);
        bcSet_.applyAfterApplying(yt);

        for (Size i=0; i < map_->size(); ++i) {
            Array rhs = yt - theta_*dt_*map_->apply_direction(i, y);
            yt = map_->solve_splitting(i, rhs, -theta_*dt_);
        }
        bcSet_.applyAfterSolving(yt);

        a = yt;
    }

    void HundsdorferScheme::setStep(Time dt) {
        dt_=dt;
    }
}
]]></document_content>
  </document>
  <document index="37">
    <source>finitedifferences/schemes/impliciteulerscheme.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andreas Gaida
 Copyright (C) 2009 Ralph Schreyer
 Copyright (C) 2009, 2017 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/functional.hpp>
#include <ql/math/matrixutilities/bicgstab.hpp>
#include <ql/math/matrixutilities/gmres.hpp>
#include <ql/methods/finitedifferences/schemes/impliciteulerscheme.hpp>
#include <utility>

namespace QuantLib {

    ImplicitEulerScheme::ImplicitEulerScheme(ext::shared_ptr<FdmLinearOpComposite> map,
                                             const bc_set& bcSet,
                                             Real relTol,
                                             SolverType solverType)
    : dt_(Null<Real>()), iterations_(ext::make_shared<Size>(0U)), relTol_(relTol),
      map_(std::move(map)), bcSet_(bcSet), solverType_(solverType) {}

    Disposable<Array> ImplicitEulerScheme::apply(const Array& r, Real theta) const {
        return r - (theta*dt_)*map_->apply(r);
    }

    void ImplicitEulerScheme::step(array_type& a, Time t) {
        step(a, t, 1.0);
    }

    void ImplicitEulerScheme::step(array_type& a, Time t, Real theta) {
        QL_REQUIRE(t-dt_ > -1e-8, "a step towards negative time given");
        map_->setTime(std::max(0.0, t-dt_), t);
        bcSet_.setTime(std::max(0.0, t-dt_));

        bcSet_.applyBeforeSolving(*map_, a);

        if (map_->size() == 1) {
            a = map_->solve_splitting(0, a, -theta*dt_);
        }
        else {
            auto preconditioner = [&](const Array& _a){ return map_->preconditioner(_a, -theta*dt_); };
            auto applyF = [&](const Array& _a){ return apply(_a, theta); };

            if (solverType_ == BiCGstab) {
                const BiCGStabResult result =
                    QuantLib::BiCGstab(applyF, std::max(Size(10), a.size()),
                        relTol_, preconditioner).solve(a, a);

                (*iterations_) += result.iterations;
                a = result.x;
            }
            else if (solverType_ == GMRES) {
                const GMRESResult result =
                    QuantLib::GMRES(applyF, std::max(Size(10), a.size() / 10U), relTol_,
                                    preconditioner)
                        .solve(a, a);

                (*iterations_) += result.errors.size();
                a = result.x;
            }
            else
                QL_FAIL("unknown/illegal solver type");
        }
        bcSet_.applyAfterSolving(a);
    }

    void ImplicitEulerScheme::setStep(Time dt) {
        dt_=dt;
    }

    Size ImplicitEulerScheme::numberOfIterations() const {
        return *iterations_;
    }
}
]]></document_content>
  </document>
  <document index="38">
    <source>finitedifferences/schemes/methodoflinesscheme.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/math/ode/adaptiverungekutta.hpp>
#include <ql/methods/finitedifferences/schemes/methodoflinesscheme.hpp>
#include <utility>

namespace QuantLib {

    MethodOfLinesScheme::MethodOfLinesScheme(const Real eps,
                                             const Real relInitStepSize,
                                             ext::shared_ptr<FdmLinearOpComposite> map,
                                             const bc_set& bcSet)
    : dt_(Null<Real>()), eps_(eps), relInitStepSize_(relInitStepSize), map_(std::move(map)),
      bcSet_(bcSet) {}


    Disposable<std::vector<Real> >
    MethodOfLinesScheme::apply(Time t, const std::vector<Real>& u) const {
        map_->setTime(t, t + 0.0001);
        bcSet_.applyBeforeApplying(*map_);

        const Array dxdt = -map_->apply(Array(u.begin(), u.end()));

        std::vector<Real> retVal(dxdt.begin(), dxdt.end());
        return retVal;
    }

    void MethodOfLinesScheme::step(array_type& a, Time t) {
        QL_REQUIRE(t-dt_ > -1e-8, "a step towards negative time given");

        const std::vector<Real> v =
           AdaptiveRungeKutta<Real>(eps_, relInitStepSize_*dt_)(
               [&](Time _t, const std::vector<Real>& _u){ return apply(_t, _u); },
               std::vector<Real>(a.begin(), a.end()),
               t, std::max(0.0, t-dt_));

        Array y(v.begin(), v.end());

        bcSet_.applyAfterSolving(y);

        a = y;
    }

    void MethodOfLinesScheme::setStep(Time dt) {
        dt_ = dt;
    }
}
]]></document_content>
  </document>
  <document index="39">
    <source>finitedifferences/schemes/modifiedcraigsneydscheme.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/schemes/modifiedcraigsneydscheme.hpp>
#include <utility>

namespace QuantLib {

    ModifiedCraigSneydScheme::ModifiedCraigSneydScheme(Real theta,
                                                       Real mu,
                                                       ext::shared_ptr<FdmLinearOpComposite> map,
                                                       const bc_set& bcSet)
    : dt_(Null<Real>()), theta_(theta), mu_(mu), map_(std::move(map)), bcSet_(bcSet) {}

    void ModifiedCraigSneydScheme::step(array_type& a, Time t) {
        QL_REQUIRE(t-dt_ > -1e-8, "a step towards negative time given");
        map_->setTime(std::max(0.0, t-dt_), t);
        bcSet_.setTime(std::max(0.0, t-dt_));

        bcSet_.applyBeforeApplying(*map_);
        Array y = a + dt_*map_->apply(a);
        bcSet_.applyAfterApplying(y);

        Array y0 = y;

        for (Size i=0; i < map_->size(); ++i) {
            Array rhs = y - theta_*dt_*map_->apply_direction(i, a);
            y = map_->solve_splitting(i, rhs, -theta_*dt_);
        }

        bcSet_.applyBeforeApplying(*map_);
        Array yt =  y0 + mu_*dt_*map_->apply_mixed(y-a)
                  +(0.5-mu_)*dt_*map_->apply(y-a);;
        bcSet_.applyAfterApplying(yt);

        for (Size i=0; i < map_->size(); ++i) {
            Array rhs = yt - theta_*dt_*map_->apply_direction(i, a);
            yt = map_->solve_splitting(i, rhs, -theta_*dt_);
        }
        bcSet_.applyAfterSolving(yt);

        a = yt;
    }

    void ModifiedCraigSneydScheme::setStep(Time dt) {
        dt_=dt;
    }
}
]]></document_content>
  </document>
  <document index="40">
    <source>finitedifferences/solvers/fdm1dimsolver.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/interpolations/cubicinterpolation.hpp>
#include <ql/methods/finitedifferences/finitedifferencemodel.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/solvers/fdm1dimsolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsnapshotcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <utility>

namespace QuantLib {

    Fdm1DimSolver::Fdm1DimSolver(const FdmSolverDesc& solverDesc,
                                 const FdmSchemeDesc& schemeDesc,
                                 ext::shared_ptr<FdmLinearOpComposite> op)
    : solverDesc_(solverDesc), schemeDesc_(schemeDesc), op_(std::move(op)),
      thetaCondition_(ext::make_shared<FdmSnapshotCondition>(
          0.99 * std::min(1.0 / 365.0,
                          solverDesc.condition->stoppingTimes().empty() ?
                              solverDesc.maturity :
                              solverDesc.condition->stoppingTimes().front()))),
      conditions_(FdmStepConditionComposite::joinConditions(thetaCondition_, solverDesc.condition)),
      x_(solverDesc.mesher->layout()->size()), initialValues_(solverDesc.mesher->layout()->size()),
      resultValues_(solverDesc.mesher->layout()->size()) {

        const ext::shared_ptr<FdmMesher> mesher = solverDesc.mesher;
        const ext::shared_ptr<FdmLinearOpLayout> layout = mesher->layout();

        const FdmLinearOpIterator endIter = layout->end();
        for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
             ++iter) {
            initialValues_[iter.index()]
                 = solverDesc_.calculator->avgInnerValue(iter,
                                                         solverDesc.maturity);
            x_[iter.index()] = mesher->location(iter, 0);
        }
    }


    void Fdm1DimSolver::performCalculations() const {
        Array rhs(initialValues_.size());
        std::copy(initialValues_.begin(), initialValues_.end(), rhs.begin());

        FdmBackwardSolver(op_, solverDesc_.bcSet, conditions_, schemeDesc_)
            .rollback(rhs, solverDesc_.maturity, 0.0,
                      solverDesc_.timeSteps, solverDesc_.dampingSteps);

        std::copy(rhs.begin(), rhs.end(), resultValues_.begin());
        interpolation_ = ext::make_shared<MonotonicCubicNaturalSpline>(x_.begin(), x_.end(),
                                        resultValues_.begin());
    }

    Real Fdm1DimSolver::interpolateAt(Real x) const {
        calculate();
        return (*interpolation_)(x);
    }

    Real Fdm1DimSolver::thetaAt(Real x) const {
        if (conditions_->stoppingTimes().front() == 0.0)
            return Null<Real>();

        calculate();
        Array thetaValues(resultValues_.size());

        const Array& rhs = thetaCondition_->getValues();
        std::copy(rhs.begin(), rhs.end(), thetaValues.begin());

        Real temp = MonotonicCubicNaturalSpline(
            x_.begin(), x_.end(), thetaValues.begin())(x);
        return ( temp - interpolateAt(x) ) / thetaCondition_->getTime();
    }


    Real Fdm1DimSolver::derivativeX(Real x) const {
        calculate();
        return interpolation_->derivative(x);
    }

    Real Fdm1DimSolver::derivativeXX(Real x) const {
        calculate();
        return interpolation_->secondDerivative(x);
    }
}
]]></document_content>
  </document>
  <document index="41">
    <source>finitedifferences/solvers/fdm2dblackscholessolver.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/operators/fdm2dblackscholesop.hpp>
#include <ql/methods/finitedifferences/solvers/fdm2dblackscholessolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdm2dimsolver.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    Fdm2dBlackScholesSolver::Fdm2dBlackScholesSolver(Handle<GeneralizedBlackScholesProcess> p1,
                                                     Handle<GeneralizedBlackScholesProcess> p2,
                                                     const Real correlation,
                                                     FdmSolverDesc solverDesc,
                                                     const FdmSchemeDesc& schemeDesc,
                                                     bool localVol,
                                                     Real illegalLocalVolOverwrite)
    : p1_(std::move(p1)), p2_(std::move(p2)), correlation_(correlation),
      solverDesc_(std::move(solverDesc)), schemeDesc_(schemeDesc), localVol_(localVol),
      illegalLocalVolOverwrite_(illegalLocalVolOverwrite) {

        registerWith(p1_);
        registerWith(p2_);
    }


    void Fdm2dBlackScholesSolver::performCalculations() const {
        
        ext::shared_ptr<Fdm2dBlackScholesOp> op(
			ext::make_shared<Fdm2dBlackScholesOp>(solverDesc_.mesher,
                                        p1_.currentLink(), 
                                        p2_.currentLink(), 
                                        correlation_,
                                        solverDesc_.maturity,
                                        localVol_,
                                        illegalLocalVolOverwrite_));

        solver_ = ext::make_shared<Fdm2DimSolver>(solverDesc_, schemeDesc_, op);
    }

    Real Fdm2dBlackScholesSolver::valueAt(Real u, Real v) const {
        calculate();
        const Real x = std::log(u);
        const Real y = std::log(v);

        return solver_->interpolateAt(x, y);
    }
    
    Real Fdm2dBlackScholesSolver::thetaAt(Real u, Real v) const {
        calculate();
        const Real x = std::log(u);
        const Real y = std::log(v);
        return solver_->thetaAt(x, y);
    }


    Real Fdm2dBlackScholesSolver::deltaXat(Real u, Real v) const {
        calculate();

        const Real x = std::log(u);
        const Real y = std::log(v);

        return solver_->derivativeX(x, y)/u;
    }

    Real Fdm2dBlackScholesSolver::deltaYat(Real u, Real v) const {
        calculate();

        const Real x = std::log(u);
        const Real y = std::log(v);

        return solver_->derivativeY(x, y)/v;
    }

    Real Fdm2dBlackScholesSolver::gammaXat(Real u, Real v) const {
        calculate();
        
        const Real x = std::log(u);
        const Real y = std::log(v);
        
        return (solver_->derivativeXX(x, y)
                -solver_->derivativeX(x, y))/(u*u);
    }

    Real Fdm2dBlackScholesSolver::gammaYat(Real u, Real v) const {
        calculate();
        
        const Real x = std::log(u);
        const Real y = std::log(v);
        
        return (solver_->derivativeYY(x, y)
                -solver_->derivativeY(x, y))/(v*v);
    }

    Real Fdm2dBlackScholesSolver::gammaXYat(Real u, Real v) const {
        calculate();

        const Real x = std::log(u);
        const Real y = std::log(v);

        return solver_->derivativeXY(x, y)/(u*v);
    }
}
]]></document_content>
  </document>
  <document index="42">
    <source>finitedifferences/solvers/fdm2dimsolver.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/interpolations/bicubicsplineinterpolation.hpp>
#include <ql/methods/finitedifferences/finitedifferencemodel.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/solvers/fdm2dimsolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsnapshotcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <utility>

namespace QuantLib {

    Fdm2DimSolver::Fdm2DimSolver(const FdmSolverDesc& solverDesc,
                                 const FdmSchemeDesc& schemeDesc,
                                 ext::shared_ptr<FdmLinearOpComposite> op)
    : solverDesc_(solverDesc), schemeDesc_(schemeDesc), op_(std::move(op)),
      thetaCondition_(ext::make_shared<FdmSnapshotCondition>(
          0.99 * std::min(1.0 / 365.0,
                          solverDesc.condition->stoppingTimes().empty() ?
                              solverDesc.maturity :
                              solverDesc.condition->stoppingTimes().front()))),
      conditions_(FdmStepConditionComposite::joinConditions(thetaCondition_, solverDesc.condition)),
      initialValues_(solverDesc.mesher->layout()->size()),
      resultValues_(solverDesc.mesher->layout()->dim()[1], solverDesc.mesher->layout()->dim()[0]) {

        const ext::shared_ptr<FdmMesher> mesher = solverDesc.mesher;
        const ext::shared_ptr<FdmLinearOpLayout> layout = mesher->layout();

        x_.reserve(layout->dim()[0]);
        y_.reserve(layout->dim()[1]);

        const FdmLinearOpIterator endIter = layout->end();
        for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
             ++iter) {
            initialValues_[iter.index()]
                 = solverDesc_.calculator->avgInnerValue(iter,
                                                         solverDesc.maturity);

            if (iter.coordinates()[1] == 0U) {
                x_.push_back(mesher->location(iter, 0));
            }
            if (iter.coordinates()[0] == 0U) {
                y_.push_back(mesher->location(iter, 1));
            }
        }
    }


    void Fdm2DimSolver::performCalculations() const {
        Array rhs(initialValues_.size());
        std::copy(initialValues_.begin(), initialValues_.end(), rhs.begin());

        FdmBackwardSolver(op_, solverDesc_.bcSet, conditions_, schemeDesc_)
            .rollback(rhs, solverDesc_.maturity, 0.0,
                      solverDesc_.timeSteps, solverDesc_.dampingSteps);

        std::copy(rhs.begin(), rhs.end(), resultValues_.begin());
        interpolation_ = ext::make_shared<BicubicSpline>(x_.begin(), x_.end(),
                              y_.begin(), y_.end(),
                              resultValues_);
    }

    Real Fdm2DimSolver::interpolateAt(Real x, Real y) const {
        calculate();
        return (*interpolation_)(x, y);
    }

    Real Fdm2DimSolver::thetaAt(Real x, Real y) const {
        if (conditions_->stoppingTimes().front() == 0.0)
            return Null<Real>();

        calculate();
        Matrix thetaValues(resultValues_.rows(), resultValues_.columns());

        const Array& rhs = thetaCondition_->getValues();
        std::copy(rhs.begin(), rhs.end(), thetaValues.begin());

        return (BicubicSpline(x_.begin(), x_.end(), y_.begin(), y_.end(),
                              thetaValues)(x, y) - interpolateAt(x, y))
              / thetaCondition_->getTime();
    }


    Real Fdm2DimSolver::derivativeX(Real x, Real y) const {
        calculate();
        return interpolation_->derivativeX(x, y);
    }

    Real Fdm2DimSolver::derivativeY(Real x, Real y) const {
        calculate();
        return interpolation_->derivativeY(x, y);
    }

    Real Fdm2DimSolver::derivativeXX(Real x, Real y) const {
        calculate();
        return interpolation_->secondDerivativeX(x, y);
    }

    Real Fdm2DimSolver::derivativeYY(Real x, Real y) const {
        calculate();
        return interpolation_->secondDerivativeY(x, y);
    }

    Real Fdm2DimSolver::derivativeXY(Real x, Real y) const {
        calculate();
        return interpolation_->derivativeXY(x, y);
    }

}
]]></document_content>
  </document>
  <document index="43">
    <source>finitedifferences/solvers/fdm3dimsolver.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/interpolations/bicubicsplineinterpolation.hpp>
#include <ql/math/interpolations/cubicinterpolation.hpp>
#include <ql/methods/finitedifferences/finitedifferencemodel.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/solvers/fdm3dimsolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsnapshotcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <utility>

namespace QuantLib {

    Fdm3DimSolver::Fdm3DimSolver(const FdmSolverDesc& solverDesc,
                                 const FdmSchemeDesc& schemeDesc,
                                 ext::shared_ptr<FdmLinearOpComposite> op)
    : solverDesc_(solverDesc), schemeDesc_(schemeDesc), op_(std::move(op)),
      thetaCondition_(ext::make_shared<FdmSnapshotCondition>(
          0.99 * std::min(1.0 / 365.0,
                          solverDesc.condition->stoppingTimes().empty() ?
                              solverDesc.maturity :
                              solverDesc.condition->stoppingTimes().front()))),
      conditions_(FdmStepConditionComposite::joinConditions(thetaCondition_, solverDesc.condition)),
      initialValues_(solverDesc.mesher->layout()->size()),
      resultValues_(
          solverDesc.mesher->layout()->dim()[2],
          Matrix(solverDesc.mesher->layout()->dim()[1], solverDesc.mesher->layout()->dim()[0])),
      interpolation_(solverDesc.mesher->layout()->dim()[2]) {

        const ext::shared_ptr<FdmMesher> mesher = solverDesc.mesher;
        const ext::shared_ptr<FdmLinearOpLayout> layout = mesher->layout();

        x_.reserve(layout->dim()[0]);
        y_.reserve(layout->dim()[1]);
        z_.reserve(layout->dim()[2]);

        const FdmLinearOpIterator endIter = layout->end();
        for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
             ++iter) {
            initialValues_[iter.index()]
               = solverDesc.calculator->avgInnerValue(iter,
                                                      solverDesc.maturity);


            if ((iter.coordinates()[1] == 0U) && (iter.coordinates()[2] == 0U)) {
                x_.push_back(mesher->location(iter, 0));
            }
            if ((iter.coordinates()[0] == 0U) && (iter.coordinates()[2] == 0U)) {
                y_.push_back(mesher->location(iter, 1));
            }
            if ((iter.coordinates()[0] == 0U) && (iter.coordinates()[1] == 0U)) {
                z_.push_back(mesher->location(iter, 2));
            }
        }
    }

    void Fdm3DimSolver::performCalculations() const {
        Array rhs(initialValues_.size());
        std::copy(initialValues_.begin(), initialValues_.end(), rhs.begin());

        FdmBackwardSolver(op_, solverDesc_.bcSet, conditions_, schemeDesc_)
             .rollback(rhs, solverDesc_.maturity, 0.0,
                       solverDesc_.timeSteps, solverDesc_.dampingSteps);

        for (Size i=0; i < z_.size(); ++i) {
            std::copy(rhs.begin()+i    *y_.size()*x_.size(),
                      rhs.begin()+(i+1)*y_.size()*x_.size(),
                      resultValues_[i].begin());

            interpolation_[i] = ext::make_shared<BicubicSpline>(x_.begin(), x_.end(),
                                  y_.begin(), y_.end(),
                                  resultValues_[i]);
        }
    }

    Real Fdm3DimSolver::interpolateAt(Real x, Real y, Rate z) const {
        calculate();

        Array zArray(z_.size());
        for (Size i=0; i < z_.size(); ++i) {
            zArray[i] = (*interpolation_[i])(x, y);
        }
        return MonotonicCubicNaturalSpline(z_.begin(), z_.end(),
                                           zArray.begin())(z);
    }

    Real Fdm3DimSolver::thetaAt(Real x, Real y, Rate z) const {
        if (conditions_->stoppingTimes().front() == 0.0)
            return Null<Real>();

        calculate();

        const Array& rhs = thetaCondition_->getValues();
        std::vector<Matrix> thetaValues(z_.size(), Matrix(y_.size(),x_.size()));
        for (Size i=0; i < z_.size(); ++i) {
            std::copy(rhs.begin()+i    *y_.size()*x_.size(),
                      rhs.begin()+(i+1)*y_.size()*x_.size(),
                      thetaValues[i].begin());
        }

        Array zArray(z_.size());
        for (Size i=0; i < z_.size(); ++i) {
            zArray[i] = BicubicSpline(x_.begin(),x_.end(),
                                      y_.begin(),y_.end(), thetaValues[i])(x,y);
        }

        return (MonotonicCubicNaturalSpline(z_.begin(), z_.end(),
                                            zArray.begin())(z)
                - interpolateAt(x, y, z)) / thetaCondition_->getTime();
    }
}
]]></document_content>
  </document>
  <document index="44">
    <source>finitedifferences/solvers/fdmbackwardsolver.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Andreas Gaida
 Copyright (C) 2009 Ralph Schreyer
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmbackwardsolver.cpp
*/

#include <ql/mathconstants.hpp>
#include <ql/methods/finitedifferences/finitedifferencemodel.hpp>
#include <ql/methods/finitedifferences/schemes/craigsneydscheme.hpp>
#include <ql/methods/finitedifferences/schemes/cranknicolsonscheme.hpp>
#include <ql/methods/finitedifferences/schemes/douglasscheme.hpp>
#include <ql/methods/finitedifferences/schemes/expliciteulerscheme.hpp>
#include <ql/methods/finitedifferences/schemes/hundsdorferscheme.hpp>
#include <ql/methods/finitedifferences/schemes/impliciteulerscheme.hpp>
#include <ql/methods/finitedifferences/schemes/methodoflinesscheme.hpp>
#include <ql/methods/finitedifferences/schemes/modifiedcraigsneydscheme.hpp>
#include <ql/methods/finitedifferences/schemes/trbdf2scheme.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbackwardsolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <utility>


namespace QuantLib {
    
    FdmSchemeDesc::FdmSchemeDesc(FdmSchemeType aType, Real aTheta, Real aMu)
    : type(aType), theta(aTheta), mu(aMu) { }

    FdmSchemeDesc FdmSchemeDesc::Douglas() { return {FdmSchemeDesc::DouglasType, 0.5, 0.0}; }

    FdmSchemeDesc FdmSchemeDesc::CrankNicolson() {
        return {FdmSchemeDesc::CrankNicolsonType, 0.5, 0.0};
    }

    FdmSchemeDesc FdmSchemeDesc::CraigSneyd() { return {FdmSchemeDesc::CraigSneydType, 0.5, 0.5}; }

    FdmSchemeDesc FdmSchemeDesc::ModifiedCraigSneyd() {
        return {FdmSchemeDesc::ModifiedCraigSneydType, 1.0 / 3.0, 1.0 / 3.0};
    }
    
    FdmSchemeDesc FdmSchemeDesc::Hundsdorfer() {
        return {FdmSchemeDesc::HundsdorferType, 0.5 + std::sqrt(3.0) / 6, 0.5};
    }
    
    FdmSchemeDesc FdmSchemeDesc::ModifiedHundsdorfer() {
        return {FdmSchemeDesc::HundsdorferType, 1.0 - std::sqrt(2.0) / 2, 0.5};
    }
    
    FdmSchemeDesc FdmSchemeDesc::ExplicitEuler() {
        return {FdmSchemeDesc::ExplicitEulerType, 0.0, 0.0};
    }

    FdmSchemeDesc FdmSchemeDesc::ImplicitEuler() {
        return {FdmSchemeDesc::ImplicitEulerType, 0.0, 0.0};
    }

    FdmSchemeDesc FdmSchemeDesc::MethodOfLines(Real eps, Real relInitStepSize) {
        return {FdmSchemeDesc::MethodOfLinesType, eps, relInitStepSize};
    }

    FdmSchemeDesc FdmSchemeDesc::TrBDF2() { return {FdmSchemeDesc::TrBDF2Type, 2 - M_SQRT2, 1e-8}; }

    FdmBackwardSolver::FdmBackwardSolver(
        ext::shared_ptr<FdmLinearOpComposite> map,
        FdmBoundaryConditionSet bcSet,
        const ext::shared_ptr<FdmStepConditionComposite>& condition,
        const FdmSchemeDesc& schemeDesc)
    : map_(std::move(map)), bcSet_(std::move(bcSet)),
      condition_((condition) != nullptr ?
                     condition :
                     ext::make_shared<FdmStepConditionComposite>(
                         std::list<std::vector<Time> >(), FdmStepConditionComposite::Conditions())),
      schemeDesc_(schemeDesc) {}

    void FdmBackwardSolver::rollback(FdmBackwardSolver::array_type& rhs, 
                                     Time from, Time to,
                                     Size steps, Size dampingSteps) {

        const Time deltaT = from - to;
        const Size allSteps = steps + dampingSteps;
        const Time dampingTo = from - (deltaT*dampingSteps)/allSteps;

        if ((dampingSteps != 0U) && schemeDesc_.type != FdmSchemeDesc::ImplicitEulerType) {
            ImplicitEulerScheme implicitEvolver(map_, bcSet_);    
            FiniteDifferenceModel<ImplicitEulerScheme> 
                    dampingModel(implicitEvolver, condition_->stoppingTimes());
            dampingModel.rollback(rhs, from, dampingTo, 
                                  dampingSteps, *condition_);
        }

        switch (schemeDesc_.type) {
          case FdmSchemeDesc::HundsdorferType:
            {
                HundsdorferScheme hsEvolver(schemeDesc_.theta, schemeDesc_.mu, 
                                            map_, bcSet_);
                FiniteDifferenceModel<HundsdorferScheme> 
                               hsModel(hsEvolver, condition_->stoppingTimes());
                hsModel.rollback(rhs, dampingTo, to, steps, *condition_);
            }
            break;
          case FdmSchemeDesc::DouglasType:
            {
                DouglasScheme dsEvolver(schemeDesc_.theta, map_, bcSet_);
                FiniteDifferenceModel<DouglasScheme> 
                               dsModel(dsEvolver, condition_->stoppingTimes());
                dsModel.rollback(rhs, dampingTo, to, steps, *condition_);
            }
            break;
          case FdmSchemeDesc::CrankNicolsonType:
            {
              CrankNicolsonScheme cnEvolver(schemeDesc_.theta, map_, bcSet_);
              FiniteDifferenceModel<CrankNicolsonScheme>
                             cnModel(cnEvolver, condition_->stoppingTimes());
              cnModel.rollback(rhs, dampingTo, to, steps, *condition_);

            }
            break;
          case FdmSchemeDesc::CraigSneydType:
            {
                CraigSneydScheme csEvolver(schemeDesc_.theta, schemeDesc_.mu, 
                                           map_, bcSet_);
                FiniteDifferenceModel<CraigSneydScheme> 
                               csModel(csEvolver, condition_->stoppingTimes());
                csModel.rollback(rhs, dampingTo, to, steps, *condition_);
            }
            break;
          case FdmSchemeDesc::ModifiedCraigSneydType:
            {
                ModifiedCraigSneydScheme csEvolver(schemeDesc_.theta, 
                                                   schemeDesc_.mu,
                                                   map_, bcSet_);
                FiniteDifferenceModel<ModifiedCraigSneydScheme> 
                              mcsModel(csEvolver, condition_->stoppingTimes());
                mcsModel.rollback(rhs, dampingTo, to, steps, *condition_);
            }
            break;
          case FdmSchemeDesc::ImplicitEulerType:
            {
                ImplicitEulerScheme implicitEvolver(map_, bcSet_);
                FiniteDifferenceModel<ImplicitEulerScheme> 
                   implicitModel(implicitEvolver, condition_->stoppingTimes());
                implicitModel.rollback(rhs, from, to, allSteps, *condition_);
            }
            break;
          case FdmSchemeDesc::ExplicitEulerType:
            {
                ExplicitEulerScheme explicitEvolver(map_, bcSet_);
                FiniteDifferenceModel<ExplicitEulerScheme> 
                   explicitModel(explicitEvolver, condition_->stoppingTimes());
                explicitModel.rollback(rhs, dampingTo, to, steps, *condition_);
            }
            break;
          case FdmSchemeDesc::MethodOfLinesType:
            {
                MethodOfLinesScheme methodOfLines(
                    schemeDesc_.theta, schemeDesc_.mu, map_, bcSet_);
                FiniteDifferenceModel<MethodOfLinesScheme>
                   molModel(methodOfLines, condition_->stoppingTimes());
                molModel.rollback(rhs, dampingTo, to, steps, *condition_);
            }
            break;
          case FdmSchemeDesc::TrBDF2Type:
            {
                const FdmSchemeDesc trDesc
                    = FdmSchemeDesc::CraigSneyd();

                const ext::shared_ptr<CraigSneydScheme> hsEvolver(
                    ext::make_shared<CraigSneydScheme>(
                        trDesc.theta, trDesc.mu, map_, bcSet_));

                TrBDF2Scheme<CraigSneydScheme> trBDF2(
                    schemeDesc_.theta, map_, hsEvolver, bcSet_,schemeDesc_.mu);

                FiniteDifferenceModel<TrBDF2Scheme<CraigSneydScheme> >
                   trBDF2Model(trBDF2, condition_->stoppingTimes());
                trBDF2Model.rollback(rhs, dampingTo, to, steps, *condition_);
            }
            break;
          default:
            QL_FAIL("Unknown scheme type");
        }
    }
}
]]></document_content>
  </document>
  <document index="45">
    <source>finitedifferences/solvers/fdmbatessolver.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmbatessolver.cpp
*/

#include <ql/methods/finitedifferences/operators/fdmbatesop.hpp>
#include <ql/methods/finitedifferences/solvers/fdm2dimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmbatessolver.hpp>
#include <ql/processes/batesprocess.hpp>
#include <utility>


namespace QuantLib {

    FdmBatesSolver::FdmBatesSolver(Handle<BatesProcess> process,
                                   FdmSolverDesc solverDesc,
                                   const FdmSchemeDesc& schemeDesc,
                                   Size integroIntegrationOrder,
                                   Handle<FdmQuantoHelper> quantoHelper)
    : process_(std::move(process)), solverDesc_(std::move(solverDesc)), schemeDesc_(schemeDesc),
      integroIntegrationOrder_(integroIntegrationOrder), quantoHelper_(std::move(quantoHelper)) {
        registerWith(process_);
        registerWith(quantoHelper_);
    }

    void FdmBatesSolver::performCalculations() const {
        ext::shared_ptr<FdmLinearOpComposite> op(
            new FdmBatesOp(solverDesc_.mesher, process_.currentLink(),
                           solverDesc_.bcSet, integroIntegrationOrder_,
                           (!quantoHelper_.empty()) 
                                   ? quantoHelper_.currentLink()
                                   : ext::shared_ptr<FdmQuantoHelper>()));

        solver_ = ext::make_shared<Fdm2DimSolver>(
                               solverDesc_, schemeDesc_, op);
    }

    Real FdmBatesSolver::valueAt(Real s, Real v) const {
        calculate();
        return solver_->interpolateAt(std::log(s), v);
    }

    Real FdmBatesSolver::deltaAt(Real s, Real v) const {
        calculate();
        return solver_->derivativeX(std::log(s), v)/s;
    }

    Real FdmBatesSolver::gammaAt(Real s, Real v) const {
        calculate();
        const Real x = std::log(s);
        return (solver_->derivativeXX(x, v)-solver_->derivativeX(x, v))/(s*s);
    }

    Real FdmBatesSolver::thetaAt(Real s, Real v) const {
        calculate();
        return solver_->thetaAt(std::log(s), v);
    }

}
]]></document_content>
  </document>
  <document index="46">
    <source>finitedifferences/solvers/fdmblackscholessolver.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/operators/fdmblackscholesop.hpp>
#include <ql/methods/finitedifferences/solvers/fdm1dimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmblackscholessolver.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    FdmBlackScholesSolver::FdmBlackScholesSolver(Handle<GeneralizedBlackScholesProcess> process,
                                                 Real strike,
                                                 FdmSolverDesc solverDesc,
                                                 const FdmSchemeDesc& schemeDesc,
                                                 bool localVol,
                                                 Real illegalLocalVolOverwrite,
                                                 Handle<FdmQuantoHelper> quantoHelper)
    : process_(std::move(process)), strike_(strike), solverDesc_(std::move(solverDesc)),
      schemeDesc_(schemeDesc), localVol_(localVol),
      illegalLocalVolOverwrite_(illegalLocalVolOverwrite), quantoHelper_(std::move(quantoHelper)) {

        registerWith(process_);
        registerWith(quantoHelper_);
    }

    void FdmBlackScholesSolver::performCalculations() const {
            const ext::shared_ptr<FdmBlackScholesOp> op(
            ext::make_shared<FdmBlackScholesOp>(
                solverDesc_.mesher, process_.currentLink(), strike_,
                localVol_, illegalLocalVolOverwrite_, 0,
                (quantoHelper_.empty())
                    ? ext::shared_ptr<FdmQuantoHelper>()
                    : quantoHelper_.currentLink()));

        solver_ = ext::make_shared<Fdm1DimSolver>(solverDesc_, schemeDesc_, op);
    }

    Real FdmBlackScholesSolver::valueAt(Real s) const {
        calculate();
        return solver_->interpolateAt(std::log(s));
    }

    Real FdmBlackScholesSolver::deltaAt(Real s) const {
        calculate();
        return solver_->derivativeX(std::log(s))/s;
    }

    Real FdmBlackScholesSolver::gammaAt(Real s) const {
        calculate();
        return (solver_->derivativeXX(std::log(s))
                -solver_->derivativeX(std::log(s)))/(s*s);
    }

    Real FdmBlackScholesSolver::thetaAt(Real s) const {
        return solver_->thetaAt(std::log(s));
    }
}
]]></document_content>
  </document>
  <document index="47">
    <source>finitedifferences/solvers/fdmcirsolver.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Lew Wei Hao

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/operators/fdmcirop.hpp>
#include <ql/methods/finitedifferences/solvers/fdm2dimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmcirsolver.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <utility>

namespace QuantLib {

    FdmCIRSolver::FdmCIRSolver(Handle<CoxIngersollRossProcess> cirProcess,
                               Handle<GeneralizedBlackScholesProcess> bsProcess,
                               FdmSolverDesc solverDesc,
                               const FdmSchemeDesc& schemeDesc,
                               const Real rho,
                               const Real strike)
    : bsProcess_(std::move(bsProcess)), cirProcess_(std::move(cirProcess)),
      solverDesc_(std::move(solverDesc)), schemeDesc_(schemeDesc), rho_(rho), strike_(strike) {
        registerWith(bsProcess_);
        registerWith(cirProcess_);
    }

    void FdmCIRSolver::performCalculations() const {
        ext::shared_ptr<FdmLinearOpComposite> op(
			ext::make_shared<FdmCIROp>(
                solverDesc_.mesher,
                cirProcess_.currentLink(),
                bsProcess_.currentLink(),
                rho_,
                strike_));

        solver_ = ext::make_shared<Fdm2DimSolver>(solverDesc_, schemeDesc_, op);
    }

    Real FdmCIRSolver::valueAt(Real s, Real r) const {
        calculate();
        return solver_->interpolateAt(std::log(s), r);
    }

    Real FdmCIRSolver::deltaAt(Real s, Real r) const {
        calculate();
        return solver_->derivativeX(std::log(s), r)/s;
    }

    Real FdmCIRSolver::gammaAt(Real s, Real r) const {
        calculate();
        const Real x = std::log(s);
        return (solver_->derivativeXX(x, r)-solver_->derivativeX(x, r))/(s*s);
    }

    Real FdmCIRSolver::thetaAt(Real s, Real r) const {
        calculate();
        return solver_->thetaAt(std::log(s), r);
    }
}
]]></document_content>
  </document>
  <document index="48">
    <source>finitedifferences/solvers/fdmg2solver.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmg2solver.cpp
*/

#include <ql/methods/finitedifferences/operators/fdmg2op.hpp>
#include <ql/methods/finitedifferences/solvers/fdm2dimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmg2solver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsnapshotcondition.hpp>
#include <ql/models/shortrate/twofactormodels/g2.hpp>
#include <utility>

namespace QuantLib {

    FdmG2Solver::FdmG2Solver(Handle<G2> model,
                             FdmSolverDesc solverDesc,
                             const FdmSchemeDesc& schemeDesc)
    : model_(std::move(model)), solverDesc_(std::move(solverDesc)), schemeDesc_(schemeDesc) {
        registerWith(model_);
    }


    void FdmG2Solver::performCalculations() const {
        const ext::shared_ptr<FdmG2Op> op(
            new FdmG2Op(solverDesc_.mesher, model_.currentLink(), 0, 1));

        solver_ = ext::make_shared<Fdm2DimSolver>(
            solverDesc_, schemeDesc_, op);
    }

    Real FdmG2Solver::valueAt(Real x, Real y) const {
        calculate();
        return solver_->interpolateAt(x, y);
    }
}
]]></document_content>
  </document>
  <document index="49">
    <source>finitedifferences/solvers/fdmhestonhullwhitesolver.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/operators/fdmhestonhullwhiteop.hpp>
#include <ql/methods/finitedifferences/solvers/fdm3dimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmhestonhullwhitesolver.hpp>
#include <ql/methods/finitedifferences/utilities/fdmquantohelper.hpp>
#include <utility>

namespace QuantLib {

    FdmHestonHullWhiteSolver::FdmHestonHullWhiteSolver(const Handle<HestonProcess>& hestonProcess,
                                                       const Handle<HullWhiteProcess>& hwProcess,
                                                       Rate corrEquityShortRate,
                                                       FdmSolverDesc solverDesc,
                                                       const FdmSchemeDesc& schemeDesc)
    : hestonProcess_(hestonProcess), hwProcess_(hwProcess),
      corrEquityShortRate_(corrEquityShortRate), solverDesc_(std::move(solverDesc)),
      schemeDesc_(schemeDesc) {

        registerWith(hestonProcess);
        registerWith(hwProcess);
    }

    void FdmHestonHullWhiteSolver::performCalculations() const {
        const ext::shared_ptr<FdmLinearOpComposite> op(
			ext::make_shared<FdmHestonHullWhiteOp>(solverDesc_.mesher,
                                     hestonProcess_.currentLink(),
                                     hwProcess_.currentLink(), 
                                     corrEquityShortRate_));

        solver_ = ext::make_shared<Fdm3DimSolver>(solverDesc_, schemeDesc_, op);
    }

    Real FdmHestonHullWhiteSolver::valueAt(Real s, Real v, Rate r) const {
        calculate();

        const Real x = std::log(s);
        return solver_->interpolateAt(x, v, r);
    }

    Real FdmHestonHullWhiteSolver::deltaAt(Real s, Real v, Rate r, Real eps) 
    const {
        return (valueAt(s+eps, v, r) - valueAt(s-eps, v, r))/(2*eps);
    }

    Real FdmHestonHullWhiteSolver::gammaAt(Real s, Real v, Rate r, Real eps) 
    const {
        return (valueAt(s+eps, v, r)+valueAt(s-eps, v,r )
                -2*valueAt(s, v, r))/(eps*eps);
    }

    Real FdmHestonHullWhiteSolver::thetaAt(Real s, Real v, Rate r) const {
        calculate();

        const Real x = std::log(s);
        return solver_->thetaAt(x, v, r);
    }
}
]]></document_content>
  </document>
  <document index="50">
    <source>finitedifferences/solvers/fdmhestonsolver.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008, 2009, 2011, 2014, 2015 Klaus Spanderen
 Copyright (C) 2015 Johannes GÃ¶ttker-Schnetmann

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/operators/fdmhestonop.hpp>
#include <ql/methods/finitedifferences/solvers/fdm2dimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmhestonsolver.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <utility>

namespace QuantLib {

    FdmHestonSolver::FdmHestonSolver(Handle<HestonProcess> process,
                                     FdmSolverDesc solverDesc,
                                     const FdmSchemeDesc& schemeDesc,
                                     Handle<FdmQuantoHelper> quantoHelper,
                                     ext::shared_ptr<LocalVolTermStructure> leverageFct,
                                     const Real mixingFactor)
    : process_(std::move(process)), solverDesc_(std::move(solverDesc)), schemeDesc_(schemeDesc),
      quantoHelper_(std::move(quantoHelper)), leverageFct_(std::move(leverageFct)),
      mixingFactor_(mixingFactor) {

        registerWith(process_);
        registerWith(quantoHelper_);
    }

    void FdmHestonSolver::performCalculations() const {
        ext::shared_ptr<FdmLinearOpComposite> op(
			ext::make_shared<FdmHestonOp>(
                solverDesc_.mesher, process_.currentLink(),
                (!quantoHelper_.empty()) ? quantoHelper_.currentLink()
                             : ext::shared_ptr<FdmQuantoHelper>(),
                leverageFct_, mixingFactor_));

        solver_ = ext::make_shared<Fdm2DimSolver>(solverDesc_, schemeDesc_, op);
    }

    Real FdmHestonSolver::valueAt(Real s, Real v) const {
        calculate();
        return solver_->interpolateAt(std::log(s), v);
    }

    Real FdmHestonSolver::deltaAt(Real s, Real v) const {
        calculate();
        return solver_->derivativeX(std::log(s), v)/s;
    }

    Real FdmHestonSolver::gammaAt(Real s, Real v) const {
        calculate();
        const Real x = std::log(s);
        return (solver_->derivativeXX(x, v)-solver_->derivativeX(x, v))/(s*s);
    }

    Real FdmHestonSolver::meanVarianceDeltaAt(Real s, Real v) const {
        calculate();

        const Real alpha = process_->rho()*process_->sigma()/s;
        return deltaAt(s, v) + alpha*solver_->derivativeY(std::log(s), v);
    }

    Real FdmHestonSolver::meanVarianceGammaAt(Real s, Real v) const {
        calculate();

        const Real x = std::log(s);
        const Real alpha = process_->rho()*process_->sigma()/s;
        return gammaAt(s, v)
                +  solver_->derivativeYY(x, v)*alpha*alpha
                +2*solver_->derivativeXY(x, v)*alpha/s;
    }

    Real FdmHestonSolver::thetaAt(Real s, Real v) const {
        calculate();
        return solver_->thetaAt(std::log(s), v);
    }
}
]]></document_content>
  </document>
  <document index="51">
    <source>finitedifferences/solvers/fdmhullwhitesolver.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmhullwhitesolver.cpp
*/

#include <ql/methods/finitedifferences/operators/fdmhullwhiteop.hpp>
#include <ql/methods/finitedifferences/solvers/fdm1dimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmhullwhitesolver.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsnapshotcondition.hpp>
#include <ql/models/shortrate/onefactormodels/hullwhite.hpp>
#include <utility>

namespace QuantLib {

    FdmHullWhiteSolver::FdmHullWhiteSolver(Handle<HullWhite> model,
                                           FdmSolverDesc solverDesc,
                                           const FdmSchemeDesc& schemeDesc)
    : model_(std::move(model)), solverDesc_(std::move(solverDesc)), schemeDesc_(schemeDesc) {
        registerWith(model_);
    }


    void FdmHullWhiteSolver::performCalculations() const {
        const ext::shared_ptr<FdmHullWhiteOp> op(
			ext::make_shared<FdmHullWhiteOp>(solverDesc_.mesher, model_.currentLink(), 0));

        solver_ = ext::make_shared<Fdm1DimSolver>(solverDesc_, schemeDesc_, op);
    }

    Real FdmHullWhiteSolver::valueAt(Real r) const {
        calculate();
        return solver_->interpolateAt(r);
    }
}
]]></document_content>
  </document>
  <document index="52">
    <source>finitedifferences/solvers/fdmsimple2dbssolver.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Ralph Schreyer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*!
 * \file fdmsimple2dbssolver.cpp
*/

#include <ql/methods/finitedifferences/operators/fdmblackscholesop.hpp>
#include <ql/methods/finitedifferences/solvers/fdm2dimsolver.hpp>
#include <ql/methods/finitedifferences/solvers/fdmsimple2dbssolver.hpp>
#include <utility>

namespace QuantLib {

    FdmSimple2dBSSolver::FdmSimple2dBSSolver(Handle<GeneralizedBlackScholesProcess> process,
                                             Real strike,
                                             FdmSolverDesc solverDesc,
                                             const FdmSchemeDesc& schemeDesc)
    : process_(std::move(process)), strike_(strike), solverDesc_(std::move(solverDesc)),
      schemeDesc_(schemeDesc) {

        registerWith(process_);
    }

    void FdmSimple2dBSSolver::performCalculations() const {
        ext::shared_ptr<FdmBlackScholesOp> op(ext::make_shared<FdmBlackScholesOp>(
                solverDesc_.mesher, process_.currentLink(), strike_));

        solver_ = ext::make_shared<Fdm2DimSolver>(solverDesc_, schemeDesc_, op);
    }

    Real FdmSimple2dBSSolver::valueAt(Real s, Real a) const {
        calculate();
        return solver_->interpolateAt(std::log(s), std::log(a));
    }

    Real FdmSimple2dBSSolver::deltaAt(Real s, Real a, Real eps) const {
        return (valueAt(s+eps, a) - valueAt(s-eps, a))/(2*eps);
    }

    Real FdmSimple2dBSSolver::gammaAt(Real s, Real a, Real eps) const {
        return (valueAt(s+eps, a)+valueAt(s-eps, a)-2*valueAt(s,a))/(eps*eps);
    }

    Real FdmSimple2dBSSolver::thetaAt(Real s, Real a) const {
        calculate();
        return solver_->thetaAt(std::log(s), std::log(a));
    }
}
]]></document_content>
  </document>
  <document index="53">
    <source>finitedifferences/stepconditions/fdmamericanstepcondition.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmamericanstepcondition.hpp>
#include <utility>

namespace QuantLib {

    FdmAmericanStepCondition::FdmAmericanStepCondition(
        ext::shared_ptr<FdmMesher> mesher, ext::shared_ptr<FdmInnerValueCalculator> calculator)
    : mesher_(std::move(mesher)), calculator_(std::move(calculator)) {}

    void FdmAmericanStepCondition::applyTo(Array& a, Time t) const {
        ext::shared_ptr<FdmLinearOpLayout> layout = mesher_->layout();

        QL_REQUIRE(layout->size() == a.size(),
                   "inconsistent array dimensions");

        const FdmLinearOpIterator endIter = layout->end();

        for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
            ++iter) {
            const Real innerValue = calculator_->innerValue(iter, t);
            if (innerValue > a[iter.index()]) {
                a[iter.index()] = innerValue;
            }
        }
    }
}
]]></document_content>
  </document>
  <document index="54">
    <source>finitedifferences/stepconditions/fdmarithmeticaveragecondition.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Ralph Schreyer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmarithmeticaveragecondition.cpp
    \brief step condition to handle arithmetic average
*/

#include <ql/math/interpolations/cubicinterpolation.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmarithmeticaveragecondition.hpp>
#include <utility>

namespace QuantLib {

    FdmArithmeticAverageCondition::FdmArithmeticAverageCondition(
        std::vector<Time> averageTimes,
        Real,
        Size pastFixings,
        const ext::shared_ptr<FdmMesher>& mesher,
        Size equityDirection)
    : x_(mesher->layout()->dim()[equityDirection]),
      a_(mesher->layout()->dim()[equityDirection == 0 ? 1 : 0]),
      averageTimes_(std::move(averageTimes)), pastFixings_(pastFixings), mesher_(mesher),
      equityDirection_(equityDirection) {

        QL_REQUIRE(mesher->layout()->dim().size()==2, "2D allowed only");
        QL_REQUIRE(equityDirection == 0 || equityDirection == 1,
                   "equityDirection has to be 0 or 1");

        const Size xSpacing = mesher_->layout()->spacing()[equityDirection];
        Array tmp = mesher_->locations(equityDirection);
        for (Size i = 0; i < x_.size(); ++i) {
            x_[i] = std::exp(tmp[i*xSpacing]);
        }
        const Size averageDirection = equityDirection == 0 ? 1 : 0;
        const Size aSpacing = mesher_->layout()->spacing()[averageDirection];
        tmp = mesher_->locations(averageDirection);
        for (Size i = 0; i < a_.size(); ++i) {
            a_[i] = std::exp(tmp[i*aSpacing]);
        }
    }

    void FdmArithmeticAverageCondition::applyTo(Array& a, Time t) const {
        QL_REQUIRE(mesher_->layout()->size() == a.size(),
                   "inconsistent array dimensions");

        const std::vector<Time>::const_iterator iter
            = std::find(averageTimes_.begin(), averageTimes_.end(), t);
        const Size nTimes
            = std::count(averageTimes_.begin(), averageTimes_.end(), t);
        if (nTimes > 0) {
            Array aCopy(a);
            const Size iT = iter - averageTimes_.begin() + 1 + pastFixings_;
            const Size averageDirection = equityDirection_ == 0 ? 1 : 0;
            const Size xSpacing = mesher_->layout()->spacing()[equityDirection_];
            const Size aSpacing = mesher_->layout()->spacing()[averageDirection];
            Array tmp(a_.size());

            for (Size i=0; i<x_.size(); ++i) {
                for (Size j=0; j<a_.size(); ++j) {
                    Size index = i*xSpacing + j*aSpacing;
                    tmp[j] = aCopy[index];
                }
                MonotonicCubicNaturalSpline interp(a_.begin(), a_.end(),
                                           tmp.begin());
                for (Size j=0; j<a_.size(); ++j) {
                    Size index = i*xSpacing + j*aSpacing;
                    a[index] = interp((iT-nTimes)/(double)(iT)*a_[j] +
                                      nTimes/(double)(iT)*x_[i], true);
                }
            }
        }
    }
}
]]></document_content>
  </document>
  <document index="55">
    <source>finitedifferences/stepconditions/fdmbermudanstepcondition.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmbermudanstepcondition.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <utility>

namespace QuantLib {

    FdmBermudanStepCondition::FdmBermudanStepCondition(
        const std::vector<Date>& exerciseDates,
        const Date& referenceDate,
        const DayCounter& dayCounter,
        ext::shared_ptr<FdmMesher> mesher,
        ext::shared_ptr<FdmInnerValueCalculator> calculator)
    : mesher_(std::move(mesher)), calculator_(std::move(calculator)) {

        exerciseTimes_.reserve(exerciseDates.size());
        for (auto exerciseDate : exerciseDates) {
            exerciseTimes_.push_back(dayCounter.yearFraction(referenceDate, exerciseDate));
        }
    }

    const std::vector<Time>& FdmBermudanStepCondition::exerciseTimes() const {
        return exerciseTimes_;
    }
    
    void FdmBermudanStepCondition::applyTo(Array& a, Time t) const {
        if (std::find(exerciseTimes_.begin(), exerciseTimes_.end(), t) 
              != exerciseTimes_.end()) {
            
            ext::shared_ptr<FdmLinearOpLayout> layout = mesher_->layout();

            QL_REQUIRE(layout->size() == a.size(),
                       "inconsistent array dimensions");

            const FdmLinearOpIterator endIter = layout->end();

            const Size dims = layout->dim().size();
            Array locations(dims);

            for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
                ++iter) {
                for (Size i=0; i < dims; ++i)
                    locations[i] = mesher_->location(iter, i);

                const Real innerValue = calculator_->innerValue(iter, t);
                if (innerValue > a[iter.index()]) {
                    a[iter.index()] = innerValue;
                }
            }            
        }
    }
}
]]></document_content>
  </document>
  <document index="56">
    <source>finitedifferences/stepconditions/fdmsimplestoragecondition.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen
 Copyright (C) 2014 Ralph Schreyer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/interpolations/bilinearinterpolation.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsimplestoragecondition.hpp>
#include <utility>

namespace QuantLib {

    FdmSimpleStorageCondition::FdmSimpleStorageCondition(
        std::vector<Time> exerciseTimes,
        ext::shared_ptr<FdmMesher> mesher,
        ext::shared_ptr<FdmInnerValueCalculator> calculator,
        Real changeRate)
    : exerciseTimes_(std::move(exerciseTimes)), mesher_(std::move(mesher)),
      calculator_(std::move(calculator)), changeRate_(changeRate) {

        const ext::shared_ptr<FdmLinearOpLayout> layout = mesher_->layout();

        x_.reserve(layout->dim()[0]);
        y_.reserve(layout->dim()[1]);

        const FdmLinearOpIterator endIter = layout->end();
        for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
             ++iter) {
            if (iter.coordinates()[1] == 0U) {
                x_.push_back(mesher_->location(iter, 0));
            }
            if (iter.coordinates()[0] == 0U) {
                y_.push_back(mesher_->location(iter, 1));
            }
        }
    }

    void FdmSimpleStorageCondition::applyTo(Array& a, Time t) const {
        const std::vector<Time>::const_iterator iter
            = std::find(exerciseTimes_.begin(), exerciseTimes_.end(), t);

        if (iter != exerciseTimes_.end()) {
            Array retVal(a.size());

            Matrix m(y_.size(), x_.size());
            std::copy(a.begin(), a.end(), m.begin());
            BilinearInterpolation interpl(x_.begin(), x_.end(),
                                          y_.begin(), y_.end(), m);

            const ext::shared_ptr<FdmLinearOpLayout> layout=mesher_->layout();

            QL_REQUIRE(layout->size() == a.size(),
                       "inconsistent array dimensions");

            const FdmLinearOpIterator endIter = layout->end();

            for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
                 ++iter) {

                const std::vector<Size>& coor = iter.coordinates();
                const Real x = x_[coor[0]];
                const Real y = y_[coor[1]];

                const Real price = calculator_->innerValue(iter, t);

                const Real maxWithDraw = std::min(y-y_.front(), changeRate_);
                const Real sellPrice   = interpl(x, y-maxWithDraw);

                const Real maxInject = std::min(y_.back()-y, changeRate_);
                const Real buyPrice  = interpl(x, y+maxInject);

                // bang-bang-wait strategy
                Real currentValue = std::max(a[iter.index()],
                    std::max(buyPrice - price*maxInject,
                             sellPrice + price*maxWithDraw));

                // check if intermediate grid points give a better value
                auto yIter = std::upper_bound(y_.begin(), y_.end(), y - maxWithDraw);

                while (yIter != y_.end() && *yIter < y + maxInject) {
                    if (*yIter != y) {
                        const Real change = *yIter - y;
                        const Real storagePrice(interpl(x, *yIter));

                        currentValue = std::max(currentValue,
                            storagePrice - change*price);
                    }
                    ++yIter;
                }

                retVal[iter.index()] = currentValue;
            }
            a = retVal;
        }
    }
}
]]></document_content>
  </document>
  <document index="57">
    <source>finitedifferences/stepconditions/fdmsimpleswingcondition.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2014 Klaus Spanderen
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsimpleswingcondition.hpp>
#include <utility>

namespace QuantLib {

    FdmSimpleSwingCondition::FdmSimpleSwingCondition(
        std::vector<Time> exerciseTimes,
        ext::shared_ptr<FdmMesher> mesher,
        ext::shared_ptr<FdmInnerValueCalculator> calculator,
        Size swingDirection,
        Size minExercises)
    : exerciseTimes_(std::move(exerciseTimes)), mesher_(std::move(mesher)),
      calculator_(std::move(calculator)), minExercises_(minExercises),
      swingDirection_(swingDirection) {}

    void FdmSimpleSwingCondition::applyTo(Array& a, Time t) const {

        const std::vector<Time>::const_iterator iter
            = std::find(exerciseTimes_.begin(), exerciseTimes_.end(), t);
        const Size maxExerciseValue=mesher_->layout()->dim()[swingDirection_]-1;

        if (iter != exerciseTimes_.end()) {
            Array retVal= a;

            const Size d = std::distance(iter, exerciseTimes_.end());

            const ext::shared_ptr<FdmLinearOpLayout> layout=mesher_->layout();

            QL_REQUIRE(layout->size() == a.size(),
                       "inconsistent array dimensions");

            const FdmLinearOpIterator endIter = layout->end();
            
            for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
                 ++iter) {
                
                const std::vector<Size>& coor = iter.coordinates();
                
                const Size exercisesUsed = coor[swingDirection_];
                
                if (exercisesUsed < maxExerciseValue) {
                    const Real cashflow = calculator_->innerValue(iter, t);
                    const Real currentValue = a[iter.index()];
                    const Real valuePlusOneExercise
                         = a[layout->neighbourhood(iter, swingDirection_, 1)];
                    
                    if (   currentValue < valuePlusOneExercise + cashflow
                        || exercisesUsed + d <=  minExercises_) {
                        retVal[iter.index()] = valuePlusOneExercise + cashflow;
                    }
                }
            }
            a = retVal;
        }
    }
}
]]></document_content>
  </document>
  <document index="58">
    <source>finitedifferences/stepconditions/fdmsnapshotcondition.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/stepconditions/fdmsnapshotcondition.hpp>

namespace QuantLib {

    FdmSnapshotCondition::FdmSnapshotCondition(Time t)
    : t_(t) {
    }


    void FdmSnapshotCondition::applyTo(Array& a, Time t) const {
        if (t == t_)
            values_ = a;
    }


    Time FdmSnapshotCondition::getTime() const {
        return t_;
    }


    const Array& FdmSnapshotCondition::getValues() const {
        return values_;
    }

}
]]></document_content>
  </document>
  <document index="59">
    <source>finitedifferences/stepconditions/fdmstepconditioncomposite.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include <ql/exercise.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmamericanstepcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmbermudanstepcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmsnapshotcondition.hpp>
#include <ql/methods/finitedifferences/stepconditions/fdmstepconditioncomposite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdividendhandler.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <set>
#include <utility>

namespace QuantLib {

    FdmStepConditionComposite::FdmStepConditionComposite(
        const std::list<std::vector<Time> >& stoppingTimes, Conditions conditions)
    : conditions_(std::move(conditions)) {

        std::set<Real> allStoppingTimes;
        for (const auto& stoppingTime : stoppingTimes) {
            allStoppingTimes.insert(stoppingTime.begin(), stoppingTime.end());
        }
        stoppingTimes_ = std::vector<Time>(allStoppingTimes.begin(),
                                           allStoppingTimes.end());
    }

    const FdmStepConditionComposite::Conditions&
    FdmStepConditionComposite::conditions() const {
        return conditions_;
    }

    const std::vector<Time>& FdmStepConditionComposite::stoppingTimes() const {
        return stoppingTimes_;
    }

    void FdmStepConditionComposite::applyTo(Array& a, Time t) const {
        for (const auto& condition : conditions_) {
            condition->applyTo(a, t);
        }
    }
    
    ext::shared_ptr<FdmStepConditionComposite> 
    FdmStepConditionComposite::joinConditions(
                const ext::shared_ptr<FdmSnapshotCondition>& c1,
                const ext::shared_ptr<FdmStepConditionComposite>& c2) {

        std::list<std::vector<Time> > stoppingTimes;
        stoppingTimes.push_back(c2->stoppingTimes());
        stoppingTimes.emplace_back(1, c1->getTime());

        FdmStepConditionComposite::Conditions conditions;
        conditions.push_back(c2);
        conditions.push_back(c1);

        return ext::make_shared<FdmStepConditionComposite>(
            stoppingTimes, conditions);
    }

    ext::shared_ptr<FdmStepConditionComposite> 
    FdmStepConditionComposite::vanillaComposite(
                 const DividendSchedule& cashFlow,
                 const ext::shared_ptr<Exercise>& exercise,
                 const ext::shared_ptr<FdmMesher>& mesher,
                 const ext::shared_ptr<FdmInnerValueCalculator>& calculator,
                 const Date& refDate,
                 const DayCounter& dayCounter) {
        
        std::list<std::vector<Time> > stoppingTimes;
        std::list<ext::shared_ptr<StepCondition<Array> > > stepConditions;

        if(!cashFlow.empty()) {
            ext::shared_ptr<FdmDividendHandler> dividendCondition(
                new FdmDividendHandler(cashFlow, mesher,
                                       refDate, dayCounter, 0));
            stepConditions.push_back(dividendCondition);

            std::vector<Time> dividendTimes = dividendCondition->dividendTimes();
            stoppingTimes.push_back(dividendTimes);

            // smoother convergence behavior with number of time steps
            const Time maturityTime = dayCounter.yearFraction(
                refDate,exercise->lastDate());

            for (auto& t: dividendTimes)
                t = std::min(maturityTime, t+1e-5);
            stoppingTimes.push_back(dividendTimes);
        }

        QL_REQUIRE(   exercise->type() == Exercise::American
                   || exercise->type() == Exercise::European
                   || exercise->type() == Exercise::Bermudan,
                   "exercise type is not supported");
        if (exercise->type() == Exercise::American) {
            stepConditions.push_back(ext::shared_ptr<StepCondition<Array> >(
                          new FdmAmericanStepCondition(mesher,calculator)));
        }
        else if (exercise->type() == Exercise::Bermudan) {
            ext::shared_ptr<FdmBermudanStepCondition> bermudanCondition(
                new FdmBermudanStepCondition(exercise->dates(),
                                             refDate, dayCounter,
                                             mesher, calculator));
            stepConditions.push_back(bermudanCondition);
            stoppingTimes.push_back(bermudanCondition->exerciseTimes());
        }
        
        return ext::make_shared<FdmStepConditionComposite>(
            stoppingTimes, stepConditions);

    }

}
]]></document_content>
  </document>
  <document index="60">
    <source>finitedifferences/tridiagonaloperator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003, 2011 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/finitedifferences/tridiagonaloperator.hpp>

namespace QuantLib {

    TridiagonalOperator::TridiagonalOperator(Size size) {
        if (size>=2) {
            n_ = size;
            diagonal_      = Array(size);
            lowerDiagonal_ = Array(size-1);
            upperDiagonal_ = Array(size-1);
            temp_          = Array(size);
        } else if (size==0) {
            n_ = 0;
            diagonal_      = Array(0);
            lowerDiagonal_ = Array(0);
            upperDiagonal_ = Array(0);
            temp_          = Array(0);
        } else {
            QL_FAIL("invalid size (" << size << ") for tridiagonal operator "
                    "(must be null or >= 2)");
        }
    }

    TridiagonalOperator::TridiagonalOperator(const Array& low,
                                             const Array& mid,
                                             const Array& high)
    : n_(mid.size()),
      diagonal_(mid), lowerDiagonal_(low), upperDiagonal_(high), temp_(n_) {
        QL_REQUIRE(low.size() == n_-1,
                   "low diagonal vector of size " << low.size() <<
                   " instead of " << n_-1);
        QL_REQUIRE(high.size() == n_-1,
                   "high diagonal vector of size " << high.size() <<
                   " instead of " << n_-1);
    }

    Disposable<Array> TridiagonalOperator::applyTo(const Array& v) const {
        QL_REQUIRE(n_!=0,
                   "uninitialized TridiagonalOperator");
        QL_REQUIRE(v.size()==n_,
                   "vector of the wrong size " << v.size() <<
                   " instead of " << n_);
        Array result(n_);
        std::transform(diagonal_.begin(), diagonal_.end(),
                       v.begin(),
                       result.begin(),
                       std::multiplies<Real>());

        // matricial product
        result[0] += upperDiagonal_[0]*v[1];
        for (Size j=1; j<=n_-2; j++)
            result[j] += lowerDiagonal_[j-1]*v[j-1]+
                upperDiagonal_[j]*v[j+1];
        result[n_-1] += lowerDiagonal_[n_-2]*v[n_-2];

        return result;
    }

    Disposable<Array> TridiagonalOperator::solveFor(const Array& rhs) const  {

        Array result(rhs.size());
        solveFor(rhs, result);
        return result;
    }

    void TridiagonalOperator::solveFor(const Array& rhs,
                                       Array& result) const  {

        QL_REQUIRE(n_!=0,
                   "uninitialized TridiagonalOperator");
        QL_REQUIRE(rhs.size()==n_,
                   "rhs vector of size " << rhs.size() <<
                   " instead of " << n_);

        Real bet = diagonal_[0];
        QL_REQUIRE(!close(bet, 0.0),
                   "diagonal's first element (" << bet <<
                   ") cannot be close to zero");
        result[0] = rhs[0]/bet;
        for (Size j=1; j<=n_-1; ++j) {
            temp_[j] = upperDiagonal_[j-1]/bet;
            bet = diagonal_[j]-lowerDiagonal_[j-1]*temp_[j];
            QL_ENSURE(!close(bet, 0.0), "division by zero");
            result[j] = (rhs[j] - lowerDiagonal_[j-1]*result[j-1])/bet;
        }
        // cannot be j>=0 with Size j
        for (Size j=n_-2; j>0; --j)
            result[j] -= temp_[j+1]*result[j+1];
        result[0] -= temp_[1]*result[1];
    }

    Disposable<Array> TridiagonalOperator::SOR(const Array& rhs,
                                               Real tol) const {
        QL_REQUIRE(n_!=0,
                   "uninitialized TridiagonalOperator");
        QL_REQUIRE(rhs.size()==n_,
                   "rhs vector of size " << rhs.size() <<
                   " instead of " << n_);

        // initial guess
        Array result = rhs;

        // solve tridiagonal system with SOR technique
        Real omega = 1.5;
        Real err = 2.0*tol;
        Real temp;
        for (Size sorIteration=0; err>tol ; ++sorIteration) {
            QL_REQUIRE(sorIteration<100000,
                       "tolerance (" << tol << ") not reached in " <<
                       sorIteration << " iterations. " <<
                       "The error still is " << err);

            temp = omega * (rhs[0]     -
                            upperDiagonal_[0]   * result[1]-
                            diagonal_[0]        * result[0])/diagonal_[0];
            err = temp*temp;
            result[0] += temp;
            Size i;
            for (i=1; i<n_-1 ; ++i) {
                temp = omega *(rhs[i]     -
                               upperDiagonal_[i]   * result[i+1]-
                               diagonal_[i]        * result[i] -
                               lowerDiagonal_[i-1] * result[i-1])/diagonal_[i];
                err += temp * temp;
                result[i] += temp;
            }

            temp = omega * (rhs[i]     -
                            diagonal_[i]        * result[i] -
                            lowerDiagonal_[i-1] * result[i-1])/diagonal_[i];
            err += temp*temp;
            result[i] += temp;
        }
        return result;
    }

    Disposable<TridiagonalOperator>
    TridiagonalOperator::identity(Size size) {
        TridiagonalOperator I(Array(size-1, 0.0),     // lower diagonal
                              Array(size,   1.0),     // diagonal
                              Array(size-1, 0.0));    // upper diagonal
        return I;
    }

}
]]></document_content>
  </document>
  <document index="61">
    <source>finitedifferences/utilities/bsmrndcalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes GÃ¶ttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bsmrndcalculator.hpp
    \brief risk neutral terminal density calculator for the
           Black-Scholes-Merton model with constant volatility
*/

#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/methods/finitedifferences/utilities/bsmrndcalculator.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <cmath>
#include <utility>

namespace QuantLib {

    BSMRNDCalculator::BSMRNDCalculator(ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {}

    std::pair<Real, Volatility>
    BSMRNDCalculator::distributionParams(Real x, Time t) const {
        const Volatility stdDev =
            process_->blackVolatility()->blackVol(t, std::exp(x))*std::sqrt(t);
        const Real mean = std::log(process_->x0()) - 0.5*stdDev*stdDev
            + std::log(  process_->dividendYield()->discount(t)
                       / process_->riskFreeRate()->discount(t));

        return std::make_pair(mean, stdDev);
    }

    Real BSMRNDCalculator::pdf(Real x, Time t) const {
        std::pair<Real, Volatility> p = distributionParams(x, t);
        return NormalDistribution(p.first, p.second)(x);
    }

    Real BSMRNDCalculator::cdf(Real x, Time t) const {
        std::pair<Real, Volatility> p = distributionParams(x, t);
        return CumulativeNormalDistribution(p.first, p.second)(x);
    }

    Real BSMRNDCalculator::invcdf(Real x, Time t) const {
        std::pair<Real, Volatility> p = distributionParams(x, t);
        return InvCumulativeNormalDistribution(p.first, p.second)(x);
    }
}
]]></document_content>
  </document>
  <document index="62">
    <source>finitedifferences/utilities/cevrndcalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cevrndcalculator.cpp */

#include <ql/errors.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

#include <ql/methods/finitedifferences/utilities/cevrndcalculator.hpp>

#include <boost/math/special_functions/gamma.hpp>
#include <boost/math/distributions/non_central_chi_squared.hpp>

namespace QuantLib {

    CEVRNDCalculator::CEVRNDCalculator(Real f0, Real alpha, Real beta)
    : f0_(f0),
      alpha_(alpha),
      beta_(beta),
      delta_((1.0-2.0*beta)/(1.0-beta)),
      x0_(X(f0)) {
        QL_REQUIRE(beta != 1.0, "beta can not be one");
    }

    Real CEVRNDCalculator::massAtZero(Time t) const {
        if (delta_ < 2.0)
            return 1.0-boost::math::gamma_p(-0.5*delta_+1.0,x0_/(2.0*t));
        else
            return 0.0;
    }

    Real CEVRNDCalculator::X(Real f) const {
        return std::pow(f, 2.0*(1.0-beta_))/square<Real>()(alpha_*(1.0-beta_));
    }

    Real CEVRNDCalculator::invX(Real x) const {
        return std::pow(x*square<Real>()(alpha_*(1.0-beta_)),
                        1.0/(2.0*(1.0-beta_)));
    }

    Real CEVRNDCalculator::pdf(Real f, Time t) const {
        const Real y = X(f);

        if (delta_ < 2.0) {
            return boost::math::pdf(
                boost::math::non_central_chi_squared_distribution<Real>(
                    4.0-delta_, y/t), x0_/t)/t * 2.0*(1.0-beta_)*y/f;
        }
        else {
            return boost::math::pdf(
                boost::math::non_central_chi_squared_distribution<Real>(
                    delta_, x0_/t), y/t)/t * 2.0*(beta_-1.0)*y/f;
        }
    }

    Real CEVRNDCalculator::cdf(Real f, Time t) const {
        const Real y = X(f);

        if (delta_ < 2.0)
            return 1.0 - boost::math::cdf(
                boost::math::non_central_chi_squared_distribution<Real>(
                    2.0-delta_, y/t), x0_/t);
        else
            return 1.0 - boost::math::cdf(
                boost::math::non_central_chi_squared_distribution<Real>(
                    delta_, x0_/t), y/t);
    }

    Real CEVRNDCalculator::sankaranApprox(Real c, Time t, Real x) const {
        const Real a = x0_/t;
        const Real b = 2.0 - delta_;

        c = std::max(c, -0.45*b);

        const Real h = 1 - 2*(b+c)*(b+3*c)/(3*square<Real>()(b+2*c));
        const Real p = (b+2*c)/square<Real>()(b+c);
        const Real m = (h-1)*(1-3*h);

        const Real u = (std::pow(a/(b+c), h) - (1 + h*p*(h-1-0.5*(2-h)*m*p)))/
                (h*std::sqrt(2*p)*(1+0.5*m*p));

        return u - x;
    }

    Real CEVRNDCalculator::invcdf(Real q, Time t) const {
        if (delta_ < 2.0) {
            if (f0_ < QL_EPSILON || q < massAtZero(t))
                return 0.0;

            const Real x = InverseCumulativeNormal()(1-q);

            auto cdfApprox = [&](Real _c){ return sankaranApprox(_c, t, x); };

            const Real y0 = X(f0_)/t;

            try {
                Brent brent;
                brent.setMaxEvaluations(20);
                const Real guess =
                    invX(brent.solve(cdfApprox, 1e-8, y0, 0.02*y0) * t);

                return InvCDFHelper(this, guess, 1e-8, 100).inverseCDF(q, t);
            }
            catch (...) {
                return InvCDFHelper(this, f0_, 1e-8, 100).inverseCDF(q, t);
            }
        }
        else {
            const Real x = t * boost::math::quantile(
                boost::math::non_central_chi_squared_distribution<Real>(
                    delta_, x0_/t), 1-q);
            return invX(x);
        }
    }
}
]]></document_content>
  </document>
  <document index="63">
    <source>finitedifferences/utilities/escroweddividendadjustment.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file escroweddividendadjustment.cpp
*/
#include <ql/methods/finitedifferences/utilities/escroweddividendadjustment.hpp>

namespace QuantLib {

    EscrowedDividendAdjustment::EscrowedDividendAdjustment(
        DividendSchedule dividendSchedule,
        Handle<YieldTermStructure> rTS,
        Handle<YieldTermStructure> qTS,
        ext::function<Real(Date)> toTime,
        Time maturity)
    : dividendSchedule_(std::move(dividendSchedule)),
      rTS_(std::move(rTS)), qTS_(std::move(qTS)),
      toTime_(std::move(toTime)), maturity_(maturity) {}


    Real EscrowedDividendAdjustment::dividendAdjustment(Time t) const {

        Real divAdj = 0.0;
        for (auto const& dividend: dividendSchedule_) {
            const Time divTime = toTime_(dividend->date());

            if (divTime >= t && t <= maturity_)
                divAdj -= dividend->amount()
                    * rTS_->discount(divTime) / rTS_->discount(t)
                    * qTS_->discount(t) / qTS_->discount(divTime);
        }

        return divAdj;
    }

    const Handle<YieldTermStructure>&
    EscrowedDividendAdjustment::riskFreeRate() const {
        return rTS_;
    }

    const Handle<YieldTermStructure>&
    EscrowedDividendAdjustment::dividendYield() const {
        return qTS_;
    }
}
]]></document_content>
  </document>
  <document index="64">
    <source>finitedifferences/utilities/fdmaffinemodelswapinnervalue.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file FdmAffineModelswapinnervalue.cpp
*/

#include <ql/models/shortrate/twofactormodels/g2.hpp>
#include <ql/models/shortrate/onefactormodels/hullwhite.hpp>
#include <ql/methods/finitedifferences/utilities/fdmaffinemodelswapinnervalue.hpp>

namespace QuantLib {

    template <>
    Disposable<Array> FdmAffineModelSwapInnerValue<HullWhite>::getState(
        const ext::shared_ptr<HullWhite>& model, Time t,
        const FdmLinearOpIterator& iter) const {

        Array retVal(1, model->dynamics()->shortRate(t,
                                    mesher_->location(iter, direction_)));
        return retVal;
    }

    template <>
    Disposable<Array> FdmAffineModelSwapInnerValue<G2>::getState(
        const ext::shared_ptr<G2>&, Time,
        const FdmLinearOpIterator& iter) const {

        Array retVal(2);
        retVal[0] = mesher_->location(iter, direction_);
        retVal[1] = mesher_->location(iter, direction_+1);

        return retVal;
    }

}
]]></document_content>
  </document>
  <document index="65">
    <source>finitedifferences/utilities/fdmaffinemodeltermstructure.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmaffinemodeltermstructure.cpp
*/

#include <ql/methods/finitedifferences/utilities/fdmaffinemodeltermstructure.hpp>
#include <ql/models/model.hpp>
#include <utility>

namespace QuantLib {

    FdmAffineModelTermStructure::FdmAffineModelTermStructure(Array r,
                                                             const Calendar& cal,
                                                             const DayCounter& dayCounter,
                                                             const Date& referenceDate,
                                                             const Date& modelReferenceDate,
                                                             ext::shared_ptr<AffineModel> model)
    : YieldTermStructure(referenceDate, cal, dayCounter), r_(std::move(r)),
      t_(dayCounter.yearFraction(modelReferenceDate, referenceDate)), model_(std::move(model)) {
        registerWith(model_);
    }

    Date FdmAffineModelTermStructure::maxDate() const {
        return Date::maxDate();
    }

    void FdmAffineModelTermStructure::setVariable(const Array& r) {
        r_ = r;
        notifyObservers();
    }

    DiscountFactor FdmAffineModelTermStructure::discountImpl(Time T) const {
        return model_->discountBond(t_, T+t_, r_);
    }
}
]]></document_content>
  </document>
  <document index="66">
    <source>finitedifferences/utilities/fdmdirichletboundary.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdirichletboundary.hpp>
#include <ql/methods/finitedifferences/utilities/fdmindicesonboundary.hpp>

namespace QuantLib {

    FdmDirichletBoundary::FdmDirichletBoundary(
                            const ext::shared_ptr<FdmMesher>& mesher,
                            Real valueOnBoundary, Size direction,
                            FdmDirichletBoundary::Side side)
    : side_(side),
      valueOnBoundary_(valueOnBoundary),
      indices_(FdmIndicesOnBoundary(mesher->layout(),
                                    direction, side).getIndices()) {

        if (side_ == Lower) {
            xExtreme_ = mesher->locations(direction)[0];
        }
        else if (side_ == Upper) {
            xExtreme_ = mesher
                ->locations(direction)[mesher->layout()->dim()[direction]-1];
        }
        else {
            QL_FAIL("internal error");
        }
    }

    void FdmDirichletBoundary::applyBeforeApplying(operator_type&) const {
    }

    void FdmDirichletBoundary::applyAfterApplying(Array& x) const {
        for (unsigned long indice : indices_) {
            x[indice] = valueOnBoundary_;
        }
    }
    
    void FdmDirichletBoundary::applyBeforeSolving(operator_type&,
                                                  array_type&) const {
    }

    void FdmDirichletBoundary::applyAfterSolving(Array& rhs) const {
        this->applyAfterApplying(rhs);
    }
    
    Real FdmDirichletBoundary::applyAfterApplying(Real x, Real value) const {
        return (   (side_ == Lower && x < xExtreme_) 
                || (side_ == Upper && x > xExtreme_)) ? valueOnBoundary_ : value;
    }
}
]]></document_content>
  </document>
  <document index="67">
    <source>finitedifferences/utilities/fdmdiscountdirichletboundary.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2019 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


/*! \file fdmdiscountdirichletboundary.cpp */

#include <ql/methods/finitedifferences/utilities/fdmdiscountdirichletboundary.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    namespace {
        class DiscountedCashflowAtBoundary {
          public:
            DiscountedCashflowAtBoundary(Time maturityTime,
                                         Real valueOnBoundary,
                                         ext::shared_ptr<YieldTermStructure> rTS)
            : maturityTime_(maturityTime), cashFlow_(valueOnBoundary), rTS_(std::move(rTS)) {}

            Real operator()(Real t) const {
                return cashFlow_
                    * rTS_->discount(maturityTime_)/rTS_->discount(t);
            }

          private:
            const Time maturityTime_;
            const Real cashFlow_;
            const ext::shared_ptr<YieldTermStructure> rTS_;
        };
    }

    FdmDiscountDirichletBoundary::FdmDiscountDirichletBoundary(
        const ext::shared_ptr<FdmMesher>& mesher,
        const ext::shared_ptr<YieldTermStructure>& rTS,
        Time maturityTime,
        Real valueOnBoundary,
        Size direction, Side side)
    : bc_(ext::make_shared<FdmTimeDepDirichletBoundary>(
            mesher,
            ext::function<Real (Real)>(
                DiscountedCashflowAtBoundary(
                    maturityTime, valueOnBoundary, rTS)),
            direction, side)) {
    }

    void FdmDiscountDirichletBoundary::setTime(Time t) {
        bc_->setTime(t);
    }
    void FdmDiscountDirichletBoundary::applyBeforeApplying(
        operator_type& op) const {
        bc_->applyBeforeApplying(op);
    }
    void FdmDiscountDirichletBoundary::applyBeforeSolving(
        operator_type& op, array_type& r) const {
        bc_->applyBeforeSolving(op, r);
    }
    void FdmDiscountDirichletBoundary::applyAfterApplying(array_type& r) const {
        bc_->applyAfterApplying(r);
    }
    void FdmDiscountDirichletBoundary::applyAfterSolving(array_type& r) const {
        bc_->applyAfterSolving(r);
    }
}
]]></document_content>
  </document>
  <document index="68">
    <source>finitedifferences/utilities/fdmdividendhandler.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/time/daycounter.hpp>
#include <ql/math/interpolations/linearinterpolation.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/utilities/fdmdividendhandler.hpp>

namespace QuantLib {


    FdmDividendHandler::FdmDividendHandler(
        const DividendSchedule& schedule,
        const ext::shared_ptr<FdmMesher>& mesher,
        const Date& referenceDate,
        const DayCounter& dayCounter,
        Size equityDirection)
    : x_(mesher->layout()->dim()[equityDirection]),
      mesher_(mesher),
      equityDirection_(equityDirection) {

        dividends_.reserve(schedule.size());
        dividendDates_.reserve(schedule.size());
        dividendTimes_.reserve(schedule.size());
        for (const auto& iter : schedule) {
            dividends_.push_back(iter->amount());
            dividendDates_.push_back(iter->date());
            dividendTimes_.push_back(dayCounter.yearFraction(referenceDate, iter->date()));
        }

         Array tmp = mesher_->locations(equityDirection);
         Size spacing = mesher_->layout()->spacing()[equityDirection];
         for (Size i = 0; i < x_.size(); ++i) {
             x_[i] = std::exp(tmp[i*spacing]);
         }
    }

    const std::vector<Time>& FdmDividendHandler::dividendTimes() const {
        return dividendTimes_;
    }
         
    const std::vector<Date>& FdmDividendHandler::dividendDates() const {
        return dividendDates_;
    }

    const std::vector<Real>& FdmDividendHandler::dividends() const {
        return dividends_;
    }

    void FdmDividendHandler::applyTo(Array& a, Time t) const {
        Array aCopy(a);

        auto iter = std::find(dividendTimes_.begin(), dividendTimes_.end(), t);

        if (iter != dividendTimes_.end()) {
            const Real dividend = dividends_[iter - dividendTimes_.begin()];

            if (mesher_->layout()->dim().size() == 1) {
                LinearInterpolation interp(x_.begin(), x_.end(), aCopy.begin());
                for (Size k=0; k<x_.size(); ++k) {
                    a[k] = interp(std::max(x_[0], x_[k]-dividend), true);
                }
            }
            else {
                Array tmp(x_.size());
                Size xSpacing = mesher_->layout()->spacing()[equityDirection_];
                
                for (Size i=0; i<mesher_->layout()->dim().size(); ++i) {
                    if (i!=equityDirection_) {
                        Size ySpacing = mesher_->layout()->spacing()[i];
                        for (Size j=0; j<mesher_->layout()->dim()[i]; ++j) {
                            for (Size k=0; k<x_.size(); ++k) {
                                Size index = j*ySpacing + k*xSpacing;
                                tmp[k] = aCopy[index];
                            }
                            LinearInterpolation interp(x_.begin(), x_.end(),
                                                       tmp.begin());
                            for (Size k=0; k<x_.size(); ++k) {
                                Size index = j*ySpacing + k*xSpacing;
                                a[index] = interp(
                                        std::max(x_[0], x_[k]-dividend), true);
                            }
                        }
                    }
                }
            }
        }
    }
}
]]></document_content>
  </document>
  <document index="69">
    <source>finitedifferences/utilities/fdmescrowedloginnervaluecalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmescrowedloginnervaluecalculator.cpp
*/

#include <ql/instruments/payoffs.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/utilities/fdmescrowedloginnervaluecalculator.hpp>

namespace QuantLib {

    FdmEscrowedLogInnerValueCalculator::FdmEscrowedLogInnerValueCalculator(
        ext::shared_ptr<EscrowedDividendAdjustment> escrowedDividendAdj,
        ext::shared_ptr<Payoff> payoff,
        ext::shared_ptr<FdmMesher> mesher,
        Size direction)
    : escrowedDividendAdj_(std::move(escrowedDividendAdj)),
      payoff_(std::move(payoff)), mesher_(std::move(mesher)),
      direction_(direction) {}

    Real FdmEscrowedLogInnerValueCalculator::innerValue(
        const FdmLinearOpIterator& iter, Time t) {

        const Real s_t = std::exp(mesher_->location(iter, direction_));
        const Real spot = s_t - escrowedDividendAdj_->dividendAdjustment(t);

        return (*payoff_)(spot);
    }

    Real FdmEscrowedLogInnerValueCalculator::avgInnerValue(
        const FdmLinearOpIterator& iter, Time t) {
        return innerValue(iter, t);
    }
}
]]></document_content>
  </document>
  <document index="70">
    <source>finitedifferences/utilities/fdmindicesonboundary.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/utilities/fdmindicesonboundary.hpp>

namespace QuantLib {
    FdmIndicesOnBoundary::FdmIndicesOnBoundary(
        const ext::shared_ptr<FdmLinearOpLayout>& layout,
        Size direction, FdmDirichletBoundary::Side side) {

        std::vector<Size> newDim(layout->dim());
        newDim[direction] = 1;
        const Size hyperSize
            = std::accumulate(newDim.begin(), newDim.end(), Size(1),
                              std::multiplies<Size>());
        indices_.resize(hyperSize);

        Size i=0;
        const FdmLinearOpIterator endIter = layout->end();
        for (FdmLinearOpIterator iter = layout->begin(); iter != endIter;
            ++iter) {
            if (   (   side == FdmDirichletBoundary::Lower
                    && iter.coordinates()[direction] == 0)
                || (   side == FdmDirichletBoundary::Upper
                    && iter.coordinates()[direction]
                                            == layout->dim()[direction]-1)) {
                QL_REQUIRE(hyperSize > i, "index missmatch");
                indices_[i++] = iter.index();
            }
        }


    }

    const std::vector<Size>& FdmIndicesOnBoundary::getIndices() const {
        return indices_;
    }
}
]]></document_content>
  </document>
  <document index="71">
    <source>finitedifferences/utilities/fdminnervaluecalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdminnervaluecalculator.cpp
    \brief layer of abstraction to calculate the inner value
*/

#include <ql/instruments/basketoption.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/integrals/simpsonintegral.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/utilities/fdminnervaluecalculator.hpp>
#include <ql/payoff.hpp>
#include <deque>
#include <utility>

namespace QuantLib {

    namespace {
        struct mapped_payoff {
            explicit mapped_payoff(
                const Payoff& payoff,
                const ext::function<Real(Real)>& gridMapping)
            : payoff(payoff), gridMapping_(gridMapping) {}

            Real operator()(Real x) const { return payoff(gridMapping_(x)); }

            const Payoff& payoff;
            const ext::function<Real(Real)>& gridMapping_;
        };
    }

    FdmCellAveragingInnerValue::FdmCellAveragingInnerValue(ext::shared_ptr<Payoff> payoff,
                                                           ext::shared_ptr<FdmMesher> mesher,
                                                           Size direction,
                                                           ext::function<Real(Real)> gridMapping)
    : payoff_(std::move(payoff)), mesher_(std::move(mesher)), direction_(direction),
      gridMapping_(std::move(gridMapping)) {}

    Real FdmCellAveragingInnerValue::innerValue(const FdmLinearOpIterator& iter, Time) {
        const Real loc = mesher_->location(iter, direction_);
        return (*payoff_)(gridMapping_(loc));
    }

    Real FdmCellAveragingInnerValue::avgInnerValue(const FdmLinearOpIterator& iter, Time t) {
        if (avgInnerValues_.empty()) {
            // calculate caching values
            avgInnerValues_.resize(mesher_->layout()->dim()[direction_]);
            std::deque<bool> initialized(avgInnerValues_.size(), false);

            const ext::shared_ptr<FdmLinearOpLayout> layout =
                mesher_->layout();
            const FdmLinearOpIterator endIter = layout->end();
            for (FdmLinearOpIterator i = layout->begin(); i != endIter; ++i) {
                const Size xn = i.coordinates()[direction_];
                if (!initialized[xn]) {
                    initialized[xn]     = true;
                    avgInnerValues_[xn] = avgInnerValueCalc(i, t);
                }
            }
        }

        return avgInnerValues_[iter.coordinates()[direction_]];
    }

    Real FdmCellAveragingInnerValue::avgInnerValueCalc(const FdmLinearOpIterator& iter, Time t) {
        const Size dim = mesher_->layout()->dim()[direction_];
        const Size coord = iter.coordinates()[direction_];

        if (coord == 0 || coord == dim-1)
            return innerValue(iter, t);

        const Real loc = mesher_->location(iter,direction_);
        const Real a = loc - mesher_->dminus(iter, direction_)/2.0;
        const Real b = loc + mesher_->dplus(iter, direction_)/2.0;

        mapped_payoff f(*payoff_, gridMapping_);

        Real retVal;
        try {
            const Real acc
                = ((f(a) != 0.0 || f(b) != 0.0) ? (f(a)+f(b))*5e-5 : 1e-4);
            retVal = SimpsonIntegral(acc, 8)(f, a, b)/(b-a);
        }
        catch (Error&) {
            // use default value
            retVal = innerValue(iter, t);
        }

        return retVal;
    }

    namespace {
        typedef Real (*Real2RealFct)(Real);
    }

    FdmLogInnerValue::FdmLogInnerValue(
        const ext::shared_ptr<Payoff>& payoff,
        const ext::shared_ptr<FdmMesher>& mesher,
        Size direction)
    : FdmCellAveragingInnerValue(
        payoff, mesher, direction,
        ext::function<Real(Real)>(static_cast<Real2RealFct>(std::exp))) {
    }


    FdmLogBasketInnerValue::FdmLogBasketInnerValue(ext::shared_ptr<BasketPayoff> payoff,
                                                   ext::shared_ptr<FdmMesher> mesher)
    : payoff_(std::move(payoff)), mesher_(std::move(mesher)) {}

    Real FdmLogBasketInnerValue::innerValue(
                                    const FdmLinearOpIterator& iter, Time) {
        Array x(mesher_->layout()->dim().size());
        for (Size i=0; i < x.size(); ++i) {
            x[i] = std::exp(mesher_->location(iter, i));
        }
        
        return (*payoff_)(x);
    }
    
    Real 
    FdmLogBasketInnerValue::avgInnerValue(
                                    const FdmLinearOpIterator& iter, Time t) {
        return innerValue(iter, t);
    }
}
]]></document_content>
  </document>
  <document index="72">
    <source>finitedifferences/utilities/fdmmesherintegral.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include <ql/methods/finitedifferences/operators/fdmlinearoplayout.hpp>
#include <ql/methods/finitedifferences/utilities/fdmmesherintegral.hpp>

namespace QuantLib {
    FdmMesherIntegral::FdmMesherIntegral(
        const ext::shared_ptr<FdmMesherComposite>& mesher,
        const ext::function<Real(const Array&, const Array&)>& integrator1d)
    : meshers_(mesher->getFdm1dMeshers().begin(),
               mesher->getFdm1dMeshers().end()),
      integrator1d_(integrator1d) {
    }

    Real FdmMesherIntegral::integrate(const Array& f) const {
        const Array x(meshers_.back()->locations().begin(),
                      meshers_.back()->locations().end());

        if (meshers_.size() == 1) {
            return integrator1d_(x, f);
        }

        const ext::shared_ptr<FdmMesherComposite> subMesher(
            new FdmMesherComposite(
                std::vector<ext::shared_ptr<Fdm1dMesher> >(
                    meshers_.begin(), meshers_.end()-1)));

        FdmMesherIntegral subMesherIntegral(subMesher, integrator1d_);
        const Size subSize = subMesher->layout()->size();

        Array g(x.size()), fSub(subSize);

        for (Size i=0; i < x.size(); ++i) {
            std::copy(f.begin() + i    *subSize,
                      f.begin() + (i+1)*subSize, fSub.begin());

            g[i] = subMesherIntegral.integrate(fSub);
        }

        return integrator1d_(x, g);
    }
}
]]></document_content>
  </document>
  <document index="73">
    <source>finitedifferences/utilities/fdmquantohelper.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 Ralph Schreyer
 Copyright (C) 2008, 2009 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmquantohelper.cpp
\brief quanto helper to store market data needed for the quanto adjustment.
*/

#include <ql/methods/finitedifferences/utilities/fdmquantohelper.hpp>
#include <ql/termstructures/volatility/equityfx/blackvoltermstructure.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    FdmQuantoHelper::FdmQuantoHelper(ext::shared_ptr<YieldTermStructure> rTS,
                                     ext::shared_ptr<YieldTermStructure> fTS,
                                     ext::shared_ptr<BlackVolTermStructure> fxVolTS,
                                     Real equityFxCorrelation,
                                     Real exchRateATMlevel)
    : rTS_(std::move(rTS)), fTS_(std::move(fTS)), fxVolTS_(std::move(fxVolTS)),
      equityFxCorrelation_(equityFxCorrelation), exchRateATMlevel_(exchRateATMlevel) {}

    Rate FdmQuantoHelper::quantoAdjustment(Volatility equityVol,
                                                 Time t1, Time t2) const {
        const Rate rDomestic = rTS_->forwardRate(t1, t2, Continuous).rate();
        const Rate rForeign  = fTS_->forwardRate(t1, t2, Continuous).rate();
        const Volatility fxVol
            = fxVolTS_->blackForwardVol(t1, t2, exchRateATMlevel_);

        return rDomestic - rForeign + equityVol*fxVol*equityFxCorrelation_;
    }

    Disposable<Array> FdmQuantoHelper::quantoAdjustment(
        const Array& equityVol, Time t1, Time t2) const {

        const Rate rDomestic = rTS_->forwardRate(t1, t2, Continuous).rate();
        const Rate rForeign  = fTS_->forwardRate(t1, t2, Continuous).rate();
        const Volatility fxVol
            = fxVolTS_->blackForwardVol(t1, t2, exchRateATMlevel_);

        Array retVal(equityVol.size());
        for (Size i=0; i < retVal.size(); ++i) {
            retVal[i]
                = rDomestic - rForeign + equityVol[i]*fxVol*equityFxCorrelation_;
        }
        return retVal;
    }
}
]]></document_content>
  </document>
  <document index="74">
    <source>finitedifferences/utilities/fdmshoutloginnervaluecalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fdmshoutinnervaluecalculator.cpp
    \brief inner value for a shout option
*/

#include <ql/instruments/payoffs.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/utilities/fdmshoutloginnervaluecalculator.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/termstructures/volatility/equityfx/blackvoltermstructure.hpp>

#include <utility>

namespace QuantLib {

    FdmShoutLogInnerValueCalculator::FdmShoutLogInnerValueCalculator(
        Handle<BlackVolTermStructure> blackVolatility,
        ext::shared_ptr<EscrowedDividendAdjustment> escrowedDividendAdj,
        Time maturity,
        ext::shared_ptr<PlainVanillaPayoff> payoff,
        ext::shared_ptr<FdmMesher> mesher,
        Size direction)
    : blackVolatility_(std::move(blackVolatility)),
      escrowedDividendAdj_(std::move(escrowedDividendAdj)),
      maturity_(maturity), payoff_(std::move(payoff)),
      mesher_(std::move(mesher)), direction_(direction) {}


    Real FdmShoutLogInnerValueCalculator::innerValue(
        const FdmLinearOpIterator& iter, Time t) {

        const Real s_t = std::exp(mesher_->location(iter, direction_));

        const DiscountFactor qf =
            escrowedDividendAdj_->dividendYield()->discount(maturity_)/
            escrowedDividendAdj_->dividendYield()->discount(t);

        const DiscountFactor df =
            escrowedDividendAdj_->riskFreeRate()->discount(maturity_)/
            escrowedDividendAdj_->riskFreeRate()->discount(t);

        const Real fwd = s_t*qf/df;
        const Volatility stdDev = blackVolatility_->blackForwardVol(
            t, maturity_, s_t)*std::sqrt(maturity_-t);

        const Real npv = blackFormula(
            payoff_->optionType(), s_t, fwd, stdDev, df);

        const Real spot = s_t - escrowedDividendAdj_->dividendAdjustment(t);

        const Real intrinsic = (payoff_->optionType() == Option::Call)
            ? spot - payoff_->strike() : payoff_->strike() - spot;

        return std::max(0.0, npv + intrinsic*df);
    }

    Real FdmShoutLogInnerValueCalculator::avgInnerValue(
        const FdmLinearOpIterator& iter, Time t) {
        return innerValue(iter, t);
    }
}
]]></document_content>
  </document>
  <document index="75">
    <source>finitedifferences/utilities/fdmtimedepdirichletboundary.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


/*! \file fdmtimedepdirichletboundary.cpp
*/

#include <ql/methods/finitedifferences/meshers/fdmmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlinearop.hpp>
#include <ql/methods/finitedifferences/utilities/fdmindicesonboundary.hpp>
#include <ql/methods/finitedifferences/utilities/fdmtimedepdirichletboundary.hpp>
#include <algorithm>
#include <utility>

namespace QuantLib {

    FdmTimeDepDirichletBoundary::FdmTimeDepDirichletBoundary(
        const ext::shared_ptr<FdmMesher>& mesher,
        ext::function<Real(Real)> valueOnBoundary,
        Size direction,
        Side side)
    : indices_(FdmIndicesOnBoundary(mesher->layout(), direction, side).getIndices()),
      valueOnBoundary_(std::move(valueOnBoundary)), values_(indices_.size()) {}

    FdmTimeDepDirichletBoundary::FdmTimeDepDirichletBoundary(
        const ext::shared_ptr<FdmMesher>& mesher,
        ext::function<Disposable<Array>(Real)> valuesOnBoundary,
        Size direction,
        Side side)
    : indices_(FdmIndicesOnBoundary(mesher->layout(), direction, side).getIndices()),
      valuesOnBoundary_(std::move(valuesOnBoundary)), values_(indices_.size()) {}

    void FdmTimeDepDirichletBoundary::setTime(Time t) {
        if (!(valueOnBoundary_ == QL_NULL_FUNCTION)) {
            std::fill(values_.begin(), values_.end(), valueOnBoundary_(t));
        } else if (!(valuesOnBoundary_ == QL_NULL_FUNCTION)) {
            values_ = valuesOnBoundary_(t);
        } else {
            QL_FAIL("no boundary values defined");
        }
    }

    void FdmTimeDepDirichletBoundary::applyAfterApplying(array_type& a) const {
        QL_REQUIRE(indices_.size() == values_.size(),
                   "values on boundary size (" << values_.size()
                   << ") does not match hypersurface size ("
                   << indices_.size() << ")");
        for (auto iter = indices_.begin(); iter != indices_.end(); ++iter) {
            a[*iter] = values_[iter - indices_.begin()];
        }
    }

    void FdmTimeDepDirichletBoundary::applyAfterSolving(array_type& a) const {
        this->applyAfterApplying(a);
    }
}
]]></document_content>
  </document>
  <document index="76">
    <source>finitedifferences/utilities/gbsmrndcalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2017 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gbsmrndcalculator.hpp
    \brief risk neutral terminal density calculator for the
           Black-Scholes-Merton model with skew dependent volatility
*/

#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/functional.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/methods/finitedifferences/utilities/gbsmrndcalculator.hpp>
#include <ql/pricingengines/blackcalculator.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    GBSMRNDCalculator::GBSMRNDCalculator(ext::shared_ptr<GeneralizedBlackScholesProcess> process)
    : process_(std::move(process)) {}

    Real GBSMRNDCalculator::pdf(Real k, Time t) const {
        const Real dk = 1e-3*k;

        return (cdf(k+dk, t) - cdf(k-dk, t)) / (2*dk);
    }

    Real GBSMRNDCalculator::cdf(Real k, Time t) const {
        const Handle<BlackVolTermStructure> volTS
            = process_->blackVolatility();

        const Real dk = 1e-3*k;
        const Real dvol_dk
            = (volTS->blackVol(t, k+dk) - volTS->blackVol(t, k-dk)) / (2*dk);

        const DiscountFactor dR
            = process_->riskFreeRate()->discount(t, true);
        const DiscountFactor dD
            = process_->dividendYield()->discount(t, true);

        const Real forward = process_->x0() * dD / dR;
        const Real stdDev = std::sqrt(
            process_->blackVolatility()->blackVariance(t, k, true));

        if (forward <= k) {
            const BlackCalculator calc(Option::Call, k, forward, stdDev, dR);

            return 1.0 + (  calc.strikeSensitivity()
                          + calc.vega(t) * dvol_dk) /dR;
        }
        else {
            const BlackCalculator calc(Option::Put, k, forward, stdDev, dR);

            return (  calc.strikeSensitivity()
                    + calc.vega(t) * dvol_dk) /dR;
        }
    }

    Real GBSMRNDCalculator::invcdf(Real q, Time t) const {
        const Real fwd = process_->x0()
            / process_->riskFreeRate()->discount(t, true)
            * process_->dividendYield()->discount(t, true);

        const Volatility atmVariance = std::sqrt(
            process_->blackVolatility()->blackVariance(t, fwd, true));

        const Real atmX = InverseCumulativeNormal()(q);

        const Real guess = fwd*std::exp(atmVariance*atmX);

        Real lower = guess;
        while (guess/lower < 65535.0 && cdf(lower, t) > q)
            lower*=0.5;

        Real upper = guess;
        while (upper/guess < 65535.0 && cdf(upper, t) < q) upper*=2;

        QL_REQUIRE(guess/lower < 65535.0 && upper/guess < 65535.0,
                "Could not find an start interval with ("
                << lower << ", " << upper << ") -> ("
                << cdf(lower, t) << ", " << cdf(upper, t) << ")");

        return Brent().solve(
            [&](Real _k){ return cdf(_k, t) - q; },
            1e-10, 0.5*(lower+upper), lower, upper);
    }
}
]]></document_content>
  </document>
  <document index="77">
    <source>finitedifferences/utilities/hestonrndcalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes GÃ¶ttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/functional.hpp>
#include <ql/math/integrals/gausslobattointegral.hpp>
#include <ql/methods/finitedifferences/utilities/bsmrndcalculator.hpp>
#include <ql/methods/finitedifferences/utilities/hestonrndcalculator.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/hestonprocess.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <complex>
#include <utility>

namespace QuantLib {

namespace {
        struct HestonParams {
            Real v0, kappa, theta, sigma, rho;
        };

        HestonParams getHestonParams(
            const ext::shared_ptr<HestonProcess>& process) {
            const HestonParams p = { process->v0(),    process->kappa(),
                                     process->theta(), process->sigma(),
                                     process->rho() };
            return p;
        }

        std::complex<Real> gamma(const HestonParams& p, Real p_x) {
            return std::complex<Real>(p.kappa, p.rho*p.sigma*p_x);
        }

        std::complex<Real> omega(const HestonParams& p, Real p_x) {
           const std::complex<Real> g = gamma(p, p_x);
           return std::sqrt(g*g
                  + p.sigma*p.sigma*std::complex<Real>(p_x*p_x, -p_x));
        }

        class CpxPv_Helper {
          public:
            CpxPv_Helper(const HestonParams& p, Real x, Time t)
              : p_(p), t_(t), x_(x),
                c_inf_(std::min(10.0, std::max(0.0001,
                      std::sqrt(1.0-square<Real>()(p_.rho))/p_.sigma))
                      *(p_.v0 + p_.kappa*p_.theta*t))  {}

            Real operator()(Real x) const {
                return std::real(transformPhi(x));
            }

            Real p0(Real p_x) const {
                if (p_x < QL_EPSILON) {
                    return 0.0;
                }

                const Real u_x = std::max(QL_EPSILON, -std::log(p_x)/c_inf_);
                return std::real(phi(u_x)
                        /((p_x*c_inf_)*std::complex<Real>(0.0, u_x)));
            }

          private:
            std::complex<Real> transformPhi(Real x) const {
                if (x < QL_EPSILON) {
                    return std::complex<Real>(0.0, 0.0);
                }

                const Real u_x = -std::log(x)/c_inf_;
                return phi(u_x)/(x*c_inf_);
            }

            std::complex<Real> phi(Real p_x) const {
                const Real sigma2 = p_.sigma*p_.sigma;
                const std::complex<Real> g = gamma(p_, p_x);
                const std::complex<Real> o = omega(p_, p_x);
                const std::complex<Real> gamma = (g-o)/(g+o);

                return 2.0*std::exp(std::complex<Real>(0.0, p_x*x_)
                        - p_.v0*std::complex<Real>(p_x*p_x, -p_x)
                          /(g+o*(1.0+std::exp(-o*t_))/(1.0-std::exp(-o*t_)))
                         +p_.kappa*p_.theta/sigma2*(
                           (g-o)*t_ - 2.0*std::log((1.0-gamma*std::exp(-o*t_))
                                                               /(1.0-gamma))));
            }

            const HestonParams p_;
            const Time t_;
            const Real x_, c_inf_;
        };
    }


    HestonRNDCalculator::HestonRNDCalculator(ext::shared_ptr<HestonProcess> hestonProcess,
                                             Real integrationEps,
                                             Size maxIntegrationIterations)
    : hestonProcess_(std::move(hestonProcess)), x0_(std::log(hestonProcess_->s0()->value())),
      integrationEps_(integrationEps), maxIntegrationIterations_(maxIntegrationIterations) {}

    Real HestonRNDCalculator::x_t(Real x, Time t) const {
        const DiscountFactor dr = hestonProcess_->riskFreeRate()->discount(t);
        const DiscountFactor dq = hestonProcess_->dividendYield()->discount(t);

        return x - x0_ + std::log(dr/dq);
    }

    Real HestonRNDCalculator::pdf(Real x, Time t) const {
        return GaussLobattoIntegral(
            maxIntegrationIterations_, 0.1*integrationEps_)(
            CpxPv_Helper(getHestonParams(hestonProcess_), x_t(x, t), t),
            0.0, 1.0)/M_TWOPI;
    }

    Real HestonRNDCalculator::cdf(Real x, Time t) const {
        CpxPv_Helper helper(getHestonParams(hestonProcess_), x_t(x, t), t);

        return GaussLobattoIntegral(maxIntegrationIterations_, 0.1*integrationEps_)(
            [&](Real p_x){ return helper.p0(p_x); },
            0.0, 1.0)/M_TWOPI + 0.5;
    }

    Real HestonRNDCalculator::invcdf(Real p, Time t) const {
        const Real v0    = hestonProcess_->v0();
        const Real kappa = hestonProcess_->kappa();
        const Real theta = hestonProcess_->theta();

        const Volatility expVol
            = std::sqrt(theta + (v0-theta)*(1-std::exp(-kappa*t))/(t*kappa));

        const ext::shared_ptr<BlackScholesMertonProcess> bsmProcess(
            ext::make_shared<BlackScholesMertonProcess>(
                hestonProcess_->s0(),
                hestonProcess_->dividendYield(),
                hestonProcess_->riskFreeRate(),
                Handle<BlackVolTermStructure>(
                    ext::make_shared<BlackConstantVol>(
                            hestonProcess_->riskFreeRate()->referenceDate(),
                            NullCalendar(),
                            expVol,
                            hestonProcess_->riskFreeRate()->dayCounter()))));

        const Real guess = BSMRNDCalculator(bsmProcess).invcdf(p, t);

        return RiskNeutralDensityCalculator::InvCDFHelper(
            this, guess, 0.1*integrationEps_, maxIntegrationIterations_)
            .inverseCDF(p, t);
    }
}
]]></document_content>
  </document>
  <document index="78">
    <source>finitedifferences/utilities/localvolrndcalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes GÃ¶ttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file localvolendcalculator.cpp
    \brief local volatility risk neutral terminal density calculation
*/

#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/math/integrals/discreteintegrals.hpp>
#include <ql/math/integrals/gausslobattointegral.hpp>
#include <ql/math/interpolations/cubicinterpolation.hpp>
#include <ql/methods/finitedifferences/meshers/concentrating1dmesher.hpp>
#include <ql/methods/finitedifferences/meshers/fdmmeshercomposite.hpp>
#include <ql/methods/finitedifferences/meshers/predefined1dmesher.hpp>
#include <ql/methods/finitedifferences/operators/fdmlocalvolfwdop.hpp>
#include <ql/methods/finitedifferences/schemes/douglasscheme.hpp>
#include <ql/methods/finitedifferences/utilities/localvolrndcalculator.hpp>
#include <ql/quote.hpp>
#include <ql/termstructures/volatility/equityfx/localvoltermstructure.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/timegrid.hpp>
#include <utility>


namespace QuantLib {
    LocalVolRNDCalculator::LocalVolRNDCalculator(
        ext::shared_ptr<Quote> spot,
        ext::shared_ptr<YieldTermStructure> rTS,
        ext::shared_ptr<YieldTermStructure> qTS,
        const ext::shared_ptr<LocalVolTermStructure>& localVol,
        Size xGrid,
        Size tGrid,
        Real x0Density,
        Real eps,
        Size maxIter,
        Time gaussianStepSize)
    : xGrid_(xGrid), tGrid_(tGrid), x0Density_(x0Density), localVolProbEps_(eps), maxIter_(maxIter),
      gaussianStepSize_(gaussianStepSize), spot_(std::move(spot)), localVol_(localVol),
      rTS_(std::move(rTS)), qTS_(std::move(qTS)),
      timeGrid_(new TimeGrid(localVol->maxTime(), tGrid)), xm_(tGrid),
      pm_(new Matrix(tGrid, xGrid)) {
        registerWith(spot_);
        registerWith(rTS_);
        registerWith(qTS_);
        registerWith(localVol_);
    }

    LocalVolRNDCalculator::LocalVolRNDCalculator(ext::shared_ptr<Quote> spot,
                                                 ext::shared_ptr<YieldTermStructure> rTS,
                                                 ext::shared_ptr<YieldTermStructure> qTS,
                                                 ext::shared_ptr<LocalVolTermStructure> localVol,
                                                 const ext::shared_ptr<TimeGrid>& timeGrid,
                                                 Size xGrid,
                                                 Real x0Density,
                                                 Real eps,
                                                 Size maxIter,
                                                 Time gaussianStepSize)
    : xGrid_(xGrid), tGrid_(timeGrid->size() - 1), x0Density_(x0Density), localVolProbEps_(eps),
      maxIter_(maxIter), gaussianStepSize_(gaussianStepSize), spot_(std::move(spot)),
      localVol_(std::move(localVol)), rTS_(std::move(rTS)), qTS_(std::move(qTS)),
      timeGrid_(timeGrid), xm_(tGrid_), pm_(new Matrix(tGrid_, xGrid_)) {
        registerWith(spot_);
        registerWith(rTS_);
        registerWith(qTS_);
        registerWith(localVol_);
    }

    Real LocalVolRNDCalculator::pdf(Real x, Time t) const {
        calculate();

        QL_REQUIRE(t > 0, "positive time expected");
        QL_REQUIRE(t <= timeGrid_->back(),
                "given time exceeds local vol time grid");

        const Time tMin = std::min(timeGrid_->at(1), 1.0/365);

        if (t <= tMin) {
            const Volatility vol = localVol_->localVol(0.0, spot_->value());
            const Volatility stdDev = vol * std::sqrt(t);
            const Real xm = - 0.5 * stdDev * stdDev +
                std::log(spot_->value() * qTS_->discount(t)/rTS_->discount(t));

            return GaussianDistribution(xm, stdDev)(x);
        }
        else if (t <= timeGrid_->at(1)) {
            const Volatility vol = localVol_->localVol(0.0, spot_->value());
            const Volatility stdDev = vol * std::sqrt(tMin);
            const Real xm = - 0.5 * stdDev * stdDev +
                std::log(spot_->value() * qTS_->discount(tMin)/rTS_->discount(tMin));

            const GaussianDistribution gaussianPDF(xm, stdDev);

            const Time deltaT = timeGrid_->at(1) - tMin;
            return gaussianPDF(x)*(timeGrid_->at(1) - t)/deltaT
                    + probabilityInterpolation(0, x)*(t - tMin)/deltaT;
        }
        else {
            const TimeGrid::const_iterator lb
                = std::lower_bound(timeGrid_->begin(), timeGrid_->end(), t);
            const TimeGrid::const_iterator llb = lb-1;

            const Size idx = std::distance(timeGrid_->begin(), lb)-1;

            const Time deltaT = *lb - *llb;
            return probabilityInterpolation(idx-1, x)*(*lb - t)/deltaT
                 + probabilityInterpolation(idx, x)*(t - *llb)/deltaT;
        }
    }

    Real LocalVolRNDCalculator::cdf(Real x, Time t) const {
        calculate();

        // get the left side of the integral
        const Time tc = timeGrid_->closestTime(t);
        const Size idx = (tc > t) ? timeGrid_->index(tc)-1
            : std::min(xm_.size()-1, timeGrid_->index(tc));

        Real xl = xm_[idx]->locations().front();
        Real xr = xm_[idx]->locations().back();

        if (x < xl)
            return 0.0;
        else if (x > xr)
            return 1.0;

        // left or right hand integral
        if (x > 0.5*(xr+xl)) {
            while (pdf(xr, t) > 0.01*localVolProbEps_) xr*=1.1;

            return 1.0-GaussLobattoIntegral(maxIter_, 0.1*localVolProbEps_)(
                [&](Real _x){ return pdf(_x, t); }, x, xr);
        }
        else {
            while (pdf(xl, t) > 0.01*localVolProbEps_) xl*=0.9;

            return GaussLobattoIntegral(maxIter_, 0.1*localVolProbEps_)(
                [&](Real _x){ return pdf(_x, t); }, xl, x);
        }
    }

    Real LocalVolRNDCalculator::invcdf(Real p, Time t) const {
        calculate();

        const Time closeGridTime(timeGrid_->closestTime(t));

        if (closeGridTime == 0.0) {
            const Real stepSize = 0.02*(
                    xm_[0]->locations().back() - xm_[0]->locations().front());
            return RiskNeutralDensityCalculator::InvCDFHelper(
                this, std::log(spot_->value()),
                0.1*localVolProbEps_, maxIter_, stepSize).inverseCDF(p, t);
        }
        else {
            Array xp(xGrid_);
            const Size idx = timeGrid_->index(closeGridTime)-1;

            const Array x(xm_[idx]->locations().begin(),
                          xm_[idx]->locations().end());
            const Real stepSize = 0.005*(x.back() - x.front());

            std::transform(x.begin(), x.end(), pm_->row_begin(idx), xp.begin(),
                           std::multiplies<Real>());

            const Real xm = DiscreteSimpsonIntegral()(x, xp);
            return RiskNeutralDensityCalculator::InvCDFHelper(
                this, xm, 0.1*localVolProbEps_, maxIter_, stepSize).inverseCDF(p, t);
        }
    }

    ext::shared_ptr<Fdm1dMesher>
    LocalVolRNDCalculator::mesher(Time t) const {
        calculate();

        const Size idx = timeGrid_->index(t);
        QL_REQUIRE(idx <= xm_.size(), "inconsistent time " << t << " given");

        if (idx > 0) {
            return xm_[idx-1];
        }
        else {
            return ext::make_shared<Predefined1dMesher>(
                std::vector<Real>(xGrid_, std::log(spot_->value())));
        }
    }

    ext::shared_ptr<TimeGrid> LocalVolRNDCalculator::timeGrid() const {
        return timeGrid_;
    }

    void LocalVolRNDCalculator::performCalculations() const {
        rescaleTimeSteps_.clear();

        const Time sT = timeGrid_->at(1);
        Time t = std::min(sT, (gaussianStepSize_ > 0.0) ? gaussianStepSize_
                                                        : 0.5*sT);
        const Volatility vol = localVol_->localVol(0.0, spot_->value());

        const Volatility stdDev = vol * std::sqrt(t);
        Real xm = - 0.5 * stdDev * stdDev +
            std::log(spot_->value() * qTS_->discount(t)/rTS_->discount(t));

        const Volatility stdDevOfFirstStep = vol * std::sqrt(sT);
        const Real normInvEps = InverseCumulativeNormal()(1 - localVolProbEps_);

        Real sLowerBound = xm - normInvEps * stdDevOfFirstStep;
        Real sUpperBound = xm + normInvEps * stdDevOfFirstStep;

        ext::shared_ptr<Fdm1dMesher> mesher(
            new Concentrating1dMesher(sLowerBound, sUpperBound, xGrid_,
                std::make_pair(xm, x0Density_), true));

        Array p(mesher->size());
        Array x(mesher->locations().begin(), mesher->locations().end());

        const GaussianDistribution gaussianPDF(xm, vol * std::sqrt(t));

        for (Size idx=0; idx < p.size(); ++idx) {
            p[idx] = gaussianPDF(x[idx]);
        }
        p = rescalePDF(x, p);

        QL_REQUIRE(x.size() > 10, "x grid is too small. "
                                  "Minimum size is greater than 10");

        const Size b = std::max(Size(1), Size(x.size()*0.04));

        ext::shared_ptr<DouglasScheme> evolver(
            new DouglasScheme(0.5,
                ext::make_shared<FdmLocalVolFwdOp>(
                    ext::make_shared<FdmMesherComposite>(mesher),
                    spot_, rTS_, qTS_, localVol_)));

        pFct_.resize(tGrid_);

        for (Size i=1; i <= tGrid_; ++i) {
            const Time dt = timeGrid_->at(i) - t;

            // leaking probability mass?
            const Real maxLeftValue =
                std::max(std::fabs(*std::min_element(p.begin(), p.begin()+b)),
                         std::fabs(*std::max_element(p.begin(), p.begin()+b)));
            const Real maxRightValue =
                std::max(std::fabs(*std::min_element(p.end()-b, p.end())),
                         std::fabs(*std::max_element(p.end()-b, p.end())));

            if (std::max(maxLeftValue, maxRightValue) > localVolProbEps_) {
                rescaleTimeSteps_.push_back(i);

                const Real oldLowerBound = sLowerBound;
                const Real oldUpperBound = sUpperBound;

                xm = DiscreteSimpsonIntegral()(x, x*p);
                Array vols(x.size());
                for (Size j=0; j < vols.size(); ++j) {
                    vols[j] = localVol_->localVol(t + dt, std::exp(x[j]));
                }

                const Real vm = DiscreteSimpsonIntegral()(x, vols)
                    /(x.back() - x.front());

                const Real scalingFactor = vm*std::sqrt(0.5*timeGrid_->back());

                if (maxLeftValue > localVolProbEps_)
                    sLowerBound -= scalingFactor*(oldUpperBound-oldLowerBound);
                if (maxRightValue > localVolProbEps_)
                    sUpperBound += scalingFactor*(oldUpperBound-oldLowerBound);

                mesher = ext::shared_ptr<Fdm1dMesher>(
                    new Concentrating1dMesher(sLowerBound, sUpperBound, xGrid_,
                        std::make_pair(xm, 0.1), false));

                const CubicNaturalSpline pSpline(x.begin(), x.end(), p.begin());
                const Array xn(mesher->locations().begin(),
                               mesher->locations().end());
                Array pn(xn.size(), 0.0);

                for (Size j=0; j < xn.size(); ++j) {
                    if (xn[j] >= oldLowerBound && xn[j] <= oldUpperBound)
                        pn[j] = pSpline(xn[j]);
                }

                x = xn;
                p = rescalePDF(xn, pn);

                evolver = ext::make_shared<DouglasScheme>(0.5,
                    ext::make_shared<FdmLocalVolFwdOp>(
                        ext::make_shared<FdmMesherComposite>(mesher),
                        spot_, rTS_, qTS_, localVol_));
            }
            evolver->setStep(dt);
            t+=dt;

            if (dt > QL_EPSILON) {
                evolver->step(p, t);
                p = rescalePDF(x, p);
            }

            xm_[i-1] = mesher;
            std::copy(p.begin(), p.end(), pm_->row_begin(i-1));
            pFct_[i-1] = ext::make_shared<CubicNaturalSpline>(
                xm_[i-1]->locations().begin(),
                xm_[i-1]->locations().end(),
                pm_->row_begin(i-1));
        }
    }


    Disposable<std::vector<Size> > LocalVolRNDCalculator::rescaleTimeSteps()
    const {
        calculate();

        return rescaleTimeSteps_;
    }

    Real LocalVolRNDCalculator::probabilityInterpolation(
        Size idx, Real x) const {
        calculate();

        if (   x < xm_[idx]->locations().front()
            || x > xm_[idx]->locations().back())
            return 0.0;
        else
            return (*pFct_[idx])(x);
    }

    Disposable<Array> LocalVolRNDCalculator::rescalePDF(
        const Array& x, const Array& p) const {

        Array retVal = p/DiscreteSimpsonIntegral()(x, p);
        return retVal;
    }
}

]]></document_content>
  </document>
  <document index="79">
    <source>finitedifferences/utilities/riskneutraldensitycalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes GÃ¶ttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/math/functional.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/methods/finitedifferences/utilities/riskneutraldensitycalculator.hpp>

namespace QuantLib {

    RiskNeutralDensityCalculator::InvCDFHelper::InvCDFHelper(
        const RiskNeutralDensityCalculator* calculator,
        Real guess, Real accuracy, Size maxEvaluations,
        Real stepSize)
    : calculator_(calculator),
      guess_(guess),
      accuracy_(accuracy),
      maxEvaluations_(maxEvaluations),
      stepSize_(stepSize) { }

    Real RiskNeutralDensityCalculator::InvCDFHelper::inverseCDF(Real p, Time t) const {
        Brent solver;
        solver.setMaxEvaluations(maxEvaluations_);
        return solver.solve([&](Real _x){ return calculator_->cdf(_x, t) - p; },
                            accuracy_, guess_, stepSize_);
    }

}
]]></document_content>
  </document>
  <document index="80">
    <source>finitedifferences/utilities/squarerootprocessrndcalculator.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Johannes GÃ¶ttker-Schnetmann
 Copyright (C) 2015 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/


#include <ql/methods/finitedifferences/utilities/squarerootprocessrndcalculator.hpp>

#include <boost/math/distributions/non_central_chi_squared.hpp>

namespace QuantLib {

    SquareRootProcessRNDCalculator::SquareRootProcessRNDCalculator(
        Real v0, Real kappa, Real theta, Real sigma)
    : v0_(v0), kappa_(kappa), theta_(theta),
      d_(4*kappa/(sigma*sigma)), df_(d_*theta) {    }


    Real SquareRootProcessRNDCalculator::pdf(Real v, Time t) const {
        const Real e   = std::exp(-kappa_*t);
        const Real k   = d_/(1-e);
        const Real ncp = k*v0_*e;

        const boost::math::non_central_chi_squared_distribution<Real>
            dist(df_, ncp);

        return boost::math::pdf(dist, v*k) * k;
    }

    Real SquareRootProcessRNDCalculator::cdf(Real v, Time t) const {
        const Real e   = std::exp(-kappa_*t);
        const Real k   = d_/(1-e);
        const Real ncp = k*v0_*e;

        const boost::math::non_central_chi_squared_distribution<Real>
            dist(df_, ncp);

        return boost::math::cdf(dist, v*k);
    }

    Real SquareRootProcessRNDCalculator::invcdf(Real q, Time t) const {
        const Real e   = std::exp(-kappa_*t);
        const Real k   = d_/(1-e);
        const Real ncp = k*v0_*e;

        const boost::math::non_central_chi_squared_distribution<Real>
            dist(df_, ncp);

        return boost::math::quantile(dist, q) / k;
    }

    Real SquareRootProcessRNDCalculator::stationary_pdf(Real v) const {
        const Real alpha = 0.5*df_;
        const Real beta = alpha/theta_;

        return std::pow(beta, alpha)*std::pow(v, alpha-1)
                *std::exp(-beta*v-boost::math::lgamma(alpha));
    }

    Real SquareRootProcessRNDCalculator::stationary_cdf(Real v) const {
        const Real alpha = 0.5*df_;
        const Real beta = alpha/theta_;

        return boost::math::gamma_p(alpha, beta*v);
    }

    Real SquareRootProcessRNDCalculator::stationary_invcdf(Real q) const {
        const Real alpha = 0.5*df_;
        const Real beta = alpha/theta_;

        return boost::math::gamma_p_inv(alpha, q)/beta;
    }
}
]]></document_content>
  </document>
  <document index="81">
    <source>lattices/binomialtree.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/lattices/binomialtree.hpp>
#include <ql/math/distributions/binomialdistribution.hpp>
#include <ql/stochasticprocess.hpp>

namespace QuantLib {

    JarrowRudd::JarrowRudd(
                        const ext::shared_ptr<StochasticProcess1D>& process,
                        Time end, Size steps, Real)
    : EqualProbabilitiesBinomialTree<JarrowRudd>(process, end, steps) {
        // drift removed
        up_ = process->stdDeviation(0.0, x0_, dt_);
    }


    CoxRossRubinstein::CoxRossRubinstein(
                        const ext::shared_ptr<StochasticProcess1D>& process,
                        Time end, Size steps, Real)
    : EqualJumpsBinomialTree<CoxRossRubinstein>(process, end, steps) {

        dx_ = process->stdDeviation(0.0, x0_, dt_);
        pu_ = 0.5 + 0.5*driftPerStep_/dx_;;
        pd_ = 1.0 - pu_;

        QL_REQUIRE(pu_<=1.0, "negative probability");
        QL_REQUIRE(pu_>=0.0, "negative probability");
    }


    AdditiveEQPBinomialTree::AdditiveEQPBinomialTree(
                        const ext::shared_ptr<StochasticProcess1D>& process,
                        Time end, Size steps, Real)
    : EqualProbabilitiesBinomialTree<AdditiveEQPBinomialTree>(process,
                                                              end, steps) {
        up_ = - 0.5 * driftPerStep_ + 0.5 *
            std::sqrt(4.0*process->variance(0.0, x0_, dt_)-
                      3.0*driftPerStep_*driftPerStep_);
    }


    Trigeorgis::Trigeorgis(
                        const ext::shared_ptr<StochasticProcess1D>& process,
                        Time end, Size steps, Real)
    : EqualJumpsBinomialTree<Trigeorgis>(process, end, steps) {

        dx_ = std::sqrt(process->variance(0.0, x0_, dt_)+
                        driftPerStep_*driftPerStep_);
        pu_ = 0.5 + 0.5*driftPerStep_/dx_;;
        pd_ = 1.0 - pu_;

        QL_REQUIRE(pu_<=1.0, "negative probability");
        QL_REQUIRE(pu_>=0.0, "negative probability");
    }


    Tian::Tian(const ext::shared_ptr<StochasticProcess1D>& process,
               Time end, Size steps, Real)
    : BinomialTree<Tian>(process, end, steps) {

        Real q = std::exp(process->variance(0.0, x0_, dt_));
        Real r = std::exp(driftPerStep_)*std::sqrt(q);

        up_ = 0.5 * r * q * (q + 1 + std::sqrt(q * q + 2 * q - 3));
        down_ = 0.5 * r * q * (q + 1 - std::sqrt(q * q + 2 * q - 3));

        pu_ = (r - down_) / (up_ - down_);
        pd_ = 1.0 - pu_;

        // doesn't work
        //     treeCentering_ = (up_+down_)/2.0;
        //     up_ = up_-treeCentering_;

        QL_REQUIRE(pu_<=1.0, "negative probability");
        QL_REQUIRE(pu_>=0.0, "negative probability");
    }


    LeisenReimer::LeisenReimer(const ext::shared_ptr<StochasticProcess1D>& process,
                               Time end,
                               Size steps,
                               Real strike)
    : BinomialTree<LeisenReimer>(process, end, ((steps % 2) != 0U ? steps : (steps + 1))) {

        QL_REQUIRE(strike>0.0, "strike must be positive");
        Size oddSteps = ((steps % 2) != 0U ? steps : (steps + 1));
        Real variance = process->variance(0.0, x0_, end);
        Real ermqdt = std::exp(driftPerStep_ + 0.5*variance/oddSteps);
        Real d2 = (std::log(x0_/strike) + driftPerStep_*oddSteps ) /
                                                          std::sqrt(variance);
        pu_ = PeizerPrattMethod2Inversion(d2, oddSteps);
        pd_ = 1.0 - pu_;
        Real pdash = PeizerPrattMethod2Inversion(d2+std::sqrt(variance),
                                                 oddSteps);
        up_ = ermqdt * pdash / pu_;
        down_ = (ermqdt - pu_ * up_) / (1.0 - pu_);
    }

    Real Joshi4::computeUpProb(Real k, Real dj) const {
        Real alpha = dj/(std::sqrt(8.0));
        Real alpha2 = alpha*alpha;
        Real alpha3 = alpha*alpha2;
        Real alpha5 = alpha3*alpha2;
        Real alpha7 = alpha5*alpha2;
        Real beta = -0.375*alpha-alpha3;
        Real gamma = (5.0/6.0)*alpha5 + (13.0/12.0)*alpha3
            +(25.0/128.0)*alpha;
        Real delta = -0.1025 *alpha- 0.9285 *alpha3
            -1.43 *alpha5 -0.5 *alpha7;
        Real p =0.5;
        Real rootk = std::sqrt(k);
        p+= alpha/rootk;
        p+= beta /(k*rootk);
        p+= gamma/(k*k*rootk);
        // delete next line to get results for j three tree
        p+= delta/(k*k*k*rootk);
        return p;
    }

    Joshi4::Joshi4(const ext::shared_ptr<StochasticProcess1D>& process,
                   Time end,
                   Size steps,
                   Real strike)
    : BinomialTree<Joshi4>(process, end, (steps % 2) != 0U ? steps : (steps + 1)) {

        QL_REQUIRE(strike>0.0, "strike must be positive");
        Size oddSteps = (steps % 2) != 0U ? steps : (steps + 1);
        Real variance = process->variance(0.0, x0_, end);
        Real ermqdt = std::exp(driftPerStep_ + 0.5*variance/oddSteps);
        Real d2 = (std::log(x0_/strike) + driftPerStep_*oddSteps ) /
                                                          std::sqrt(variance);
        pu_ = computeUpProb((oddSteps-1.0)/2.0,d2 );
        pd_ = 1.0 - pu_;
        Real pdash = computeUpProb((oddSteps-1.0)/2.0,d2+std::sqrt(variance));
        up_ = ermqdt * pdash / pu_;
        down_ = (ermqdt - pu_ * up_) / (1.0 - pu_);
    }
}
]]></document_content>
  </document>
  <document index="82">
    <source>lattices/trinomialtree.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/lattices/trinomialtree.hpp>
#include <ql/stochasticprocess.hpp>

namespace QuantLib {

    TrinomialTree::TrinomialTree(
                        const ext::shared_ptr<StochasticProcess1D>& process,
                        const TimeGrid& timeGrid,
                        bool isPositive)
    : Tree<TrinomialTree>(timeGrid.size()), dx_(1, 0.0), timeGrid_(timeGrid) {
        x0_ = process->x0();

        Size nTimeSteps = timeGrid.size() - 1;
        QL_REQUIRE(nTimeSteps > 0, "null time steps for trinomial tree");

        Integer jMin = 0;
        Integer jMax = 0;

        for (Size i=0; i<nTimeSteps; i++) {
            Time t = timeGrid[i];
            Time dt = timeGrid.dt(i);

            //Variance must be independent of x
            Real v2 = process->variance(t, 0.0, dt);
            Volatility v = std::sqrt(v2);
            dx_.push_back(v*std::sqrt(3.0));

            Branching branching;
            for (Integer j=jMin; j<=jMax; j++) {
                Real x = x0_ + j*dx_[i];
                Real m = process->expectation(t, x, dt);
                auto temp = Integer(std::floor((m - x0_) / dx_[i + 1] + 0.5));

                if (isPositive) {
                    while (x0_+(temp-1)*dx_[i+1]<=0) {
                        temp++;
                    }
                }

                Real e = m - (x0_ + temp*dx_[i+1]);
                Real e2 = e*e;
                Real e3 = e*std::sqrt(3.0);

                Real p1 = (1.0 + e2/v2 - e3/v)/6.0;
                Real p2 = (2.0 - e2/v2)/3.0;
                Real p3 = (1.0 + e2/v2 + e3/v)/6.0;

                branching.add(temp, p1, p2, p3);
            }
            branchings_.push_back(branching);

            jMin = branching.jMin();
            jMax = branching.jMax();
        }
    }

}

]]></document_content>
  </document>
  <document index="83">
    <source>montecarlo/brownianbridge.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

// ===========================================================================
// NOTE: The following copyright notice applies to the original code,
//
// Copyright (C) 2002 Peter JÃ¤ckel "Monte Carlo Methods in Finance".
// All rights reserved.
//
// Permission to use, copy, modify, and distribute this software is freely
// granted, provided that this notice is preserved.
// ===========================================================================

#include <ql/methods/montecarlo/brownianbridge.hpp>

namespace QuantLib {

    BrownianBridge::BrownianBridge(Size steps)
    : size_(steps), t_(size_), sqrtdt_(size_),
      bridgeIndex_(size_), leftIndex_(size_), rightIndex_(size_),
      leftWeight_(size_), rightWeight_(size_), stdDev_(size_) {
        for (Size i=0; i<size_; ++i)
            t_[i] = static_cast<Time>(i+1);
        initialize();
    }

    BrownianBridge::BrownianBridge(const std::vector<Time>& times)
    : size_(times.size()), t_(times), sqrtdt_(size_),
      bridgeIndex_(size_), leftIndex_(size_), rightIndex_(size_),
      leftWeight_(size_), rightWeight_(size_), stdDev_(size_) {
        initialize();
    }

    BrownianBridge::BrownianBridge(const TimeGrid& timeGrid)
    : size_(timeGrid.size()-1), t_(size_), sqrtdt_(size_),
      bridgeIndex_(size_), leftIndex_(size_), rightIndex_(size_),
      leftWeight_(size_), rightWeight_(size_), stdDev_(size_) {
        for (Size i=0; i<size_; ++i)
            t_[i] = timeGrid[i+1];
        initialize();
    }


    void BrownianBridge::initialize() {

        sqrtdt_[0] = std::sqrt(t_[0]);
        for (Size i=1; i<size_; ++i)
            sqrtdt_[i] = std::sqrt(t_[i]-t_[i-1]);

        // map is used to indicate which points are already constructed.
        // If map[i] is zero, path point i is yet unconstructed.
        // map[i]-1 is the index of the variate that constructs
        // the path point # i.
        std::vector<Size> map(size_, 0);

        //  The first point in the construction is the global step.
        map[size_-1] = 1;
        //  The global step is constructed from the first variate.
        bridgeIndex_[0] = size_-1;
        //  The variance of the global step
        stdDev_[0] = std::sqrt(t_[size_-1]);
        //  The global step to the last point in time is special.
        leftWeight_[0] = rightWeight_[0] = 0.0;
        for (Size j=0, i=1; i<size_; ++i) {
            // Find the next unpopulated entry in the map.
            while (map[j] != 0U)
                ++j;
            Size k = j;
            // Find the next populated entry in the map from there.
            while (map[k] == 0U)
                ++k;
            // l-1 is now the index of the point to be constructed next.
            Size l = j + ((k-1-j)>>1);
            map[l] = i;
            // The i-th Gaussian variate will be used to set point l-1.
            bridgeIndex_[i] = l;
            leftIndex_[i]   = j;
            rightIndex_[i]  = k;
            if (j != 0) {
                leftWeight_[i]= (t_[k]-t_[l])/(t_[k]-t_[j-1]);
                rightWeight_[i] = (t_[l]-t_[j-1])/(t_[k]-t_[j-1]);
                stdDev_[i] =
                    std::sqrt(((t_[l]-t_[j-1])*(t_[k]-t_[l]))
                              /(t_[k]-t_[j-1]));
            } else {
                leftWeight_[i]  = (t_[k]-t_[l])/t_[k];
                rightWeight_[i] =  t_[l]/t_[k];
                stdDev_[i] = std::sqrt(t_[l]*(t_[k]-t_[l])/t_[k]);
            }
            j=k+1;
            if (j>=size_)
                j=0;    //  wrap around
        }
    }

}

]]></document_content>
  </document>
  <document index="84">
    <source>montecarlo/genericlsregression.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Mark Joshi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/montecarlo/genericlsregression.hpp>
#include <ql/math/statistics/sequencestatistics.hpp>
#include <ql/math/matrixutilities/svd.hpp>

namespace QuantLib {

    Real genericLongstaffSchwartzRegression(
                std::vector<std::vector<NodeData> >& simulationData,
                std::vector<std::vector<Real> >& basisCoefficients) {

        Size steps = simulationData.size();
        basisCoefficients.resize(steps-1);

        for (Size i=steps-1; i!=0; --i) {

            std::vector<NodeData>& exerciseData = simulationData[i];

            // 1) find the covariance matrix of basis function values and
            //    deflated cash-flows
            Size N = exerciseData.front().values.size();
            std::vector<Real> temp(N+1);
            SequenceStatistics stats(N+1);

            Size j;
            for (j=0; j<exerciseData.size(); ++j) {
                if (exerciseData[j].isValid) {
                    std::copy(exerciseData[j].values.begin(),
                              exerciseData[j].values.end(),
                              temp.begin());
                    temp.back() = exerciseData[j].cumulatedCashFlows
                                - exerciseData[j].controlValue;

                    stats.add(temp);
                }
            }

            std::vector<Real> means = stats.mean();
            Matrix covariance = stats.covariance();

            Matrix C(N,N);
            Array target(N);
            for (Size k=0; k<N; ++k) {
                target[k] = covariance[k][N] + means[k]*means[N];
                for (Size l=0; l<=k; ++l)
                    C[k][l] = C[l][k] = covariance[k][l] + means[k]*means[l];
            }

            // 2) solve for least squares regression
            Array alphas = SVD(C).solveFor(target);
            basisCoefficients[i-1].resize(N);
            std::copy(alphas.begin(), alphas.end(),
                      basisCoefficients[i-1].begin());

            // 3) use exercise strategy to divide paths into exercise and
            //    non-exercise domains
            for (j=0; j<exerciseData.size(); ++j) {
                if (exerciseData[j].isValid) {
                    Real exerciseValue = exerciseData[j].exerciseValue;
                    Real continuationValue =
                        exerciseData[j].cumulatedCashFlows;
                    Real estimatedContinuationValue =
                        std::inner_product(
                                 exerciseData[j].values.begin(),
                                 exerciseData[j].values.end(),
                                 alphas.begin(),
                                 exerciseData[j].controlValue);

                    // for exercise paths, add deflated rebate to
                    // deflated cash-flows at previous time frame;
                    // for non-exercise paths, add deflated cash-flows to
                    // deflated cash-flows at previous time frame
                    Real value = estimatedContinuationValue <= exerciseValue ?
                                 exerciseValue :
                                 continuationValue;

                    simulationData[i-1][j].cumulatedCashFlows += value;
                }
            }
        }

        // the value of the product can now be estimated by averaging
        // over all paths
        Statistics estimate;
        std::vector<NodeData>& estimatedData = simulationData[0];
        for (auto& j : estimatedData)
            estimate.add(j.cumulatedCashFlows);

        return estimate.mean();
    }

}

]]></document_content>
  </document>
  <document index="85">
    <source>montecarlo/lsmbasissystem.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Klaus Spanderen
 Copyright (C) 2010 Kakhkhor Abdijalilov
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file lsmbasissystem.cpp
    \brief utility classes for longstaff schwartz early exercise Monte Carlo
*/

#include <ql/math/integrals/gaussianquadratures.hpp>
#include <ql/methods/montecarlo/lsmbasissystem.hpp>
#include <numeric>
#include <set>
#include <utility>

namespace QuantLib {
    namespace {

        // makes typing a little easier
        typedef std::vector<ext::function<Real(Real)> > VF_R;
        typedef std::vector<ext::function<Real(Array)> > VF_A;
        typedef std::vector<std::vector<Size> > VV;

        // pow(x, order)
        class MonomialFct {
          public:
            explicit MonomialFct(Size order): order_(order) {}
            inline Real operator()(const Real x) const {
                Real ret = 1.0;
                for(Size i=0; i<order_; ++i)
                    ret *= x;
                return ret;
            }
          private:
            const Size order_;
        };

        /* multiplies [Real -> Real] functors
           to create [Array -> Real] functor */
        class MultiDimFct {
          public:
            explicit MultiDimFct(VF_R b) : b_(std::move(b)) {
                QL_REQUIRE(!b_.empty(), "zero size basis");
            }
            inline Real operator()(const Array& a) const {
                #if defined(QL_EXTRA_SAFETY_CHECKS)
                QL_REQUIRE(b_.size()==a.size(), "wrong argument size");
                #endif
                Real ret = b_[0](a[0]);
                for(Size i=1; i<b_.size(); ++i)
                    ret *= b_[i](a[i]);
                return ret;
            }
          private:
            const VF_R b_;
        };

        // check size and order of tuples
        void check_tuples(const VV& v, Size dim, Size order) {
            for (const auto& i : v) {
                QL_REQUIRE(dim == i.size(), "wrong tuple size");
                QL_REQUIRE(order == std::accumulate(i.begin(), i.end(), 0UL), "wrong tuple order");
            }
        }

        // build order N+1 tuples from order N tuples
        VV next_order_tuples(const VV& v) {
            const Size order = std::accumulate(v[0].begin(), v[0].end(), 0UL);
            const Size dim = v[0].size();

            check_tuples(v, dim, order);

            // the set of unique tuples
            std::set<std::vector<Size> > tuples;
            std::vector<Size> x;
            for(Size i=0; i<dim; ++i) {
                // increase i-th value in every tuple by 1
                for (const auto& j : v) {
                    x = j;
                    x[i] += 1;
                    tuples.insert(x);
                }
            }

            VV ret(tuples.begin(), tuples.end());
            return ret;
        }
    } 

    // LsmBasisSystem static methods

    VF_R LsmBasisSystem::pathBasisSystem(Size order, PolynomType polyType) {
        VF_R ret(order+1);
        for (Size i=0; i<=order; ++i) {
            switch (polyType) {
              case Monomial:
                ret[i] = MonomialFct(i);
                break;
              case Laguerre:
                {
                  GaussLaguerrePolynomial p;
                  ret[i] = [=](Real x){ return p.weightedValue(i, x); };
                }
                break;
              case Hermite:
                {
                  GaussHermitePolynomial p;
                  ret[i] = [=](Real x){ return p.weightedValue(i, x); };
                }
                break;
              case Hyperbolic:
                {
                  GaussHyperbolicPolynomial p;
                  ret[i] = [=](Real x){ return p.weightedValue(i, x); };
                }
                break;
              case Legendre:
                {
                  GaussLegendrePolynomial p;
                  ret[i] = [=](Real x){ return p.weightedValue(i, x); };
                }
                break;
              case Chebyshev:
                {
                  GaussChebyshevPolynomial p;
                  ret[i] = [=](Real x){ return p.weightedValue(i, x); };
                }
                break;
              case Chebyshev2nd:
                {
                  GaussChebyshev2ndPolynomial p;
                  ret[i] = [=](Real x){ return p.weightedValue(i, x); };
                }
                break;
              default:
                QL_FAIL("unknown regression type");
            }
        }
        return ret;
    }

    VF_A LsmBasisSystem::multiPathBasisSystem(Size dim, Size order,
                                              PolynomType polyType) {
        QL_REQUIRE(dim>0, "zero dimension");
        // get single factor basis
        VF_R pathBasis = pathBasisSystem(order, polyType);
        VF_A ret;
        // 0-th order term
        VF_R term(dim, pathBasis[0]);
        ret.push_back(MultiDimFct(term));
        // start with all 0 tuple
        VV tuples(1, std::vector<Size>(dim));
        // add multi-factor terms
        for(Size i=1; i<=order; ++i) {
            tuples = next_order_tuples(tuples);
            // now we have all tuples of order i
            // for each tuple add the corresponding term
            for (auto& tuple : tuples) {
                for(Size k=0; k<dim; ++k)
                    term[k] = pathBasis[tuple[k]];
                ret.push_back(MultiDimFct(term));
            }
        }
        return ret;
    }
}
]]></document_content>
  </document>
  <document index="86">
    <source>montecarlo/parametricexercise.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/methods/montecarlo/parametricexercise.hpp>
#include <ql/math/optimization/problem.hpp>
#include <ql/math/optimization/constraint.hpp>

namespace QuantLib {

    namespace {

        class ValueEstimate : public CostFunction {
          public:
            ValueEstimate(const std::vector<NodeData>& simulationData,
                          const ParametricExercise& exercise,
                          Size exerciseIndex);
            Real value(const Array& parameters) const override;
            Disposable<Array> values(const Array&) const override {
                QL_FAIL("values method not implemented");
            }

        private:
            const std::vector<NodeData>& simulationData_;
            const ParametricExercise& exercise_;
            Size exerciseIndex_;
            mutable std::vector<Real> parameters_;
        };

        ValueEstimate::ValueEstimate(
                                 const std::vector<NodeData>& simulationData,
                                 const ParametricExercise& exercise,
                                 Size exerciseIndex)
        : simulationData_(simulationData), exercise_(exercise),
          exerciseIndex_(exerciseIndex),
          parameters_(exercise.numberOfParameters()[exerciseIndex]) {
            for (const auto& i : simulationData_) {
                if (i.isValid)
                    return;
            }
            QL_FAIL("no valid paths");
        }

        Real ValueEstimate::value(const Array& parameters) const {
            std::copy(parameters.begin(), parameters.end(),
                      parameters_.begin());
            Real sum = 0.0;
            Size n = 0;
            for (const auto& i : simulationData_) {
                if (i.isValid) {
                    ++n;
                    if (exercise_.exercise(exerciseIndex_, parameters_, i.values))
                        sum += i.exerciseValue;
                    else
                        sum += i.cumulatedCashFlows;
                }
            }
            return -sum/n;
        }

    }



    Real genericEarlyExerciseOptimization(
                          std::vector<std::vector<NodeData> >& simulationData,
                          const ParametricExercise& exercise,
                          std::vector<std::vector<Real> >& parameters,
                          const EndCriteria& endCriteria,
                          OptimizationMethod& method) {

        Size steps = simulationData.size();
        parameters.resize(steps-1);

        for (Size i=steps-1; i!=0; --i) {
            const std::vector<NodeData>& exerciseData = simulationData[i];

            parameters[i-1].resize(exercise.numberOfParameters()[i-1]);


            // optimize
            ValueEstimate f(exerciseData, exercise, i-1);

            Array guess(parameters[i-1].size());
            exercise.guess(i-1, parameters[i-1]);
            std::copy(parameters[i-1].begin(), parameters[i-1].end(),
                      guess.begin());

            NoConstraint c;

            Problem p(f, c, guess);
            method.minimize(p, endCriteria);

            Array result = p.currentValue();
            std::copy(result.begin(), result.end(),
                      parameters[i-1].begin());

            std::vector<NodeData>& previousData = simulationData[i-1];
            for (Size j=0; j<previousData.size(); ++j) {
                if (exerciseData[j].isValid) {
                    if (exercise.exercise(i-1,
                                          parameters[i-1],
                                          exerciseData[j].values))
                        previousData[j].cumulatedCashFlows +=
                            exerciseData[j].exerciseValue;
                    else
                        previousData[j].cumulatedCashFlows +=
                            exerciseData[j].cumulatedCashFlows;
                }
            }
        }

        Real sum = 0.0;
        const std::vector<NodeData>& initialData = simulationData.front();
        for (const auto& i : initialData)
            sum += i.cumulatedCashFlows;
        return sum/initialData.size();
    }

}

]]></document_content>
  </document>
</documents>