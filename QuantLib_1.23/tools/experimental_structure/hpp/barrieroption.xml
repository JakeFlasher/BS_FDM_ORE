<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/barrieroption/analyticdoublebarrierbinaryengine.hpp>
#include <ql/experimental/barrieroption/analyticdoublebarrierengine.hpp>
#include <ql/experimental/barrieroption/mcdoublebarrierengine.hpp>
#include <ql/experimental/barrieroption/binomialdoublebarrierengine.hpp>
#include <ql/experimental/barrieroption/discretizeddoublebarrieroption.hpp>
#include <ql/experimental/barrieroption/doublebarrieroption.hpp>
#include <ql/experimental/barrieroption/doublebarriertype.hpp>
#include <ql/experimental/barrieroption/perturbativebarrieroptionengine.hpp>
#include <ql/experimental/barrieroption/quantodoublebarrieroption.hpp>
#include <ql/experimental/barrieroption/vannavolgabarrierengine.hpp>
#include <ql/experimental/barrieroption/vannavolgadoublebarrierengine.hpp>
#include <ql/experimental/barrieroption/vannavolgainterpolation.hpp>
#include <ql/experimental/barrieroption/wulinyongdoublebarrierengine.hpp>

]]></document_content>
  </document>
  <document index="2">
    <source>analyticdoublebarrierbinaryengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticdoublebarrierbinaryengine.hpp
    \brief analytic binary double barrier (one-touch double barrier) option engine
*/

#ifndef quantlib_binary_double_barrier_engine_hpp
#define quantlib_binary_double_barrier_engine_hpp

#include <ql/experimental/barrieroption/doublebarrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic pricing engine for double barrier binary options
    /*! This engine implements C.H.Hui series ("One-Touch Double Barrier 
        Binary Option Values", Applied Financial Economics 6/1996), as
        described in "The complete guide to option pricing formulas 2nd Ed", 
        E.G. Haug, McGraw-Hill, p.180

        The Knock In part of KI+KO and KO+KI options pays at hit, while the
        Double Knock In pays at end. 
        This engine thus requires European esercise for Double Knock options, 
        and American exercise for KIKO/KOKI.

        \ingroup barrierengines

        greeks are calculated by simple numeric derivation

        \test
        - the correctness of the returned value is tested by reproducing 
          results available in literature.
    */
    class AnalyticDoubleBarrierBinaryEngine : public DoubleBarrierOption::engine {
      public:
        explicit AnalyticDoubleBarrierBinaryEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="3">
    <source>analyticdoublebarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticdoublebarrierengine.hpp
    \brief Analytic double barrier european option engines

  ! Valid only if strike is in barrier range
*/

#ifndef quantlib_analytic_double_barrier_engine_hpp
#define quantlib_analytic_double_barrier_engine_hpp

#include <ql/experimental/barrieroption/doublebarrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {

    //! Pricing engine for double barrier european options using analytical formulae
    /*! The formulas are taken from "The complete guide to option pricing formulas 2nd Ed",
         E.G. Haug, McGraw-Hill, p.156 and following.
         Implements the Ikeda and Kunitomo series (see "Pricing Options with 
         Curved Boundaries" Mathematical Finance 2/1992").
         This code handles only flat barriers

        \ingroup barrierengines

        \note the formula holds only when strike is in the barrier range

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class AnalyticDoubleBarrierEngine : public DoubleBarrierOption::engine {
      public:
        explicit AnalyticDoubleBarrierEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process, int series = 5);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        CumulativeNormalDistribution f_;
        int series_;
        // helper methods
        Real underlying() const;
        Real strike() const;
        Time residualTime() const;
        Volatility volatility() const;
        Real volatilitySquared() const;
        Real barrierLo() const;
        Real barrierHi() const;
        Real stdDeviation() const;
        Rate riskFreeRate() const;
        DiscountFactor riskFreeDiscount() const;
        Rate dividendYield() const;
        Rate costOfCarry() const;
        DiscountFactor dividendDiscount() const;
        Real vanillaEquivalent() const;
        Real callKO() const;
        Real putKO() const;
        Real callKI() const;
        Real putKI() const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="4">
    <source>binomialdoublebarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file binomialdoublebarrierengine.hpp
    \brief Binomial Double Barrier option engine
*/

#ifndef quantlib_binomial_double_barrier_engine_hpp
#define quantlib_binomial_double_barrier_engine_hpp

#include <ql/experimental/barrieroption/discretizeddoublebarrieroption.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <ql/methods/lattices/binomialtree.hpp>
#include <ql/methods/lattices/bsmlattice.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/termstructures/yield/flatforward.hpp>
#include <utility>

namespace QuantLib {

    //! Pricing engine for double barrier options using binomial trees
    /*! \ingroup barrierengines

        \note This engine requires a the discretized option classes. 
        By default uses a standard binomial implementation, but it can
        also work with DiscretizedDermanKaniDoubleBarrierOption to
        implement a Derman-Kani optimization.

        \test the correctness of the returned values is tested by
              checking it against analytic results.
    */
    template <class T, class D = DiscretizedDoubleBarrierOption>
    class BinomialDoubleBarrierEngine : public DoubleBarrierOption::engine {
      public:
        BinomialDoubleBarrierEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                                    Size timeSteps)
        : process_(std::move(process)), timeSteps_(timeSteps) {
            QL_REQUIRE(timeSteps>0,
                       "timeSteps must be positive, " << timeSteps <<
                       " not allowed");
            registerWith(process_);
        }
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Size timeSteps_;
    };


    // template definitions

    template <class T, class D>
    void BinomialDoubleBarrierEngine<T,D>::calculate() const {

        DayCounter rfdc  = process_->riskFreeRate()->dayCounter();
        DayCounter divdc = process_->dividendYield()->dayCounter();
        DayCounter voldc = process_->blackVolatility()->dayCounter();
        Calendar volcal = process_->blackVolatility()->calendar();

        Real s0 = process_->stateVariable()->value();
        QL_REQUIRE(s0 > 0.0, "negative or null underlying given");
        Volatility v = process_->blackVolatility()->blackVol(
            arguments_.exercise->lastDate(), s0);
        Date maturityDate = arguments_.exercise->lastDate();
        Rate r = process_->riskFreeRate()->zeroRate(maturityDate,
            rfdc, Continuous, NoFrequency);
        Rate q = process_->dividendYield()->zeroRate(maturityDate,
            divdc, Continuous, NoFrequency);
        Date referenceDate = process_->riskFreeRate()->referenceDate();

        // binomial trees with constant coefficient
        Handle<YieldTermStructure> flatRiskFree(
            ext::shared_ptr<YieldTermStructure>(
                new FlatForward(referenceDate, r, rfdc)));
        Handle<YieldTermStructure> flatDividends(
            ext::shared_ptr<YieldTermStructure>(
                new FlatForward(referenceDate, q, divdc)));
        Handle<BlackVolTermStructure> flatVol(
            ext::shared_ptr<BlackVolTermStructure>(
                new BlackConstantVol(referenceDate, volcal, v, voldc)));

        ext::shared_ptr<StrikedTypePayoff> payoff =
            ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-striked payoff given");

        Time maturity = rfdc.yearFraction(referenceDate, maturityDate);

        ext::shared_ptr<StochasticProcess1D> bs(
                         new GeneralizedBlackScholesProcess(
                                      process_->stateVariable(),
                                      flatDividends, flatRiskFree, flatVol));

        TimeGrid grid(maturity, timeSteps_);

        ext::shared_ptr<T> tree(new T(bs, maturity, timeSteps_,
                                        payoff->strike()));

        ext::shared_ptr<BlackScholesLattice<T> > lattice(
            new BlackScholesLattice<T>(tree, r, maturity, timeSteps_));
        
        D option(arguments_, *process_, grid);
        option.initialize(lattice, maturity);

        // Partial derivatives calculated from various points in the
        // binomial tree 
        // (see J.C.Hull, "Options, Futures and other derivatives", 6th edition, pp 397/398)

        // Rollback to third-last step, and get underlying prices (s2) &
        // option values (p2) at this point
        option.rollback(grid[2]);
        Array va2(option.values());
        QL_ENSURE(va2.size() == 3, "Expect 3 nodes in grid at second step");
        Real p2u = va2[2]; // up
        Real p2m = va2[1]; // mid
        Real p2d = va2[0]; // down (low)
        Real s2u = lattice->underlying(2, 2); // up price
        Real s2m = lattice->underlying(2, 1); // middle price
        Real s2d = lattice->underlying(2, 0); // down (low) price

        // calculate gamma by taking the first derivate of the two deltas
        Real delta2u = (p2u - p2m)/(s2u-s2m);
        Real delta2d = (p2m-p2d)/(s2m-s2d);
        Real gamma = (delta2u - delta2d) / ((s2u-s2d)/2);

        // Rollback to second-last step, and get option values (p1) at
        // this point
        option.rollback(grid[1]);
        Array va(option.values());
        QL_ENSURE(va.size() == 2, "Expect 2 nodes in grid at first step");
        Real p1u = va[1];
        Real p1d = va[0];
        Real s1u = lattice->underlying(1, 1); // up (high) price
        Real s1d = lattice->underlying(1, 0); // down (low) price

        Real delta = (p1u - p1d) / (s1u - s1d);

        // Finally, rollback to t=0
        option.rollback(0.0);
        Real p0 = option.presentValue();

        results_.value = p0;
        results_.delta = delta;
        results_.gamma = gamma;
        // theta can be approximated by calculating the numerical derivative
        // between mid value at third-last step and at t0. The underlying price
        // is the same, only time varies.
        results_.theta = (p2m - p0) / grid[2];
    }

}


#endif
]]></document_content>
  </document>
  <document index="5">
    <source>discretizeddoublebarrieroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file discretizedbarrieroption.hpp
    \brief discretized barrier option
*/

#ifndef quantlib_discretized_double_barrier_option_h
#define quantlib_discretized_double_barrier_option_h

#include <ql/discretizedasset.hpp>
#include <ql/methods/lattices/bsmlattice.hpp>
#include <ql/experimental/barrieroption/doublebarrieroption.hpp>
#include <ql/pricingengines/vanilla/discretizedvanillaoption.hpp>

namespace QuantLib {

    //! Standard discretized option helper class
    /*! This class is used with the BinomialDoubleBarrierEngine to
        implement a standard binomial algorithm for double barrier
        options
    */
    class DiscretizedDoubleBarrierOption : public DiscretizedAsset {
      public:
        DiscretizedDoubleBarrierOption(const DoubleBarrierOption::arguments&,
                                 const StochasticProcess& process,
                                 const TimeGrid& grid = TimeGrid());

        void reset(Size size) override;

        const Array& vanilla() const { 
            return vanilla_.values(); 
        }

        const DoubleBarrierOption::arguments& arguments() const {
           return arguments_;
        }

        std::vector<Time> mandatoryTimes() const override { return stoppingTimes_; }

        void checkBarrier(Array &optvalues, const Array &grid) const;
      protected:
        void postAdjustValuesImpl() override;

      private:
        DoubleBarrierOption::arguments arguments_;
        std::vector<Time> stoppingTimes_;
        DiscretizedVanillaOption vanilla_; 
    };

    //! Derman-Kani-Ergener-Bardhan discretized option helper class
    /*! This class is used with the BinomialDoubleBarrierEngine to
        implement the enhanced binomial algorithm of E.Derman, I.Kani,
        D.Ergener, I.Bardhan ("Enhanced Numerical Methods for Options with
        Barriers", 1995)

        \note This algorithm is only suitable if the payoff can be approximated 
        linearly, e.g. is not usable for cash-or-nothing payoffs.
    */
    class DiscretizedDermanKaniDoubleBarrierOption : public DiscretizedAsset {
      public:
        DiscretizedDermanKaniDoubleBarrierOption(const DoubleBarrierOption::arguments&,
                                 const StochasticProcess& process,
                                 const TimeGrid& grid = TimeGrid());

        void reset(Size size) override;

        std::vector<Time> mandatoryTimes() const override { return unenhanced_.mandatoryTimes(); }

      protected:
        void postAdjustValuesImpl() override;

      private:
        void adjustBarrier(Array &optvalues, const Array &grid);
        DiscretizedDoubleBarrierOption unenhanced_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="6">
    <source>doublebarrieroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file doublebarrieroption.hpp
    \brief double Barrier european option on a single asset
*/

#ifndef quantlib_double_barrier_option_hpp
#define quantlib_double_barrier_option_hpp

#include <ql/instruments/oneassetoption.hpp>
#include <ql/experimental/barrieroption/doublebarriertype.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    class GeneralizedBlackScholesProcess;

    //! %Double Barrier option on a single asset.
    /*! The analytic pricing engine will be used if none if passed.

        \ingroup instruments
    */
    class DoubleBarrierOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        DoubleBarrierOption(DoubleBarrier::Type barrierType,
                      Real barrier_lo,
                      Real barrier_hi,
                      Real rebate,
                      const ext::shared_ptr<StrikedTypePayoff>& payoff,
                      const ext::shared_ptr<Exercise>& exercise);
        void setupArguments(PricingEngine::arguments*) const override;
        /*! \warning see VanillaOption for notes on implied-volatility
                     calculation.
        */
        Volatility impliedVolatility(
             Real price,
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             Real accuracy = 1.0e-4,
             Size maxEvaluations = 100,
             Volatility minVol = 1.0e-7,
             Volatility maxVol = 4.0) const;
      protected:
        // arguments
        DoubleBarrier::Type barrierType_;
        Real barrier_lo_;
        Real barrier_hi_;
        Real rebate_;
    };

    //! %Arguments for double barrier option calculation
    class DoubleBarrierOption::arguments : public OneAssetOption::arguments {
      public:
        arguments();
        DoubleBarrier::Type barrierType;
        Real barrier_lo;
        Real barrier_hi;
        Real rebate;
        void validate() const override;
    };

    //! %Double-Barrier-option %engine base class
    class DoubleBarrierOption::engine
        : public GenericEngine<DoubleBarrierOption::arguments,
                               DoubleBarrierOption::results> {
      protected:
        bool triggered(Real underlying) const;
    };

}

#endif
]]></document_content>
  </document>
  <document index="7">
    <source>doublebarriertype.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file doublebarriertype.hpp
    \brief Double Barrier type
*/

#ifndef quantlib_double_barrier_type_hpp
#define quantlib_double_barrier_type_hpp

#include <ql/qldefines.hpp>
#include <ostream>

namespace QuantLib {

    //! Placeholder for enumerated barrier types
    struct DoubleBarrier {
        enum Type {
           KnockIn,
           KnockOut,
           KIKO,     //! lower barrier KI, upper KO
           KOKI      //! lower barrier KO, upper KI
        };
    };

    std::ostream& operator<<(std::ostream& out,
                             DoubleBarrier::Type type);

}

#endif
]]></document_content>
  </document>
  <document index="8">
    <source>mcdoublebarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2020 Lew Wei Hao

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mcdoublebarrierengine.hpp
    \brief Monte Carlo barrier option engines
*/

#ifndef quantlib_mc_double_barrier_engines_hpp
#define quantlib_mc_double_barrier_engines_hpp

#include <ql/exercise.hpp>
#include <ql/experimental/barrieroption/doublebarrieroption.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <utility>

namespace QuantLib {

    template <class RNG = PseudoRandom, class S = Statistics>
    class MCDoubleBarrierEngine : public DoubleBarrierOption::engine,
                                  public McSimulation<SingleVariate,RNG,S> {
      public:
        typedef typename McSimulation<SingleVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef typename McSimulation<SingleVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        // constructor
        MCDoubleBarrierEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                              Size timeSteps,
                              Size timeStepsPerYear,
                              bool brownianBridge,
                              bool antithetic,
                              Size requiredSamples,
                              Real requiredTolerance,
                              Size maxSamples,
                              BigNatural seed);
        void calculate() const override {
            Real spot = process_->x0();
            QL_REQUIRE(spot >= 0.0, "negative or null underlying given");
            QL_REQUIRE(!triggered(spot), "barrier touched");
            McSimulation<SingleVariate,RNG,S>::calculate(requiredTolerance_,
                                                         requiredSamples_,
                                                         maxSamples_);
            results_.value = this->mcModel_->sampleAccumulator().mean();
            if (RNG::allowsErrorEstimate)
            results_.errorEstimate =
                this->mcModel_->sampleAccumulator().errorEstimate();
        }

      protected:
        // McSimulation implementation
        TimeGrid timeGrid() const override;
        ext::shared_ptr<path_generator_type> pathGenerator() const override {
            TimeGrid grid = timeGrid();
            typename RNG::rsg_type gen =
                RNG::make_sequence_generator(grid.size()-1,seed_);
            return ext::shared_ptr<path_generator_type>(
                         new path_generator_type(process_,
                                                 grid, gen, brownianBridge_));
        }
        ext::shared_ptr<path_pricer_type> pathPricer() const override;
        // data members
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Size timeSteps_, timeStepsPerYear_;
        Size requiredSamples_, maxSamples_;
        Real requiredTolerance_;
        bool antithetic_;
        bool brownianBridge_;
        BigNatural seed_;
    };

    //! Monte Carlo double-barrier-option engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCDoubleBarrierEngine {
      public:
        explicit MakeMCDoubleBarrierEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>);
        // named parameters
        MakeMCDoubleBarrierEngine& withSteps(Size steps);
        MakeMCDoubleBarrierEngine& withStepsPerYear(Size steps);
        MakeMCDoubleBarrierEngine& withBrownianBridge(bool b = true);
        MakeMCDoubleBarrierEngine& withAntitheticVariate(bool b = true);
        MakeMCDoubleBarrierEngine& withSamples(Size samples);
        MakeMCDoubleBarrierEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCDoubleBarrierEngine& withMaxSamples(Size samples);
        MakeMCDoubleBarrierEngine& withSeed(BigNatural seed);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        bool brownianBridge_, antithetic_;
        Size steps_, stepsPerYear_, samples_, maxSamples_;
        Real tolerance_;
        BigNatural seed_;
    };

    class DoubleBarrierPathPricer : public PathPricer<Path> {
      public:
        DoubleBarrierPathPricer(DoubleBarrier::Type barrierType,
                                Real barrierLow,
                                Real barrieHigh,
                                Real rebate,
                                Option::Type type,
                                Real strike,
                                std::vector<DiscountFactor> discounts);
        Real operator()(const Path& path) const override;

      private:
        DoubleBarrier::Type barrierType_;
        Real barrierLow_;
        Real barrierHigh_;
        Real rebate_;
        PlainVanillaPayoff payoff_;
        std::vector<DiscountFactor> discounts_;
    };

    // template definitions

    template <class RNG, class S>
    inline MCDoubleBarrierEngine<RNG, S>::MCDoubleBarrierEngine(
        ext::shared_ptr<GeneralizedBlackScholesProcess> process,
        Size timeSteps,
        Size timeStepsPerYear,
        bool brownianBridge,
        bool antitheticVariate,
        Size requiredSamples,
        Real requiredTolerance,
        Size maxSamples,
        BigNatural seed)
    : McSimulation<SingleVariate, RNG, S>(antitheticVariate, false), process_(std::move(process)),
      timeSteps_(timeSteps), timeStepsPerYear_(timeStepsPerYear), requiredSamples_(requiredSamples),
      maxSamples_(maxSamples), requiredTolerance_(requiredTolerance),
      brownianBridge_(brownianBridge), seed_(seed) {
        QL_REQUIRE(timeSteps != Null<Size>() ||
                   timeStepsPerYear != Null<Size>(),
                   "no time steps provided");
        QL_REQUIRE(timeSteps == Null<Size>() ||
                   timeStepsPerYear == Null<Size>(),
                   "both time steps and time steps per year were provided");
        QL_REQUIRE(timeSteps != 0,
                   "timeSteps must be positive, " << timeSteps <<
                   " not allowed");
        QL_REQUIRE(timeStepsPerYear != 0,
                   "timeStepsPerYear must be positive, " << timeStepsPerYear <<
                   " not allowed");
        registerWith(process_);
    }

    template <class RNG, class S>
    inline TimeGrid MCDoubleBarrierEngine<RNG,S>::timeGrid() const {

        Time residualTime = process_->time(arguments_.exercise->lastDate());
        if (timeSteps_ != Null<Size>()) {
            return TimeGrid(residualTime, timeSteps_);
        } else if (timeStepsPerYear_ != Null<Size>()) {
            Size steps = static_cast<Size>(timeStepsPerYear_*residualTime);
            return TimeGrid(residualTime, std::max<Size>(steps, 1));
        } else {
            QL_FAIL("time steps not specified");
        }
    }

    template <class RNG, class S>
    inline
    ext::shared_ptr<typename MCDoubleBarrierEngine<RNG,S>::path_pricer_type>
    MCDoubleBarrierEngine<RNG,S>::pathPricer() const {
        ext::shared_ptr<PlainVanillaPayoff> payoff =
            ext::dynamic_pointer_cast<PlainVanillaPayoff>(arguments_.payoff);
        QL_REQUIRE(payoff, "non-plain payoff given");

        TimeGrid grid = timeGrid();
        std::vector<DiscountFactor> discounts(grid.size());
        for (Size i=0; i<grid.size(); i++)
            discounts[i] = process_->riskFreeRate()->discount(grid[i]);

        return ext::shared_ptr<
                    typename MCDoubleBarrierEngine<RNG,S>::path_pricer_type>(
            new DoubleBarrierPathPricer(
                arguments_.barrierType,
                arguments_.barrier_lo,
                arguments_.barrier_hi,
                arguments_.rebate,
                payoff->optionType(),
                payoff->strike(),
                discounts));
        }

        template <class RNG, class S>
        inline MakeMCDoubleBarrierEngine<RNG, S>::MakeMCDoubleBarrierEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process)
        : process_(std::move(process)), brownianBridge_(false), antithetic_(false),
          steps_(Null<Size>()), stepsPerYear_(Null<Size>()), samples_(Null<Size>()),
          maxSamples_(Null<Size>()), tolerance_(Null<Real>()), seed_(0) {}

        template <class RNG, class S>
        inline MakeMCDoubleBarrierEngine<RNG, S>&
        MakeMCDoubleBarrierEngine<RNG, S>::withSteps(Size steps) {
            steps_ = steps;
            return *this;
    }

    template <class RNG, class S>
    inline MakeMCDoubleBarrierEngine<RNG,S>&
    MakeMCDoubleBarrierEngine<RNG,S>::withStepsPerYear(Size steps) {
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDoubleBarrierEngine<RNG,S>&
    MakeMCDoubleBarrierEngine<RNG,S>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDoubleBarrierEngine<RNG,S>&
    MakeMCDoubleBarrierEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDoubleBarrierEngine<RNG,S>&
    MakeMCDoubleBarrierEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDoubleBarrierEngine<RNG,S>&
    MakeMCDoubleBarrierEngine<RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDoubleBarrierEngine<RNG,S>&
    MakeMCDoubleBarrierEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCDoubleBarrierEngine<RNG,S>&
    MakeMCDoubleBarrierEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCDoubleBarrierEngine<RNG,S>::operator ext::shared_ptr<PricingEngine>()
                                                                      const {
        QL_REQUIRE(steps_ != Null<Size>() || stepsPerYear_ != Null<Size>(),
                   "number of steps not given");
        QL_REQUIRE(steps_ == Null<Size>() || stepsPerYear_ == Null<Size>(),
                   "number of steps overspecified");
        return ext::shared_ptr<PricingEngine>(new
            MCDoubleBarrierEngine<RNG,S>(process_,
                                   steps_,
                                   stepsPerYear_,
                                   brownianBridge_,
                                   antithetic_,
                                   samples_,
                                   tolerance_,
                                   maxSamples_,
                                   seed_));
    }

}


#endif
]]></document_content>
  </document>
  <document index="9">
    <source>perturbativebarrieroptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file perturbativebarrieroptionengine.hpp
    \brief perturbative barrier-option engine
*/

#ifndef quantlib_perturbative_barrier_option_engine_hpp
#define quantlib_perturbative_barrier_option_engine_hpp

#include <ql/instruments/barrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! perturbative barrier-option engine
    /*! This engine implements the approach described in
        <http://www.econ.univpm.it/recchioni/finance/w3/>.

        \warning This was reported to fail tests on Mac OS X 10.8.4.

        \ingroup barrierengines
    */
    class PerturbativeBarrierOptionEngine : public BarrierOption::engine  {
      public:
        explicit PerturbativeBarrierOptionEngine(ext::shared_ptr<GeneralizedBlackScholesProcess>,
                                                 Natural order = 1,
                                                 bool zeroGamma = false);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Natural order_;
        bool zeroGamma_;
    };

}


#endif

]]></document_content>
  </document>
  <document index="10">
    <source>quantodoublebarrieroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Thema Consulting SA

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file quantodoublebarrieroption.hpp
    \brief Quanto version of a double barrier option
*/

#ifndef quantlib_quanto_double_barrier_option_hpp
#define quantlib_quanto_double_barrier_option_hpp

#include <ql/instruments/quantovanillaoption.hpp>
#include <ql/experimental/barrieroption/doublebarrieroption.hpp>

namespace QuantLib {

    //! Quanto version of a double barrier option
    /*! \ingroup instruments */
    class QuantoDoubleBarrierOption : public DoubleBarrierOption {
      public:
        typedef DoubleBarrierOption::arguments arguments;
        typedef QuantoOptionResults<DoubleBarrierOption::results> results;
        QuantoDoubleBarrierOption(
                        DoubleBarrier::Type barrierType,
                        Real barrier_lo,
                        Real barrier_hi,
                        Real rebate,
                        const ext::shared_ptr<StrikedTypePayoff>& payoff,
                        const ext::shared_ptr<Exercise>& exercise
            );
        //! \name greeks
        //@{
        Real qvega() const;
        Real qrho() const;
        Real qlambda() const;
        //@}
        void fetchResults(const PricingEngine::results*) const override;

      private:
        void setupExpired() const override;
        // results
        mutable Real qvega_, qrho_, qlambda_;
    };

}


#endif

]]></document_content>
  </document>
  <document index="11">
    <source>vannavolgabarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Yue Tian

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vannavolgabarrierengine.hpp
    \brief Vanna/Volga barrier option engine
*/

#ifndef quantlib_vanna_volga_barrier_engine_hpp
#define quantlib_vanna_volga_barrier_engine_hpp

#include <ql/processes/blackscholesprocess.hpp>
#include <ql/instruments/dividendbarrieroption.hpp>
#include <ql/experimental/fx/deltavolquote.hpp>

namespace QuantLib {

    //! Vanna Volga barrier option engine

    /*!
        \ingroup barrierengines
    */
    class VannaVolgaBarrierEngine
        : public GenericEngine<DividendBarrierOption::arguments,
                               DividendBarrierOption::results> {
      public:

        // Constructor
        VannaVolgaBarrierEngine(Handle<DeltaVolQuote> atmVol,
                                Handle<DeltaVolQuote> vol25Put,
                                Handle<DeltaVolQuote> vol25Call,
                                Handle<Quote> spotFX,
                                Handle<YieldTermStructure> domesticTS,
                                Handle<YieldTermStructure> foreignTS,
                                bool adaptVanDelta = false,
                                Real bsPriceWithSmile = 0.0);

        void calculate() const override;

      private:
        const Handle<DeltaVolQuote> atmVol_;
        const Handle<DeltaVolQuote> vol25Put_;
        const Handle<DeltaVolQuote> vol25Call_;
        const Time T_;
        const Handle<Quote> spotFX_;
        const Handle<YieldTermStructure> domesticTS_;
        const Handle<YieldTermStructure> foreignTS_;
        const bool adaptVanDelta_;
        const Real bsPriceWithSmile_;

    };


}

#endif /*quantlib_fd_black_scholes_barrier_engine_hpp*/
]]></document_content>
  </document>
  <document index="12">
    <source>vannavolgadoublebarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Yue Tian

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vannavolgadoublebarrierengine.hpp
    \brief Vanna/Volga double-barrier option engine
*/

#ifndef quantlib_vanna_volga_double_barrier_engine_hpp
#define quantlib_vanna_volga_double_barrier_engine_hpp

#include <ql/experimental/barrieroption/doublebarrieroption.hpp>
#include <ql/experimental/barrieroption/vannavolgainterpolation.hpp>
#include <ql/experimental/fx/blackdeltacalculator.hpp>
#include <ql/experimental/fx/deltavolquote.hpp>
#include <ql/math/matrix.hpp>
#include <ql/pricingengines/barrier/analyticbarrierengine.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <utility>

namespace QuantLib {

    //! Vanna Volga double-barrier option engine

    /*!
        \ingroup barrierengines
    */
   template <class DoubleBarrierEngine>
      class VannaVolgaDoubleBarrierEngine
           : public GenericEngine<DoubleBarrierOption::arguments,
                                  DoubleBarrierOption::results> {
         public:
           // Constructor
           VannaVolgaDoubleBarrierEngine(Handle<DeltaVolQuote> atmVol,
                                         Handle<DeltaVolQuote> vol25Put,
                                         Handle<DeltaVolQuote> vol25Call,
                                         Handle<Quote> spotFX,
                                         Handle<YieldTermStructure> domesticTS,
                                         Handle<YieldTermStructure> foreignTS,
                                         const bool adaptVanDelta = false,
                                         const Real bsPriceWithSmile = 0.0,
                                         int series = 5)
           : GenericEngine<DoubleBarrierOption::arguments, DoubleBarrierOption::results>(),
             atmVol_(std::move(atmVol)), vol25Put_(std::move(vol25Put)),
             vol25Call_(std::move(vol25Call)), T_(atmVol_->maturity()), spotFX_(std::move(spotFX)),
             domesticTS_(std::move(domesticTS)), foreignTS_(std::move(foreignTS)),
             adaptVanDelta_(adaptVanDelta), bsPriceWithSmile_(bsPriceWithSmile), series_(series) {

               QL_REQUIRE(vol25Put_->delta() == -0.25,
                          "25 delta put is required by vanna volga method");
               QL_REQUIRE(vol25Call_->delta() == 0.25,
                          "25 delta call is required by vanna volga method");

               QL_REQUIRE(vol25Put_->maturity() == vol25Call_->maturity() &&
                              vol25Put_->maturity() == atmVol_->maturity(),
                          "Maturity of 3 vols are not the same");

               QL_REQUIRE(!domesticTS_.empty(), "domestic yield curve is not defined");
               QL_REQUIRE(!foreignTS_.empty(), "foreign yield curve is not defined");

               registerWith(atmVol_);
               registerWith(vol25Put_);
               registerWith(vol25Call_);
               registerWith(spotFX_);
               registerWith(domesticTS_);
               registerWith(foreignTS_);
           }

             void calculate() const override {

                 using std::sqrt;

                 const Real sigmaShift_vega = 0.001;
                 const Real sigmaShift_volga = 0.0001;
                 const Real spotShift_delta = 0.0001 * spotFX_->value();
                 const Real sigmaShift_vanna = 0.0001;

                 QL_REQUIRE(arguments_.barrierType == DoubleBarrier::KnockIn ||
                                arguments_.barrierType == DoubleBarrier::KnockOut,
                            "Only same type barrier supported");

                 Handle<Quote> x0Quote( // used for shift
                     ext::make_shared<SimpleQuote>(spotFX_->value()));
                 Handle<Quote> atmVolQuote( // used for shift
                     ext::make_shared<SimpleQuote>(atmVol_->value()));

                 ext::shared_ptr<BlackVolTermStructure> blackVolTS =
                     ext::make_shared<BlackConstantVol>(Settings::instance().evaluationDate(),
                                                        NullCalendar(), atmVolQuote,
                                                        Actual365Fixed());
                 ext::shared_ptr<BlackScholesMertonProcess> stochProcess =
                     ext::make_shared<BlackScholesMertonProcess>(
                         x0Quote, foreignTS_, domesticTS_,
                         Handle<BlackVolTermStructure>(blackVolTS));

                 ext::shared_ptr<PricingEngine> engineBS =
                     ext::make_shared<DoubleBarrierEngine>(stochProcess, series_);

                 BlackDeltaCalculator blackDeltaCalculatorAtm(
                     Option::Call, atmVol_->deltaType(), x0Quote->value(),
                     domesticTS_->discount(T_), foreignTS_->discount(T_),
                     atmVol_->value() * sqrt(T_));
                 Real atmStrike = blackDeltaCalculatorAtm.atmStrike(atmVol_->atmType());

                 Real call25Vol = vol25Call_->value();
                 Real put25Vol = vol25Put_->value();
                 BlackDeltaCalculator blackDeltaCalculatorPut25(
                     Option::Put, vol25Put_->deltaType(), x0Quote->value(),
                     domesticTS_->discount(T_), foreignTS_->discount(T_), put25Vol * sqrt(T_));
                 Real put25Strike = blackDeltaCalculatorPut25.strikeFromDelta(-0.25);
                 BlackDeltaCalculator blackDeltaCalculatorCall25(
                     Option::Call, vol25Call_->deltaType(), x0Quote->value(),
                     domesticTS_->discount(T_), foreignTS_->discount(T_), call25Vol * sqrt(T_));
                 Real call25Strike = blackDeltaCalculatorCall25.strikeFromDelta(0.25);

                 // here use vanna volga interpolated smile to price vanilla
                 std::vector<Real> strikes;
                 std::vector<Real> vols;
                 strikes.push_back(put25Strike);
                 vols.push_back(put25Vol);
                 strikes.push_back(atmStrike);
                 vols.push_back(atmVol_->value());
                 strikes.push_back(call25Strike);
                 vols.push_back(call25Vol);
                 VannaVolga vannaVolga(x0Quote->value(), foreignTS_->discount(T_),
                                       foreignTS_->discount(T_), T_);
                 Interpolation interpolation =
                     vannaVolga.interpolate(strikes.begin(), strikes.end(), vols.begin());
                 interpolation.enableExtrapolation();
                 const ext::shared_ptr<StrikedTypePayoff> payoff =
                     ext::dynamic_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
                 Real strikeVol = interpolation(payoff->strike());
                 // vanilla option price
                 Real vanillaOption = blackFormula(payoff->optionType(), payoff->strike(),
                                                   x0Quote->value() * foreignTS_->discount(T_) /
                                                       domesticTS_->discount(T_),
                                                   strikeVol * sqrt(T_), domesticTS_->discount(T_));

                 // already out
                 if ((x0Quote->value() > arguments_.barrier_hi ||
                      x0Quote->value() < arguments_.barrier_lo) &&
                     arguments_.barrierType == DoubleBarrier::KnockOut) {
                     results_.value = 0.0;
                     results_.additionalResults["VanillaPrice"] =
                         adaptVanDelta_ ? bsPriceWithSmile_ : vanillaOption;
                     results_.additionalResults["BarrierInPrice"] =
                         adaptVanDelta_ ? bsPriceWithSmile_ : vanillaOption;
                     results_.additionalResults["BarrierOutPrice"] = 0.0;
                 }
                 // already in
                 else if ((x0Quote->value() > arguments_.barrier_hi ||
                           x0Quote->value() < arguments_.barrier_lo) &&
                          arguments_.barrierType == DoubleBarrier::KnockIn) {
                     results_.value = adaptVanDelta_ ? bsPriceWithSmile_ : vanillaOption;
                     results_.additionalResults["VanillaPrice"] =
                         adaptVanDelta_ ? bsPriceWithSmile_ : vanillaOption;
                     results_.additionalResults["BarrierInPrice"] =
                         adaptVanDelta_ ? bsPriceWithSmile_ : vanillaOption;
                     results_.additionalResults["BarrierOutPrice"] = 0.0;
                 } else {

                     // set up BS barrier option pricing
                     // only calculate out barrier option price
                     // in barrier price = vanilla - out barrier
                     ext::shared_ptr<StrikedTypePayoff> payoff =
                         ext::static_pointer_cast<StrikedTypePayoff>(arguments_.payoff);
                     DoubleBarrierOption doubleBarrierOption(
                         DoubleBarrier::KnockOut, arguments_.barrier_lo, arguments_.barrier_hi,
                         arguments_.rebate, payoff, arguments_.exercise);

                     doubleBarrierOption.setPricingEngine(engineBS);

                     // BS price
                     Real priceBS = doubleBarrierOption.NPV();

                     Real priceAtmCallBS = blackFormula(
                         Option::Call, atmStrike,
                         x0Quote->value() * foreignTS_->discount(T_) / domesticTS_->discount(T_),
                         atmVol_->value() * sqrt(T_), domesticTS_->discount(T_));
                     Real price25CallBS = blackFormula(
                         Option::Call, call25Strike,
                         x0Quote->value() * foreignTS_->discount(T_) / domesticTS_->discount(T_),
                         atmVol_->value() * sqrt(T_), domesticTS_->discount(T_));
                     Real price25PutBS = blackFormula(
                         Option::Put, put25Strike,
                         x0Quote->value() * foreignTS_->discount(T_) / domesticTS_->discount(T_),
                         atmVol_->value() * sqrt(T_), domesticTS_->discount(T_));

                     // market price
                     Real priceAtmCallMkt = blackFormula(
                         Option::Call, atmStrike,
                         x0Quote->value() * foreignTS_->discount(T_) / domesticTS_->discount(T_),
                         atmVol_->value() * sqrt(T_), domesticTS_->discount(T_));
                     Real price25CallMkt = blackFormula(
                         Option::Call, call25Strike,
                         x0Quote->value() * foreignTS_->discount(T_) / domesticTS_->discount(T_),
                         call25Vol * sqrt(T_), domesticTS_->discount(T_));
                     Real price25PutMkt = blackFormula(
                         Option::Put, put25Strike,
                         x0Quote->value() * foreignTS_->discount(T_) / domesticTS_->discount(T_),
                         put25Vol * sqrt(T_), domesticTS_->discount(T_));

                     // Analytical Black Scholes formula
                     NormalDistribution norm;
                     Real d1atm = (std::log(x0Quote->value() * foreignTS_->discount(T_) /
                                            domesticTS_->discount(T_) / atmStrike) +
                                   0.5 * std::pow(atmVolQuote->value(), 2.0) * T_) /
                                  (atmVolQuote->value() * sqrt(T_));
                     Real vegaAtm_Analytical =
                         x0Quote->value() * norm(d1atm) * sqrt(T_) * foreignTS_->discount(T_);
                     Real vannaAtm_Analytical = vegaAtm_Analytical / x0Quote->value() *
                                                (1.0 - d1atm / (atmVolQuote->value() * sqrt(T_)));
                     Real volgaAtm_Analytical = vegaAtm_Analytical * d1atm *
                                                (d1atm - atmVolQuote->value() * sqrt(T_)) /
                                                atmVolQuote->value();

                     Real d125call = (std::log(x0Quote->value() * foreignTS_->discount(T_) /
                                               domesticTS_->discount(T_) / call25Strike) +
                                      0.5 * std::pow(atmVolQuote->value(), 2.0) * T_) /
                                     (atmVolQuote->value() * sqrt(T_));
                     Real vega25Call_Analytical =
                         x0Quote->value() * norm(d125call) * sqrt(T_) * foreignTS_->discount(T_);
                     Real vanna25Call_Analytical =
                         vega25Call_Analytical / x0Quote->value() *
                         (1.0 - d125call / (atmVolQuote->value() * sqrt(T_)));
                     Real volga25Call_Analytical = vega25Call_Analytical * d125call *
                                                   (d125call - atmVolQuote->value() * sqrt(T_)) /
                                                   atmVolQuote->value();

                     Real d125Put = (std::log(x0Quote->value() * foreignTS_->discount(T_) /
                                              domesticTS_->discount(T_) / put25Strike) +
                                     0.5 * std::pow(atmVolQuote->value(), 2.0) * T_) /
                                    (atmVolQuote->value() * sqrt(T_));
                     Real vega25Put_Analytical =
                         x0Quote->value() * norm(d125Put) * sqrt(T_) * foreignTS_->discount(T_);
                     Real vanna25Put_Analytical =
                         vega25Put_Analytical / x0Quote->value() *
                         (1.0 - d125Put / (atmVolQuote->value() * sqrt(T_)));
                     Real volga25Put_Analytical = vega25Put_Analytical * d125Put *
                                                  (d125Put - atmVolQuote->value() * sqrt(T_)) /
                                                  atmVolQuote->value();


                     // BS vega
                     ext::static_pointer_cast<SimpleQuote>(atmVolQuote.currentLink())
                         ->setValue(atmVolQuote->value() + sigmaShift_vega);
                     doubleBarrierOption.recalculate();
                     Real vegaBarBS = (doubleBarrierOption.NPV() - priceBS) / sigmaShift_vega;
                     ext::static_pointer_cast<SimpleQuote>(atmVolQuote.currentLink())
                         ->setValue(atmVolQuote->value() - sigmaShift_vega); // setback

                     // BS volga

                     // vegaBar2
                     // base NPV
                     ext::static_pointer_cast<SimpleQuote>(atmVolQuote.currentLink())
                         ->setValue(atmVolQuote->value() + sigmaShift_volga);
                     doubleBarrierOption.recalculate();
                     Real priceBS2 = doubleBarrierOption.NPV();

                     // shifted npv
                     ext::static_pointer_cast<SimpleQuote>(atmVolQuote.currentLink())
                         ->setValue(atmVolQuote->value() + sigmaShift_vega);
                     doubleBarrierOption.recalculate();
                     Real vegaBarBS2 = (doubleBarrierOption.NPV() - priceBS2) / sigmaShift_vega;
                     Real volgaBarBS = (vegaBarBS2 - vegaBarBS) / sigmaShift_volga;
                     ext::static_pointer_cast<SimpleQuote>(atmVolQuote.currentLink())
                         ->setValue(atmVolQuote->value() - sigmaShift_volga -
                                    sigmaShift_vega); // setback

                     // BS Delta
                     // base delta
                     ext::static_pointer_cast<SimpleQuote>(x0Quote.currentLink())
                         ->setValue(x0Quote->value() + spotShift_delta); // shift forth
                     doubleBarrierOption.recalculate();
                     Real priceBS_delta1 = doubleBarrierOption.NPV();

                     ext::static_pointer_cast<SimpleQuote>(x0Quote.currentLink())
                         ->setValue(x0Quote->value() - 2 * spotShift_delta); // shift back
                     doubleBarrierOption.recalculate();
                     Real priceBS_delta2 = doubleBarrierOption.NPV();

                     ext::static_pointer_cast<SimpleQuote>(x0Quote.currentLink())
                         ->setValue(x0Quote->value() + spotShift_delta); // set back
                     Real deltaBar1 = (priceBS_delta1 - priceBS_delta2) / (2.0 * spotShift_delta);

                     // shifted vanna
                     ext::static_pointer_cast<SimpleQuote>(atmVolQuote.currentLink())
                         ->setValue(atmVolQuote->value() + sigmaShift_vanna); // shift sigma
                     // shifted delta
                     ext::static_pointer_cast<SimpleQuote>(x0Quote.currentLink())
                         ->setValue(x0Quote->value() + spotShift_delta); // shift forth
                     doubleBarrierOption.recalculate();
                     priceBS_delta1 = doubleBarrierOption.NPV();

                     ext::static_pointer_cast<SimpleQuote>(x0Quote.currentLink())
                         ->setValue(x0Quote->value() - 2 * spotShift_delta); // shift back
                     doubleBarrierOption.recalculate();
                     priceBS_delta2 = doubleBarrierOption.NPV();

                     ext::static_pointer_cast<SimpleQuote>(x0Quote.currentLink())
                         ->setValue(x0Quote->value() + spotShift_delta); // set back
                     Real deltaBar2 = (priceBS_delta1 - priceBS_delta2) / (2.0 * spotShift_delta);

                     Real vannaBarBS = (deltaBar2 - deltaBar1) / sigmaShift_vanna;

                     ext::static_pointer_cast<SimpleQuote>(atmVolQuote.currentLink())
                         ->setValue(atmVolQuote->value() - sigmaShift_vanna); // set back

                     // Matrix
                     Matrix A(3, 3, 0.0);

                     // analytical
                     A[0][0] = vegaAtm_Analytical;
                     A[0][1] = vega25Call_Analytical;
                     A[0][2] = vega25Put_Analytical;
                     A[1][0] = vannaAtm_Analytical;
                     A[1][1] = vanna25Call_Analytical;
                     A[1][2] = vanna25Put_Analytical;
                     A[2][0] = volgaAtm_Analytical;
                     A[2][1] = volga25Call_Analytical;
                     A[2][2] = volga25Put_Analytical;

                     Array b(3, 0.0);
                     b[0] = vegaBarBS;
                     b[1] = vannaBarBS;
                     b[2] = volgaBarBS;
                     Array q = inverse(A) * b;

                     Real H = arguments_.barrier_hi;
                     Real L = arguments_.barrier_lo;
                     Real theta_tilt_minus = ((domesticTS_->zeroRate(T_, Continuous) -
                                               foreignTS_->zeroRate(T_, Continuous)) /
                                                  atmVol_->value() -
                                              atmVol_->value() / 2.0) *
                                             std::sqrt(T_);
                     Real h =
                         1.0 / atmVol_->value() * std::log(H / x0Quote->value()) / std::sqrt(T_);
                     Real l =
                         1.0 / atmVol_->value() * std::log(L / x0Quote->value()) / std::sqrt(T_);
                     CumulativeNormalDistribution cnd;

                     Real doubleNoTouch = 0.0;
                     for (int j = -series_; j < series_; j++) {
                         Real e_minus = 2 * j * (h - l) - theta_tilt_minus;
                         doubleNoTouch +=
                             std::exp(-2.0 * j * theta_tilt_minus * (h - l)) *
                                 (cnd(h + e_minus) - cnd(l + e_minus)) -
                             std::exp(-2.0 * j * theta_tilt_minus * (h - l) +
                                      2.0 * theta_tilt_minus * h) *
                                 (cnd(h - 2.0 * h + e_minus) - cnd(l - 2.0 * h + e_minus));
                     }

                     Real p_survival = doubleNoTouch;

                     Real lambda = p_survival;
                     Real adjust = q[0] * (priceAtmCallMkt - priceAtmCallBS) +
                                   q[1] * (price25CallMkt - price25CallBS) +
                                   q[2] * (price25PutMkt - price25PutBS);
                     Real outPrice = priceBS + lambda * adjust; //
                     Real inPrice;

                     // adapt Vanilla delta
                     if (adaptVanDelta_) {
                         outPrice += lambda * (bsPriceWithSmile_ - vanillaOption);
                         // capfloored by (0, vanilla)
                         outPrice = std::max(0.0, std::min(bsPriceWithSmile_, outPrice));
                         inPrice = bsPriceWithSmile_ - outPrice;
                     } else {
                         // capfloored by (0, vanilla)
                         outPrice = std::max(0.0, std::min(vanillaOption, outPrice));
                         inPrice = vanillaOption - outPrice;
                     }

                     if (arguments_.barrierType == DoubleBarrier::KnockOut)
                         results_.value = outPrice;
                     else
                         results_.value = inPrice;
                     results_.additionalResults["VanillaPrice"] = vanillaOption;
                     results_.additionalResults["BarrierInPrice"] = inPrice;
                     results_.additionalResults["BarrierOutPrice"] = outPrice;
                     results_.additionalResults["lambda"] = lambda;
                 }
             }


         private:
           const Handle<DeltaVolQuote> atmVol_;
           const Handle<DeltaVolQuote> vol25Put_;
           const Handle<DeltaVolQuote> vol25Call_;
           const Time T_;
           const Handle<Quote> spotFX_;
           const Handle<YieldTermStructure> domesticTS_;
           const Handle<YieldTermStructure> foreignTS_;
           const bool adaptVanDelta_;
           const Real bsPriceWithSmile_;
           const int series_;
       };


}

#endif
]]></document_content>
  </document>
  <document index="13">
    <source>vannavolgainterpolation.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Yue Tian

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vannavolgainterpolation.hpp
    \brief Vanna/Volga interpolation between discrete points
*/

#ifndef quantlib_vanna_volga_interpolation_hpp
#define quantlib_vanna_volga_interpolation_hpp

#include <ql/math/interpolation.hpp>
#include <ql/pricingengines/blackformula.hpp>
#include <ql/math/distributions/normaldistribution.hpp>
#include <vector>

namespace QuantLib {

    namespace detail {
        template<class I1, class I2> class VannaVolgaInterpolationImpl;
    }

    //! %Vanna Volga interpolation between discrete points
    class VannaVolgaInterpolation : public Interpolation {
      public:
        /*! \pre the \f$ x \f$ values must be sorted. */
        template <class I1, class I2>
        VannaVolgaInterpolation(const I1& xBegin, const I1& xEnd,
                            const I2& yBegin,
                            Real spot,
                            DiscountFactor dDiscount,
                            DiscountFactor fDiscount,
                            Time T) {
            impl_ = ext::make_shared<
                detail::VannaVolgaInterpolationImpl<I1,I2> >(
                    xBegin, xEnd, yBegin,
                    spot, dDiscount, fDiscount, T);
            impl_->update();
        }
    };

    //! %VannaVolga-interpolation factory and traits
    class VannaVolga {
      public:
        VannaVolga(Real spot,
                   DiscountFactor dDiscount,
                   DiscountFactor fDiscount,
                   Time T)
        :spot_(spot), dDiscount_(dDiscount), fDiscount_(fDiscount), T_(T)
        {}
        template <class I1, class I2>
        Interpolation interpolate(const I1& xBegin, const I1& xEnd,
                                  const I2& yBegin) const {
            return VannaVolgaInterpolation(xBegin, xEnd, yBegin, spot_, dDiscount_, fDiscount_, T_);
        }
        static const Size requiredPoints = 3;
      private:
        Real spot_;
        DiscountFactor dDiscount_;
        DiscountFactor fDiscount_;
        Time T_;
    };

    namespace detail {

        template <class I1, class I2>
        class VannaVolgaInterpolationImpl
            : public Interpolation::templateImpl<I1,I2> {
          public:
            VannaVolgaInterpolationImpl(const I1& xBegin, const I1& xEnd,
                                    const I2& yBegin,
                                    Real spot,
                                    DiscountFactor dDiscount,
                                    DiscountFactor fDiscount,
                                    Time T)
            : Interpolation::templateImpl<I1,I2>(xBegin, xEnd, yBegin,
                                                 VannaVolga::requiredPoints),
              spot_(spot), dDiscount_(dDiscount), fDiscount_(fDiscount), T_(T) {
                QL_REQUIRE(this->xEnd_-this->xBegin_ == 3,
                    "Vanna Volga Interpolator only interpolates 3 volatilities in strike space");
            }
            void update() override {
                //atmVol should be the second vol
                atmVol_ = this->yBegin_[1];
                fwd_ = spot_*fDiscount_/dDiscount_;
                for(Size i = 0; i < 3; i++){
                    premiaBS.push_back(blackFormula(Option::Call, this->xBegin_[i], fwd_, atmVol_ * std::sqrt(T_), dDiscount_));
                    premiaMKT.push_back(blackFormula(Option::Call, this->xBegin_[i], fwd_, this->yBegin_[i] * std::sqrt(T_), dDiscount_));
                    vegas.push_back(vega(this->xBegin_[i]));
                }
            }
            Real value(Real k) const override {
                Real x1 = vega(k)/vegas[0]
                    * (std::log(this->xBegin_[1]/k) * std::log(this->xBegin_[2]/k))
                    / (std::log(this->xBegin_[1]/this->xBegin_[0]) * std::log(this->xBegin_[2]/this->xBegin_[0]));
                Real x2 = vega(k)/vegas[1]
                    * (std::log(k/this->xBegin_[0]) * std::log(this->xBegin_[2]/k))
                    / (std::log(this->xBegin_[1]/this->xBegin_[0]) * std::log(this->xBegin_[2]/this->xBegin_[1]));
                Real x3 = vega(k)/vegas[2]
                    * (std::log(k/this->xBegin_[0]) * std::log(k/this->xBegin_[1]))
                    / (std::log(this->xBegin_[2]/this->xBegin_[0]) * std::log(this->xBegin_[2]/this->xBegin_[1]));

                Real cBS = blackFormula(Option::Call, k, fwd_, atmVol_ * std::sqrt(T_), dDiscount_);
                Real c = cBS + x1*(premiaMKT[0] - premiaBS[0]) + x2*(premiaMKT[1] - premiaBS[1]) + x3*(premiaMKT[2] - premiaBS[2]);
                Real std = blackFormulaImpliedStdDev(Option::Call, k, fwd_, c, dDiscount_);
                return std / sqrt(T_);
            }
            Real primitive(Real) const override {
                QL_FAIL("Vanna Volga primitive not implemented");
            }
            Real derivative(Real) const override {
                QL_FAIL("Vanna Volga derivative not implemented");
            }
            Real secondDerivative(Real) const override {
                QL_FAIL("Vanna Volga secondDerivative not implemented");
            }

          private:
            std::vector<Real> premiaBS;
            std::vector<Real> premiaMKT;
            std::vector<Real> vegas;
            Real atmVol_;
            Real spot_;
            Real fwd_;
            DiscountFactor dDiscount_;
            DiscountFactor fDiscount_;
            Time T_;

            Real vega(Real k) const {
                Real d1 = (std::log(fwd_/k) + 0.5 * std::pow(atmVol_, 2.0) * T_)/(atmVol_ * std::sqrt(T_));
                NormalDistribution norm;
                return spot_ * dDiscount_ * std::sqrt(T_) * norm(d1);
            }
        };

    }

}

#endif
]]></document_content>
  </document>
  <document index="14">
    <source>wulinyongdoublebarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Yue Tian

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file wulinyongdoublebarrierengine.hpp
    \brief Wulin Suo, Yong Wang double-barrier option engine
*/

#ifndef wulin_yong_double_barrier_engine_hpp
#define wulin_yong_double_barrier_engine_hpp

#include <ql/experimental/barrieroption/doublebarrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/math/distributions/normaldistribution.hpp>

namespace QuantLib {

    //! Pricing engine for barrier options using analytical formulae
    /*! The formulas are taken from "Barrier Option Pricing",
         Wulin Suo, Yong Wang.

        \ingroup barrierengines

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class WulinYongDoubleBarrierEngine : public DoubleBarrierOption::engine {
      public:
        explicit WulinYongDoubleBarrierEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process, int series = 5);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        const int series_;
        CumulativeNormalDistribution f_;
        // helper methods
        Real strike() const;
        Time residualTime() const;
        Volatility volatility() const;
        Rate riskFreeRate() const;
        DiscountFactor riskFreeDiscount() const;
        Rate dividendYield() const;
        DiscountFactor dividendDiscount() const;
        Real D(Real X, Real lambda, Real sigma, Real T) const;

    };

}


#endif
]]></document_content>
  </document>
</documents>