<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/basismodels/swaptioncfs.hpp>
#include <ql/experimental/basismodels/tenoroptionletvts.hpp>
#include <ql/experimental/basismodels/tenorswaptionvts.hpp>

]]></document_content>
  </document>
  <document index="2">
    <source>swaptioncfs.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2018 Sebastian Schlenkrich

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file swaptioncfs.hpp
    \brief translate swaption into deterministic fixed and float cash flows
*/

#ifndef quantlib_swaptioncfs_hpp
#define quantlib_swaptioncfs_hpp

#include <ql/instruments/swaption.hpp>
#include <ql/option.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/time/date.hpp>

namespace QuantLib {

    class IborLegCashFlows {
      protected:
        Date refDate_; // today, base for time calculations w.r.t. Act/365 (Fixed)
        Leg floatLeg_;
        std::vector<Real> floatTimes_;
        std::vector<Real> floatWeights_;

      public:
        inline const Leg& floatLeg() const { return floatLeg_; }
        inline const std::vector<Real>& floatTimes() const { return floatTimes_; }
        inline const std::vector<Real>& floatWeights() const { return floatWeights_; }
        IborLegCashFlows(const Leg& iborLeg,
                         const Handle<YieldTermStructure>& discountCurve,
                         bool contTenorSpread = true);
        IborLegCashFlows() = default;
        ; // allow default constructor which does nothing
    };


    class SwapCashFlows : public IborLegCashFlows {
      protected:
        // resulting cash flows as leg
        Leg fixedLeg_;
        std::vector<Real> fixedTimes_;
        std::vector<Real> fixedWeights_;
        std::vector<Real> annuityWeights_;

      public:
        SwapCashFlows(const ext::shared_ptr<VanillaSwap>& swap,
                      const Handle<YieldTermStructure>& discountCurve,
                      bool contTenorSpread = true);
        SwapCashFlows() = default;
        ; // allow default constructor which does nothing
          // inspectors
        inline const Leg& fixedLeg() const { return fixedLeg_; }
        inline const std::vector<Real>& fixedTimes() const { return fixedTimes_; }
        inline const std::vector<Real>& fixedWeights() const { return fixedWeights_; }
        inline const std::vector<Real>& annuityWeights() const { return annuityWeights_; }
    };


    class SwaptionCashFlows : public SwapCashFlows {
      protected:
        ext::shared_ptr<Swaption> swaption_;
        std::vector<Real> exerciseTimes_;

      public:
        SwaptionCashFlows(const ext::shared_ptr<Swaption>& swaption,
                          const Handle<YieldTermStructure>& discountCurve,
                          bool contTenorSpread = true);
        SwaptionCashFlows() = default;
        ; // allow default constructor which does nothing
        // inspectors
        inline ext::shared_ptr<Swaption> swaption() const { return swaption_; }
        inline const std::vector<Real>& exerciseTimes() const { return exerciseTimes_; }
    };


}

#endif
]]></document_content>
  </document>
  <document index="3">
    <source>tenoroptionletvts.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2018 Sebastian Schlenkrich

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file tenoroptionletvts.hpp
    \brief caplet volatility term structure based on volatility transformation
*/

#ifndef quantlib_tenoroptionletvts_hpp
#define quantlib_tenoroptionletvts_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/math/interpolation.hpp>
#include <ql/termstructures/volatility/optionlet/optionletvolatilitystructure.hpp>
#include <ql/termstructures/volatility/smilesection.hpp>
#include <ql/time/dategenerationrule.hpp>
#include <utility>


namespace QuantLib {

    class TenorOptionletVTS : public OptionletVolatilityStructure {

      public:
        class CorrelationStructure; // declaration below

      protected:
        class TenorOptionletSmileSection : public SmileSection {
          protected:
            ext::shared_ptr<CorrelationStructure> correlation_;
            std::vector<ext::shared_ptr<SmileSection> > baseSmileSection_;
            std::vector<Time> startTimeBase_; // for correlation parametrisation
            std::vector<Real> fraRateBase_;
            Real fraRateTarg_;
            std::vector<Real> v_;
            // implement transformation formula
            Volatility volatilityImpl(Rate strike) const override;

          public:
            // constructor includes actual transformation details
            TenorOptionletSmileSection(const TenorOptionletVTS& volTS, Time optionTime);

            // further SmileSection interface methods
            Real minStrike() const override {
                return baseSmileSection_[0]->minStrike() + fraRateTarg_ - fraRateBase_[0];
            }
            Real maxStrike() const override {
                return baseSmileSection_[0]->maxStrike() + fraRateTarg_ - fraRateBase_[0];
            }
            Real atmLevel() const override { return fraRateTarg_; }
        };

        Handle<OptionletVolatilityStructure> baseVTS_;
        ext::shared_ptr<IborIndex> baseIndex_;
        ext::shared_ptr<IborIndex> targIndex_;
        ext::shared_ptr<CorrelationStructure> correlation_;

      public:
        // functor interface for parametric correlation
        class CorrelationStructure {
          public:
            // return the correlation between two FRA rates starting at start1 and start2
            virtual Real operator()(const Time& start1, const Time& start2) const = 0;
            virtual ~CorrelationStructure() = default;
            ;
        };

        // very basic choice for correlation structure
        class TwoParameterCorrelation : public CorrelationStructure {
          protected:
            ext::shared_ptr<Interpolation> rhoInf_;
            ext::shared_ptr<Interpolation> beta_;

          public:
            TwoParameterCorrelation(ext::shared_ptr<Interpolation> rhoInf,
                                    ext::shared_ptr<Interpolation> beta)
            : rhoInf_(std::move(rhoInf)), beta_(std::move(beta)) {}
            Real operator()(const Time& start1, const Time& start2) const override {
                Real rhoInf = (*rhoInf_)(start1);
                Real beta = (*beta_)(start1);
                Real rho = rhoInf + (1.0 - rhoInf) * exp(-beta * fabs(start2 - start1));
                return rho;
            }
        };

        // constructor
        TenorOptionletVTS(const Handle<OptionletVolatilityStructure>& baseVTS,
                          ext::shared_ptr<IborIndex> baseIndex,
                          ext::shared_ptr<IborIndex> targIndex,
                          ext::shared_ptr<CorrelationStructure> correlation);

        // Termstructure interface

        //! the latest date for which the curve can return values
        Date maxDate() const override { return baseVTS_->maxDate(); }

        // VolatilityTermstructure interface

        //! implements the actual smile calculation in derived classes
        ext::shared_ptr<SmileSection> smileSectionImpl(Time optionTime) const override {
            return ext::shared_ptr<SmileSection>(new TenorOptionletSmileSection(*this, optionTime));
        }
        //! implements the actual volatility calculation in derived classes
        Volatility volatilityImpl(Time optionTime, Rate strike) const override {
            return smileSection(optionTime)->volatility(strike);
        }


        //! the minimum strike for which the term structure can return vols
        Rate minStrike() const override { return baseVTS_->minStrike(); }
        //! the maximum strike for which the term structure can return vols
        Rate maxStrike() const override { return baseVTS_->maxStrike(); }

        // the methodology is designed for normal volatilities
        VolatilityType volatilityType() const override { return Normal; }
    };

    typedef TenorOptionletVTS::CorrelationStructure TenorOptionletVTSCorrelationStructure;

}

#endif
]]></document_content>
  </document>
  <document index="4">
    <source>tenorswaptionvts.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2018 Sebastian Schlenkrich

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file tenorswaptionvts.hpp
    \brief swaption volatility term structure based on volatility transformation
*/

#ifndef quantlib_tenorswaptionvts_hpp
#define quantlib_tenorswaptionvts_hpp

#include <ql/instruments/swaption.hpp>
#include <ql/option.hpp>
#include <ql/termstructures/volatility/smilesection.hpp>
#include <ql/termstructures/volatility/swaption/swaptionvolstructure.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/time/date.hpp>
#include <utility>

namespace QuantLib {

    class TenorSwaptionVTS : public SwaptionVolatilityStructure {
      protected:
        class TenorSwaptionSmileSection : public SmileSection {
          protected:
            ext::shared_ptr<SmileSection> baseSmileSection_;
            Real swapRateBase_;
            Real swapRateTarg_;
            Real swapRateFinl_;
            Real lambda_;
            Real annuityScaling_;
            // implement transformation formula
            Volatility volatilityImpl(Rate strike) const override;

          public:
            // constructor includes actual transformation details
            TenorSwaptionSmileSection(const TenorSwaptionVTS& volTS,
                                      Time optionTime,
                                      Time swapLength);

            // further SmileSection interface methods
            Real minStrike() const override {
                return baseSmileSection_->minStrike() + swapRateTarg_ - swapRateBase_;
            }
            Real maxStrike() const override {
                return baseSmileSection_->maxStrike() + swapRateTarg_ - swapRateBase_;
            }
            Real atmLevel() const override { return swapRateFinl_; }
        };

        Handle<SwaptionVolatilityStructure> baseVTS_;
        Handle<YieldTermStructure> discountCurve_;

        ext::shared_ptr<IborIndex> baseIndex_;
        ext::shared_ptr<IborIndex> targIndex_;
        Period baseFixedFreq_;
        Period targFixedFreq_;
        DayCounter baseFixedDC_;
        DayCounter targFixedDC_;

      public:
        // constructor
        TenorSwaptionVTS(const Handle<SwaptionVolatilityStructure>& baseVTS,
                         Handle<YieldTermStructure> discountCurve,
                         ext::shared_ptr<IborIndex> baseIndex,
                         ext::shared_ptr<IborIndex> targIndex,
                         const Period& baseFixedFreq,
                         const Period& targFixedFreq,
                         DayCounter baseFixedDC,
                         DayCounter targFixedDC)
        : SwaptionVolatilityStructure(baseVTS->referenceDate(),
                                      baseVTS->calendar(),
                                      baseVTS->businessDayConvention(),
                                      baseVTS->dayCounter()),
          baseVTS_(baseVTS), discountCurve_(std::move(discountCurve)),
          baseIndex_(std::move(baseIndex)), targIndex_(std::move(targIndex)),
          baseFixedFreq_(baseFixedFreq), targFixedFreq_(targFixedFreq),
          baseFixedDC_(std::move(baseFixedDC)), targFixedDC_(std::move(targFixedDC)) {}

        // Termstructure interface

        //! the latest date for which the curve can return values
        Date maxDate() const override { return baseVTS_->maxDate(); }

        // SwaptionVolatility interface

        //! the minimum strike for which the term structure can return vols
        Rate minStrike() const override { return baseVTS_->minStrike(); }
        //! the maximum strike for which the term structure can return vols
        Rate maxStrike() const override { return baseVTS_->maxStrike(); }


        // SwaptionVolatilityStructure interface

        //! the largest length for which the term structure can return vols
        const Period& maxSwapTenor() const override { return baseVTS_->maxSwapTenor(); }

        ext::shared_ptr<SmileSection> smileSectionImpl(Time optionTime,
                                                       Time swapLength) const override {
            return ext::shared_ptr<SmileSection>(
                new TenorSwaptionSmileSection(*this, optionTime, swapLength));
        }

        Volatility volatilityImpl(Time optionTime, Time swapLength, Rate strike) const override {
            return smileSectionImpl(optionTime, swapLength)->volatility(strike, Normal, 0.0);
        }

        // the methodology is designed for normal volatilities
        VolatilityType volatilityType() const override { return Normal; }
    };

}

#endif
]]></document_content>
  </document>
</documents>