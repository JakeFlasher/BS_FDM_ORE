<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/exoticoptions/analyticamericanmargrabeengine.hpp>
#include <ql/experimental/exoticoptions/analyticcomplexchooserengine.hpp>
#include <ql/experimental/exoticoptions/analyticcompoundoptionengine.hpp>
#include <ql/experimental/exoticoptions/analyticeuropeanmargrabeengine.hpp>
#include <ql/experimental/exoticoptions/analyticholderextensibleoptionengine.hpp>
#include <ql/experimental/exoticoptions/analyticpartialtimebarrieroptionengine.hpp>
#include <ql/experimental/exoticoptions/analyticpdfhestonengine.hpp>
#include <ql/experimental/exoticoptions/analyticsimplechooserengine.hpp>
#include <ql/experimental/exoticoptions/analytictwoassetbarrierengine.hpp>
#include <ql/experimental/exoticoptions/analytictwoassetcorrelationengine.hpp>
#include <ql/experimental/exoticoptions/analyticwriterextensibleoptionengine.hpp>
#include <ql/experimental/exoticoptions/complexchooseroption.hpp>
#include <ql/experimental/exoticoptions/compoundoption.hpp>
#include <ql/experimental/exoticoptions/continuousarithmeticasianlevyengine.hpp>
#include <ql/experimental/exoticoptions/continuousarithmeticasianvecerengine.hpp>
#include <ql/experimental/exoticoptions/everestoption.hpp>
#include <ql/experimental/exoticoptions/himalayaoption.hpp>
#include <ql/experimental/exoticoptions/holderextensibleoption.hpp>
#include <ql/experimental/exoticoptions/kirkspreadoptionengine.hpp>
#include <ql/experimental/exoticoptions/margrabeoption.hpp>
#include <ql/experimental/exoticoptions/mceverestengine.hpp>
#include <ql/experimental/exoticoptions/mchimalayaengine.hpp>
#include <ql/experimental/exoticoptions/mcpagodaengine.hpp>
#include <ql/experimental/exoticoptions/pagodaoption.hpp>
#include <ql/experimental/exoticoptions/partialtimebarrieroption.hpp>
#include <ql/experimental/exoticoptions/simplechooseroption.hpp>
#include <ql/experimental/exoticoptions/spreadoption.hpp>
#include <ql/experimental/exoticoptions/twoassetbarrieroption.hpp>
#include <ql/experimental/exoticoptions/twoassetcorrelationoption.hpp>
#include <ql/experimental/exoticoptions/writerextensibleoption.hpp>

]]></document_content>
  </document>
  <document index="2">
    <source>analyticamericanmargrabeengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticamericanmargrabeengine.hpp
    \brief Analytic engine for American Margrabe option
*/

#ifndef quantlib_analytic_american_margrabe_engine_hpp
#define quantlib_analytic_american_margrabe_engine_hpp

#include <ql/experimental/exoticoptions/margrabeoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic engine for American Margrabe option
    /*! This class implements formulae from
        "The Value of an American Option to Exchange One Asset for Another",
        W. Margrabe,
        Journal of Finance, 33, 177-86.

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class AnalyticAmericanMargrabeEngine : public MargrabeOption::engine {
      public:
        AnalyticAmericanMargrabeEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
                                       ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
                                       Real correlation);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2_;
        Real rho_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="3">
    <source>analyticcomplexchooserengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticcomplexchooserengine.hpp
    \brief Analytic engine for complex chooser option
*/

#ifndef quantlib_analytic_complex_chooser_engine_hpp
#define quantlib_analytic_complex_chooser_engine_hpp

#include <ql/experimental/exoticoptions/complexchooseroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/pricingengines/blackscholescalculator.hpp>

namespace QuantLib {

    class AnalyticComplexChooserEngine : public ComplexChooserOption::engine {
      public:
        explicit AnalyticComplexChooserEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Real strike(Option::Type optionType) const;
        Time choosingTime() const;
        Time putMaturity() const;
        Time callMaturity() const;
        Volatility volatility(Time t) const;

        Rate dividendYield(Time t) const;
        DiscountFactor dividendDiscount(Time t) const;

        Rate riskFreeRate(Time t) const;
        DiscountFactor riskFreeDiscount(Time t) const;

        BlackScholesCalculator bsCalculator(Real spot,
                                            Option::Type optionType) const;
        Real CriticalValueChooser() const;
        Real ComplexChooser() const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="4">
    <source>analyticcompoundoptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticcompoundoptionengine.hpp
    \brief Analytic compound option engines
*/

#ifndef quantlib_analytic_compound_option_engine_hpp
#define quantlib_analytic_compound_option_engine_hpp

#include <ql/experimental/exoticoptions/compoundoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/math/distributions/bivariatenormaldistribution.hpp>

namespace QuantLib {

    //! Pricing engine for compound options using analytical formulae
    /*! The formulas are taken from "Foreign Exchange Risk",
        Uwe Wystup, Risk 2002, where closed form Greeks are available.
        (not available in Haug 2007).
        Value: Page 84, Greeks: Pages 94-95.

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class AnalyticCompoundOptionEngine : public CompoundOption::engine {
      public:
        explicit AnalyticCompoundOptionEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        CumulativeNormalDistribution N_;
        NormalDistribution n_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;

        // helper methods
        Time residualTimeMother() const;
        Time residualTimeDaughter() const;
        Time residualTimeMotherDaughter() const;

        Date maturityMother() const;
        Date maturityDaughter() const;

        Real dPlus() const;
        Real dMinus() const;

        Real dPlusTau12(Real S) const;
        Real dMinusTau12() const;

        Real strikeDaughter() const;
        Real strikeMother() const;

        Real spot() const;

        Real volatilityDaughter() const;
        Real volatilityMother() const;

        Real riskFreeRateDaughter() const;
        Real dividendRateDaughter() const;

        Real stdDeviationDaughter() const;
        Real stdDeviationMother() const;

        Real typeDaughter() const;
        Real typeMother() const;

        Real transformX(Real X) const;
        Real e(Real X) const;

        DiscountFactor riskFreeDiscountDaughter() const;
        DiscountFactor riskFreeDiscountMother() const;
        DiscountFactor riskFreeDiscountMotherDaughter() const;

        DiscountFactor dividendDiscountDaughter() const;
        DiscountFactor dividendDiscountMother() const;
        DiscountFactor dividendDiscountMotherDaughter() const;

        ext::shared_ptr<PlainVanillaPayoff> payoffMother() const;
        ext::shared_ptr<PlainVanillaPayoff> payoffDaughter() const;
    };

}

#endif
]]></document_content>
  </document>
  <document index="5">
    <source>analyticeuropeanmargrabeengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticeuropeanmargrabeengine.hpp
    \brief Analytic engine for European Margrabe option
*/

#ifndef quantlib_analytic_european_margrabe_engine_hpp
#define quantlib_analytic_european_margrabe_engine_hpp

#include <ql/experimental/exoticoptions/margrabeoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic engine for European Margrabe option
    /*! This class implements formulae from
        "The Value of an Option to Exchange One Asset for Another",
        W. Margrabe,
        Journal of Finance, 33 (March 1978), 177-186.

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
    */
    class AnalyticEuropeanMargrabeEngine : public MargrabeOption::engine {
      public:
        AnalyticEuropeanMargrabeEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
                                       ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
                                       Real correlation);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2_;
        Real rho_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="6">
    <source>analyticholderextensibleoptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticholderextensibleoptionengine.hpp
    \brief Analytic engine for holder-extensible options
*/

#ifndef quantlib_analytic_holder_extensible_option_engine_hpp
#define quantlib_analytic_holder_extensible_option_engine_hpp

#include <ql/experimental/exoticoptions/holderextensibleoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/pricingengines/blackscholescalculator.hpp>

namespace QuantLib {

    class AnalyticHolderExtensibleOptionEngine
        : public HolderExtensibleOption::engine {
      public:
        explicit AnalyticHolderExtensibleOptionEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Real strike() const;
        Time firstExpiryTime() const;
        Time secondExpiryTime() const;
        Volatility volatility() const;
        Rate riskFreeRate() const;
        Rate dividendYield() const;
        DiscountFactor dividendDiscount(Time t) const;
        DiscountFactor riskFreeDiscount(Time t) const;
        Real I1Call() const;
        Real I2Call() const;
        Real I1Put() const;
        Real I2Put() const;
        BlackScholesCalculator bsCalculator(Real spot, Option::Type optionType) const;
        Real M2(Real a, Real b, Real c, Real d, Real rho) const;
        Real N2(Real a, Real b) const;
        Real y1(Option::Type) const;
        Real y2(Option::Type) const;
        Real z1() const;
        Real z2() const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="7">
    <source>analyticpartialtimebarrieroptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticpartialtimebarrieroptionengine.hpp
    \brief Analytic engine for partial-time barrier options
*/

#ifndef quantlib_analytic_partial_time_barrier_option_engine_hpp
#define quantlib_analytic_partial_time_barrier_option_engine_hpp

#include <ql/experimental/exoticoptions/partialtimebarrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    class AnalyticPartialTimeBarrierOptionEngine
        : public PartialTimeBarrierOption::engine {
      public:
        explicit AnalyticPartialTimeBarrierOptionEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Real underlying() const;
        Real strike() const;
        Time residualTime() const;
        Time coverEventTime() const;
        Volatility volatility(Time t) const;
        Real barrier() const;
        Real rebate() const;
        Real stdDeviation() const;
        Rate riskFreeRate() const;
        DiscountFactor riskFreeDiscount() const;
        Rate dividendYield() const;
        DiscountFactor dividendDiscount() const;
        Real M(Real a,Real b,Real rho) const;
        Real d1()const;
        Real d2()const;
        Real e1() const;
        Real e2() const;
        Real e3() const;
        Real e4() const;
        Real f1() const;
        Real f2() const;
        Real rho() const;
        Rate mu() const;
        Real CoB2(PartialBarrier::Type barrierType) const;
        Real CoB1() const;
        Real CA(Integer n) const;
        Real CIA(Integer n) const;
        Real g1()const;
        Real g2()const;
        Real g3()const;
        Real g4()const;
        Real HS(Real S, Real H, Real power)const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="8">
    <source>analyticpdfhestonengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticpdfhestonengine.hpp
    \brief Analytic engine for arbitrary European payoffs under the Heston model
*/

#ifndef quantlib_analytic_pdf_heston_engine_hpp
#define quantlib_analytic_pdf_heston_engine_hpp

#include <ql/instruments/vanillaoption.hpp>
#include <ql/models/equity/hestonmodel.hpp>
#include <ql/pricingengines/genericmodelengine.hpp>

namespace QuantLib {

    //! Analytic engine for arbitrary European payoffs under the Heston model

    /*! References:

        The formulas are taken from A. Dragulescu, V. Yakovenko, 2002.
        Probability distribution of returns in the Heston model
        with stochastic volatility.
        http://arxiv.org/pdf/cond-mat/0203046.pdf

        \test the correctness of the returned value is tested by
              reproducing digital prices using call spreads and the
              AnalyticHestonEngine.

    */
    class AnalyticPDFHestonEngine
       : public GenericModelEngine<HestonModel,
                                   VanillaOption::arguments,
                                   VanillaOption::results> {
      public:
        explicit AnalyticPDFHestonEngine(ext::shared_ptr<HestonModel> model,
                                         Real gaussLobattoEps = 1e-6,
                                         Size gaussLobattoIntegrationOrder = 10000UL);
        void calculate() const override;


        // probability in x_t = ln(s_t)
        Real Pv(Real x_t, Time t) const;

        // cumulative distribution function Pr(x < X)
        Real cdf(Real X, Time t) const;

      private:
        Real weightedPayoff(Real x_t, Time t) const;

        const Size maxIntegrationIterations_;
        const Real integrationEps_;

        const ext::shared_ptr<HestonModel> model_;
    };
}


#endif
]]></document_content>
  </document>
  <document index="9">
    <source>analyticsimplechooserengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticsimplechooserengine.hpp
    \brief Analytic engine for simple chooser option
*/

#ifndef quantlib_analytic_simple_chooser_engine_hpp
#define quantlib_analytic_simple_chooser_engine_hpp

#include <ql/experimental/exoticoptions/simplechooseroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Pricing engine for European Simple Chooser option
    /*! This class implements a Simple Chooser Option
        option, with European exercise.
    */
    class AnalyticSimpleChooserEngine : public SimpleChooserOption::engine {
      public:
        explicit AnalyticSimpleChooserEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="10">
    <source>analytictwoassetbarrierengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analytictwoassetbarrierengine.hpp
    \brief Analytic engine for barrier option on two assets
*/

#ifndef quantlib_analytic_two_asset_barrier_engine_hpp
#define quantlib_analytic_two_asset_barrier_engine_hpp

#include <ql/experimental/exoticoptions/twoassetbarrieroption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic engine for barrier option on two assets
    /*! The formulas are taken from "Option pricing formulas",
        E.G. Haug, McGraw-Hill,

        \ingroup barrierengines

        \test the correctness of the returned value is tested by
              reproducing results available in literature.
     */
    class AnalyticTwoAssetBarrierEngine
        : public TwoAssetBarrierOption::engine {
      public:
        AnalyticTwoAssetBarrierEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process1,
                                      ext::shared_ptr<GeneralizedBlackScholesProcess> process2,
                                      Handle<Quote> rho);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process1_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> process2_;
        Handle<Quote> rho_;

        // helper methods
        Real underlying1() const;
        Real underlying2() const;

        Real strike() const;
        Time residualTime() const;

        Volatility volatility1() const;
        Volatility volatility2() const;

        Real barrier() const;
        Real rho() const;

        Rate riskFreeRate() const;

        Rate dividendYield1() const;
        Rate dividendYield2() const;

        Rate costOfCarry1() const;
        Rate costOfCarry2() const;

        Real mu(Real b, Real vol) const;

        Real d1() const;
        Real d2() const;
        Real d3() const;
        Real d4() const;

        Real e1() const;
        Real e2() const;
        Real e3() const;
        Real e4() const;

        Real call() const;
        Real put() const;

        Real A(Real eta, Real phi) const;
        Real B(Real eta, Real phi) const;

        Real M(Real m_a, Real m_b,Real rho) const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="11">
    <source>analytictwoassetcorrelationengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analytictwoassetcorrelationengine.hpp
    \brief Analytic engine for two-asset correlation options
*/

#ifndef quantlib_analytic_two_asset_correlation_option_engine_hpp
#define quantlib_analytic_two_asset_correlation_option_engine_hpp

#include <ql/experimental/exoticoptions/twoassetcorrelationoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic two-asset correlation option engine
    class AnalyticTwoAssetCorrelationEngine
        : public TwoAssetCorrelationOption::engine {
      public:
        AnalyticTwoAssetCorrelationEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> p1,
                                          ext::shared_ptr<GeneralizedBlackScholesProcess> p2,
                                          Handle<Quote> correlation);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> p1_;
        ext::shared_ptr<GeneralizedBlackScholesProcess> p2_;
        Handle<Quote> correlation_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="12">
    <source>analyticwriterextensibleoptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file analyticwriterextensibleoptionengine.hpp
    \brief Analytic engine for writer-extensible options
*/

#ifndef quantlib_analytic_writer_extensible_option_engine_hpp
#define quantlib_analytic_writer_extensible_option_engine_hpp

#include <ql/experimental/exoticoptions/writerextensibleoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Analytic engine for writer-extensible options
    class AnalyticWriterExtensibleOptionEngine
        : public WriterExtensibleOption::engine {
      public:
        explicit AnalyticWriterExtensibleOptionEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="13">
    <source>complexchooseroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file complexchooseroption.hpp
    \brief Complex chooser option
*/

#ifndef quantlib_complex_chooser_option_hpp
#define quantlib_complex_chooser_option_hpp

#include <ql/instruments/oneassetoption.hpp>

namespace QuantLib{

    class GeneralizedBlackScholesProcess;

    class ComplexChooserOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        ComplexChooserOption(Date choosingDate,
                             Real strikeCall,
                             Real strikePut,
                             const ext::shared_ptr<Exercise>& exerciseCall,
                             const ext::shared_ptr<Exercise>& exercisePut);
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        Date choosingDate_;
        Real strikeCall_;
        Real strikePut_;
        const ext::shared_ptr<Exercise>& exerciseCall_;
        const ext::shared_ptr<Exercise>& exercisePut_;
    };

    class ComplexChooserOption::arguments : public OneAssetOption::arguments {
      public:
        void validate() const override;
        Date choosingDate;
        Real strikeCall;
        Real strikePut;
        ext::shared_ptr<Exercise> exerciseCall;
        ext::shared_ptr<Exercise> exercisePut;
    };

    class ComplexChooserOption::engine
        : public GenericEngine<ComplexChooserOption::arguments,
                               ComplexChooserOption::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="14">
    <source>compoundoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Dimitri Reiswich

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file compoundoption.hpp
    \brief Compound option on a single asset
*/

#ifndef quantlib_compound_option_hpp
#define quantlib_compound_option_hpp

#include <ql/instruments/oneassetoption.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    //! %Compound option on a single asset.
    /*! \ingroup instruments */
    class CompoundOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        // Mother is the compound Option.
        // Daughter is the option which plays the role of the underlying.
        CompoundOption(const ext::shared_ptr<StrikedTypePayoff>& motherPayoff,
                       const ext::shared_ptr<Exercise>& motherExercise,
                       ext::shared_ptr<StrikedTypePayoff> daughterPayoff,
                       ext::shared_ptr<Exercise> daughterExercise);
        void setupArguments(PricingEngine::arguments*) const override;

      private:
        ext::shared_ptr<StrikedTypePayoff> daughterPayoff_;
        ext::shared_ptr<Exercise> daughterExercise_;
    };

    class CompoundOption::arguments : public OneAssetOption::arguments {
      public:
        ext::shared_ptr<StrikedTypePayoff> daughterPayoff;
        ext::shared_ptr<Exercise> daughterExercise;
        void validate() const override;
    };

    //! %Compound-option %engine base class
    class CompoundOption::engine
        : public GenericEngine<CompoundOption::arguments,
                               CompoundOption::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="15">
    <source>continuousarithmeticasianlevyengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file continuousarithmeticasianlevyengine.hpp
    \brief Levy engine for continuous arithmetic Asian options
*/

#ifndef quantlib_continuous_arithmetic_asian_levy_engine_hpp
#define quantlib_continuous_arithmetic_asian_levy_engine_hpp

#include <ql/instruments/asianoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    class ContinuousArithmeticAsianLevyEngine
        : public ContinuousAveragingAsianOption::engine {
      public:
        ContinuousArithmeticAsianLevyEngine(ext::shared_ptr<GeneralizedBlackScholesProcess> process,
                                            Handle<Quote> currentAverage,
                                            Date startDate);
        void calculate() const override;

      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Handle<Quote> currentAverage_ ;
        Date startDate_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="16">
    <source>continuousarithmeticasianvecerengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Bernd Lewerenz

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file continuousarithmeticasianvecerengine.hpp
    \brief Vecer engine for continuous arithmetic Asian options
*/

#ifndef quantlib_continuous_arithmetic_asian_vecer_engine_hpp
#define quantlib_continuous_arithmetic_asian_vecer_engine_hpp

#include <ql/instruments/asianoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Vecer engine for continuous-avaeraging Asian options
    /*! See <http://www.stat.columbia.edu/~vecer/asian-vecer.pdf> */
    class ContinuousArithmeticAsianVecerEngine
        : public ContinuousAveragingAsianOption::engine {
      public:
        ContinuousArithmeticAsianVecerEngine(
            ext::shared_ptr<GeneralizedBlackScholesProcess> process,
            Handle<Quote> currentAverage,
            Date startDate,
            Size timeSteps = 100,
            Size assetSteps = 100,
            Real z_min = -1.0,
            Real z_max = 1.0);
        void calculate() const override;

      protected:
        // Replication of average by holding this amount in assets
        Real cont_strategy(Time t, Time T1,Time T2,Real v, Real r) const; 
      private:
        ext::shared_ptr<GeneralizedBlackScholesProcess> process_;
        Handle<Quote> currentAverage_ ;
        Date startDate_;
        Real z_min_;
        Real z_max_;
        Size timeSteps_;
        Size assetSteps_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="17">
    <source>everestoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file everestoption.hpp
    \brief Everest option on a number of assets
*/

#ifndef quantlib_everest_option_hpp
#define quantlib_everest_option_hpp

#include <ql/instruments/multiassetoption.hpp>

namespace QuantLib {

    class EverestOption : public MultiAssetOption {
      public:
        class engine;
        class arguments;
        class results;
        EverestOption(Real notional,
                      Rate guarantee,
                      const ext::shared_ptr<Exercise>&);
        Rate yield() const;

        void setupArguments(PricingEngine::arguments*) const override;
        void fetchResults(const PricingEngine::results*) const override;

      private :
        Real notional_;
        Rate guarantee_;
        mutable Rate yield_;
    };

    class EverestOption::arguments : public MultiAssetOption::arguments {
      public:
        arguments();
        void validate() const override;

        Real notional;
        Rate guarantee;
    };

    class EverestOption::results : public MultiAssetOption::results {
      public:
        void reset() override;

        Rate yield;
    };

    class EverestOption::engine
        : public GenericEngine<EverestOption::arguments,
                               EverestOption::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="18">
    <source>himalayaoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file himalayaoption.hpp
    \brief Himalaya option on a number of assets
*/

#ifndef quantlib_himalaya_option_hpp
#define quantlib_himalaya_option_hpp

#include <ql/instruments/multiassetoption.hpp>
#include <ql/time/date.hpp>
#include <vector>

namespace QuantLib {

    //! Himalaya option
    /*! The payoff of a Himalaya option is computed in the following
        way: Given a basket of N assets, and N time periods, at the
        end of each period the option who performed the best is added
        to the average and then discarded from the basket. At the end
        of the N, periods the option pays the max between the strike
        and the average of the best performers.

        \warning This implementation still does not manage seasoned
                 options.
    */
    class HimalayaOption : public MultiAssetOption {
      public:
        class engine;
        class arguments;
        class results;
        HimalayaOption(const std::vector<Date>& fixingDates,
                       Real strike);

        void setupArguments(PricingEngine::arguments*) const override;

      private:
        std::vector<Date> fixingDates_;
    };

    class HimalayaOption::arguments : public MultiAssetOption::arguments {
      public:
        void validate() const override;
        std::vector<Date> fixingDates;
    };

    class HimalayaOption::results : public MultiAssetOption::results {};

    class HimalayaOption::engine
        : public GenericEngine<HimalayaOption::arguments,
                               HimalayaOption::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="19">
    <source>holderextensibleoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file holderextensibleoption.hpp
    \brief Holder-extensible option
*/

#ifndef quantlib_holder_extensible_option_hpp
#define quantlib_holder_extensible_option_hpp

#include <ql/instruments/payoffs.hpp>
#include <ql/instruments/oneassetoption.hpp>

namespace QuantLib {

    class GeneralizedBlackScholesProcess;

    class HolderExtensibleOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        HolderExtensibleOption(
                       Option::Type type,
                       Real premium,
                       Date secondExpiryDate,
                       Real secondStrike,
                       const ext::shared_ptr<StrikedTypePayoff>& payoff,
                       const ext::shared_ptr<Exercise>& exercise);
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        Real premium_;
        Date secondExpiryDate_;
        Real secondStrike_;
    };

    class HolderExtensibleOption::arguments : public OneAssetOption::arguments {
      public:
        Real premium;
        Date secondExpiryDate;
        Real secondStrike;

        void validate() const override;
    };

    class HolderExtensibleOption::engine
        : public GenericEngine<HolderExtensibleOption::arguments,
                               HolderExtensibleOption::results> {};

}


#endif
]]></document_content>
  </document>
  <document index="20">
    <source>kirkspreadoptionengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file kirkspreadoptionengine.hpp
    \brief Kirk approximation for European spread option on futures
*/

#ifndef quantlib_kirk_spread_option_engine_hpp
#define quantlib_kirk_spread_option_engine_hpp

#include <ql/experimental/exoticoptions/spreadoption.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    //! Kirk approximation for European spread option on futures
    class KirkSpreadOptionEngine : public SpreadOption::engine {
      public:
        KirkSpreadOptionEngine(ext::shared_ptr<BlackProcess> process1,
                               ext::shared_ptr<BlackProcess> process2,
                               Handle<Quote> correlation);
        void calculate() const override;

      private:
        ext::shared_ptr<BlackProcess> process1_;
        ext::shared_ptr<BlackProcess> process2_;
        Handle<Quote> rho_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="21">
    <source>margrabeoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file margrabeoption.hpp
    \brief Margrabe option on two assets
*/

#ifndef quantlib_margrabe_option_hpp
#define quantlib_margrabe_option_hpp

#include <ql/instruments/multiassetoption.hpp>

namespace QuantLib {

    //! Margrabe option on two assets
    /*! This option gives the holder the right to exchange Q2 stocks
        of the second asset for Q1 stocks of the first at expiration.

        \ingroup instruments
    */
    class MargrabeOption : public MultiAssetOption {
      public:
        class arguments;
        class results;
        class engine;
        MargrabeOption(Integer Q1,
                       Integer Q2,
                       const ext::shared_ptr<Exercise>&);
        void setupArguments(PricingEngine::arguments*) const override;
        Real delta1() const;
        Real delta2() const;
        Real gamma1() const;
        Real gamma2() const;
        void fetchResults(const PricingEngine::results*) const override;

      protected:
        Integer Q1_;
        Integer Q2_;
        mutable Real delta1_, delta2_, gamma1_, gamma2_;
    };

    //! Extra %arguments for Margrabe option
    class MargrabeOption::arguments
        : public MultiAssetOption::arguments {
      public:
        arguments() : Q1(Null<Integer>()),
                      Q2(Null<Integer>()) {}
        void validate() const override;
        Integer Q1;
        Integer Q2;
    };

    //! Extra %results for Margrabe option
    class MargrabeOption::results
        : public MultiAssetOption::results {
      public:
        results() : delta1(Null<Real>()),
                    delta2(Null<Real>()),
                    gamma1(Null<Real>()),
                    gamma2(Null<Real>()) {}
        Real delta1;
        Real delta2;
        Real gamma1;
        Real gamma2;
        void reset() override {
            MultiAssetOption::results::reset();
            delta1 = Null<Real>();
            delta2 = Null<Real>();
            gamma1 = Null<Real>();
            gamma2 = Null<Real>();
        }
    };

    //! %Margrabe option %engine base class
    class MargrabeOption::engine
        : public GenericEngine<MargrabeOption::arguments,
                               MargrabeOption::results> {};
}


#endif
]]></document_content>
  </document>
  <document index="22">
    <source>mceverestengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mceverestengine.hpp
    \brief Monte Carlo engine for Everest options
*/

#ifndef quantlib_mc_everest_engine_hpp
#define quantlib_mc_everest_engine_hpp

#include <ql/exercise.hpp>
#include <ql/experimental/exoticoptions/everestoption.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/stochasticprocessarray.hpp>
#include <utility>

namespace QuantLib {

    template <class RNG = PseudoRandom, class S = Statistics>
    class MCEverestEngine : public EverestOption::engine,
                            public McSimulation<MultiVariate,RNG,S> {
      public:
        typedef typename McSimulation<MultiVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef typename McSimulation<MultiVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename McSimulation<MultiVariate,RNG,S>::stats_type
            stats_type;
        MCEverestEngine(ext::shared_ptr<StochasticProcessArray>,
                        Size timeSteps,
                        Size timeStepsPerYear,
                        bool brownianBridge,
                        bool antitheticVariate,
                        Size requiredSamples,
                        Real requiredTolerance,
                        Size maxSamples,
                        BigNatural seed);
        void calculate() const override {

            McSimulation<MultiVariate,RNG,S>::calculate(requiredTolerance_,
                                                        requiredSamples_,
                                                        maxSamples_);
            results_.value = this->mcModel_->sampleAccumulator().mean();

            if (RNG::allowsErrorEstimate) {
                results_.errorEstimate =
                    this->mcModel_->sampleAccumulator().errorEstimate();
            }

            Real notional = arguments_.notional;
            DiscountFactor discount = endDiscount();
            results_.yield = results_.value/(notional * discount) - 1.0;
        }

      private:
        DiscountFactor endDiscount() const;
        // McEverest implementation
        TimeGrid timeGrid() const override;
        ext::shared_ptr<path_generator_type> pathGenerator() const override {

            Size numAssets = processes_->size();

            TimeGrid grid = timeGrid();
            typename RNG::rsg_type gen =
                RNG::make_sequence_generator(numAssets*(grid.size()-1),seed_);

            return ext::shared_ptr<path_generator_type>(
                         new path_generator_type(processes_,
                                                 grid, gen, brownianBridge_));
        }
        ext::shared_ptr<path_pricer_type> pathPricer() const override;

        // data members
        ext::shared_ptr<StochasticProcessArray> processes_;
        Size timeSteps_, timeStepsPerYear_;
        Size requiredSamples_;
        Size maxSamples_;
        Real requiredTolerance_;
        bool brownianBridge_;
        BigNatural seed_;
    };


    //! Monte Carlo Everest-option engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCEverestEngine {
      public:
        explicit MakeMCEverestEngine(ext::shared_ptr<StochasticProcessArray>);
        // named parameters
        MakeMCEverestEngine& withSteps(Size steps);
        MakeMCEverestEngine& withStepsPerYear(Size steps);
        MakeMCEverestEngine& withBrownianBridge(bool b = true);
        MakeMCEverestEngine& withAntitheticVariate(bool b = true);
        MakeMCEverestEngine& withSamples(Size samples);
        MakeMCEverestEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCEverestEngine& withMaxSamples(Size samples);
        MakeMCEverestEngine& withSeed(BigNatural seed);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<StochasticProcessArray> process_;
        bool brownianBridge_, antithetic_;
        Size steps_, stepsPerYear_, samples_, maxSamples_;
        Real tolerance_;
        BigNatural seed_;
    };


    class EverestMultiPathPricer : public PathPricer<MultiPath> {
      public:
        explicit EverestMultiPathPricer(Real notional,
                                        Rate guarantee,
                                        DiscountFactor discount);
        Real operator()(const MultiPath& multiPath) const override;

      private:
        Real notional_;
        Rate guarantee_;
        DiscountFactor discount_;
    };


    // template definitions

    template <class RNG, class S>
    inline MCEverestEngine<RNG, S>::MCEverestEngine(
        ext::shared_ptr<StochasticProcessArray> processes,
        Size timeSteps,
        Size timeStepsPerYear,
        bool brownianBridge,
        bool antitheticVariate,
        Size requiredSamples,
        Real requiredTolerance,
        Size maxSamples,
        BigNatural seed)
    : McSimulation<MultiVariate, RNG, S>(antitheticVariate, false),
      processes_(std::move(processes)), timeSteps_(timeSteps), timeStepsPerYear_(timeStepsPerYear),
      requiredSamples_(requiredSamples), maxSamples_(maxSamples),
      requiredTolerance_(requiredTolerance), brownianBridge_(brownianBridge), seed_(seed) {
        QL_REQUIRE(timeSteps != Null<Size>() ||
                   timeStepsPerYear != Null<Size>(),
                   "no time steps provided");
        QL_REQUIRE(timeSteps == Null<Size>() ||
                   timeStepsPerYear == Null<Size>(),
                   "both time steps and time steps per year were provided");
        QL_REQUIRE(timeSteps != 0,
                   "timeSteps must be positive, " << timeSteps <<
                   " not allowed");
        QL_REQUIRE(timeStepsPerYear != 0,
                   "timeStepsPerYear must be positive, " << timeStepsPerYear <<
                   " not allowed");
        registerWith(processes_);
    }

    template <class RNG, class S>
    inline TimeGrid MCEverestEngine<RNG,S>::timeGrid() const {
        Time residualTime = processes_->time(
                                       this->arguments_.exercise->lastDate());
        if (timeSteps_ != Null<Size>()) {
            return TimeGrid(residualTime, timeSteps_);
        } else if (timeStepsPerYear_ != Null<Size>()) {
            Size steps = static_cast<Size>(timeStepsPerYear_*residualTime);
            return TimeGrid(residualTime, std::max<Size>(steps, 1));
        } else {
            QL_FAIL("time steps not specified");
        }
    }

    template <class RNG, class S>
    inline DiscountFactor MCEverestEngine<RNG,S>::endDiscount() const {
        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                                                      processes_->process(0));
        QL_REQUIRE(process, "Black-Scholes process required");

        return process->riskFreeRate()->discount(
                                             arguments_.exercise->lastDate());
    }

    template <class RNG, class S>
    inline ext::shared_ptr<typename MCEverestEngine<RNG,S>::path_pricer_type>
    MCEverestEngine<RNG,S>::pathPricer() const {

        return ext::shared_ptr<
                         typename MCEverestEngine<RNG,S>::path_pricer_type>(
                              new EverestMultiPathPricer(arguments_.notional,
                                                         arguments_.guarantee,
                                                         endDiscount()));
    }


    template <class RNG, class S>
    inline MakeMCEverestEngine<RNG, S>::MakeMCEverestEngine(
        ext::shared_ptr<StochasticProcessArray> process)
    : process_(std::move(process)), brownianBridge_(false), antithetic_(false),
      steps_(Null<Size>()), stepsPerYear_(Null<Size>()), samples_(Null<Size>()),
      maxSamples_(Null<Size>()), tolerance_(Null<Real>()), seed_(0) {}

    template <class RNG, class S>
    inline MakeMCEverestEngine<RNG,S>&
    MakeMCEverestEngine<RNG,S>::withSteps(Size steps) {
        steps_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEverestEngine<RNG,S>&
    MakeMCEverestEngine<RNG,S>::withStepsPerYear(Size steps) {
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEverestEngine<RNG,S>&
    MakeMCEverestEngine<RNG,S>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEverestEngine<RNG,S>&
    MakeMCEverestEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEverestEngine<RNG,S>&
    MakeMCEverestEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEverestEngine<RNG,S>&
    MakeMCEverestEngine<RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEverestEngine<RNG,S>&
    MakeMCEverestEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCEverestEngine<RNG,S>&
    MakeMCEverestEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCEverestEngine<RNG,S>::operator
    ext::shared_ptr<PricingEngine>() const {
        QL_REQUIRE(steps_ != Null<Size>() || stepsPerYear_ != Null<Size>(),
                   "number of steps not given");
        QL_REQUIRE(steps_ == Null<Size>() || stepsPerYear_ == Null<Size>(),
                   "number of steps overspecified");
        return ext::shared_ptr<PricingEngine>(new
            MCEverestEngine<RNG,S>(process_,
                                   steps_,
                                   stepsPerYear_,
                                   brownianBridge_,
                                   antithetic_,
                                   samples_, tolerance_,
                                   maxSamples_,
                                   seed_));
    }

}


#endif
]]></document_content>
  </document>
  <document index="23">
    <source>mchimalayaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mchimalayaengine.hpp
    \brief Monte Carlo engine for Himalaya options
*/

#ifndef quantlib_mc_himalaya_engine_hpp
#define quantlib_mc_himalaya_engine_hpp

#include <ql/exercise.hpp>
#include <ql/experimental/exoticoptions/himalayaoption.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/stochasticprocessarray.hpp>
#include <utility>

namespace QuantLib {

    template <class RNG = PseudoRandom, class S = Statistics>
    class MCHimalayaEngine : public HimalayaOption::engine,
                             public McSimulation<MultiVariate,RNG,S> {
      public:
        typedef typename McSimulation<MultiVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef typename McSimulation<MultiVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename McSimulation<MultiVariate,RNG,S>::stats_type
            stats_type;
        MCHimalayaEngine(ext::shared_ptr<StochasticProcessArray>,
                         bool brownianBridge,
                         bool antitheticVariate,
                         Size requiredSamples,
                         Real requiredTolerance,
                         Size maxSamples,
                         BigNatural seed);

        void calculate() const override {
            McSimulation<MultiVariate,RNG,S>::calculate(requiredTolerance_,
                                                        requiredSamples_,
                                                        maxSamples_);
            results_.value = this->mcModel_->sampleAccumulator().mean();

            if (RNG::allowsErrorEstimate)
            results_.errorEstimate =
                this->mcModel_->sampleAccumulator().errorEstimate();
        }

      private:
        // McSimulation implementation
        TimeGrid timeGrid() const override;
        ext::shared_ptr<path_generator_type> pathGenerator() const override {

            Size numAssets = processes_->size();

            TimeGrid grid = timeGrid();
            typename RNG::rsg_type gen =
                RNG::make_sequence_generator(numAssets*(grid.size()-1),seed_);

            return ext::shared_ptr<path_generator_type>(
                         new path_generator_type(processes_,
                                                 grid, gen, brownianBridge_));
        }
        ext::shared_ptr<path_pricer_type> pathPricer() const override;

        // data members
        ext::shared_ptr<StochasticProcessArray> processes_;
        Size requiredSamples_;
        Size maxSamples_;
        Real requiredTolerance_;
        bool brownianBridge_;
        BigNatural seed_;
    };


    //! Monte Carlo Himalaya-option engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCHimalayaEngine {
      public:
        explicit MakeMCHimalayaEngine(ext::shared_ptr<StochasticProcessArray>);
        // named parameters
        MakeMCHimalayaEngine& withBrownianBridge(bool b = true);
        MakeMCHimalayaEngine& withAntitheticVariate(bool b = true);
        MakeMCHimalayaEngine& withSamples(Size samples);
        MakeMCHimalayaEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCHimalayaEngine& withMaxSamples(Size samples);
        MakeMCHimalayaEngine& withSeed(BigNatural seed);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<StochasticProcessArray> process_;
        bool brownianBridge_, antithetic_;
        Size samples_, maxSamples_;
        Real tolerance_;
        BigNatural seed_;
    };


    class HimalayaMultiPathPricer : public PathPricer<MultiPath> {
      public:
        HimalayaMultiPathPricer(ext::shared_ptr<Payoff> payoff, DiscountFactor discount);
        Real operator()(const MultiPath& multiPath) const override;

      private:
        ext::shared_ptr<Payoff> payoff_;
        DiscountFactor discount_;
    };

    // template definitions

    template <class RNG, class S>
    inline MCHimalayaEngine<RNG, S>::MCHimalayaEngine(
        ext::shared_ptr<StochasticProcessArray> processes,
        bool brownianBridge,
        bool antitheticVariate,
        Size requiredSamples,
        Real requiredTolerance,
        Size maxSamples,
        BigNatural seed)
    : McSimulation<MultiVariate, RNG, S>(antitheticVariate, false),
      processes_(std::move(processes)), requiredSamples_(requiredSamples), maxSamples_(maxSamples),
      requiredTolerance_(requiredTolerance), brownianBridge_(brownianBridge), seed_(seed) {
        registerWith(processes_);
    }

    template <class RNG, class S>
    inline TimeGrid MCHimalayaEngine<RNG,S>::timeGrid() const {

        std::vector<Time> fixingTimes;
        for (Size i=0; i<arguments_.fixingDates.size(); i++) {
            Time t = processes_->time(arguments_.fixingDates[i]);
            QL_REQUIRE(t >= 0.0, "seasoned options are not handled");
            if (i > 0) {
                QL_REQUIRE(t > fixingTimes.back(), "fixing dates not sorted");
            }
            fixingTimes.push_back(t);
        }

        return TimeGrid(fixingTimes.begin(), fixingTimes.end());
    }

    template <class RNG, class S>
    inline
    ext::shared_ptr<typename MCHimalayaEngine<RNG,S>::path_pricer_type>
    MCHimalayaEngine<RNG,S>::pathPricer() const {

        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                                                      processes_->process(0));
        QL_REQUIRE(process, "Black-Scholes process required");

        return ext::shared_ptr<
                         typename MCHimalayaEngine<RNG,S>::path_pricer_type>(
            new HimalayaMultiPathPricer(arguments_.payoff,
                                        process->riskFreeRate()->discount(
                                           arguments_.exercise->lastDate())));
    }


    template <class RNG, class S>
    inline MakeMCHimalayaEngine<RNG, S>::MakeMCHimalayaEngine(
        ext::shared_ptr<StochasticProcessArray> process)
    : process_(std::move(process)), brownianBridge_(false), antithetic_(false),
      samples_(Null<Size>()), maxSamples_(Null<Size>()), tolerance_(Null<Real>()), seed_(0) {}

    template <class RNG, class S>
    inline MakeMCHimalayaEngine<RNG,S>&
    MakeMCHimalayaEngine<RNG,S>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHimalayaEngine<RNG,S>&
    MakeMCHimalayaEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHimalayaEngine<RNG,S>&
    MakeMCHimalayaEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHimalayaEngine<RNG,S>&
    MakeMCHimalayaEngine<RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHimalayaEngine<RNG,S>&
    MakeMCHimalayaEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCHimalayaEngine<RNG,S>&
    MakeMCHimalayaEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCHimalayaEngine<RNG,S>::operator ext::shared_ptr<PricingEngine>()
                                                                      const {
        return ext::shared_ptr<PricingEngine>(new
            MCHimalayaEngine<RNG,S>(process_,
                                    brownianBridge_,
                                    antithetic_,
                                    samples_,
                                    tolerance_,
                                    maxSamples_,
                                    seed_));
    }

}

#endif
]]></document_content>
  </document>
  <document index="24">
    <source>mcpagodaengine.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mcpagodaengine.hpp
    \brief Monte Carlo engine for pagoda options
*/

#ifndef quantlib_mc_pagoda_engine_hpp
#define quantlib_mc_pagoda_engine_hpp

#include <ql/exercise.hpp>
#include <ql/experimental/exoticoptions/pagodaoption.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/stochasticprocessarray.hpp>
#include <utility>

namespace QuantLib {

    //! Pricing engine for pagoda options using Monte Carlo simulation
    template <class RNG = PseudoRandom, class S = Statistics>
    class MCPagodaEngine : public PagodaOption::engine,
                           public McSimulation<MultiVariate,RNG,S> {
      public:
        typedef typename McSimulation<MultiVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef typename McSimulation<MultiVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename McSimulation<MultiVariate,RNG,S>::stats_type
            stats_type;
        // constructor
        MCPagodaEngine(ext::shared_ptr<StochasticProcessArray>,
                       bool brownianBridge,
                       bool antitheticVariate,
                       Size requiredSamples,
                       Real requiredTolerance,
                       Size maxSamples,
                       BigNatural seed);
        void calculate() const override {
            McSimulation<MultiVariate,RNG,S>::calculate(requiredTolerance_,
                                                        requiredSamples_,
                                                        maxSamples_);
            results_.value = this->mcModel_->sampleAccumulator().mean();
            if (RNG::allowsErrorEstimate)
                results_.errorEstimate =
                    this->mcModel_->sampleAccumulator().errorEstimate();
        }

      private:
        // McSimulation implementation
        TimeGrid timeGrid() const override;
        ext::shared_ptr<path_generator_type> pathGenerator() const override {

            Size numAssets = processes_->size();

            TimeGrid grid = timeGrid();
            typename RNG::rsg_type gen =
                RNG::make_sequence_generator(numAssets*(grid.size()-1),seed_);

            return ext::shared_ptr<path_generator_type>(
                         new path_generator_type(processes_,
                                                 grid, gen, brownianBridge_));
        }
        ext::shared_ptr<path_pricer_type> pathPricer() const override;

        // data members
        ext::shared_ptr<StochasticProcessArray> processes_;
        Size requiredSamples_;
        Size maxSamples_;
        Real requiredTolerance_;
        bool brownianBridge_;
        BigNatural seed_;
    };


    //! Monte Carlo pagoda-option engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCPagodaEngine {
      public:
        explicit MakeMCPagodaEngine(ext::shared_ptr<StochasticProcessArray>);
        // named parameters
        MakeMCPagodaEngine& withBrownianBridge(bool b = true);
        MakeMCPagodaEngine& withAntitheticVariate(bool b = true);
        MakeMCPagodaEngine& withSamples(Size samples);
        MakeMCPagodaEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCPagodaEngine& withMaxSamples(Size samples);
        MakeMCPagodaEngine& withSeed(BigNatural seed);
        // conversion to pricing engine
        operator ext::shared_ptr<PricingEngine>() const;
      private:
        ext::shared_ptr<StochasticProcessArray> process_;
        bool brownianBridge_, antithetic_;
        Size samples_, maxSamples_;
        Real tolerance_;
        BigNatural seed_;
    };


    class PagodaMultiPathPricer : public PathPricer<MultiPath> {
      public:
        PagodaMultiPathPricer(Real roof, Real fraction,
                              DiscountFactor discount);
        Real operator()(const MultiPath& multiPath) const override;

      private:
        DiscountFactor discount_;
        Real roof_, fraction_;
    };


    // template definitions

    template <class RNG, class S>
    inline MCPagodaEngine<RNG, S>::MCPagodaEngine(ext::shared_ptr<StochasticProcessArray> processes,
                                                  bool brownianBridge,
                                                  bool antitheticVariate,
                                                  Size requiredSamples,
                                                  Real requiredTolerance,
                                                  Size maxSamples,
                                                  BigNatural seed)
    : McSimulation<MultiVariate, RNG, S>(antitheticVariate, false),
      processes_(std::move(processes)), requiredSamples_(requiredSamples), maxSamples_(maxSamples),
      requiredTolerance_(requiredTolerance), brownianBridge_(brownianBridge), seed_(seed) {
        registerWith(processes_);
    }

    template <class RNG, class S>
    inline TimeGrid MCPagodaEngine<RNG,S>::timeGrid() const {

        std::vector<Time> fixingTimes;
        for (Size i=0; i<arguments_.fixingDates.size(); i++) {
            Time t = processes_->time(arguments_.fixingDates[i]);
            QL_REQUIRE(t >= 0.0, "seasoned options are not handled");
            if (i > 0) {
                QL_REQUIRE(t > fixingTimes.back(), "fixing dates not sorted");
            }
            fixingTimes.push_back(t);
        }

        return TimeGrid(fixingTimes.begin(), fixingTimes.end());
    }


    template <class RNG, class S>
    inline
    ext::shared_ptr<typename MCPagodaEngine<RNG,S>::path_pricer_type>
    MCPagodaEngine<RNG,S>::pathPricer() const {

        ext::shared_ptr<GeneralizedBlackScholesProcess> process =
            ext::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                                                      processes_->process(0));
        QL_REQUIRE(process, "Black-Scholes process required");

        return ext::shared_ptr<
                         typename MCPagodaEngine<RNG,S>::path_pricer_type>(
            new PagodaMultiPathPricer(arguments_.roof, arguments_.fraction,
                                      process->riskFreeRate()->discount(
                                           arguments_.exercise->lastDate())));
    }


    template <class RNG, class S>
    inline MakeMCPagodaEngine<RNG, S>::MakeMCPagodaEngine(
        ext::shared_ptr<StochasticProcessArray> process)
    : process_(std::move(process)), brownianBridge_(false), antithetic_(false),
      samples_(Null<Size>()), maxSamples_(Null<Size>()), tolerance_(Null<Real>()), seed_(0) {}

    template <class RNG, class S>
    inline MakeMCPagodaEngine<RNG,S>&
    MakeMCPagodaEngine<RNG,S>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPagodaEngine<RNG,S>&
    MakeMCPagodaEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPagodaEngine<RNG,S>&
    MakeMCPagodaEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPagodaEngine<RNG,S>&
    MakeMCPagodaEngine<RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPagodaEngine<RNG,S>&
    MakeMCPagodaEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCPagodaEngine<RNG,S>&
    MakeMCPagodaEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCPagodaEngine<RNG,S>::operator
    ext::shared_ptr<PricingEngine>() const {
        return ext::shared_ptr<PricingEngine>(new
            MCPagodaEngine<RNG,S>(process_,
                                  brownianBridge_,
                                  antithetic_,
                                  samples_, tolerance_,
                                  maxSamples_,
                                  seed_));
    }

}



#endif
]]></document_content>
  </document>
  <document index="25">
    <source>pagodaoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file pagodaoption.hpp
    \brief Roofed Asian option on a number of assets
*/

#ifndef quantlib_pagoda_option_hpp
#define quantlib_pagoda_option_hpp

#include <ql/instruments/multiassetoption.hpp>
#include <ql/time/date.hpp>
#include <vector>

namespace QuantLib {

    //! Roofed Asian option on a number of assets
    /*! The payoff is a given fraction multiplied by the minimum
        between a given roof and the positive portfolio performance.
        If the performance of the portfolio is below then the payoff
        is null.

        \warning This implementation still does not manage seasoned
                 options.

        \ingroup instruments
    */
    class PagodaOption : public MultiAssetOption {
      public:
        class engine;
        class arguments;
        PagodaOption(const std::vector<Date>& fixingDates,
                     Real roof,
                     Real fraction);
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        // arguments
        std::vector<Date> fixingDates_;
        Real roof_;
        Real fraction_;
    };


    class PagodaOption::arguments : public MultiAssetOption::arguments {
      public:
        arguments();
        void validate() const override;
        std::vector<Date> fixingDates;
        Real roof; Real fraction;
    };


    //! %Pagoda-option %engine base class
    class PagodaOption::engine
        : public GenericEngine<PagodaOption::arguments,
                               PagodaOption::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="26">
    <source>partialtimebarrieroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file partialtimebarrieroption.hpp
    \brief Partial-time barrier option
*/

#ifndef quantlib_partial_time_barrier_option_hpp
#define quantlib_partial_time_barrier_option_hpp

#include <ql/instruments/oneassetoption.hpp>
#include <ql/instruments/barriertype.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    class GeneralizedBlackScholesProcess;

    struct PartialBarrier : public Barrier {
        enum Range { Start, End, EndB1, EndB2 };
    };

    class PartialTimeBarrierOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        PartialTimeBarrierOption(PartialBarrier::Type barrierType,
            PartialBarrier::Range barrierRange,
            Real barrier,
            Real rebate,
            Date coverEventDate,
            const ext::shared_ptr<StrikedTypePayoff>& payoff,
            const ext::shared_ptr<Exercise>& exercise);
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        PartialBarrier::Type barrierType_;
        PartialBarrier::Range barrierRange_;
        Real barrier_;
        Real rebate_;
        Date coverEventDate_;
    };

    //! %Arguments for barrier option calculation
    class PartialTimeBarrierOption::arguments
        : public OneAssetOption::arguments {
      public:
        arguments();
        PartialBarrier::Type barrierType;
        PartialBarrier::Range barrierRange;
        Real barrier;
        Real rebate;
        Date coverEventDate;
        void validate() const override;
    };

    //! %Partial-Time-Barrier-Option %engine base class
    class PartialTimeBarrierOption::engine
        : public GenericEngine<PartialTimeBarrierOption::arguments,
                               PartialTimeBarrierOption::results> {
    };

}


#endif
]]></document_content>
  </document>
  <document index="27">
    <source>simplechooseroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file simplechooseroption.hpp
    \brief Simple chooser option on a single asset
*/

#ifndef quantlib_simple_chooser_option_hpp
#define quantlib_simple_chooser_option_hpp

#include <ql/instruments/oneassetoption.hpp>

namespace QuantLib {

    //! Simple chooser option
    /*! This option gives the holder the right to choose, at a future
        date prior to exercise, whether the option should be a call or
        a put.  The exercise date and strike are the same for both
        call and put option.
    */
    class SimpleChooserOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        SimpleChooserOption(Date choosingDate,
                            Real strike,
                            const ext::shared_ptr<Exercise>& exercise);
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        Date choosingDate_;
    };

    //! Extra %arguments for single chooser option
    class SimpleChooserOption::arguments
        : public OneAssetOption::arguments {
      public:
        arguments() : choosingDate(Null<Date>()) {}
        void validate() const override;
        Date choosingDate;
    };

    //! Simple chooser option %engine base class
    class SimpleChooserOption::engine
        : public GenericEngine<SimpleChooserOption::arguments,
                               SimpleChooserOption::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="28">
    <source>spreadoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file spreadoption.hpp
    \brief Spread option on two assets
*/

#ifndef quantlib_spread_option_hpp
#define quantlib_spread_option_hpp

#include <ql/instruments/multiassetoption.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    //! Spread option on two assets
    class SpreadOption : public MultiAssetOption {
      public:
        class engine;
        SpreadOption(const ext::shared_ptr<PlainVanillaPayoff>& payoff,
                     const ext::shared_ptr<Exercise>& exercise)
        : MultiAssetOption(payoff, exercise) {}
    };

    //! %Spread option %engine base class
    class SpreadOption::engine
        : public GenericEngine<SpreadOption::arguments,
                               SpreadOption::results> {};

}


#endif
]]></document_content>
  </document>
  <document index="29">
    <source>twoassetbarrieroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2012 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file twoassetbarrieroption.hpp
    \brief Barrier option on two assets
*/

#ifndef quantlib_two_asset_barrier_option_hpp
#define quantlib_two_asset_barrier_option_hpp

#include <ql/instruments/oneassetoption.hpp>
#include <ql/instruments/barriertype.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    class GeneralizedBlackScholesProcess;

    //! %Barrier option on two assets
    /*! \ingroup instruments */
    class TwoAssetBarrierOption : public Option {
      public:
        class arguments;
        class engine;
        TwoAssetBarrierOption(
                      Barrier::Type barrierType,
                      Real barrier,
                      const ext::shared_ptr<StrikedTypePayoff>& payoff,
                      const ext::shared_ptr<Exercise>& exercise);

        bool isExpired() const override;
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        // arguments
        Barrier::Type barrierType_;
        Real barrier_;
    };


    //! %Arguments for two-asset %barrier %option calculation
    class TwoAssetBarrierOption::arguments : public Option::arguments {
      public:
        arguments();
        Barrier::Type barrierType;
        Real barrier;
        void validate() const override;
    };

    //! %Two-asset barrier-option %engine base class
    class TwoAssetBarrierOption::engine
        : public GenericEngine<TwoAssetBarrierOption::arguments,
                               TwoAssetBarrierOption::results> {
      protected:
        bool triggered(Real underlying) const;
    };

}


#endif
]]></document_content>
  </document>
  <document index="30">
    <source>twoassetcorrelationoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file twoassetcorrelationoption.hpp
    \brief Two-asset correlation option
*/

#ifndef quantlib_two_asset_correlation_option_hpp
#define quantlib_two_asset_correlation_option_hpp

#include <ql/instruments/multiassetoption.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    class TwoAssetCorrelationOption : public MultiAssetOption {
      public:
        class arguments;
        class engine;
        TwoAssetCorrelationOption(Option::Type type,
                                  Real strike1,
                                  Real strike2,
                                  const ext::shared_ptr<Exercise>&);
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        Real X2_;
    };

    class TwoAssetCorrelationOption::arguments
        : public MultiAssetOption::arguments {
      public:
        arguments() : X2(Null<Real>()) {}
        void validate() const override {
            MultiAssetOption::arguments::validate();
            QL_REQUIRE(X2 != Null<Real>(), "no X2 given");
        }
        Real X2;
    };

    class TwoAssetCorrelationOption::engine
        : public GenericEngine<TwoAssetCorrelationOption::arguments,
                               TwoAssetCorrelationOption::results> {};

}


#endif
]]></document_content>
  </document>
  <document index="31">
    <source>writerextensibleoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Master IMAFA - Polytech'Nice Sophia - Université de Nice Sophia Antipolis

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file writerextensibleoption.hpp
    \brief Writer-extensible option
*/

#ifndef quantlib_writer_extensible_option_hpp
#define quantlib_writer_extensible_option_hpp

#include <ql/instruments/oneassetoption.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    //! Writer-extensible option
    class WriterExtensibleOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        /*!
          \param payoff1    The first payoff
          \param exercise1  The first exercise date
          \param payoff2    The payoff of the extended option
          \param exercise2  The second exercise date
        */
        WriterExtensibleOption(const ext::shared_ptr<PlainVanillaPayoff>& payoff1,
                               const ext::shared_ptr<Exercise>& exercise1,
                               const ext::shared_ptr<PlainVanillaPayoff>& payoff2,
                               ext::shared_ptr<Exercise> exercise2);
        // inspectors
        ext::shared_ptr<Payoff> payoff2() { return payoff2_; }
        ext::shared_ptr<Exercise> exercise2() { return exercise2_; };
        // Instrument interface
        bool isExpired() const override;
        void setupArguments(PricingEngine::arguments*) const override;

      private:
        ext::shared_ptr<StrikedTypePayoff> payoff2_;
        ext::shared_ptr<Exercise> exercise2_;
    };

    //! Additional arguments for writer-extensible option
    class WriterExtensibleOption::arguments
        : public OneAssetOption::arguments {
      public:
        void validate() const override;
        ext::shared_ptr<Payoff> payoff2;
        ext::shared_ptr<Exercise> exercise2;
    };

    //! Base engine
    class WriterExtensibleOption::engine :
        public GenericEngine<WriterExtensibleOption::arguments,
                             WriterExtensibleOption::results> {};

}

#endif
]]></document_content>
  </document>
</documents>