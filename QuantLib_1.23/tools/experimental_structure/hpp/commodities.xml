<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/experimental/commodities/commodity.hpp>
#include <ql/experimental/commodities/commoditycashflow.hpp>
#include <ql/experimental/commodities/commoditycurve.hpp>
#include <ql/experimental/commodities/commodityindex.hpp>
#include <ql/experimental/commodities/commoditypricinghelpers.hpp>
#include <ql/experimental/commodities/commoditysettings.hpp>
#include <ql/experimental/commodities/commoditytype.hpp>
#include <ql/experimental/commodities/commodityunitcost.hpp>
#include <ql/experimental/commodities/dateinterval.hpp>
#include <ql/experimental/commodities/energybasisswap.hpp>
#include <ql/experimental/commodities/energycommodity.hpp>
#include <ql/experimental/commodities/energyfuture.hpp>
#include <ql/experimental/commodities/energyswap.hpp>
#include <ql/experimental/commodities/energyvanillaswap.hpp>
#include <ql/experimental/commodities/exchangecontract.hpp>
#include <ql/experimental/commodities/paymentterm.hpp>
#include <ql/experimental/commodities/petroleumunitsofmeasure.hpp>
#include <ql/experimental/commodities/pricingperiod.hpp>
#include <ql/experimental/commodities/quantity.hpp>
#include <ql/experimental/commodities/unitofmeasure.hpp>
#include <ql/experimental/commodities/unitofmeasureconversion.hpp>
#include <ql/experimental/commodities/unitofmeasureconversionmanager.hpp>

]]></document_content>
  </document>
  <document index="2">
    <source>commodity.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file commodity.hpp
    \brief Commodity base class
*/

#ifndef quantlib_commodity_hpp
#define quantlib_commodity_hpp

#include <ql/instrument.hpp>
#include <ql/money.hpp>
#include <iosfwd>
#include <utility>
#include <vector>

namespace QuantLib {

    typedef std::map<std::string, boost::any> SecondaryCosts;
    typedef std::map<std::string, Money> SecondaryCostAmounts;

    std::ostream& operator<<(std::ostream& out,
                             const SecondaryCostAmounts& secondaryCostAmounts);


    struct PricingError {
        enum Level { Info, Warning, Error, Fatal };

        Level errorLevel;
        std::string tradeId;
        std::string error;
        std::string detail;

        PricingError(Level errorLevel, std::string error, std::string detail)
        : errorLevel(errorLevel), error(std::move(error)), detail(std::move(detail)) {}
    };

    typedef std::vector<PricingError> PricingErrors;

    std::ostream& operator<<(std::ostream& out, const PricingError& error);
    std::ostream& operator<<(std::ostream& out, const PricingErrors& errors);


    //! Commodity base class
    /*! \ingroup instruments */
    class Commodity : public Instrument {
      public:
        explicit Commodity(ext::shared_ptr<SecondaryCosts> secondaryCosts);
        const ext::shared_ptr<SecondaryCosts>& secondaryCosts() const;
        const SecondaryCostAmounts& secondaryCostAmounts() const;
        const PricingErrors& pricingErrors() const;
        void addPricingError(PricingError::Level errorLevel,
                             const std::string& error,
                             const std::string& detail = "") const;
      protected:
        ext::shared_ptr<SecondaryCosts> secondaryCosts_;
        mutable PricingErrors pricingErrors_;
        mutable SecondaryCostAmounts secondaryCostAmounts_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="3">
    <source>commoditycashflow.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file commoditycashflow.hpp
    \brief Commodity cash flow
*/

#ifndef quantlib_commodity_cash_flow_hpp
#define quantlib_commodity_cash_flow_hpp

#include <ql/cashflow.hpp>
#include <ql/money.hpp>
#include <map>
#include <utility>

namespace QuantLib {

    class CommodityCashFlow : public CashFlow {
      public:
        CommodityCashFlow(const Date& date,
                          Money discountedAmount,
                          Money undiscountedAmount,
                          Money discountedPaymentAmount,
                          Money undiscountedPaymentAmount,
                          Real discountFactor,
                          Real paymentDiscountFactor,
                          bool finalized)
        : date_(date), discountedAmount_(std::move(discountedAmount)),
          undiscountedAmount_(std::move(undiscountedAmount)),
          discountedPaymentAmount_(std::move(discountedPaymentAmount)),
          undiscountedPaymentAmount_(std::move(undiscountedPaymentAmount)),
          discountFactor_(discountFactor), paymentDiscountFactor_(paymentDiscountFactor),
          finalized_(finalized) {}
        //! \name Event interface
        //@{
        Date date() const override { return date_; }
        //@}
        //! \name CashFlow interface
        //@{
        Real amount() const override { return discountedAmount_.value(); }
        //@}
        const Currency& currency() const {
            return discountedAmount_.currency();
        }

        const Money& discountedAmount() const { return discountedAmount_; }
        const Money& undiscountedAmount() const { return undiscountedAmount_; }
        const Money& discountedPaymentAmount() const {
            return discountedPaymentAmount_;
        }
        const Money& undiscountedPaymentAmount() const {
            return undiscountedPaymentAmount_;
        }
        Real discountFactor() const { return discountFactor_; }
        Real paymentDiscountFactor() const { return paymentDiscountFactor_; }
        bool finalized() const { return finalized_; }

        //! \name Visitability
        //@{
        void accept(AcyclicVisitor&) override;
        //@}
      private:
        Date date_;
        Money discountedAmount_, undiscountedAmount_,
              discountedPaymentAmount_, undiscountedPaymentAmount_;
        Real discountFactor_, paymentDiscountFactor_;
        bool finalized_;
    };

    typedef std::map<Date, ext::shared_ptr<CommodityCashFlow> >
                                                           CommodityCashFlows;

    #ifndef __DOXYGEN__
    std::ostream& operator<<(std::ostream& out,
                             const CommodityCashFlows& cashFlows);
    #endif

}

#endif
]]></document_content>
  </document>
  <document index="4">
    <source>commoditycurve.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file commoditycurve.hpp
    \brief Commodity curve
*/

#ifndef quantlib_commodity_curve_hpp
#define quantlib_commodity_curve_hpp

#include <ql/termstructure.hpp>
#include <ql/experimental/commodities/commoditytype.hpp>
#include <ql/experimental/commodities/unitofmeasure.hpp>
#include <ql/experimental/commodities/exchangecontract.hpp>
#include <ql/currency.hpp>
#include <ql/math/interpolations/forwardflatinterpolation.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>

namespace QuantLib {

    //! Commodity term structure
    class CommodityCurve : public TermStructure {
        friend class CommodityIndex;
      public:
        // constructor
        CommodityCurve(std::string name,
                       CommodityType commodityType,
                       Currency currency,
                       UnitOfMeasure unitOfMeasure,
                       const Calendar& calendar,
                       const std::vector<Date>& dates,
                       std::vector<Real> prices,
                       const DayCounter& dayCounter = Actual365Fixed());

        CommodityCurve(std::string name,
                       CommodityType commodityType,
                       Currency currency,
                       UnitOfMeasure unitOfMeasure,
                       const Calendar& calendar,
                       const DayCounter& dayCounter = Actual365Fixed());

        //! \name Inspectors
        //@{
        const std::string& name() const;
        const CommodityType& commodityType() const;
        const UnitOfMeasure& unitOfMeasure() const;
        const Currency& currency() const;
        Date maxDate() const override;
        const std::vector<Time>& times() const;
        const std::vector<Date>& dates() const;
        const std::vector<Real>& prices() const;
        std::vector<std::pair<Date,Real> > nodes() const;
        bool empty() const;

        void setPrices(std::map<Date, Real>& prices);
        void setBasisOfCurve(
                       const ext::shared_ptr<CommodityCurve>& basisOfCurve);

        Real price(
               const Date& d,
               const ext::shared_ptr<ExchangeContracts>& exchangeContracts,
               Integer nearbyOffset) const;
        Real basisOfPrice(const Date& d) const;
        Date underlyingPriceDate(
                const Date& date,
                const ext::shared_ptr<ExchangeContracts>& exchangeContracts,
                Integer nearbyOffset) const;

        const ext::shared_ptr<CommodityCurve>& basisOfCurve() const;

        friend std::ostream& operator<<(std::ostream& out,
                                        const CommodityCurve& curve);
      protected:
        Real basisOfPriceImpl(Time t) const;

        std::string name_;
        CommodityType commodityType_;
        UnitOfMeasure unitOfMeasure_;
        Currency currency_;
        mutable std::vector<Date> dates_;
        mutable std::vector<Time> times_;
        mutable std::vector<Real> data_;
        mutable Interpolation interpolation_;
        ForwardFlat interpolator_;
        ext::shared_ptr<CommodityCurve> basisOfCurve_;
        Real basisOfCurveUomConversionFactor_;

        Real priceImpl(Time t) const;
    };


    // inline definitions

    inline bool operator==(const CommodityCurve& c1, const CommodityCurve& c2) {
        return c1.name() == c2.name();
    }

    inline const std::string& CommodityCurve::name() const {
        return name_;
    }

    inline Date CommodityCurve::maxDate() const {
        return dates_.back();
    }

    inline const std::vector<Time>& CommodityCurve::times() const {
        return times_;
    }

    inline const std::vector<Date>& CommodityCurve::dates() const {
        return dates_;
    }

    inline const std::vector<Real>& CommodityCurve::prices() const {
        return data_;
    }

    inline bool CommodityCurve::empty() const {
        return dates_.empty();
    }

    inline const ext::shared_ptr<CommodityCurve>&
    CommodityCurve::basisOfCurve() const {
        return basisOfCurve_;
    }

    inline std::vector<std::pair<Date,Real> > CommodityCurve::nodes() const {
        std::vector<std::pair<Date,Real> > results(dates_.size());
        for (Size i = 0; i < dates_.size(); ++i)
            results[i] = std::make_pair(dates_[i], data_[i]);
        return results;
    }

    inline Real CommodityCurve::basisOfPrice(const Date& d) const {
        Time t = timeFromReference(d);
        return basisOfPriceImpl(t);
    }

    // gets a price that can include an arbitrary number of basis curves
    inline Real CommodityCurve::price(
                const Date& d,
                const ext::shared_ptr<ExchangeContracts>& exchangeContracts,
                Integer nearbyOffset) const {
        Date date = nearbyOffset > 0 ?
            underlyingPriceDate(d, exchangeContracts, nearbyOffset) : d;
        Time t = timeFromReference(date);
        Real priceValue = 0;
        try {
            priceValue = priceImpl(t);
        } catch (const std::exception& e) {
            QL_FAIL("error retrieving price for curve [" << name() << "]: "
                    << e.what());
        }
        return priceValue + basisOfPriceImpl(t);
    }

    // get the date for the underlying price, in the case of nearby
    // curves, rolls on the underlying contract expiry
    inline Date CommodityCurve::underlyingPriceDate(
                const Date& date,
                const ext::shared_ptr<ExchangeContracts>& exchangeContracts,
                Integer nearbyOffset) const {
        QL_REQUIRE(nearbyOffset > 0, "nearby offset must be > 0");
        ExchangeContracts::const_iterator ic =
            exchangeContracts->lower_bound(date);
        if (ic != exchangeContracts->end()) {
            for (int i = 0; i < nearbyOffset-1 && ic!=exchangeContracts->end(); ++i)
                ++ic;
            QL_REQUIRE(ic != exchangeContracts->end(),
                       "not enough nearby contracts available for curve ["
                       << name() << "] for date [" << date << "].");
            return ic->second.underlyingStartDate();
        }
        return date;
    }

    inline Real CommodityCurve::basisOfPriceImpl(Time t) const {
        if (basisOfCurve_ != nullptr) {
            Real basisCurvePriceValue = 0;
            try {
                basisCurvePriceValue =
                    basisOfCurve_->priceImpl(t)
                    * basisOfCurveUomConversionFactor_;
            } catch (const std::exception& e) {
                QL_FAIL("error retrieving price for curve [" << name() <<
                        "]: " << e.what());
            }
            return basisCurvePriceValue + basisOfCurve_->basisOfPriceImpl(t);
        }
        return 0;
    }

    inline Real CommodityCurve::priceImpl(Time t) const {
        return interpolation_(t, true);
    }

}


#endif
]]></document_content>
  </document>
  <document index="5">
    <source>commodityindex.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file commodityindex.hpp
    \brief Commodity index
*/

#ifndef quantlib_commodity_index_hpp
#define quantlib_commodity_index_hpp

#include <ql/experimental/commodities/commoditycurve.hpp>
#include <ql/indexes/indexmanager.hpp>

namespace QuantLib {

    class TermStructure;

    //! base class for commodity indexes
    class CommodityIndex : public Observable,
                           public Observer {
      public:
        CommodityIndex(const std::string& name,
                       CommodityType commodityType,
                       Currency currency,
                       UnitOfMeasure unitOfMeasure,
                       Calendar calendar,
                       Real lotQuantity,
                       ext::shared_ptr<CommodityCurve> forwardCurve,
                       ext::shared_ptr<ExchangeContracts> exchangeContracts,
                       int nearbyOffset);
        //! \name Index interface
        //@{
        std::string name() const;
        //@}
        //! \name Observer interface
        //@{
        void update() override;
        //@}
        //! \name Inspectors
        //@{
        const CommodityType& commodityType() const;
        const Currency& currency() const;
        const UnitOfMeasure& unitOfMeasure() const;
        const Calendar& calendar() const;
        const ext::shared_ptr<CommodityCurve>& forwardCurve() const;
        Real lotQuantity() const;

        Real price(const Date& date);
        Real forwardPrice(const Date& date) const;
        Date lastQuoteDate() const;
        //@}
        void addQuote(const Date& quoteDate, Real quote);

        void addQuotes(const std::map<Date, Real>& quotes) {
            std::string tag = name();
            quotes_ = IndexManager::instance().getHistory(tag);
            for (auto quote : quotes) {
                quotes_[quote.first] = quote.second;
            }
            IndexManager::instance().setHistory(tag, quotes_);
        }

        void clearQuotes() const;
        //! returns TRUE if the quote date is valid
        bool isValidQuoteDate(const Date& quoteDate) const;
        bool empty() const;
        bool forwardCurveEmpty() const;
        const TimeSeries<Real>& quotes() const;

        friend std::ostream& operator<<(std::ostream&, const CommodityIndex&);
      protected:
        std::string name_;
        CommodityType commodityType_;
        UnitOfMeasure unitOfMeasure_;
        Currency currency_;
        Calendar calendar_;
        Real lotQuantity_;
        TimeSeries<Real> quotes_;
        ext::shared_ptr<CommodityCurve> forwardCurve_;
        Real forwardCurveUomConversionFactor_;
        ext::shared_ptr<ExchangeContracts> exchangeContracts_;
        Integer nearbyOffset_;
    };


    // inline definitions

    inline bool operator==(const CommodityIndex& i1, const CommodityIndex& i2) {
        return i1.name() == i2.name();
    }

    inline void CommodityIndex::update() {
        notifyObservers();
    }

    inline std::string CommodityIndex::name() const {
        return name_;
    }

    inline const CommodityType& CommodityIndex::commodityType() const {
        return commodityType_;
    }

    inline const UnitOfMeasure& CommodityIndex::unitOfMeasure() const {
        return unitOfMeasure_;
    }

    inline const Currency& CommodityIndex::currency() const {
        return currency_;
    }

    inline const Calendar& CommodityIndex::calendar() const {
        return calendar_;
    }

    inline Real CommodityIndex::lotQuantity() const {
        return lotQuantity_;
    }

    inline const ext::shared_ptr<CommodityCurve>&
    CommodityIndex::forwardCurve() const {
        return forwardCurve_;
    }

    inline const TimeSeries<Real>& CommodityIndex::quotes() const {
        return quotes_;
    }

    inline Real CommodityIndex::price(const Date& date) {
        auto hq = quotes_.find(date);
        if (hq->second == Null<Real>()) {
            ++hq;
            if (hq == quotes_.end())
                //if (hq->second == Null<Real>())
                return Null<Real>();
        }
        return hq->second;
    }

    inline Real CommodityIndex::forwardPrice(const Date& date) const {
        try {
            Real forwardPrice =
                forwardCurve_->price(date, exchangeContracts_, nearbyOffset_);
            return forwardPrice * forwardCurveUomConversionFactor_;
        } catch (const std::exception& e) {
            QL_FAIL("error fetching forward price for index " << name_
                    << ": " << e.what());
        }
    }

    inline Date CommodityIndex::lastQuoteDate() const {
        if (quotes_.empty())
            return Date::minDate();
        return quotes_.lastDate();
    }

    inline bool CommodityIndex::empty() const {
        return quotes_.empty();
    }

    inline bool CommodityIndex::forwardCurveEmpty() const {
        if (forwardCurve_ != nullptr)
            return forwardCurve_->empty();
        return false;
    }

    inline void CommodityIndex::addQuote(const Date& quoteDate, Real quote) {
        //QL_REQUIRE(isValidQuoteDate(quoteDate),
        //           "Quote date " << quoteDate.weekday() << ", " <<
        //           quoteDate << " is not valid");
        std::string tag = name();
        quotes_ = IndexManager::instance().getHistory(tag);
        quotes_[quoteDate] = quote;
        IndexManager::instance().setHistory(tag, quotes_);
    }

    inline void CommodityIndex::clearQuotes() const {
        IndexManager::instance().clearHistory(name());
    }

    inline bool CommodityIndex::isValidQuoteDate(const Date& quoteDate) const {
        return calendar().isBusinessDay(quoteDate);
    }

}

#endif
]]></document_content>
  </document>
  <document index="6">
    <source>commoditypricinghelpers.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file commoditypricinghelpers.hpp
    \brief Commodity pricing helpers
*/

#ifndef quantlib_commodity_pricing_helpers_hpp
#define quantlib_commodity_pricing_helpers_hpp

#include <ql/experimental/commodities/energycommodity.hpp>
#include <ql/experimental/commodities/paymentterm.hpp>
#include <ql/experimental/commodities/pricingperiod.hpp>
#include <ql/experimental/commodities/unitofmeasureconversionmanager.hpp>
#include <ql/currencies/exchangeratemanager.hpp>

namespace QuantLib {

    //! commodity index helper
    class CommodityPricingHelper {
      public:
        CommodityPricingHelper();

        static Real calculateFxConversionFactor(const Currency& fromCurrency,
                                                const Currency& toCurrency,
                                                const Date& evaluationDate);

        static Real calculateUomConversionFactor(
                                       const CommodityType& commodityType,
                                       const UnitOfMeasure& fromUnitOfMeasure,
                                       const UnitOfMeasure& toUnitOfMeasure);

        static Real calculateUnitCost(const CommodityType& commodityType,
                                      const CommodityUnitCost& unitCost,
                                      const Currency& baseCurrency,
                                      const UnitOfMeasure& baseUnitOfMeasure,
                                      const Date& evaluationDate);

        static void createPricingPeriods(
                          Date startDate, Date endDate,
                          const Quantity& quantity,
                          EnergyCommodity::DeliverySchedule deliverySchedule,
                          EnergyCommodity::QuantityPeriodicity qtyPeriodicity,
                          const PaymentTerm& paymentTerm,
                          PricingPeriods& pricingPeriods);
    };


    inline Real CommodityPricingHelper::calculateUomConversionFactor(
                                       const CommodityType& commodityType,
                                       const UnitOfMeasure& fromUnitOfMeasure,
                                       const UnitOfMeasure& toUnitOfMeasure) {
        if (toUnitOfMeasure != fromUnitOfMeasure) {
            UnitOfMeasureConversion uomConv =
                UnitOfMeasureConversionManager::instance().lookup(
                           commodityType, fromUnitOfMeasure, toUnitOfMeasure);
            return uomConv.conversionFactor();
        }

        return 1;
    }

    inline Real CommodityPricingHelper::calculateFxConversionFactor(
                                                 const Currency& fromCurrency,
                                                 const Currency& toCurrency,
                                                 const Date& evaluationDate) {
        if (fromCurrency != toCurrency) {
            ExchangeRate exchRate =
                ExchangeRateManager::instance().lookup(fromCurrency,
                                                       toCurrency,
                                                       evaluationDate,
                                                       ExchangeRate::Direct);
            if (fromCurrency != exchRate.source())
                return (Real)1 / exchRate.rate();
            return exchRate.rate();
        }
        return 1;
    }

    inline Real CommodityPricingHelper::calculateUnitCost(
                                       const CommodityType& commodityType,
                                       const CommodityUnitCost& unitCost,
                                       const Currency& baseCurrency,
                                       const UnitOfMeasure& baseUnitOfMeasure,
                                       const Date& evaluationDate) {
        if (unitCost.amount().value() != 0) {
            Real unitCostUomConversionFactor =
                calculateUomConversionFactor(commodityType,
                                             unitCost.unitOfMeasure(),
                                             baseUnitOfMeasure);
            Real unitCostFxConversionFactor =
                calculateFxConversionFactor(unitCost.amount().currency(),
                                            baseCurrency, evaluationDate);
            return unitCost.amount().value() * unitCostUomConversionFactor
                 * unitCostFxConversionFactor;
        }
        return 0;
    }

}

#endif
]]></document_content>
  </document>
  <document index="7">
    <source>commoditysettings.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file commoditysettings.hpp
    \brief commodity settings
*/

#ifndef quantlib_commodity_settings_hpp
#define quantlib_commodity_settings_hpp

#include <ql/patterns/singleton.hpp>
#include <ql/experimental/commodities/unitofmeasure.hpp>
#include <ql/currency.hpp>

namespace QuantLib {

    //! global repository for run-time library settings
    class CommoditySettings : public Singleton<CommoditySettings> {
        friend class Singleton<CommoditySettings>;
      private:
        CommoditySettings();

      public:
        Currency& currency();
        UnitOfMeasure& unitOfMeasure();
      private:
        Currency currency_;
        UnitOfMeasure unitOfMeasure_;
    };

}


#endif

]]></document_content>
  </document>
  <document index="8">
    <source>commoditytype.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file commodity.hpp
    \brief commodity type
*/

#ifndef quantlib_commodity_type_hpp
#define quantlib_commodity_type_hpp

#include <ql/qldefines.hpp>
#include <ql/shared_ptr.hpp>
#include <iosfwd>
#include <map>
#include <string>
#include <utility>

namespace QuantLib {

    //! commodity type
    class CommodityType {
      public:
        //! default constructor
        /*! Instances built via this constructor have undefined
          behavior. Such instances can only act as placeholders
          and must be reassigned to a valid currency before being
          used.
        */
        CommodityType() = default;
        CommodityType(const std::string& code, const std::string& name);
        //! \name Inspectors
        //@{
        //! commodity code, e.g, "HO"
        const std::string& code() const;
        //! name, e.g, "Heating Oil"
        const std::string& name() const;
        // commodity code
        //@}
        //! \name Other information
        //@{
        //! is this a usable instance?
        bool empty() const;
        //@}

      protected:
        struct Data;
        ext::shared_ptr<Data> data_;

        struct Data {
            std::string name, code;

            Data(std::string name, std::string code)
            : name(std::move(name)), code(std::move(code)) {}
        };

        static std::map<std::string, ext::shared_ptr<Data> > commodityTypes_;
    };

    /*! \relates CommodityType */
    bool operator==(const CommodityType&,
                    const CommodityType&);

    /*! \relates CommodityType */
    bool operator!=(const CommodityType&,
                    const CommodityType&);

    /*! \relates CommodityType */
    std::ostream& operator<<(std::ostream&,
                             const CommodityType&);


    class NullCommodityType : public CommodityType {
      public:
        NullCommodityType() :
        CommodityType("<NULL>", "<NULL>") {}
    };


    inline const std::string& CommodityType::code() const {
        return data_->code;
    }

    inline const std::string& CommodityType::name() const {
        return data_->name;
    }

    inline bool CommodityType::empty() const {
        return !data_;
    }

    inline bool operator==(const CommodityType& c1, const CommodityType& c2) {
        return c1.code() == c2.code();
    }

    inline bool operator!=(const CommodityType& c1, const CommodityType& c2) {
        return !(c1 == c2);
    }

}


#endif
]]></document_content>
  </document>
  <document index="9">
    <source>commodityunitcost.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file commodityunitcost.hpp
    \brief Commodity unit cost
*/

#ifndef quantlib_commodity_unit_cost_hpp
#define quantlib_commodity_unit_cost_hpp

#include <ql/experimental/commodities/unitofmeasure.hpp>
#include <ql/money.hpp>
#include <utility>

namespace QuantLib {

    class CommodityUnitCost {
      public:
        CommodityUnitCost() = default;
        CommodityUnitCost(Money amount, UnitOfMeasure unitOfMeasure)
        : amount_(std::move(amount)), unitOfMeasure_(std::move(unitOfMeasure)) {}

        const Money& amount() const { return amount_; }
        const UnitOfMeasure& unitOfMeasure() const { return unitOfMeasure_; }

      private:
        Money amount_;
        UnitOfMeasure unitOfMeasure_;
    };

    std::ostream& operator<<(std::ostream& out,
                             const CommodityUnitCost& unitCost);

}

#endif
]]></document_content>
  </document>
  <document index="10">
    <source>dateinterval.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file dateinterval.hpp
    \brief Date interval
*/

#ifndef quantlib_date_interval_hpp
#define quantlib_date_interval_hpp

#include <ql/time/date.hpp>
#include <ql/errors.hpp>
#include <algorithm>

namespace QuantLib {

    //! Date interval described by a number of a given time unit
    /*! \ingroup datetime */
    class DateInterval {
        friend std::ostream& operator<<(std::ostream&, const DateInterval&);

      private:
        Date startDate_;
        Date endDate_;
      public:
        DateInterval() = default;
        DateInterval(const Date& startDate, const Date& endDate)
        : startDate_(startDate), endDate_(endDate) {
            QL_REQUIRE(endDate_ >= startDate_,
                       "end date must be >= start date");
        }
        const Date& startDate() const { return startDate_; }
        const Date& endDate() const { return endDate_; }

        bool isDateBetween(Date date,
                           bool includeFirst = true,
                           bool includeLast = true) const {
            if (includeFirst && !(date >= startDate_))
                return false;
            else if (!(date > startDate_))
                return false;
            if (includeLast && !(date <= endDate_))
                return false;
            else if (!(date < endDate_))
                return false;
            return true;
        }

        DateInterval intersection(const DateInterval& di) const {
            if ((startDate_ < di.startDate_ && endDate_ < di.startDate_) ||
                (startDate_ > di.endDate_ && endDate_ > di.endDate_))
                return {};
            return {std::max(startDate_, di.startDate_), std::min(endDate_, di.endDate_)};
        }

        bool operator==(const DateInterval& rhs) const {
            return startDate_ == rhs.startDate_ && endDate_ == rhs.endDate_;
        }

        bool operator!=(const DateInterval& rhs) const {
            return !(*this == rhs);
        }
    };

}

#endif
]]></document_content>
  </document>
  <document index="11">
    <source>energybasisswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file energybasisswap.hpp
    \brief Energy basis swap
*/

#ifndef quantlib_energy_basis_swap_hpp
#define quantlib_energy_basis_swap_hpp

#include <ql/experimental/commodities/energyswap.hpp>
#include <ql/experimental/commodities/commodityindex.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>

namespace QuantLib {

    //! Energy basis swap
    class EnergyBasisSwap : public EnergySwap {
      public:
        EnergyBasisSwap(const Calendar& calendar,
                        ext::shared_ptr<CommodityIndex> spreadIndex,
                        ext::shared_ptr<CommodityIndex> payIndex,
                        ext::shared_ptr<CommodityIndex> receiveIndex,
                        bool spreadToPayLeg,
                        const Currency& payCurrency,
                        const Currency& receiveCurrency,
                        const PricingPeriods& pricingPeriods,
                        CommodityUnitCost basis,
                        const CommodityType& commodityType,
                        const ext::shared_ptr<SecondaryCosts>& secondaryCosts,
                        Handle<YieldTermStructure> payLegTermStructure,
                        Handle<YieldTermStructure> receiveLegTermStructure,
                        Handle<YieldTermStructure> discountTermStructure);

        const ext::shared_ptr<CommodityIndex>& payIndex() const {
            return payIndex_;
        }
        const ext::shared_ptr<CommodityIndex>& receiveIndex() const {
            return receiveIndex_;
        }
        const CommodityUnitCost& basis() const { return basis_; }

      protected:
        void performCalculations() const override;

        ext::shared_ptr<CommodityIndex> spreadIndex_;
        ext::shared_ptr<CommodityIndex> payIndex_;
        ext::shared_ptr<CommodityIndex> receiveIndex_;
        bool spreadToPayLeg_;
        CommodityUnitCost basis_;
        Handle<YieldTermStructure> payLegTermStructure_;
        Handle<YieldTermStructure> receiveLegTermStructure_;
        Handle<YieldTermStructure> discountTermStructure_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="12">
    <source>energycommodity.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file energycommodity.hpp
    \brief Energy commodity
*/

#ifndef quantlib_energy_commodity_hpp
#define quantlib_energy_commodity_hpp

#include <ql/experimental/commodities/commodity.hpp>
#include <ql/experimental/commodities/commoditytype.hpp>
#include <ql/experimental/commodities/commodityunitcost.hpp>
#include <ql/experimental/commodities/unitofmeasure.hpp>
#include <ql/experimental/commodities/quantity.hpp>
#include <ql/time/date.hpp>
#include <ql/money.hpp>

namespace QuantLib {

    struct EnergyDailyPosition {
        Date date;
        Real quantityAmount;
        Real payLegPrice = 0;
        Real receiveLegPrice = 0;
        Real riskDelta;
        bool unrealized = false;

        EnergyDailyPosition() = default;
        EnergyDailyPosition(const Date& date,
                            Real payLegPrice,
                            Real receiveLegPrice,
                            bool unrealized);
    };

    typedef std::map<Date, EnergyDailyPosition> EnergyDailyPositions;

    #ifndef __DOXYGEN__
    std::ostream& operator<<(std::ostream& out,
                             const EnergyDailyPositions& dailyPositions);
    #endif



    //! Energy commodity class
    /*! \ingroup instruments */
    class EnergyCommodity : public Commodity {
      public:
        class arguments;
        class results;
        class engine;

        enum DeliverySchedule { Constant,
                                Window,
                                Hourly,
                                Daily,
                                Weekly,
                                Monthly,
                                Quarterly,
                                Yearly };
        enum QuantityPeriodicity { Absolute,
                                   PerHour,
                                   PerDay,
                                   PerWeek,
                                   PerMonth,
                                   PerQuarter,
                                   PerYear };
        enum PaymentSchedule { WindowSettlement,
                               MonthlySettlement,
                               QuarterlySettlement,
                               YearlySettlement };

        EnergyCommodity(CommodityType commodityType,
                        const ext::shared_ptr<SecondaryCosts>& secondaryCosts);

        virtual Quantity quantity() const = 0;
        const CommodityType& commodityType() const;

        void setupArguments(PricingEngine::arguments*) const override;
        void fetchResults(const PricingEngine::results*) const override;

      protected:
        static Real calculateFxConversionFactor(const Currency& fromCurrency,
                                                const Currency& toCurrency,
                                                const Date& evaluationDate);
        static Real calculateUomConversionFactor(
                                       const CommodityType& commodityType,
                                       const UnitOfMeasure& fromUnitOfMeasure,
                                       const UnitOfMeasure& toUnitOfMeasure);
        Real calculateUnitCost(const CommodityType& commodityType,
                               const CommodityUnitCost& unitCost,
                               const Date& evaluationDate) const;
        void calculateSecondaryCostAmounts(const CommodityType& commodityType,
                                           Real totalQuantityValue,
                                           const Date& evaluationDate) const;

        CommodityType commodityType_;
    };


    class EnergyCommodity::arguments : public virtual PricingEngine::arguments {
      public:
        Currency currency;
        UnitOfMeasure unitOfMeasure;
        void validate() const override {}
    };

    class EnergyCommodity::results : public Instrument::results {
      public:
        Real NPV;
        Currency currency;
        UnitOfMeasure unitOfMeasure;
        void reset() override { Instrument::results::reset(); }
    };

    class EnergyCommodity::engine
        : public GenericEngine<EnergyCommodity::arguments,
                               EnergyCommodity::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="13">
    <source>energyfuture.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file energyfuture.hpp
    \brief Energy future
*/

#ifndef quantlib_energy_future_hpp
#define quantlib_energy_future_hpp

#include <ql/experimental/commodities/energycommodity.hpp>
#include <ql/experimental/commodities/commodityindex.hpp>

namespace QuantLib {

    //! Energy future
    /*! \ingroup instruments */
    class EnergyFuture : public EnergyCommodity {
      public:
        EnergyFuture(Integer buySell,
                     Quantity quantity,
                     CommodityUnitCost tradePrice,
                     ext::shared_ptr<CommodityIndex> index,
                     const CommodityType& commodityType,
                     const ext::shared_ptr<SecondaryCosts>& secondaryCosts);
        bool isExpired() const override;
        //Integer buySell{} const { return buySell_; }
        Quantity quantity() const override { return quantity_; }
        const CommodityUnitCost& tradePrice() const { return tradePrice_; }
        ext::shared_ptr<CommodityIndex> index() const { return index_; }

      protected:
        void performCalculations() const override;
        Integer buySell_;
        Quantity quantity_;
        CommodityUnitCost tradePrice_;
        ext::shared_ptr<CommodityIndex> index_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="14">
    <source>energyswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file energyswap.hpp
    \brief Energy swap
*/

#ifndef quantlib_energy_swap_hpp
#define quantlib_energy_swap_hpp

#include <ql/experimental/commodities/energycommodity.hpp>
#include <ql/experimental/commodities/pricingperiod.hpp>
#include <ql/experimental/commodities/commoditycashflow.hpp>
#include <ql/time/calendar.hpp>

namespace QuantLib {

    class EnergySwap : public EnergyCommodity {
      public:
        EnergySwap(Calendar calendar,
                   Currency payCurrency,
                   Currency receiveCurrency,
                   PricingPeriods pricingPeriods,
                   const CommodityType& commodityType,
                   const ext::shared_ptr<SecondaryCosts>& secondaryCosts);

        bool isExpired() const override;
        const Calendar& calendar() const { return calendar_; }
        const Currency& payCurrency() const { return payCurrency_; }
        const Currency& receiveCurrency() const { return receiveCurrency_; }
        const PricingPeriods& pricingPeriods() const { return pricingPeriods_; }
        const EnergyDailyPositions& dailyPositions() const {
            return dailyPositions_;
        }
        const CommodityCashFlows& paymentCashFlows() const {
            return paymentCashFlows_;
        }

        const CommodityType& commodityType() const;
        Quantity quantity() const override;

      protected:
        Calendar calendar_;
        Currency payCurrency_;
        Currency receiveCurrency_;
        PricingPeriods pricingPeriods_;
        mutable EnergyDailyPositions dailyPositions_;
        mutable CommodityCashFlows paymentCashFlows_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="15">
    <source>energyvanillaswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file energyvanillaswap.hpp
    \brief Vanilla energy swap
*/

#ifndef quantlib_energy_vanilla_swap_hpp
#define quantlib_energy_vanilla_swap_hpp

#include <ql/experimental/commodities/energyswap.hpp>
#include <ql/experimental/commodities/commodityindex.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>

namespace QuantLib {

    //! Vanilla energy swap
    class EnergyVanillaSwap : public EnergySwap {
      public:
        EnergyVanillaSwap(bool payer,
                          const Calendar& calendar,
                          Money fixedPrice,
                          UnitOfMeasure fixedPriceUnitOfMeasure,
                          ext::shared_ptr<CommodityIndex> index,
                          const Currency& payCurrency,
                          const Currency& receiveCurrency,
                          const PricingPeriods& pricingPeriods,
                          const CommodityType& commodityType,
                          const ext::shared_ptr<SecondaryCosts>& secondaryCosts,
                          Handle<YieldTermStructure> payLegTermStructure,
                          Handle<YieldTermStructure> receiveLegTermStructure,
                          Handle<YieldTermStructure> discountTermStructure);

        bool isExpired() const override;
        Integer payReceive() const { return payReceive_; }
        const Money& fixedPrice() const { return fixedPrice_; }
        const UnitOfMeasure& fixedPriceUnitOfMeasure() const {
            return fixedPriceUnitOfMeasure_;
        }
        const ext::shared_ptr<CommodityIndex>& index() const {
            return index_;
        }

      protected:
        void performCalculations() const override;

        Integer payReceive_;
        Money fixedPrice_;
        UnitOfMeasure fixedPriceUnitOfMeasure_;
        ext::shared_ptr<CommodityIndex> index_;
        Handle<YieldTermStructure> payLegTermStructure_;
        Handle<YieldTermStructure> receiveLegTermStructure_;
        Handle<YieldTermStructure> discountTermStructure_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="16">
    <source>exchangecontract.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file exchangecontract.hpp
    \brief Exchange contract
*/

#ifndef quantlib_exchange_contract_hpp
#define quantlib_exchange_contract_hpp

#include <ql/time/date.hpp>
#include <map>
#include <utility>

namespace QuantLib {

    class ExchangeContract {
      public:
        ExchangeContract() = default;
        ExchangeContract(std::string code,
                         Date expirationDate,
                         Date underlyingStartDate,
                         Date underlyingEndDate);

        const std::string& code() const;
        const Date& expirationDate() const;
        const Date& underlyingStartDate() const;
        const Date& underlyingEndDate() const;
      protected:
        std::string code_;
        Date expirationDate_;
        Date underlyingStartDate_;
        Date underlyingEndDate_;
    };

    inline ExchangeContract::ExchangeContract(std::string code,
                                              Date expirationDate,
                                              Date underlyingStartDate,
                                              Date underlyingEndDate)
    : code_(std::move(code)), expirationDate_(expirationDate),
      underlyingStartDate_(underlyingStartDate), underlyingEndDate_(underlyingEndDate) {}

    inline const std::string& ExchangeContract::code() const {
        return code_;
    }

    inline const Date& ExchangeContract::expirationDate() const {
        return expirationDate_;
    }

    inline const Date& ExchangeContract::underlyingStartDate() const {
        return underlyingStartDate_;
    }

    inline const Date& ExchangeContract::underlyingEndDate() const {
        return underlyingEndDate_;
    }

    typedef std::map<Date, ExchangeContract> ExchangeContracts;

}

#endif
]]></document_content>
  </document>
  <document index="17">
    <source>paymentterm.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file commoditypricinghelpers.hpp
    \brief Commodity pricing helpers
*/

#ifndef quantlib_payment_term_hpp
#define quantlib_payment_term_hpp

#include <ql/time/calendar.hpp>
#include <map>
#include <utility>

namespace QuantLib {

    class PaymentTerm {
      public:
        enum EventType { TradeDate, PricingDate };

        PaymentTerm() = default;
        PaymentTerm(const std::string& name,
                    EventType eventType,
                    Integer offsetDays,
                    const Calendar& calendar);
        //! \name Inspectors
        //@{
        //! name, e.g, "Pricing end + 5 days"
        const std::string& name() const;
        EventType eventType() const;
        Integer offsetDays() const;
        const Calendar& calendar() const;

        bool empty() const;
        //@}
        Date getPaymentDate(const Date& date) const;
      protected:
        struct Data;
        ext::shared_ptr<Data> data_;

        struct Data {
            std::string name;
            EventType eventType;
            Integer offsetDays;
            Calendar calendar;

            Data(std::string name, EventType eventType, Integer offsetDays, Calendar calendar);
        };

        static std::map<std::string, ext::shared_ptr<Data> > paymentTerms_;
    };

    /*! \relates PaymentTerm */
    bool operator==(const PaymentTerm&,
                    const PaymentTerm&);

    /*! \relates PaymentTerm */
    bool operator!=(const PaymentTerm&,
                    const PaymentTerm&);

    /*! \relates PaymentTerm */
    std::ostream& operator<<(std::ostream&,
                             const PaymentTerm&);


    inline PaymentTerm::Data::Data(std::string name,
                                   PaymentTerm::EventType eventType,
                                   Integer offsetDays,
                                   Calendar calendar)
    : name(std::move(name)), eventType(eventType), offsetDays(offsetDays),
      calendar(std::move(calendar)) {}

    inline const std::string& PaymentTerm::name() const {
        return data_->name;
    }

    inline PaymentTerm::EventType PaymentTerm::eventType() const {
        return data_->eventType;
    }

    inline Integer PaymentTerm::offsetDays() const {
        return data_->offsetDays;
    }
 
    inline const Calendar& PaymentTerm::calendar() const {
        return data_->calendar;
    }

    inline Date PaymentTerm::getPaymentDate(const Date& date) const {
        return data_->calendar.adjust(date + data_->offsetDays);
    }

    inline bool PaymentTerm::empty() const {
        return !data_;
    }

    inline bool operator==(const PaymentTerm& c1, const PaymentTerm& c2) {
        return c1.name() == c2.name();
    }

    inline bool operator!=(const PaymentTerm& c1, const PaymentTerm& c2) {
        return !(c1 == c2);
    }

}


#endif
]]></document_content>
  </document>
  <document index="18">
    <source>petroleumunitsofmeasure.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file petroleumunitsofmeasure.hpp
    \brief Petroleum units of measure
*/

#ifndef quantlib_petroleum_units_of_measure_hpp
#define quantlib_petroleum_units_of_measure_hpp

#include <ql/experimental/commodities/unitofmeasure.hpp>

namespace QuantLib {

    class BarrelUnitOfMeasure : public UnitOfMeasure {
      public:
        BarrelUnitOfMeasure() {
            static ext::shared_ptr<Data> data(
                           new Data("Barrels", "BBL", UnitOfMeasure::Volume));
            data_ = data;
        }
    };

    class MTUnitOfMeasure : public UnitOfMeasure {
      public:
        MTUnitOfMeasure() {
            static ext::shared_ptr<Data> data(
                        new Data("Metric Tonnes", "MT", UnitOfMeasure::Mass));
            data_ = data;
        }
    };

    class MBUnitOfMeasure : public UnitOfMeasure {
      public:
        MBUnitOfMeasure() {
            static ext::shared_ptr<Data> data(
                         new Data("1000 Barrels", "MB", UnitOfMeasure::Volume,
                                  BarrelUnitOfMeasure()));
            data_ = data;
        }
    };

    class GallonUnitOfMeasure : public UnitOfMeasure {
      public:
        GallonUnitOfMeasure() {
            static ext::shared_ptr<Data> data(
                          new Data("US Gallons", "GAL", UnitOfMeasure::Volume,
                                   BarrelUnitOfMeasure()));
            data_ = data;
        }
    };

    class LitreUnitOfMeasure : public UnitOfMeasure {
      public:
        LitreUnitOfMeasure() {
            static ext::shared_ptr<Data> data(
                                new Data("Litres", "l", UnitOfMeasure::Volume,
                                         BarrelUnitOfMeasure()));
            data_ = data;
        }
    };

    class KilolitreUnitOfMeasure : public UnitOfMeasure {
      public:
        KilolitreUnitOfMeasure() {
            static ext::shared_ptr<Data> data(
                           new Data("Kilolitres", "kl", UnitOfMeasure::Volume,
                                    BarrelUnitOfMeasure()));
            data_ = data;
        }
    };

    class TokyoKilolitreUnitOfMeasure : public UnitOfMeasure {
      public:
        TokyoKilolitreUnitOfMeasure() {
            static ext::shared_ptr<Data> data(
                new Data("Tokyo Kilolitres", "KL_tk", UnitOfMeasure::Volume,
                         BarrelUnitOfMeasure()));
            data_ = data;
        }
    };

}


#endif
]]></document_content>
  </document>
  <document index="19">
    <source>pricingperiod.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file pricingperiod.hpp
    \brief Pricing period
*/

#ifndef quantlib_pricing_period_hpp
#define quantlib_pricing_period_hpp

#include <ql/experimental/commodities/dateinterval.hpp>
#include <ql/experimental/commodities/quantity.hpp>
#include <utility>
#include <vector>

namespace QuantLib {

    //! Time pricingperiod described by a number of a given time unit
    /*! \ingroup datetime */
    class PricingPeriod : public DateInterval {
      public:
        PricingPeriod(const Date& startDate,
                      const Date& endDate,
                      const Date& paymentDate,
                      Quantity quantity)
        : DateInterval(startDate, endDate), paymentDate_(paymentDate),
          quantity_(std::move(quantity)) {}
        const Date& paymentDate() const { return paymentDate_; }
        const Quantity& quantity() const { return quantity_; }
      private:
        Date paymentDate_;
        Quantity quantity_;
    };

    typedef std::vector<ext::shared_ptr<PricingPeriod> > PricingPeriods;
}

#endif
]]></document_content>
  </document>
  <document index="20">
    <source>quantity.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file quantity.hpp
    \brief Amount of a commodity
*/

#ifndef quantlib_quantity_hpp
#define quantlib_quantity_hpp

#include <ql/experimental/commodities/commoditytype.hpp>
#include <ql/experimental/commodities/unitofmeasure.hpp>
#include <utility>

namespace QuantLib {

    //! Amount of a commodity
    class Quantity {
      public:
        //! \name Constructors
        //@{
        Quantity() = default;
        Quantity(CommodityType commodityType, UnitOfMeasure unitOfMeasure, Real amount);
        //@}
        //! \name Inspectors
        //@{
        const CommodityType& commodityType() const;
        const UnitOfMeasure& unitOfMeasure() const;
        Real amount() const;
        Quantity rounded() const;
        //@}
        /*! \name Quantity arithmetics

            See below for non-member functions and for settings which
            determine the behavior of the operators.
        */
        //@{
        Quantity operator+() const;
        Quantity operator-() const;
        Quantity& operator+=(const Quantity&);
        Quantity& operator-=(const Quantity&);
        Quantity& operator*=(Real);
        Quantity& operator/=(Real);
        //@}
        /*! \name Conversion settings

            These parameters are used for combining quantity amounts
            in different currencies
        */
        //@{
        enum ConversionType {
            NoConversion,                /*!< do not perform conversions */
            BaseUnitOfMeasureConversion, /*!< convert both operands to
                                              the base unitOfMeasure before
                                              converting */
            AutomatedConversion          /*!< return the result in the
                                              unitOfMeasure of the first
                                              operand */
        };
        static ConversionType conversionType;
        static UnitOfMeasure baseUnitOfMeasure;
        //@}

        friend std::ostream& operator<<(std::ostream&, const Quantity&);
      private:
        CommodityType commodityType_;
        UnitOfMeasure unitOfMeasure_;
        Real amount_ = 0.0;
    };


    // More arithmetics and comparisons

    /*! \relates Quantity */
    Quantity operator+(const Quantity&, const Quantity&);
    /*! \relates Quantity */
    Quantity operator-(const Quantity&, const Quantity&);
    /*! \relates Quantity */
    Quantity operator*(const Quantity&, Real);
    /*! \relates Quantity */
    Quantity operator*(Real, const Quantity&);
    /*! \relates Quantity */
    Quantity operator/(const Quantity&, Real);
    /*! \relates Quantity */
    Real operator/(const Quantity&, const Quantity&);

    /*! \relates Quantity */
    bool operator==(const Quantity&, const Quantity&);
    /*! \relates Quantity */
    bool operator!=(const Quantity&, const Quantity&);
    /*! \relates Quantity */
    bool operator<(const Quantity&, const Quantity&);
    /*! \relates Quantity */
    bool operator<=(const Quantity&, const Quantity&);
    /*! \relates Quantity */
    bool operator>(const Quantity&, const Quantity&);
    /*! \relates Quantity */
    bool operator>=(const Quantity&, const Quantity&);

    /*! \relates Quantity */
    bool close(const Quantity&, const Quantity&, Size n = 42);
    /*! \relates Quantity */
    bool close_enough(const Quantity&, const Quantity&, Size n = 42);


    // inline definitions

    inline Quantity::Quantity(CommodityType commodityType, UnitOfMeasure unitOfMeasure, Real amount)
    : commodityType_(std::move(commodityType)), unitOfMeasure_(std::move(unitOfMeasure)),
      amount_(amount) {}

    inline const CommodityType& Quantity::commodityType() const {
        return commodityType_;
    }

    inline const UnitOfMeasure& Quantity::unitOfMeasure() const {
        return unitOfMeasure_;
    }

    inline Real Quantity::amount() const {
        return amount_;
    }

    inline Quantity Quantity::rounded() const {
        return Quantity(commodityType_,
                        unitOfMeasure_,
                        unitOfMeasure_.rounding()(amount_));
    }

    inline Quantity Quantity::operator+() const {
        return *this;
    }

    inline Quantity Quantity::operator-() const {
        return Quantity(commodityType_, unitOfMeasure_, -amount_);
    }

    inline Quantity& Quantity::operator*=(Real x) {
        amount_ *= x;
        return *this;
    }

    inline Quantity& Quantity::operator/=(Real x) {
        amount_ /= x;
        return *this;
    }


    inline Quantity operator+(const Quantity& m1, const Quantity& m2) {
        Quantity tmp = m1;
        tmp += m2;
        return tmp;
    }

    inline Quantity operator-(const Quantity& m1, const Quantity& m2) {
        Quantity tmp = m1;
        tmp -= m2;
        return tmp;
    }

    inline Quantity operator*(const Quantity& m, Real x) {
        Quantity tmp = m;
        tmp *= x;
        return tmp;
    }

    inline Quantity operator*(Real x, const Quantity& m) {
        return m*x;
    }

    inline Quantity operator/(const Quantity& m, Real x) {
        Quantity tmp = m;
        tmp /= x;
        return tmp;
    }

    inline bool operator!=(const Quantity& m1, const Quantity& m2) {
        return !(m1 == m2);
    }

    inline bool operator>(const Quantity& m1, const Quantity& m2) {
        return m2 < m1;
    }

    inline bool operator>=(const Quantity& m1, const Quantity& m2) {
        return m2 <= m1;
    }

}


#endif
]]></document_content>
  </document>
  <document index="21">
    <source>unitofmeasure.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file unitofmeasure.hpp
    \brief Unit of measure
*/

#ifndef quantlib_unit_of_measure_hpp
#define quantlib_unit_of_measure_hpp

#include <ql/types.hpp>
#include <ql/math/rounding.hpp>
#include <ql/shared_ptr.hpp>
#include <string>
#include <map>
#include <iosfwd>

namespace QuantLib {

    //! %Unit of measure specification
    class UnitOfMeasure {
      public:
        enum Type { Mass, Volume, Energy, Quantity };
        //! default constructor
        /*! Instances built via this constructor have undefined
            behavior. Such instances can only act as placeholders
            and must be reassigned to a valid currency before being
            used.
        */
        UnitOfMeasure() = default;
        UnitOfMeasure(const std::string& name,
                      const std::string& code,
                      Type unitType);
        //! \name Inspectors
        //@{
        //! name, e.g, "Barrels"
        const std::string& name() const;
        //! code, e.g, "BBL", "MT"
        const std::string& code() const;
        //! unit type (mass, volume...)
        Type unitType() const;
        //@}
        //! \name Other information
        //@{
        //! is this a usable instance?
        bool empty() const;
        // rounding
        const Rounding& rounding() const;
        //! unit used for triangulation when required
        const UnitOfMeasure& triangulationUnitOfMeasure() const;
        //@}
      protected:
        struct Data;
        ext::shared_ptr<Data> data_;
      private:
        static std::map<std::string, ext::shared_ptr<UnitOfMeasure::Data> >
        unitsOfMeasure_;
    };

    struct UnitOfMeasure::Data {
        std::string name, code;
        UnitOfMeasure::Type unitType;
        UnitOfMeasure triangulationUnitOfMeasure;
        Rounding rounding;

        Data(std::string name,
             std::string code,
             UnitOfMeasure::Type unitType,
             UnitOfMeasure triangulationUnitOfMeasure = UnitOfMeasure(),
             const Rounding& rounding = Rounding(0));
    };


    /*! \relates UnitOfMeasure */
    bool operator==(const UnitOfMeasure&,
                    const UnitOfMeasure&);

    /*! \relates UnitOfMeasure */
    bool operator!=(const UnitOfMeasure&,
                    const UnitOfMeasure&);

    /*! \relates UnitOfMeasure */
    std::ostream& operator<<(std::ostream&,
                             const UnitOfMeasure&);


    // inline definitions

    inline const std::string& UnitOfMeasure::name() const {
        return data_->name;
    }

    inline const std::string& UnitOfMeasure::code() const {
        return data_->code;
    }

    inline UnitOfMeasure::Type UnitOfMeasure::unitType() const {
        return data_->unitType;
    }

    inline const Rounding& UnitOfMeasure::rounding() const {
        return data_->rounding;
    }

    inline bool UnitOfMeasure::empty() const {
        return !data_;
    }

    inline const UnitOfMeasure&
    UnitOfMeasure::triangulationUnitOfMeasure() const {
        return data_->triangulationUnitOfMeasure;
    }

    inline bool operator==(const UnitOfMeasure& c1, const UnitOfMeasure& c2) {
        return c1.code() == c2.code();
    }

    inline bool operator!=(const UnitOfMeasure& c1, const UnitOfMeasure& c2) {
        return !(c1 == c2);
    }

    class LotUnitOfMeasure : public UnitOfMeasure {
      public:
        LotUnitOfMeasure() {
            static ext::shared_ptr<Data> data(
                new Data("Lot", "Lot", UnitOfMeasure::Quantity));
            data_ = data;
        }
    };

}


#endif
]]></document_content>
  </document>
  <document index="22">
    <source>unitofmeasureconversion.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file energycommodity.hpp
    \brief Energy commodity
*/

#ifndef quantlib_unit_of_measure_conversion_hpp
#define quantlib_unit_of_measure_conversion_hpp

#include <ql/experimental/commodities/quantity.hpp>
#include <ql/experimental/commodities/unitofmeasure.hpp>
#include <ql/utilities/null.hpp>
#include <utility>

namespace QuantLib {

    class UnitOfMeasureConversion {
      public:
        enum Type { Direct,  /*!< given directly by the user */
                    Derived  /*!< derived from conversion factors
                                  between other uoms */
        };
        //! \name Constructors
        //@{
        UnitOfMeasureConversion() = default;
        /*! the conversionFactor \f$ r \f$ is given with the
            convention that a unit of the source is worth \f$ r \f$
            units of the target.
        */
        UnitOfMeasureConversion(const CommodityType& commodityType,
                                const UnitOfMeasure& source,
                                const UnitOfMeasure& target,
                                Real conversionFactor);
        //@}

        //! \name Inspectors
        //@{
        //! the source UOM.
        const UnitOfMeasure& source() const;
        //! the target UOM.
        const UnitOfMeasure& target() const;
        //! the commodity type.
        const CommodityType& commodityType() const;
        //! the type
        Type type() const;
        //! the conversion factor
        Real conversionFactor() const;

        const std::string& code() const;
        //@}

        //! \name Utility methods
        //@{
        //! apply the conversion factor to a cash amount
        Quantity convert(const Quantity& quantity) const;
        //! chain two conversion factors
        static UnitOfMeasureConversion chain(const UnitOfMeasureConversion& r1,
                                             const UnitOfMeasureConversion& r2);
        //@}
      protected:
        UnitOfMeasureConversion(const UnitOfMeasureConversion& r1,
                                const UnitOfMeasureConversion& r2);

        struct Data;
        ext::shared_ptr<Data> data_;

        struct Data {
            CommodityType commodityType;
            UnitOfMeasure source, target;
            Real conversionFactor;
            Type type;
            std::string code;
            std::pair<ext::shared_ptr<UnitOfMeasureConversion>,
                      ext::shared_ptr<UnitOfMeasureConversion> >
            conversionFactorChain;

            Data(const CommodityType& commodityType,
                 const UnitOfMeasure& source,
                 const UnitOfMeasure& target,
                 Real conversionFactor,
                 Type type);

            Data(const UnitOfMeasureConversion& r1,
                 const UnitOfMeasureConversion& r2);
        };
    };

    // inline definitions

    inline const CommodityType& UnitOfMeasureConversion::commodityType() const {
        return data_->commodityType;
    }

    inline const UnitOfMeasure& UnitOfMeasureConversion::source() const {
        return data_->source;
    }

    inline const UnitOfMeasure& UnitOfMeasureConversion::target() const {
        return data_->target;
    }

    inline Real UnitOfMeasureConversion::conversionFactor() const {
        return data_->conversionFactor;
    }

    inline UnitOfMeasureConversion::Type UnitOfMeasureConversion::type() const {
        return data_->type;
    }

    inline const std::string& UnitOfMeasureConversion::code() const {
        return data_->code;
    }

}

#endif
]]></document_content>
  </document>
  <document index="23">
    <source>unitofmeasureconversionmanager.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 J. Erik Radmall
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file unitofmeasureconversionmanager.hpp
    \brief Unit-of-measure conversion manager
*/

#ifndef quantlib_unit_of_measure_conversion_manager_hpp
#define quantlib_unit_of_measure_conversion_manager_hpp

#include <ql/experimental/commodities/unitofmeasureconversion.hpp>
#include <ql/patterns/singleton.hpp>
#include <list>

namespace QuantLib {

    //! repository of conversion factors between units of measure
    /*! \test lookup of direct unit of measure conversion is tested. */
    class UnitOfMeasureConversionManager
        : public Singleton<UnitOfMeasureConversionManager> {
        friend class Singleton<UnitOfMeasureConversionManager>;

      public:
        UnitOfMeasureConversion lookup(
            const CommodityType& commodityType,
            const UnitOfMeasure&,
            const UnitOfMeasure&,
            UnitOfMeasureConversion::Type type =
                                    UnitOfMeasureConversion::Derived) const;
        void add(const UnitOfMeasureConversion&);
        void clear();

      private:
        std::list<UnitOfMeasureConversion> data_;
        UnitOfMeasureConversionManager();
        void addKnownConversionFactors();
        UnitOfMeasureConversion directLookup(const CommodityType& commodityType,
                                             const UnitOfMeasure& source,
                                             const UnitOfMeasure& target) const;
        UnitOfMeasureConversion smartLookup(const CommodityType& commodityType,
                                            const UnitOfMeasure& source,
                                            const UnitOfMeasure& target,
                                            std::list<std::string> forbidden =
                                                std::list<std::string>()) const;
    };

}

#endif
]]></document_content>
  </document>
</documents>