<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>Makefile.am</source>
    <document_content><![CDATA[
SUBDIRS = ibor inflation swap

AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    bmaindex.hpp \
    iborindex.hpp \
    indexmanager.hpp \
    inflationindex.hpp \
    interestrateindex.hpp \
    region.hpp \
    swapindex.hpp

cpp_files = \
    bmaindex.cpp \
    iborindex.cpp \
    indexmanager.cpp \
    inflationindex.cpp \
    interestrateindex.cpp \
    region.cpp \
    swapindex.cpp

libIndexes_la_LIBADD = \
    ibor/libIborIndexes.la \
    swap/libSwapIndexes.la

if UNITY_BUILD

nodist_libIndexes_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libIndexes_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libIndexes.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="2">
    <source>all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/indexes/bmaindex.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/indexes/indexmanager.hpp>
#include <ql/indexes/inflationindex.hpp>
#include <ql/indexes/interestrateindex.hpp>
#include <ql/indexes/region.hpp>
#include <ql/indexes/swapindex.hpp>

#include <ql/indexes/ibor/all.hpp>
#include <ql/indexes/inflation/all.hpp>
#include <ql/indexes/swap/all.hpp>
]]></document_content>
  </document>
  <document index="3">
    <source>bmaindex.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/bmaindex.hpp>
#include <ql/currencies/america.hpp>
#include <ql/time/calendars/unitedstates.hpp>
#include <ql/time/daycounters/actualactual.hpp>

namespace QuantLib {

    namespace {

        Date previousWednesday(const Date& date) {
            Weekday w = date.weekday();
            if (w >= 4) // roll back w-4 days
                return date - (w - 4) * Days;
            else // roll forward 4-w days and back one week
                return date + (4 - w - 7) * Days;
        }

        Date nextWednesday(const Date& date) {
            return previousWednesday(date+7);
        }

    }

    BMAIndex::BMAIndex(const Handle<YieldTermStructure>& h)
    : InterestRateIndex("BMA",
                        1 * Weeks,
                        1,
                        USDCurrency(),
                        UnitedStates(UnitedStates::GovernmentBond),
                        ActualActual(ActualActual::ISDA)),
      termStructure_(h) {
        registerWith (h);
    }

    BMAIndex::BMAIndex(const Handle<YieldTermStructure>& h,
                       const Calendar& fixingCalendar)
    : InterestRateIndex("BMA",
                        1 * Weeks,
                        1,
                        USDCurrency(),
                        fixingCalendar,
                        ActualActual(ActualActual::ISDA)),
      termStructure_(h) {
        registerWith (h);
    }

    bool BMAIndex::isValidFixingDate(const Date& date) const {
        Calendar cal = fixingCalendar();
        // either the fixing date is last Wednesday, or all days
        // between last Wednesday included and the fixing date are
        // holidays
        for (Date d = previousWednesday(date); d<date; ++d) {
            if (cal.isBusinessDay(d))
                return false;
        }
        // also, the fixing date itself must be a business day
        return cal.isBusinessDay(date);
    }

    Handle<YieldTermStructure> BMAIndex::forwardingTermStructure() const {
        return termStructure_;
    }

    Date BMAIndex::maturityDate(const Date& valueDate) const {
        Calendar cal = fixingCalendar();
        Date fixingDate = cal.advance(valueDate, -1, Days);
        Date nextWednesday = previousWednesday(fixingDate+7);
        return cal.advance(nextWednesday, 1, Days);
    }

    Schedule BMAIndex::fixingSchedule(const Date& start, const Date& end) {
        return MakeSchedule().from(previousWednesday(start))
                             .to(nextWednesday(end))
                             .withFrequency(Weekly)
                             .withCalendar(fixingCalendar())
                             .withConvention(Following)
                             .forwards();
    }

    Rate BMAIndex::forecastFixing(const Date& fixingDate) const {
        QL_REQUIRE(!termStructure_.empty(),
                   "null term structure set to this instance of " << name());
        Date start = fixingCalendar().advance(fixingDate, 1, Days);
        Date end = maturityDate(start);
        return termStructure_->forwardRate(start, end,
                                           dayCounter_,
                                           Simple);
    }

}
]]></document_content>
  </document>
  <document index="4">
    <source>bmaindex.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Roland Lichters

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bmaindex.hpp
    \brief Bond Market Association index
*/

#ifndef quantlib_bma_index_hpp
#define quantlib_bma_index_hpp

#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/indexes/interestrateindex.hpp>
#include <ql/time/schedule.hpp>

namespace QuantLib {

    //! Bond Market Association index
    /*! The BMA index is the short-term tax-exempt reference index of
        the Bond Market Association.  It has tenor one week, is fixed
        weekly on Wednesdays and is applied with a one-day's fixing
        gap from Thursdays on for one week.  It is the tax-exempt
        correspondent of the 1M USD-Libor.
    */
    class BMAIndex : public InterestRateIndex {
      public:
        explicit BMAIndex(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
        /*! \deprecated Use the other constructor instead.
                        Deprecated in version 1.19.
        */
        QL_DEPRECATED
        BMAIndex(const Handle<YieldTermStructure>& h,
                 const Calendar& fixingCalendar);
        //! \name Index interface
        //@{
        /*! BMA is fixed weekly on Wednesdays.
        */
        bool isValidFixingDate(const Date& fixingDate) const override;
        //@}
        //! \name Inspectors
        //@{
        Handle<YieldTermStructure> forwardingTermStructure() const;
        //@}
        //! \name Date calculations
        //@{
        Date maturityDate(const Date& valueDate) const override;
        /*! This method returns a schedule of fixing dates between
            start and end.
        */
        Schedule fixingSchedule(const Date& start,
                                const Date& end);
        // @}
      protected:
        Rate forecastFixing(const Date& fixingDate) const override;
        Handle<YieldTermStructure> termStructure_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="5">
    <source>ibor/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    aonia.hpp \
    audlibor.hpp \
    bbsw.hpp \
    bibor.hpp \
    bkbm.hpp \
    cadlibor.hpp \
    cdor.hpp \
    chflibor.hpp \
    dkklibor.hpp \
    eonia.hpp \
    estr.hpp \
    euribor.hpp \
    eurlibor.hpp \
    fedfunds.hpp \
    gbplibor.hpp \
    jibar.hpp \
    jpylibor.hpp \
    libor.hpp \
    mosprime.hpp \
    nzdlibor.hpp \
    nzocr.hpp \
    pribor.hpp \
    robor.hpp \
    seklibor.hpp \
    shibor.hpp \
    sofr.hpp \
    sonia.hpp \
    tibor.hpp \
    thbfix.hpp \
    trlibor.hpp \
    usdlibor.hpp \
    wibor.hpp \
    zibor.hpp

cpp_files = \
    bibor.cpp \
    eonia.cpp \
    estr.cpp \
    euribor.cpp \
    eurlibor.cpp \
    fedfunds.cpp \
    libor.cpp \
    shibor.cpp \
    sofr.cpp \
    sonia.cpp


if UNITY_BUILD

nodist_libIborIndexes_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libIborIndexes_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libIborIndexes.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done
]]></document_content>
  </document>
  <document index="6">
    <source>ibor/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/indexes/ibor/aonia.hpp>
#include <ql/indexes/ibor/audlibor.hpp>
#include <ql/indexes/ibor/bbsw.hpp>
#include <ql/indexes/ibor/bibor.hpp>
#include <ql/indexes/ibor/bkbm.hpp>
#include <ql/indexes/ibor/cadlibor.hpp>
#include <ql/indexes/ibor/cdor.hpp>
#include <ql/indexes/ibor/chflibor.hpp>
#include <ql/indexes/ibor/dkklibor.hpp>
#include <ql/indexes/ibor/eonia.hpp>
#include <ql/indexes/ibor/estr.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/indexes/ibor/eurlibor.hpp>
#include <ql/indexes/ibor/fedfunds.hpp>
#include <ql/indexes/ibor/gbplibor.hpp>
#include <ql/indexes/ibor/jibar.hpp>
#include <ql/indexes/ibor/jpylibor.hpp>
#include <ql/indexes/ibor/libor.hpp>
#include <ql/indexes/ibor/mosprime.hpp>
#include <ql/indexes/ibor/nzdlibor.hpp>
#include <ql/indexes/ibor/nzocr.hpp>
#include <ql/indexes/ibor/pribor.hpp>
#include <ql/indexes/ibor/robor.hpp>
#include <ql/indexes/ibor/seklibor.hpp>
#include <ql/indexes/ibor/shibor.hpp>
#include <ql/indexes/ibor/sofr.hpp>
#include <ql/indexes/ibor/sonia.hpp>
#include <ql/indexes/ibor/tibor.hpp>
#include <ql/indexes/ibor/thbfix.hpp>
#include <ql/indexes/ibor/trlibor.hpp>
#include <ql/indexes/ibor/usdlibor.hpp>
#include <ql/indexes/ibor/wibor.hpp>
#include <ql/indexes/ibor/zibor.hpp>

]]></document_content>
  </document>
  <document index="7">
    <source>ibor/aonia.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2016 Fabrice Lecuyer

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file aonia.hpp
\brief %Aonia index
*/

#ifndef quantlib_aonia_hpp
#define quantlib_aonia_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/australia.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/oceania.hpp>

namespace QuantLib {

    //! %Aonia index
    /*! Aonia (Australia Overnight Index Average) rate fixed by the RBA.

    See <http://www.isda.org/publications/pdf/Supplement-13-to-2000DefinitionsAnnex.pdf>.
    */
    class Aonia : public OvernightIndex {
      public:
        explicit Aonia(const Handle<YieldTermStructure>& h =
                              Handle<YieldTermStructure>())
        : OvernightIndex("Aonia", 0, AUDCurrency(),
                         Australia(),
                         Actual365Fixed(), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="8">
    <source>ibor/audlibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file audlibor.hpp
    \brief %AUD %LIBOR rate
*/

#ifndef quantlib_aud_libor_hpp
#define quantlib_aud_libor_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/australia.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/oceania.hpp>

namespace QuantLib {

    //! %AUD %LIBOR rate
    /*! Australian Dollar LIBOR discontinued as of 2013.
    */
    class AUDLibor : public Libor {
      public:
        AUDLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h =
                                     Handle<YieldTermStructure>())
        : Libor("AUDLibor", tenor,
                2,
                AUDCurrency(),
                Australia(),
                Actual360(), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="9">
    <source>ibor/bbsw.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2016 Fabrice Lecuyer

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bbsw.hpp
    \brief %Bbsw index
*/

#ifndef quantlib_bbsw_hpp
#define quantlib_bbsw_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/australia.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/oceania.hpp>

namespace QuantLib {

    //! %Bbsw index
    /*! Bbsw rate fixed by AFMA.

        See <http://www.afma.com.au/data/BBSW>.
    */
    class Bbsw : public IborIndex {
      public:
        Bbsw(const Period& tenor,
             const Handle<YieldTermStructure>& h =
                             Handle<YieldTermStructure>())
        : IborIndex("Bbsw", tenor,
                    0, // settlement days
                    AUDCurrency(), Australia(),
                    HalfMonthModifiedFollowing, true,
                    Actual365Fixed(), h) {
            QL_REQUIRE(this->tenor().units() != Days,
                       "for daily tenors (" << this->tenor() <<
                       ") dedicated DailyTenor constructor must be used");
        }
    };

    //! 1-month %Bbsw index
    class Bbsw1M : public Bbsw {
      public:
        explicit Bbsw1M(const Handle<YieldTermStructure>& h =
                               Handle<YieldTermStructure>())
        : Bbsw(Period(1, Months), h) {}
    };

    //! 2-months %Bbsw index
    class Bbsw2M : public Bbsw {
      public:
        explicit Bbsw2M(const Handle<YieldTermStructure>& h =
                               Handle<YieldTermStructure>())
        : Bbsw(Period(2, Months), h) {}
    };

    //! 3-months %Bbsw index
    class Bbsw3M : public Bbsw {
      public:
        explicit Bbsw3M(const Handle<YieldTermStructure>& h =
                               Handle<YieldTermStructure>())
        : Bbsw(Period(3, Months), h) {}
    };

    //! 4-months %Bbsw index
    class Bbsw4M : public Bbsw {
      public:
        explicit Bbsw4M(const Handle<YieldTermStructure>& h =
                               Handle<YieldTermStructure>())
        : Bbsw(Period(4, Months), h) {}
    };

    //! 5-months %Bbsw index
    class Bbsw5M : public Bbsw {
      public:
        explicit Bbsw5M(const Handle<YieldTermStructure>& h =
                               Handle<YieldTermStructure>())
        : Bbsw(Period(5, Months), h) {}
    };

    //! 6-months %Bbsw index
    class Bbsw6M : public Bbsw {
      public:
        explicit Bbsw6M(const Handle<YieldTermStructure>& h =
                               Handle<YieldTermStructure>())
        : Bbsw(Period(6, Months), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="10">
    <source>ibor/bibor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Matthias Groncki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/ibor/bibor.hpp>
#include <ql/time/calendars/thailand.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/asia.hpp>

namespace QuantLib {

    namespace {

        BusinessDayConvention BiborConvention(const Period& p) {
            switch (p.units()) {
              case Days:
              case Weeks:
                return Following;
              case Months:
              case Years:
                return ModifiedFollowing;
              default:
                QL_FAIL("invalid time units");
            }
        }

        bool BiborEOM(const Period& p) {
            switch (p.units()) {
              case Days:
              case Weeks:
                return false;
              case Months:
              case Years:
                return true;
              default:
                QL_FAIL("invalid time units");
            }
        }

    }

    Bibor::Bibor(const Period& tenor,
                     const Handle<YieldTermStructure>& h)
    : IborIndex("Bibor", tenor,
                2, // settlement days
                THBCurrency(), Thailand(),
                BiborConvention(tenor), BiborEOM(tenor),
                Actual365Fixed(), h) {
        QL_REQUIRE(this->tenor().units()!=Days,
                   "for daily tenors (" << this->tenor() <<
                   ") dedicated DailyTenor constructor must be used");
    }

}
]]></document_content>
  </document>
  <document index="11">
    <source>ibor/bibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Matthias Groncki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bibor.hpp
    \brief %Bangkok Interbank Offered Rate index
*/

#ifndef quantlib_bibor_hpp
#define quantlib_bibor_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! %Bibor index
    /*! Bangkok Interbank Offered Rate  fixed by the Bank of Thailand BOT.
    */
    class Bibor : public IborIndex {
      public:
        Bibor(const Period& tenor,
                const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
    };


    //! 1-week %Bibor index
    class BiborSW : public Bibor {
      public:
        explicit BiborSW(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Bibor(Period(1, Weeks), h) {}
    };


    //! 1-month %Euribor index
    class Bibor1M : public Bibor {
      public:
        explicit Bibor1M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Bibor(Period(1, Months), h) {}
    };

    //! 2-months %Euribor index
    class Bibor2M : public Bibor {
      public:
        explicit Bibor2M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Bibor(Period(2, Months), h) {}
    };

    //! 3-months %Bibor index
    class Bibor3M : public Bibor {
      public:
        explicit Bibor3M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Bibor(Period(3, Months), h) {}
    };

    //! 6-months %Bibor index
    class Bibor6M : public Bibor {
      public:
        explicit Bibor6M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Bibor(Period(6, Months), h) {}
    };

    //! 9-months %Bibor index
    class Bibor9M : public Bibor {
      public:
        explicit Bibor9M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Bibor(Period(9, Months), h) {}
    };

    //! 1-year %Bibor index
    class Bibor1Y : public Bibor {
      public:
        explicit Bibor1Y(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Bibor(Period(1, Years), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="12">
    <source>ibor/bkbm.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2016 Fabrice Lecuyer

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bkbm.hpp
\brief %Bkbm index
*/

#ifndef quantlib_bkbm_hpp
#define quantlib_bkbm_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/newzealand.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/oceania.hpp>

namespace QuantLib {

    //! %Bkbm index
    /*! Bkbm rate fixed by NZFMA.

        See <http://www.nzfma.org/Site/data/default.aspx>.
    */
    class Bkbm : public IborIndex {
      public:
        Bkbm(const Period& tenor,
             const Handle<YieldTermStructure>& h =
                             Handle<YieldTermStructure>())
        : IborIndex("Bkbm", tenor,
                    0, // settlement days
                    NZDCurrency(), NewZealand(),
                    ModifiedFollowing, true,
                    Actual365Fixed(), h) {
            QL_REQUIRE(this->tenor().units() != Days,
                       "for daily tenors (" << this->tenor() <<
                       ") dedicated DailyTenor constructor must be used");
        }
    };

    //! 1-month %Bkbm index
    class Bkbm1M : public Bkbm {
      public:
        explicit Bkbm1M(const Handle<YieldTermStructure>& h =
                               Handle<YieldTermStructure>())
        : Bkbm(Period(1, Months), h) {}
    };

    //! 2-months %Bkbm index
    class Bkbm2M : public Bkbm {
      public:
        explicit Bkbm2M(const Handle<YieldTermStructure>& h =
                               Handle<YieldTermStructure>())
        : Bkbm(Period(2, Months), h) {}
    };

    //! 3-months %Bkbm index
    class Bkbm3M : public Bkbm {
      public:
        explicit Bkbm3M(const Handle<YieldTermStructure>& h =
                               Handle<YieldTermStructure>())
        : Bkbm(Period(3, Months), h) {}
    };

    //! 4-months %Bkbm index
    class Bkbm4M : public Bkbm {
      public:
        explicit Bkbm4M(const Handle<YieldTermStructure>& h =
                               Handle<YieldTermStructure>())
        : Bkbm(Period(4, Months), h) {}
    };

    //! 5-months %Bkbm index
    class Bkbm5M : public Bkbm {
      public:
        explicit Bkbm5M(const Handle<YieldTermStructure>& h =
                               Handle<YieldTermStructure>())
        : Bkbm(Period(5, Months), h) {}
    };

    //! 6-months %Bkbm index
    class Bkbm6M : public Bkbm {
      public:
        explicit Bkbm6M(const Handle<YieldTermStructure>& h =
                               Handle<YieldTermStructure>())
        : Bkbm(Period(6, Months), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="13">
    <source>ibor/cadlibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cadlibor.hpp
    \brief %CAD %LIBOR rate
*/

#ifndef quantlib_cad_libor_hpp
#define quantlib_cad_libor_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/canada.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/america.hpp>

namespace QuantLib {

    //! %CAD LIBOR rate
    /*! Canadian Dollar LIBOR discontinued as of 2013.

        Conventions are taken from a number of sources including
        OpenGamma "Interest Rate Instruments and Market Conventions
        Guide", BBG, IKON.

        \warning This is the rate fixed in London by BBA. Use CDOR if
                 you're interested in the Canadian fixing by IDA.
    */
    class CADLibor : public Libor {
      public:
        CADLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Libor("CADLibor", tenor,
                0,
                CADCurrency(),
                Canada(),
                Actual365Fixed(), h) {}
    };

    //! Overnight %CAD %Libor index
    class CADLiborON : public DailyTenorLibor {
      public:
        explicit CADLiborON(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : DailyTenorLibor("CADLibor",
                          0,
                          CADCurrency(),
                          Canada(),
                          Actual365Fixed(), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="14">
    <source>ibor/cdor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cdor.hpp
    \brief %CDOR rate
*/

#ifndef quantlib_cdor_hpp
#define quantlib_cdor_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/canada.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/america.hpp>

namespace QuantLib {

    //! %CDOR rate
    /*! Canadian Dollar Offered Rate fixed by IDA.

        Conventions are taken from a number of sources including
        OpenGamma "Interest Rate Instruments and Market Conventions
        Guide", BBG, IKON.

        \warning This is the rate fixed in Canada by IDA. Use CADLibor
                 if you're interested in the London fixing by BBA.
    */
    class Cdor : public IborIndex {
      public:
        Cdor(const Period& tenor,
             const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : IborIndex("CDOR", tenor, 0, CADCurrency(),
                    Canada(), ModifiedFollowing, false,
                    Actual365Fixed(), h) {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="15">
    <source>ibor/chflibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file chflibor.hpp
    \brief %CHF %LIBOR rate
*/

#ifndef quantlib_chf_libor_hpp
#define quantlib_chf_libor_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/switzerland.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    //! %CHF %LIBOR rate
    /*! Swiss Franc LIBOR fixed by ICE.

        See <https://www.theice.com/marketdata/reports/170>.

        \warning This is the rate fixed in London by BBA. Use ZIBOR if
                 you're interested in the Zurich fixing.
    */
    class CHFLibor : public Libor {
      public:
        CHFLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Libor("CHFLibor", tenor,
                2,
                CHFCurrency(),
                Switzerland(),
                Actual360(), h) {}
    };

    //! base class for the one day deposit BBA %CHF %LIBOR indexes
    class DailyTenorCHFLibor : public DailyTenorLibor {
      public:
        DailyTenorCHFLibor(Natural settlementDays,
                           const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : DailyTenorLibor("CHFLibor", settlementDays,
                          CHFCurrency(),
                          Switzerland(),
                          Actual360(), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="16">
    <source>ibor/dkklibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file dkklibor.hpp
    \brief %DKK %LIBOR rate
*/

#ifndef quantlib_dkk_libor_hpp
#define quantlib_dkk_libor_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/denmark.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    //! %DKK %LIBOR rate
    /*! Danish Krona LIBOR discontinued as of 2013.
    */
    class DKKLibor : public Libor {
      public:
        DKKLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Libor("DKKLibor", tenor,
                2,
                DKKCurrency(),
                Denmark(),
                Actual360(), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="17">
    <source>ibor/eonia.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/ibor/eonia.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    Eonia::Eonia(const Handle<YieldTermStructure>& h)
    : OvernightIndex("Eonia", 0, EURCurrency(), TARGET(), Actual360(), h) {}

}
]]></document_content>
  </document>
  <document index="18">
    <source>ibor/eonia.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file eonia.hpp
    \brief %Eonia index
*/

#ifndef quantlib_eonia_hpp
#define quantlib_eonia_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! %Eonia (Euro Overnight Index Average) rate fixed by the ECB.
    class Eonia : public OvernightIndex {
      public:
        explicit Eonia(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
    };

}

#endif
]]></document_content>
  </document>
  <document index="19">
    <source>ibor/estr.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Magnus Mencke

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/ibor/estr.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    Estr::Estr(const Handle<YieldTermStructure>& h)
    : OvernightIndex("ESTR", 0, EURCurrency(), TARGET(), Actual360(), h) {}

}
]]></document_content>
  </document>
  <document index="20">
    <source>ibor/estr.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Magnus Mencke

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file eonia.hpp
    \brief %ESTR index
*/

#ifndef quantlib_estr_hpp
#define quantlib_estr_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! %ESTR (Euro Short-Term Rate) rate fixed by the ECB.
    class Estr : public OvernightIndex {
      public:
        explicit Estr(const Handle<YieldTermStructure>& h =
                      Handle<YieldTermStructure>());
    };

}

#endif
]]></document_content>
  </document>
  <document index="21">
    <source>ibor/euribor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Chiara Fornarola

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/ibor/euribor.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    namespace {

        BusinessDayConvention euriborConvention(const Period& p) {
            switch (p.units()) {
              case Days:
              case Weeks:
                return Following;
              case Months:
              case Years:
                return ModifiedFollowing;
              default:
                QL_FAIL("invalid time units");
            }
        }

        bool euriborEOM(const Period& p) {
            switch (p.units()) {
              case Days:
              case Weeks:
                return false;
              case Months:
              case Years:
                return true;
              default:
                QL_FAIL("invalid time units");
            }
        }

    }

    Euribor::Euribor(const Period& tenor,
                     const Handle<YieldTermStructure>& h)
    : IborIndex("Euribor", tenor,
                2, // settlement days
                EURCurrency(), TARGET(),
                euriborConvention(tenor), euriborEOM(tenor),
                Actual360(), h) {
        QL_REQUIRE(this->tenor().units()!=Days,
                   "for daily tenors (" << this->tenor() <<
                   ") dedicated DailyTenor constructor must be used");
    }

    Euribor365::Euribor365(const Period& tenor,
                           const Handle<YieldTermStructure>& h)
    : IborIndex("Euribor365", tenor,
                2, // settlement days
                EURCurrency(), TARGET(),
                euriborConvention(tenor), euriborEOM(tenor),
                Actual365Fixed(), h) {
        QL_REQUIRE(this->tenor().units()!=Days,
                   "for daily tenors (" << this->tenor() <<
                   ") dedicated DailyTenor constructor must be used");
    }

}
]]></document_content>
  </document>
  <document index="22">
    <source>ibor/euribor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl
 Copyright (C) 2006 Katiuscia Manzoni
 Copyright (C) 2006 Chiara Fornarola
 Copyright (C) 2009 Roland Lichters
 Copyright (C) 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file euribor.hpp
    \brief %Euribor index
*/

#ifndef quantlib_euribor_hpp
#define quantlib_euribor_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! %Euribor index
    /*! Euribor rate fixed by the ECB.

        \warning This is the rate fixed by the ECB. Use EurLibor
                 if you're interested in the London fixing by BBA.
    */
    class Euribor : public IborIndex {
      public:
        Euribor(const Period& tenor,
                const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
    };

    //! Actual/365 %Euribor index
    /*! Euribor rate adjusted for the mismatch between the actual/360
        convention used for Euribor and the actual/365 convention
        previously used by a few pre-EUR currencies.
    */
    class Euribor365 : public IborIndex {
      public:
        Euribor365(const Period& tenor,
                   const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
    };

    //! 1-week %Euribor index
    class EuriborSW : public Euribor {
      public:
        explicit EuriborSW(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor(Period(1, Weeks), h) {}
    };

    //! 2-weeks %Euribor index
    class Euribor2W : public Euribor {
      public:
        explicit Euribor2W(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor(Period(2, Weeks), h) {}
    };

    //! 3-weeks %Euribor index
    class Euribor3W : public Euribor {
      public:
        explicit Euribor3W(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor(Period(3, Weeks), h) {}
    };

    //! 1-month %Euribor index
    class Euribor1M : public Euribor {
      public:
        explicit Euribor1M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor(Period(1, Months), h) {}
    };

    //! 2-months %Euribor index
    class Euribor2M : public Euribor {
      public:
        explicit Euribor2M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor(Period(2, Months), h) {}
    };

    //! 3-months %Euribor index
    class Euribor3M : public Euribor {
      public:
        explicit Euribor3M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor(Period(3, Months), h) {}
    };

    //! 4-months %Euribor index
    class Euribor4M : public Euribor {
      public:
        explicit Euribor4M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor(Period(4, Months), h) {}
    };

    //! 5-months %Euribor index
    class Euribor5M : public Euribor {
      public:
        explicit Euribor5M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor(Period(5, Months), h) {}
    };

    //! 6-months %Euribor index
    class Euribor6M : public Euribor {
      public:
        explicit Euribor6M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor(Period(6, Months), h) {}
    };

    //! 7-months %Euribor index
    class Euribor7M : public Euribor {
      public:
        explicit Euribor7M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor(Period(7, Months), h) {}
    };

    //! 8-months %Euribor index
    class Euribor8M : public Euribor {
      public:
        explicit Euribor8M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor(Period(8, Months), h) {}
    };

    //! 9-months %Euribor index
    class Euribor9M : public Euribor {
      public:
        explicit Euribor9M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor(Period(9, Months), h) {}
    };

    //! 10-months %Euribor index
    class Euribor10M : public Euribor {
      public:
        explicit Euribor10M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor(Period(10, Months), h) {}
    };

    //! 11-months %Euribor index
    class Euribor11M : public Euribor {
      public:
        explicit Euribor11M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor(Period(11, Months), h) {}
    };

    //! 1-year %Euribor index
    class Euribor1Y : public Euribor {
      public:
        explicit Euribor1Y(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor(Period(1, Years), h) {}
    };


    //! 1-week %Euribor365 index
    class Euribor365_SW : public Euribor365 {
      public:
        explicit Euribor365_SW(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor365(Period(1, Weeks), h) {}
    };

    //! 2-weeks %Euribor365 index
    class Euribor365_2W : public Euribor365 {
      public:
        explicit Euribor365_2W(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor365(Period(2, Weeks), h) {}
    };

    //! 3-weeks %Euribor365 index
    class Euribor365_3W : public Euribor365 {
      public:
        explicit Euribor365_3W(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor365(Period(3, Weeks), h) {}
    };

    //! 1-month %Euribor365 index
    class Euribor365_1M : public Euribor365 {
      public:
        explicit Euribor365_1M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor365(Period(1, Months), h) {}
    };

    //! 2-months %Euribor365 index
    class Euribor365_2M : public Euribor365 {
      public:
        explicit Euribor365_2M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor365(Period(2, Months), h) {}
    };

    //! 3-months %Euribor365 index
    class Euribor365_3M : public Euribor365 {
      public:
        explicit Euribor365_3M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor365(Period(3, Months), h) {}
    };

    //! 4-months %Euribor365 index
    class Euribor365_4M : public Euribor365 {
      public:
        explicit Euribor365_4M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor365(Period(4, Months), h) {}
    };

    //! 5-months %Euribor365 index
    class Euribor365_5M : public Euribor365 {
      public:
        explicit Euribor365_5M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor365(Period(5, Months), h) {}
    };

    //! 6-months %Euribor365 index
    class Euribor365_6M : public Euribor365 {
      public:
        explicit Euribor365_6M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor365(Period(6, Months), h) {}
    };

    //! 7-months %Euribor365 index
    class Euribor365_7M : public Euribor365 {
      public:
        explicit Euribor365_7M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor365(Period(7, Months), h) {}
    };

    //! 8-months %Euribor365 index
    class Euribor365_8M : public Euribor365 {
      public:
        explicit Euribor365_8M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor365(Period(8, Months), h) {}
    };

    //! 9-months %Euribor365 index
    class Euribor365_9M : public Euribor365 {
      public:
        explicit Euribor365_9M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor365(Period(9, Months), h) {}
    };

    //! 10-months %Euribor365 index
    class Euribor365_10M : public Euribor365 {
      public:
        explicit Euribor365_10M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor365(Period(10, Months), h) {}
    };

    //! 11-months %Euribor365 index
    class Euribor365_11M : public Euribor365 {
      public:
        explicit Euribor365_11M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor365(Period(11, Months), h) {}
    };

    //! 1-year %Euribor365 index
    class Euribor365_1Y : public Euribor365 {
      public:
        explicit Euribor365_1Y(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Euribor365(Period(1, Years), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="23">
    <source>ibor/eurlibor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Chiara Fornarola

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/ibor/eurlibor.hpp>
#include <ql/time/calendars/jointcalendar.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/calendars/unitedkingdom.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    namespace {

        BusinessDayConvention eurliborConvention(const Period& p) {
            switch (p.units()) {
              case Days:
              case Weeks:
                return Following;
              case Months:
              case Years:
                return ModifiedFollowing;
              default:
                QL_FAIL("invalid time units");
            }
        }

        bool eurliborEOM(const Period& p) {
            switch (p.units()) {
              case Days:
              case Weeks:
                return false;
              case Months:
              case Years:
                return true;
              default:
                QL_FAIL("invalid time units");
            }
        }

    }

    EURLibor::EURLibor(const Period& tenor,
                       const Handle<YieldTermStructure>& h)
    : IborIndex("EURLibor", tenor,
                2,
                EURCurrency(),
                // http://www.bba.org.uk/bba/jsp/polopoly.jsp?d=225&a=1412 :
                // JoinBusinessDays is the fixing calendar for
                // all indexes but o/n
                JointCalendar(UnitedKingdom(UnitedKingdom::Exchange),
                              TARGET(),
                              JoinBusinessDays),
                eurliborConvention(tenor), eurliborEOM(tenor),
                Actual360(), h),
      target_(TARGET()) {
        QL_REQUIRE(this->tenor().units()!=Days,
                   "for daily tenors (" << this->tenor() <<
                   ") dedicated DailyTenor constructor must be used");
    }

    Date EURLibor::valueDate(const Date& fixingDate) const {

        QL_REQUIRE(isValidFixingDate(fixingDate),
                   "Fixing date " << fixingDate << " is not valid");

        // http://www.bba.org.uk/bba/jsp/polopoly.jsp?d=225&a=1412 :
        // In the case of EUR the Value Date shall be two TARGET
        // business days after the Fixing Date.
        return target_.advance(fixingDate, fixingDays_, Days);
    }

    Date EURLibor::maturityDate(const Date& valueDate) const {
        // http://www.bba.org.uk/bba/jsp/polopoly.jsp?d=225&a=1412 :
        // In the case of EUR only, maturity dates will be based on days in
        // which the Target system is open.
        return target_.advance(valueDate, tenor_, convention_, endOfMonth());
    }

    DailyTenorEURLibor::DailyTenorEURLibor(Natural settlementDays,
                                           const Handle<YieldTermStructure>& h)
    : IborIndex("EURLibor", 1*Days,
                settlementDays,
                EURCurrency(),
                // http://www.bba.org.uk/bba/jsp/polopoly.jsp?d=225&a=1412 :
                // no o/n or s/n fixings (as the case may be) will take place
                // when the principal centre of the currency concerned is
                // closed but London is open on the fixing day.
                TARGET(),
                eurliborConvention(1*Days), eurliborEOM(1*Days),
                Actual360(), h) {}

}
]]></document_content>
  </document>
  <document index="24">
    <source>ibor/eurlibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2006, 2007 Chiara Fornarola
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file eurlibor.hpp
    \brief %EUR %LIBOR rate
*/

#ifndef quantlib_eur_libor_hpp
#define quantlib_eur_libor_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! base class for all ICE %EUR %LIBOR indexes but the O/N
    /*! Euro LIBOR fixed by ICE.

        See <https://www.theice.com/marketdata/reports/170>.

        \warning This is the rate fixed in London by BBA. Use Euribor if
                 you're interested in the fixing by the ECB.
    */
    class EURLibor : public IborIndex {
      public:
        EURLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
        /*! \name Date calculations

            See <https://www.theice.com/marketdata/reports/170>.
            @{
        */
        Date valueDate(const Date& fixingDate) const override;
        Date maturityDate(const Date& valueDate) const override;
        // @}
      private:
        Calendar target_;
    };

    //! base class for the one day deposit ICE %EUR %LIBOR indexes
    /*! Euro O/N LIBOR fixed by ICE. It can be also used for T/N and S/N
        indexes, even if such indexes do not have ICE fixing.

        See <https://www.theice.com/marketdata/reports/170>.

        \warning This is the rate fixed in London by ICE. Use Eonia if
                 you're interested in the fixing by the ECB.
    */
    class DailyTenorEURLibor : public IborIndex {
      public:
        DailyTenorEURLibor(Natural settlementDays,
                           const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
    };

    //! Overnight %EUR %Libor index
    class EURLiborON : public DailyTenorEURLibor {
      public:
        explicit EURLiborON(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : DailyTenorEURLibor(0, h) {}
    };

    //! 1-week %EUR %Libor index
    class EURLiborSW : public EURLibor {
      public:
        explicit EURLiborSW(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : EURLibor(Period(1, Weeks), h) {}
    };

    //! 2-weeks %EUR %Libor index
    class EURLibor2W : public EURLibor {
      public:
        explicit EURLibor2W(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : EURLibor(Period(2, Weeks), h) {}
    };


    //! 1-month %EUR %Libor index
    class EURLibor1M : public EURLibor {
      public:
        explicit EURLibor1M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : EURLibor(Period(1, Months), h) {}
    };

    //! 2-months %EUR %Libor index
    class EURLibor2M : public EURLibor {
      public:
        explicit EURLibor2M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : EURLibor(Period(2, Months), h) {}
    };

    //! 3-months %EUR %Libor index
    class EURLibor3M : public EURLibor {
      public:
        explicit EURLibor3M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : EURLibor(Period(3, Months), h) {}
    };

    //! 4-months %EUR %Libor index
    class EURLibor4M : public EURLibor {
      public:
        explicit EURLibor4M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : EURLibor(Period(4, Months), h) {}
    };

    //! 5-months %EUR %Libor index
    class EURLibor5M : public EURLibor {
      public:
        explicit EURLibor5M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : EURLibor(Period(5, Months), h) {}
    };

    //! 6-months %EUR %Libor index
    class EURLibor6M : public EURLibor {
      public:
        explicit EURLibor6M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : EURLibor(Period(6, Months), h) {}
    };

    //! 7-months %EUR %Libor index
    class EURLibor7M : public EURLibor{
      public:
        explicit EURLibor7M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : EURLibor(Period(7, Months), h) {}
    };

    //! 8-months %EUR %Libor index
    class EURLibor8M : public EURLibor {
      public:
        explicit EURLibor8M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : EURLibor(Period(8, Months), h) {}
    };

    //! 9-months %EUR %Libor index
    class EURLibor9M : public EURLibor {
      public:
        explicit EURLibor9M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : EURLibor(Period(9, Months), h) {}
    };

    //! 10-months %EUR %Libor index
    class EURLibor10M : public EURLibor {
      public:
        explicit EURLibor10M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : EURLibor(Period(10, Months), h) {}
    };

    //! 11-months %EUR %Libor index
    class EURLibor11M : public EURLibor {
      public:
        explicit EURLibor11M(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : EURLibor(Period(11, Months), h) {}
    };

    //! 1-year %EUR %Libor index
    class EURLibor1Y : public EURLibor {
      public:
        explicit EURLibor1Y(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : EURLibor(Period(1, Years), h) {}
    };


}

#endif
]]></document_content>
  </document>
  <document index="25">
    <source>ibor/fedfunds.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/ibor/fedfunds.hpp>
#include <ql/time/calendars/unitedstates.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/america.hpp>

namespace QuantLib {

    FedFunds::FedFunds(const Handle<YieldTermStructure>& h)
    : OvernightIndex("FedFunds", 0,
                     USDCurrency(),
                     UnitedStates(UnitedStates::FederalReserve),
                     Actual360(), h) {}

}
]]></document_content>
  </document>
  <document index="26">
    <source>ibor/fedfunds.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fedfunds.hpp
    \brief %FedFunds index
*/

#ifndef quantlib_fed_funds_hpp
#define quantlib_fed_funds_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! %Fed Funds rate fixed by the FED.
    /*! (for balances held at the Federal Reserve) */
    class FedFunds : public OvernightIndex {
      public:
        explicit FedFunds(const Handle<YieldTermStructure>& h =
                                                Handle<YieldTermStructure>());
    };

}


#endif
]]></document_content>
  </document>
  <document index="27">
    <source>ibor/gbplibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gbplibor.hpp
    \brief %GBP %LIBOR rate
*/

#ifndef quantlib_gbp_libor_hpp
#define quantlib_gbp_libor_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/unitedkingdom.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    //! %GBP %LIBOR rate
    /*! Pound Sterling LIBOR fixed by ICE.

        See <https://www.theice.com/marketdata/reports/170>.
    */
    class GBPLibor : public Libor {
      public:
        GBPLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Libor("GBPLibor", tenor,
                0,
                GBPCurrency(),
                UnitedKingdom(UnitedKingdom::Exchange),
                Actual365Fixed(), h) {}
    };

    //! Base class for the one day deposit ICE %GBP %LIBOR indexes
    class DailyTenorGBPLibor : public DailyTenorLibor {
      public:
        DailyTenorGBPLibor(Natural settlementDays,
                           const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : DailyTenorLibor("GBPLibor", settlementDays,
                          GBPCurrency(),
                          UnitedKingdom(UnitedKingdom::Exchange),
                          Actual365Fixed(), h) {}
    };

    //! Overnight %GBP %Libor index
    class GBPLiborON : public DailyTenorGBPLibor {
      public:
        explicit GBPLiborON(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : DailyTenorGBPLibor(0, h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="28">
    <source>ibor/jibar.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005 StatPro Italia srl

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file jibar.hpp
    \brief %JIBAR rate
*/

#ifndef quantlib_jibar_hpp
#define quantlib_jibar_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/southafrica.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/africa.hpp>

namespace QuantLib {

    //! %JIBAR rate
    /*! Johannesburg Interbank Agreed Rate

        \todo check settlement days and day-count convention.
    */
    class Jibar : public IborIndex {
      public:
        Jibar(const Period& tenor,
              const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : IborIndex("Jibar", tenor, 0, ZARCurrency(),
                SouthAfrica(), ModifiedFollowing, false,
                Actual365Fixed(), h) {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="29">
    <source>ibor/jpylibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file jpylibor.hpp
    \brief %JPY %LIBOR rate
*/

#ifndef quantlib_jpy_libor_hpp
#define quantlib_jpy_libor_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/unitedkingdom.hpp>
#include <ql/time/calendars/japan.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/asia.hpp>

namespace QuantLib {

    //! %JPY %LIBOR rate
    /*! Japanese Yen LIBOR fixed by ICE.

        See <https://www.theice.com/marketdata/reports/170>.

        \warning This is the rate fixed in London by ICE. Use TIBOR if
                 you're interested in the Tokio fixing.
    */
    class JPYLibor : public Libor {
      public:
        JPYLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Libor("JPYLibor", tenor,
                2,
                JPYCurrency(),
                Japan(),
                Actual360(), h) {}
    };

    //! base class for the one day deposit ICE %JPY %LIBOR indexes
    class DailyTenorJPYLibor : public DailyTenorLibor {
      public:
        DailyTenorJPYLibor(Natural settlementDays,
                           const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : DailyTenorLibor("JPYLibor", settlementDays,
                          JPYCurrency(),
                          Japan(),
                          Actual360(), h) {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="30">
    <source>ibor/libor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Chiara Fornarola
 Copyright (C) 2005, 2006, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/jointcalendar.hpp>
#include <ql/time/calendars/unitedkingdom.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    namespace {

        BusinessDayConvention liborConvention(const Period& p) {
            switch (p.units()) {
              case Days:
              case Weeks:
                return Following;
              case Months:
              case Years:
                return ModifiedFollowing;
              default:
                QL_FAIL("invalid time units");
            }
        }

        bool liborEOM(const Period& p) {
            switch (p.units()) {
              case Days:
              case Weeks:
                return false;
              case Months:
              case Years:
                return true;
              default:
                QL_FAIL("invalid time units");
            }
        }

    }


    Libor::Libor(const std::string& familyName,
                 const Period& tenor,
                 Natural settlementDays,
                 const Currency& currency,
                 const Calendar& financialCenterCalendar,
                 const DayCounter& dayCounter,
                 const Handle<YieldTermStructure>& h)
    : IborIndex(familyName, tenor, settlementDays, currency,
                // http://www.bba.org.uk/bba/jsp/polopoly.jsp?d=225&a=1412 :
                // UnitedKingdom::Exchange is the fixing calendar for
                // a) all currencies but EUR
                // b) all indexes but o/n and s/n
                UnitedKingdom(UnitedKingdom::Exchange),
                liborConvention(tenor), liborEOM(tenor),
                dayCounter, h),
      financialCenterCalendar_(financialCenterCalendar),
      jointCalendar_(JointCalendar(UnitedKingdom(UnitedKingdom::Exchange),
                                   financialCenterCalendar,
                                   JoinHolidays)) {
        QL_REQUIRE(this->tenor().units()!=Days,
                   "for daily tenors (" << this->tenor() <<
                   ") dedicated DailyTenor constructor must be used");
        QL_REQUIRE(currency!=EURCurrency(),
                   "for EUR Libor dedicated EurLibor constructor must be used");
    }

    Date Libor::valueDate(const Date& fixingDate) const {

        QL_REQUIRE(isValidFixingDate(fixingDate),
                   "Fixing date " << fixingDate << " is not valid");

        // http://www.bba.org.uk/bba/jsp/polopoly.jsp?d=225&a=1412 :
        // For all currencies other than EUR and GBP the period between
        // Fixing Date and Value Date will be two London business days
        // after the Fixing Date, or if that day is not both a London
        // business day and a business day in the principal financial centre
        // of the currency concerned, the next following day which is a
        // business day in both centres shall be the Value Date.
        Date d = fixingCalendar().advance(fixingDate, fixingDays_, Days);
        return jointCalendar_.adjust(d);
    }

    Date Libor::maturityDate(const Date& valueDate) const {
        // Where a deposit is made on the final business day of a
        // particular calendar month, the maturity of the deposit shall
        // be on the final business day of the month in which it matures
        // (not the corresponding date in the month of maturity). Or in
        // other words, in line with market convention, BBA LIBOR rates
        // are dealt on an end-end basis. For instance a one month
        // deposit for value 28th February would mature on 31st March,
        // not the 28th of March.
        return jointCalendar_.advance(valueDate, tenor_, convention_,
                                                         endOfMonth());
    }

    Calendar Libor::jointCalendar() const {
        return jointCalendar_;
    }

    ext::shared_ptr<IborIndex> Libor::clone(
                                  const Handle<YieldTermStructure>& h) const {
        return ext::shared_ptr<IborIndex>(new Libor(familyName(),
                                                      tenor(),
                                                      fixingDays(),
                                                      currency(),
                                                      financialCenterCalendar_,
                                                      dayCounter(),
                                                      h));
    }


    DailyTenorLibor::DailyTenorLibor(
                 const std::string& familyName,
                 Natural settlementDays,
                 const Currency& currency,
                 const Calendar& financialCenterCalendar,
                 const DayCounter& dayCounter,
                 const Handle<YieldTermStructure>& h)
    : IborIndex(familyName, 1*Days, settlementDays, currency,
                // http://www.bba.org.uk/bba/jsp/polopoly.jsp?d=225&a=1412 :
                // no o/n or s/n fixings (as the case may be) will take place
                // when the principal centre of the currency concerned is
                // closed but London is open on the fixing day.
                JointCalendar(UnitedKingdom(UnitedKingdom::Exchange),
                              financialCenterCalendar,
                              JoinHolidays),
                liborConvention(1*Days), liborEOM(1*Days),
                dayCounter, h) {
        QL_REQUIRE(currency!=EURCurrency(),
                   "for EUR Libor dedicated EurLibor constructor must be used");
    }

}
]]></document_content>
  </document>
  <document index="31">
    <source>ibor/libor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Chiara Fornarola
 Copyright (C) 2005, 2006, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file libor.hpp
    \brief base class for BBA LIBOR indexes
*/

#ifndef quantlib_libor_hpp
#define quantlib_libor_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! base class for all ICE LIBOR indexes but the EUR, O/N, and S/N ones
    /*! LIBOR fixed by ICE.

        See <https://www.theice.com/marketdata/reports/170>.
    */
    class Libor : public IborIndex {
      public:
        Libor(const std::string& familyName,
              const Period& tenor,
              Natural settlementDays,
              const Currency& currency,
              const Calendar& financialCenterCalendar,
              const DayCounter& dayCounter,
              const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
        /*! \name Date calculations

            See <https://www.theice.com/marketdata/reports/170>.
            @{
        */
        Date valueDate(const Date& fixingDate) const override;
        Date maturityDate(const Date& valueDate) const override;
        // @}
        //! \name Other methods
        //@{
        ext::shared_ptr<IborIndex> clone(const Handle<YieldTermStructure>& h) const override;
        // @}
        //! \name Other inspectors
        //@{
        Calendar jointCalendar() const;
        // @}
      private:
        Calendar financialCenterCalendar_;
        Calendar jointCalendar_;
    };

    //! base class for all O/N-S/N BBA LIBOR indexes but the EUR ones
    /*! One day deposit LIBOR fixed by ICE.

        See <https://www.theice.com/marketdata/reports/170>.
    */
    class DailyTenorLibor : public IborIndex {
      public:
        DailyTenorLibor(const std::string& familyName,
                        Natural settlementDays,
                        const Currency& currency,
                        const Calendar& financialCenterCalendar,
                        const DayCounter& dayCounter,
                        const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
    };

}

#endif
]]></document_content>
  </document>
  <document index="32">
    <source>ibor/mosprime.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2018 Matthias Lungwitz

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mosprime.hpp
\brief %MOSPRIME rate
*/

#ifndef quantlib_mosprime_hpp
#define quantlib_mosprime_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/russia.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

	//! %MOSPRIME rate
	/*! Moscow Prime Offered Rate fixed by NFEA.

	Conventions are taken from
	http://www.mosprime.com/uploads/files/MosPrime%20Rate%20Rules%20since%2030.01.2014.docx

	\warning Roll convention and EoM not yet checked.
	*/
	class Mosprime : public IborIndex {
	public:
		Mosprime(const Period& tenor,
			const Handle<YieldTermStructure>& h =
			Handle<YieldTermStructure>())
			: IborIndex("MOSPRIME", tenor, (tenor == 1 * Days ? 0 : 1), RUBCurrency(),
				Russia(), ModifiedFollowing, false,
				ActualActual(ActualActual::ISDA), h) {}
	};

}


#endif
]]></document_content>
  </document>
  <document index="33">
    <source>ibor/nzdlibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file nzdlibor.hpp
    \brief %NZD %LIBOR rate
*/

#ifndef quantlib_nzd_libor_hpp
#define quantlib_nzd_libor_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/newzealand.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/oceania.hpp>

namespace QuantLib {

    //! %NZD %LIBOR rate
    /*! New Zealand Dollar LIBOR discontinued as of 2013.
    */
    class NZDLibor : public Libor {
      public:
        NZDLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Libor("NZDLibor", tenor,
                2,
                NZDCurrency(),
                NewZealand(),
                Actual360(), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="34">
    <source>ibor/nzocr.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2016 Fabrice Lecuyer

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file nzocr.hpp
\brief %NZOCR index
*/

#ifndef quantlib_nzocr_hpp
#define quantlib_nzocr_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/newzealand.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/oceania.hpp>

namespace QuantLib {

    //! %Nzocr index
    /*! %Nzocr (New Zealand official cash rate) rate fixed by the RBNZ.

        See <http://www.rbnz.govt.nz/monetary-policy/official-cash-rate-decisions>.
    */
    class Nzocr : public OvernightIndex {
      public:
        explicit Nzocr(const Handle<YieldTermStructure>& h =
                              Handle<YieldTermStructure>())
        : OvernightIndex("Nzocr", 0, NZDCurrency(),
                         NewZealand(),
                         Actual365Fixed(), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="35">
    <source>ibor/pribor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2018 Matthias Lungwitz

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file pribor.hpp
\brief %PRIBOR rate
*/

#ifndef quantlib_pribor_hpp
#define quantlib_pribor_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/czechrepublic.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

	//! %PRIBOR rate
	/*! Prague Interbank Offered Rate fixed by CFBF.

	Conventions are taken from
	OpenGamma "Interest Rate Instruments and Market Conventions
	Guide" as well as
	https://cfbf.cz/wp-content/uploads/2018/02/pribor-rules.pdf

	\warning Roll convention and EoM not yet checked.
	*/
	class Pribor : public IborIndex {
	public:
		Pribor(const Period& tenor,
			const Handle<YieldTermStructure>& h =
			Handle<YieldTermStructure>())
			: IborIndex("PRIBOR", tenor, (tenor == 1 * Days ? 0 : 2), CZKCurrency(),
				CzechRepublic(), ModifiedFollowing, false,
				Actual360(), h) {}
	};

}


#endif
]]></document_content>
  </document>
  <document index="36">
    <source>ibor/robor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2018 Matthias Lungwitz

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file robor.hpp
\brief %ROBOR rate
*/

#ifndef quantlib_robor_hpp
#define quantlib_robor_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/romania.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

	//! %ROBOR rate
	/*! Romanian Interbank Offered Rate fixed by BNR.

	Conventions are taken from
	http://www.bnr.ro/files/d/Legislatie/En/RRR.pdf

	\warning Roll convention and EoM not yet checked.
	*/
	class Robor : public IborIndex {
	public:
		Robor(const Period& tenor,
			const Handle<YieldTermStructure>& h =
			Handle<YieldTermStructure>())
			: IborIndex("ROBOR", tenor, (tenor == 1 * Days ? 0 : 2), RONCurrency(),
				Romania(), ModifiedFollowing, false,
				Actual360(), h) {}
	};

}


#endif
]]></document_content>
  </document>
  <document index="37">
    <source>ibor/seklibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file seklibor.hpp
    \brief %SEK %LIBOR rate
*/

#ifndef quantlib_sek_libor_hpp
#define quantlib_sek_libor_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/sweden.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    //! %SEK %LIBOR rate
    /*! Sweden Krone LIBOR discontinued as of 2013.
    */
    class SEKLibor : public Libor {
      public:
        SEKLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Libor("SEKLibor", tenor,
                2,
                SEKCurrency(),
                Sweden(),
                Actual360(), h) {}
    };

}

#endif
]]></document_content>
  </document>
  <document index="38">
    <source>ibor/shibor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Cheng Li

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/ibor/shibor.hpp>
#include <ql/currencies/asia.hpp>
#include <ql/time/calendars/china.hpp>
#include <ql/time/daycounters/actual360.hpp>

namespace QuantLib {

    namespace {

        BusinessDayConvention shiborConvention(const Period& p) {
            switch (p.units()) {
              case Days:
              case Weeks:
                return Following;
              case Months:
              case Years:
                return ModifiedFollowing;
              default:
                QL_FAIL("invalid time units");
            }
        }

    }

    Shibor::Shibor(const Period& tenor,
                   const Handle<YieldTermStructure>& h)
    : IborIndex("Shibor", tenor, (tenor == 1*Days? 0 : 1), CNYCurrency(),
                China(China::IB), shiborConvention(tenor), false,
                Actual360(), h) {}
    
    ext::shared_ptr<IborIndex> Shibor::clone(
                                  const Handle<YieldTermStructure>& h) const {
        return ext::shared_ptr<IborIndex>(new Shibor(tenor(), h));
    }
}
]]></document_content>
  </document>
  <document index="39">
    <source>ibor/shibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Cheng Li

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file shibor.hpp
    \brief China Shibor indexes
*/

#ifndef quantlib_shibor_hpp
#define quantlib_shibor_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    class Shibor : public IborIndex {
      public:
        Shibor(
            const Period& tenor,
            const Handle<YieldTermStructure>& h = Handle<YieldTermStructure>());

        ext::shared_ptr<IborIndex>
        clone(const Handle<YieldTermStructure>& forwarding) const override;
    };

}


#endif
]]></document_content>
  </document>
  <document index="40">
    <source>ibor/sofr.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Roy Zywina

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/ibor/sofr.hpp>
#include <ql/time/calendars/unitedstates.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/america.hpp>

namespace QuantLib {

    Sofr::Sofr(const Handle<YieldTermStructure>& h)
    : OvernightIndex("SOFR", 0, USDCurrency(),
                     UnitedStates(UnitedStates::GovernmentBond),
                     Actual360(), h) {}

}
]]></document_content>
  </document>
  <document index="41">
    <source>ibor/sofr.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Roy Zywina

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file sofr.hpp
    \brief %SOFR index
*/

#ifndef quantlib_sofr_hpp
#define quantlib_sofr_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! %Sofr (Secured Overnight Financing Rate) index.
    class Sofr : public OvernightIndex {
      public:
        explicit Sofr(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
    };

}

#endif
]]></document_content>
  </document>
  <document index="42">
    <source>ibor/sonia.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/ibor/sonia.hpp>
#include <ql/time/calendars/unitedkingdom.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    Sonia::Sonia(const Handle<YieldTermStructure>& h)
    : OvernightIndex("Sonia", 0, GBPCurrency(),
                     UnitedKingdom(UnitedKingdom::Exchange),
                     Actual365Fixed(), h) {}

}
]]></document_content>
  </document>
  <document index="43">
    <source>ibor/sonia.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file eonia.hpp
    \brief %Eonia index
*/

#ifndef quantlib_sonia_hpp
#define quantlib_sonia_hpp

#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    //! %Sonia (Sterling Overnight Index Average) rate.
    class Sonia : public OvernightIndex {
      public:
        explicit Sonia(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
    };

}

#endif
]]></document_content>
  </document>
  <document index="44">
    <source>ibor/thbfix.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Matthias Groncki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file thbfix.hpp
    \brief %THB %THBFIX rate
*/

#ifndef quantlib_thbfix_hpp
#define quantlib_thbfix_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/thailand.hpp>
#include <ql/time/calendars/unitedstates.hpp>
#include <ql/time/calendars/unitedkingdom.hpp>
#include <ql/time/calendars/jointcalendar.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/asia.hpp>

namespace QuantLib {

    //! %THB %THBFIX rate
    /*! THBFIX

    THB interest rate implied by USD/THB foreign exchange swaps

    The Swap Offer Rate represents the cost of
    borrowing a currency synthetically by borrowing USD
    for the same tenor and using the foreign exchange swap
    offer rate on the offer side to swap out the USD in return
    for the foreign currency.

    Fixing is based on average FX Forward rates from 21 banks
    and the USD Libor Fixing.

    Fixing is published at 11:00 am BKK time
    */
    class THBFIX : public IborIndex {
      public:
        THBFIX(const Period& tenor,
               const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : IborIndex("THBFIX", tenor,
                    2,
                    THBCurrency(),
                    JointCalendar(UnitedKingdom(UnitedKingdom::Exchange),
                                  JointCalendar(UnitedStates(UnitedStates::LiborImpact),
                                                Thailand())),
                    ModifiedFollowing, true,
                    Actual365Fixed(), h) {}
    };
}

#endif
]]></document_content>
  </document>
  <document index="45">
    <source>ibor/tibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file tibor.hpp
    \brief %JPY %TIBOR rate
*/

#ifndef quantlib_tibor_hpp
#define quantlib_tibor_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/japan.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/asia.hpp>

namespace QuantLib {

    //! %JPY %TIBOR index
    /*! Tokyo Interbank Offered Rate.

        \warning This is the rate fixed in Tokio by JBA. Use JPYLibor
                 if you're interested in the London fixing by BBA.

        \todo check settlement days and end-of-month adjustment.
    */
    class Tibor : public IborIndex {
      public:
        Tibor(const Period& tenor,
              const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : IborIndex("Tibor", tenor, 2, JPYCurrency(),
                    Japan(), ModifiedFollowing,
                    false, Actual365Fixed(), h) {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="46">
    <source>ibor/trlibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Sercan Atalik

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file trlibor.hpp
    \brief %TRY %LIBOR rate
*/

#ifndef quantlib_try_libor_hpp
#define quantlib_try_libor_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/turkey.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    //! %TRY %LIBOR rate
    /*! TRY LIBOR fixed by TBA.

        See <http://www.trlibor.org/trlibor/english/>

        \todo check end-of-month adjustment.
    */
    class TRLibor : public IborIndex {
      public:
        TRLibor(const Period& tenor,
                const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : IborIndex("TRLibor", tenor, 0, TRYCurrency(),
                    Turkey(), ModifiedFollowing, false,
                    Actual360(), h) {}
    };

}


#endif

]]></document_content>
  </document>
  <document index="47">
    <source>ibor/usdlibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006 StatPro Italia srl
 Copyright (C) 2017 Peter Caspers
 Copyright (C) 2017 Oleg Kulkov

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file usdlibor.hpp
    \brief %USD %LIBOR rate
*/

#ifndef quantlib_usd_libor_hpp
#define quantlib_usd_libor_hpp

#include <ql/indexes/ibor/libor.hpp>
#include <ql/time/calendars/unitedstates.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/america.hpp>

namespace QuantLib {

    //! %USD %LIBOR rate
    /*! US Dollar LIBOR fixed by ICE.

        See <https://www.theice.com/marketdata/reports/170>.
    */
    class USDLibor : public Libor {
      public:
        USDLibor(const Period& tenor,
                 const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : Libor("USDLibor", tenor,
                2,
                USDCurrency(),
                UnitedStates(UnitedStates::LiborImpact),
                Actual360(), h) {}
    };

    //! base class for the one day deposit ICE %USD %LIBOR indexes
    class DailyTenorUSDLibor : public DailyTenorLibor {
      public:
        DailyTenorUSDLibor(Natural settlementDays,
                           const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : DailyTenorLibor("USDLibor", settlementDays,
                          USDCurrency(),
                          UnitedStates(UnitedStates::LiborImpact),
                          Actual360(), h) {}
    };

    //! Overnight %USD %Libor index
    class USDLiborON : public DailyTenorUSDLibor {
      public:
        explicit USDLiborON(const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : DailyTenorUSDLibor(0, h) {}
    };
}

#endif
]]></document_content>
  </document>
  <document index="48">
    <source>ibor/wibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2018 Matthias Lungwitz

This file is part of QuantLib, a free-software/open-source library
for financial quantitative analysts and developers - http://quantlib.org/

QuantLib is free software: you can redistribute it and/or modify it
under the terms of the QuantLib license.  You should have received a
copy of the license along with this program; if not, please email
<quantlib-dev@lists.sf.net>. The license is also available online at
<http://quantlib.org/license.shtml>.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file wibor.hpp
\brief %WIBOR rate
*/

#ifndef quantlib_wibor_hpp
#define quantlib_wibor_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/poland.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

	//! %WIBOR rate
	/*! Warsaw Interbank Offered Rate fixed by ACI.

	Conventions are taken from
	http://www.acipolska.pl/images/stories/Rules_for_Fixing_WIBID_and_WIBOR_Reference_Rates_EN.pdf

	\warning Roll convention and EoM not yet checked.
	*/
	class Wibor : public IborIndex {
	public:
		Wibor(const Period& tenor,
			const Handle<YieldTermStructure>& h =
			Handle<YieldTermStructure>())
			: IborIndex("WIBOR", tenor, (tenor == 1 * Days ? 0 : 2), PLNCurrency(),
				Poland(), ModifiedFollowing, false,
				Actual365Fixed(), h) {}
	};

}


#endif
]]></document_content>
  </document>
  <document index="49">
    <source>ibor/zibor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file zibor.hpp
    \brief %CHF %ZIBOR rate
*/

#ifndef quantlib_zibor_hpp
#define quantlib_zibor_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/time/calendars/switzerland.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    //! %CHF %ZIBOR rate
    /*! Zurich Interbank Offered Rate.

        \warning This is the rate fixed in Zurich by BBA. Use CHFLibor if
                 you're interested in the London fixing by BBA.

        \todo check settlement days, end-of-month adjustment,
              and day-count convention.
    */
    class Zibor : public IborIndex {
      public:
        Zibor(const Period& tenor,
              const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>())
        : IborIndex("Zibor", tenor, 2, CHFCurrency(),
                Switzerland(), ModifiedFollowing, false,
                Actual360(), h) {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="50">
    <source>iborindex.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 StatPro Italia srl
 Copyright (C) 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/iborindex.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    IborIndex::IborIndex(const std::string& familyName,
                         const Period& tenor,
                         Natural settlementDays,
                         const Currency& currency,
                         const Calendar& fixingCalendar,
                         BusinessDayConvention convention,
                         bool endOfMonth,
                         const DayCounter& dayCounter,
                         Handle<YieldTermStructure> h)
    : InterestRateIndex(familyName, tenor, settlementDays, currency, fixingCalendar, dayCounter),
      convention_(convention), termStructure_(std::move(h)), endOfMonth_(endOfMonth) {
        registerWith(termStructure_);
    }

    Rate IborIndex::forecastFixing(const Date& fixingDate) const {
        Date d1 = valueDate(fixingDate);
        Date d2 = maturityDate(d1);
        Time t = dayCounter_.yearFraction(d1, d2);
        QL_REQUIRE(t>0.0,
                   "\n cannot calculate forward rate between " <<
                   d1 << " and " << d2 <<
                   ":\n non positive time (" << t <<
                   ") using " << dayCounter_.name() << " daycounter");
        return forecastFixing(d1, d2, t);
    }

    Date IborIndex::maturityDate(const Date& valueDate) const {
        return fixingCalendar().advance(valueDate,
                                        tenor_,
                                        convention_,
                                        endOfMonth_);
    }

    ext::shared_ptr<IborIndex> IborIndex::clone(
                               const Handle<YieldTermStructure>& h) const {
        return ext::make_shared<IborIndex>(
                                        familyName(),
                                                      tenor(),
                                                      fixingDays(),
                                                      currency(),
                                                      fixingCalendar(),
                                                      businessDayConvention(),
                                                      endOfMonth(),
                                                      dayCounter(),
                                                      h);
    }


    OvernightIndex::OvernightIndex(const std::string& familyName,
                                   Natural settlementDays,
                                   const Currency& curr,
                                   const Calendar& fixCal,
                                   const DayCounter& dc,
                                   const Handle<YieldTermStructure>& h)
   : IborIndex(familyName, 1*Days, settlementDays, curr,
               fixCal, Following, false, dc, h) {}

    ext::shared_ptr<IborIndex> OvernightIndex::clone(
                               const Handle<YieldTermStructure>& h) const {
        return ext::shared_ptr<IborIndex>(
                                        new OvernightIndex(familyName(),
                                                           fixingDays(),
                                                           currency(),
                                                           fixingCalendar(),
                                                           dayCounter(),
                                                           h));
    }

}
]]></document_content>
  </document>
  <document index="51">
    <source>iborindex.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009 StatPro Italia srl
 Copyright (C) 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file iborindex.hpp
    \brief base class for Inter-Bank-Offered-Rate indexes
*/

#ifndef quantlib_ibor_index_hpp
#define quantlib_ibor_index_hpp

#include <ql/indexes/interestrateindex.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>

namespace QuantLib {

    //! base class for Inter-Bank-Offered-Rate indexes (e.g. %Libor, etc.)
    class IborIndex : public InterestRateIndex {
      public:
        IborIndex(const std::string& familyName,
                  const Period& tenor,
                  Natural settlementDays,
                  const Currency& currency,
                  const Calendar& fixingCalendar,
                  BusinessDayConvention convention,
                  bool endOfMonth,
                  const DayCounter& dayCounter,
                  Handle<YieldTermStructure> h = Handle<YieldTermStructure>());
        //! \name InterestRateIndex interface
        //@{
        Date maturityDate(const Date& valueDate) const override;
        Rate forecastFixing(const Date& fixingDate) const override;
        // @}
        //! \name Inspectors
        //@{
        BusinessDayConvention businessDayConvention() const;
        bool endOfMonth() const { return endOfMonth_; }
        //! the curve used to forecast fixings
        Handle<YieldTermStructure> forwardingTermStructure() const;
        //@}
        //! \name Other methods
        //@{
        //! returns a copy of itself linked to a different forwarding curve
        virtual ext::shared_ptr<IborIndex> clone(
                        const Handle<YieldTermStructure>& forwarding) const;
        // @}
      protected:
        BusinessDayConvention convention_;
        Handle<YieldTermStructure> termStructure_;
        bool endOfMonth_;
      private:
        // overload to avoid date/time (re)calculation
        /* This can be called with cached coupon dates (and it does
           give quite a performance boost to coupon calculations) but
           is potentially misleading: by passing the wrong dates, one
           can ask a 6-months index for a 1-year fixing.

           For that reason, we're leaving this method private and
           we're declaring the IborCoupon class (which uses it) as a
           friend.  Should the need arise, we might promote it to
           public, but before doing that I'd think hard whether we
           have any other way to get the same results.
        */
        Rate forecastFixing(const Date& valueDate,
                            const Date& endDate,
                            Time t) const;
        friend class IborCoupon;
    };


    class OvernightIndex : public IborIndex {
      public:
        OvernightIndex(const std::string& familyName,
                       Natural settlementDays,
                       const Currency& currency,
                       const Calendar& fixingCalendar,
                       const DayCounter& dayCounter,
                       const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
        //! returns a copy of itself linked to a different forwarding curve
        ext::shared_ptr<IborIndex> clone(const Handle<YieldTermStructure>& h) const override;
    };


    // inline

    inline BusinessDayConvention IborIndex::businessDayConvention() const {
        return convention_;
    }

    inline Handle<YieldTermStructure>
    IborIndex::forwardingTermStructure() const {
        return termStructure_;
    }

    inline Rate IborIndex::forecastFixing(const Date& d1,
                                          const Date& d2,
                                          Time t) const {
        QL_REQUIRE(!termStructure_.empty(),
                   "null term structure set to this instance of " << name());
        DiscountFactor disc1 = termStructure_->discount(d1);
        DiscountFactor disc2 = termStructure_->discount(d2);
        return (disc1/disc2 - 1.0) / t;
    }

}

#endif
]]></document_content>
  </document>
  <document index="52">
    <source>indexmanager.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/indexmanager.hpp>
#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#    pragma GCC diagnostic push
#    pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#endif
#include <boost/algorithm/string/case_conv.hpp>
#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#    pragma GCC diagnostic pop
#endif

using boost::algorithm::to_upper_copy;
using std::string;

namespace QuantLib {

    bool IndexManager::hasHistory(const string& name) const {
        return data_.find(to_upper_copy(name)) != data_.end();
    }

    const TimeSeries<Real>& IndexManager::getHistory(const string& name) const {
        return data_[to_upper_copy(name)].value();
    }

    void IndexManager::setHistory(const string& name, const TimeSeries<Real>& history) {
        data_[to_upper_copy(name)] = history;
    }

    ext::shared_ptr<Observable> IndexManager::notifier(const string& name) const {
        return data_[to_upper_copy(name)];
    }

    std::vector<string> IndexManager::histories() const {
        std::vector<string> temp;
        temp.reserve(data_.size());
        for (history_map::const_iterator i = data_.begin(); i != data_.end(); ++i)
            temp.push_back(i->first);
        return temp;
    }

    void IndexManager::clearHistory(const string& name) { data_.erase(to_upper_copy(name)); }

    void IndexManager::clearHistories() { data_.clear(); }

    bool IndexManager::hasHistoricalFixing(const std::string& name, const Date& fixingDate) const {
        auto const& indexIter = data_.find(to_upper_copy(name));
        return (indexIter != data_.end()) &&
               ((*indexIter).second.value()[fixingDate] != Null<Real>());
    }

}
]]></document_content>
  </document>
  <document index="53">
    <source>indexmanager.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file indexmanager.hpp
    \brief global repository for past index fixings
*/

#ifndef quantlib_index_manager_hpp
#define quantlib_index_manager_hpp

#include <ql/patterns/singleton.hpp>
#include <ql/timeseries.hpp>
#include <ql/utilities/observablevalue.hpp>


namespace QuantLib {

    //! global repository for past index fixings
    /*! \note index names are case insensitive */
    class IndexManager : public Singleton<IndexManager> {
        friend class Singleton<IndexManager>;

      private:
        IndexManager() = default;

      public:
        //! returns whether historical fixings were stored for the index
        bool hasHistory(const std::string& name) const;
        //! returns the (possibly empty) history of the index fixings
        const TimeSeries<Real>& getHistory(const std::string& name) const;
        //! stores the historical fixings of the index
        void setHistory(const std::string& name, const TimeSeries<Real>&);
        //! observer notifying of changes in the index fixings
        ext::shared_ptr<Observable> notifier(const std::string& name) const;
        //! returns all names of the indexes for which fixings were stored
        std::vector<std::string> histories() const;
        //! clears the historical fixings of the index
        void clearHistory(const std::string& name);
        //! clears all stored fixings
        void clearHistories();
        //! returns whether a specific historical fixing was stored for the index and date
        bool hasHistoricalFixing(const std::string& name, const Date& fixingDate) const;

      private:
        typedef std::map<std::string, ObservableValue<TimeSeries<Real> > > history_map;
        mutable history_map data_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="54">
    <source>inflation/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    aucpi.hpp \
    euhicp.hpp \
    frhicp.hpp \
    ukrpi.hpp \
    uscpi.hpp \
    zacpi.hpp

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="55">
    <source>inflation/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/indexes/inflation/aucpi.hpp>
#include <ql/indexes/inflation/euhicp.hpp>
#include <ql/indexes/inflation/frhicp.hpp>
#include <ql/indexes/inflation/ukrpi.hpp>
#include <ql/indexes/inflation/uscpi.hpp>
#include <ql/indexes/inflation/zacpi.hpp>

]]></document_content>
  </document>
  <document index="56">
    <source>inflation/aucpi.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file aucpi.hpp
    \brief Australian CPI inflation indexes
*/

#ifndef quantlib_aucpi_hpp
#define quantlib_aucpi_hpp

#include <ql/indexes/inflationindex.hpp>
#include <ql/currencies/oceania.hpp>

namespace QuantLib {

    //! AU CPI index (either quarterly or annual)
    class AUCPI : public ZeroInflationIndex {
      public:
        AUCPI(Frequency frequency,
              bool revised,
              bool interpolated,
              const Handle<ZeroInflationTermStructure>& ts =
                                         Handle<ZeroInflationTermStructure>())
        : ZeroInflationIndex("CPI",
                             AustraliaRegion(),
                             revised,
                             interpolated,
                             frequency,
                             Period(2, Months),
                             AUDCurrency(),
                             ts) {}
    };


    //! Genuine year-on-year AU CPI (i.e. not a ratio)
    class YYAUCPI : public YoYInflationIndex {
      public:
        YYAUCPI(Frequency frequency,
                bool revised,
                bool interpolated,
                const Handle<YoYInflationTermStructure>& ts =
                                          Handle<YoYInflationTermStructure>())
        : YoYInflationIndex("YY_CPI",
                            AustraliaRegion(),
                            revised,
                            interpolated,
                            false,
                            frequency,
                            Period(2, Months),
                            AUDCurrency(),
                            ts) {}
    };

    //! Fake year-on-year AUCPI (i.e. a ratio)
    class YYAUCPIr : public YoYInflationIndex {
      public:
        YYAUCPIr(Frequency frequency,
                 bool revised,
                 bool interpolated,
                 const Handle<YoYInflationTermStructure>& ts =
                                          Handle<YoYInflationTermStructure>())
        : YoYInflationIndex("YYR_CPI",
                            AustraliaRegion(),
                            revised,
                            interpolated,
                            true,
                            frequency,
                            Period(2, Months),
                            AUDCurrency(),
                            ts) {}
    };

}

#endif

]]></document_content>
  </document>
  <document index="57">
    <source>inflation/euhicp.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 Chris Kenyon
 Copyright (C) 2010 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file euhicp.hpp
    \brief EU HICP index
*/

#ifndef quantlib_euhicp_hpp
#define quantlib_euhicp_hpp

#include <ql/indexes/inflationindex.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    //! EU HICP index
    class EUHICP : public ZeroInflationIndex {
      public:
        EUHICP(bool interpolated,
               const Handle<ZeroInflationTermStructure>& ts =
                                        Handle<ZeroInflationTermStructure>())
        : ZeroInflationIndex("HICP",
                             EURegion(),
                             false,
                             interpolated,
                             Monthly,
                             Period(1, Months), // availability
                             EURCurrency(),
                             ts) {}
    };

    //! EU HICPXT index
    class EUHICPXT : public ZeroInflationIndex {
      public:
        EUHICPXT(bool interpolated,
                 const Handle<ZeroInflationTermStructure>& ts =
                                        Handle<ZeroInflationTermStructure>())
        : ZeroInflationIndex("HICPXT",
                             EURegion(),
                             false,
                             interpolated,
                             Monthly,
                             Period(1, Months), // availability
                             EURCurrency(),
                             ts) {}
    };


    //! Genuine year-on-year EU HICP (i.e. not a ratio of EU HICP)
    class YYEUHICP : public YoYInflationIndex {
      public:
        YYEUHICP(bool interpolated,
                 const Handle<YoYInflationTermStructure>& ts =
                                         Handle<YoYInflationTermStructure>())
        : YoYInflationIndex("YY_HICP",
                            EURegion(),
                            false,
                            interpolated,
                            false,
                            Monthly,
                            Period(1, Months),
                            EURCurrency(),
                            ts) {}
    };

    //! Genuine year-on-year EU HICPXT
    class YYEUHICPXT : public YoYInflationIndex {
      public:
        YYEUHICPXT(bool interpolated,
                   const Handle<YoYInflationTermStructure>& ts =
                                         Handle<YoYInflationTermStructure>())
        : YoYInflationIndex("YY_HICPXT",
                            EURegion(),
                            false,
                            interpolated,
                            false,
                            Monthly,
                            Period(1, Months),
                            EURCurrency(),
                            ts) {}
    };


    //! Fake year-on-year EU HICP (i.e. a ratio of EU HICP)
    class YYEUHICPr : public YoYInflationIndex {
      public:
        YYEUHICPr(bool interpolated,
                  const Handle<YoYInflationTermStructure>& ts =
                                         Handle<YoYInflationTermStructure>())
        : YoYInflationIndex("YYR_HICP",
                            EURegion(),
                            false,
                            interpolated,
                            true,
                            Monthly,
                            Period(1, Months),
                            EURCurrency(),
                            ts) {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="58">
    <source>inflation/frhicp.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file frhicp.hpp
    \brief French HICP inflation indexes
*/

#ifndef quantlib_frhicp_hpp
#define quantlib_frhicp_hpp

#include <ql/indexes/inflationindex.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    //! FR HICP index
    class FRHICP : public ZeroInflationIndex {
      public:
        FRHICP(bool interpolated,
               const Handle<ZeroInflationTermStructure>& ts =
                                         Handle<ZeroInflationTermStructure>())
        : ZeroInflationIndex("HICP",
                             FranceRegion(),
                             false,
                             interpolated,
                             Monthly,
                             Period(1, Months),
                             EURCurrency(),
                             ts) {}
    };


    //! Genuine year-on-year FR HICP (i.e. not a ratio)
    class YYFRHICP : public YoYInflationIndex {
      public:
        YYFRHICP(bool interpolated,
                 const Handle<YoYInflationTermStructure>& ts =
                                          Handle<YoYInflationTermStructure>())
        : YoYInflationIndex("YY_HICP",
                            FranceRegion(),
                            false,
                            interpolated,
                            false,
                            Monthly,
                            Period(1, Months),
                            EURCurrency(),
                            ts) {}
    };


    //! Fake year-on-year FR HICP (i.e. a ratio)
    class YYFRHICPr : public YoYInflationIndex {
      public:
        YYFRHICPr(bool interpolated,
                  const Handle<YoYInflationTermStructure>& ts =
                                          Handle<YoYInflationTermStructure>())
        : YoYInflationIndex("YYR_HICP",
                            FranceRegion(),
                            false,
                            interpolated,
                            true,
                            Monthly,
                            Period(1, Months),
                            EURCurrency(),
                            ts) {}
    };

}

#endif

]]></document_content>
  </document>
  <document index="59">
    <source>inflation/ukrpi.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file ukrpi.hpp
    \brief %UKRPI index
*/

#ifndef quantlib_ukrpi_hpp
#define quantlib_ukrpi_hpp

#include <ql/indexes/inflationindex.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    //! UK Retail Price Inflation Index
    class UKRPI : public ZeroInflationIndex {
      public:
        UKRPI(bool interpolated,
              const Handle<ZeroInflationTermStructure>& ts =
                    Handle<ZeroInflationTermStructure>())
        : ZeroInflationIndex("RPI",
                             UKRegion(),
                             false,
                             interpolated,
                             Monthly,
                             Period(1, Months),
                             GBPCurrency(),
                             ts) {}
    };


    //! Genuine year-on-year UK RPI (i.e. not a ratio of UK RPI)
    class YYUKRPI : public YoYInflationIndex {
      public:
        YYUKRPI(bool interpolated,
                const Handle<YoYInflationTermStructure>& ts =
                        Handle<YoYInflationTermStructure>())
        : YoYInflationIndex("YY_RPI",
                            UKRegion(),
                            false,
                            interpolated,
                            false,
                            Monthly,
                            Period(1, Months),
                            GBPCurrency(),
                            ts) {}
    };


    //! Fake year-on-year UK RPI (i.e. a ratio of UK RPI)
    class YYUKRPIr : public YoYInflationIndex {
      public:
        YYUKRPIr(bool interpolated,
                 const Handle<YoYInflationTermStructure>& ts =
                        Handle<YoYInflationTermStructure>())
        : YoYInflationIndex("YYR_RPI",
                            UKRegion(),
                            false,
                            interpolated,
                            true,
                            Monthly,
                            Period(1, Months),
                            GBPCurrency(),
                            ts) {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="60">
    <source>inflation/uscpi.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

/*! \file uscpi.hpp
 \brief US CPI index
 */

#ifndef quantlib_uscpi_hpp
#define quantlib_uscpi_hpp

#include <ql/indexes/inflationindex.hpp>
#include <ql/currencies/america.hpp>

namespace QuantLib {

    //! US CPI index
    class USCPI : public ZeroInflationIndex {
    public:
        USCPI(bool interpolated,
               const Handle<ZeroInflationTermStructure>& ts =
                                         Handle<ZeroInflationTermStructure>())
        : ZeroInflationIndex("CPI",
                             USRegion(),
                             false,
                             interpolated,
                             Monthly,
                             Period(1, Months), // availability
                             USDCurrency(),
                             ts) {}
    };


    //! Genuine year-on-year US CPI (i.e. not a ratio of US CPI)
    class YYUSCPI : public YoYInflationIndex {
    public:
        YYUSCPI(bool interpolated,
                 const Handle<YoYInflationTermStructure>& ts =
                                          Handle<YoYInflationTermStructure>())
        : YoYInflationIndex("YY_CPI",
                            USRegion(),
                            false,
                            interpolated,
                            false,
                            Monthly,
                            Period(1, Months),
                            USDCurrency(),
                            ts) {}
    };


    //! Fake year-on-year US CPI (i.e. a ratio of US CPI)
    class YYUSCPIr : public YoYInflationIndex {
    public:
        YYUSCPIr(bool interpolated,
                  const Handle<YoYInflationTermStructure>& ts =
                                          Handle<YoYInflationTermStructure>())
        : YoYInflationIndex("YYR_CPI",
                            USRegion(),
                            false,
                            interpolated,
                            true,
                            Monthly,
                            Period(1, Months),
                            USDCurrency(),
                            ts) {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="61">
    <source>inflation/zacpi.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file zacpi.hpp
    \brief %ZACPI index
*/

#ifndef quantlib_zacpi_hpp
#define quantlib_zacpi_hpp

#include <ql/indexes/inflationindex.hpp>
#include <ql/currencies/africa.hpp>

namespace QuantLib {

    //! South African Comsumer Price Inflation Index
    class ZACPI : public ZeroInflationIndex {
      public:
        ZACPI(bool interpolated,
              const Handle<ZeroInflationTermStructure>& ts =
                    Handle<ZeroInflationTermStructure>())
        : ZeroInflationIndex("CPI",
                             ZARegion(),
                             false,
                             interpolated,
                             Monthly,
                             Period(1, Months),
                             ZARCurrency(),
                             ts) {}
    };


    //! Genuine year-on-year South African CPI (i.e. not a ratio of ZA CPI)
    class YYZACPI : public YoYInflationIndex {
      public:
        YYZACPI(bool interpolated,
                const Handle<YoYInflationTermStructure>& ts =
                        Handle<YoYInflationTermStructure>())
        : YoYInflationIndex("YY_CPI",
                            ZARegion(),
                            false,
                            interpolated,
                            false,
                            Monthly,
                            Period(1, Months),
                            ZARCurrency(),
                            ts) {}
    };


    //! Fake year-on-year South African CPI (i.e. a ratio of ZA CPI)
    class YYZACPIr : public YoYInflationIndex {
      public:
        YYZACPIr(bool interpolated,
                 const Handle<YoYInflationTermStructure>& ts =
                        Handle<YoYInflationTermStructure>())
        : YoYInflationIndex("YYR_CPI",
                            ZARegion(),
                            false,
                            interpolated,
                            true,
                            Monthly,
                            Period(1, Months),
                            ZARCurrency(),
                            ts) {}
    };

}


#endif
]]></document_content>
  </document>
  <document index="62">
    <source>inflationindex.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Chris Kenyon
 Copyright (C) 2021 Ralf Konrad Eckel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/inflationindex.hpp>
#include <ql/termstructures/inflationtermstructure.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <utility>

namespace QuantLib {

    InflationIndex::InflationIndex(std::string familyName,
                                   Region region,
                                   bool revised,
                                   bool interpolated,
                                   Frequency frequency,
                                   const Period& availabilityLag,
                                   Currency currency)
    : familyName_(std::move(familyName)), region_(std::move(region)), revised_(revised),
      interpolated_(interpolated), frequency_(frequency), availabilityLag_(availabilityLag),
      currency_(std::move(currency)) {
        name_ = region_.name() + " " + familyName_;
        registerWith(Settings::instance().evaluationDate());
        registerWith(IndexManager::instance().notifier(name()));
    }


    Calendar InflationIndex::fixingCalendar() const {
        static NullCalendar c;
        return c;
    }

    void InflationIndex::addFixing(const Date& fixingDate,
                                   Real fixing,
                                   bool forceOverwrite) {

        std::pair<Date,Date> lim = inflationPeriod(fixingDate, frequency_);
        Size n = static_cast<QuantLib::Size>(lim.second - lim.first) + 1;
        std::vector<Date> dates(n);
        std::vector<Rate> rates(n);
        for (Size i=0; i<n; ++i) {
            dates[i] = lim.first + i;
            rates[i] = fixing;
        }

        Index::addFixings(dates.begin(), dates.end(),
                          rates.begin(), forceOverwrite);
    }

    ZeroInflationIndex::ZeroInflationIndex(const std::string& familyName,
                                           const Region& region,
                                           bool revised,
                                           bool interpolated,
                                           Frequency frequency,
                                           const Period& availabilityLag,
                                           const Currency& currency,
                                           Handle<ZeroInflationTermStructure> zeroInflation)
    : InflationIndex(
          familyName, region, revised, interpolated, frequency, availabilityLag, currency),
      zeroInflation_(std::move(zeroInflation)) {
        registerWith(zeroInflation_);
    }

    Rate ZeroInflationIndex::fixing(const Date& aFixingDate,
                                    bool /*forecastTodaysFixing*/) const {
        if (!needsForecast(aFixingDate)) {
            std::pair<Date,Date> lim = inflationPeriod(aFixingDate, frequency_);
            const TimeSeries<Real>& ts = timeSeries();
            Real pastFixing = ts[lim.first];
            QL_REQUIRE(pastFixing != Null<Real>(),
                       "Missing " << name() << " fixing for " << lim.first);
            Real theFixing = pastFixing;
            if (interpolated_) {
                // fixings stored on first day of every period
                if (aFixingDate == lim.first) {
                    // we don't actually need the next fixing
                    theFixing = pastFixing;
                } else {
                    Real pastFixing2 = ts[lim.second+1];
                    QL_REQUIRE(pastFixing2 != Null<Real>(),
                               "Missing " << name() << " fixing for " << lim.second+1);

                    // Use lagged period for interpolation
                    std::pair<Date, Date> reference_period_lim = inflationPeriod(aFixingDate + zeroInflationTermStructure()->observationLag(), frequency_);
                    // now linearly interpolate
                    Real daysInPeriod = reference_period_lim.second + 1 - reference_period_lim.first;
                    theFixing = pastFixing
                        + (pastFixing2 - pastFixing)*(aFixingDate - lim.first) / daysInPeriod;
                }
            }
            return theFixing;
        } else {
            return forecastFixing(aFixingDate);
        }
    }


    bool ZeroInflationIndex::needsForecast(const Date& fixingDate) const {

        // Stored fixings are always non-interpolated.
        // If an interpolated fixing is required then
        // the availability lag + one inflation period
        // must have passed to use historical fixings
        // (because you need the next one to interpolate).
        // The interpolation is calculated (linearly) on demand.

        Date today = Settings::instance().evaluationDate();
        Date todayMinusLag = today - availabilityLag_;

        Date historicalFixingKnown =
            inflationPeriod(todayMinusLag, frequency_).first-1;
        Date latestNeededDate = fixingDate;

        if (interpolated_) { // might need the next one too
            std::pair<Date,Date> p = inflationPeriod(fixingDate, frequency_);
            if (fixingDate > p.first)
                latestNeededDate += Period(frequency_);
        }

        if (latestNeededDate <= historicalFixingKnown) {
            // the fixing date is well before the availability lag, so
            // we know that fixings were provided.
            return false;
        } else if (latestNeededDate > today) {
            // the fixing can't be available, no matter what's in the
            // time series
            return true;
        } else {
            // we're not sure, but the fixing might be there so we
            // check.  Todo: check which fixings are not possible, to
            // avoid using fixings in the future
            Real f = timeSeries()[latestNeededDate];
            return (f == Null<Real>());
        }
    }


    Rate ZeroInflationIndex::forecastFixing(const Date& fixingDate) const {
        // the term structure is relative to the fixing value at the base date.
        Date baseDate = zeroInflation_->baseDate();
        QL_REQUIRE(!needsForecast(baseDate),
                   name() << " index fixing at base date " << baseDate << " is not available");
        Real baseFixing = fixing(baseDate);
        Date effectiveFixingDate;
        if (interpolated()) {
            effectiveFixingDate = fixingDate;
        } else {
            // start of period is the convention
            // so it's easier to do linear interpolation on fixings
            effectiveFixingDate = inflationPeriod(fixingDate, frequency()).first;
        }

        // no observation lag because it is the fixing for the date
        // but if index is not interpolated then that fixing is constant
        // for each period, hence the t uses the effectiveFixingDate
        // However, it's slightly safe to get the zeroRate with the
        // fixingDate to avoid potential problems at the edges of periods
        Time t = zeroInflation_->dayCounter().yearFraction(baseDate, effectiveFixingDate);
        bool forceLinearInterpolation = false;
        Rate zero = zeroInflation_->zeroRate(fixingDate, Period(0,Days), forceLinearInterpolation);
        // Annual compounding is the convention for zero inflation rates (or quotes)
        return baseFixing * std::pow(1.0 + zero, t);
    }


    ext::shared_ptr<ZeroInflationIndex> ZeroInflationIndex::clone(
                          const Handle<ZeroInflationTermStructure>& h) const {
        return ext::make_shared<ZeroInflationIndex>(
                      familyName_, region_, revised_,
                                             interpolated_, frequency_,
                                             availabilityLag_, currency_, h);
    }

    // these still need to be fixed to latest versions

    YoYInflationIndex::YoYInflationIndex(const std::string& familyName,
                                         const Region& region,
                                         bool revised,
                                         bool interpolated,
                                         bool ratio,
                                         Frequency frequency,
                                         const Period& availabilityLag,
                                         const Currency& currency,
                                         Handle<YoYInflationTermStructure> yoyInflation)
    : InflationIndex(
          familyName, region, revised, interpolated, frequency, availabilityLag, currency),
      ratio_(ratio), yoyInflation_(std::move(yoyInflation)) {
        registerWith(yoyInflation_);
    }


    Rate YoYInflationIndex::fixing(const Date& fixingDate,
                                   bool /*forecastTodaysFixing*/) const {

        Date today = Settings::instance().evaluationDate();
        Date todayMinusLag = today - availabilityLag_;
        std::pair<Date,Date> lim = inflationPeriod(todayMinusLag, frequency_);
        Date lastFix = lim.first-1;

        Date flatMustForecastOn = lastFix+1;
        Date interpMustForecastOn = lastFix+1 - Period(frequency_);


        if (interpolated() && fixingDate >= interpMustForecastOn) {
            return forecastFixing(fixingDate);
        }

        if (!interpolated() && fixingDate >= flatMustForecastOn) {
            return forecastFixing(fixingDate);
        }

        // four cases with ratio() and interpolated()

        const TimeSeries<Real>& ts = timeSeries();
        if (ratio()) {

            if(interpolated()){ // IS ratio, IS interpolated

                std::pair<Date,Date> lim = inflationPeriod(fixingDate, frequency_);
                Date fixMinus1Y=NullCalendar().advance(fixingDate, -1*Years, ModifiedFollowing);
                std::pair<Date,Date> limBef = inflationPeriod(fixMinus1Y, frequency_);
                Real dp= lim.second + 1 - lim.first;
                Real dpBef=limBef.second + 1 - limBef.first;
                Real dl = fixingDate-lim.first;
                // potentially does not work on 29th Feb
                Real dlBef = fixMinus1Y - limBef.first;
                // get the four relevant fixings
                // recall that they are stored flat for every day
                Rate limFirstFix = ts[lim.first];
                QL_REQUIRE(limFirstFix != Null<Rate>(),
                            "Missing " << name() << " fixing for "
                            << lim.first );
                Rate limSecondFix = ts[lim.second+1];
                QL_REQUIRE(limSecondFix != Null<Rate>(),
                            "Missing " << name() << " fixing for "
                            << lim.second+1 );
                Rate limBefFirstFix = ts[limBef.first];
                QL_REQUIRE(limBefFirstFix != Null<Rate>(),
                            "Missing " << name() << " fixing for "
                            << limBef.first );
                Rate limBefSecondFix =
                IndexManager::instance().getHistory(name())[limBef.second+1];
                QL_REQUIRE(limBefSecondFix != Null<Rate>(),
                            "Missing " << name() << " fixing for "
                            << limBef.second+1 );

                Real linearNow = limFirstFix + (limSecondFix-limFirstFix)*dl/dp;
                Real linearBef = limBefFirstFix + (limBefSecondFix-limBefFirstFix)*dlBef/dpBef;
                Rate wasYES = linearNow / linearBef - 1.0;

                return wasYES;

            } else {    // IS ratio, NOT interpolated
                Rate pastFixing = ts[fixingDate];
                QL_REQUIRE(pastFixing != Null<Rate>(),
                            "Missing " << name() << " fixing for "
                            << fixingDate);
                Date previousDate = fixingDate - 1*Years;
                Rate previousFixing = ts[previousDate];
                QL_REQUIRE(previousFixing != Null<Rate>(),
                           "Missing " << name() << " fixing for "
                           << previousDate );

                return pastFixing/previousFixing - 1.0;
            }

        } else {  // NOT ratio

            if (interpolated()) { // NOT ratio, IS interpolated

                std::pair<Date,Date> lim = inflationPeriod(fixingDate, frequency_);
                Real dp= lim.second + 1 - lim.first;
                Real dl = fixingDate-lim.first;
                Rate limFirstFix = ts[lim.first];
                QL_REQUIRE(limFirstFix != Null<Rate>(),
                            "Missing " << name() << " fixing for "
                            << lim.first );
                Rate limSecondFix = ts[lim.second+1];
                QL_REQUIRE(limSecondFix != Null<Rate>(),
                            "Missing " << name() << " fixing for "
                            << lim.second+1 );
                Real linearNow = limFirstFix + (limSecondFix-limFirstFix)*dl/dp;

                return linearNow;

            } else { // NOT ratio, NOT interpolated
                    // so just flat

                Rate pastFixing = ts[fixingDate];
                QL_REQUIRE(pastFixing != Null<Rate>(),
                           "Missing " << name() << " fixing for "
                           << fixingDate);
                return pastFixing;

            }
        }

        // QL_FAIL("YoYInflationIndex::fixing, should never get here");

    }


    Real YoYInflationIndex::forecastFixing(const Date& fixingDate) const {

        Date d;
        if (interpolated()) {
            d = fixingDate;
        } else {
            // if the value is not interpolated use the starting value
            // by internal convention this will be consistent
            std::pair<Date,Date> lim = inflationPeriod(fixingDate, frequency_);
            d = lim.first;
        }
        return yoyInflation_->yoyRate(d,0*Days);
    }

    ext::shared_ptr<YoYInflationIndex> YoYInflationIndex::clone(
                           const Handle<YoYInflationTermStructure>& h) const {
        return ext::make_shared<YoYInflationIndex>(
                      familyName_, region_, revised_,
                                            interpolated_, ratio_, frequency_,
                                            availabilityLag_, currency_, h);
    }


    CPI::InterpolationType
    detail::CPI::effectiveInterpolationType(const ext::shared_ptr<ZeroInflationIndex>& index,
                                            const QuantLib::CPI::InterpolationType& type) {
        if (type == QuantLib::CPI::AsIndex) {
            return index->interpolated() ? QuantLib::CPI::Linear : QuantLib::CPI::Flat;
        } else {
            return type;
        }
    }
}
]]></document_content>
  </document>
  <document index="63">
    <source>inflationindex.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Chris Kenyon
 Copyright (C) 2021 Ralf Konrad Eckel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file inflationindex.hpp
    \brief base classes for inflation indexes
*/

#ifndef quantlib_inflation_index_hpp
#define quantlib_inflation_index_hpp

#include <ql/index.hpp>
#include <ql/indexes/region.hpp>
#include <ql/termstructures/inflationtermstructure.hpp>
#include <ql/currency.hpp>
#include <ql/handle.hpp>

namespace QuantLib {

    class ZeroInflationTermStructure;
    class YoYInflationTermStructure;

    struct CPI {
        //! when you observe an index, how do you interpolate between fixings?
        enum InterpolationType {
            AsIndex, //!< same interpolation as index
            Flat,    //!< flat from previous fixing
            Linear   //!< linearly between bracketing fixings
        };
    };


    //! Base class for inflation-rate indexes,
    class InflationIndex : public Index, public Observer {
      public:
        /*! An inflation index may return interpolated
         values.  These are linearly interpolated
         values with act/act convention within a period.
         Note that stored "fixings" are always flat (constant)
         within a period and interpolated as needed.  This
         is because interpolation adds an addional availability
         lag (because you always need the next period to
         give the previous period's value)
         and enables storage of the most recent uninterpolated value.
         */
        InflationIndex(std::string familyName,
                       Region region,
                       bool revised,
                       bool interpolated,
                       Frequency frequency,
                       const Period& availabilitiyLag,
                       Currency currency);
        //! \name Index interface
        //@{
        std::string name() const override;

        /*! Inflation indices do not have fixing calendars.  An
            inflation index value is valid for every day (including
            weekends) of a calendar period.  I.e. it uses the
            NullCalendar as its fixing calendar.
        */
        Calendar fixingCalendar() const override;
        bool isValidFixingDate(const Date&) const override { return true; }

        /*! Forecasting index values requires an inflation term
            structure.  The inflation term structure (ITS) defines the
            usual lag (not the index).  I.e.  an ITS is always relatve
            to a base date that is earlier than its asof date.  This
            must be so because indices are available only with a lag.
            However, the index availability lag only sets a minimum
            lag for the ITS.  An ITS may be relative to an earlier
            date, e.g. an index may have a 2-month delay in
            publication but the inflation swaps may take as their base
            the index 3 months before.
        */
        Rate fixing(const Date& fixingDate, bool forecastTodaysFixing = false) const override = 0;

        /*! this method creates all the "fixings" for the relevant
            period of the index.  E.g. for monthly indices it will put
            the same value in every calendar day in the month.
        */
        void addFixing(const Date& fixingDate, Rate fixing, bool forceOverwrite = false) override;
        //@}

        //! \name Observer interface
        //@{
        void update() override;
        //@}

        //! \name Inspectors
        //@{
        std::string familyName() const;
        Region region() const;
        bool revised() const;
        /*! Forecasting index values using an inflation term structure
            uses the interpolation of the inflation term structure
            unless interpolation is set to false.  In this case the
            extrapolated values are constant within each period taking
            the mid-period extrapolated value.
        */
        bool interpolated() const;
        Frequency frequency() const;
        /*! The availability lag describes when the index is
            <i>available</i>, not how it is used.  Specifically the
            fixing for, say, January, may only be available in April
            but the index will always return the index value
            applicable for January as its January fixing (independent
            of the lag in availability).
        */
        Period availabilityLag() const;
        Currency currency() const;
        //@}

      protected:
        Date referenceDate_;
        std::string familyName_;
        Region region_;
        bool revised_;
        bool interpolated_;
        Frequency frequency_;
        Period availabilityLag_;
        Currency currency_;
      private:
        std::string name_;
    };


    //! Base class for zero inflation indices.
    class ZeroInflationIndex : public InflationIndex {
      public:
        //! Always use the evaluation date as the reference date
        ZeroInflationIndex(
            const std::string& familyName,
            const Region& region,
            bool revised,
            bool interpolated,
            Frequency frequency,
            const Period& availabilityLag,
            const Currency& currency,
            Handle<ZeroInflationTermStructure> ts = Handle<ZeroInflationTermStructure>());

        //! \name Index interface
        //@{
        /*! \warning the forecastTodaysFixing parameter (required by
                     the Index interface) is currently ignored.
        */
        Rate fixing(const Date& fixingDate, bool forecastTodaysFixing = false) const override;
        //@}
        //! \name Other methods
        //@{
        Handle<ZeroInflationTermStructure> zeroInflationTermStructure() const;
        ext::shared_ptr<ZeroInflationIndex> clone(
                           const Handle<ZeroInflationTermStructure>& h) const;
        //@}
      private:
        bool needsForecast(const Date& fixingDate) const;
        Rate forecastFixing(const Date& fixingDate) const;
        Handle<ZeroInflationTermStructure> zeroInflation_;
    };

    //! Base class for year-on-year inflation indices.
    /*! These may be genuine indices published on, say, Bloomberg, or
        "fake" indices that are defined as the ratio of an index at
        different time points.
    */
    class YoYInflationIndex : public InflationIndex {
      public:
        YoYInflationIndex(
            const std::string& familyName,
            const Region& region,
            bool revised,
            bool interpolated,
            bool ratio, // is this one a genuine index or a ratio?
            Frequency frequency,
            const Period& availabilityLag,
            const Currency& currency,
            Handle<YoYInflationTermStructure> ts = Handle<YoYInflationTermStructure>());
        //! \name Index interface
        //@{
        /*! \warning the forecastTodaysFixing parameter (required by
                     the Index interface) is currently ignored.
        */
        Rate fixing(const Date& fixingDate, bool forecastTodaysFixing = false) const override;

        //@}
        //! \name Other methods
        //@{
        bool ratio() const;
        Handle<YoYInflationTermStructure> yoyInflationTermStructure() const;

        ext::shared_ptr<YoYInflationIndex> clone(
                            const Handle<YoYInflationTermStructure>& h) const;
        //@}
      private:
        Rate forecastFixing(const Date& fixingDate) const;
        bool ratio_;
        Handle<YoYInflationTermStructure> yoyInflation_;
    };


    namespace detail {
        namespace CPI {
            // Returns either CPI::Flat or CPI::Linear depending on the combination of index and
            // CPI::InterpolationType.
            QuantLib::CPI::InterpolationType effectiveInterpolationType(
                const ext::shared_ptr<ZeroInflationIndex>& index,
                const QuantLib::CPI::InterpolationType& type = QuantLib::CPI::AsIndex);


            // checks whether the combination of index and CPI::InterpolationType results
            // effectively in CPI::Linear
            bool
            isInterpolated(const ext::shared_ptr<ZeroInflationIndex>& index,
                           const QuantLib::CPI::InterpolationType& type = QuantLib::CPI::AsIndex);
        }
    }


    // inline

    inline std::string InflationIndex::name() const {
        return name_;
    }

    inline void InflationIndex::update() {
        notifyObservers();
    }

    inline std::string InflationIndex::familyName() const {
        return familyName_;
    }

    inline Region InflationIndex::region() const {
        return region_;
    }

    inline bool InflationIndex::revised() const {
        return revised_;
    }

    inline bool InflationIndex::interpolated() const {
        return interpolated_;
    }

    inline Frequency InflationIndex::frequency() const {
        return frequency_;
    }

    inline Period InflationIndex::availabilityLag() const {
        return availabilityLag_;
    }

    inline Currency InflationIndex::currency() const {
        return currency_;
    }

    inline Handle<ZeroInflationTermStructure>
    ZeroInflationIndex::zeroInflationTermStructure() const {
        return zeroInflation_;
    }

    inline bool YoYInflationIndex::ratio() const {
        return ratio_;
    }

    inline Handle<YoYInflationTermStructure>
    YoYInflationIndex::yoyInflationTermStructure() const {
        return yoyInflation_;
    }

    inline bool detail::CPI::isInterpolated(const ext::shared_ptr<ZeroInflationIndex>& index,
                                            const QuantLib::CPI::InterpolationType& type) {
        return detail::CPI::effectiveInterpolationType(index, type) == QuantLib::CPI::Linear;
    }
}

#endif
]]></document_content>
  </document>
  <document index="64">
    <source>interestrateindex.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2011 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/interestrateindex.hpp>
#include <ql/settings.hpp>
#include <sstream>
#include <utility>

namespace QuantLib {

    InterestRateIndex::InterestRateIndex(std::string familyName,
                                         const Period& tenor,
                                         Natural fixingDays,
                                         Currency currency,
                                         Calendar fixingCalendar,
                                         DayCounter dayCounter)
    : familyName_(std::move(familyName)), tenor_(tenor), fixingDays_(fixingDays),
      currency_(std::move(currency)), dayCounter_(std::move(dayCounter)),
      fixingCalendar_(std::move(fixingCalendar)) {
        tenor_.normalize();

        std::ostringstream out;
        out << familyName_;
        if (tenor_ == 1*Days) {
            if (fixingDays_==0)
                out << "ON";
            else if (fixingDays_==1)
                out << "TN";
            else if (fixingDays_==2)
                out << "SN";
            else
                out << io::short_period(tenor_);
        } else {
            out << io::short_period(tenor_);
        }
        out << " " << dayCounter_.name();
        name_ = out.str();

        registerWith(Settings::instance().evaluationDate());
        registerWith(IndexManager::instance().notifier(InterestRateIndex::name()));
    }

    Rate InterestRateIndex::fixing(const Date& fixingDate,
                                   bool forecastTodaysFixing) const {

        QL_REQUIRE(isValidFixingDate(fixingDate),
                   "Fixing date " << fixingDate << " is not valid");

        Date today = Settings::instance().evaluationDate();

        if (fixingDate>today ||
            (fixingDate==today && forecastTodaysFixing))
            return forecastFixing(fixingDate);

        if (fixingDate<today ||
            Settings::instance().enforcesTodaysHistoricFixings()) {
            // must have been fixed
            // do not catch exceptions
            Rate result = pastFixing(fixingDate);
            QL_REQUIRE(result != Null<Real>(),
                       "Missing " << name() << " fixing for " << fixingDate);
            return result;
        }

        try {
            // might have been fixed
            Rate result = pastFixing(fixingDate);
            if (result!=Null<Real>())
                return result;
            else
                ;   // fall through and forecast
        } catch (Error&) {
                ;   // fall through and forecast
        }
        return forecastFixing(fixingDate);
    }

}
]]></document_content>
  </document>
  <document index="65">
    <source>interestrateindex.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007, 2009 StatPro Italia srl
 Copyright (C) 2006, 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file interestrateindex.hpp
    \brief base class for interest rate indexes
*/

#ifndef quantlib_interestrateindex_hpp
#define quantlib_interestrateindex_hpp

#include <ql/index.hpp>
#include <ql/time/calendar.hpp>
#include <ql/currency.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/time/period.hpp>

namespace QuantLib {

    //! base class for interest rate indexes
    /*! \todo add methods returning InterestRate */
    class InterestRateIndex : public Index,
                              public Observer {
      public:
        InterestRateIndex(std::string familyName,
                          const Period& tenor,
                          Natural settlementDays,
                          Currency currency,
                          Calendar fixingCalendar,
                          DayCounter dayCounter);
        //! \name Index interface
        //@{
        std::string name() const override;
        Calendar fixingCalendar() const override;
        bool isValidFixingDate(const Date& fixingDate) const override;
        Rate fixing(const Date& fixingDate, bool forecastTodaysFixing = false) const override;
        //@}
        //! \name Observer interface
        //@{
        void update() override;
        //@}
        //! \name Inspectors
        //@{
        std::string familyName() const { return familyName_; }
        Period tenor() const { return tenor_; }
        Natural fixingDays() const { return fixingDays_; }
        Date fixingDate(const Date& valueDate) const;
        const Currency& currency() const { return currency_; }
        const DayCounter& dayCounter() const { return dayCounter_; }
        //@}
        /*! \name Date calculations

            These method can be overridden to implement particular
            conventions (e.g. EurLibor)

            @{
        */
        virtual Date valueDate(const Date& fixingDate) const;
        virtual Date maturityDate(const Date& valueDate) const = 0;
        //@}
        //! \name Fixing calculations
        //@{
        //! It can be overridden to implement particular conventions
        virtual Rate forecastFixing(const Date& fixingDate) const = 0;
        virtual Rate pastFixing(const Date& fixingDate) const;
        // @}
      protected:
        std::string familyName_;
        Period tenor_;
        Natural fixingDays_;
        Currency currency_;
        DayCounter dayCounter_;
        std::string name_;
      private:
        Calendar fixingCalendar_;
    };


    // inline definitions

    inline std::string InterestRateIndex::name() const {
        return name_;
    }

    inline Calendar InterestRateIndex::fixingCalendar() const {
        return fixingCalendar_;
    }

    inline bool InterestRateIndex::isValidFixingDate(const Date& d) const {
        return fixingCalendar().isBusinessDay(d);
    }

    inline void InterestRateIndex::update() {
        notifyObservers();
    }

    inline Date InterestRateIndex::fixingDate(const Date& valueDate) const {
        Date fixingDate = fixingCalendar().advance(valueDate,
            -static_cast<Integer>(fixingDays_), Days);
        return fixingDate;
    }

    inline Date InterestRateIndex::valueDate(const Date& fixingDate) const {
        QL_REQUIRE(isValidFixingDate(fixingDate),
                   fixingDate << " is not a valid fixing date");
        return fixingCalendar().advance(fixingDate, fixingDays_, Days);
    }

    inline Rate InterestRateIndex::pastFixing(const Date& fixingDate) const {
        QL_REQUIRE(isValidFixingDate(fixingDate),
                   fixingDate << " is not a valid fixing date");
        return timeSeries()[fixingDate];
    }

}

#endif
]]></document_content>
  </document>
  <document index="66">
    <source>region.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Chris Kenyon
 Copyright (C) 2014 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/region.hpp>

namespace QuantLib {

    CustomRegion::CustomRegion(const std::string& name,
                               const std::string& code) {
        data_ = ext::make_shared<Data>(name,code);
    }


    AustraliaRegion::AustraliaRegion() {
        static ext::shared_ptr<Data> AUdata(new Data("Australia","AU"));
        data_ = AUdata;
    }

    EURegion::EURegion() {
        static ext::shared_ptr<Data> EUdata(new Data("EU","EU"));
        data_ = EUdata;
    }

    FranceRegion::FranceRegion() {
        static ext::shared_ptr<Data> FRdata(new Data("France","FR"));
        data_ = FRdata;
    }

    UKRegion::UKRegion() {
        static ext::shared_ptr<Data> UKdata(new Data("UK","UK"));
        data_ = UKdata;
    }

    USRegion::USRegion() {
        static ext::shared_ptr<Data> USdata(new Data("USA","US"));
        data_ = USdata;
    }

    ZARegion::ZARegion() {
        static ext::shared_ptr<Data> ZAdata(new Data("South Africa","ZA"));
        data_ = ZAdata;
    }


}

]]></document_content>
  </document>
  <document index="67">
    <source>region.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Chris Kenyon
 Copyright (C) 2014 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file region.hpp
    \brief Region, i.e. geographical area, specification
*/

#ifndef quantlib_region_hpp
#define quantlib_region_hpp

#include <ql/qldefines.hpp>
#include <ql/shared_ptr.hpp>
#include <string>
#include <utility>

namespace QuantLib {

    //! Region class, used for inflation applicability.
    class Region {
      public:
        //! \name Inspectors
        //@{
        const std::string& name() const;
        const std::string& code() const;
        //@}
      protected:
        Region() = default;
        struct Data;
        ext::shared_ptr<Data> data_;
    };

    struct Region::Data {
        std::string name;
        std::string code;
        Data(std::string name, std::string code) : name(std::move(name)), code(std::move(code)) {}
    };

    //! \relates Region
    bool operator==(const Region&, const Region&);

    //! \relates Region
    bool operator!=(const Region&, const Region&);


    //! Custom geographical/economic region
    /*! This class allows one to create an instance of a particular
        region without having to define and compile a corresponding
        class.
    */
    class CustomRegion : public Region {
      public:
        CustomRegion(const std::string& name,
                     const std::string& code);
    };


    //! Australia as geographical/economic region
    class AustraliaRegion : public Region {
      public:
        AustraliaRegion();
    };

    //! European Union as geographical/economic region
    class EURegion : public Region {
      public:
        EURegion();
    };

    //! France as geographical/economic region
    class FranceRegion : public Region {
      public:
        FranceRegion();
    };

    //! United Kingdom as geographical/economic region
    class UKRegion : public Region {
      public:
        UKRegion();
    };

    //! USA as geographical/economic region
    class USRegion : public Region {
    public:
        USRegion();
    };

    //! South Africa as geographical/economic region
    class ZARegion : public Region {
    public:
        ZARegion();
    };


    // inline definitions

    inline const std::string& Region::name() const {
        return data_->name;
    }

    inline const std::string& Region::code() const {
        return data_->code;
    }

    inline bool operator==(const Region& r1, const Region& r2) {
        return r1.name() == r2.name();
    }

    inline bool operator!=(const Region& r1, const Region& r2) {
        return !(r1.name() == r2.name());
    }

}

#endif
]]></document_content>
  </document>
  <document index="68">
    <source>swap/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    chfliborswap.hpp \
    euriborswap.hpp \
    eurliborswap.hpp \
    gbpliborswap.hpp \
    jpyliborswap.hpp \
    usdliborswap.hpp

cpp_files = \
    chfliborswap.cpp \
    euriborswap.cpp \
    eurliborswap.cpp \
    gbpliborswap.cpp \
    jpyliborswap.cpp \
    usdliborswap.cpp

if UNITY_BUILD

nodist_libSwapIndexes_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libSwapIndexes_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libSwapIndexes.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="69">
    <source>swap/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/indexes/swap/chfliborswap.hpp>
#include <ql/indexes/swap/euriborswap.hpp>
#include <ql/indexes/swap/eurliborswap.hpp>
#include <ql/indexes/swap/gbpliborswap.hpp>
#include <ql/indexes/swap/jpyliborswap.hpp>
#include <ql/indexes/swap/usdliborswap.hpp>

]]></document_content>
  </document>
  <document index="70">
    <source>swap/chfliborswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007, 2008, 2011 Ferdinando Ametrano
 Copyright (C) 2006 Chiara Fornarola

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/swap/chfliborswap.hpp>
#include <ql/indexes/ibor/chflibor.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    ChfLiborSwapIsdaFix::ChfLiborSwapIsdaFix(
                                const Period& tenor,
                                const Handle<YieldTermStructure>& h)
    : SwapIndex("ChfLiborSwapIsdaFix", // familyName
                tenor,
                2, // settlementDays
                CHFCurrency(),
                TARGET(),
                1*Years, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                Thirty360(Thirty360::BondBasis), // fixedLegDaycounter
                tenor > 1*Years ?
                    ext::shared_ptr<IborIndex>(new CHFLibor(6*Months, h)) :
                    ext::shared_ptr<IborIndex>(new CHFLibor(3*Months, h))) {}

    ChfLiborSwapIsdaFix::ChfLiborSwapIsdaFix(
                                const Period& tenor,
                                const Handle<YieldTermStructure>& forwarding,
                                const Handle<YieldTermStructure>& discounting)
    : SwapIndex("ChfLiborSwapIsdaFix", // familyName
                tenor,
                2, // settlementDays
                CHFCurrency(),
                TARGET(),
                1*Years, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                Thirty360(Thirty360::BondBasis), // fixedLegDaycounter
                tenor > 1*Years ?
                    ext::shared_ptr<IborIndex>(new CHFLibor(6*Months, forwarding)) :
                    ext::shared_ptr<IborIndex>(new CHFLibor(3*Months, forwarding)),
                discounting) {}

}
]]></document_content>
  </document>
  <document index="71">
    <source>swap/chfliborswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file chfliborswap.hpp
    \brief %CHF %Libor %Swap indexes
*/

#ifndef quantlib_chfliborswap_hpp
#define quantlib_chfliborswap_hpp

#include <ql/indexes/swapindex.hpp>

namespace QuantLib {

    //! %ChfLiborSwapIsdaFix index base class
    /*! %CHF %Libor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 11am London.
        Annual 30/360 vs 6M Libor, 1Y vs 3M Libor.
        Reuters page ISDAFIX4 or CHFSFIX=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class ChfLiborSwapIsdaFix : public SwapIndex {
      public:
        ChfLiborSwapIsdaFix(const Period& tenor,
                            const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
        ChfLiborSwapIsdaFix(const Period& tenor,
                            const Handle<YieldTermStructure>& forwarding,
                            const Handle<YieldTermStructure>& discounting);
    };

}

#endif
]]></document_content>
  </document>
  <document index="72">
    <source>swap/euriborswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007, 2008, 2009 Ferdinando Ametrano
 Copyright (C) 2006 Katiuscia Manzoni

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/swap/euriborswap.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    EuriborSwapIsdaFixA::EuriborSwapIsdaFixA(
                                        const Period& tenor,
                                        const Handle<YieldTermStructure>& h)
    : SwapIndex("EuriborSwapIsdaFixA", // familyName
                tenor,
                2, // settlementDays
                EURCurrency(),
                TARGET(),
                1*Years, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                Thirty360(Thirty360::BondBasis), // fixedLegDaycounter
                tenor > 1*Years ?
                    ext::shared_ptr<IborIndex>(new Euribor(6*Months, h)) :
                    ext::shared_ptr<IborIndex>(new Euribor(3*Months, h))) {}

    EuriborSwapIsdaFixA::EuriborSwapIsdaFixA(
                                const Period& tenor,
                                const Handle<YieldTermStructure>& forwarding,
                                const Handle<YieldTermStructure>& discounting)
    : SwapIndex("EuriborSwapIsdaFixA", // familyName
                tenor,
                2, // settlementDays
                EURCurrency(),
                TARGET(),
                1*Years, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                Thirty360(Thirty360::BondBasis), // fixedLegDaycounter
                tenor > 1*Years ?
                    ext::shared_ptr<IborIndex>(new Euribor(6*Months, forwarding)) :
                    ext::shared_ptr<IborIndex>(new Euribor(3*Months, forwarding)),
                discounting) {}

    EuriborSwapIsdaFixB::EuriborSwapIsdaFixB(
                                        const Period& tenor,
                                        const Handle<YieldTermStructure>& h)
    : SwapIndex("EuriborSwapIsdaFixB", // familyName
                tenor,
                2, // settlementDays
                EURCurrency(),
                TARGET(),
                1*Years, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                Thirty360(Thirty360::BondBasis), // fixedLegDaycounter
                tenor > 1*Years ?
                    ext::shared_ptr<IborIndex>(new Euribor(6*Months, h)) :
                    ext::shared_ptr<IborIndex>(new Euribor(3*Months, h))) {}

    EuriborSwapIsdaFixB::EuriborSwapIsdaFixB(
                                const Period& tenor,
                                const Handle<YieldTermStructure>& forwarding,
                                const Handle<YieldTermStructure>& discounting)
    : SwapIndex("EuriborSwapIsdaFixB", // familyName
                tenor,
                2, // settlementDays
                EURCurrency(),
                TARGET(),
                1*Years, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                Thirty360(Thirty360::BondBasis), // fixedLegDaycounter
                tenor > 1*Years ?
                    ext::shared_ptr<IborIndex>(new Euribor(6*Months, forwarding)) :
                    ext::shared_ptr<IborIndex>(new Euribor(3*Months, forwarding)),
                discounting) {}


    EuriborSwapIfrFix::EuriborSwapIfrFix(const Period& tenor,
                                         const Handle<YieldTermStructure>& h)
    : SwapIndex("EuriborSwapIfrFix", // familyName
                tenor,
                2, // settlementDays
                EURCurrency(),
                TARGET(),
                1*Years, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                Thirty360(Thirty360::BondBasis), // fixedLegDaycounter
                tenor > 1*Years ?
                    ext::shared_ptr<IborIndex>(new Euribor(6*Months, h)) :
                    ext::shared_ptr<IborIndex>(new Euribor(3*Months, h))) {}

    EuriborSwapIfrFix::EuriborSwapIfrFix(
                                const Period& tenor,
                                const Handle<YieldTermStructure>& forwarding,
                                const Handle<YieldTermStructure>& discounting)
    : SwapIndex("EuriborSwapIfrFix", // familyName
                tenor,
                2, // settlementDays
                EURCurrency(),
                TARGET(),
                1*Years, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                Thirty360(Thirty360::BondBasis), // fixedLegDaycounter
                tenor > 1*Years ?
                    ext::shared_ptr<IborIndex>(new Euribor(6*Months, forwarding)) :
                    ext::shared_ptr<IborIndex>(new Euribor(3*Months, forwarding)),
                discounting) {}


}
]]></document_content>
  </document>
  <document index="73">
    <source>swap/euriborswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file euriborswap.hpp
    \brief Euribor %Swap indexes
*/

#ifndef quantlib_euriborswap_hpp
#define quantlib_euriborswap_hpp

#include <ql/indexes/swapindex.hpp>

namespace QuantLib {

    //! %EuriborSwapIsdaFixA index base class
    /*! %Euribor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 11am Frankfurt.
        Annual 30/360 vs 6M Euribor, 1Y vs 3M Euribor.
        Reuters page ISDAFIX2 or EURSFIXA=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class EuriborSwapIsdaFixA : public SwapIndex {
      public:
        EuriborSwapIsdaFixA(const Period& tenor,
                            const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
        EuriborSwapIsdaFixA(const Period& tenor,
                            const Handle<YieldTermStructure>& forwarding,
                            const Handle<YieldTermStructure>& discounting);
    };

    //! %EuriborSwapIsdaFixB index base class
    /*! %Euribor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 12am Frankfurt.
        Annual 30/360 vs 6M Euribor, 1Y vs 3M Euribor.
        Reuters page ISDAFIX2 or EURSFIXB=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class EuriborSwapIsdaFixB : public SwapIndex {
      public:
        EuriborSwapIsdaFixB(const Period& tenor,
                            const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
        EuriborSwapIsdaFixB(const Period& tenor,
                            const Handle<YieldTermStructure>& forwarding,
                            const Handle<YieldTermStructure>& discounting);
    };

    //! %EuriborSwapIfrFix index base class
    /*! %Euribor %Swap indexes published by IFR Markets and
        distributed by Reuters page TGM42281 and by Telerate.
        Annual 30/360 vs 6M Euribor, 1Y vs 3M Euribor.
        For more info see <http://www.ifrmarkets.com>.

    */
    class EuriborSwapIfrFix : public SwapIndex {
      public:
        EuriborSwapIfrFix(const Period& tenor,
                          const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
        EuriborSwapIfrFix(const Period& tenor,
                          const Handle<YieldTermStructure>& forwarding,
                          const Handle<YieldTermStructure>& discounting);
    };

}

#endif
]]></document_content>
  </document>
  <document index="74">
    <source>swap/eurliborswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007, 2008 Ferdinando Ametrano
 Copyright (C) 2006 Chiara Fornarola

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/swap/eurliborswap.hpp>
#include <ql/indexes/ibor/eurlibor.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    EurLiborSwapIsdaFixA::EurLiborSwapIsdaFixA(
                                        const Period& tenor,
                                        const Handle<YieldTermStructure>& h)
    : SwapIndex("EurLiborSwapIsdaFixA", // familyName
                tenor,
                2, // settlementDays
                EURCurrency(),
                TARGET(),
                1*Years, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                Thirty360(Thirty360::BondBasis), // fixedLegDaycounter
                tenor > 1*Years ?
                    ext::shared_ptr<IborIndex>(new EURLibor(6*Months, h)) :
                    ext::shared_ptr<IborIndex>(new EURLibor(3*Months, h))) {}

    EurLiborSwapIsdaFixA::EurLiborSwapIsdaFixA(
                                const Period& tenor,
                                const Handle<YieldTermStructure>& forwarding,
                                const Handle<YieldTermStructure>& discounting)
    : SwapIndex("EurLiborSwapIsdaFixA", // familyName
                tenor,
                2, // settlementDays
                EURCurrency(),
                TARGET(),
                1*Years, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                Thirty360(Thirty360::BondBasis), // fixedLegDaycounter
                tenor > 1*Years ?
                    ext::shared_ptr<IborIndex>(new EURLibor(6*Months, forwarding)) :
                    ext::shared_ptr<IborIndex>(new EURLibor(3*Months, forwarding)),
                discounting) {}

    EurLiborSwapIsdaFixB::EurLiborSwapIsdaFixB(
                                        const Period& tenor,
                                        const Handle<YieldTermStructure>& h)
    : SwapIndex("EurLiborSwapIsdaFixB", // familyName
                tenor,
                2, // settlementDays
                EURCurrency(),
                TARGET(),
                1*Years, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                Thirty360(Thirty360::BondBasis), // fixedLegDaycounter
                tenor > 1*Years ?
                    ext::shared_ptr<IborIndex>(new EURLibor(6*Months, h)) :
                    ext::shared_ptr<IborIndex>(new EURLibor(3*Months, h))) {}

    EurLiborSwapIsdaFixB::EurLiborSwapIsdaFixB(
                                const Period& tenor,
                                const Handle<YieldTermStructure>& forwarding,
                                const Handle<YieldTermStructure>& discounting)
    : SwapIndex("EurLiborSwapIsdaFixB", // familyName
                tenor,
                2, // settlementDays
                EURCurrency(),
                TARGET(),
                1*Years, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                Thirty360(Thirty360::BondBasis), // fixedLegDaycounter
                tenor > 1*Years ?
                    ext::shared_ptr<IborIndex>(new EURLibor(6*Months, forwarding)) :
                    ext::shared_ptr<IborIndex>(new EURLibor(3*Months, forwarding)),
                discounting) {}

    EurLiborSwapIfrFix::EurLiborSwapIfrFix(
                                        const Period& tenor,
                                        const Handle<YieldTermStructure>& h)
    : SwapIndex("EurLiborSwapIfrFix", // familyName
                tenor,
                2, // settlementDays
                EURCurrency(),
                TARGET(),
                1*Years, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                Thirty360(Thirty360::BondBasis), // fixedLegDaycounter
                tenor > 1*Years ?
                    ext::shared_ptr<IborIndex>(new EURLibor(6*Months, h)) :
                    ext::shared_ptr<IborIndex>(new EURLibor(3*Months, h))) {}

    EurLiborSwapIfrFix::EurLiborSwapIfrFix(
                                const Period& tenor,
                                const Handle<YieldTermStructure>& forwarding,
                                const Handle<YieldTermStructure>& discounting)
    : SwapIndex("EurLiborSwapIfrFix", // familyName
                tenor,
                2, // settlementDays
                EURCurrency(),
                TARGET(),
                1*Years, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                Thirty360(Thirty360::BondBasis), // fixedLegDaycounter
                tenor > 1*Years ?
                    ext::shared_ptr<IborIndex>(new EURLibor(6*Months, forwarding)) :
                    ext::shared_ptr<IborIndex>(new EURLibor(3*Months, forwarding)),
                discounting) {}

}
]]></document_content>
  </document>
  <document index="75">
    <source>swap/eurliborswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file eurliborswap.hpp
    \brief %EUR %Libor %Swap indexes
*/

#ifndef quantlib_eurliborswap_hpp
#define quantlib_eurliborswap_hpp

#include <ql/indexes/swapindex.hpp>

namespace QuantLib {

    //! %EurLiborSwapIsdaFixA index base class
    /*! %EUR %Libor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 10am London.
        Annual 30/360 vs 6M Libor, 1Y vs 3M Libor.
        Reuters page ISDAFIX2 or EURSFIXLA=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class EurLiborSwapIsdaFixA : public SwapIndex {
      public:
        EurLiborSwapIsdaFixA(const Period& tenor,
                             const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
        EurLiborSwapIsdaFixA(const Period& tenor,
                             const Handle<YieldTermStructure>& forwarding,
                             const Handle<YieldTermStructure>& discounting);
    };

    //! %EurLiborSwapIsdaFixB index base class
    /*! %EUR %Libor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 11am London.
        Annual 30/360 vs 6M Libor, 1Y vs 3M Libor.
        Reuters page ISDAFIX2 or EURSFIXLB=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class EurLiborSwapIsdaFixB : public SwapIndex {
      public:
        EurLiborSwapIsdaFixB(const Period& tenor,
                             const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
        EurLiborSwapIsdaFixB(const Period& tenor,
                             const Handle<YieldTermStructure>& forwarding,
                             const Handle<YieldTermStructure>& discounting);
    };


    //! %EurLiborSwapIfrFix index base class
    /*! %EUR %Libor %Swap indexes published by IFR Markets and
        distributed by Reuters page TGM42281 and by Telerate.
        Annual 30/360 vs 6M Libor, 1Y vs 3M Libor.
        For more info see <http://www.ifrmarkets.com>.

    */
    class EurLiborSwapIfrFix : public SwapIndex {
      public:
        EurLiborSwapIfrFix(const Period& tenor,
                           const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
        EurLiborSwapIfrFix(const Period& tenor,
                           const Handle<YieldTermStructure>& forwarding,
                           const Handle<YieldTermStructure>& discounting);
    };

}

#endif
]]></document_content>
  </document>
  <document index="76">
    <source>swap/gbpliborswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007, 2008, 2011 Ferdinando Ametrano
 Copyright (C) 2006 Chiara Fornarola

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/swap/gbpliborswap.hpp>
#include <ql/indexes/ibor/gbplibor.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/currencies/europe.hpp>

namespace QuantLib {

    GbpLiborSwapIsdaFix::GbpLiborSwapIsdaFix(
                            const Period& tenor,
                            const Handle<YieldTermStructure>& h)
    : SwapIndex("GbpLiborSwapIsdaFix", // familyName
                tenor,
                0, // settlementDays
                GBPCurrency(),
                UnitedKingdom(UnitedKingdom::Exchange),
                tenor > 1*Years ? // fixedLegTenor
                    6*Months : 1*Years,
                ModifiedFollowing, // fixedLegConvention
                Actual365Fixed(), // fixedLegDaycounter
                tenor > 1*Years ?
                    ext::shared_ptr<IborIndex>(new GBPLibor(6*Months, h)) :
                    ext::shared_ptr<IborIndex>(new GBPLibor(3*Months, h))) {}

    GbpLiborSwapIsdaFix::GbpLiborSwapIsdaFix(
                            const Period& tenor,
                            const Handle<YieldTermStructure>& forwarding,
                            const Handle<YieldTermStructure>& discounting)
    : SwapIndex("GbpLiborSwapIsdaFix", // familyName
                tenor,
                0, // settlementDays
                GBPCurrency(),
                UnitedKingdom(UnitedKingdom::Exchange),
                tenor > 1*Years ? // fixedLegTenor
                    6*Months : 1*Years,
                ModifiedFollowing, // fixedLegConvention
                Actual365Fixed(), // fixedLegDaycounter
                tenor > 1*Years ?
                    ext::shared_ptr<IborIndex>(new GBPLibor(6*Months, forwarding)) :
                    ext::shared_ptr<IborIndex>(new GBPLibor(3*Months, forwarding)),
                discounting) {}

}
]]></document_content>
  </document>
  <document index="77">
    <source>swap/gbpliborswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file gbpliborswap.hpp
    \brief %GBP %Libor %Swap indexes
*/

#ifndef quantlib_gbpliborswap_hpp
#define quantlib_gbpliborswap_hpp

#include <ql/indexes/swapindex.hpp>

namespace QuantLib {

    //! %GbpLiborSwapIsdaFix index base class
    /*! %GBP %Libor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 11am London.
        Semiannual Actual/365F vs 6M Libor, 1Y Annual vs 3M Libor.
        Reuters page ISDAFIX4 or GBPSFIX=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class GbpLiborSwapIsdaFix : public SwapIndex {
      public:
        GbpLiborSwapIsdaFix(const Period& tenor,
                            const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
        GbpLiborSwapIsdaFix(const Period& tenor,
                            const Handle<YieldTermStructure>& forwarding,
                            const Handle<YieldTermStructure>& discounting);
    };

}

#endif
]]></document_content>
  </document>
  <document index="78">
    <source>swap/jpyliborswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/swap/jpyliborswap.hpp>
#include <ql/indexes/ibor/jpylibor.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/currencies/asia.hpp>

namespace QuantLib {

    JpyLiborSwapIsdaFixAm::JpyLiborSwapIsdaFixAm(
                                const Period& tenor,
                                const Handle<YieldTermStructure>& h)
    : SwapIndex("JpyLiborSwapIsdaFixAm", // familyName
                tenor,
                2, // settlementDays
                JPYCurrency(),
                TARGET(),
                6*Months, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                ActualActual(ActualActual::ISDA), // fixedLegDaycounter
                ext::shared_ptr<IborIndex>(new JPYLibor(6*Months, h))) {}

    JpyLiborSwapIsdaFixAm::JpyLiborSwapIsdaFixAm(
                                const Period& tenor,
                                const Handle<YieldTermStructure>& forwarding,
                                const Handle<YieldTermStructure>& discounting)
    : SwapIndex("JpyLiborSwapIsdaFixAm", // familyName
                tenor,
                2, // settlementDays
                JPYCurrency(),
                TARGET(),
                6*Months, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                ActualActual(ActualActual::ISDA), // fixedLegDaycounter
                ext::shared_ptr<IborIndex>(new JPYLibor(6*Months, forwarding)),
                discounting) {}

    JpyLiborSwapIsdaFixPm::JpyLiborSwapIsdaFixPm(
                                const Period& tenor,
                                const Handle<YieldTermStructure>& h)
    : SwapIndex("JpyLiborSwapIsdaFixPm", // familyName
                tenor,
                2, // settlementDays
                JPYCurrency(),
                TARGET(),
                6*Months, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                ActualActual(ActualActual::ISDA), // fixedLegDaycounter
                ext::shared_ptr<IborIndex>(new JPYLibor(6*Months, h))) {}

    JpyLiborSwapIsdaFixPm::JpyLiborSwapIsdaFixPm(
                                const Period& tenor,
                                const Handle<YieldTermStructure>& forwarding,
                                const Handle<YieldTermStructure>& discounting)
    : SwapIndex("JpyLiborSwapIsdaFixPm", // familyName
                tenor,
                2, // settlementDays
                JPYCurrency(),
                TARGET(),
                6*Months, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                ActualActual(ActualActual::ISDA), // fixedLegDaycounter
                ext::shared_ptr<IborIndex>(new JPYLibor(6*Months, forwarding)),
                discounting) {}

}
]]></document_content>
  </document>
  <document index="79">
    <source>swap/jpyliborswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file jpyliborswap.hpp
    \brief %JPY %Libor %Swap indexes
*/

#ifndef quantlib_jpyliborswap_hpp
#define quantlib_jpyliborswap_hpp

#include <ql/indexes/swapindex.hpp>

namespace QuantLib {

    //! %JpyLiborSwapIsdaFixAm index base class
    /*! %JPY %Libor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 10am Tokyo.
        Semiannual Act/365 vs 6M Libor. Reuters page ISDAFIX1 or JPYSFIXA=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class JpyLiborSwapIsdaFixAm : public SwapIndex {
      public:
        JpyLiborSwapIsdaFixAm(const Period& tenor,
                              const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
        JpyLiborSwapIsdaFixAm(const Period& tenor,
                              const Handle<YieldTermStructure>& forwarding,
                             const Handle<YieldTermStructure>& discounting);
    };

    //! %JpyLiborSwapIsdaFixPm index base class
    /*! %JPY %Libor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 3pm Tokyo.
        Semiannual Act/365 vs 6M Libor. Reuters page ISDAFIX1 or JPYSFIXP=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class JpyLiborSwapIsdaFixPm : public SwapIndex {
      public:
        JpyLiborSwapIsdaFixPm(const Period& tenor,
                              const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
        JpyLiborSwapIsdaFixPm(const Period& tenor,
                              const Handle<YieldTermStructure>& forwarding,
                             const Handle<YieldTermStructure>& discounting);
    };

}

#endif
]]></document_content>
  </document>
  <document index="80">
    <source>swap/usdliborswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/indexes/swap/usdliborswap.hpp>
#include <ql/indexes/ibor/usdlibor.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/currencies/america.hpp>

namespace QuantLib {

    UsdLiborSwapIsdaFixAm::UsdLiborSwapIsdaFixAm(
                                const Period& tenor,
                                const Handle<YieldTermStructure>& h)
    : SwapIndex("UsdLiborSwapIsdaFixAm", // familyName
                tenor,
                2, // settlementDays
                USDCurrency(),
                UnitedStates(UnitedStates::GovernmentBond),
                6*Months, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                Thirty360(Thirty360::BondBasis), // fixedLegDaycounter
                ext::shared_ptr<IborIndex>(new USDLibor(3*Months, h))) {}

    UsdLiborSwapIsdaFixAm::UsdLiborSwapIsdaFixAm(
                                const Period& tenor,
                                const Handle<YieldTermStructure>& forwarding,
                                const Handle<YieldTermStructure>& discounting)
    : SwapIndex("UsdLiborSwapIsdaFixAm", // familyName
                tenor,
                2, // settlementDays
                USDCurrency(),
                UnitedStates(UnitedStates::GovernmentBond),
                6*Months, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                Thirty360(Thirty360::BondBasis), // fixedLegDaycounter
                ext::shared_ptr<IborIndex>(new USDLibor(3*Months, forwarding)),
                discounting) {}

    UsdLiborSwapIsdaFixPm::UsdLiborSwapIsdaFixPm(
                                const Period& tenor,
                                const Handle<YieldTermStructure>& h)
    : SwapIndex("UsdLiborSwapIsdaFixPm", // familyName
                tenor,
                2, // settlementDays
                USDCurrency(),
                UnitedStates(UnitedStates::GovernmentBond),
                6*Months, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                Thirty360(Thirty360::BondBasis), // fixedLegDaycounter
                ext::shared_ptr<IborIndex>(new USDLibor(3*Months, h))) {}

    UsdLiborSwapIsdaFixPm::UsdLiborSwapIsdaFixPm(
                                const Period& tenor,
                                const Handle<YieldTermStructure>& forwarding,
                                const Handle<YieldTermStructure>& discounting)
    : SwapIndex("UsdLiborSwapIsdaFixPm", // familyName
                tenor,
                2, // settlementDays
                USDCurrency(),
                UnitedStates(UnitedStates::GovernmentBond),
                6*Months, // fixedLegTenor
                ModifiedFollowing, // fixedLegConvention
                Thirty360(Thirty360::BondBasis), // fixedLegDaycounter
                ext::shared_ptr<IborIndex>(new USDLibor(3*Months, forwarding)),
                discounting) {}

}
]]></document_content>
  </document>
  <document index="81">
    <source>swap/usdliborswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file usdliborswap.hpp
    \brief %USD %Libor %Swap indexes
*/

#ifndef quantlib_usdliborswap_hpp
#define quantlib_usdliborswap_hpp

#include <ql/indexes/swapindex.hpp>

namespace QuantLib {

    //! %UsdLiborSwapIsdaFixAm index base class
    /*! %USD %Libor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 11am New York.
        Semiannual 30/360 vs 3M Libor. Reuters page ISDAFIX1 or USDSFIX=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class UsdLiborSwapIsdaFixAm : public SwapIndex {
      public:
        UsdLiborSwapIsdaFixAm(const Period& tenor,
                              const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
        UsdLiborSwapIsdaFixAm(const Period& tenor,
                              const Handle<YieldTermStructure>& forwarding,
                              const Handle<YieldTermStructure>& discounting);
    };

    //! %UsdLiborSwapIsdaFixPm index base class
    /*! %USD %Libor %Swap indexes fixed by ISDA in cooperation with
        Reuters and Intercapital Brokers at 3pm New York.
        Semiannual 30/360 vs 3M Libor. Reuters page ISDAFIX1 or USDSFIXP=.

        Further info can be found at <http://www.isda.org/fix/isdafix.html> or
        Reuters page ISDAFIX.

    */
    class UsdLiborSwapIsdaFixPm : public SwapIndex {
      public:
        UsdLiborSwapIsdaFixPm(const Period& tenor,
                              const Handle<YieldTermStructure>& h =
                                    Handle<YieldTermStructure>());
        UsdLiborSwapIsdaFixPm(const Period& tenor,
                              const Handle<YieldTermStructure>& forwarding,
                              const Handle<YieldTermStructure>& discounting);
    };

}

#endif
]]></document_content>
  </document>
  <document index="82">
    <source>swapindex.cpp</source>
    <document_content><![CDATA[/*
 Copyright (C) 2006, 2009 Ferdinando Ametrano
 Copyright (C) 2006, 2007, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.


 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 or FITNESS FOR A PARTICULAR PURPOSE. See the license for more details. */

#include <ql/indexes/iborindex.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/instruments/makeois.hpp>
#include <ql/instruments/makevanillaswap.hpp>
#include <ql/time/schedule.hpp>
#include <sstream>
#include <utility>

namespace QuantLib {

    SwapIndex::SwapIndex(const std::string& familyName,
                         const Period& tenor,
                         Natural settlementDays,
                         const Currency& currency,
                         const Calendar& fixingCalendar,
                         const Period& fixedLegTenor,
                         BusinessDayConvention fixedLegConvention,
                         const DayCounter& fixedLegDayCounter,
                         ext::shared_ptr<IborIndex> iborIndex)
    : InterestRateIndex(
          familyName, tenor, settlementDays, currency, fixingCalendar, fixedLegDayCounter),
      tenor_(tenor), iborIndex_(std::move(iborIndex)), fixedLegTenor_(fixedLegTenor),
      fixedLegConvention_(fixedLegConvention), exogenousDiscount_(false),
      discount_(Handle<YieldTermStructure>()) {
        registerWith(iborIndex_);
    }

    SwapIndex::SwapIndex(const std::string& familyName,
                         const Period& tenor,
                         Natural settlementDays,
                         const Currency& currency,
                         const Calendar& fixingCalendar,
                         const Period& fixedLegTenor,
                         BusinessDayConvention fixedLegConvention,
                         const DayCounter& fixedLegDayCounter,
                         ext::shared_ptr<IborIndex> iborIndex,
                         Handle<YieldTermStructure> discount)
    : InterestRateIndex(
          familyName, tenor, settlementDays, currency, fixingCalendar, fixedLegDayCounter),
      tenor_(tenor), iborIndex_(std::move(iborIndex)), fixedLegTenor_(fixedLegTenor),
      fixedLegConvention_(fixedLegConvention), exogenousDiscount_(true),
      discount_(std::move(discount)) {
        registerWith(iborIndex_);
        registerWith(discount_);
    }

    Handle<YieldTermStructure> SwapIndex::forwardingTermStructure() const {
        return iborIndex_->forwardingTermStructure();
    }

    Handle<YieldTermStructure> SwapIndex::discountingTermStructure() const {
        return discount_;  // empty if not exogenous
    }

    Rate SwapIndex::forecastFixing(const Date& fixingDate) const {
        return underlyingSwap(fixingDate)->fairRate();
    }

    ext::shared_ptr<VanillaSwap>
    SwapIndex::underlyingSwap(const Date& fixingDate) const {

        QL_REQUIRE(fixingDate!=Date(), "null fixing date");

        // caching mechanism
        if (lastFixingDate_!=fixingDate) {
            Rate fixedRate = 0.0;
            if (exogenousDiscount_)
                lastSwap_ = MakeVanillaSwap(tenor_, iborIndex_, fixedRate)
                    .withEffectiveDate(valueDate(fixingDate))
                    .withFixedLegCalendar(fixingCalendar())
                    .withFixedLegDayCount(dayCounter_)
                    .withFixedLegTenor(fixedLegTenor_)
                    .withFixedLegConvention(fixedLegConvention_)
                    .withFixedLegTerminationDateConvention(fixedLegConvention_)
                    .withDiscountingTermStructure(discount_);
            else
                lastSwap_ = MakeVanillaSwap(tenor_, iborIndex_, fixedRate)
                    .withEffectiveDate(valueDate(fixingDate))
                    .withFixedLegCalendar(fixingCalendar())
                    .withFixedLegDayCount(dayCounter_)
                    .withFixedLegTenor(fixedLegTenor_)
                    .withFixedLegConvention(fixedLegConvention_)
                    .withFixedLegTerminationDateConvention(fixedLegConvention_);
            lastFixingDate_ = fixingDate;
        }
        return lastSwap_;
    }

    Date SwapIndex::maturityDate(const Date& valueDate) const {
        Date fixDate = fixingDate(valueDate);
        return underlyingSwap(fixDate)->maturityDate();
    }

    ext::shared_ptr<SwapIndex>
    SwapIndex::clone(const Handle<YieldTermStructure>& forwarding) const {

        if (exogenousDiscount_)
            return ext::shared_ptr<SwapIndex>(new
                SwapIndex(familyName(),
                          tenor(),
                          fixingDays(),
                          currency(),
                          fixingCalendar(),
                          fixedLegTenor(),
                          fixedLegConvention(),
                          dayCounter(),
                          iborIndex_->clone(forwarding),
                          discount_));
        else
            return ext::shared_ptr<SwapIndex>(new
                SwapIndex(familyName(),
                          tenor(),
                          fixingDays(),
                          currency(),
                          fixingCalendar(),
                          fixedLegTenor(),
                          fixedLegConvention(),
                          dayCounter(),
                          iborIndex_->clone(forwarding)));
    }

    ext::shared_ptr<SwapIndex>
    SwapIndex::clone(const Handle<YieldTermStructure>& forwarding,
                     const Handle<YieldTermStructure>& discounting) const {
        return ext::shared_ptr<SwapIndex>(new
             SwapIndex(familyName(),
                       tenor(),
                       fixingDays(),
                       currency(),
                       fixingCalendar(),
                       fixedLegTenor(),
                       fixedLegConvention(),
                       dayCounter(),
                       iborIndex_->clone(forwarding),
                       discounting));
    }

    ext::shared_ptr<SwapIndex>
    SwapIndex::clone(const Period& tenor) const {

        if (exogenousDiscount_)
            return ext::shared_ptr<SwapIndex>(new
                SwapIndex(familyName(),
                          tenor,
                          fixingDays(),
                          currency(),
                          fixingCalendar(),
                          fixedLegTenor(),
                          fixedLegConvention(),
                          dayCounter(),
                          iborIndex(),
                          discountingTermStructure()));
        else
            return ext::shared_ptr<SwapIndex>(new
                SwapIndex(familyName(),
                          tenor,
                          fixingDays(),
                          currency(),
                          fixingCalendar(),
                          fixedLegTenor(),
                          fixedLegConvention(),
                          dayCounter(),
                          iborIndex()));

    }

    OvernightIndexedSwapIndex::OvernightIndexedSwapIndex(
        const std::string& familyName,
        const Period& tenor,
        Natural settlementDays,
        const Currency& currency,
        const ext::shared_ptr<OvernightIndex>& overnightIndex,
        bool telescopicValueDates,
        RateAveraging::Type averagingMethod)
    : SwapIndex(familyName,
                tenor,
                settlementDays,
                currency,
                overnightIndex->fixingCalendar(),
                1 * Years,
                ModifiedFollowing,
                overnightIndex->dayCounter(),
                overnightIndex),
      overnightIndex_(overnightIndex), 
      telescopicValueDates_(telescopicValueDates), 
      averagingMethod_(averagingMethod) {}


    ext::shared_ptr<OvernightIndexedSwap>
    OvernightIndexedSwapIndex::underlyingSwap(const Date& fixingDate) const {

        QL_REQUIRE(fixingDate!=Date(), "null fixing date");

        // caching mechanism
        if (lastFixingDate_!=fixingDate) {
            Rate fixedRate = 0.0;
            lastSwap_ = MakeOIS(tenor_, overnightIndex_, fixedRate)
                .withEffectiveDate(valueDate(fixingDate))
                .withFixedLegDayCount(dayCounter_)
                .withTelescopicValueDates(telescopicValueDates_)
                .withAveragingMethod(averagingMethod_);
            lastFixingDate_ = fixingDate;
        }
        return lastSwap_;
    }

}
]]></document_content>
  </document>
  <document index="83">
    <source>swapindex.hpp</source>
    <document_content><![CDATA[/*
 Copyright (C) 2006, 2009 Ferdinando Ametrano
 Copyright (C) 2006, 2007, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.


 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 or FITNESS FOR A PARTICULAR PURPOSE. See the license for more details. */

/*! \file swapindex.hpp
    \brief swap-rate indexes
*/

#ifndef quantlib_swapindex_hpp
#define quantlib_swapindex_hpp

#include <ql/indexes/interestrateindex.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/cashflows/rateaveraging.hpp>

namespace QuantLib {

    class Schedule;

    class IborIndex;
    class VanillaSwap;

    class OvernightIndex;
    class OvernightIndexedSwap;

    //! base class for swap-rate indexes
    class SwapIndex : public InterestRateIndex {
      public:
        SwapIndex(const std::string& familyName,
                  const Period& tenor,
                  Natural settlementDays,
                  const Currency& currency,
                  const Calendar& fixingCalendar,
                  const Period& fixedLegTenor,
                  BusinessDayConvention fixedLegConvention,
                  const DayCounter& fixedLegDayCounter,
                  ext::shared_ptr<IborIndex> iborIndex);
        SwapIndex(const std::string& familyName,
                  const Period& tenor,
                  Natural settlementDays,
                  const Currency& currency,
                  const Calendar& fixingCalendar,
                  const Period& fixedLegTenor,
                  BusinessDayConvention fixedLegConvention,
                  const DayCounter& fixedLegDayCounter,
                  ext::shared_ptr<IborIndex> iborIndex,
                  Handle<YieldTermStructure> discountingTermStructure);
        //! \name InterestRateIndex interface
        //@{
        Date maturityDate(const Date& valueDate) const override;
        //@}
        //! \name Inspectors
        //@{
        Period fixedLegTenor() const { return fixedLegTenor_; }
        BusinessDayConvention fixedLegConvention() const;
        ext::shared_ptr<IborIndex> iborIndex() const { return iborIndex_; }
        Handle<YieldTermStructure> forwardingTermStructure() const;
        Handle<YieldTermStructure> discountingTermStructure() const;
        bool exogenousDiscount() const;
        /*! \warning Relinking the term structure underlying the index will
                     not have effect on the returned swap.
        */
        ext::shared_ptr<VanillaSwap> underlyingSwap(
                                                const Date& fixingDate) const;
        //@}
        //! \name Other methods
        //@{
        //! returns a copy of itself linked to a different forwarding curve
        virtual ext::shared_ptr<SwapIndex> clone(
                        const Handle<YieldTermStructure>& forwarding) const;
        //! returns a copy of itself linked to different curves
        virtual ext::shared_ptr<SwapIndex> clone(
                        const Handle<YieldTermStructure>& forwarding,
                        const Handle<YieldTermStructure>& discounting) const;
        //! returns a copy of itself with different tenor
        virtual ext::shared_ptr<SwapIndex> clone(
                        const Period& tenor) const;
        // @}
      protected:
        Rate forecastFixing(const Date& fixingDate) const override;
        Period tenor_;
        ext::shared_ptr<IborIndex> iborIndex_;
        Period fixedLegTenor_;
        BusinessDayConvention fixedLegConvention_;
        bool exogenousDiscount_;
        Handle<YieldTermStructure> discount_;
        // cache data to avoid swap recreation when the same fixing date
        // is used multiple time to forecast changing fixing
        mutable ext::shared_ptr<VanillaSwap> lastSwap_;
        mutable Date lastFixingDate_;
    };


    //! base class for overnight indexed swap indexes
    class OvernightIndexedSwapIndex : public SwapIndex {
      public:
        OvernightIndexedSwapIndex(
                  const std::string& familyName,
                  const Period& tenor,
                  Natural settlementDays,
                  const Currency& currency,
                  const ext::shared_ptr<OvernightIndex>& overnightIndex,
                  bool telescopicValueDates = false,
                  RateAveraging::Type averagingMethod = RateAveraging::Compound);
        //! \name Inspectors
        //@{
        ext::shared_ptr<OvernightIndex> overnightIndex() const;
        /*! \warning Relinking the term structure underlying the index will
                     not have effect on the returned swap.
        */
        ext::shared_ptr<OvernightIndexedSwap> underlyingSwap(
                                                const Date& fixingDate) const;
        //@}
      protected:
        ext::shared_ptr<OvernightIndex> overnightIndex_;
        bool telescopicValueDates_;
        RateAveraging::Type averagingMethod_;
        // cache data to avoid swap recreation when the same fixing date
        // is used multiple time to forecast changing fixing
        mutable ext::shared_ptr<OvernightIndexedSwap> lastSwap_;
        mutable Date lastFixingDate_;
    };

    // inline definitions

    inline BusinessDayConvention SwapIndex::fixedLegConvention() const {
        return fixedLegConvention_;
    }

    inline bool SwapIndex::exogenousDiscount() const {
        return exogenousDiscount_;
    }

    inline ext::shared_ptr<OvernightIndex>
    OvernightIndexedSwapIndex::overnightIndex() const {
        return overnightIndex_;
    }

}

#endif
]]></document_content>
  </document>
</documents>