<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    clone.hpp \
    dataformatters.hpp \
    dataparsers.hpp \
    disposable.hpp \
    null.hpp \
	null_deleter.hpp \
    observablevalue.hpp \
    steppingiterator.hpp \
    tracing.hpp \
    vectors.hpp

cpp_files = \
    dataformatters.cpp \
    dataparsers.cpp \
    tracing.cpp

if UNITY_BUILD

nodist_libUtilities_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libUtilities_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libUtilities.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="2">
    <source>all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/utilities/clone.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/utilities/dataparsers.hpp>
#include <ql/utilities/disposable.hpp>
#include <ql/utilities/null.hpp>
#include <ql/utilities/null_deleter.hpp>
#include <ql/utilities/observablevalue.hpp>
#include <ql/utilities/steppingiterator.hpp>
#include <ql/utilities/tracing.hpp>
#include <ql/utilities/vectors.hpp>

]]></document_content>
  </document>
  <document index="3">
    <source>clone.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file clone.hpp
    \brief cloning proxy to an underlying object
*/

#ifndef quantlib_clone_hpp
#define quantlib_clone_hpp

#include <ql/errors.hpp>
#if !defined(QL_USE_STD_UNIQUE_PTR)
#include <boost/scoped_ptr.hpp>
#endif
#include <algorithm>
#include <memory>

namespace QuantLib {

    //! cloning proxy to an underlying object
    /*! When copied, this class will make a clone of its underlying
        object, which must provide a <tt>clone()</tt> method returning
        a std::auto_ptr (or a std::unique_ptr, depending on your
        configuration) to a newly-allocated instance.
    */
    template <class T>
    class Clone {
      public:
        Clone() = default;
        #if defined(QL_USE_STD_UNIQUE_PTR)
        Clone(std::unique_ptr<T>&&);
        #else
        Clone(std::auto_ptr<T>);
        #endif
        Clone(const T&);
        Clone(const Clone<T>&);
        Clone(Clone<T>&&) QL_NOEXCEPT;
        Clone<T>& operator=(const T&);
        Clone<T>& operator=(const Clone<T>&);
        Clone<T>& operator=(Clone<T>&&) QL_NOEXCEPT;
        T& operator*() const;
        T* operator->() const;
        bool empty() const;
        void swap(Clone<T>& t);
      private:
        std::unique_ptr<T> ptr_;
    };

    /*! \relates Clone */
    template <class T>
    void swap(Clone<T>&, Clone<T>&);


    // inline definitions

    #if defined(QL_USE_STD_UNIQUE_PTR)
    template <class T>
    inline Clone<T>::Clone(std::unique_ptr<T>&& p)
    : ptr_(std::move(p)) {}
    #else
    template <class T>
    inline Clone<T>::Clone(std::auto_ptr<T> p)
    : ptr_(std::move(p)) {}
    #endif

    template <class T>
    inline Clone<T>::Clone(const T& t)
    : ptr_(t.clone().release()) {}

    template <class T>
    inline Clone<T>::Clone(const Clone<T>& t)
    : ptr_(t.empty() ? (T*)nullptr : t->clone().release()) {}

    template <class T>
    inline Clone<T>::Clone(Clone<T>&& t) QL_NOEXCEPT {
        swap(t);
    }

    template <class T>
    inline Clone<T>& Clone<T>::operator=(const T& t) {
        #if defined(QL_USE_STD_UNIQUE_PTR)
        ptr_ = t.clone();
        #else
        ptr_.reset(t.clone().release());
        #endif
        return *this;
    }

    template <class T>
    inline Clone<T>& Clone<T>::operator=(const Clone<T>& t) {
        ptr_.reset(t.empty() ? (T*)nullptr : t->clone().release());
        return *this;
    }

    template <class T>
    inline Clone<T>& Clone<T>::operator=(Clone<T>&& t) QL_NOEXCEPT {
        swap(t);
        return *this;
    }

    template <class T>
    inline T& Clone<T>::operator*() const {
        QL_REQUIRE(!this->empty(), "no underlying objects");
        return *(this->ptr_);
    }

    template <class T>
    inline T* Clone<T>::operator->() const {
        return this->ptr_.get();
    }

    template <class T>
    inline bool Clone<T>::empty() const {
        return !ptr_;
    }

    template <class T>
    inline void Clone<T>::swap(Clone<T>& t) {
        this->ptr_.swap(t.ptr_);
    }

    template <class T>
    inline void swap(Clone<T>& t, Clone<T>& u) {
        t.swap(u);
    }

}


#endif
]]></document_content>
  </document>
  <document index="4">
    <source>dataformatters.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/utilities/dataformatters.hpp>
#include <ostream>

namespace QuantLib {

    namespace detail {

        std::ostream& operator<<(std::ostream& out,
                                 const ordinal_holder& holder) {
            Size n = holder.n;
            out << n;
            if (n == Size(11) || n == Size(12) || n == Size(13)) {
                out << "th";
            } else {
                switch (n % 10) {
                  case 1:  out << "st";  break;
                  case 2:  out << "nd";  break;
                  case 3:  out << "rd";  break;
                  default: out << "th";
                }
            }
            return out;
        }

        std::ostream& operator<<(std::ostream& out,
                                 const percent_holder& holder) {
            std::ios::fmtflags flags = out.flags();
            Size width = (Size)out.width();
            if (width > 2)
                out.width(width-2); // eat space used by percent sign
            out << std::fixed;
            if (holder.value == Null<Real>())
                out << "null";
            else
                out << holder.value * 100.0 << " %";
            out.flags(flags);
            return out;
        }

    }

}

]]></document_content>
  </document>
  <document index="5">
    <source>dataformatters.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file dataformatters.hpp
    \brief output manipulators
*/

#ifndef quantlib_data_formatters_hpp
#define quantlib_data_formatters_hpp

#include <ql/utilities/null.hpp>
#include <iosfwd>

namespace QuantLib {

    namespace detail {

        template <typename T> struct null_checker {
            explicit null_checker(T value) : value(value) {}
            T value;
        };
        template <typename T>
        std::ostream& operator<<(std::ostream&, const null_checker<T>&);

        struct ordinal_holder {
            explicit ordinal_holder(Size n) : n(n) {}
            Size n;
        };
        std::ostream& operator<<(std::ostream&, const ordinal_holder&);

        template <typename T> struct power_of_two_holder {
            explicit power_of_two_holder(T n) : n(n) {}
            T n;
        };
        template <typename T>
        std::ostream& operator<<(std::ostream&,
                                 const power_of_two_holder<T>&);

        struct percent_holder {
            explicit percent_holder(Real value) : value(value) {}
            Real value;
        };
        std::ostream& operator<<(std::ostream&, const percent_holder&);

        template <typename InputIterator> struct sequence_holder {
            sequence_holder(InputIterator begin, InputIterator end)
            : begin(begin), end(end) {}
            InputIterator begin, end;
        };
        template <typename I>
        std::ostream& operator<<(std::ostream&, const sequence_holder<I>&);

    }


    namespace io {

        /*! \defgroup manips Output manipulators

            Helper functions for creating formatted output.

            @{
        */

        //! check for nulls before output
        template <typename T>
        detail::null_checker<T> checknull(T);

        //! outputs naturals as 1st, 2nd, 3rd...
        detail::ordinal_holder ordinal(Size);

        //! output integers as powers of two
        template <typename T>
        detail::power_of_two_holder<T> power_of_two(T);

        //! output reals as percentages
        detail::percent_holder percent(Real);

        //! output rates and spreads as percentages
        detail::percent_holder rate(Rate);

        //! output volatilities as percentages
        detail::percent_holder volatility(Volatility);

        //! output STL-compliant containers as space-separated sequences
        template <class Container>
        detail::sequence_holder<typename Container::const_iterator>
        sequence(const Container& c);

        /*! @}  */


        // inline definitions

        template <typename T>
        inline detail::null_checker<T> checknull(T x) {
            return detail::null_checker<T>(x);
        }

        inline detail::ordinal_holder ordinal(Size n) {
            return detail::ordinal_holder(n);
        }

        template <typename T>
        inline detail::power_of_two_holder<T> power_of_two(T n) {
            return detail::power_of_two_holder<T>(n);
        }

        inline detail::percent_holder percent(Real x) {
            return detail::percent_holder(x);
        }

        inline detail::percent_holder rate(Rate r) {
            return detail::percent_holder(r);
        }

        inline detail::percent_holder volatility(Volatility v) {
            return detail::percent_holder(v);
        }

        template <class Container>
        inline detail::sequence_holder<typename Container::const_iterator>
        sequence(const Container& c) {
            return detail::sequence_holder<typename Container::const_iterator>(
                                                           c.begin(), c.end());
        }

    }

    namespace detail {

        template <typename T>
        inline std::ostream& operator<<(std::ostream& out,
                                        const null_checker<T>& checker) {
            if (checker.value == Null<T>())
                return out << "null";
            else
                return out << checker.value;
        }

        template <typename T>
        inline std::ostream& operator<<(std::ostream& out,
                                        const power_of_two_holder<T>& holder) {
            if (holder.n == Null<T>())
                return out << "null";

            T n = holder.n;
            Integer power = 0;
            if (n != 0) {
                while (!(n & 1UL)) {
                    power++;
                    n >>= 1;
                }
            }
            return out << n << "*2^" << power;
        }

        template <typename I>
        inline std::ostream& operator<<(std::ostream& out,
                                        const sequence_holder<I>& holder) {
            out << "( ";
            for (I i = holder.begin; i != holder.end; ++i)
                out << *i << " ";
            out << ")";
            return out;
        }

    }

}


#endif
]]></document_content>
  </document>
  <document index="6">
    <source>dataparsers.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Decillion Pty(Ltd)
 Copyright (C) 2006 Joseph Wang
 Copyright (2) 2009 Mark Joshi
 Copyright (2) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/utilities/dataparsers.hpp>
#include <ql/utilities/null.hpp>
#include <ql/time/period.hpp>
#include <ql/errors.hpp>
#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#endif
#ifndef QL_PATCH_SOLARIS
#include <boost/algorithm/string/case_conv.hpp>
#include <boost/date_time/gregorian/gregorian.hpp>
#endif
#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic pop
#endif
#include <string>
#include <locale>
#include <cctype>
#if defined(BOOST_NO_STDC_NAMESPACE)
    namespace std { using ::toupper; }
#endif

namespace QuantLib {

    Period PeriodParser::parse(const std::string& str) {
        QL_REQUIRE(str.length()>1, "period string length must be at least 2");

        std::vector<std::string > subStrings;
        std::string reducedString = str;

        Size iPos, reducedStringDim = 100000, max_iter = 0;
        while (reducedStringDim>0) {
            iPos = reducedString.find_first_of("DdWwMmYy");
            Size subStringDim = iPos+1;
            reducedStringDim = reducedString.length()-subStringDim;
            subStrings.push_back(reducedString.substr(0, subStringDim));
            reducedString = reducedString.substr(iPos+1, reducedStringDim);
            ++max_iter;
            QL_REQUIRE(max_iter<str.length(), "unknown '" << str << "' unit");
        }

        Period result = parseOnePeriod(subStrings[0]);
        for (Size i=1; i<subStrings.size(); ++i)
            result += parseOnePeriod(subStrings[i]);
        return result;
    }

    Period PeriodParser::parseOnePeriod(const std::string& str) {
        QL_REQUIRE(str.length()>1, "single period require a string of at "
                   "least 2 characters");

        Size iPos = str.find_first_of("DdWwMmYy");
        QL_REQUIRE(iPos==str.length()-1, "unknown '" <<
                   str.substr(str.length()-1, str.length()) << "' unit");
        TimeUnit units = Days;
        char abbr = static_cast<char>(std::toupper(str[iPos]));
        if      (abbr == 'D') units = Days;
        else if (abbr == 'W') units = Weeks;
        else if (abbr == 'M') units = Months;
        else if (abbr == 'Y') units = Years;

        Size nPos = str.find_first_of("-+0123456789");
        QL_REQUIRE(nPos<iPos, "no numbers of " << units << " provided");
        Integer n;
        try {
            n = std::stoi(str.substr(nPos,iPos));
        } catch (std::exception& e) {
            QL_FAIL("unable to parse the number of units of " << units <<
                    " in '" << str << "'. Error:" << e.what());
        }

        return {n, units};
    }

    Date DateParser::parseFormatted(const std::string& str,
                                    const std::string& fmt) {
        #ifndef QL_PATCH_SOLARIS
        using namespace boost::gregorian;

        date boostDate;
        std::istringstream is(str);
        is.imbue(std::locale(std::locale(), new date_input_facet(fmt)));
        is >> boostDate;
        date_duration noDays = boostDate - date(1901, 1, 1);
        return Date(1, January, 1901) + noDays.days();
        #else
        QL_FAIL("DateParser::parseFormatted not supported under Solaris");
        #endif
    }

    Date DateParser::parseISO(const std::string& str) {
        QL_REQUIRE(str.size() == 10 && str[4] == '-' && str[7] == '-',
                   "invalid format");
        Integer year = std::stoi(str.substr(0, 4));
        Month month = static_cast<Month>(std::stoi(str.substr(5, 2)));
        Integer day = std::stoi(str.substr(8, 2));

        return {day, month, year};
    }

}
]]></document_content>
  </document>
  <document index="7">
    <source>dataparsers.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Decillion Pty(Ltd)
 Copyright (C) 2006 Joseph Wang
 Copyright (C) 2009 Mark Joshi
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file dataparsers.hpp
    \brief Classes used to parse data for input
*/

#ifndef quantlib_data_parsers_hpp
#define quantlib_data_parsers_hpp

#include <ql/time/date.hpp>
#include <vector>
#include <string>

namespace QuantLib {

    namespace io {

        /*! \deprecated Use std::stoi instead.
                        Deprecated in version 1.22.
        */
        QL_DEPRECATED
        inline Integer to_integer(const std::string& s) {
            return std::stoi(s);
        }

    }

    class PeriodParser {
      public:
        static Period parse(const std::string& str);
      private:
        static Period parseOnePeriod(const std::string& str);
    };

    class DateParser {
      public:
        //! Parses a string in a used-defined format.
        /*! This method uses the parsing functions from
            Boost.Date_Time and supports the same formats.
        */
        static Date parseFormatted(const std::string& str,
                                   const std::string& fmt);
        static Date parseISO(const std::string& str);
    };

}


#endif
]]></document_content>
  </document>
  <document index="8">
    <source>disposable.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file disposable.hpp
    \brief generic disposable object with move semantics
*/

#ifndef quantlib_disposable_hpp
#define quantlib_disposable_hpp

#include <ql/qldefines.hpp>

namespace QuantLib {

    #ifndef QL_USE_DISPOSABLE

    template <class T>
    using Disposable = T;

    #else

    #pragma message("Warning: enabling the old Disposable class template is deprecated.")
    #pragma message("    If you're using --enable-disposable in your build")
    #pragma message("    or if you defined QL_USE_DISPOSABLE in ql/userconfig.hpp,")
    #pragma message("    please restore the default compilation options in the near future.")

    //! generic disposable object with move semantics
    /*! This class can be used for returning a value by copy. It relies
        on the returned object exposing a <tt>swap(T\&)</tt> method through
        which the copy constructor and assignment operator are implemented,
        thus resulting in actual move semantics. Typical use of this
        class is along the following lines:
        \code
        Disposable<Foo> bar(Integer i) {
            Foo f(i*2);
            return f;
        }
        \endcode

        \warning In order to avoid copies in code such as shown above,
                 the conversion from <tt>T</tt> to <tt>Disposable\<T\></tt>
                 is destructive, i.e., it does <b>not</b> preserve the
                 state of the original object. Therefore, it is necessary
                 for the developer to avoid code such as
        \code
        Disposable<Foo> bar(Foo& f) {
            return f;
        }
        \endcode
                 which would likely render the passed object unusable.
                 The correct way to obtain the desired behavior would be:
        \code
        Disposable<Foo> bar(Foo& f) {
            Foo temp = f;
            return temp;
        }
        \endcode
    */
    template <class T>
    class Disposable : public T {
      public:
        Disposable(T& t);
        Disposable(const Disposable<T>& t);
        Disposable<T>& operator=(const Disposable<T>& t);
    };


    // inline definitions

    template <class T>
    inline Disposable<T>::Disposable(T& t) {
        this->swap(t);
    }

    template <class T>
    inline Disposable<T>::Disposable(const Disposable<T>& t) : T() {
        this->swap(const_cast<Disposable<T>&>(t));
    }

    template <class T>
    inline Disposable<T>& Disposable<T>::operator=(const Disposable<T>& t) {
        this->swap(const_cast<Disposable<T>&>(t));
        return *this;
    }

    #endif

}


#endif
]]></document_content>
  </document>
  <document index="9">
    <source>null.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004 StatPro Italia srl
 Copyright (C) 2010 Kakhkhor Abdijalilov

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file null.hpp
    \brief null values
*/

#ifndef quantlib_null_hpp
#define quantlib_null_hpp

#include <ql/types.hpp>

#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#endif

#include <boost/type_traits.hpp>

#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4))
#pragma GCC diagnostic pop
#endif

namespace QuantLib {

    //! template class providing a null value for a given type.
    template <class Type>
    class Null;


    namespace detail {

        template <bool>
        struct FloatingPointNull;

        // null value for floating-point types
        template <>
        struct FloatingPointNull<true> {
            static float nullValue() {
                return QL_NULL_REAL;
            }
        };

        // null value for integer types
        template <>
        struct FloatingPointNull<false> {
            static int nullValue() {
                return QL_NULL_INTEGER;
            }
        };

    }

    // default implementation for built-in types
    template <typename T>
    class Null {
      public:
        Null() = default;
        operator T() const {
            return T(detail::FloatingPointNull<
                         boost::is_floating_point<T>::value>::nullValue());
        }
    };

}


#endif
]]></document_content>
  </document>
  <document index="10">
    <source>null_deleter.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2016 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file null_deleter.hpp
    \brief empty deleter for shared_ptr
*/

#ifndef quantlib_nulldeleter_hpp
#define quantlib_nulldeleter_hpp

#include <ql/qldefines.hpp>

#if BOOST_VERSION >= 105600

#include <boost/core/null_deleter.hpp>
namespace QuantLib {
using boost::null_deleter;   // NOLINT(misc-unused-using-decls)
}

#else

namespace QuantLib {
struct null_deleter {
    template <typename T> void operator()(T *) const {}
};
}

#endif

#endif
]]></document_content>
  </document>
  <document index="11">
    <source>observablevalue.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file observablevalue.hpp
    \brief observable and assignable proxy to concrete value
*/

#ifndef quantlib_observable_value_hpp
#define quantlib_observable_value_hpp

#include <ql/patterns/observable.hpp>

namespace QuantLib {

    //! %observable and assignable proxy to concrete value
    /*! Observers can be registered with instances of this class so
        that they are notified when a different value is assigned to
        such instances. Client code can copy the contained value or
        pass it to functions via implicit conversion.
        \note it is not possible to call non-const method on the
              returned value. This is by design, as this possibility
              would necessarily bypass the notification code; client
              code should modify the value via re-assignment instead.
    */
    template <class T>
    class ObservableValue {
      public:
        ObservableValue();
        ObservableValue(const T&);
        ObservableValue(const ObservableValue<T>&);
        //! \name controlled assignment
        //@{
        ObservableValue<T>& operator=(const T&);
        ObservableValue<T>& operator=(const ObservableValue<T>&);
        //@}
        //! implicit conversion
        operator T() const;
        operator ext::shared_ptr<Observable>() const;
        //! explicit inspector
        const T& value() const;
      private:
        T value_;
        ext::shared_ptr<Observable> observable_;
    };


    // template definition

    template <class T>
    ObservableValue<T>::ObservableValue()
    : value_(), observable_(new Observable) {}

    template <class T>
    ObservableValue<T>::ObservableValue(const T& t)
    : value_(t), observable_(new Observable) {}

    template <class T>
    ObservableValue<T>::ObservableValue(const ObservableValue<T>& t)
    : value_(t.value_), observable_(new Observable) {}

    template <class T>
    ObservableValue<T>& ObservableValue<T>::operator=(const T& t) {
        value_ = t;
        observable_->notifyObservers();
        return *this;
    }

    template <class T>
    ObservableValue<T>&
    ObservableValue<T>::operator=(const ObservableValue<T>& t) { // NOLINT(bugprone-unhandled-self-assignment)
        value_ = t.value_;
        observable_->notifyObservers();
        return *this;
    }

    template <class T>
    ObservableValue<T>::operator T() const {
        return value_;
    }

    template <class T>
    ObservableValue<T>::operator ext::shared_ptr<Observable>() const {
        return observable_;
    }

    template <class T>
    const T& ObservableValue<T>::value() const {
        return value_;
    }

}

#endif
]]></document_content>
  </document>
  <document index="12">
    <source>steppingiterator.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file steppingiterator.hpp
    \brief Iterator advancing in constant steps
*/

#ifndef quantlib_stepping_iterator_hpp
#define quantlib_stepping_iterator_hpp

#include <ql/types.hpp>
#include <boost/iterator/iterator_adaptor.hpp>

namespace QuantLib {

    //! Iterator advancing in constant steps
    /*! This iterator advances an underlying random-access iterator in
        steps of \f$ n \f$ positions, where \f$ n \f$ is a positive
        integer given upon construction.
    */
    template <class Iterator>
    class step_iterator :
        public boost::iterator_adaptor<step_iterator<Iterator>, Iterator> {
      private:
        typedef boost::iterator_adaptor<step_iterator<Iterator>, Iterator>
                                                                      super_t;
        // a Size would mess up integer division in distance_to
        BigInteger step_;
      public:
        step_iterator() = default;
        explicit step_iterator(const Iterator& base, Size step)
        : super_t(base), step_(static_cast<BigInteger>(step)) {}
        template <class OtherIterator>
        step_iterator(const step_iterator<OtherIterator>& i,
                      typename boost::enable_if_convertible
                      <OtherIterator,Iterator>::type* = 0)
        : super_t(i.base()), step_(static_cast<BigInteger>(i.step())) {}
        // inspector
        Size step() const { return static_cast<Size>(this->step_); }
        // iterator adapter interface
        void increment() {
            std::advance(this->base_reference(), step_);
        }
        void decrement() {
            std::advance(this->base_reference(), -step_);
        }
        void advance(typename super_t::difference_type n) {
            this->base_reference() += n*(this->step_);
        }
        typename super_t::difference_type
        distance_to(const step_iterator& i) const {
            return (i.base()-this->base())/(this->step_);
        }
    };

    //! helper function to create step iterators
    /*! \relates step_iterator */
    template <class Iterator>
    step_iterator<Iterator> make_step_iterator(Iterator it, Size step) {
        return step_iterator<Iterator>(it,step);
    }

}


#endif
]]></document_content>
  </document>
  <document index="13">
    <source>tracing.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/utilities/tracing.hpp>
#include <iostream>

namespace QuantLib {

    // defined here in order not to include the full <iostream> in the header

    namespace detail {

        Tracing::Tracing() : out_(&std::cerr) {}
    }

}

]]></document_content>
  </document>
  <document index="14">
    <source>tracing.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file tracing.hpp
    \brief tracing facilities
*/

#ifndef quantlib_tracing_hpp
#define quantlib_tracing_hpp

#include <ql/types.hpp>
#include <ql/errors.hpp>
#include <ql/patterns/singleton.hpp>
#include <boost/current_function.hpp>
#include <iosfwd>

namespace QuantLib {

    namespace detail {

        class Tracing : public Singleton<Tracing> {
            friend class QuantLib::Singleton<Tracing>;
          private:
            Tracing();  // NOLINT(modernize-use-equals-delete)
          public:
            void enable() {
                #if defined(QL_ENABLE_TRACING)
                enabled_ = true;
                #else
                QL_FAIL("tracing support not available");
                #endif
            }
            void disable() { enabled_ = false; }
            void setStream(std::ostream& stream) { out_ = &stream; }
            bool enabled() const { return enabled_; }
            std::ostream& stream() { return *out_; }
            Integer depth() const { return depth_; }
            void down() { depth_++; }
            void up() { depth_--; }
          private:
            std::ostream* out_;
            bool enabled_ = false;
            Integer depth_ = 0;
        };

    }

}

/*! \addtogroup macros
    @{
*/

/*! \defgroup debugMacros Debugging macros

    For debugging purposes, macros can be used to output information
    about the code being executed.  Instrumenting code as in:
    \code
    namespace Foo {

        int bar(int i) {
            QL_TRACE_ENTER_FUNCTION;
            QL_TRACE_VARIABLE(i);

            if (i == 42) {
                QL_TRACE_LOCATION;
                QL_TRACE("Right answer, but no question");
            } else {
                QL_TRACE_LOCATION;
                QL_TRACE("Wrong answer");
                i *= 2;
            }

            QL_TRACE_VARIABLE(i);
            QL_TRACE_EXIT_FUNCTION;
            return i;
        }

    }
    \endcode
    will output a trace like the following when the code is run:
    \code
    trace[3]: Entering int Foo::bar(int)
    trace[3]: i = 21
    trace[3]: At line 16 in tracing_example.cpp
    trace[3]: Wrong answer
    trace[3]: i = 42
    trace[3]: Exiting int Foo::bar(int)
    \endcode
    (the actual output will depend on the compiler and the file
    names).  A word of warning must be added: adding so much tracing
    to your code might degrade its readability.

    @{
*/

/*! \def QL_TRACE_ENABLE
    \brief enable tracing

    The statement
    \code
    QL_TRACE_ENABLE;
    \endcode
    can be used to enable tracing. Such statement might be
    ignored; refer to QL_TRACE for details.
*/

/*! \def QL_TRACE_DISABLE
    \brief disable tracing

    The statement
    \code
    QL_TRACE_DISABLE;
    \endcode
    can be used to disable tracing. Such statement might be
    ignored; refer to QL_TRACE for details.
*/

/*! \def QL_TRACE_ON
    \brief set tracing stream

    The statement
    \code
    QL_TRACE_ON(stream);
    \endcode
    can be used to set the stream where tracing messages are
    output. Such statement might be ignored; refer to QL_TRACE for
    details.
*/

/*! \def QL_TRACE
    \brief output tracing information

    The statement
    \code
    QL_TRACE(message);
    \endcode
    can be used to output a trace of the code being executed. If
    tracing was disabled during configuration, such statements are
    removed by the preprocessor for maximum performance; if it was
    enabled, whether and where the message is output depends on the
    current settings.
*/

/*! \def QL_TRACE_ENTER_FUNCTION
    \brief output tracing information

    The statement
    \code
    QL_TRACE_ENTER_FUNCTION;
    \endcode
    can be used at the beginning of a function to trace the fact that
    the program execution is entering such function. It should be
    paired with a corresponding QL_TRACE_EXIT_FUNCTION macro. Such
    statement might be ignored; refer to QL_TRACE for details. Also,
    function information might not be available depending on the
    compiler.
*/

/*! \def QL_TRACE_EXIT_FUNCTION
    \brief output tracing information

    The statement
    \code
    QL_TRACE_EXIT_FUNCTION;
    \endcode
    can be used before returning from a function to trace the fact
    that the program execution is exiting such function. It should be
    paired with a corresponding QL_TRACE_ENTER_FUNCTION macro. Such
    statement might be ignored; refer to QL_TRACE for details. Also,
    function information might not be available depending on the
    compiler.
*/

/*! \def QL_TRACE_LOCATION
    \brief output tracing information

    The statement
    \code
    QL_TRACE_LOCATION;
    \endcode
    can be used to trace the current file and line. Such statement
    might be ignored; refer to QL_TRACE for details.
*/

/*! \def QL_TRACE_VARIABLE
    \brief output tracing information

    The statement
    \code
    QL_TRACE_VARIABLE(variable);
    \endcode
    can be used to trace the current value of a variable. Such
    statement might be ignored; refer to QL_TRACE for details. Also,
    the variable type must allow sending it to an output stream.
*/

/*! @} */

/*! @} */

#if defined(QL_ENABLE_TRACING)

#define QL_DEFAULT_TRACER   QuantLib::detail::Tracing::instance()

#define QL_TRACE_ENABLE \
QL_DEFAULT_TRACER.enable()

#define QL_TRACE_DISABLE \
QL_DEFAULT_TRACER.disable()

#define QL_TRACE_ON(out) \
QL_DEFAULT_TRACER.setStream(out)

#define QL_TRACE(message) \
if (QL_DEFAULT_TRACER.enabled()) \
    try { \
        QL_DEFAULT_TRACER.stream() << "trace[" << QL_DEFAULT_TRACER.depth() \
                                   << "]: " << message << std::endl; \
    } catch (...) {} \
else

#define QL_TRACE_ENTER_FUNCTION \
if (QL_DEFAULT_TRACER.enabled()) \
    try { \
        QL_DEFAULT_TRACER.down(); \
        QL_DEFAULT_TRACER.stream() << "trace[" << QL_DEFAULT_TRACER.depth() \
                                   << "]: " \
                                   << "Entering " << BOOST_CURRENT_FUNCTION \
                                   << std::endl; \
    } catch (...) {} \
else

#define QL_TRACE_EXIT_FUNCTION \
if (QL_DEFAULT_TRACER.enabled()) \
    try { \
        QL_DEFAULT_TRACER.stream() << "trace[" << QL_DEFAULT_TRACER.depth() \
                                   << "]: " \
                                   << "Exiting " << BOOST_CURRENT_FUNCTION \
                                   << std::endl; \
        QL_DEFAULT_TRACER.up(); \
    } catch (...) { QL_DEFAULT_TRACER.up(); } \
else

#define QL_TRACE_LOCATION \
QL_TRACE("At line " << __LINE__ << " in " << __FILE__)

#define QL_TRACE_VARIABLE(variable) \
QL_TRACE(#variable << " = " << variable)

#else

#define QL_DEFAULT_TRACER
#define QL_TRACE_ENABLE
#define QL_TRACE_DISABLE
#define QL_TRACE_ON(out)
#define QL_TRACE(message)
#define QL_TRACE_ENTER_FUNCTION
#define QL_TRACE_EXIT_FUNCTION
#define QL_TRACE_LOCATION
#define QL_TRACE_VARIABLE(variable)

#endif

#endif
]]></document_content>
  </document>
  <document index="15">
    <source>vectors.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vectors.hpp
    \brief Utilities for vector manipulation
*/

#ifndef quantlib_utilities_vectors_hpp
#define quantlib_utilities_vectors_hpp

#include <ql/types.hpp>
#include <vector>

namespace QuantLib {

    namespace detail {

        template <class T, class U>
        T get(const std::vector<T>& v,
              Size i,
              U defaultValue) {
            if (v.empty()) {
                return static_cast<T>(defaultValue);
            } else if (i < v.size()) {
                return v[i];
            } else {
                return v.back();
            }
        }

    }

}


#endif
]]></document_content>
  </document>
</documents>