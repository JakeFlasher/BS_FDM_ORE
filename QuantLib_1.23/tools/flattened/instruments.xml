<?xml version="1.0" encoding="UTF-8"?>
<documents>
  <document index="1">
    <source>Makefile.am</source>
    <document_content><![CDATA[
SUBDIRS = bonds

AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    asianoption.hpp \
    assetswap.hpp \
    averagetype.hpp \
    barrieroption.hpp \
    barriertype.hpp \
    basketoption.hpp \
    bmaswap.hpp \
    bond.hpp \
    callabilityschedule.hpp \
    capfloor.hpp \
    claim.hpp \
    cliquetoption.hpp \
    compositeinstrument.hpp \
    cpiswap.hpp \
    cpicapfloor.hpp \
    creditdefaultswap.hpp \
	dividendbarrieroption.hpp \
    dividendschedule.hpp \
    dividendvanillaoption.hpp \
    europeanoption.hpp \
    fixedratebondforward.hpp \
    floatfloatswap.hpp \
    floatfloatswaption.hpp \
    forward.hpp \
    forwardrateagreement.hpp \
    forwardvanillaoption.hpp \
    futures.hpp \
    impliedvolatility.hpp \
    inflationcapfloor.hpp \
    lookbackoption.hpp \
    makecapfloor.hpp \
    makecds.hpp \
    makecms.hpp \
    makeois.hpp \
    makeswaption.hpp \
    makevanillaswap.hpp \
    makeyoyinflationcapfloor.hpp \
    multiassetoption.hpp \
    nonstandardswap.hpp \
    nonstandardswaption.hpp \
    oneassetoption.hpp \
    overnightindexedswap.hpp \
    overnightindexfuture.hpp \
    payoffs.hpp \
    quantobarrieroption.hpp \
    quantoforwardvanillaoption.hpp \
    quantovanillaoption.hpp \
    stickyratchet.hpp \
    stock.hpp \
    swap.hpp \
    swaption.hpp \
    vanillaoption.hpp \
	vanillastorageoption.hpp \
	vanillaswingoption.hpp \
    vanillaswap.hpp \
    varianceswap.hpp \
    yearonyearinflationswap.hpp \
    zerocouponinflationswap.hpp \
    zerocouponswap.hpp

cpp_files = \
    asianoption.cpp \
    assetswap.cpp \
    averagetype.cpp \
    barrieroption.cpp \
    barriertype.cpp \
    basketoption.cpp \
    bmaswap.cpp \
    bond.cpp \
    capfloor.cpp \
    claim.cpp \
    cliquetoption.cpp \
    compositeinstrument.cpp \
    cpiswap.cpp \
    cpicapfloor.cpp \
    creditdefaultswap.cpp \
	dividendbarrieroption.cpp \
    dividendvanillaoption.cpp \
    europeanoption.cpp \
    fixedratebondforward.cpp \
    floatfloatswap.cpp \
    floatfloatswaption.cpp \
    forward.cpp \
    forwardrateagreement.cpp \
    forwardvanillaoption.cpp \
    futures.cpp \
    impliedvolatility.cpp \
    inflationcapfloor.cpp \
    lookbackoption.cpp \
    makecapfloor.cpp \
    makecds.cpp \
    makecms.cpp \
    makeois.cpp \
    makeswaption.cpp \
    makevanillaswap.cpp \
    makeyoyinflationcapfloor.cpp \
    multiassetoption.cpp \
    nonstandardswap.cpp \
    nonstandardswaption.cpp \
    oneassetoption.cpp \
    overnightindexedswap.cpp \
    overnightindexfuture.cpp \
    payoffs.cpp \
    quantobarrieroption.cpp \
    quantoforwardvanillaoption.cpp \
    quantovanillaoption.cpp \
    stickyratchet.cpp \
    stock.cpp \
    swap.cpp \
    swaption.cpp \
    vanillaoption.cpp \
    vanillaswap.cpp \
    vanillaswingoption.cpp \
    varianceswap.cpp \
    yearonyearinflationswap.cpp \
    zerocouponinflationswap.cpp \
    zerocouponswap.cpp

if UNITY_BUILD

nodist_libInstruments_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libInstruments_la_SOURCES = $(cpp_files)

endif

libInstruments_la_LIBADD = \
    bonds/libBonds.la

noinst_LTLIBRARIES = libInstruments.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="2">
    <source>all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/instruments/asianoption.hpp>
#include <ql/instruments/assetswap.hpp>
#include <ql/instruments/averagetype.hpp>
#include <ql/instruments/barrieroption.hpp>
#include <ql/instruments/barriertype.hpp>
#include <ql/instruments/basketoption.hpp>
#include <ql/instruments/bmaswap.hpp>
#include <ql/instruments/bond.hpp>
#include <ql/instruments/callabilityschedule.hpp>
#include <ql/instruments/capfloor.hpp>
#include <ql/instruments/claim.hpp>
#include <ql/instruments/cliquetoption.hpp>
#include <ql/instruments/compositeinstrument.hpp>
#include <ql/instruments/cpiswap.hpp>
#include <ql/instruments/cpicapfloor.hpp>
#include <ql/instruments/creditdefaultswap.hpp>
#include <ql/instruments/dividendbarrieroption.hpp>
#include <ql/instruments/dividendschedule.hpp>
#include <ql/instruments/dividendvanillaoption.hpp>
#include <ql/instruments/europeanoption.hpp>
#include <ql/instruments/fixedratebondforward.hpp>
#include <ql/instruments/floatfloatswap.hpp>
#include <ql/instruments/floatfloatswaption.hpp>
#include <ql/instruments/forward.hpp>
#include <ql/instruments/forwardrateagreement.hpp>
#include <ql/instruments/forwardvanillaoption.hpp>
#include <ql/instruments/futures.hpp>
#include <ql/instruments/impliedvolatility.hpp>
#include <ql/instruments/inflationcapfloor.hpp>
#include <ql/instruments/lookbackoption.hpp>
#include <ql/instruments/makecapfloor.hpp>
#include <ql/instruments/makecds.hpp>
#include <ql/instruments/makecms.hpp>
#include <ql/instruments/makeois.hpp>
#include <ql/instruments/makeswaption.hpp>
#include <ql/instruments/makevanillaswap.hpp>
#include <ql/instruments/makeyoyinflationcapfloor.hpp>
#include <ql/instruments/multiassetoption.hpp>
#include <ql/instruments/nonstandardswap.hpp>
#include <ql/instruments/nonstandardswaption.hpp>
#include <ql/instruments/oneassetoption.hpp>
#include <ql/instruments/overnightindexedswap.hpp>
#include <ql/instruments/overnightindexfuture.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/instruments/quantobarrieroption.hpp>
#include <ql/instruments/quantoforwardvanillaoption.hpp>
#include <ql/instruments/quantovanillaoption.hpp>
#include <ql/instruments/stickyratchet.hpp>
#include <ql/instruments/stock.hpp>
#include <ql/instruments/swap.hpp>
#include <ql/instruments/swaption.hpp>
#include <ql/instruments/vanillaoption.hpp>
#include <ql/instruments/vanillastorageoption.hpp>
#include <ql/instruments/vanillaswingoption.hpp>
#include <ql/instruments/vanillaswap.hpp>
#include <ql/instruments/varianceswap.hpp>
#include <ql/instruments/yearonyearinflationswap.hpp>
#include <ql/instruments/zerocouponinflationswap.hpp>
#include <ql/instruments/zerocouponswap.hpp>

#include <ql/instruments/bonds/all.hpp>
]]></document_content>
  </document>
  <document index="3">
    <source>asianoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/asianoption.hpp>
#include <ql/time/date.hpp>
#include <ql/settings.hpp>
#include <utility>

namespace QuantLib {

    DiscreteAveragingAsianOption::DiscreteAveragingAsianOption(
        Average::Type averageType,
        Real runningAccumulator,
        Size pastFixings,
        std::vector<Date> fixingDates,
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise), averageType_(averageType),
      runningAccumulator_(runningAccumulator), pastFixings_(pastFixings),
      fixingDates_(std::move(fixingDates)), allPastFixingsProvided_(false),
      allPastFixings_(std::vector<Real>()) {
        std::sort(fixingDates_.begin(), fixingDates_.end());

        // Add a hard override to the runningAccumulator if pastFixings is 0
        // (ie. the option is unseasoned)
        if (pastFixings_ == 0) {
            if (averageType == Average::Geometric) {
                runningAccumulator_ = 1.0;
            } else if (averageType == Average::Arithmetic) {
                runningAccumulator_ = 0.0;
            } else {
                QL_FAIL("Unrecognised average type, must be Average::Arithmetic or Average::Geometric");
            }
        }
    }

    DiscreteAveragingAsianOption::DiscreteAveragingAsianOption(
        Average::Type averageType,
        std::vector<Date> fixingDates,
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise,
        std::vector<Real> allPastFixings)
    : OneAssetOption(payoff, exercise), averageType_(averageType), runningAccumulator_(0.0),
      pastFixings_(0), fixingDates_(std::move(std::move(fixingDates))),
      allPastFixingsProvided_(true), allPastFixings_(std::move(allPastFixings)) {}

    void DiscreteAveragingAsianOption::setupArguments(
                                       PricingEngine::arguments* args) const {

        Real runningAccumulator = runningAccumulator_;
        Size pastFixings = pastFixings_;
        std::vector<Date> fixingDates = fixingDates_;

        // If the option was initialised with a list of fixings, before pricing we
        // compare the evaluation date to the fixing dates, and set up the pastFixings,
        // fixingDates, and runningAccumulator accordingly
        if (allPastFixingsProvided_) {
            std::vector<Date> futureFixingDates = std::vector<Date>();
            Date today = Settings::instance().evaluationDate();

            pastFixings = 0;
            for (auto fixingDate : fixingDates_) {
                if (fixingDate < today) {
                    pastFixings += 1;
                } else {
                    futureFixingDates.push_back(fixingDate);
                }
            }
            fixingDates = futureFixingDates;

            if (pastFixings > allPastFixings_.size())
                QL_FAIL("Not enough past fixings have been provided for the required historical fixing dates");

            if (averageType_ == Average::Geometric) {
                runningAccumulator = 1.0;
                for (Size i=0; i<pastFixings; i++)
                    runningAccumulator *= allPastFixings_[i];

            } else if (averageType_ == Average::Arithmetic) {
                runningAccumulator = 0.0;
                for (Size i=0; i<pastFixings; i++)
                    runningAccumulator += allPastFixings_[i];

            } else {
                QL_FAIL("Unrecognised average type, must be Average::Arithmetic or Average::Geometric");
            }

        }

        OneAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<DiscreteAveragingAsianOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->averageType = averageType_;
        moreArgs->runningAccumulator = runningAccumulator;
        moreArgs->pastFixings = pastFixings;
        moreArgs->fixingDates = fixingDates;
    }

    void DiscreteAveragingAsianOption::arguments::validate() const {

        OneAssetOption::arguments::validate();

        QL_REQUIRE(Integer(averageType) != -1, "unspecified average type");
        QL_REQUIRE(pastFixings != Null<Size>(), "null past-fixing number");
        QL_REQUIRE(runningAccumulator != Null<Real>(), "null running product");
        switch (averageType) {
            case Average::Arithmetic:
                QL_REQUIRE(runningAccumulator >= 0.0,
                           "non negative running sum required: "
                           << runningAccumulator << " not allowed");
                break;
            case Average::Geometric:
                QL_REQUIRE(runningAccumulator > 0.0,
                           "positive running product required: "
                           << runningAccumulator << " not allowed");
                break;
            default:
                QL_FAIL("invalid average type");
        }

        // check fixingTimes_ here
    }




    ContinuousAveragingAsianOption::ContinuousAveragingAsianOption(
        Average::Type averageType,
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise),
      averageType_(averageType) {}

    void ContinuousAveragingAsianOption::setupArguments(
                                       PricingEngine::arguments* args) const {

        OneAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<ContinuousAveragingAsianOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->averageType = averageType_;
    }

    void ContinuousAveragingAsianOption::arguments::validate() const {

        OneAssetOption::arguments::validate();

        QL_REQUIRE(Integer(averageType) != -1, "unspecified average type");
    }

}

]]></document_content>
  </document>
  <document index="4">
    <source>asianoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file asianoption.hpp
    \brief Asian option on a single asset
*/

#ifndef quantlib_asian_option_hpp
#define quantlib_asian_option_hpp

#include <ql/instruments/oneassetoption.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/instruments/averagetype.hpp>
#include <ql/time/date.hpp>
#include <vector>

namespace QuantLib {

    //! Continuous-averaging Asian option
    /*! \todo add running average

        \ingroup instruments
    */
    class ContinuousAveragingAsianOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        ContinuousAveragingAsianOption(
                Average::Type averageType,
                const ext::shared_ptr<StrikedTypePayoff>& payoff,
                const ext::shared_ptr<Exercise>& exercise);
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        Average::Type averageType_;
    };

    //! Discrete-averaging Asian option
    /*! \ingroup instruments */
    class DiscreteAveragingAsianOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        /*! This constructor takes the running sum or product of past fixings,
            depending on the average type.  The fixing dates passed here can be
            only the future ones.
        */
        DiscreteAveragingAsianOption(Average::Type averageType,
                                     Real runningAccumulator,
                                     Size pastFixings,
                                     std::vector<Date> fixingDates,
                                     const ext::shared_ptr<StrikedTypePayoff>& payoff,
                                     const ext::shared_ptr<Exercise>& exercise);

        /*! This constructor takes past fixings as a vector, defaulting to an empty
            vector representing an unseasoned option.  This constructor expects *all* fixing dates
            to be provided, including those in the past, and to be already sorted.  During the
            calculations, the option will compare them to the evaluation date to determine which
            are historic; it will then take as many values from allPastFixings as needed and ignore
            the others.  If not enough fixings are provided, it will raise an error.
        */
        DiscreteAveragingAsianOption(Average::Type averageType,
                                     std::vector<Date> fixingDates,
                                     const ext::shared_ptr<StrikedTypePayoff>& payoff,
                                     const ext::shared_ptr<Exercise>& exercise,
                                     std::vector<Real> allPastFixings = std::vector<Real>());

        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        Average::Type averageType_;
        Real runningAccumulator_;
        Size pastFixings_;
        std::vector<Date> fixingDates_;

        // For backwards compatibility with the traditional interface, we keep track of
        // whether this option was initialised using the full array of seasoned fixings
        // (even if empty) or if a pastFixings and a runningAccumulator was provided
        bool allPastFixingsProvided_;
        std::vector<Real> allPastFixings_;
    };

    //! Extra %arguments for single-asset discrete-average Asian option
    class DiscreteAveragingAsianOption::arguments
        : public OneAssetOption::arguments {
      public:
        arguments() : averageType(Average::Type(-1)),
                      runningAccumulator(Null<Real>()),
                      pastFixings(Null<Size>()) {}
        void validate() const override;
        Average::Type averageType;
        Real runningAccumulator;
        Size pastFixings;
        std::vector<Date> fixingDates;
    };

    //! Extra %arguments for single-asset continuous-average Asian option
    class ContinuousAveragingAsianOption::arguments
        : public OneAssetOption::arguments {
      public:
        arguments() : averageType(Average::Type(-1)) {}
        void validate() const override;
        Average::Type averageType;
    };

    //! Discrete-averaging Asian %engine base class
    class DiscreteAveragingAsianOption::engine
        : public GenericEngine<DiscreteAveragingAsianOption::arguments,
                               DiscreteAveragingAsianOption::results> {};

    //! Continuous-averaging Asian %engine base class
    class ContinuousAveragingAsianOption::engine
        : public GenericEngine<ContinuousAveragingAsianOption::arguments,
                               ContinuousAveragingAsianOption::results> {};

}


#endif
]]></document_content>
  </document>
  <document index="5">
    <source>assetswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Chiara Fornarola
 Copyright (C) 2007, 2009, 2011 Ferdinando Ametrano
 Copyright (C) 2007, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/instruments/assetswap.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <utility>

using std::vector;

namespace QuantLib {

    AssetSwap::AssetSwap(bool parSwap,
                         ext::shared_ptr<Bond> bond,
                         Real bondCleanPrice,
                         Real nonParRepayment,
                         Real gearing,
                         const ext::shared_ptr<IborIndex>& iborIndex,
                         Spread spread,
                         const DayCounter& floatingDayCounter,
                         Date dealMaturity,
                         bool payBondCoupon)
    : Swap(2), bond_(std::move(bond)), bondCleanPrice_(bondCleanPrice),
      nonParRepayment_(nonParRepayment), spread_(spread), parSwap_(parSwap) {
        Schedule tempSch(bond_->settlementDate(),
                         bond_->maturityDate(),
                         iborIndex->tenor(),
                         iborIndex->fixingCalendar(),
                         iborIndex->businessDayConvention(),
                         iborIndex->businessDayConvention(),
                         DateGeneration::Backward,
                         false); // endOfMonth
        if (dealMaturity==Date())
            dealMaturity = bond_->maturityDate();
        QL_REQUIRE(dealMaturity <= tempSch.dates().back(),
                   "deal maturity " << dealMaturity <<
                   " cannot be later than (adjusted) bond maturity " <<
                   tempSch.dates().back());
        QL_REQUIRE(dealMaturity > tempSch.dates()[0],
                   "deal maturity " << dealMaturity <<
                   " must be later than swap start date " <<
                   tempSch.dates()[0]);

        // the following might become an input parameter
        BusinessDayConvention paymentAdjustment = Following;

        Date finalDate = tempSch.calendar().adjust(
            dealMaturity, paymentAdjustment);
        Schedule schedule = tempSch.until(finalDate);

        // bondCleanPrice must be the (forward) clean price
        // at the floating schedule start date
        upfrontDate_ = schedule.startDate();
        Real dirtyPrice = bondCleanPrice_ +
                          bond_->accruedAmount(upfrontDate_);

        Real notional = bond_->notional(upfrontDate_);
        /* In the market asset swap, the bond is purchased in return for
           payment of the full price. The notional of the floating leg is
           then scaled by the full price. */
        if (!parSwap_)
            notional *= dirtyPrice/100.0;

        if (floatingDayCounter==DayCounter())
            legs_[1] = IborLeg(schedule, iborIndex)
                .withNotionals(notional)
                .withPaymentAdjustment(paymentAdjustment)
                .withGearings(gearing)
                .withSpreads(spread);
        else
            legs_[1] = IborLeg(schedule, iborIndex)
                .withNotionals(notional)
                .withPaymentDayCounter(floatingDayCounter)
                .withPaymentAdjustment(paymentAdjustment)
                .withGearings(gearing)
                .withSpreads(spread);

        Leg::const_iterator i;
        for (i=legs_[1].begin(); i<legs_[1].end(); ++i)
            registerWith(*i);

        const Leg& bondLeg = bond_->cashflows();
        // skip bond redemption
        for (i = bondLeg.begin(); i<bondLeg.end()-1 && (*i)->date()<=dealMaturity; ++i) {
            // whatever might be the choice for the discounting engine
            // bond flows on upfrontDate_ must be discarded
            bool upfrontDateBondFlows = false;
            if (!(*i)->hasOccurred(upfrontDate_, upfrontDateBondFlows))
                legs_[0].push_back(*i);
        }
        // if the first skipped cashflow is not the redemption
        // and it is a coupon then add the accrued coupon
        if (i<bondLeg.end()-1) {
            ext::shared_ptr<Coupon> c = ext::dynamic_pointer_cast<Coupon>(*i);
            if (c != nullptr) {
                ext::shared_ptr<CashFlow> accruedCoupon(new
                    SimpleCashFlow(c->accruedAmount(dealMaturity), finalDate));
                legs_[0].push_back(accruedCoupon);
            }
        }
        // add the nonParRepayment_
        ext::shared_ptr<CashFlow> nonParRepaymentFlow(new
            SimpleCashFlow(nonParRepayment_, finalDate));
        legs_[0].push_back(nonParRepaymentFlow);

        QL_REQUIRE(!legs_[0].empty(),
                   "empty bond leg to start with");

        // special flows
        if (parSwap_) {
            // upfront on the floating leg
            Real upfront = (dirtyPrice-100.0)/100.0*notional;
            ext::shared_ptr<CashFlow> upfrontCashFlow(new
                SimpleCashFlow(upfront, upfrontDate_));
            legs_[1].insert(legs_[1].begin(), upfrontCashFlow);
            // backpayment on the floating leg
            // (accounts for non-par redemption, if any)
            Real backPayment = notional;
            ext::shared_ptr<CashFlow> backPaymentCashFlow(new
                SimpleCashFlow(backPayment, finalDate));
            legs_[1].push_back(backPaymentCashFlow);
        } else {
            // final notional exchange
            ext::shared_ptr<CashFlow> finalCashFlow (new
                SimpleCashFlow(notional, finalDate));
            legs_[1].push_back(finalCashFlow);
        }

        QL_REQUIRE(!legs_[0].empty(), "empty bond leg");
        for (i=legs_[0].begin(); i<legs_[0].end(); ++i)
            registerWith(*i);

        if (payBondCoupon) {
            payer_[0]=-1.0;
            payer_[1]=+1.0;
        } else {
            payer_[0]=+1.0;
            payer_[1]=-1.0;
        }
    }

    AssetSwap::AssetSwap(bool payBondCoupon,
                         ext::shared_ptr<Bond> bond,
                         Real bondCleanPrice,
                         const ext::shared_ptr<IborIndex>& iborIndex,
                         Spread spread,
                         const Schedule& floatSchedule,
                         const DayCounter& floatingDayCounter,
                         bool parSwap)
    : Swap(2), bond_(std::move(bond)), bondCleanPrice_(bondCleanPrice), nonParRepayment_(100),
      spread_(spread), parSwap_(parSwap) {
        Schedule schedule = floatSchedule;
        if (floatSchedule.empty())
            schedule = Schedule(bond_->settlementDate(),
                                bond_->maturityDate(),
                                iborIndex->tenor(),
                                iborIndex->fixingCalendar(),
                                iborIndex->businessDayConvention(),
                                iborIndex->businessDayConvention(),
                                DateGeneration::Backward,
                                false); // endOfMonth

        // the following might become an input parameter
        BusinessDayConvention paymentAdjustment = Following;

        Date finalDate = schedule.calendar().adjust(
            schedule.endDate(), paymentAdjustment);
        Date adjBondMaturityDate = schedule.calendar().adjust(
            bond_->maturityDate(), paymentAdjustment);

        QL_REQUIRE(finalDate==adjBondMaturityDate,
                   "adjusted schedule end date (" <<
                   finalDate <<
                   ") must be equal to adjusted bond maturity date (" <<
                   adjBondMaturityDate << ")");

        // bondCleanPrice must be the (forward) clean price
        // at the floating schedule start date
        upfrontDate_ = schedule.startDate();
        Real dirtyPrice = bondCleanPrice_ +
                          bond_->accruedAmount(upfrontDate_);

        Real notional = bond_->notional(upfrontDate_);
        /* In the market asset swap, the bond is purchased in return for
           payment of the full price. The notional of the floating leg is
           then scaled by the full price. */
        if (!parSwap_)
            notional *= dirtyPrice/100.0;

        if (floatingDayCounter==DayCounter())
            legs_[1] = IborLeg(schedule, iborIndex)
                .withNotionals(notional)
                .withPaymentAdjustment(paymentAdjustment)
                .withSpreads(spread);
        else
            legs_[1] = IborLeg(schedule, iborIndex)
                .withNotionals(notional)
                .withPaymentDayCounter(floatingDayCounter)
                .withPaymentAdjustment(paymentAdjustment)
                .withSpreads(spread);

        for (Leg::const_iterator i=legs_[1].begin(); i<legs_[1].end(); ++i)
            registerWith(*i);

        const Leg& bondLeg = bond_->cashflows();
        for (auto i = bondLeg.begin(); i < bondLeg.end(); ++i) {
            // whatever might be the choice for the discounting engine
            // bond flows on upfrontDate_ must be discarded
            bool upfrontDateBondFlows = false;
            if (!(*i)->hasOccurred(upfrontDate_, upfrontDateBondFlows))
                legs_[0].push_back(*i);
        }

        QL_REQUIRE(!legs_[0].empty(),
                   "empty bond leg to start with");

        // special flows
        if (parSwap_) {
            // upfront on the floating leg
            Real upfront = (dirtyPrice-100.0)/100.0*notional;
            ext::shared_ptr<CashFlow> upfrontCashFlow(new
                SimpleCashFlow(upfront, upfrontDate_));
            legs_[1].insert(legs_[1].begin(), upfrontCashFlow);
            // backpayment on the floating leg
            // (accounts for non-par redemption, if any)
            Real backPayment = notional;
            ext::shared_ptr<CashFlow> backPaymentCashFlow(new
                SimpleCashFlow(backPayment, finalDate));
            legs_[1].push_back(backPaymentCashFlow);
        } else {
            // final notional exchange
            ext::shared_ptr<CashFlow> finalCashFlow(new
                SimpleCashFlow(notional, finalDate));
            legs_[1].push_back(finalCashFlow);
        }

        QL_REQUIRE(!legs_[0].empty(), "empty bond leg");
        for (Leg::const_iterator i=legs_[0].begin(); i<legs_[0].end(); ++i)
            registerWith(*i);

        if (payBondCoupon) {
            payer_[0]=-1.0;
            payer_[1]=+1.0;
        } else {
            payer_[0]=+1.0;
            payer_[1]=-1.0;
        }
    }

    void AssetSwap::setupArguments(PricingEngine::arguments* args) const {

        Swap::setupArguments(args);

        auto* arguments = dynamic_cast<AssetSwap::arguments*>(args);

        if (arguments == nullptr) // it's a swap engine...
            return;

        const Leg& fixedCoupons = bondLeg();

        arguments->fixedResetDates = arguments->fixedPayDates =
            vector<Date>(fixedCoupons.size());
        arguments->fixedCoupons = vector<Real>(fixedCoupons.size());

        for (Size i=0; i<fixedCoupons.size(); ++i) {
            ext::shared_ptr<FixedRateCoupon> coupon =
                ext::dynamic_pointer_cast<FixedRateCoupon>(fixedCoupons[i]);

            arguments->fixedPayDates[i] = coupon->date();
            arguments->fixedResetDates[i] = coupon->accrualStartDate();
            arguments->fixedCoupons[i] = coupon->amount();
        }

        const Leg& floatingCoupons = floatingLeg();

        arguments->floatingResetDates = arguments->floatingPayDates =
            arguments->floatingFixingDates =
            vector<Date>(floatingCoupons.size());
        arguments->floatingAccrualTimes =
            vector<Time>(floatingCoupons.size());
        arguments->floatingSpreads =
            vector<Spread>(floatingCoupons.size());

        for (Size i=0; i<floatingCoupons.size(); ++i) {
            ext::shared_ptr<FloatingRateCoupon> coupon =
                ext::dynamic_pointer_cast<FloatingRateCoupon>(floatingCoupons[i]);

            arguments->floatingResetDates[i] = coupon->accrualStartDate();
            arguments->floatingPayDates[i] = coupon->date();
            arguments->floatingFixingDates[i] = coupon->fixingDate();
            arguments->floatingAccrualTimes[i] = coupon->accrualPeriod();
            arguments->floatingSpreads[i] = coupon->spread();
        }
    }

    Spread AssetSwap::fairSpread() const {
        static const Spread basisPoint = 1.0e-4;
        calculate();
        if (fairSpread_ != Null<Spread>()) {
            return fairSpread_;
        } else if (legBPS_.size() > 1 && legBPS_[1] != Null<Spread>()) {
            fairSpread_ = spread_ - NPV_/legBPS_[1]*basisPoint;
            return fairSpread_;
        } else {
            QL_FAIL("fair spread not available");
        }
    }

    Real AssetSwap::floatingLegBPS() const {
        calculate();
        QL_REQUIRE(legBPS_.size() > 1 && legBPS_[1] != Null<Real>(),
                   "floating-leg BPS not available");
        return legBPS_[1];
    }

    Real AssetSwap::floatingLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_.size() > 1 && legNPV_[1] != Null<Real>(),
                   "floating-leg NPV not available");
        return legNPV_[1];
    }

    Real AssetSwap::fairCleanPrice() const {
        calculate();
        if (fairCleanPrice_ != Null<Real>()) {
            return fairCleanPrice_;
        } else {
            QL_REQUIRE(startDiscounts_[1]!=Null<DiscountFactor>(),
                       "fair clean price not available for seasoned deal");
            Real notional = bond_->notional(upfrontDate_);
            if (parSwap_) {
                fairCleanPrice_ = bondCleanPrice_ - payer_[1] *
                    NPV_*npvDateDiscount_/startDiscounts_[1]/(notional/100.0);
            } else {
                Real accruedAmount = bond_->accruedAmount(upfrontDate_);
                Real dirtyPrice = bondCleanPrice_ + accruedAmount;
                Real fairDirtyPrice = - legNPV_[0]/legNPV_[1] * dirtyPrice;
                fairCleanPrice_ = fairDirtyPrice - accruedAmount;
            }

            return fairCleanPrice_;
        }
    }

    Real AssetSwap::fairNonParRepayment() const {
        calculate();
        if (fairNonParRepayment_ != Null<Real>()) {
            return fairNonParRepayment_;
        } else {
            QL_REQUIRE(endDiscounts_[1]!=Null<DiscountFactor>(),
                       "fair non par repayment not available for expired leg");
            Real notional = bond_->notional(upfrontDate_);
            fairNonParRepayment_ = nonParRepayment_ - payer_[0] * 
                NPV_*npvDateDiscount_/endDiscounts_[1]/(notional/100.0);
            return fairNonParRepayment_;
        }
    }

    void AssetSwap::setupExpired() const {
        Swap::setupExpired();
        fairSpread_ = Null<Spread>();
        fairCleanPrice_ = Null<Real>();
        fairNonParRepayment_ = Null<Real>();
    }

    void AssetSwap::fetchResults(const PricingEngine::results* r) const {
        Swap::fetchResults(r);
        const auto* results = dynamic_cast<const AssetSwap::results*>(r);
        if (results != nullptr) {
            fairSpread_ = results->fairSpread;
            fairCleanPrice_= results->fairCleanPrice;
            fairNonParRepayment_= results->fairNonParRepayment;
        } else {
            fairSpread_ = Null<Spread>();
            fairCleanPrice_ = Null<Real>();
            fairNonParRepayment_ = Null<Real>();
        }
    }

    void AssetSwap::arguments::validate() const {
        QL_REQUIRE(fixedResetDates.size() == fixedPayDates.size(),
                   "number of fixed start dates different from "
                   "number of fixed payment dates");
        QL_REQUIRE(fixedPayDates.size() == fixedCoupons.size(),
                   "number of fixed payment dates different from "
                   "number of fixed coupon amounts");
        QL_REQUIRE(floatingResetDates.size() == floatingPayDates.size(),
                   "number of floating start dates different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingFixingDates.size() == floatingPayDates.size(),
                   "number of floating fixing dates different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingAccrualTimes.size() == floatingPayDates.size(),
                   "number of floating accrual times different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingSpreads.size() == floatingPayDates.size(),
                   "number of floating spreads different from "
                   "number of floating payment dates");
    }

    void AssetSwap::results::reset() {
        Swap::results::reset();
        fairSpread = Null<Spread>();
        fairCleanPrice = Null<Real>();
        fairNonParRepayment = Null<Real>();
    }

}
]]></document_content>
  </document>
  <document index="6">
    <source>assetswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Chiara Fornarola
 Copyright (C) 2007, 2009, 2011 Ferdinando Ametrano
 Copyright (C) 2007, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file assetswap.hpp
    \brief Bullet bond vs Libor swap
*/

#ifndef quantlib_asset_swap_hpp
#define quantlib_asset_swap_hpp

#include <ql/instruments/swap.hpp>
#include <ql/instruments/bond.hpp>
#include <ql/time/schedule.hpp>
#include <ql/time/daycounter.hpp>

namespace QuantLib {

    class IborIndex;

    //! Bullet bond vs %Libor swap
    /*! for mechanics of par asset swap and market asset swap, refer to
        "Introduction to Asset Swap", Lehman Brothers European Fixed
        Income Research - January 2000, D. O'Kane

        \ingroup instruments

        \warning bondCleanPrice must be the (forward) price at the
                 floatSchedule start date

        \bug fair prices are not calculated correctly when using
             indexed coupons.
    */
    class AssetSwap : public Swap {
      public:
        class arguments;
        class results;

        AssetSwap(bool payBondCoupon,
                  ext::shared_ptr<Bond> bond,
                  Real bondCleanPrice,
                  const ext::shared_ptr<IborIndex>& iborIndex,
                  Spread spread,
                  const Schedule& floatSchedule = Schedule(),
                  const DayCounter& floatingDayCount = DayCounter(),
                  bool parAssetSwap = true);

        AssetSwap(bool parAssetSwap,
                  ext::shared_ptr<Bond> bond,
                  Real bondCleanPrice,
                  Real nonParRepayment,
                  Real gearing,
                  const ext::shared_ptr<IborIndex>& iborIndex,
                  Spread spread = 0.0,
                  const DayCounter& floatingDayCount = DayCounter(),
                  Date dealMaturity = Date(),
                  bool payBondCoupon = false);
        // results
        Spread fairSpread() const;
        Real floatingLegBPS() const;
        Real floatingLegNPV() const;
        Real fairCleanPrice() const;
        Real fairNonParRepayment() const;
        // inspectors
        bool parSwap() const { return parSwap_; }
        Spread spread() const { return spread_; }
        Real cleanPrice() const { return bondCleanPrice_; }
        Real nonParRepayment() const { return nonParRepayment_; }
        const ext::shared_ptr<Bond>& bond() const { return bond_; }
        bool payBondCoupon() const { return (payer_[0] == -1.0); }
        const Leg& bondLeg() const { return legs_[0]; }
        const Leg& floatingLeg() const { return legs_[1]; }
        // other
        void setupArguments(PricingEngine::arguments* args) const override;
        void fetchResults(const PricingEngine::results*) const override;

      private:
        void setupExpired() const override;
        ext::shared_ptr<Bond> bond_;
        Real bondCleanPrice_, nonParRepayment_;
        Spread spread_;
        bool parSwap_;
        Date upfrontDate_;
        // results
        mutable Spread fairSpread_;
        mutable Real fairCleanPrice_, fairNonParRepayment_;
    };


    //! %Arguments for asset swap calculation
    class AssetSwap::arguments : public Swap::arguments {
      public:
        arguments() = default;
        std::vector<Date> fixedResetDates;
        std::vector<Date> fixedPayDates;
        std::vector<Real> fixedCoupons;
        std::vector<Time> floatingAccrualTimes;
        std::vector<Date> floatingResetDates;
        std::vector<Date> floatingFixingDates;
        std::vector<Date> floatingPayDates;
        std::vector<Spread> floatingSpreads;
        void validate() const override;
    };

    //! %Results from simple swap calculation
    class AssetSwap::results : public Swap::results {
      public:
        Spread fairSpread;
        Real fairCleanPrice, fairNonParRepayment;
        void reset() override;
    };

}

#endif
]]></document_content>
  </document>
  <document index="7">
    <source>averagetype.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Neil Firth
 Copyright (C) 2003, 2004, 2007 Ferdinando Ametrano
 Copyright (C) 2003, 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/averagetype.hpp>
#include <ql/types.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    std::ostream& operator<<(std::ostream& out,
                             Average::Type type) {
        switch (type) {
          case Average::Arithmetic:
            return out << "Arithmetic";
          case Average::Geometric:
            return out << "Geometric";
          default:
            QL_FAIL("unknown Average::Type (" << Integer(type) << ")");
        }
    }

}
]]></document_content>
  </document>
  <document index="8">
    <source>averagetype.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004, 2007 Ferdinando Ametrano
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file averagetype.hpp
    \brief Averaging algorithm enumeration
*/

#ifndef quantlib_average_type_hpp
#define quantlib_average_type_hpp

#include <ql/qldefines.hpp>
#include <iosfwd>

namespace QuantLib {

    //! Placeholder for enumerated averaging types
    struct Average {
        enum Type { Arithmetic, Geometric };
    };

    std::ostream& operator<<(std::ostream& out,
                             Average::Type type);

}

#endif
]]></document_content>
  </document>
  <document index="9">
    <source>barrieroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Neil Firth
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/barrieroption.hpp>
#include <ql/instruments/impliedvolatility.hpp>
#include <ql/pricingengines/barrier/analyticbarrierengine.hpp>
#include <ql/exercise.hpp>
#include <memory>

namespace QuantLib {

    BarrierOption::BarrierOption(
        Barrier::Type barrierType,
        Real barrier,
        Real rebate,
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise),
      barrierType_(barrierType), barrier_(barrier), rebate_(rebate) {}

    void BarrierOption::setupArguments(PricingEngine::arguments* args) const {

        OneAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<BarrierOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->barrierType = barrierType_;
        moreArgs->barrier = barrier_;
        moreArgs->rebate = rebate_;
    }


    Volatility BarrierOption::impliedVolatility(
             Real targetValue,
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             Real accuracy,
             Size maxEvaluations,
             Volatility minVol,
             Volatility maxVol) const {

        QL_REQUIRE(!isExpired(), "option expired");

        ext::shared_ptr<SimpleQuote> volQuote(new SimpleQuote);

        ext::shared_ptr<GeneralizedBlackScholesProcess> newProcess =
            detail::ImpliedVolatilityHelper::clone(process, volQuote);

        // engines are built-in for the time being
        std::unique_ptr<PricingEngine> engine;
        switch (exercise_->type()) {
          case Exercise::European:
            engine.reset(new AnalyticBarrierEngine(newProcess));
            break;
          case Exercise::American:
          case Exercise::Bermudan:
            QL_FAIL("engine not available for non-European barrier option");
            break;
          default:
            QL_FAIL("unknown exercise type");
        }

        return detail::ImpliedVolatilityHelper::calculate(*this,
                                                          *engine,
                                                          *volQuote,
                                                          targetValue,
                                                          accuracy,
                                                          maxEvaluations,
                                                          minVol, maxVol);
    }


    BarrierOption::arguments::arguments()
    : barrierType(Barrier::Type(-1)), barrier(Null<Real>()),
      rebate(Null<Real>()) {}

    void BarrierOption::arguments::validate() const {
        OneAssetOption::arguments::validate();

        switch (barrierType) {
          case Barrier::DownIn:
          case Barrier::UpIn:
          case Barrier::DownOut:
          case Barrier::UpOut:
            break;
          default:
            QL_FAIL("unknown type");
        }

        QL_REQUIRE(barrier != Null<Real>(), "no barrier given");
        QL_REQUIRE(rebate != Null<Real>(), "no rebate given");
    }

    bool BarrierOption::engine::triggered(Real underlying) const {
        switch (arguments_.barrierType) {
          case Barrier::DownIn:
          case Barrier::DownOut:
            return underlying < arguments_.barrier;
          case Barrier::UpIn:
          case Barrier::UpOut:
            return underlying > arguments_.barrier;
          default:
            QL_FAIL("unknown type");
        }
    }

}

]]></document_content>
  </document>
  <document index="10">
    <source>barrieroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Neil Firth
 Copyright (C) 2003, 2004 Ferdinando Ametrano
 Copyright (C) 2003, 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file barrieroption.hpp
    \brief Barrier option on a single asset
*/

#ifndef quantlib_barrier_option_hpp
#define quantlib_barrier_option_hpp

#include <ql/instruments/oneassetoption.hpp>
#include <ql/instruments/barriertype.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    class GeneralizedBlackScholesProcess;

    //! %Barrier option on a single asset.
    /*! The analytic pricing engine will be used if none if passed.

        \ingroup instruments
    */
    class BarrierOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        BarrierOption(Barrier::Type barrierType,
                      Real barrier,
                      Real rebate,
                      const ext::shared_ptr<StrikedTypePayoff>& payoff,
                      const ext::shared_ptr<Exercise>& exercise);
        void setupArguments(PricingEngine::arguments*) const override;
        /*! \warning see VanillaOption for notes on implied-volatility
                     calculation.
        */
        Volatility impliedVolatility(
             Real price,
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             Real accuracy = 1.0e-4,
             Size maxEvaluations = 100,
             Volatility minVol = 1.0e-7,
             Volatility maxVol = 4.0) const;
      protected:
        // arguments
        Barrier::Type barrierType_;
        Real barrier_;
        Real rebate_;
    };

    //! %Arguments for barrier option calculation
    class BarrierOption::arguments : public OneAssetOption::arguments {
      public:
        arguments();
        Barrier::Type barrierType;
        Real barrier;
        Real rebate;
        void validate() const override;
    };

    //! %Barrier-option %engine base class
    class BarrierOption::engine
        : public GenericEngine<BarrierOption::arguments,
                               BarrierOption::results> {
      protected:
        bool triggered(Real underlying) const;
    };

}

#endif
]]></document_content>
  </document>
  <document index="11">
    <source>barriertype.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Neil Firth
 Copyright (C) 2003, 2004, 2007 Ferdinando Ametrano
 Copyright (C) 2003, 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/barriertype.hpp>
#include <ql/types.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    std::ostream& operator<<(std::ostream& out,
                             Barrier::Type type) {
        switch (type) {
          case Barrier::DownIn:
            return out << "Down&In";
          case Barrier::UpIn:
            return out << "Up&In";
          case Barrier::DownOut:
            return out << "Down&Out";
          case Barrier::UpOut:
            return out << "Up&Out";
          default:
            QL_FAIL("unknown Barrier::Type (" << Integer(type) << ")");
        }
    }

}
]]></document_content>
  </document>
  <document index="12">
    <source>barriertype.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004 Neil Firth
 Copyright (C) 2003, 2004, 2007 Ferdinando Ametrano
 Copyright (C) 2003, 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file barriertype.hpp
    \brief Barrier type
*/

#ifndef quantlib_barrier_type_hpp
#define quantlib_barrier_type_hpp

#include <ql/qldefines.hpp>
#include <iosfwd>

namespace QuantLib {

    //! Placeholder for enumerated barrier types
    struct Barrier {
        enum Type { DownIn, UpIn, DownOut, UpOut };
    };

    std::ostream& operator<<(std::ostream& out,
                             Barrier::Type type);

}

#endif
]]></document_content>
  </document>
  <document index="13">
    <source>basketoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Neil Firth
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2007 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/basketoption.hpp>

namespace QuantLib {

    BasketOption::BasketOption(
        const ext::shared_ptr<BasketPayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : MultiAssetOption(payoff, exercise) {}

}

]]></document_content>
  </document>
  <document index="14">
    <source>basketoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Neil Firth
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2007 Joseph Wang

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file basketoption.hpp
    \brief Basket option on a number of assets
*/

#ifndef quantlib_basket_option_hpp
#define quantlib_basket_option_hpp

#include <ql/instruments/multiassetoption.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/math/array.hpp>
#include <utility>

namespace QuantLib {

    class BasketPayoff : public Payoff {
      private:
        ext::shared_ptr<Payoff> basePayoff_;
      public:
        explicit BasketPayoff(ext::shared_ptr<Payoff> p) : basePayoff_(std::move(p)) {}
        ~BasketPayoff() override = default;
        std::string name() const override { return basePayoff_->name(); }
        std::string description() const override { return basePayoff_->description(); }
        Real operator()(Real price) const override { return (*basePayoff_)(price); }
        virtual Real operator()(const Array &a) const {
            return (*basePayoff_)(accumulate(a));
        }
        virtual Real accumulate(const Array &a) const = 0;
        ext::shared_ptr<Payoff> basePayoff() { return basePayoff_; }
    };

    class MinBasketPayoff : public BasketPayoff {
      public:
        explicit MinBasketPayoff(const ext::shared_ptr<Payoff> &p)
        : BasketPayoff(p) {}
        Real accumulate(const Array& a) const override {
            return *std::min_element(a.begin(), a.end());
        }
    };

    class MaxBasketPayoff : public BasketPayoff {
      public:
        explicit MaxBasketPayoff(const ext::shared_ptr<Payoff> &p)
        : BasketPayoff(p) {}
        Real accumulate(const Array& a) const override {
            return *std::max_element(a.begin(), a.end());
        }
    };

    class AverageBasketPayoff : public BasketPayoff {
      public:
        AverageBasketPayoff(const ext::shared_ptr<Payoff>& p, Array a)
        : BasketPayoff(p), weights_(std::move(a)) {}
        AverageBasketPayoff(const ext::shared_ptr<Payoff> &p,
                            Size n)
        : BasketPayoff(p), weights_(n, 1.0/static_cast<Real>(n)) {}
        Real accumulate(const Array& a) const override {
            return std::inner_product(weights_.begin(),
                                      weights_.end(),
                                      a.begin(), 0.0);
        }

      private:
        Array weights_;
    };


    class SpreadBasketPayoff : public BasketPayoff {
      public:
        explicit SpreadBasketPayoff(const ext::shared_ptr<Payoff> &p)
        : BasketPayoff(p) {}
        Real accumulate(const Array& a) const override {
            QL_REQUIRE(a.size() == 2, 
                    "payoff is only defined for two underlyings");
            return a[0]-a[1];
        }
    };
    
    //! Basket option on a number of assets
    /*! \ingroup instruments */
    class BasketOption : public MultiAssetOption {
      public:
        class engine;
        BasketOption(const ext::shared_ptr<BasketPayoff>&,
                     const ext::shared_ptr<Exercise>&);
    };

    //! %Basket-option %engine base class
    class BasketOption::engine
        : public GenericEngine<BasketOption::arguments,
                               BasketOption::results> {};

}


#endif

]]></document_content>
  </document>
  <document index="15">
    <source>bmaswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Roland Lichters
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/bmaswap.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/averagebmacoupon.hpp>

namespace QuantLib {

    BMASwap::BMASwap(Type type,
                     Real nominal,
                     // Libor leg
                     const Schedule& liborSchedule,
                     Real liborFraction,
                     Spread liborSpread,
                     const ext::shared_ptr<IborIndex>& liborIndex,
                     const DayCounter& liborDayCount,
                     // BMA leg
                     const Schedule& bmaSchedule,
                     const ext::shared_ptr<BMAIndex>& bmaIndex,
                     const DayCounter& bmaDayCount)
    : Swap(2), type_(type), nominal_(nominal),
      liborFraction_(liborFraction), liborSpread_(liborSpread)  {

        BusinessDayConvention convention =
            liborSchedule.businessDayConvention();

        legs_[0] = IborLeg(liborSchedule, liborIndex)
            .withNotionals(nominal)
            .withPaymentDayCounter(liborDayCount)
            .withPaymentAdjustment(convention)
            .withFixingDays(liborIndex->fixingDays())
            .withGearings(liborFraction)
            .withSpreads(liborSpread);

        legs_[1] = AverageBMALeg(bmaSchedule, bmaIndex)
            .withNotionals(nominal)
            .withPaymentDayCounter(bmaDayCount)
            .withPaymentAdjustment(bmaSchedule.businessDayConvention());

        for (Size j=0; j<2; ++j) {
            for (auto& i : legs_[j])
                registerWith(i);
        }

        switch (type_) {
          case Payer:
            payer_[0] = +1.0;
            payer_[1] = -1.0;
            break;
          case Receiver:
            payer_[0] = -1.0;
            payer_[1] = +1.0;
            break;
          default:
            QL_FAIL("Unknown BMA-swap type");
        }
    }

    Real BMASwap::liborFraction() const {
        return liborFraction_;
    }

    Spread BMASwap::liborSpread() const {
        return liborSpread_;
    }

    Real BMASwap::nominal() const {
        return nominal_;
    }

    Swap::Type BMASwap::type() const {
        return type_;
    }

    const Leg& BMASwap::liborLeg() const {
        return legs_[0];
    }

    const Leg& BMASwap::bmaLeg() const {
        return legs_[1];
    }


    Real BMASwap::liborLegBPS() const {
        calculate();
        QL_REQUIRE(legBPS_[0] != Null<Real>(), "result not available");
        return legBPS_[0];
    }

    Real BMASwap::liborLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[0] != Null<Real>(), "result not available");
        return legNPV_[0];
    }

    Real BMASwap::fairLiborFraction() const {
        static Spread basisPoint = 1.0e-4;

        Real spreadNPV = (liborSpread_/basisPoint)*liborLegBPS();
        Real pureLiborNPV = liborLegNPV() - spreadNPV;
        QL_REQUIRE(pureLiborNPV != 0.0,
                   "result not available (null libor NPV)");
        return -liborFraction_ * (bmaLegNPV() + spreadNPV) / pureLiborNPV;
    }

    Spread BMASwap::fairLiborSpread() const {
        static Spread basisPoint = 1.0e-4;

        return liborSpread_ - NPV()/(liborLegBPS()/basisPoint);
    }

    Real BMASwap::bmaLegBPS() const {
        calculate();
        QL_REQUIRE(legBPS_[1] != Null<Real>(), "result not available");
        return legBPS_[1];
    }

    Real BMASwap::bmaLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[1] != Null<Real>(), "result not available");
        return legNPV_[1];
    }

}
]]></document_content>
  </document>
  <document index="16">
    <source>bmaswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Roland Lichters
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bmaswap.hpp
    \brief swap paying Libor against BMA coupons
*/

#ifndef quantlib_bma_swap_hpp
#define quantlib_bma_swap_hpp

#include <ql/instruments/swap.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/indexes/bmaindex.hpp>

namespace QuantLib {

    //! swap paying Libor against BMA coupons
    class BMASwap : public Swap {
      public:
        /*! In this constructor, the type (Payer or Receiver) refers
            to the BMA leg.
        */
        BMASwap(Type type,
                Real nominal,
                // Libor leg
                const Schedule& liborSchedule,
                Rate liborFraction,
                Rate liborSpread,
                const ext::shared_ptr<IborIndex>& liborIndex,
                const DayCounter& liborDayCount,
                // BMA leg
                const Schedule& bmaSchedule,
                const ext::shared_ptr<BMAIndex>& bmaIndex,
                const DayCounter& bmaDayCount);

        //! \name Inspectors
        //@{
        Real liborFraction() const;
        Spread liborSpread() const;
        Real nominal() const;
        //! "Payer" or "Receiver" refers to the BMA leg
        Type type() const;
        const Leg& bmaLeg() const;
        const Leg& liborLeg() const;
        //@}

        //! \name Results
        //@{
        Real liborLegBPS() const;
        Real liborLegNPV() const;
        Rate fairLiborFraction() const;
        Spread fairLiborSpread() const;

        Real bmaLegBPS() const;
        Real bmaLegNPV() const;
        //@}

      private:
        Type type_;
        Real nominal_;
        Rate liborFraction_;
        Rate liborSpread_;
    };

}

#endif

]]></document_content>
  </document>
  <document index="17">
    <source>bond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Jeff Yu
 Copyright (C) 2004 M-Dimension Consulting Inc.
 Copyright (C) 2005, 2006, 2007, 2008, 2010 StatPro Italia srl
 Copyright (C) 2007, 2008, 2009 Ferdinando Ametrano
 Copyright (C) 2007 Chiara Fornarola
 Copyright (C) 2008 Simon Ibbotson

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/floatingratecoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/instruments/bond.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/pricingengines/bond/bondfunctions.hpp>
#include <ql/pricingengines/bond/discountingbondengine.hpp>
#include <utility>

namespace QuantLib {

    Bond::Bond(Natural settlementDays, Calendar calendar, const Date& issueDate, const Leg& coupons)
    : settlementDays_(settlementDays), calendar_(std::move(calendar)), cashflows_(coupons),
      issueDate_(issueDate) {

        if (!coupons.empty()) {
            std::sort(cashflows_.begin(), cashflows_.end(),
                      earlier_than<ext::shared_ptr<CashFlow> >());

            if (issueDate_ != Date()) {
                QL_REQUIRE(issueDate_<cashflows_[0]->date(),
                           "issue date (" << issueDate_ <<
                           ") must be earlier than first payment date (" <<
                           cashflows_[0]->date() << ")");
            }

            maturityDate_ = coupons.back()->date();

            addRedemptionsToCashflows();
        }

        registerWith(Settings::instance().evaluationDate());
        for (const auto& cashflow : cashflows_)
            registerWith(cashflow);
    }

    Bond::Bond(Natural settlementDays,
               Calendar calendar,
               Real faceAmount,
               const Date& maturityDate,
               const Date& issueDate,
               const Leg& cashflows)
    : settlementDays_(settlementDays), calendar_(std::move(calendar)), cashflows_(cashflows),
      maturityDate_(maturityDate), issueDate_(issueDate) {

        if (!cashflows.empty()) {

            std::sort(cashflows_.begin(), cashflows_.end()-1,
                      earlier_than<ext::shared_ptr<CashFlow> >());

            if (maturityDate_ == Date())
                maturityDate_ = CashFlows::maturityDate(cashflows);

            if (issueDate_ != Date()) {
                QL_REQUIRE(issueDate_<cashflows_[0]->date(),
                           "issue date (" << issueDate_ <<
                           ") must be earlier than first payment date (" <<
                           cashflows_[0]->date() << ")");
            }

            notionals_.resize(2);
            notionalSchedule_.resize(2);

            notionalSchedule_[0] = Date();
            notionals_[0] = faceAmount;

            notionalSchedule_[1] = maturityDate_;
            notionals_[1] = 0.0;

            redemptions_.push_back(cashflows.back());
        }

        registerWith(Settings::instance().evaluationDate());
        for (const auto& cashflow : cashflows_)
            registerWith(cashflow);
    }

    bool Bond::isExpired() const {
        // this is the Instrument interface, so it doesn't use
        // BondFunctions, and includeSettlementDateFlows is true
        // (unless QL_TODAY_PAYMENTS will set it to false later on)
        return CashFlows::isExpired(cashflows_,
                                    true,
                                    Settings::instance().evaluationDate());
    }

    Real Bond::notional(Date d) const {
        if (d == Date())
            d = settlementDate();

        if (d > notionalSchedule_.back()) {
            // after maturity
            return 0.0;
        }

        // After the check above, d is between the schedule
        // boundaries.  We search starting from the second notional
        // date, since the first is null.  After the call to
        // lower_bound, *i is the earliest date which is greater or
        // equal than d.  Its index is greater or equal to 1.
        auto i = std::lower_bound(notionalSchedule_.begin() + 1, notionalSchedule_.end(), d);
        Size index = std::distance(notionalSchedule_.begin(), i);

        if (d < notionalSchedule_[index]) {
            // no doubt about what to return
            return notionals_[index-1];
        } else {
            // d is equal to a redemption date.
            // As per bond conventions, the payment has occurred;
            // the bond already changed notional.
            return notionals_[index];
        }
    }

    const ext::shared_ptr<CashFlow>& Bond::redemption() const {
        QL_REQUIRE(redemptions_.size() == 1,
                   "multiple redemption cash flows given");
        return redemptions_.back();
    }

    Date Bond::startDate() const {
        return BondFunctions::startDate(*this);
    }

    Date Bond::maturityDate() const {
        if (maturityDate_!=Null<Date>())
            return maturityDate_;
        else
            return BondFunctions::maturityDate(*this);
    }

    bool Bond::isTradable(Date d) const {
        return BondFunctions::isTradable(*this, d);
    }

    Date Bond::settlementDate(Date d) const {
        if (d==Date())
            d = Settings::instance().evaluationDate();

        // usually, the settlement is at T+n...
        Date settlement = calendar_.advance(d, settlementDays_, Days);
        // ...but the bond won't be traded until the issue date (if given.)
        if (issueDate_ == Date())
            return settlement;
        else
            return std::max(settlement, issueDate_);
    }

    Real Bond::cleanPrice() const {
        return dirtyPrice() - accruedAmount(settlementDate());
    }

    Real Bond::dirtyPrice() const {
        Real currentNotional = notional(settlementDate());
        if (currentNotional == 0.0)
            return 0.0;
        else
            return settlementValue()*100.0/currentNotional;
    }

    Real Bond::settlementValue() const {
        calculate();
        QL_REQUIRE(settlementValue_ != Null<Real>(),
                   "settlement value not provided");
        return settlementValue_;
    }

    Real Bond::settlementValue(Real cleanPrice) const {
        Real dirtyPrice = cleanPrice + accruedAmount(settlementDate());
        return dirtyPrice / 100.0 * notional(settlementDate());
    }

    Rate Bond::yield(const DayCounter& dc,
                     Compounding comp,
                     Frequency freq,
                     Real accuracy,
                     Size maxEvaluations,
                     Real guess,
                     Bond::Price::Type priceType) const {
        Real currentNotional = notional(settlementDate());
        if (currentNotional == 0.0)
            return 0.0;

        Real price = priceType == Bond::Price::Clean ? cleanPrice() : dirtyPrice();

        return BondFunctions::yield(*this, price, dc, comp, freq,
                                    settlementDate(),
                                    accuracy, maxEvaluations,
                                    guess, priceType);
    }

    Real Bond::cleanPrice(Rate y,
                          const DayCounter& dc,
                          Compounding comp,
                          Frequency freq,
                          Date settlement) const {
        return BondFunctions::cleanPrice(*this, y, dc, comp, freq, settlement);
    }

    Real Bond::dirtyPrice(Rate y,
                          const DayCounter& dc,
                          Compounding comp,
                          Frequency freq,
                          Date settlement) const {
        Real currentNotional = notional(settlement);
        if (currentNotional == 0.0)
            return 0.0;

        return BondFunctions::cleanPrice(*this, y, dc, comp, freq, settlement)
            + accruedAmount(settlement);
    }

    Rate Bond::yield(Real price,
                     const DayCounter& dc,
                     Compounding comp,
                     Frequency freq,
                     Date settlement,
                     Real accuracy,
                     Size maxEvaluations,
                     Real guess,
                     Bond::Price::Type priceType) const {
        Real currentNotional = notional(settlement);
        if (currentNotional == 0.0)
            return 0.0;

        return BondFunctions::yield(*this, price, dc, comp, freq,
                                    settlement, accuracy, maxEvaluations,
                                    guess, priceType);
    }

    Real Bond::accruedAmount(Date settlement) const {
        Real currentNotional = notional(settlement);
        if (currentNotional == 0.0)
            return 0.0;

        return BondFunctions::accruedAmount(*this, settlement);
    }

    Rate Bond::nextCouponRate(Date settlement) const {
        return BondFunctions::nextCouponRate(*this, settlement);
    }

    Rate Bond::previousCouponRate(Date settlement) const {
        return BondFunctions::previousCouponRate(*this, settlement);
    }

    Date Bond::nextCashFlowDate(Date settlement) const {
        return BondFunctions::nextCashFlowDate(*this, settlement);
    }

    Date Bond::previousCashFlowDate(Date settlement) const {
        return BondFunctions::previousCashFlowDate(*this, settlement);
    }

    void Bond::setupExpired() const {
        Instrument::setupExpired();
        settlementValue_ = 0.0;
    }

    void Bond::setupArguments(PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<Bond::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->settlementDate = settlementDate();
        arguments->cashflows = cashflows_;
        arguments->calendar = calendar_;
    }

    void Bond::fetchResults(const PricingEngine::results* r) const {

        Instrument::fetchResults(r);

        const auto* results = dynamic_cast<const Bond::results*>(r);
        QL_ENSURE(results != nullptr, "wrong result type");

        settlementValue_ = results->settlementValue;
    }

    void Bond::addRedemptionsToCashflows(const std::vector<Real>& redemptions) {
        // First, we gather the notional information from the cashflows
        calculateNotionalsFromCashflows();
        // Then, we create the redemptions based on the notional
        // information and we add them to the cashflows vector after
        // the coupons.
        redemptions_.clear();
        for (Size i=1; i<notionalSchedule_.size(); ++i) {
            Real R = i < redemptions.size() ? redemptions[i] :
                     !redemptions.empty()   ? redemptions.back() :
                                              100.0;
            Real amount = (R/100.0)*(notionals_[i-1]-notionals_[i]);
            ext::shared_ptr<CashFlow> payment;
            if (i < notionalSchedule_.size()-1)
                payment.reset(new AmortizingPayment(amount,
                                                    notionalSchedule_[i]));
            else
                payment.reset(new Redemption(amount, notionalSchedule_[i]));
            cashflows_.push_back(payment);
            redemptions_.push_back(payment);
        }
        // stable_sort now moves the redemptions to the right places
        // while ensuring that they follow coupons with the same date.
        std::stable_sort(cashflows_.begin(), cashflows_.end(),
                         earlier_than<ext::shared_ptr<CashFlow> >());
    }

    void Bond::setSingleRedemption(Real notional,
                                   Real redemption,
                                   const Date& date) {

        ext::shared_ptr<CashFlow> redemptionCashflow(
                         new Redemption(notional*redemption/100.0, date));
        setSingleRedemption(notional, redemptionCashflow);
    }

    void Bond::setSingleRedemption(Real notional,
                                   const ext::shared_ptr<CashFlow>& redemption) {
        notionals_.resize(2);
        notionalSchedule_.resize(2);
        redemptions_.clear();

        notionalSchedule_[0] = Date();
        notionals_[0] = notional;

        notionalSchedule_[1] = redemption->date();
        notionals_[1] = 0.0;

        cashflows_.push_back(redemption);
        redemptions_.push_back(redemption);
    }

    void Bond::deepUpdate() {
        for (auto& cashflow : cashflows_) {
            ext::shared_ptr<LazyObject> f = ext::dynamic_pointer_cast<LazyObject>(cashflow);
            if (f != nullptr)
                f->update();
        }
        update();
    }

    void Bond::calculateNotionalsFromCashflows() {
        notionalSchedule_.clear();
        notionals_.clear();

        Date lastPaymentDate = Date();
        notionalSchedule_.emplace_back();
        for (auto& cashflow : cashflows_) {
            ext::shared_ptr<Coupon> coupon = ext::dynamic_pointer_cast<Coupon>(cashflow);
            if (!coupon)
                continue;

            Real notional = coupon->nominal();
            // we add the notional only if it is the first one...
            if (notionals_.empty()) {
                notionals_.push_back(coupon->nominal());
                lastPaymentDate = coupon->date();
            } else if (!close(notional, notionals_.back())) {
                // ...or if it has changed.
                QL_REQUIRE(notional < notionals_.back(),
                           "increasing coupon notionals");
                notionals_.push_back(coupon->nominal());
                // in this case, we also add the last valid date for
                // the previous one...
                notionalSchedule_.push_back(lastPaymentDate);
                // ...and store the candidate for this one.
                lastPaymentDate = coupon->date();
            } else {
                // otherwise, we just extend the valid range of dates
                // for the current notional.
                lastPaymentDate = coupon->date();
            }
        }
        QL_REQUIRE(!notionals_.empty(), "no coupons provided");
        notionals_.push_back(0.0);
        notionalSchedule_.push_back(lastPaymentDate);
    }


    void Bond::arguments::validate() const {
        QL_REQUIRE(settlementDate != Date(), "no settlement date provided");
        QL_REQUIRE(!cashflows.empty(), "no cash flow provided");
        for (const auto & cf: cashflows)
            QL_REQUIRE(cf, "null cash flow provided");
    }

}
]]></document_content>
  </document>
  <document index="18">
    <source>bond.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Jeff Yu
 Copyright (C) 2004 M-Dimension Consulting Inc.
 Copyright (C) 2005, 2006, 2007, 2008 StatPro Italia srl
 Copyright (C) 2007, 2008, 2009 Ferdinando Ametrano
 Copyright (C) 2007 Chiara Fornarola
 Copyright (C) 2008 Simon Ibbotson

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file bond.hpp
    \brief concrete bond class
*/

#ifndef quantlib_bond_hpp
#define quantlib_bond_hpp

#include <ql/instrument.hpp>

#include <ql/time/calendar.hpp>
#include <ql/cashflow.hpp>
#include <ql/compounding.hpp>

#include <vector>

namespace QuantLib {

    class DayCounter;

    //! Base bond class
    /*! Derived classes must fill the uninitialized data members.

        \warning Most methods assume that the cash flows are stored
                 sorted by date, the redemption(s) being after any
                 cash flow at the same date. In particular, if there's
                 one single redemption, it must be the last cash flow,

        \ingroup instruments

        \test
        - price/yield calculations are cross-checked for consistency.
        - price/yield calculations are checked against known good
          values.
    */
    class Bond : public Instrument {
      public:
        //! Bond price information
        class Price {
          public:
            enum Type { Dirty, Clean };
            Price() : amount_(Null<Real>()) {}
            Price(Real amount, Type type) : amount_(amount), type_(type) {}
            Real amount() const {
                QL_REQUIRE(amount_ != Null<Real>(), "no amount given");
                return amount_;
            }
            Type type() const { return type_; }
          private:
            Real amount_;
            Type type_;
        };

        //! constructor for amortizing or non-amortizing bonds.
        /*! Redemptions and maturity are calculated from the coupon
            data, if available.  Therefore, redemptions must not be
            included in the passed cash flows.
        */
        Bond(Natural settlementDays,
             Calendar calendar,
             const Date& issueDate = Date(),
             const Leg& coupons = Leg());

        //! old constructor for non amortizing bonds.
        /*! \warning The last passed cash flow must be the bond
                     redemption. No other cash flow can have a date
                     later than the redemption date.
        */
        Bond(Natural settlementDays,
             Calendar calendar,
             Real faceAmount,
             const Date& maturityDate,
             const Date& issueDate = Date(),
             const Leg& cashflows = Leg());

        class arguments;
        class results;
        class engine;

        //! \name Instrument interface
        //@{
        bool isExpired() const override;
        //@}
        //! \name Observable interface
        //@{
        void deepUpdate() override;
        //@}
        //! \name Inspectors
        //@{
        Natural settlementDays() const;
        const Calendar& calendar() const;

        const std::vector<Real>& notionals() const;
        virtual Real notional(Date d = Date()) const;

        /*! \note returns all the cashflows, including the redemptions. */
        const Leg& cashflows() const;
        /*! returns just the redemption flows (not interest payments) */
        const Leg& redemptions() const;
        /*! returns the redemption, if only one is defined */
        const ext::shared_ptr<CashFlow>& redemption() const;

        Date startDate() const;
        Date maturityDate() const;
        Date issueDate() const;

        bool isTradable(Date d = Date()) const;
        Date settlementDate(Date d = Date()) const;
        //@}

        //! \name Calculations
        //@{

        //! theoretical clean price
        /*! The default bond settlement is used for calculation.

            \warning the theoretical price calculated from a flat term
                     structure might differ slightly from the price
                     calculated from the corresponding yield by means
                     of the other overload of this function. If the
                     price from a constant yield is desired, it is
                     advisable to use such other overload.
        */
        Real cleanPrice() const;

        //! theoretical dirty price
        /*! The default bond settlement is used for calculation.

            \warning the theoretical price calculated from a flat term
                     structure might differ slightly from the price
                     calculated from the corresponding yield by means
                     of the other overload of this function. If the
                     price from a constant yield is desired, it is
                     advisable to use such other overload.
        */
        Real dirtyPrice() const;

        //! theoretical settlement value
        /*! The default bond settlement date is used for calculation. */
        Real settlementValue() const;

        //! theoretical bond yield
        /*! The default bond settlement and theoretical price are used
            for calculation.
        */
        Rate yield(const DayCounter& dc,
                   Compounding comp,
                   Frequency freq,
                   Real accuracy = 1.0e-8,
                   Size maxEvaluations = 100,
                   Real guess = 0.05,
                   Bond::Price::Type priceType = Bond::Price::Clean) const;

        //! clean price given a yield and settlement date
        /*! The default bond settlement is used if no date is given. */
        Real cleanPrice(Rate yield,
                        const DayCounter& dc,
                        Compounding comp,
                        Frequency freq,
                        Date settlementDate = Date()) const;

        //! dirty price given a yield and settlement date
        /*! The default bond settlement is used if no date is given. */
        Real dirtyPrice(Rate yield,
                        const DayCounter& dc,
                        Compounding comp,
                        Frequency freq,
                        Date settlementDate = Date()) const;

        //! settlement value as a function of the clean price
        /*! The default bond settlement date is used for calculation. */
        Real settlementValue(Real cleanPrice) const;

        //! yield given a (clean) price and settlement date
        /*! The default bond settlement is used if no date is given. */
        Rate yield(Real cleanPrice,
                   const DayCounter& dc,
                   Compounding comp,
                   Frequency freq,
                   Date settlementDate = Date(),
                   Real accuracy = 1.0e-8,
                   Size maxEvaluations = 100,
                   Real guess = 0.05,
                   Bond::Price::Type priceType = Bond::Price::Clean) const;

        //! accrued amount at a given date
        /*! The default bond settlement is used if no date is given. */
        virtual Real accruedAmount(Date d = Date()) const;
        //@}

        /*! Expected next coupon: depending on (the bond and) the given date
            the coupon can be historic, deterministic or expected in a
            stochastic sense. When the bond settlement date is used the coupon
            is the already-fixed not-yet-paid one.

            The current bond settlement is used if no date is given.
        */
        virtual Rate nextCouponRate(Date d = Date()) const;

        //! Previous coupon already paid at a given date
        /*! Expected previous coupon: depending on (the bond and) the given
            date the coupon can be historic, deterministic or expected in a
            stochastic sense. When the bond settlement date is used the coupon
            is the last paid one.

            The current bond settlement is used if no date is given.
        */
        Rate previousCouponRate(Date d = Date()) const;

        Date nextCashFlowDate(Date d = Date()) const;
        Date previousCashFlowDate(Date d = Date()) const;

      protected:
        void setupExpired() const override;
        void setupArguments(PricingEngine::arguments*) const override;
        void fetchResults(const PricingEngine::results*) const override;

        /*! This method can be called by derived classes in order to
            build redemption payments from the existing cash flows.
            It must be called after setting up the cashflows_ vector
            and will fill the notionalSchedule_, notionals_, and
            redemptions_ data members.

            If given, the elements of the redemptions vector will
            multiply the amount of the redemption cash flow.  The
            elements will be taken in base 100, i.e., a redemption
            equal to 100 does not modify the amount.

            \pre The cashflows_ vector must contain at least one
                 coupon and must be sorted by date.
        */
        void addRedemptionsToCashflows(const std::vector<Real>& redemptions
                                                       = std::vector<Real>());

        /*! This method can be called by derived classes in order to
            build a bond with a single redemption payment.  It will
            fill the notionalSchedule_, notionals_, and redemptions_
            data members.
        */
        void setSingleRedemption(Real notional,
                                 Real redemption,
                                 const Date& date);

        /*! This method can be called by derived classes in order to
            build a bond with a single redemption payment.  It will
            fill the notionalSchedule_, notionals_, and redemptions_
            data members.
        */
        void setSingleRedemption(Real notional,
                                 const ext::shared_ptr<CashFlow>& redemption);

        /*! used internally to collect notional information from the
            coupons. It should not be called by derived classes,
            unless they already provide redemption cash flows (in
            which case they must set up the redemptions_ data member
            independently).  It will fill the notionalSchedule_ and
            notionals_ data members.
        */
        void calculateNotionalsFromCashflows();

        Natural settlementDays_;
        Calendar calendar_;
        std::vector<Date> notionalSchedule_;
        std::vector<Real> notionals_;
        Leg cashflows_; // all cashflows
        Leg redemptions_; // the redemptions

        Date maturityDate_, issueDate_;
        mutable Real settlementValue_;
    };

    class Bond::arguments : public PricingEngine::arguments {
      public:
        Date settlementDate;
        Leg cashflows;
        Calendar calendar;
        void validate() const override;
    };

    class Bond::results : public Instrument::results {
      public:
        Real settlementValue;
        void reset() override {
            settlementValue = Null<Real>();
            Instrument::results::reset();
        }
    };

    class Bond::engine : public GenericEngine<Bond::arguments,
                                              Bond::results> {};


    // inline definitions

    inline Natural Bond::settlementDays() const {
        return settlementDays_;
    }

    inline const Calendar& Bond::calendar() const {
        return calendar_;
    }

    inline const std::vector<Real>& Bond::notionals() const {
        return notionals_;
    }

    inline const Leg& Bond::cashflows() const {
        return cashflows_;
    }

    inline const Leg& Bond::redemptions() const {
        return redemptions_;
    }

    inline Date Bond::issueDate() const {
        return issueDate_;
    }

}

#endif
]]></document_content>
  </document>
  <document index="19">
    <source>bonds/Makefile.am</source>
    <document_content><![CDATA[
AM_CPPFLAGS = -I${top_builddir} -I${top_srcdir}

this_includedir=${includedir}/${subdir}
this_include_HEADERS = \
    all.hpp \
    btp.hpp \
    cmsratebond.hpp \
    cpibond.hpp \
    fixedratebond.hpp \
    floatingratebond.hpp \
    zerocouponbond.hpp

cpp_files = \
    btp.cpp \
    cmsratebond.cpp \
    cpibond.cpp \
    fixedratebond.cpp \
    floatingratebond.cpp \
    zerocouponbond.cpp

if UNITY_BUILD

nodist_libBonds_la_SOURCES = unity.cpp

unity.cpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > $@
	echo "/* Add the files to be included into Makefile.am instead. */" >> $@
	echo >> $@
	for i in $(cpp_files); do \
		echo "#include \"${subdir}/$$i\"" >> $@; \
	done

EXTRA_DIST = $(cpp_files)

else

libBonds_la_SOURCES = $(cpp_files)

endif

noinst_LTLIBRARIES = libBonds.la

all.hpp: Makefile.am
	echo "/* This file is automatically generated; do not edit.     */" > ${srcdir}/$@
	echo "/* Add the files to be included into Makefile.am instead. */" >> ${srcdir}/$@
	echo >> ${srcdir}/$@
	for i in $(filter-out all.hpp, $(this_include_HEADERS)); do \
		echo "#include <${subdir}/$$i>" >> ${srcdir}/$@; \
	done
	echo >> ${srcdir}/$@
	subdirs='$(SUBDIRS)'; for i in $$subdirs; do \
		echo "#include <${subdir}/$$i/all.hpp>" >> ${srcdir}/$@; \
	done

]]></document_content>
  </document>
  <document index="20">
    <source>bonds/all.hpp</source>
    <document_content><![CDATA[/* This file is automatically generated; do not edit.     */
/* Add the files to be included into Makefile.am instead. */

#include <ql/instruments/bonds/btp.hpp>
#include <ql/instruments/bonds/cmsratebond.hpp>
#include <ql/instruments/bonds/cpibond.hpp>
#include <ql/instruments/bonds/fixedratebond.hpp>
#include <ql/instruments/bonds/floatingratebond.hpp>
#include <ql/instruments/bonds/zerocouponbond.hpp>

]]></document_content>
  </document>
  <document index="21">
    <source>bonds/btp.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/bonds/btp.hpp>
#include <ql/instruments/makevanillaswap.hpp>
#include <ql/pricingengines/bond/bondfunctions.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <ql/time/calendars/target.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/actualactual.hpp>
#include <ql/time/schedule.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <utility>

namespace QuantLib {

    CCTEU::CCTEU(const Date& maturityDate,
                 Spread spread,
                 const Handle<YieldTermStructure>& fwdCurve,
                 const Date& startDate,
                 const Date& issueDate)
    : FloatingRateBond(2, 100.0,
                       Schedule(startDate,
                                maturityDate, 6*Months,
                                NullCalendar(), Unadjusted, Unadjusted,
                                DateGeneration::Backward, true),
                       ext::make_shared<Euribor6M>(fwdCurve),
                       Actual360(),
                       Following,
                       Euribor6M().fixingDays(),
                       std::vector<Real>(1, 1.0), // gearing
                       std::vector<Spread>(1, spread),
                       std::vector<Rate>(), // caps
                       std::vector<Rate>(), // floors
                       false, // in arrears
                       100.0, // redemption
                       issueDate) {}

    BTP::BTP(const Date& maturityDate,
             Rate fixedRate,
             const Date& startDate,
             const Date& issueDate)
    : FixedRateBond(2, 100.0,
                    Schedule(startDate,
                             maturityDate, 6*Months,
                             NullCalendar(), Unadjusted, Unadjusted,
                             DateGeneration::Backward, true),
                    std::vector<Rate>(1, fixedRate),
                    ActualActual(ActualActual::ISMA),
                    ModifiedFollowing, 100.0, issueDate, TARGET()) {}

    BTP::BTP(const Date& maturityDate,
             Rate fixedRate,
             Real redemption,
             const Date& startDate,
             const Date& issueDate)
    : FixedRateBond(2, 100.0,
                    Schedule(startDate,
                             maturityDate, 6*Months,
                             NullCalendar(), Unadjusted, Unadjusted,
                             DateGeneration::Backward, true),
                    std::vector<Rate>(1, fixedRate),
                    ActualActual(ActualActual::ISMA),
                    ModifiedFollowing, redemption, issueDate, TARGET()) {}

    Rate BTP::yield(Real cleanPrice,
                    Date settlementDate,
                    Real accuracy,
                    Size maxEvaluations) const {
        return Bond::yield(cleanPrice, ActualActual(ActualActual::ISMA),
                           Compounded, Annual,
                           settlementDate, accuracy, maxEvaluations);
    }


    RendistatoBasket::RendistatoBasket(const std::vector<ext::shared_ptr<BTP> >& btps,
                                       const std::vector<Real>& outstandings,
                                       std::vector<Handle<Quote> > cleanPriceQuotes)
    : btps_(btps), outstandings_(outstandings), quotes_(std::move(cleanPriceQuotes)) {

        QL_REQUIRE(!btps_.empty(), "empty RendistatoCalculator Basket");
        Size k = btps_.size();

        QL_REQUIRE(outstandings_.size()==k,
                   "mismatch between number of BTPs (" << k <<
                   ") and number of outstandings (" <<
                   outstandings_.size() << ")");
        QL_REQUIRE(quotes_.size()==k,
                   "mismatch between number of BTPs (" << k <<
                   ") and number of clean prices quotes (" <<
                   quotes_.size() << ")");

        // require non-negative outstanding
        for (Size i=0; i<k; ++i) {
            QL_REQUIRE(outstandings[i]>=0,
                       "negative outstanding for " << io::ordinal(i) <<
                       " bond, maturity " << btps[i]->maturityDate());
            // add check for prices ??
        }

        // TODO: filter out expired bonds, zero outstanding bond, etc

        QL_REQUIRE(!btps_.empty(), "invalid bonds only in RendistatoCalculator Basket");
        n_ = btps_.size();

        outstanding_ = 0.0;
        for (Size i=0; i<n_; ++i)
            outstanding_ += outstandings[i];

        weights_.resize(n_);
        for (Size i=0; i<n_; ++i) {
            weights_[i] = outstandings[i]/outstanding_;
            registerWith(quotes_[i]);
        }
    }


    RendistatoCalculator::RendistatoCalculator(ext::shared_ptr<RendistatoBasket> basket,
                                               ext::shared_ptr<Euribor> euriborIndex,
                                               Handle<YieldTermStructure> discountCurve)
    : basket_(std::move(basket)), euriborIndex_(std::move(euriborIndex)),
      discountCurve_(std::move(discountCurve)), yields_(basket_->size(), 0.05),
      durations_(basket_->size()),
      nSwaps_(15), // TODO: generalize number of swaps and their lengths
      swaps_(nSwaps_), swapLengths_(nSwaps_), swapBondDurations_(nSwaps_, Null<Time>()),
      swapBondYields_(nSwaps_, 0.05), swapRates_(nSwaps_, Null<Rate>()) {
        registerWith(basket_);
        registerWith(euriborIndex_);
        registerWith(discountCurve_);

        Rate dummyRate = 0.05;
        for (Size i=0; i<nSwaps_; ++i) {
            swapLengths_[i] = static_cast<Real>(i+1);
            swaps_[i] = MakeVanillaSwap(
                swapLengths_[i]*Years, euriborIndex_, dummyRate, 1*Days)
                                .withDiscountingTermStructure(discountCurve_);
        }
    }

    void RendistatoCalculator::performCalculations() const {

        const std::vector<ext::shared_ptr<BTP> >& btps = basket_->btps();
        const std::vector<Handle<Quote> >& quotes = basket_->cleanPriceQuotes();
        Date bondSettlementDate = btps[0]->settlementDate();
        for (Size i=0; i<basket_->size(); ++i) {
            yields_[i] = BondFunctions::yield(
                *btps[i], quotes[i]->value(),
                ActualActual(ActualActual::ISMA), Compounded, Annual,
                bondSettlementDate,
                // accuracy, maxIterations, guess
                1.0e-10, 100, yields_[i]);
            durations_[i] = BondFunctions::duration(
                *btps[i], yields_[i],
                ActualActual(ActualActual::ISMA), Compounded, Annual,
                Duration::Modified, bondSettlementDate);
        }
        duration_ = std::inner_product(basket_->weights().begin(),
                                       basket_->weights().end(),
                                       durations_.begin(), 0.0);

        Natural settlDays = 2;
        DayCounter fixedDayCount = swaps_[0]->fixedDayCount();
        equivalentSwapIndex_ = nSwaps_-1;
        swapRates_[0]= swaps_[0]->fairRate();
        FixedRateBond swapBond(settlDays,
                               100.0,      // faceAmount
                               swaps_[0]->fixedSchedule(),
                               std::vector<Rate>(1, swapRates_[0]),
                               fixedDayCount,
                               Following, // paymentConvention
                               100.0);    // redemption
        swapBondYields_[0] = BondFunctions::yield(swapBond,
            100.0, // floating leg NPV including end payment
            ActualActual(ActualActual::ISMA), Compounded, Annual,
            bondSettlementDate,
            // accuracy, maxIterations, guess
            1.0e-10, 100, swapBondYields_[0]);
        swapBondDurations_[0] = BondFunctions::duration(
            swapBond, swapBondYields_[0],
            ActualActual(ActualActual::ISMA), Compounded, Annual,
            Duration::Modified, bondSettlementDate);
        for (Size i=1; i<nSwaps_; ++i) {
            swapRates_[i]= swaps_[i]->fairRate();
            FixedRateBond swapBond(settlDays,
                                   100.0,      // faceAmount
                                   swaps_[i]->fixedSchedule(),
                                   std::vector<Rate>(1, swapRates_[i]),
                                   fixedDayCount,
                                   Following, // paymentConvention
                                   100.0);    // redemption
            swapBondYields_[i] = BondFunctions::yield(swapBond,
                100.0, // floating leg NPV including end payment
                ActualActual(ActualActual::ISMA), Compounded, Annual,
                bondSettlementDate,
                // accuracy, maxIterations, guess
                1.0e-10, 100, swapBondYields_[i]);
            swapBondDurations_[i] = BondFunctions::duration(
                swapBond, swapBondYields_[i],
                ActualActual(ActualActual::ISMA), Compounded, Annual,
                Duration::Modified, bondSettlementDate);
            if (swapBondDurations_[i] > duration_) {
                equivalentSwapIndex_ = i-1;
                break; // exit the loop
            }
        }
    }

    RendistatoEquivalentSwapLengthQuote::RendistatoEquivalentSwapLengthQuote(
        ext::shared_ptr<RendistatoCalculator> r)
    : r_(std::move(r)) {}

    bool RendistatoEquivalentSwapLengthQuote::isValid() const {
        try {
            value();
            return true;
        } catch (...) {
            return false;
        }
    }

    RendistatoEquivalentSwapSpreadQuote::RendistatoEquivalentSwapSpreadQuote(
        ext::shared_ptr<RendistatoCalculator> r)
    : r_(std::move(r)) {}

    bool RendistatoEquivalentSwapSpreadQuote::isValid() const {
        try {
            value();
            return true;
        } catch (...) {
            return false;
        }
    }
}
]]></document_content>
  </document>
  <document index="22">
    <source>bonds/btp.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2011 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file btp.hpp
    \brief Italian BTP (Buoni Poliennali del Tesoro) fixed rate bond
*/

#ifndef quantlib_btp_hpp
#define quantlib_btp_hpp

#include <ql/instruments/bonds/fixedratebond.hpp>
#include <ql/instruments/bonds/floatingratebond.hpp>
#include <ql/indexes/ibor/euribor.hpp>
#include <ql/instruments/vanillaswap.hpp>

#include <numeric>

namespace QuantLib {

    /*! Italian CCTEU (Certificato di credito del tesoro)
        Euribor6M indexed floating rate bond
    
        \ingroup instruments

    */
    class CCTEU : public FloatingRateBond {
      public:
        CCTEU(const Date& maturityDate,
              Spread spread,
              const Handle<YieldTermStructure>& fwdCurve =
                                    Handle<YieldTermStructure>(),
              const Date& startDate = Date(),
              const Date& issueDate = Date());
        //! \name Bond interface
        //@{
        //! accrued amount at a given date
        /*! The default bond settlement is used if no date is given. */
        Real accruedAmount(Date d = Date()) const override;
        //@}
    };

    //! Italian BTP (Buono Poliennali del Tesoro) fixed rate bond
    /*! \ingroup instruments

    */
    class BTP : public FixedRateBond {
      public:
        BTP(const Date& maturityDate,
            Rate fixedRate,
            const Date& startDate = Date(),
            const Date& issueDate = Date());
        /*! constructor needed for legacy non-par redemption BTPs.
            As of today the only remaining one is IT123456789012
            that will redeem 99.999 on xx-may-2037 */
        BTP(const Date& maturityDate,
            Rate fixedRate,
            Real redemption,
            const Date& startDate = Date(),
            const Date& issueDate = Date());
        //! \name Bond interface
        //@{
        //! accrued amount at a given date
        /*! The default bond settlement is used if no date is given. */
        Real accruedAmount(Date d = Date()) const override;
        //@}
        //! BTP yield given a (clean) price and settlement date
        /*! The default BTP conventions are used: Actual/Actual (ISMA),
            Compounded, Annual.
            The default bond settlement is used if no date is given. */
        Rate yield(Real cleanPrice,
                   Date settlementDate = Date(),
                   Real accuracy = 1.0e-8,
                   Size maxEvaluations = 100) const;
    };

    class RendistatoBasket : public Observer,
                             public Observable {
      public:
        RendistatoBasket(const std::vector<ext::shared_ptr<BTP> >& btps,
                         const std::vector<Real>& outstandings,
                         std::vector<Handle<Quote> > cleanPriceQuotes);
        //! \name Inspectors
        //@{
        Size size() const { return n_;}
        const std::vector<ext::shared_ptr<BTP> >& btps() const;
        const std::vector<Handle<Quote> >& cleanPriceQuotes() const;
        const std::vector<Real>& outstandings() const { return outstandings_;}
        const std::vector<Real>& weights() const { return weights_;}
        Real outstanding() const { return outstanding_;}
        //@}
        //! \name Observer interface
        //@{
        void update() override { notifyObservers(); }
        //@}
      private:
        std::vector<ext::shared_ptr<BTP> > btps_;
        std::vector<Real> outstandings_;
        std::vector<Handle<Quote> > quotes_;
        Real outstanding_;
        Size n_;
        std::vector<Real> weights_;
    };

    class RendistatoCalculator : public LazyObject {
      public:
        RendistatoCalculator(ext::shared_ptr<RendistatoBasket> basket,
                             ext::shared_ptr<Euribor> euriborIndex,
                             Handle<YieldTermStructure> discountCurve);
        //! \name Calculations
        //@{
        Rate yield() const;
        Time duration() const;
        // bonds
        const std::vector<Rate>& yields() const;
        const std::vector<Time>& durations() const;
        // swaps
        const std::vector<Time>& swapLengths() const;
        const std::vector<Rate>& swapRates() const;
        const std::vector<Rate>& swapYields() const;
        const std::vector<Time>& swapDurations() const;
        //@}
        //! \name Equivalent Swap proxy
        //@{
        ext::shared_ptr<VanillaSwap> equivalentSwap() const;
        Rate equivalentSwapRate() const;
        Rate equivalentSwapYield() const;
        Time equivalentSwapDuration() const;
        Time equivalentSwapLength() const;
        Spread equivalentSwapSpread() const;
        //@}
      protected:
        //! \name LazyObject interface
        //@{
        void performCalculations() const override;
        //@}
      private:
        ext::shared_ptr<RendistatoBasket> basket_;
        ext::shared_ptr<Euribor> euriborIndex_;
        Handle<YieldTermStructure> discountCurve_;

        mutable std::vector<Rate> yields_;
        mutable std::vector<Time> durations_;
        mutable Time duration_;
        mutable Size equivalentSwapIndex_;

        Size nSwaps_;
        mutable std::vector<ext::shared_ptr<VanillaSwap> > swaps_;
        std::vector<Time> swapLengths_;
        mutable std::vector<Time> swapBondDurations_;
        mutable std::vector<Rate> swapBondYields_, swapRates_;
    };

    //! RendistatoCalculator equivalent swap lenth Quote adapter
    class RendistatoEquivalentSwapLengthQuote : public Quote {
      public:
        RendistatoEquivalentSwapLengthQuote(ext::shared_ptr<RendistatoCalculator> r);
        Real value() const override;
        bool isValid() const override;

      private:
        ext::shared_ptr<RendistatoCalculator> r_;
    };

    //! RendistatoCalculator equivalent swap spread Quote adapter
    class RendistatoEquivalentSwapSpreadQuote : public Quote {
      public:
        RendistatoEquivalentSwapSpreadQuote(ext::shared_ptr<RendistatoCalculator> r);
        Real value() const override;
        bool isValid() const override;

      private:
        ext::shared_ptr<RendistatoCalculator> r_;
    };

    // inline

    inline Real CCTEU::accruedAmount(Date d) const {
        Real result = FloatingRateBond::accruedAmount(d);
        return ClosestRounding(5)(result);
    }

    inline Real BTP::accruedAmount(Date d) const {
        Real result = FixedRateBond::accruedAmount(d);
        return ClosestRounding(5)(result);
    }

    inline const std::vector<ext::shared_ptr<BTP> >&
    RendistatoBasket::btps() const {
        return btps_;
    }

    inline const std::vector<Handle<Quote> >&
    RendistatoBasket::cleanPriceQuotes() const {
        return quotes_;
    }

    inline Rate RendistatoCalculator::yield() const {
        return std::inner_product(basket_->weights().begin(),
                                  basket_->weights().end(),
                                  yields().begin(), 0.0);
    }

    inline Time RendistatoCalculator::duration() const {
        calculate();
        return duration_;
    }

    inline const std::vector<Rate>& RendistatoCalculator::yields() const {
        calculate();
        return yields_;
    }

    inline const std::vector<Time>& RendistatoCalculator::durations() const {
        calculate();
        return durations_;
    }

    inline const std::vector<Time>& RendistatoCalculator::swapLengths() const {
        return swapLengths_;
    }

    inline const std::vector<Rate>& RendistatoCalculator::swapRates() const {
        calculate();
        return swapRates_;
    }

    inline const std::vector<Rate>& RendistatoCalculator::swapYields() const {
        calculate();
        return swapBondYields_;
    }

    inline const std::vector<Time>& RendistatoCalculator::swapDurations() const {
        calculate();
        return swapBondDurations_;
    }

    inline ext::shared_ptr<VanillaSwap>
    RendistatoCalculator::equivalentSwap() const {
        calculate();
        return swaps_[equivalentSwapIndex_];
    }

    inline Rate RendistatoCalculator::equivalentSwapRate() const {
        calculate();
        return swapRates_[equivalentSwapIndex_];
    }

    inline Rate RendistatoCalculator::equivalentSwapYield() const {
        calculate();
        return swapBondYields_[equivalentSwapIndex_];
    }

    inline Time RendistatoCalculator::equivalentSwapDuration() const {
        calculate();
        return swapBondDurations_[equivalentSwapIndex_];
    }

    inline Time RendistatoCalculator::equivalentSwapLength() const {
        calculate();
        return swapLengths_[equivalentSwapIndex_];
    }

    inline Spread RendistatoCalculator::equivalentSwapSpread() const {
        return yield() - equivalentSwapRate();
    }

    inline Real RendistatoEquivalentSwapLengthQuote::value() const {
        return r_->equivalentSwapLength();
    }

    inline Real RendistatoEquivalentSwapSpreadQuote::value() const {
        return r_->equivalentSwapSpread();
    }

}

#endif
]]></document_content>
  </document>
  <document index="23">
    <source>bonds/cmsratebond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2006, 2007 Chiara Fornarola
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/bonds/cmsratebond.hpp>
#include <ql/cashflows/cmscoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/time/schedule.hpp>

namespace QuantLib {

    CmsRateBond::CmsRateBond(
                           Natural settlementDays,
                           Real faceAmount,
                           const Schedule& schedule,
                           const ext::shared_ptr<SwapIndex>& index,
                           const DayCounter& paymentDayCounter,
                           BusinessDayConvention paymentConvention,
                           Natural fixingDays,
                           const std::vector<Real>& gearings,
                           const std::vector<Spread>& spreads,
                           const std::vector<Rate>& caps,
                           const std::vector<Rate>& floors,
                           bool inArrears,
                           Real redemption,
                           const Date& issueDate)
    : Bond(settlementDays, schedule.calendar(), issueDate) {

        maturityDate_ = schedule.endDate();

        cashflows_ = CmsLeg(schedule, index)
            .withNotionals(faceAmount)
            .withPaymentDayCounter(paymentDayCounter)
            .withPaymentAdjustment(paymentConvention)
            .withFixingDays(fixingDays)
            .withGearings(gearings)
            .withSpreads(spreads)
            .withCaps(caps)
            .withFloors(floors)
            .inArrears(inArrears);

        addRedemptionsToCashflows(std::vector<Real>(1, redemption));

        QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");
        QL_ENSURE(redemptions_.size() == 1, "multiple redemptions created");

        registerWith(index);
    }

}
]]></document_content>
  </document>
  <document index="24">
    <source>bonds/cmsratebond.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2006, 2007 Chiara Fornarola

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cmsratebond.hpp
    \brief CMS-rate bond
*/

#ifndef quantlib_cms_rate_bond_hpp
#define quantlib_cms_rate_bond_hpp

#include <ql/instruments/bond.hpp>

namespace QuantLib {

    class Schedule;
    class SwapIndex;

    //! CMS-rate bond
    /*! \ingroup instruments

        \test calculations are tested by checking results against
              cached values.
    */
    class CmsRateBond : public Bond {
      public:
        CmsRateBond(Natural settlementDays,
                    Real faceAmount,
                    const Schedule& schedule,
                    const ext::shared_ptr<SwapIndex>& index,
                    const DayCounter& paymentDayCounter,
                    BusinessDayConvention paymentConvention
                                    = Following,
                    Natural fixingDays = Null<Natural>(),
                    const std::vector<Real>& gearings
                                    = std::vector<Real>(1, 1.0),
                    const std::vector<Spread>& spreads
                                    = std::vector<Spread>(1, 0.0),
                    const std::vector<Rate>& caps
                                    = std::vector<Rate>(),
                    const std::vector<Rate>& floors
                                    = std::vector<Rate>(),
                    bool inArrears = false,
                    Real redemption = 100.0,
                    const Date& issueDate = Date());
    };

}

#endif
]]></document_content>
  </document>
  <document index="25">
    <source>bonds/cpibond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2011 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/cpicoupon.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/indexes/inflationindex.hpp>
#include <ql/instruments/bonds/cpibond.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/time/schedule.hpp>
#include <utility>


namespace QuantLib {

    CPIBond::CPIBond(Natural settlementDays,
                     Real faceAmount,
                     bool growthOnly,
                     Real baseCPI,
                     const Period& observationLag,
                     ext::shared_ptr<ZeroInflationIndex> cpiIndex,
                     CPI::InterpolationType observationInterpolation,
                     const Schedule& schedule,
                     const std::vector<Rate>& fixedRate,
                     const DayCounter& accrualDayCounter,
                     BusinessDayConvention paymentConvention,
                     const Date& issueDate,
                     const Calendar& paymentCalendar,
                     const Period& exCouponPeriod,
                     const Calendar& exCouponCalendar,
                     const BusinessDayConvention exCouponConvention,
                     bool exCouponEndOfMonth)
    : Bond(settlementDays,
           paymentCalendar == Calendar() ? schedule.calendar() : paymentCalendar,
           issueDate),
      frequency_(schedule.tenor().frequency()), dayCounter_(accrualDayCounter),
      growthOnly_(growthOnly), baseCPI_(baseCPI), observationLag_(observationLag),
      cpiIndex_(std::move(cpiIndex)), observationInterpolation_(observationInterpolation) {

        maturityDate_ = schedule.endDate();

        // a CPIleg know about zero legs and inclusion of base inflation notional
        cashflows_ = CPILeg(schedule, cpiIndex_,
                            baseCPI_, observationLag_)
            .withNotionals(faceAmount)
            .withFixedRates(fixedRate)
            .withPaymentDayCounter(accrualDayCounter)
            .withPaymentAdjustment(paymentConvention)
            .withPaymentCalendar(calendar_)
            .withObservationInterpolation(observationInterpolation_)
            .withSubtractInflationNominal(growthOnly_)
            .withExCouponPeriod(exCouponPeriod,
                                exCouponCalendar,
                                exCouponConvention,
                                exCouponEndOfMonth);


        calculateNotionalsFromCashflows();

        redemptions_.push_back(cashflows_.back());

        registerWith(cpiIndex_);
        Leg::const_iterator i;
        for (i = cashflows_.begin(); i < cashflows_.end(); ++i) {
            registerWith(*i);
        }
    }
}

]]></document_content>
  </document>
  <document index="26">
    <source>bonds/cpibond.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2011 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

/*! \file cpibond.hpp
 \brief zero-inflation-indexed-ratio-with-base bond
 */

#ifndef quantlib_cpibond_hpp
#define quantlib_cpibond_hpp


#include <ql/instruments/bond.hpp>
#include <ql/time/dategenerationrule.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/interestrate.hpp>
#include <ql/cashflows/cpicoupon.hpp>

namespace QuantLib {

    class Schedule;

    //! cpi bond; if there is only one date in the schedule it
    //! is a zero bond returning an inflated notional.
    /*! \ingroup instruments

     */
    class CPIBond : public Bond {
      public:
        CPIBond(Natural settlementDays,
                Real faceAmount,
                bool growthOnly,
                Real baseCPI,
                const Period& observationLag,
                ext::shared_ptr<ZeroInflationIndex> cpiIndex,
                CPI::InterpolationType observationInterpolation,
                const Schedule& schedule,
                const std::vector<Rate>& coupons,
                const DayCounter& accrualDayCounter,
                BusinessDayConvention paymentConvention = ModifiedFollowing,
                const Date& issueDate = Date(),
                const Calendar& paymentCalendar = Calendar(),
                const Period& exCouponPeriod = Period(),
                const Calendar& exCouponCalendar = Calendar(),
                BusinessDayConvention exCouponConvention = Unadjusted,
                bool exCouponEndOfMonth = false);

        Frequency frequency() const { return frequency_; }
        const DayCounter& dayCounter() const { return dayCounter_; }
        bool growthOnly() const { return growthOnly_; }
        Real baseCPI() const { return baseCPI_; }
        Period observationLag() const { return observationLag_; }
        const ext::shared_ptr<ZeroInflationIndex>& cpiIndex() const { return cpiIndex_; }
        CPI::InterpolationType observationInterpolation() const { return observationInterpolation_; }

      protected:
        Frequency frequency_;
        DayCounter dayCounter_;
        bool growthOnly_;
        Real baseCPI_;
        Period observationLag_;
        ext::shared_ptr<ZeroInflationIndex> cpiIndex_;
        CPI::InterpolationType observationInterpolation_;
    };


}






#endif
]]></document_content>
  </document>
  <document index="27">
    <source>bonds/fixedratebond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Jeff Yu
 Copyright (C) 2004 M-Dimension Consulting Inc.
 Copyright (C) 2005, 2006, 2007 StatPro Italia srl
 Copyright (C) 2007, 2008, 2010 Ferdinando Ametrano
 Copyright (C) 2009 Piter Dias

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/bonds/fixedratebond.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/time/schedule.hpp>

namespace QuantLib {

    FixedRateBond::FixedRateBond(Natural settlementDays,
                                 Real faceAmount,
                                 const Schedule& schedule,
                                 const std::vector<Rate>& coupons,
                                 const DayCounter& accrualDayCounter,
                                 BusinessDayConvention paymentConvention,
                                 Real redemption,
                                 const Date& issueDate,
                                 const Calendar& paymentCalendar,
                                 const Period& exCouponPeriod,
                                 const Calendar& exCouponCalendar,
                                 const BusinessDayConvention exCouponConvention,
                                 bool exCouponEndOfMonth,
                                 const DayCounter& firstPeriodDayCounter)
     : Bond(settlementDays,
            paymentCalendar==Calendar() ? schedule.calendar() : paymentCalendar,
            issueDate),
       frequency_(schedule.hasTenor() ? schedule.tenor().frequency() : NoFrequency),
       dayCounter_(accrualDayCounter),
       firstPeriodDayCounter_(firstPeriodDayCounter) {

        maturityDate_ = schedule.endDate();

        cashflows_ = FixedRateLeg(schedule)
            .withNotionals(faceAmount)
            .withCouponRates(coupons, accrualDayCounter)
            .withFirstPeriodDayCounter(firstPeriodDayCounter)
            .withPaymentCalendar(calendar_)
            .withPaymentAdjustment(paymentConvention)
            .withExCouponPeriod(exCouponPeriod,
                                exCouponCalendar,
                                exCouponConvention,
                                exCouponEndOfMonth);

        addRedemptionsToCashflows(std::vector<Real>(1, redemption));

        QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");
        QL_ENSURE(redemptions_.size() == 1, "multiple redemptions created");
    }

    FixedRateBond::FixedRateBond(Natural settlementDays,
                                 const Calendar& calendar,
                                 Real faceAmount,
                                 const Date& startDate,
                                 const Date& maturityDate,
                                 const Period& tenor,
                                 const std::vector<Rate>& coupons,
                                 const DayCounter& accrualDayCounter,
                                 BusinessDayConvention accrualConvention,
                                 BusinessDayConvention paymentConvention,
                                 Real redemption,
                                 const Date& issueDate,
                                 const Date& stubDate,
                                 DateGeneration::Rule rule,
                                 bool endOfMonth,
                                 const Calendar& paymentCalendar,
                                 const Period& exCouponPeriod,
                                 const Calendar& exCouponCalendar,
                                 const BusinessDayConvention exCouponConvention,
                                 bool exCouponEndOfMonth,
                                 const DayCounter& firstPeriodDayCounter)
     : Bond(settlementDays,
            paymentCalendar==Calendar() ? calendar : paymentCalendar,
            issueDate),
      frequency_(tenor.frequency()), dayCounter_(accrualDayCounter),
      firstPeriodDayCounter_(firstPeriodDayCounter) {

        maturityDate_ = maturityDate;

        Date firstDate, nextToLastDate;
        switch (rule) {
          case DateGeneration::Backward:
            firstDate = Date();
            nextToLastDate = stubDate;
            break;
          case DateGeneration::Forward:
            firstDate = stubDate;
            nextToLastDate = Date();
            break;
          case DateGeneration::Zero:
          case DateGeneration::ThirdWednesday:
          case DateGeneration::Twentieth:
          case DateGeneration::TwentiethIMM:
            QL_FAIL("stub date (" << stubDate << ") not allowed with " <<
                    rule << " DateGeneration::Rule");
          default:
            QL_FAIL("unknown DateGeneration::Rule (" << Integer(rule) << ")");
        }

        Schedule schedule(startDate, maturityDate_, tenor,
                          calendar, accrualConvention, accrualConvention,
                          rule, endOfMonth,
                          firstDate, nextToLastDate);

        cashflows_ = FixedRateLeg(schedule)
            .withNotionals(faceAmount)
            .withCouponRates(coupons, accrualDayCounter)
            .withFirstPeriodDayCounter(firstPeriodDayCounter)
            .withPaymentCalendar(calendar_)
            .withPaymentAdjustment(paymentConvention)
            .withExCouponPeriod(exCouponPeriod,
                                exCouponCalendar,
                                exCouponConvention,
                                exCouponEndOfMonth);

        addRedemptionsToCashflows(std::vector<Real>(1, redemption));

        QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");
        QL_ENSURE(redemptions_.size() == 1, "multiple redemptions created");
    }

    FixedRateBond::FixedRateBond(Natural settlementDays,
                                 Real faceAmount,
                                 const Schedule& schedule,
                                 const std::vector<InterestRate>& coupons,
                                 BusinessDayConvention paymentConvention,
                                 Real redemption,
                                 const Date& issueDate,
                                 const Calendar& paymentCalendar,
                                 const Period& exCouponPeriod,
                                 const Calendar& exCouponCalendar,
                                 const BusinessDayConvention exCouponConvention,
                                 bool exCouponEndOfMonth)
     : Bond(settlementDays,
            paymentCalendar==Calendar() ? schedule.calendar() : paymentCalendar,
            issueDate),
      frequency_(schedule.tenor().frequency()),
      dayCounter_(coupons[0].dayCounter()) {

        maturityDate_ = schedule.endDate();

        cashflows_ = FixedRateLeg(schedule)
            .withNotionals(faceAmount)
            .withCouponRates(coupons)
            .withPaymentCalendar(calendar_)
            .withPaymentAdjustment(paymentConvention)
            .withExCouponPeriod(exCouponPeriod,
                                exCouponCalendar,
                                exCouponConvention,
                                exCouponEndOfMonth);

        addRedemptionsToCashflows(std::vector<Real>(1, redemption));

        QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");
        QL_ENSURE(redemptions_.size() == 1, "multiple redemptions created");
    }

}
]]></document_content>
  </document>
  <document index="28">
    <source>bonds/fixedratebond.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Jeff Yu
 Copyright (C) 2004 M-Dimension Consulting Inc.
 Copyright (C) 2005 StatPro Italia srl
 Copyright (C) 2007, 2008, 2010 Ferdinando Ametrano
 Copyright (C) 2009 Piter Dias

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fixedratebond.hpp
    \brief fixed-rate bond
*/

#ifndef quantlib_fixed_rate_bond_hpp
#define quantlib_fixed_rate_bond_hpp

#include <ql/instruments/bond.hpp>
#include <ql/time/dategenerationrule.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/interestrate.hpp>

namespace QuantLib {

    class Schedule;

    //! fixed-rate bond
    /*! \ingroup instruments

        \test calculations are tested by checking results against
              cached values.
    */
    class FixedRateBond : public Bond {
      public:
        //! simple annual compounding coupon rates
        FixedRateBond(Natural settlementDays,
                      Real faceAmount,
                      const Schedule& schedule,
                      const std::vector<Rate>& coupons,
                      const DayCounter& accrualDayCounter,
                      BusinessDayConvention paymentConvention = Following,
                      Real redemption = 100.0,
                      const Date& issueDate = Date(),
                      const Calendar& paymentCalendar = Calendar(),
                      const Period& exCouponPeriod = Period(),
                      const Calendar& exCouponCalendar = Calendar(),
                      BusinessDayConvention exCouponConvention = Unadjusted,
                      bool exCouponEndOfMonth = false,
                      const DayCounter& firstPeriodDayCounter = DayCounter());
        /*! simple annual compounding coupon rates
            with internal schedule calculation */
        FixedRateBond(Natural settlementDays,
                      const Calendar& couponCalendar,
                      Real faceAmount,
                      const Date& startDate,
                      const Date& maturityDate,
                      const Period& tenor,
                      const std::vector<Rate>& coupons,
                      const DayCounter& accrualDayCounter,
                      BusinessDayConvention accrualConvention = Following,
                      BusinessDayConvention paymentConvention = Following,
                      Real redemption = 100.0,
                      const Date& issueDate = Date(),
                      const Date& stubDate = Date(),
                      DateGeneration::Rule rule = DateGeneration::Backward,
                      bool endOfMonth = false,
                      const Calendar& paymentCalendar = Calendar(),
                      const Period& exCouponPeriod = Period(),
                      const Calendar& exCouponCalendar = Calendar(),
                      BusinessDayConvention exCouponConvention = Unadjusted,
                      bool exCouponEndOfMonth = false,
                      const DayCounter& firstPeriodDayCounter = DayCounter());
        //! generic compounding and frequency InterestRate coupons
        FixedRateBond(Natural settlementDays,
                      Real faceAmount,
                      const Schedule& schedule,
                      const std::vector<InterestRate>& coupons,
                      BusinessDayConvention paymentConvention = Following,
                      Real redemption = 100.0,
                      const Date& issueDate = Date(),
                      const Calendar& paymentCalendar = Calendar(),
                      const Period& exCouponPeriod = Period(),
                      const Calendar& exCouponCalendar = Calendar(),
                      BusinessDayConvention exCouponConvention = Unadjusted,
                      bool exCouponEndOfMonth = false);
        Frequency frequency() const { return frequency_; }
        const DayCounter& dayCounter() const {return dayCounter_;}
        const DayCounter& firstPeriodDayCounter() const {return firstPeriodDayCounter_;}
      protected:
        Frequency frequency_;
        DayCounter dayCounter_;
        DayCounter firstPeriodDayCounter_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="29">
    <source>bonds/floatingratebond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Chiara Fornarola

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/bonds/floatingratebond.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/time/schedule.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/indexes/iborindex.hpp>

namespace QuantLib {

    FloatingRateBond::FloatingRateBond(
                           Natural settlementDays,
                           Real faceAmount,
                           const Schedule& schedule,
                           const ext::shared_ptr<IborIndex>& iborIndex,
                           const DayCounter& paymentDayCounter,
                           BusinessDayConvention paymentConvention,
                           Natural fixingDays,
                           const std::vector<Real>& gearings,
                           const std::vector<Spread>& spreads,
                           const std::vector<Rate>& caps,
                           const std::vector<Rate>& floors,
                           bool inArrears,
                           Real redemption,
                           const Date& issueDate,
                           const Period& exCouponPeriod,
                           const Calendar& exCouponCalendar,
                           const BusinessDayConvention exCouponConvention,
                           bool exCouponEndOfMonth)
    : Bond(settlementDays, schedule.calendar(), issueDate) {

        maturityDate_ = schedule.endDate();

        cashflows_ = IborLeg(schedule, iborIndex)
            .withNotionals(faceAmount)
            .withPaymentDayCounter(paymentDayCounter)
            .withPaymentAdjustment(paymentConvention)
            .withFixingDays(fixingDays)
            .withGearings(gearings)
            .withSpreads(spreads)
            .withCaps(caps)
            .withFloors(floors)
            .inArrears(inArrears)
            .withExCouponPeriod(exCouponPeriod, exCouponCalendar, exCouponConvention, exCouponEndOfMonth);

        addRedemptionsToCashflows(std::vector<Real>(1, redemption));

        QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");
        QL_ENSURE(redemptions_.size() == 1, "multiple redemptions created");

        registerWith(iborIndex);
    }

    FloatingRateBond::FloatingRateBond(
                           Natural settlementDays,
                           Real faceAmount,
                           const Date& startDate,
                           const Date& maturityDate,
                           Frequency couponFrequency,
                           const Calendar& calendar,
                           const ext::shared_ptr<IborIndex>& iborIndex,
                           const DayCounter& accrualDayCounter,
                           BusinessDayConvention accrualConvention,
                           BusinessDayConvention paymentConvention,
                           Natural fixingDays,
                           const std::vector<Real>& gearings,
                           const std::vector<Spread>& spreads,
                           const std::vector<Rate>& caps,
                           const std::vector<Rate>& floors,
                           bool inArrears,
                           Real redemption,
                           const Date& issueDate,
                           const Date& stubDate,
                           DateGeneration::Rule rule,
                           bool endOfMonth,
                           const Period& exCouponPeriod,
                           const Calendar& exCouponCalendar,
                           const BusinessDayConvention exCouponConvention,
                           bool exCouponEndOfMonth)
    : Bond(settlementDays, calendar, issueDate) {

        maturityDate_ = maturityDate;

        Date firstDate, nextToLastDate;
        switch (rule) {
          case DateGeneration::Backward:
            firstDate = Date();
            nextToLastDate = stubDate;
            break;
          case DateGeneration::Forward:
            firstDate = stubDate;
            nextToLastDate = Date();
            break;
          case DateGeneration::Zero:
          case DateGeneration::ThirdWednesday:
          case DateGeneration::Twentieth:
          case DateGeneration::TwentiethIMM:
            QL_FAIL("stub date (" << stubDate << ") not allowed with " <<
                    rule << " DateGeneration::Rule");
          default:
            QL_FAIL("unknown DateGeneration::Rule (" << Integer(rule) << ")");
        }

        Schedule schedule(startDate, maturityDate_, Period(couponFrequency),
                          calendar_, accrualConvention, accrualConvention,
                          rule, endOfMonth,
                          firstDate, nextToLastDate);

        cashflows_ = IborLeg(schedule, iborIndex)
            .withNotionals(faceAmount)
            .withPaymentDayCounter(accrualDayCounter)
            .withPaymentAdjustment(paymentConvention)
            .withFixingDays(fixingDays)
            .withGearings(gearings)
            .withSpreads(spreads)
            .withCaps(caps)
            .withFloors(floors)
            .inArrears(inArrears)
			.withExCouponPeriod(exCouponPeriod,exCouponCalendar, exCouponConvention, exCouponEndOfMonth);

        addRedemptionsToCashflows(std::vector<Real>(1, redemption));

        QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");
        QL_ENSURE(redemptions_.size() == 1, "multiple redemptions created");

        registerWith(iborIndex);
    }

}
]]></document_content>
  </document>
  <document index="30">
    <source>bonds/floatingratebond.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Chiara Fornarola

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file floatingratebond.hpp
    \brief floating-rate bond
*/

#ifndef quantlib_floating_rate_bond_hpp
#define quantlib_floating_rate_bond_hpp

#include <ql/instruments/bond.hpp>
#include <ql/time/dategenerationrule.hpp>

namespace QuantLib {

    class Schedule;
    class IborIndex;

    //! floating-rate bond (possibly capped and/or floored)
    /*! \ingroup instruments

        \test calculations are tested by checking results against
              cached values.
    */
    class FloatingRateBond : public Bond {
      public:
        FloatingRateBond(Natural settlementDays,
                         Real faceAmount,
                         const Schedule& schedule,
                         const ext::shared_ptr<IborIndex>& iborIndex,
                         const DayCounter& accrualDayCounter,
                         BusinessDayConvention paymentConvention = Following,
                         Natural fixingDays = Null<Natural>(),
                         const std::vector<Real>& gearings = std::vector<Real>(1, 1.0),
                         const std::vector<Spread>& spreads = std::vector<Spread>(1, 0.0),
                         const std::vector<Rate>& caps = std::vector<Rate>(),
                         const std::vector<Rate>& floors = std::vector<Rate>(),
                         bool inArrears = false,
                         Real redemption = 100.0,
                         const Date& issueDate = Date(),
                         const Period& exCouponPeriod = Period(),
                         const Calendar& exCouponCalendar = Calendar(),
                         BusinessDayConvention exCouponConvention = Unadjusted,
                         bool exCouponEndOfMonth = false);
        FloatingRateBond(Natural settlementDays,
                         Real faceAmount,
                         const Date& startDate,
                         const Date& maturityDate,
                         Frequency couponFrequency,
                         const Calendar& calendar,
                         const ext::shared_ptr<IborIndex>& iborIndex,
                         const DayCounter& accrualDayCounter,
                         BusinessDayConvention accrualConvention = Following,
                         BusinessDayConvention paymentConvention = Following,
                         Natural fixingDays = Null<Natural>(),
                         const std::vector<Real>& gearings = std::vector<Real>(1, 1.0),
                         const std::vector<Spread>& spreads = std::vector<Spread>(1, 0.0),
                         const std::vector<Rate>& caps = std::vector<Rate>(),
                         const std::vector<Rate>& floors = std::vector<Rate>(),
                         bool inArrears = false,
                         Real redemption = 100.0,
                         const Date& issueDate = Date(),
                         const Date& stubDate = Date(),
                         DateGeneration::Rule rule = DateGeneration::Backward,
                         bool endOfMonth = false,
                         const Period& exCouponPeriod = Period(),
                         const Calendar& exCouponCalendar = Calendar(),
                         BusinessDayConvention exCouponConvention = Unadjusted,
                         bool exCouponEndOfMonth = false);
    };

}

#endif
]]></document_content>
  </document>
  <document index="31">
    <source>bonds/zerocouponbond.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005, 2008 StatPro Italia srl
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/bonds/zerocouponbond.hpp>
#include <ql/cashflows/simplecashflow.hpp>

namespace QuantLib {

    ZeroCouponBond::ZeroCouponBond(Natural settlementDays,
                                   const Calendar& calendar,
                                   Real faceAmount,
                                   const Date& maturityDate,
                                   BusinessDayConvention paymentConvention,
                                   Real redemption,
                                   const Date& issueDate)
    : Bond(settlementDays, calendar, issueDate) {

        maturityDate_ = maturityDate;
        Date redemptionDate = calendar_.adjust(maturityDate,
                                               paymentConvention);
        setSingleRedemption(faceAmount, redemption, redemptionDate);
    }

}
]]></document_content>
  </document>
  <document index="32">
    <source>bonds/zerocouponbond.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2005 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file zerocouponbond.hpp
    \brief zero-coupon bond
*/

#ifndef quantlib_zero_coupon_bond_hpp
#define quantlib_zero_coupon_bond_hpp

#include <ql/instruments/bond.hpp>

namespace QuantLib {

    //! zero-coupon bond
    /*! \ingroup instruments

        \test calculations are tested by checking results against
              cached values.
    */
    class ZeroCouponBond : public Bond {
      public:
        ZeroCouponBond(Natural settlementDays,
                       const Calendar& calendar,
                       Real faceAmount,
                       const Date& maturityDate,
                       BusinessDayConvention paymentConvention = Following,
                       Real redemption = 100.0,
                       const Date& issueDate = Date());
    };

}

#endif
]]></document_content>
  </document>
  <document index="33">
    <source>callabilityschedule.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Joseph Wang
 Copyright (C) 2005, 2006 Theo Boafo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file callabilityschedule.hpp
    \brief Schedule of put/call dates
*/

#ifndef quantlib_callability_schedule_hpp
#define quantlib_callability_schedule_hpp

#include <ql/event.hpp>
#include <ql/instruments/bond.hpp>
#include <ql/patterns/visitor.hpp>
#include <ql/utilities/null.hpp>
#include <ql/shared_ptr.hpp>
#include <boost/optional.hpp>
#include <vector>

namespace QuantLib {

    //! %instrument callability
    class Callability : public Event {
      public:
        //! type of the callability
        enum Type { Call, Put };

        Callability(const Bond::Price& price, Type type, const Date& date)
        : price_(price), type_(type), date_(date) {}
        const Bond::Price& price() const {
            QL_REQUIRE(price_, "no price given");
            return *price_;
        }
        Type type() const { return type_; }
        //! \name Event interface
        //@{
        Date date() const override { return date_; }
        //@}
        //! \name Visitability
        //@{
        void accept(AcyclicVisitor&) override;
        //@}
      private:
        boost::optional<Bond::Price> price_;
        Type type_;
        Date date_;
    };

    inline void Callability::accept(AcyclicVisitor& v){
        auto* v1 = dynamic_cast<Visitor<Callability>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Event::accept(v);
    }

    typedef std::vector<ext::shared_ptr<Callability> > CallabilitySchedule;

}

#endif
]]></document_content>
  </document>
  <document index="34">
    <source>capfloor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2014 Ferdinando Ametrano
 Copyright (C) 2006 Franois du Vignaud
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2006, 2007 StatPro Italia srl
 Copyright (C) 2016 Paolo Mazzocchi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflows.hpp>
#include <ql/instruments/capfloor.hpp>
#include <ql/math/solvers1d/newtonsafe.hpp>
#include <ql/pricingengines/capfloor/bacheliercapfloorengine.hpp>
#include <ql/pricingengines/capfloor/blackcapfloorengine.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        class ImpliedCapVolHelper {
          public:
            ImpliedCapVolHelper(const CapFloor&,
                                Handle<YieldTermStructure> discountCurve,
                                Real targetValue,
                                Real displacement,
                                VolatilityType type);
            Real operator()(Volatility x) const;
            Real derivative(Volatility x) const;
          private:
            ext::shared_ptr<PricingEngine> engine_;
            Handle<YieldTermStructure> discountCurve_;
            Real targetValue_;
            ext::shared_ptr<SimpleQuote> vol_;
            const Instrument::results* results_;
        };

        ImpliedCapVolHelper::ImpliedCapVolHelper(const CapFloor& cap,
                                                 Handle<YieldTermStructure> discountCurve,
                                                 Real targetValue,
                                                 Real displacement,
                                                 VolatilityType type)
        : discountCurve_(std::move(discountCurve)), targetValue_(targetValue),
          vol_(ext::make_shared<SimpleQuote>(-1.0)) {

            // vol_ is set an implausible value, so that calculation is forced
            // at first ImpliedCapVolHelper::operator()(Volatility x) call
            Handle<Quote> h(vol_);

            switch (type) {
            case ShiftedLognormal:
                engine_ = ext::shared_ptr<PricingEngine>(new
                    BlackCapFloorEngine(discountCurve_, h, Actual365Fixed(),
                                                                displacement));
                break;
            case Normal:
                engine_ = ext::shared_ptr<PricingEngine>(new
                    BachelierCapFloorEngine(discountCurve_, h, 
                                                            Actual365Fixed()));
                break;
            default:
                QL_FAIL("unknown VolatilityType (" << type << ")");
                break;
            }

            cap.setupArguments(engine_->getArguments());

            results_ =
                dynamic_cast<const Instrument::results*>(engine_->getResults());
        }

        Real ImpliedCapVolHelper::operator()(Volatility x) const {
            if (x!=vol_->value()) {
                vol_->setValue(x);
                engine_->calculate();
            }
            return results_->value-targetValue_;
        }

        Real ImpliedCapVolHelper::derivative(Volatility x) const {
            if (x!=vol_->value()) {
                vol_->setValue(x);
                engine_->calculate();
            }
            auto vega_ = results_->additionalResults.find("vega");
            QL_REQUIRE(vega_ != results_->additionalResults.end(),
                       "vega not provided");
            return boost::any_cast<Real>(vega_->second);
        }
    }

    std::ostream& operator<<(std::ostream& out,
                             CapFloor::Type t) {
        switch (t) {
          case CapFloor::Cap:
            return out << "Cap";
          case CapFloor::Floor:
            return out << "Floor";
          case CapFloor::Collar:
            return out << "Collar";
          default:
            QL_FAIL("unknown CapFloor::Type (" << Integer(t) << ")");
        }
    }

    CapFloor::CapFloor(CapFloor::Type type,
                       Leg floatingLeg,
                       std::vector<Rate> capRates,
                       std::vector<Rate> floorRates)
    : type_(type), floatingLeg_(std::move(floatingLeg)), capRates_(std::move(capRates)),
      floorRates_(std::move(floorRates)) {
        if (type_ == Cap || type_ == Collar) {
            QL_REQUIRE(!capRates_.empty(), "no cap rates given");
            capRates_.reserve(floatingLeg_.size());
            while (capRates_.size() < floatingLeg_.size())
                capRates_.push_back(capRates_.back());
        }
        if (type_ == Floor || type_ == Collar) {
            QL_REQUIRE(!floorRates_.empty(), "no floor rates given");
            floorRates_.reserve(floatingLeg_.size());
            while (floorRates_.size() < floatingLeg_.size())
                floorRates_.push_back(floorRates_.back());
        }
        Leg::const_iterator i;
        for (i = floatingLeg_.begin(); i != floatingLeg_.end(); ++i)
            registerWith(*i);

        registerWith(Settings::instance().evaluationDate());
    }

    CapFloor::CapFloor(CapFloor::Type type, Leg floatingLeg, const std::vector<Rate>& strikes)
    : type_(type), floatingLeg_(std::move(floatingLeg)) {
        QL_REQUIRE(!strikes.empty(), "no strikes given");
        if (type_ == Cap) {
            capRates_ = strikes;
            capRates_.reserve(floatingLeg_.size());
            while (capRates_.size() < floatingLeg_.size())
                capRates_.push_back(capRates_.back());
        } else if (type_ == Floor) {
            floorRates_ = strikes;
            floorRates_.reserve(floatingLeg_.size());
            while (floorRates_.size() < floatingLeg_.size())
                floorRates_.push_back(floorRates_.back());
        } else
            QL_FAIL("only Cap/Floor types allowed in this constructor");

        Leg::const_iterator i;
        for (i = floatingLeg_.begin(); i != floatingLeg_.end(); ++i)
            registerWith(*i);

        registerWith(Settings::instance().evaluationDate());
    }

    bool CapFloor::isExpired() const {
        for (Size i=floatingLeg_.size(); i>0; --i)
            if (!floatingLeg_[i-1]->hasOccurred())
                return false;
        return true;
    }

    Date CapFloor::startDate() const {
        return CashFlows::startDate(floatingLeg_);
    }

    Date CapFloor::maturityDate() const {
        return CashFlows::maturityDate(floatingLeg_);
    }

    ext::shared_ptr<FloatingRateCoupon>
    CapFloor::lastFloatingRateCoupon() const {
        ext::shared_ptr<CashFlow> lastCF(floatingLeg_.back());
        ext::shared_ptr<FloatingRateCoupon> lastFloatingCoupon =
            ext::dynamic_pointer_cast<FloatingRateCoupon>(lastCF);
        return lastFloatingCoupon;
    }

    ext::shared_ptr<CapFloor> CapFloor::optionlet(const Size i) const {
        QL_REQUIRE(i < floatingLeg().size(),
                   io::ordinal(i+1) << " optionlet does not exist, only " <<
                   floatingLeg().size());
        Leg cf(1, floatingLeg()[i]);

        std::vector<Rate> cap, floor;
        if (type() == Cap || type() == Collar)
            cap.push_back(capRates()[i]);
        if (type() == Floor || type() == Collar)
            floor.push_back(floorRates()[i]);

        return ext::make_shared<CapFloor>(type(), cf, cap, floor);
    }

    void CapFloor::setupArguments(PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<CapFloor::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        Size n = floatingLeg_.size();

        arguments->startDates.resize(n);
        arguments->fixingDates.resize(n);
        arguments->endDates.resize(n);
        arguments->accrualTimes.resize(n);
        arguments->forwards.resize(n);
        arguments->nominals.resize(n);
        arguments->gearings.resize(n);
        arguments->capRates.resize(n);
        arguments->floorRates.resize(n);
        arguments->spreads.resize(n);
        arguments->indexes.resize(n);

        arguments->type = type_;

        Date today = Settings::instance().evaluationDate();

        for (Size i=0; i<n; ++i) {
            ext::shared_ptr<FloatingRateCoupon> coupon =
                ext::dynamic_pointer_cast<FloatingRateCoupon>(
                                                             floatingLeg_[i]);
            QL_REQUIRE(coupon, "non-FloatingRateCoupon given");
            arguments->startDates[i] = coupon->accrualStartDate();
            arguments->fixingDates[i] = coupon->fixingDate();
            arguments->endDates[i] = coupon->date();

            // this is passed explicitly for precision
            arguments->accrualTimes[i] = coupon->accrualPeriod();

            // this is passed explicitly for precision...
            if (arguments->endDates[i] >= today) { // ...but only if needed
                arguments->forwards[i] = coupon->adjustedFixing();
            } else {
                arguments->forwards[i] = Null<Rate>();
            }

            arguments->nominals[i] = coupon->nominal();
            Spread spread = coupon->spread();
            Real gearing = coupon->gearing();
            arguments->gearings[i] = gearing;
            arguments->spreads[i] = spread;

            if (type_ == Cap || type_ == Collar)
                arguments->capRates[i] = (capRates_[i]-spread)/gearing;
            else
                arguments->capRates[i] = Null<Rate>();

            if (type_ == Floor || type_ == Collar)
                arguments->floorRates[i] = (floorRates_[i]-spread)/gearing;
            else
                arguments->floorRates[i] = Null<Rate>();

            arguments->indexes[i] = coupon->index();
        }
    }

    void CapFloor::deepUpdate() {
        for (auto& i : floatingLeg_) {
            ext::shared_ptr<LazyObject> f = ext::dynamic_pointer_cast<LazyObject>(i);
            if (f != nullptr)
                f->update();
        }
        update();
    }

    void CapFloor::arguments::validate() const {
        QL_REQUIRE(endDates.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of end dates ("
                   << endDates.size() << ")");
        QL_REQUIRE(accrualTimes.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of accrual times ("
                   << accrualTimes.size() << ")");
        QL_REQUIRE(type == CapFloor::Floor ||
                   capRates.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of cap rates ("
                   << capRates.size() << ")");
        QL_REQUIRE(type == CapFloor::Cap ||
                   floorRates.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of floor rates ("
                   << floorRates.size() << ")");
        QL_REQUIRE(gearings.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of gearings ("
                   << gearings.size() << ")");
        QL_REQUIRE(spreads.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of spreads ("
                   << spreads.size() << ")");
        QL_REQUIRE(nominals.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of nominals ("
                   << nominals.size() << ")");
        QL_REQUIRE(forwards.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of forwards ("
                   << forwards.size() << ")");
    }

    Rate CapFloor::atmRate(const YieldTermStructure& discountCurve) const {
        bool includeSettlementDateFlows = false;
        Date settlementDate = discountCurve.referenceDate();
        return CashFlows::atmRate(floatingLeg_, discountCurve,
                                  includeSettlementDateFlows,
                                  settlementDate);
    }

    Volatility CapFloor::impliedVolatility(Real targetValue,
                                           const Handle<YieldTermStructure>& d,
                                           Volatility guess,
                                           Real accuracy,
                                           Natural maxEvaluations,
                                           Volatility minVol,
                                           Volatility maxVol,
                                           VolatilityType type,
                                           Real displacement) const {
        //calculate();
        QL_REQUIRE(!isExpired(), "instrument expired");

        ImpliedCapVolHelper f(*this, d, targetValue, displacement, type);
        //Brent solver;
        NewtonSafe solver;
        solver.setMaxEvaluations(maxEvaluations);
        return solver.solve(f, accuracy, guess, minVol, maxVol);
    }

}
]]></document_content>
  </document>
  <document index="35">
    <source>capfloor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2006, 2014 Ferdinando Ametrano
 Copyright (C) 2006 Franois du Vignaud
 Copyright (C) 2006, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file capfloor.hpp
    \brief cap and floor class
*/

#ifndef quantlib_instruments_capfloor_hpp
#define quantlib_instruments_capfloor_hpp

#include <ql/instrument.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/handle.hpp>
#include <ql/termstructures/volatility/volatilitytype.hpp>

namespace QuantLib {

    class YieldTermStructure;

    //! Base class for cap-like instruments
    /*! \ingroup instruments

        \test
        - the correctness of the returned value is tested by checking
          that the price of a cap (resp. floor) decreases
          (resp. increases) with the strike rate.
        - the relationship between the values of caps, floors and the
          resulting collars is checked.
        - the put-call parity between the values of caps, floors and
          swaps is checked.
        - the correctness of the returned implied volatility is tested
          by using it for reproducing the target value.
        - the correctness of the returned value is tested by checking
          it against a known good value.
    */
    class CapFloor : public Instrument {
      public:
        enum Type { Cap, Floor, Collar };
        class arguments;
        class engine;
        CapFloor(Type type,
                 Leg floatingLeg,
                 std::vector<Rate> capRates,
                 std::vector<Rate> floorRates);
        CapFloor(Type type, Leg floatingLeg, const std::vector<Rate>& strikes);
        //! \name Observable interface
        //@{
        void deepUpdate() override;
        //@}
        //! \name Instrument interface
        //@{
        bool isExpired() const override;
        void setupArguments(PricingEngine::arguments*) const override;
        //@}
        //! \name Inspectors
        //@{
        Type type() const { return type_; }
        const std::vector<Rate>& capRates() const { return capRates_; }
        const std::vector<Rate>& floorRates() const { return floorRates_; }
        const Leg& floatingLeg() const { return floatingLeg_; }

        Date startDate() const;
        Date maturityDate() const;
        ext::shared_ptr<FloatingRateCoupon> lastFloatingRateCoupon() const;
        //! Returns the n-th optionlet as a new CapFloor with only one cash flow.
        ext::shared_ptr<CapFloor> optionlet(Size n) const;
        //@}
        Rate atmRate(const YieldTermStructure& discountCurve) const;
        //! implied term volatility
        Volatility impliedVolatility(
                                 Real price,
                                 const Handle<YieldTermStructure>& disc,
                                 Volatility guess,
                                 Real accuracy = 1.0e-4,
                                 Natural maxEvaluations = 100,
                                 Volatility minVol = 1.0e-7,
                                 Volatility maxVol = 4.0,
                                 VolatilityType type = ShiftedLognormal,
                                 Real displacement = 0.0) const;
      private:
        Type type_;
        Leg floatingLeg_;
        std::vector<Rate> capRates_;
        std::vector<Rate> floorRates_;
    };

    //! Concrete cap class
    /*! \ingroup instruments */
    class Cap : public CapFloor {
      public:
        Cap(const Leg& floatingLeg,
            const std::vector<Rate>& exerciseRates)
        : CapFloor(CapFloor::Cap, floatingLeg,
                   exerciseRates, std::vector<Rate>()) {}
    };

    //! Concrete floor class
    /*! \ingroup instruments */
    class Floor : public CapFloor {
      public:
        Floor(const Leg& floatingLeg,
              const std::vector<Rate>& exerciseRates)
        : CapFloor(CapFloor::Floor, floatingLeg,
                   std::vector<Rate>(), exerciseRates) {}
    };

    //! Concrete collar class
    /*! \ingroup instruments */
    class Collar : public CapFloor {
      public:
        Collar(const Leg& floatingLeg,
               const std::vector<Rate>& capRates,
               const std::vector<Rate>& floorRates)
        : CapFloor(CapFloor::Collar, floatingLeg, capRates, floorRates) {}
    };


    //! %Arguments for cap/floor calculation
    class CapFloor::arguments : public virtual PricingEngine::arguments {
      public:
        arguments() : type(CapFloor::Type(-1)) {}
        CapFloor::Type type;
        std::vector<Date> startDates;
        std::vector<Date> fixingDates;
        std::vector<Date> endDates;
        std::vector<Time> accrualTimes;
        std::vector<Rate> capRates;
        std::vector<Rate> floorRates;
        std::vector<Rate> forwards;
        std::vector<Real> gearings;
        std::vector<Real> spreads;
        std::vector<Real> nominals;
        std::vector<ext::shared_ptr<InterestRateIndex> > indexes;
        void validate() const override;
    };

    //! base class for cap/floor engines
    class CapFloor::engine
        : public GenericEngine<CapFloor::arguments, CapFloor::results> {};

    std::ostream& operator<<(std::ostream&, CapFloor::Type);

}

#endif
]]></document_content>
  </document>
  <document index="36">
    <source>claim.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/claim.hpp>

namespace QuantLib {

    Real FaceValueClaim::amount(const Date&,
                                Real notional,
                                Real recoveryRate) const {
        return notional * (1.0-recoveryRate);
    }



    FaceValueAccrualClaim::FaceValueAccrualClaim(
                          const ext::shared_ptr<Bond>& referenceSecurity)
    : referenceSecurity_(referenceSecurity) {
        registerWith(referenceSecurity);
    }

    Real FaceValueAccrualClaim::amount(const Date& d,
                                       Real notional,
                                       Real recoveryRate) const {
        Real accrual = referenceSecurity_->accruedAmount(d)
                     / referenceSecurity_->notional(d);
        return notional * (1.0-recoveryRate-accrual);
    }

}

]]></document_content>
  </document>
  <document index="37">
    <source>claim.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file claim.hpp
    \brief Classes for default-event claims.
*/

#ifndef quantlib_claim_hpp
#define quantlib_claim_hpp

#include <ql/instruments/bond.hpp>

namespace QuantLib {

    //! Claim associated to a default event
    class Claim : public Observable, public Observer {
      public:
        ~Claim() override = default;
        virtual Real amount(const Date& defaultDate,
                            Real notional,
                            Real recoveryRate) const = 0;
        void update() override { notifyObservers(); }
    };


    //! Claim on a notional
    class FaceValueClaim : public Claim {
      public:
        Real amount(const Date& d, Real notional, Real recoveryRate) const override;
    };

    //! Claim on the notional of a reference security, including accrual
    class FaceValueAccrualClaim : public Claim {
      public:
        FaceValueAccrualClaim(
                          const ext::shared_ptr<Bond>& referenceSecurity);
        Real amount(const Date& d, Real notional, Real recoveryRate) const override;

      private:
        ext::shared_ptr<Bond> referenceSecurity_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="38">
    <source>cliquetoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/instruments/cliquetoption.hpp>
#include <utility>

namespace QuantLib {

    CliquetOption::CliquetOption(const ext::shared_ptr<PercentageStrikePayoff>& payoff,
                                 const ext::shared_ptr<EuropeanExercise>& maturity,
                                 std::vector<Date> resetDates)
    : OneAssetOption(payoff, maturity), resetDates_(std::move(resetDates)) {}

    void CliquetOption::setupArguments(PricingEngine::arguments* args) const {
        OneAssetOption::setupArguments(args);
        // set accrued coupon, last fixing, caps, floors
        auto* moreArgs = dynamic_cast<CliquetOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong engine type");
        moreArgs->resetDates = resetDates_;
    }

    void CliquetOption::arguments::validate() const {
        OneAssetOption::arguments::validate();

        ext::shared_ptr<PercentageStrikePayoff> moneyness =
            ext::dynamic_pointer_cast<PercentageStrikePayoff>(payoff);
        QL_REQUIRE(moneyness,
                   "wrong payoff type");
        QL_REQUIRE(moneyness->strike() > 0.0,
                   "negative or zero moneyness given");
        QL_REQUIRE(accruedCoupon == Null<Real>() || accruedCoupon >= 0.0,
                   "negative accrued coupon");
        QL_REQUIRE(localCap == Null<Real>() || localCap >= 0.0,
                   "negative local cap");
        QL_REQUIRE(localFloor == Null<Real>() || localFloor >= 0.0,
                   "negative local floor");
        QL_REQUIRE(globalCap == Null<Real>() || globalCap >= 0.0,
                   "negative global cap");
        QL_REQUIRE(globalFloor == Null<Real>() || globalFloor >= 0.0,
                   "negative global floor");
        QL_REQUIRE(!resetDates.empty(),
                   "no reset dates given");
        for (Size i=0; i<resetDates.size(); ++i) {
            QL_REQUIRE(exercise->lastDate() > resetDates[i],
                       "reset date greater or equal to maturity");
            QL_REQUIRE(i == 0 || resetDates[i] > resetDates[i-1],
                       "unsorted reset dates");
        }
    }

}
]]></document_content>
  </document>
  <document index="39">
    <source>cliquetoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file cliquetoption.hpp
    \brief Cliquet option
*/

#ifndef ql_cliquet_option_hpp
#define ql_cliquet_option_hpp

#include <ql/instruments/oneassetoption.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/time/date.hpp>
#include <vector>

namespace QuantLib {

    class EuropeanExercise;

    //! cliquet (Ratchet) option
    /*! A cliquet option, also known as Ratchet option, is a series of
        forward-starting (a.k.a. deferred strike) options where the
        strike for each forward start option is set equal to a fixed
        percentage of the spot price at the beginning of each period.

        \todo
        - add local/global caps/floors
        - add accrued coupon and last fixing

        \ingroup instruments
    */
    class CliquetOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        CliquetOption(const ext::shared_ptr<PercentageStrikePayoff>&,
                      const ext::shared_ptr<EuropeanExercise>& maturity,
                      std::vector<Date> resetDates);
        void setupArguments(PricingEngine::arguments*) const override;

      private:
        std::vector<Date> resetDates_;
    };

    //! %Arguments for cliquet option calculation
    // should inherit from a strikeless version of VanillaOption::arguments
    class CliquetOption::arguments : public OneAssetOption::arguments {
      public:
        arguments() : accruedCoupon(Null<Real>()),
                      lastFixing(Null<Real>()),
                      localCap(Null<Real>()),
                      localFloor(Null<Real>()),
                      globalCap(Null<Real>()),
                      globalFloor(Null<Real>()) {}
        void validate() const override;
        Real accruedCoupon, lastFixing;
        Real localCap, localFloor, globalCap, globalFloor;
        std::vector<Date> resetDates;
    };

    //! Cliquet %engine base class
    class CliquetOption::engine
        : public GenericEngine<CliquetOption::arguments,
                               CliquetOption::results> {};

}


#endif
]]></document_content>
  </document>
  <document index="40">
    <source>compositeinstrument.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/compositeinstrument.hpp>

namespace QuantLib {

    void CompositeInstrument::add(
           const ext::shared_ptr<Instrument>& instrument, Real multiplier) {
        components_.emplace_back(instrument, multiplier);
        registerWith(instrument);
        update();
        // When we ask for the NPV of an expired composite, the
        // components are not recalculated and thus wouldn't forward
        // later notifications according to the default behavior of
        // LazyObject instances.  This means that even if the
        // evaluation date changes so that the composite is no longer
        // expired, the instrument wouldn't be notified and thus it
        // wouldn't recalculate.  To avoid this, we override the
        // default behavior of the components.
        instrument->alwaysForwardNotifications();
    }

    void CompositeInstrument::subtract(
           const ext::shared_ptr<Instrument>& instrument, Real multiplier) {
        add(instrument, -multiplier);
    }

    bool CompositeInstrument::isExpired() const {
        for (const auto& component : components_) {
            if (!component.first->isExpired())
                return false;
        }
        return true;
    }

    void CompositeInstrument::performCalculations() const {
        NPV_ = 0.0;
        for (const auto& component : components_) {
            NPV_ += component.second * component.first->NPV();
        }
    }

    void CompositeInstrument::deepUpdate() {
        for (const_iterator i=components_.begin(); i!=components_.end(); ++i) {
            i->first->deepUpdate();
        }
        update();
    }

}

]]></document_content>
  </document>
  <document index="41">
    <source>compositeinstrument.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file compositeinstrument.hpp
    \brief Composite instrument class
*/

#ifndef quantlib_composite_instrument_hpp
#define quantlib_composite_instrument_hpp

#include <ql/instrument.hpp>
#include <list>
#include <utility>

namespace QuantLib {

    //! %Composite instrument
    /*! This instrument is an aggregate of other instruments. Its NPV
        is the sum of the NPVs of its components, each possibly
        multiplied by a given factor.

        \warning Methods that drive the calculation directly (such as
                 recalculate(), freeze() and others) might not work
                 correctly.

        \ingroup instruments
    */
    class CompositeInstrument : public Instrument {
        typedef std::pair<ext::shared_ptr<Instrument>, Real> component;
        typedef std::list<component>::iterator iterator;
        typedef std::list<component>::const_iterator const_iterator;
      public:
        //! adds an instrument to the composite
        void add(const ext::shared_ptr<Instrument>& instrument,
                 Real multiplier = 1.0);
        //! shorts an instrument from the composite
        void subtract(const ext::shared_ptr<Instrument>& instrument,
                      Real multiplier = 1.0);
        //! \name Observer interface
        //@{
        void deepUpdate() override;
        //@}
        //! \name Instrument interface
        //@{
        bool isExpired() const override;

      protected:
        void performCalculations() const override;
        //@}
      private:
        std::list<component> components_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="42">
    <source>cpicapfloor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2011 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */


#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/indexes/inflationindex.hpp>
#include <ql/instruments/cpicapfloor.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/time/schedule.hpp>
#include <utility>


namespace QuantLib {

    CPICapFloor::CPICapFloor(Option::Type type,
                             Real nominal,
                             const Date& startDate, // start date of contract (only)
                             Real baseCPI,
                             const Date& maturity, // this is pre-adjustment!
                             Calendar fixCalendar,
                             BusinessDayConvention fixConvention,
                             Calendar payCalendar,
                             BusinessDayConvention payConvention,
                             Rate strike,
                             Handle<ZeroInflationIndex> infIndex,
                             const Period& observationLag,
                             CPI::InterpolationType observationInterpolation)
    : type_(type), nominal_(nominal), startDate_(startDate), baseCPI_(baseCPI), maturity_(maturity),
      fixCalendar_(std::move(fixCalendar)), fixConvention_(fixConvention),
      payCalendar_(std::move(payCalendar)), payConvention_(payConvention), strike_(strike),
      infIndex_(std::move(infIndex)), observationLag_(observationLag),
      observationInterpolation_(observationInterpolation) {
        QL_REQUIRE(fixCalendar_ != Calendar(),"CPICapFloor: fixing calendar may not be null.");
        QL_REQUIRE(payCalendar_ != Calendar(),"CPICapFloor: payment calendar may not be null.");

        if (observationInterpolation_ == CPI::Flat  ||
            (observationInterpolation_ == CPI::AsIndex && !infIndex_->interpolated())
            ) {
            QL_REQUIRE(observationLag_ >= infIndex_->availabilityLag(),
                       "CPIcapfloor's observationLag must be at least availabilityLag of inflation index: "
                       <<"when the observation is effectively flat"
                       << observationLag_ << " vs " << infIndex_->availabilityLag());
        }
        if (observationInterpolation_ == CPI::Linear ||
            (observationInterpolation_ == CPI::AsIndex && infIndex_->interpolated())
            ) {
            QL_REQUIRE(observationLag_ > infIndex_->availabilityLag(),
                       "CPIcapfloor's observationLag must be greater than availabilityLag of inflation index: "
                       <<"when the observation is effectively linear"
                       << observationLag_ << " vs " << infIndex_->availabilityLag());
        }
    }


    //! when you fix - but remember that there is an observation interpolation factor as well
    Date CPICapFloor::fixingDate() const {
        return fixCalendar_.adjust(maturity_ - observationLag_, fixConvention_);
    }


    Date CPICapFloor::payDate() const {
        return payCalendar_.adjust(maturity_, payConvention_);
    }


    bool CPICapFloor::isExpired() const {
        return (Settings::instance().evaluationDate() > maturity_);
    }


    void CPICapFloor::arguments::validate() const {
        // nothing yet
    }


    void CPICapFloor::setupArguments(PricingEngine::arguments* args) const {

        // correct PricingEngine?
        auto* arguments = dynamic_cast<CPICapFloor::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type, not CPICapFloor::arguments*");

        // data move
        arguments->type = type_;
        arguments->nominal = nominal_;
        arguments->startDate = startDate_;
        arguments->baseCPI = baseCPI_;
        arguments->maturity = maturity_;
        arguments->fixCalendar = fixCalendar_;
        arguments->fixConvention = fixConvention_;
        arguments->payCalendar = fixCalendar_;
        arguments->payConvention = payConvention_;
        arguments->fixDate = fixingDate();
        arguments->payDate = payDate();
        arguments->strike = strike_;
        arguments->infIndex = infIndex_;
        arguments->observationLag = observationLag_;
        arguments->observationInterpolation = observationInterpolation_;

    }


    void CPICapFloor::results::reset() {
        Instrument::results::reset();
    }


    void CPICapFloor::fetchResults(const PricingEngine::results* r) const {
        Instrument::fetchResults(r);
    }



}
]]></document_content>
  </document>
  <document index="43">
    <source>cpicapfloor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2011 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

/*! \file cpicapfloor.hpp
 \brief zero-inflation-indexed-ratio-with-base option
 */


#ifndef quantlib_cpicapfloor_hpp
#define quantlib_cpicapfloor_hpp

#include <ql/instrument.hpp>
#include <ql/option.hpp>
#include <ql/time/calendar.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/indexes/inflationindex.hpp>
#include <ql/cashflows/cpicoupon.hpp>

namespace QuantLib {

    //! CPI cap or floor
    /*! Quoted as a fixed strike rate \f$ K \f$.  Payoff:
     \f[
     P_n(0,T) \max(y (N [(1+K)^{T}-1] -
                 N \left[ \frac{I(T)}{I(0)} -1 \right]), 0)
     \f]
     where \f$ T \f$ is the maturity time, \f$ P_n(0,t) \f$ is the
     nominal discount factor at time \f$ t \f$, \f$ N \f$ is the
     notional, and \f$ I(t) \f$ is the inflation index value at
     time \f$ t \f$.

     Inflation is generally available on every day, including
     holidays and weekends.  Hence there is a variable to state
     whether the observe/fix dates for inflation are adjusted or
     not.  The default is not to adjust.

     N.B. a cpi cap or floor is an option, not a cap or floor on a coupon.
     Thus this is very similar to a ZCIIS and has a single flow, this is
     as usual for cpi because it is cumulative up to option maturity from base
     date.

     We do not inherit from Option, although this would be reasonable,
     because we do not have that degree of generality.

     */
    class CPICapFloor : public Instrument {
    public:
        class arguments;
        class results;
        class engine;
        CPICapFloor(Option::Type type,
                    Real nominal,
                    const Date& startDate, // start date of contract (only)
                    Real baseCPI,
                    const Date& maturity, // this is pre-adjustment!
                    Calendar fixCalendar,
                    BusinessDayConvention fixConvention,
                    Calendar payCalendar,
                    BusinessDayConvention payConvention,
                    Rate strike,
                    Handle<ZeroInflationIndex> infIndex,
                    const Period& observationLag,
                    CPI::InterpolationType observationInterpolation = CPI::AsIndex);

        //! \name Inspectors
        //@{
        Option::Type type() const { return type_; }
        Real nominal() const { return nominal_; }
        //! \f$ K \f$ in the above formula.
        Rate strike() const { return strike_; }
        Date fixingDate() const;
        Date payDate() const;
        Handle<ZeroInflationIndex> inflationIndex() const { return infIndex_; }
        Period observationLag() const { return observationLag_; }
        //@}

        //! \name Instrument interface
        //@{
        bool isExpired() const override;
        void setupArguments(PricingEngine::arguments*) const override;
        void fetchResults(const PricingEngine::results* r) const override;
        //@}

    protected:
        Option::Type type_;
        Real nominal_;
        Date startDate_, fixDate_, payDate_;
        Real baseCPI_;
        Date maturity_;
        Calendar fixCalendar_;
        BusinessDayConvention fixConvention_;
        Calendar payCalendar_;
        BusinessDayConvention payConvention_;
        Rate strike_;
        Handle<ZeroInflationIndex> infIndex_;
        Period observationLag_;
        CPI::InterpolationType observationInterpolation_;
    };


    class CPICapFloor::arguments : public virtual PricingEngine::arguments{
    public:
        Option::Type type;
        Real nominal;
        Date startDate, fixDate, payDate;
        Real baseCPI;
        Date maturity;
        Calendar fixCalendar, payCalendar;
        BusinessDayConvention fixConvention, payConvention;
        Rate strike;
        Handle<ZeroInflationIndex> infIndex;
        Period observationLag;
        CPI::InterpolationType observationInterpolation;

        void validate() const override;
    };


    class CPICapFloor::results : public Instrument::results {
    public:
      void reset() override;
    };


    class CPICapFloor::engine : public GenericEngine<CPICapFloor::arguments,
                                                     CPICapFloor::results> {
    };

}


#endif

]]></document_content>
  </document>
  <document index="44">
    <source>cpiswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009, 2011 Chris Kenyon
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/cpicoupon.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/indexes/inflationindex.hpp>
#include <ql/instruments/cpiswap.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/time/schedule.hpp>
#include <utility>

namespace QuantLib {

    // accrual adjustment is already in the schedules, as are calendars
    CPISwap::CPISwap(Type type,
                     Real nominal,
                     bool subtractInflationNominal,
                     // float + spread leg
                     Spread spread,
                     DayCounter floatDayCount,
                     Schedule floatSchedule,
                     const BusinessDayConvention& floatPaymentRoll,
                     Natural fixingDays,
                     ext::shared_ptr<IborIndex> floatIndex,
                     // fixed x inflation leg
                     Rate fixedRate,
                     Real baseCPI,
                     DayCounter fixedDayCount,
                     Schedule fixedSchedule,
                     const BusinessDayConvention& fixedPaymentRoll,
                     const Period& observationLag,
                     ext::shared_ptr<ZeroInflationIndex> fixedIndex,
                     CPI::InterpolationType observationInterpolation,
                     Real inflationNominal)
    : Swap(2), type_(type), nominal_(nominal), subtractInflationNominal_(subtractInflationNominal),
      spread_(spread), floatDayCount_(std::move(floatDayCount)),
      floatSchedule_(std::move(floatSchedule)), floatPaymentRoll_(floatPaymentRoll),
      fixingDays_(fixingDays), floatIndex_(std::move(floatIndex)), fixedRate_(fixedRate),
      baseCPI_(baseCPI), fixedDayCount_(std::move(fixedDayCount)),
      fixedSchedule_(std::move(fixedSchedule)), fixedPaymentRoll_(fixedPaymentRoll),
      fixedIndex_(std::move(fixedIndex)), observationLag_(observationLag),
      observationInterpolation_(observationInterpolation) {
        QL_REQUIRE(!floatSchedule_.empty(), "empty float schedule");
        QL_REQUIRE(!fixedSchedule_.empty(), "empty fixed schedule");
        // \todo if roll!=unadjusted then need calendars ...

        if (inflationNominal==Null<Real>()) inflationNominal_ = nominal_;
        else inflationNominal_ = inflationNominal;

        Leg floatingLeg;
        if (floatSchedule_.size() > 1) {
            floatingLeg = IborLeg(floatSchedule_, floatIndex_)
            .withNotionals(nominal_)
            .withSpreads(spread_)
            .withPaymentDayCounter(floatDayCount_)
            .withPaymentAdjustment(floatPaymentRoll_)
            .withFixingDays(fixingDays_);
        }

        if (floatSchedule_.size()==1 ||
            !subtractInflationNominal_ ||
            (subtractInflationNominal && std::fabs(nominal_-inflationNominal_)>0.00001)
            )
        {
            Date payNotional;
            if (floatSchedule_.size()==1) { // no coupons
                payNotional = floatSchedule_[0];
                payNotional = floatSchedule_.calendar().adjust(payNotional, floatPaymentRoll_);
            } else { // use the pay date of the last coupon
                payNotional = floatingLeg.back()->date();
            }

            Real floatAmount = subtractInflationNominal_ ? nominal_ - inflationNominal_ : nominal_;
            ext::shared_ptr<CashFlow> nf(new SimpleCashFlow(floatAmount, payNotional));
            floatingLeg.push_back(nf);
        }

        // a CPIleg know about zero legs and inclusion of base inflation notional
        Leg cpiLeg = CPILeg(fixedSchedule_, fixedIndex_,
                            baseCPI_, observationLag_)
        .withNotionals(inflationNominal_)
        .withFixedRates(fixedRate_)
        .withPaymentDayCounter(fixedDayCount_)
        .withPaymentAdjustment(fixedPaymentRoll_)
        .withObservationInterpolation(observationInterpolation_)
        .withSubtractInflationNominal(subtractInflationNominal_);


        Leg::const_iterator i;
        for (i = cpiLeg.begin(); i < cpiLeg.end(); ++i) {
            registerWith(*i);
        }

        for (i = floatingLeg.begin(); i < floatingLeg.end(); ++i) {
            registerWith(*i);
        }

        legs_[0] = cpiLeg;
        legs_[1] = floatingLeg;

        if (type_==Payer) {
            payer_[0] = 1.0;
            payer_[1] = -1.0;
        } else {
            payer_[0] = -1.0;
            payer_[1] = 1.0;
        }
    }


    //! for simple case sufficient to copy base class
    void CPISwap::setupArguments(PricingEngine::arguments* args) const {

        Swap::setupArguments(args);

        auto* arguments = dynamic_cast<CPISwap::arguments*>(args);

        if (arguments == nullptr)
            return; // it's a swap engine...
    }


    Rate CPISwap::fairRate() const {
        calculate();
        QL_REQUIRE(fairRate_ != Null<Rate>(), "result not available");
        return fairRate_;
    }

    Spread CPISwap::fairSpread() const {
        calculate();
        QL_REQUIRE(fairSpread_ != Null<Spread>(), "result not available");
        return fairSpread_;
    }


    Real CPISwap::fixedLegNPV() const {//FIXME
        calculate();
        QL_REQUIRE(legNPV_[0] != Null<Real>(), "result not available");
        return legNPV_[0];
    }

    Real CPISwap::floatLegNPV() const {//FIXME
        calculate();
        QL_REQUIRE(legNPV_[1] != Null<Real>(), "result not available");
        return legNPV_[1];
    }

    void CPISwap::setupExpired() const {
        Swap::setupExpired();
        legBPS_[0] = legBPS_[1] = 0.0;
        fairRate_ = Null<Rate>();
        fairSpread_ = Null<Spread>();
    }

    void CPISwap::fetchResults(const PricingEngine::results* r) const {
        static const Spread basisPoint = 1.0e-4;

        // copy from VanillaSwap
        // works because similarly simple instrument
        // that we always expect to be priced with a swap engine

        Swap::fetchResults(r);

        const auto* results = dynamic_cast<const CPISwap::results*>(r);
        if (results != nullptr) { // might be a swap engine, so no error is thrown
            fairRate_ = results->fairRate;
            fairSpread_ = results->fairSpread;
        } else {
            fairRate_ = Null<Rate>();
            fairSpread_ = Null<Spread>();
        }

        if (fairRate_ == Null<Rate>()) {
            // calculate it from other results
            if (legBPS_[0] != Null<Real>())
                fairRate_ = fixedRate_ - NPV_/(legBPS_[0]/basisPoint);
        }
        if (fairSpread_ == Null<Spread>()) {
            // ditto
            if (legBPS_[1] != Null<Real>())
                fairSpread_ = spread_ - NPV_/(legBPS_[1]/basisPoint);
        }

    }

    void CPISwap::arguments::validate() const {
        Swap::arguments::validate();
    }

    void CPISwap::results::reset() {
        Swap::results::reset();
        fairRate = Null<Rate>();
        fairSpread = Null<Spread>();
    }

}

]]></document_content>
  </document>
  <document index="45">
    <source>cpiswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009, 2011 Chris Kenyon
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

/*! \file cpiswap.hpp
 \brief zero-inflation-indexed-ratio-with-base swap
 */

#ifndef quantlib_zeroinflationswap_hpp
#define quantlib_zeroinflationswap_hpp

#include <ql/instruments/swap.hpp>
#include <ql/time/calendar.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/time/schedule.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/cashflows/cpicoupon.hpp>

namespace QuantLib {

    class ZeroInflationIndex;

    //! zero-inflation-indexed swap,
    /*! fixed x zero-inflation, i.e. fixed x CPI(i'th fixing)/CPI(base)
        versus floating + spread

        Note that this does ony the inflation-vs-floating-leg.
        Extension to inflation-vs-fixed-leg.  is simple - just replace
        the floating leg with a fixed leg.

        Typically there are notional exchanges at the end: either
        inflated-notional vs notional; or just (inflated-notional -
        notional) vs zero.  The latter is perhaphs more typical.
        \warning Setting subtractInflationNominal to true means that
        the original inflation nominal is subtracted from both
        nominals before they are exchanged, even if they are
        different.

        This swap can mimic a ZCIIS where [(1+q)^n - 1] is exchanged
        against (cpi ratio - 1), by using differnt nominals on each
        leg and setting subtractInflationNominal to true.  ALSO -
        there must be just one date in each schedule.

        The two legs can have different schedules, fixing (days vs
        lag), settlement, and roll conventions.  N.B. accrual
        adjustment periods are already in the schedules.  Trade date
        and swap settlement date are outside the scope of the
        instrument.
    */
    class CPISwap : public Swap {
      public:
        class arguments;
        class results;
        class engine;

        /*! In this swap, the type (Payer or Receiver) refers to the floating leg. */
        CPISwap(Type type,
                Real nominal,
                bool subtractInflationNominal,
                // float+spread leg
                Spread spread,
                DayCounter floatDayCount,
                Schedule floatSchedule,
                const BusinessDayConvention& floatRoll,
                Natural fixingDays,
                ext::shared_ptr<IborIndex> floatIndex,
                // fixed x inflation leg
                Rate fixedRate,
                Real baseCPI,
                DayCounter fixedDayCount,
                Schedule fixedSchedule,
                const BusinessDayConvention& fixedRoll,
                const Period& observationLag,
                ext::shared_ptr<ZeroInflationIndex> fixedIndex,
                CPI::InterpolationType observationInterpolation = CPI::AsIndex,
                Real inflationNominal = Null<Real>());

        // results
        // float+spread
        virtual Real floatLegNPV() const;
        virtual Spread fairSpread() const;
        // fixed rate x inflation
        virtual Real fixedLegNPV() const;
        virtual Rate fairRate() const;

        // inspectors
        virtual Type type() const;
        virtual Real nominal() const;
        virtual bool subtractInflationNominal() const;

        // float+spread
        virtual Spread spread() const;
        virtual const DayCounter& floatDayCount() const;
        virtual const Schedule& floatSchedule() const;
        virtual const BusinessDayConvention& floatPaymentRoll() const;
        virtual Natural fixingDays() const;
        virtual const ext::shared_ptr<IborIndex>& floatIndex() const;

        // fixed rate x inflation
        virtual Rate fixedRate() const;
        virtual Real baseCPI() const;
        virtual const DayCounter& fixedDayCount() const;
        virtual const Schedule& fixedSchedule() const;
        virtual const BusinessDayConvention& fixedPaymentRoll() const;
        virtual Period observationLag() const;
        virtual const ext::shared_ptr<ZeroInflationIndex>& fixedIndex() const;
        virtual CPI::InterpolationType observationInterpolation() const;
        virtual Real inflationNominal() const;

        // legs
        virtual const Leg& cpiLeg() const;
        virtual const Leg& floatLeg() const;

        // other
        void setupArguments(PricingEngine::arguments* args) const override;
        void fetchResults(const PricingEngine::results*) const override;

      private:
        void setupExpired() const override;

        Type type_;
        Real nominal_;
        bool subtractInflationNominal_;

        // float+spread leg
        Spread spread_;
        DayCounter floatDayCount_;
        Schedule floatSchedule_;
        BusinessDayConvention floatPaymentRoll_;
        Natural fixingDays_;
        ext::shared_ptr<IborIndex> floatIndex_;

        // fixed x inflation leg
        Rate fixedRate_;
        Real baseCPI_;
        DayCounter fixedDayCount_;
        Schedule fixedSchedule_;
        BusinessDayConvention fixedPaymentRoll_;
        ext::shared_ptr<ZeroInflationIndex> fixedIndex_;
        Period observationLag_;
        CPI::InterpolationType observationInterpolation_;
        Real inflationNominal_;
        // results
        mutable Spread fairSpread_;
        mutable Rate fairRate_;

    };


    //! %Arguments for swap calculation
    class CPISwap::arguments : public Swap::arguments {
    public:
      arguments() : nominal(Null<Real>()) {}
      Type type = Receiver;
      Real nominal;

      void validate() const override;
    };

    //! %Results from swap calculation
    class CPISwap::results : public Swap::results {
    public:
        Rate fairRate;
        Spread fairSpread;
        void reset() override;
    };

    class CPISwap::engine : public GenericEngine<CPISwap::arguments,
                                                 CPISwap::results> {};


    // inline definitions

    // inspectors
    inline  Swap::Type CPISwap::type() const { return type_; }
    inline  Real CPISwap::nominal() const { return nominal_; }
    inline  bool CPISwap::subtractInflationNominal() const { return subtractInflationNominal_; }

    // float+spread
    inline Spread CPISwap::spread() const { return spread_; }
    inline const DayCounter& CPISwap::floatDayCount() const { return floatDayCount_; }
    inline const Schedule& CPISwap::floatSchedule() const { return floatSchedule_; }
    inline const BusinessDayConvention& CPISwap::floatPaymentRoll() const { return floatPaymentRoll_; }
    inline Natural CPISwap::fixingDays() const { return fixingDays_; }
    inline const ext::shared_ptr<IborIndex>& CPISwap::floatIndex() const { return floatIndex_; }

    // fixed rate x inflation
    inline Rate CPISwap::fixedRate() const { return fixedRate_; }
    inline Real CPISwap::baseCPI() const { return baseCPI_; }
    inline const DayCounter& CPISwap::fixedDayCount() const { return fixedDayCount_; }
    inline const Schedule& CPISwap::fixedSchedule() const { return fixedSchedule_; }
    inline const BusinessDayConvention& CPISwap::fixedPaymentRoll() const { return fixedPaymentRoll_; }
    inline Period CPISwap::observationLag() const { return observationLag_; }
    inline const ext::shared_ptr<ZeroInflationIndex>& CPISwap::fixedIndex() const { return fixedIndex_; }
    inline CPI::InterpolationType CPISwap::observationInterpolation() const { return observationInterpolation_; }
    inline Real CPISwap::inflationNominal() const { return inflationNominal_; }

    inline const Leg& CPISwap::cpiLeg() const {//inflation indexed
        return legs_[0];
    }

    inline const Leg& CPISwap::floatLeg() const {
        return legs_[1];
    }

}

#endif

]]></document_content>
  </document>
  <document index="46">
    <source>creditdefaultswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 Jose Aparicio
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/instruments/claim.hpp>
#include <ql/instruments/creditdefaultswap.hpp>
#include <ql/math/solvers1d/brent.hpp>
#include <ql/pricingengines/credit/isdacdsengine.hpp>
#include <ql/pricingengines/credit/midpointcdsengine.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/termstructures/credit/flathazardrate.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/time/calendars/weekendsonly.hpp>
#include <ql/time/schedule.hpp>
#include <utility>

namespace QuantLib {

    CreditDefaultSwap::CreditDefaultSwap(Protection::Side side,
                                         Real notional,
                                         Rate spread,
                                         const Schedule& schedule,
                                         BusinessDayConvention convention,
                                         const DayCounter& dayCounter,
                                         bool settlesAccrual,
                                         bool paysAtDefaultTime,
                                         const Date& protectionStart,
                                         ext::shared_ptr<Claim> claim,
                                         const DayCounter& lastPeriodDayCounter,
                                         const bool rebatesAccrual,
                                         const Date& tradeDate,
                                         Natural cashSettlementDays)
    : side_(side), notional_(notional), upfront_(boost::none), runningSpread_(spread),
      settlesAccrual_(settlesAccrual), paysAtDefaultTime_(paysAtDefaultTime),
      claim_(std::move(claim)),
      protectionStart_(protectionStart == Null<Date>() ? schedule[0] : protectionStart),
      tradeDate_(tradeDate), cashSettlementDays_(cashSettlementDays) {

        init(schedule, convention, dayCounter, lastPeriodDayCounter, rebatesAccrual);
    }

    CreditDefaultSwap::CreditDefaultSwap(Protection::Side side,
                                         Real notional,
                                         Rate upfront,
                                         Rate runningSpread,
                                         const Schedule& schedule,
                                         BusinessDayConvention convention,
                                         const DayCounter& dayCounter,
                                         bool settlesAccrual,
                                         bool paysAtDefaultTime,
                                         const Date& protectionStart,
                                         const Date& upfrontDate,
                                         ext::shared_ptr<Claim> claim,
                                         const DayCounter& lastPeriodDayCounter,
                                         const bool rebatesAccrual,
                                         const Date& tradeDate,
                                         Natural cashSettlementDays)
    : side_(side), notional_(notional), upfront_(upfront), runningSpread_(runningSpread),
      settlesAccrual_(settlesAccrual), paysAtDefaultTime_(paysAtDefaultTime),
      claim_(std::move(claim)),
      protectionStart_(protectionStart == Null<Date>() ? schedule[0] : protectionStart),
      tradeDate_(tradeDate), cashSettlementDays_(cashSettlementDays) {

        init(schedule, convention, dayCounter, lastPeriodDayCounter, rebatesAccrual, upfrontDate);
    }

    void CreditDefaultSwap::init(const Schedule& schedule, BusinessDayConvention paymentConvention,
        const DayCounter& dayCounter, const DayCounter& lastPeriodDayCounter,
        bool rebatesAccrual, const Date& upfrontDate) {

        QL_REQUIRE(!schedule.empty(), "CreditDefaultSwap needs a non-empty schedule.");

        bool postBigBang = false;
        if (schedule.hasRule()) {
            DateGeneration::Rule rule = schedule.rule();
            postBigBang = rule == DateGeneration::CDS || rule == DateGeneration::CDS2015;
        }

        if (!postBigBang) {
            QL_REQUIRE(protectionStart_ <= schedule[0], "protection can not start after accrual");
        }

        leg_ = FixedRateLeg(schedule)
            .withNotionals(notional_)
            .withCouponRates(runningSpread_, dayCounter)
            .withPaymentAdjustment(paymentConvention)
            .withLastPeriodDayCounter(lastPeriodDayCounter);

        // Deduce the trade date if not given.
        if (tradeDate_ == Date()) {
            if (postBigBang) {
                tradeDate_ = protectionStart_;
            } else {
                tradeDate_ = protectionStart_ - 1;
            }
        }

        // Deduce the cash settlement date if not given.
        Date effectiveUpfrontDate = upfrontDate;
        if (effectiveUpfrontDate == Date()) {
            effectiveUpfrontDate = schedule.calendar().advance(tradeDate_,
                cashSettlementDays_, Days, paymentConvention);
        }
        QL_REQUIRE(effectiveUpfrontDate >= protectionStart_, "The cash settlement date must not " <<
            "be before the protection start date.");

        // Create the upfront payment, if one is provided.
        Real upfrontAmount = 0.0;
        if (upfront_) // NOLINT(readability-implicit-bool-conversion)
            upfrontAmount = *upfront_ * notional_;
        upfrontPayment_ = ext::make_shared<SimpleCashFlow>(upfrontAmount, effectiveUpfrontDate);

        // Set the maturity date.
        maturity_ = schedule.dates().back();

        // Deal with the accrual rebate. We use the standard conventions for accrual calculation introduced with the 
        // CDS Big Bang in 2009.
        if (rebatesAccrual) {

            Real rebateAmount = 0.0;
            Date refDate = tradeDate_ + 1;

            if (tradeDate_ >= schedule.dates().front()) {
                for (Size i = 0; i < leg_.size(); ++i) {
                    const ext::shared_ptr<CashFlow>& cf = leg_[i];
                    if (refDate < cf->date()) {
                        // Calculate the accrual. The most likely scenario.
                        ext::shared_ptr<FixedRateCoupon> frc = ext::dynamic_pointer_cast<FixedRateCoupon>(cf);
                        rebateAmount = frc->accruedAmount(refDate);
                        break;
                    } else if (refDate == cf->date() && i < leg_.size() - 1) {
                        // If not the last coupon and trade date + 1 is the next coupon payment date, 
                        // the accrual is 0 so do nothing.
                        break;
                    } else {
                        // Must have trade date + 1 >= last coupon's payment date. '>' here probably does not make
                        // sense - should possibly have an exception above if trade date >= last coupon's date.
                        ext::shared_ptr<FixedRateCoupon> frc = ext::dynamic_pointer_cast<FixedRateCoupon>(cf);
                        rebateAmount = frc->amount();
                        break;
                    }
                }
            }

            accrualRebate_ = ext::make_shared<SimpleCashFlow>(rebateAmount, effectiveUpfrontDate);
        }

        if (!claim_)
            claim_ = ext::make_shared<FaceValueClaim>();
        registerWith(claim_);
    }

    Protection::Side CreditDefaultSwap::side() const {
        return side_;
    }

    Real CreditDefaultSwap::notional() const {
        return notional_;
    }

    Rate CreditDefaultSwap::runningSpread() const {
        return runningSpread_;
    }

    boost::optional<Rate> CreditDefaultSwap::upfront() const {
        return upfront_;
    }

    bool CreditDefaultSwap::settlesAccrual() const {
        return settlesAccrual_;
    }

    bool CreditDefaultSwap::paysAtDefaultTime() const {
        return paysAtDefaultTime_;
    }

    const Leg& CreditDefaultSwap::coupons() const {
        return leg_;
    }


    bool CreditDefaultSwap::isExpired() const {
        for (auto i = leg_.rbegin(); i != leg_.rend(); ++i) {
            if (!(*i)->hasOccurred())
                return false;
        }
        return true;
    }

    void CreditDefaultSwap::setupExpired() const {
        Instrument::setupExpired();
        fairSpread_ = fairUpfront_ = 0.0;
        couponLegBPS_ = upfrontBPS_ = 0.0;
        couponLegNPV_ = defaultLegNPV_ = upfrontNPV_ = 0.0;
    }

    void CreditDefaultSwap::setupArguments(
                                       PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<CreditDefaultSwap::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->side = side_;
        arguments->notional = notional_;
        arguments->leg = leg_;
        arguments->upfrontPayment = upfrontPayment_;
        arguments->accrualRebate = accrualRebate_;
        arguments->settlesAccrual = settlesAccrual_;
        arguments->paysAtDefaultTime = paysAtDefaultTime_;
        arguments->claim = claim_;
        arguments->upfront = upfront_;
        arguments->spread = runningSpread_;
        arguments->protectionStart = protectionStart_;
        arguments->maturity = maturity_;
    }


    void CreditDefaultSwap::fetchResults(
                                      const PricingEngine::results* r) const {
        Instrument::fetchResults(r);

        const auto* results = dynamic_cast<const CreditDefaultSwap::results*>(r);
        QL_REQUIRE(results != nullptr, "wrong result type");

        fairSpread_ = results->fairSpread;
        fairUpfront_ = results->fairUpfront;
        couponLegBPS_ = results->couponLegBPS;
        couponLegNPV_ = results->couponLegNPV;
        defaultLegNPV_ = results->defaultLegNPV;
        upfrontNPV_ = results->upfrontNPV;
        upfrontBPS_ = results->upfrontBPS;
        accrualRebateNPV_ = results->accrualRebateNPV;
    }

    Rate CreditDefaultSwap::fairUpfront() const {
        calculate();
        QL_REQUIRE(fairUpfront_ != Null<Rate>(),
                   "fair upfront not available");
        return fairUpfront_;
    }

    Rate CreditDefaultSwap::fairSpread() const {
        calculate();
        QL_REQUIRE(fairSpread_ != Null<Rate>(),
                   "fair spread not available");
        return fairSpread_;
    }

    Real CreditDefaultSwap::couponLegBPS() const {
        calculate();
        QL_REQUIRE(couponLegBPS_ != Null<Rate>(),
                   "coupon-leg BPS not available");
        return couponLegBPS_;
    }

    Real CreditDefaultSwap::couponLegNPV() const {
        calculate();
        QL_REQUIRE(couponLegNPV_ != Null<Rate>(),
                   "coupon-leg NPV not available");
        return couponLegNPV_;
    }

    Real CreditDefaultSwap::defaultLegNPV() const {
        calculate();
        QL_REQUIRE(defaultLegNPV_ != Null<Rate>(),
                   "default-leg NPV not available");
        return defaultLegNPV_;
    }

    Real CreditDefaultSwap::upfrontNPV() const {
        calculate();
        QL_REQUIRE(upfrontNPV_ != Null<Real>(),
                   "upfront NPV not available");
        return upfrontNPV_;
    }

    Real CreditDefaultSwap::upfrontBPS() const {
        calculate();
        QL_REQUIRE(upfrontBPS_ != Null<Real>(),
                   "upfront BPS not available");
        return upfrontBPS_;
    }

    Real CreditDefaultSwap::accrualRebateNPV() const {
        calculate();
        QL_REQUIRE(accrualRebateNPV_ != Null<Real>(),
                   "accrual Rebate NPV not available");
        return accrualRebateNPV_;
    }

    namespace {

        class ObjectiveFunction {
          public:
            ObjectiveFunction(Real target,
                              SimpleQuote& quote,
                              PricingEngine& engine,
                              const CreditDefaultSwap::results* results)
            : target_(target), quote_(quote),
              engine_(engine), results_(results) {}

            Real operator()(Real guess) const {
                quote_.setValue(guess);
                engine_.calculate();
                return results_->value - target_;
            }
          private:
            Real target_;
            SimpleQuote& quote_;
            PricingEngine& engine_;
            const CreditDefaultSwap::results* results_;
        };

    }

    Rate CreditDefaultSwap::impliedHazardRate(
                               Real targetNPV,
                               const Handle<YieldTermStructure>& discountCurve,
                               const DayCounter& dayCounter,
                               Real recoveryRate,
                               Real accuracy,
                               PricingModel model) const {

        ext::shared_ptr<SimpleQuote> flatRate = ext::make_shared<SimpleQuote>(0.0);

        Handle<DefaultProbabilityTermStructure> probability =
            Handle<DefaultProbabilityTermStructure>(
                ext::make_shared<FlatHazardRate>(0, WeekendsOnly(),
                                                   Handle<Quote>(flatRate), dayCounter));

        ext::shared_ptr<PricingEngine> engine;
        switch (model) {
          case Midpoint:
            engine = ext::make_shared<MidPointCdsEngine>(
                probability, recoveryRate, discountCurve);
            break;
          case ISDA:
            engine = ext::make_shared<IsdaCdsEngine>(
                probability, recoveryRate, discountCurve,
                boost::none,
                IsdaCdsEngine::Taylor,
                IsdaCdsEngine::HalfDayBias,
                IsdaCdsEngine::Piecewise);
            break;
          default:
            QL_FAIL("unknown CDS pricing model: " << model);
        }

        setupArguments(engine->getArguments());
        const auto* results = dynamic_cast<const CreditDefaultSwap::results*>(engine->getResults());

        ObjectiveFunction f(targetNPV, *flatRate, *engine, results);
        //very close guess if targetNPV = 0.
        Rate guess = runningSpread_ / (1 - recoveryRate) * 365./360.;
        Real step = 0.1 * guess;
        return Brent().solve(f, accuracy, guess, step);
    }

    Rate CreditDefaultSwap::conventionalSpread(
                              Real conventionalRecovery,
                              const Handle<YieldTermStructure>& discountCurve,
                              const DayCounter& dayCounter,
                              PricingModel model) const {

        ext::shared_ptr<SimpleQuote> flatRate = ext::make_shared<SimpleQuote>(0.0);

        Handle<DefaultProbabilityTermStructure> probability =
            Handle<DefaultProbabilityTermStructure>(
                ext::make_shared<FlatHazardRate>(0, WeekendsOnly(),
                                                   Handle<Quote>(flatRate), dayCounter));

        ext::shared_ptr<PricingEngine> engine;
        switch (model) {
          case Midpoint:
            engine = ext::make_shared<MidPointCdsEngine>(
                probability, conventionalRecovery, discountCurve);
            break;
          case ISDA:
            engine = ext::make_shared<IsdaCdsEngine>(
                probability, conventionalRecovery, discountCurve,
                boost::none,
                IsdaCdsEngine::Taylor,
                IsdaCdsEngine::HalfDayBias,
                IsdaCdsEngine::Piecewise);
            break;
          default:
            QL_FAIL("unknown CDS pricing model: " << model);
        }

        setupArguments(engine->getArguments());
        const auto* results = dynamic_cast<const CreditDefaultSwap::results*>(engine->getResults());

        ObjectiveFunction f(0., *flatRate, *engine, results);
        Rate guess = runningSpread_ / (1 - conventionalRecovery) * 365./360.;
        Real step = guess * 0.1;

        Brent().solve(f, 1e-9, guess, step);
        return results->fairSpread;
    }


    const Date& CreditDefaultSwap::protectionStartDate() const {
        return protectionStart_;
    }

    const Date& CreditDefaultSwap::protectionEndDate() const {
        return ext::dynamic_pointer_cast<Coupon>(leg_.back())
            ->accrualEndDate();
    }

    const ext::shared_ptr<SimpleCashFlow>& CreditDefaultSwap::upfrontPayment() const {
        return upfrontPayment_;
    }

    const ext::shared_ptr<SimpleCashFlow>& CreditDefaultSwap::accrualRebate() const {
        return accrualRebate_;
    }

    const Date& CreditDefaultSwap::tradeDate() const {
        return tradeDate_;
    }

    Natural CreditDefaultSwap::cashSettlementDays() const {
        return cashSettlementDays_;
    }

    CreditDefaultSwap::arguments::arguments()
    : side(Protection::Side(-1)), notional(Null<Real>()),
      spread(Null<Rate>()) {}

    void CreditDefaultSwap::arguments::validate() const {
        QL_REQUIRE(side != Protection::Side(-1), "side not set");
        QL_REQUIRE(notional != Null<Real>(), "notional not set");
        QL_REQUIRE(notional != 0.0, "null notional set");
        QL_REQUIRE(spread != Null<Rate>(), "spread not set");
        QL_REQUIRE(!leg.empty(), "coupons not set");
        QL_REQUIRE(upfrontPayment, "upfront payment not set");
        QL_REQUIRE(claim, "claim not set");
        QL_REQUIRE(protectionStart != Null<Date>(),
                   "protection start date not set");
        QL_REQUIRE(maturity != Null<Date>(),
                   "maturity date not set");
    }

    void CreditDefaultSwap::results::reset() {
        Instrument::results::reset();
        fairSpread = Null<Rate>();
        fairUpfront = Null<Rate>();
        couponLegBPS = Null<Real>();
        couponLegNPV = Null<Real>();
        defaultLegNPV = Null<Real>();
        upfrontBPS = Null<Real>();
        upfrontNPV = Null<Real>();
        accrualRebateNPV = Null<Real>();
    }

    Date cdsMaturity(const Date& tradeDate, const Period& tenor, DateGeneration::Rule rule) {

        QL_REQUIRE(rule == DateGeneration::CDS2015 || rule == DateGeneration::CDS || rule == DateGeneration::OldCDS,
            "cdsMaturity should only be used with date generation rule CDS2015, CDS or OldCDS");

        QL_REQUIRE(tenor.units() == Years || (tenor.units() == Months && tenor.length() % 3 == 0),
            "cdsMaturity expects a tenor that is a multiple of 3 months.");

        if (rule == DateGeneration::OldCDS) {
            QL_REQUIRE(tenor != 0 * Months, "A tenor of 0M is not supported for OldCDS.");
        }

        Date anchorDate = previousTwentieth(tradeDate, rule);
        if (rule == DateGeneration::CDS2015 && (anchorDate == Date(20, Dec, anchorDate.year()) ||
            anchorDate == Date(20, Jun, anchorDate.year()))) {
            if (tenor.length() == 0) {
                return Null<Date>();
            } else {
                anchorDate -= 3 * Months;
            }
        }

        Date maturity = anchorDate + tenor + 3 * Months;
        QL_REQUIRE(maturity > tradeDate, "error calculating CDS maturity. Tenor is " << tenor << ", trade date is " <<
            io::iso_date(tradeDate) << " generating a maturity of " << io::iso_date(maturity) << " <= trade date.");

        return maturity;
    }

}
]]></document_content>
  </document>
  <document index="47">
    <source>creditdefaultswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008, 2009 Jose Aparicio
 Copyright (C) 2008 Roland Lichters
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file creditdefaultswap.hpp
    \brief Credit default swap
*/

#ifndef quantlib_credit_default_swap_hpp
#define quantlib_credit_default_swap_hpp

#include <ql/instrument.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/default.hpp>
#include <ql/termstructures/defaulttermstructure.hpp>
#include <ql/time/schedule.hpp>

namespace QuantLib {

    class YieldTermStructure;
    class Claim;

    //! Credit default swap
    /*! \note This instrument currently assumes that the issuer did
              not default until today's date.

        \warning if <tt>Settings::includeReferenceDateCashFlows()</tt>
                 is set to <tt>true</tt>, payments occurring at the
                 settlement date of the swap might be included in the
                 NPV and therefore affect the fair-spread
                 calculation. This might not be what you want.

        \warning conventionalSpread (and impliedHazardRate) by default
                 use the mid-point engine, which is not ISDA conform.

        \ingroup instruments
    */
    class CreditDefaultSwap : public Instrument {
      public:
        class arguments;
        class results;
        class engine;
        enum PricingModel {
            Midpoint,
            ISDA
        };
        //! \name Constructors
        //@{
        //! CDS quoted as running-spread only
        /*! @param side  Whether the protection is bought or sold.
            @param notional  Notional value
            @param spread  Running spread in fractional units.
            @param schedule  Coupon schedule.
            @param paymentConvention  Business-day convention for
                                      payment-date adjustment.
            @param dayCounter  Day-count convention for accrual.
            @param settlesAccrual  Whether or not the accrued coupon is
                                   due in the event of a default.
            @param paysAtDefaultTime  If set to true, any payments
                                      triggered by a default event are
                                      due at default time. If set to
                                      false, they are due at the end of
                                      the accrual period.
            @param protectionStart  The first date where a default event will trigger the contract. 
                                    Before the CDS Big Bang 2009, this was typically trade date (T) + 1 calendar day.
                                    After the CDS Big Bang 2009, protection is typically effective immediately i.e. on 
                                    trade date so this is what should be entered for protection start.
                                    Notice that there is no default lookback period and protection start here. 
                                    In the way it determines the dirty amount it is more like the trade execution date.
            @param lastPeriodDayCounter Day-count convention for accrual in last period
            @param rebatesAccrual  The protection seller pays the accrued 
                                    scheduled current coupon at the start 
                                    of the contract. The rebate date is not
                                    provided but computed to be two days after
                                    protection start.
            @param tradeDate  The contract's trade date. It will be used with the \p cashSettlementDays to determine 
                              the date on which the cash settlement amount is paid. If not given, the trade date is 
                              guessed from the protection start date and \p schedule date generation rule.
            @param cashSettlementDays  The number of business days from \p tradeDate to cash settlement date.
        */
        CreditDefaultSwap(Protection::Side side,
                          Real notional,
                          Rate spread,
                          const Schedule& schedule,
                          BusinessDayConvention paymentConvention,
                          const DayCounter& dayCounter,
                          bool settlesAccrual = true,
                          bool paysAtDefaultTime = true,
                          const Date& protectionStart = Date(),
                          ext::shared_ptr<Claim> = ext::shared_ptr<Claim>(),
                          const DayCounter& lastPeriodDayCounter = DayCounter(),
                          bool rebatesAccrual = true,
                          const Date& tradeDate = Date(),
                          Natural cashSettlementDays = 3);
        //! CDS quoted as upfront and running spread
        /*! @param side  Whether the protection is bought or sold.
            @param notional  Notional value
            @param upfront Upfront in fractional units.
            @param spread Running spread in fractional units.
            @param schedule  Coupon schedule.
            @param paymentConvention  Business-day convention for
                                      payment-date adjustment.
            @param dayCounter  Day-count convention for accrual.
            @param settlesAccrual Whether or not the accrued coupon is
                                  due in the event of a default.
            @param paysAtDefaultTime If set to true, any payments
                                     triggered by a default event are
                                     due at default time. If set to
                                     false, they are due at the end of
                                     the accrual period.
            @param protectionStart  The first date where a default event will trigger the contract. 
                                    Before the CDS Big Bang 2009, this was typically trade date (T) + 1 calendar day.
                                    After the CDS Big Bang 2009, protection is typically effective immediately i.e. on 
                                    trade date so this is what should be entered for protection start.
                                    Notice that there is no default lookback period and protection start here. 
                                    In the way it determines the dirty amount it is more like the trade execution date.
            @param upfrontDate Settlement date for the upfront and accrual 
                                    rebate (if any) payments.
                                    Typically T+3, this is also the default 
                                    value.
            @param lastPeriodDayCounter Day-count convention for accrual in last period
            @param rebatesAccrual  The protection seller pays the accrued 
                                    scheduled current coupon at the start 
                                    of the contract. The rebate date is not
                                    provided but computed to be two days after
                                    protection start.
            @param tradeDate  The contract's trade date. It will be used with the \p cashSettlementDays to determine 
                              the date on which the cash settlement amount is paid if \p upfrontDate is empty. If not 
                              given, the trade date is guessed from the protection start date and \p schedule date 
                              generation rule.
            @param cashSettlementDays  The number of business days from \p tradeDate to cash settlement date.
        */
        CreditDefaultSwap(Protection::Side side,
                          Real notional,
                          Rate upfront,
                          Rate spread,
                          const Schedule& schedule,
                          BusinessDayConvention paymentConvention,
                          const DayCounter& dayCounter,
                          bool settlesAccrual = true,
                          bool paysAtDefaultTime = true,
                          const Date& protectionStart = Date(),
                          const Date& upfrontDate = Date(),
                          ext::shared_ptr<Claim> = ext::shared_ptr<Claim>(),
                          const DayCounter& lastPeriodDayCounter = DayCounter(),
                          bool rebatesAccrual = true,
                          const Date& tradeDate = Date(),
                          Natural cashSettlementDays = 3);
        //@}
        //! \name Instrument interface
        //@{
        bool isExpired() const override;
        void setupArguments(PricingEngine::arguments*) const override;
        void fetchResults(const PricingEngine::results*) const override;
        //@}
        //! \name Inspectors
        //@{
        Protection::Side side() const;
        Real notional() const;
        Rate runningSpread() const;
        boost::optional<Rate> upfront() const;
        bool settlesAccrual() const;
        bool paysAtDefaultTime() const;
        const Leg& coupons() const;
        //! The first date for which defaults will trigger the contract
        const Date& protectionStartDate() const;
        //! The last date for which defaults will trigger the contract
        const Date& protectionEndDate() const;
        bool rebatesAccrual() const { return accrualRebate_ != nullptr; }
        const ext::shared_ptr<SimpleCashFlow>& upfrontPayment() const;
        const ext::shared_ptr<SimpleCashFlow>& accrualRebate() const;
        const Date& tradeDate() const;
        Natural cashSettlementDays() const;
        //@}
        //! \name Results
        //@{
        /*! Returns the upfront spread that, given the running spread
            and the quoted recovery rate, will make the instrument
            have an NPV of 0.
        */
        Rate fairUpfront() const;
        /*! Returns the running spread that, given the quoted recovery
            rate, will make the running-only CDS have an NPV of 0.

            \note This calculation does not take any upfront into
                  account, even if one was given.
        */
        Rate fairSpread() const;
        /*! Returns the variation of the fixed-leg value given a
            one-basis-point change in the running spread.
        */
        Real couponLegBPS() const;
        Real upfrontBPS() const;
        Real couponLegNPV() const;
        Real defaultLegNPV() const;
        Real upfrontNPV() const;
        Real accrualRebateNPV() const;

        //! Implied hazard rate calculation
        /*! \note This method performs the calculation with the
                  instrument characteristics. It will coincide with
                  the ISDA calculation if your object has the standard
                  characteristics. Notably:
                  - The calendar should have no bank holidays, just
                    weekends.
                  - The yield curve should be LIBOR piecewise constant
                    in fwd rates, with a discount factor of 1 on the
                    calculation date, which coincides with the trade
                    date.
                  - Convention should be Following for yield curve and
                    contract cashflows.
                  - The CDS should pay accrued and mature on standard
                    IMM dates, settle on trade date +1 and upfront
                    settle on trade date +3.
        */
        Rate impliedHazardRate(Real targetNPV,
                               const Handle<YieldTermStructure>& discountCurve,
                               const DayCounter& dayCounter,
                               Real recoveryRate = 0.4,
                               Real accuracy = 1.0e-8,
                               PricingModel model = Midpoint) const;

        //! Conventional/standard upfront-to-spread conversion
        /*! Under a standard ISDA model and a set of standardised
            instrument characteristics, it is the running only quoted
            spread that will make a CDS contract have an NPV of 0 when
            quoted for that running only spread.  Refer to: "ISDA
            Standard CDS converter specification." May 2009.

            The conventional recovery rate to apply in the calculation
            is as specified by ISDA, not necessarily equal to the
            market-quoted one.  It is typically 0.4 for SeniorSec and
            0.2 for subordinate.

            \note The conversion employs a flat hazard rate. As a result,
                  you will not recover the market quotes.

            \note This method performs the calculation with the
                  instrument characteristics. It will coincide with
                  the ISDA calculation if your object has the standard
                  characteristics. Notably:
                  - The calendar should have no bank holidays, just
                    weekends.
                  - The yield curve should be LIBOR piecewise constant
                    in fwd rates, with a discount factor of 1 on the
                    calculation date, which coincides with the trade
                    date.
                  - Convention should be Following for yield curve and
                    contract cashflows.
                  - The CDS should pay accrued and mature on standard
                    IMM dates, settle on trade date +1 and upfront
                    settle on trade date +3.
        */
        Rate conventionalSpread(Real conventionalRecovery,
                                const Handle<YieldTermStructure>& discountCurve,
                                const DayCounter& dayCounter,
                                PricingModel model = Midpoint) const;
        //@}
      protected:
        //! \name Instrument interface
        //@{
        void setupExpired() const override;
        //@}
        // data members
        Protection::Side side_;
        Real notional_;
        boost::optional<Rate> upfront_;
        Rate runningSpread_;
        bool settlesAccrual_, paysAtDefaultTime_;
        ext::shared_ptr<Claim> claim_;
        Leg leg_;
        ext::shared_ptr<SimpleCashFlow> upfrontPayment_;
        ext::shared_ptr<SimpleCashFlow> accrualRebate_;
        Date protectionStart_;
        Date tradeDate_;
        Natural cashSettlementDays_;
        Date maturity_;
        // results
        mutable Rate fairUpfront_;
        mutable Rate fairSpread_;
        mutable Real couponLegBPS_, couponLegNPV_;
        mutable Real upfrontBPS_, upfrontNPV_;
        mutable Real defaultLegNPV_;
        mutable Real accrualRebateNPV_;

      private:
        //! Shared initialisation.
        void init(const Schedule& schedule, BusinessDayConvention paymentConvention, const DayCounter& dayCounter,
            const DayCounter& lastPeriodDayCounter, bool rebatesAccrual, const Date& upfrontDate = Date());
    };


    class CreditDefaultSwap::arguments
        : public virtual PricingEngine::arguments {
      public:
        arguments();
        Protection::Side side;
        Real notional;
        boost::optional<Rate> upfront;
        Rate spread;
        Leg leg;
        // if not initialized by constructors means theres no flows.
        ext::shared_ptr<SimpleCashFlow> upfrontPayment;
        ext::shared_ptr<SimpleCashFlow> accrualRebate;
        bool settlesAccrual;
        bool paysAtDefaultTime;
        ext::shared_ptr<Claim> claim;
        Date protectionStart;
        Date maturity;
        void validate() const override;
    };

    class CreditDefaultSwap::results : public Instrument::results {
      public:
        Rate fairSpread;
        Rate fairUpfront;
        Real couponLegBPS;
        Real couponLegNPV;
        Real defaultLegNPV;
        Real upfrontBPS;
        Real upfrontNPV;
        Real accrualRebateNPV;
        void reset() override;
    };

    class CreditDefaultSwap::engine
        : public GenericEngine<CreditDefaultSwap::arguments,
                               CreditDefaultSwap::results> {};

    /*! Return the CDS maturity date given the CDS trade date, \p tradeDate, the CDS \p tenor and a CDS \p rule.

        A \c Null<Date>() is returned when a \p rule of \c CDS2015 and a \p tenor length of zero fail to yield a valid
        CDS maturity date.

        \warning An exception will be thrown if the \p rule is not \c CDS2015, \c CDS or \c OldCDS.

        \warning An exception will be thrown if the \p rule is \c OldCDS and a \p tenor of 0 months is provided. This
                 restriction can be removed if 0M tenor was available before the CDS Big Bang 2009.

        \warning An exception will be thrown if the \p tenor is not a multiple of 3 months. For the avoidance of
                 doubt, a \p tenor of 0 months is supported.
    */
    Date cdsMaturity(const Date& tradeDate, const Period& tenor, DateGeneration::Rule rule);

}


#endif
]]></document_content>
  </document>
  <document index="48">
    <source>dividendbarrieroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/dividendbarrieroption.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    DividendBarrierOption::DividendBarrierOption(
                        Barrier::Type barrierType,
                        Real barrier,
                        Real rebate,
                        const ext::shared_ptr<StrikedTypePayoff>& payoff,
                        const ext::shared_ptr<Exercise>& exercise,
                        const std::vector<Date>& dividendDates,
                        const std::vector<Real>& dividends)
    : BarrierOption(barrierType, barrier, rebate, payoff, exercise),
      cashFlow_(DividendVector(dividendDates, dividends)) {}


    void DividendBarrierOption::setupArguments(
                                       PricingEngine::arguments* args) const {
        BarrierOption::setupArguments(args);

        auto* arguments = dynamic_cast<DividendBarrierOption::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong engine type");

        arguments->cashFlow = cashFlow_;
    }


    void DividendBarrierOption::arguments::validate() const {
        BarrierOption::arguments::validate();

        Date exerciseDate = exercise->lastDate();

        for (Size i = 0; i < cashFlow.size(); i++) {
            QL_REQUIRE(cashFlow[i]->date() <= exerciseDate,
                       "the " << io::ordinal(i+1) << " dividend date ("
                       << cashFlow[i]->date()
                       << ") is later than the exercise date ("
                       << exerciseDate << ")");
        }
    }

}

]]></document_content>
  </document>
  <document index="49">
    <source>dividendbarrieroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Andreas Gaida
 Copyright (C) 2008 Ralph Schreyer
 Copyright (C) 2008 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file dividendbarrieroption.hpp
    \brief Barrier option on a single asset with discrete dividends
*/

#ifndef quantlib_dividend_barrier_option_hpp
#define quantlib_dividend_barrier_option_hpp

#include <ql/instruments/barrieroption.hpp>
#include <ql/instruments/dividendschedule.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    //! Single-asset barrier option with discrete dividends
    /*! \ingroup instruments */
    class DividendBarrierOption : public BarrierOption {
      public:
        class arguments;
        class engine;
        DividendBarrierOption(
                        Barrier::Type barrierType,
                        Real barrier,
                        Real rebate,
                        const ext::shared_ptr<StrikedTypePayoff>& payoff,
                        const ext::shared_ptr<Exercise>& exercise,
                        const std::vector<Date>& dividendDates,
                        const std::vector<Real>& dividends);
      protected:
        void setupArguments(PricingEngine::arguments*) const override;

      private:
        DividendSchedule cashFlow_;
    };


    //! %Arguments for dividend barrier option calculation
    class DividendBarrierOption::arguments : public BarrierOption::arguments {
      public:
        DividendSchedule cashFlow;
        arguments() = default;
        void validate() const override;
    };

    //! %Dividend-barrier-option %engine base class
    class DividendBarrierOption::engine
        : public GenericEngine<DividendBarrierOption::arguments,
                               DividendBarrierOption::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="50">
    <source>dividendschedule.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2005 Joseph Wang
 Copyright (C) 2005, 2006 Theo Boafo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file dividendschedule.hpp
    \brief Schedule of dividend dates
*/

#ifndef quantlib_dividend_schedule_hpp
#define quantlib_dividend_schedule_hpp

#include <ql/cashflows/dividend.hpp>
#include <vector>

namespace QuantLib {

    typedef std::vector<ext::shared_ptr<Dividend> > DividendSchedule;

}

#endif
]]></document_content>
  </document>
  <document index="51">
    <source>dividendvanillaoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/dividendvanillaoption.hpp>
#include <ql/instruments/impliedvolatility.hpp>
#include <ql/pricingengines/vanilla/analyticdividendeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesvanillaengine.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/exercise.hpp>
#include <memory>

namespace QuantLib {

    DividendVanillaOption::DividendVanillaOption(
                           const ext::shared_ptr<StrikedTypePayoff>& payoff,
                           const ext::shared_ptr<Exercise>& exercise,
                           const std::vector<Date>& dividendDates,
                           const std::vector<Real>& dividends)
    : OneAssetOption(payoff, exercise),
      cashFlow_(DividendVector(dividendDates, dividends)) {}


    Volatility DividendVanillaOption::impliedVolatility(
             Real targetValue,
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             Real accuracy,
             Size maxEvaluations,
             Volatility minVol,
             Volatility maxVol) const {

        QL_REQUIRE(!isExpired(), "option expired");

        ext::shared_ptr<SimpleQuote> volQuote(new SimpleQuote);

        ext::shared_ptr<GeneralizedBlackScholesProcess> newProcess =
            detail::ImpliedVolatilityHelper::clone(process, volQuote);

        // engines are built-in for the time being
        std::unique_ptr<PricingEngine> engine;
        switch (exercise_->type()) {
          case Exercise::European:
            engine.reset(new AnalyticDividendEuropeanEngine(newProcess));
            break;
          case Exercise::American:
            engine.reset(new FdBlackScholesVanillaEngine(newProcess));
            break;
          case Exercise::Bermudan:
            QL_FAIL("engine not available for Bermudan option with dividends");
            break;
          default:
            QL_FAIL("unknown exercise type");
        }

        return detail::ImpliedVolatilityHelper::calculate(*this,
                                                          *engine,
                                                          *volQuote,
                                                          targetValue,
                                                          accuracy,
                                                          maxEvaluations,
                                                          minVol, maxVol);
    }


    void DividendVanillaOption::setupArguments(
                                       PricingEngine::arguments* args) const {
        OneAssetOption::setupArguments(args);

        auto* arguments = dynamic_cast<DividendVanillaOption::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong engine type");

        arguments->cashFlow = cashFlow_;
    }


    void DividendVanillaOption::arguments::validate() const {
        OneAssetOption::arguments::validate();

        Date exerciseDate = exercise->lastDate();

        for (Size i = 0; i < cashFlow.size(); i++) {
            QL_REQUIRE(cashFlow[i]->date() <= exerciseDate,
                       "the " << io::ordinal(i+1) << " dividend date ("
                       << cashFlow[i]->date()
                       << ") is later than the exercise date ("
                       << exerciseDate << ")");
        }
    }

}

]]></document_content>
  </document>
  <document index="52">
    <source>dividendvanillaoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file dividendvanillaoption.hpp
    \brief Vanilla option on a single asset with discrete dividends
*/

#ifndef quantlib_dividend_vanilla_option_hpp
#define quantlib_dividend_vanilla_option_hpp

#include <ql/instruments/oneassetoption.hpp>
#include <ql/instruments/dividendschedule.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    class GeneralizedBlackScholesProcess;

    //! Single-asset vanilla option (no barriers) with discrete dividends
    /*! \ingroup instruments */
    class DividendVanillaOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        DividendVanillaOption(
                      const ext::shared_ptr<StrikedTypePayoff>& payoff,
                      const ext::shared_ptr<Exercise>& exercise,
                      const std::vector<Date>& dividendDates,
                      const std::vector<Real>& dividends);
        /*! \warning see VanillaOption for notes on implied-volatility
                     calculation.
        */
        Volatility impliedVolatility(
             Real price,
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             Real accuracy = 1.0e-4,
             Size maxEvaluations = 100,
             Volatility minVol = 1.0e-7,
             Volatility maxVol = 4.0) const;
      protected:
        void setupArguments(PricingEngine::arguments*) const override;

      private:
        DividendSchedule cashFlow_;
    };


    //! %Arguments for dividend vanilla option calculation
    class DividendVanillaOption::arguments : public OneAssetOption::arguments {
      public:
        DividendSchedule cashFlow;
        arguments() = default;
        void validate() const override;
    };

    //! %Dividend-vanilla-option %engine base class
    class DividendVanillaOption::engine
        : public GenericEngine<DividendVanillaOption::arguments,
                               DividendVanillaOption::results> {};

}


#endif

]]></document_content>
  </document>
  <document index="53">
    <source>europeanoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/europeanoption.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>

namespace QuantLib {

    EuropeanOption::EuropeanOption(
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : VanillaOption(payoff, exercise) {}

}

]]></document_content>
  </document>
  <document index="54">
    <source>europeanoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004, 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file europeanoption.hpp
    \brief European option on a single asset
*/

#ifndef quantlib_european_option_hpp
#define quantlib_european_option_hpp

#include <ql/instruments/vanillaoption.hpp>

namespace QuantLib {

    //! European option on a single asset
    /*! \ingroup instruments */
    class EuropeanOption : public VanillaOption {
      public:
        EuropeanOption(const ext::shared_ptr<StrikedTypePayoff>&,
                       const ext::shared_ptr<Exercise>&);
    };

}


#endif

]]></document_content>
  </document>
  <document index="55">
    <source>fixedratebondforward.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/fixedratebondforward.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/cashflow.hpp>

namespace QuantLib {

    FixedRateBondForward::FixedRateBondForward(
                    const Date& valueDate,
                    const Date& maturityDate,
                    Position::Type type,
                    Real strike,
                    Natural settlementDays,
                    const DayCounter& dayCounter,
                    const Calendar& calendar,
                    BusinessDayConvention businessDayConvention,
                    const ext::shared_ptr<FixedRateBond>& fixedCouponBond,
                    const Handle<YieldTermStructure>& discountCurve,
                    const Handle<YieldTermStructure>& incomeDiscountCurve)
    : Forward(dayCounter, calendar, businessDayConvention, settlementDays,
              ext::shared_ptr<Payoff>(new ForwardTypePayoff(type,strike)),
              valueDate, maturityDate, discountCurve),
      fixedCouponBond_(fixedCouponBond) {

        incomeDiscountCurve_ = incomeDiscountCurve;
        registerWith(incomeDiscountCurve_);
        registerWith(fixedCouponBond);
    }


    Real FixedRateBondForward::cleanForwardPrice() const {
        return forwardValue() -
               fixedCouponBond_->accruedAmount(maturityDate_);
    }


    Real FixedRateBondForward::forwardPrice() const {
        return forwardValue();
    }


    Real FixedRateBondForward::spotIncome(const Handle<YieldTermStructure>&
                                                  incomeDiscountCurve) const {

        Real income = 0.0;
        Date settlement = settlementDate();
        Leg cf =
            fixedCouponBond_->cashflows();

        /*
          the following assumes
          1. cashflows are in ascending order !
          2. considers as income: all coupons paid between settlementDate()
          and contract delivery/maturity date
        */
        for (auto& i : cf) {
            if (!i->hasOccurred(settlement, false)) {
                if (i->hasOccurred(maturityDate_, false)) {
                    income += i->amount() * incomeDiscountCurve->discount(i->date());
                } else {
                    break;
                }
            }
        }

        return income;
    }


    Real FixedRateBondForward::spotValue() const {
        return fixedCouponBond_->dirtyPrice();
    }


    void FixedRateBondForward::performCalculations() const {

        underlyingSpotValue_ = spotValue();
        underlyingIncome_    = spotIncome(incomeDiscountCurve_);

        Forward::performCalculations();
    }

}

]]></document_content>
  </document>
  <document index="56">
    <source>fixedratebondforward.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file fixedratebondforward.hpp
    \brief forward contract on a fixed-rate bond
*/

#ifndef quantlib_fixed_rate_bond_forward_hpp
#define quantlib_fixed_rate_bond_forward_hpp

#include <ql/instruments/forward.hpp>
#include <ql/instruments/bonds/fixedratebond.hpp>

namespace QuantLib {

    //! %Forward contract on a fixed-rate bond
    /*! 1. valueDate refers to the settlement date of the bond forward
           contract.  maturityDate is the delivery (or repurchase)
           date for the underlying bond (not the bond's maturity
           date).

        2. Relevant formulas used in the calculations (\f$P\f$ refers
           to a price):

           a. \f$ P_{CleanFwd}(t) = P_{DirtyFwd}(t) -
              AI(t=deliveryDate) \f$ where \f$ AI \f$ refers to the
              accrued interest on the underlying bond.

           b. \f$ P_{DirtyFwd}(t) = \frac{P_{DirtySpot}(t) -
              SpotIncome(t)} {discountCurve->discount(t=deliveryDate)} \f$

           c. \f$ SpotIncome(t) = \sum_i \left( CF_i \times
              incomeDiscountCurve->discount(t_i) \right) \f$ where \f$
              CF_i \f$ represents the ith bond cash flow (coupon
              payment) associated with the underlying bond falling
              between the settlementDate and the deliveryDate. (Note
              the two different discount curves used in b. and c.)

        \todo Add preconditions and tests

        \todo Create switch- if coupon goes to seller is toggled on,
              don't consider income in the \f$ P_{DirtyFwd}(t) \f$
              calculation.

        \todo Verify this works when the underlying is paper (in which
              case ignore all AI.)

        \warning This class still needs to be rigorously tested

        \ingroup instruments
    */
    class FixedRateBondForward : public Forward {
      public:
        //! \name Constructors
        /*! If strike is given in the constructor, can calculate the
            NPV of the contract via NPV().

            If strike/forward price is desired, it can be obtained via
            forwardPrice(). In this case, the strike variable in the
            constructor is irrelevant and will be ignored.
        */
        //@{
        FixedRateBondForward(
                    const Date& valueDate,
                    const Date& maturityDate,
                    Position::Type type,
                    Real strike,
                    Natural settlementDays,
                    const DayCounter& dayCounter,
                    const Calendar& calendar,
                    BusinessDayConvention businessDayConvention,
                    const ext::shared_ptr<FixedRateBond>& fixedCouponBond,
                    const Handle<YieldTermStructure>& discountCurve =
                                                Handle<YieldTermStructure>(),
                    const Handle<YieldTermStructure>& incomeDiscountCurve =
                                                Handle<YieldTermStructure>());
        //@}

        //! \name Calculations
        //@{

        //! (dirty) forward bond price
        Real forwardPrice() const;

        //! (dirty) forward bond price minus accrued on bond at delivery
        Real cleanForwardPrice() const;

        //!  NPV of bond coupons discounted using incomeDiscountCurve
        /*! Here only coupons between max(evaluation date,settlement
            date) and maturity date of bond forward contract are
            considered income.
        */
        Real spotIncome(const Handle<YieldTermStructure>& incomeDiscountCurve) const override;

        //!  NPV of underlying bond
        Real spotValue() const override;

        //@}

      protected:
        ext::shared_ptr<FixedRateBond> fixedCouponBond_;
        void performCalculations() const override;
    };

}


#endif

]]></document_content>
  </document>
  <document index="57">
    <source>floatfloatswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/capflooredcoupon.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/cmscoupon.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/experimental/coupons/cmsspreadcoupon.hpp> // internal
#include <ql/indexes/iborindex.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/instruments/floatfloatswap.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    FloatFloatSwap::FloatFloatSwap(const Swap::Type type,
                                   const Real nominal1,
                                   const Real nominal2,
                                   const Schedule& schedule1,
                                   ext::shared_ptr<InterestRateIndex> index1,
                                   DayCounter dayCount1,
                                   const Schedule& schedule2,
                                   ext::shared_ptr<InterestRateIndex> index2,
                                   DayCounter dayCount2,
                                   const bool intermediateCapitalExchange,
                                   const bool finalCapitalExchange,
                                   const Real gearing1,
                                   const Real spread1,
                                   const Real cappedRate1,
                                   const Real flooredRate1,
                                   const Real gearing2,
                                   const Real spread2,
                                   const Real cappedRate2,
                                   const Real flooredRate2,
                                   const boost::optional<BusinessDayConvention>& paymentConvention1,
                                   const boost::optional<BusinessDayConvention>& paymentConvention2)
    : Swap(2), type_(type), nominal1_(std::vector<Real>(schedule1.size() - 1, nominal1)),
      nominal2_(std::vector<Real>(schedule2.size() - 1, nominal2)), schedule1_(schedule1),
      schedule2_(schedule2), index1_(std::move(index1)), index2_(std::move(index2)),
      gearing1_(std::vector<Real>(schedule1.size() - 1, gearing1)),
      gearing2_(std::vector<Real>(schedule2.size() - 1, gearing2)),
      spread1_(std::vector<Real>(schedule1.size() - 1, spread1)),
      spread2_(std::vector<Real>(schedule2.size() - 1, spread2)),
      cappedRate1_(std::vector<Real>(schedule1.size() - 1, cappedRate1)),
      flooredRate1_(std::vector<Real>(schedule1.size() - 1, flooredRate1)),
      cappedRate2_(std::vector<Real>(schedule2.size() - 1, cappedRate2)),
      flooredRate2_(std::vector<Real>(schedule2.size() - 1, flooredRate2)),
      dayCount1_(std::move(dayCount1)), dayCount2_(std::move(dayCount2)),
      intermediateCapitalExchange_(intermediateCapitalExchange),
      finalCapitalExchange_(finalCapitalExchange) {

        init(paymentConvention1, paymentConvention2);
    }

    FloatFloatSwap::FloatFloatSwap(const Swap::Type type,
                                   std::vector<Real> nominal1,
                                   std::vector<Real> nominal2,
                                   Schedule schedule1,
                                   ext::shared_ptr<InterestRateIndex> index1,
                                   DayCounter dayCount1,
                                   Schedule schedule2,
                                   ext::shared_ptr<InterestRateIndex> index2,
                                   DayCounter dayCount2,
                                   const bool intermediateCapitalExchange,
                                   const bool finalCapitalExchange,
                                   std::vector<Real> gearing1,
                                   std::vector<Real> spread1,
                                   std::vector<Real> cappedRate1,
                                   std::vector<Real> flooredRate1,
                                   std::vector<Real> gearing2,
                                   std::vector<Real> spread2,
                                   std::vector<Real> cappedRate2,
                                   std::vector<Real> flooredRate2,
                                   const boost::optional<BusinessDayConvention>& paymentConvention1,
                                   const boost::optional<BusinessDayConvention>& paymentConvention2)
    : Swap(2), type_(type), nominal1_(std::move(nominal1)), nominal2_(std::move(nominal2)),
      schedule1_(std::move(schedule1)), schedule2_(std::move(schedule2)),
      index1_(std::move(index1)), index2_(std::move(index2)), gearing1_(std::move(gearing1)),
      gearing2_(std::move(gearing2)), spread1_(std::move(spread1)), spread2_(std::move(spread2)),
      cappedRate1_(std::move(cappedRate1)), flooredRate1_(std::move(flooredRate1)),
      cappedRate2_(std::move(cappedRate2)), flooredRate2_(std::move(flooredRate2)),
      dayCount1_(std::move(dayCount1)), dayCount2_(std::move(dayCount2)),
      intermediateCapitalExchange_(intermediateCapitalExchange),
      finalCapitalExchange_(finalCapitalExchange) {

        init(paymentConvention1, paymentConvention2);
    }

    void FloatFloatSwap::init(
        boost::optional<BusinessDayConvention> paymentConvention1,
        boost::optional<BusinessDayConvention> paymentConvention2) {

        QL_REQUIRE(nominal1_.size() == schedule1_.size() - 1,
                   "nominal1 size (" << nominal1_.size()
                                     << ") does not match schedule1 size ("
                                     << schedule1_.size() << ")");
        QL_REQUIRE(nominal2_.size() == schedule2_.size() - 1,
                   "nominal2 size (" << nominal2_.size()
                                     << ") does not match schedule2 size ("
                                     << nominal2_.size() << ")");
        QL_REQUIRE(gearing1_.empty() || gearing1_.size() == nominal1_.size(),
                   "nominal1 size (" << nominal1_.size() << ") does not match gearing1 size ("
                                     << gearing1_.size() << ")");
        QL_REQUIRE(gearing2_.empty() || gearing2_.size() == nominal2_.size(),
                   "nominal2 size (" << nominal2_.size() << ") does not match gearing2 size ("
                                     << gearing2_.size() << ")");
        QL_REQUIRE(cappedRate1_.empty() || cappedRate1_.size() == nominal1_.size(),
                   "nominal1 size (" << nominal1_.size() << ") does not match cappedRate1 size ("
                                     << cappedRate1_.size() << ")");
        QL_REQUIRE(cappedRate2_.empty() || cappedRate2_.size() == nominal2_.size(),
                   "nominal2 size (" << nominal2_.size() << ") does not match cappedRate2 size ("
                                     << cappedRate2_.size() << ")");
        QL_REQUIRE(flooredRate1_.empty() || flooredRate1_.size() == nominal1_.size(),
                   "nominal1 size (" << nominal1_.size() << ") does not match flooredRate1 size ("
                                     << flooredRate1_.size() << ")");
        QL_REQUIRE(flooredRate2_.empty() || flooredRate2_.size() == nominal2_.size(),
                   "nominal2 size (" << nominal2_.size() << ") does not match flooredRate2 size ("
                                     << flooredRate2_.size() << ")");

        if (paymentConvention1) // NOLINT(readability-implicit-bool-conversion)
            paymentConvention1_ = *paymentConvention1;
        else
            paymentConvention1_ = schedule1_.businessDayConvention();

        if (paymentConvention2) // NOLINT(readability-implicit-bool-conversion)
            paymentConvention2_ = *paymentConvention2;
        else
            paymentConvention2_ = schedule2_.businessDayConvention();

        if (gearing1_.empty())
            gearing1_ = std::vector<Real>(nominal1_.size(), 1.0);
        if (gearing2_.empty())
            gearing2_ = std::vector<Real>(nominal2_.size(), 1.0);
        if (spread1_.empty())
            spread1_ = std::vector<Real>(nominal1_.size(), 0.0);
        if (spread2_.empty())
            spread2_ = std::vector<Real>(nominal2_.size(), 0.0);
        if (cappedRate1_.empty())
            cappedRate1_ = std::vector<Real>(nominal1_.size(), Null<Real>());
        if (cappedRate2_.empty())
            cappedRate2_ = std::vector<Real>(nominal2_.size(), Null<Real>());
        if (flooredRate1_.empty())
            flooredRate1_ = std::vector<Real>(nominal1_.size(), Null<Real>());
        if (flooredRate2_.empty())
            flooredRate2_ = std::vector<Real>(nominal2_.size(), Null<Real>());

        bool isNull;
        isNull = cappedRate1_[0] == Null<Real>();
        for (Size i = 0; i < cappedRate1_.size(); i++) {
            if (isNull)
                QL_REQUIRE(cappedRate1_[i] == Null<Real>(),
                           "cappedRate1 must be null for all or none entry ("
                               << (i + 1) << "th is " << cappedRate1_[i]
                               << ")");
            else
                QL_REQUIRE(cappedRate1_[i] != Null<Real>(),
                           "cappedRate 1 must be null for all or none entry ("
                               << "1st is " << cappedRate1_[0] << ")");
        }
        isNull = cappedRate2_[0] == Null<Real>();
        for (Size i = 0; i < cappedRate2_.size(); i++) {
            if (isNull)
                QL_REQUIRE(cappedRate2_[i] == Null<Real>(),
                           "cappedRate2 must be null for all or none entry ("
                               << (i + 1) << "th is " << cappedRate2_[i]
                               << ")");
            else
                QL_REQUIRE(cappedRate2_[i] != Null<Real>(),
                           "cappedRate2 must be null for all or none entry ("
                               << "1st is " << cappedRate2_[0] << ")");
        }
        isNull = flooredRate1_[0] == Null<Real>();
        for (Size i = 0; i < flooredRate1_.size(); i++) {
            if (isNull)
                QL_REQUIRE(flooredRate1_[i] == Null<Real>(),
                           "flooredRate1 must be null for all or none entry ("
                               << (i + 1) << "th is " << flooredRate1_[i]
                               << ")");
            else
                QL_REQUIRE(flooredRate1_[i] != Null<Real>(),
                           "flooredRate 1 must be null for all or none entry ("
                               << "1st is " << flooredRate1_[0] << ")");
        }
        isNull = flooredRate2_[0] == Null<Real>();
        for (Size i = 0; i < flooredRate2_.size(); i++) {
            if (isNull)
                QL_REQUIRE(flooredRate2_[i] == Null<Real>(),
                           "flooredRate2 must be null for all or none entry ("
                               << (i + 1) << "th is " << flooredRate2_[i]
                               << ")");
            else
                QL_REQUIRE(flooredRate2_[i] != Null<Real>(),
                           "flooredRate2 must be null for all or none entry ("
                               << "1st is " << flooredRate2_[0] << ")");
        }

        // if the gearing is zero then the ibor / cms leg will be set up with
        // fixed coupons which makes trouble here in this context. We therefore
        // use a dirty trick and enforce the gearing to be non zero.
        for (double& i : gearing1_)
            if (close(i, 0.0))
                i = QL_EPSILON;
        for (double& i : gearing2_)
            if (close(i, 0.0))
                i = QL_EPSILON;

        ext::shared_ptr<IborIndex> ibor1 =
            ext::dynamic_pointer_cast<IborIndex>(index1_);
        ext::shared_ptr<IborIndex> ibor2 =
            ext::dynamic_pointer_cast<IborIndex>(index2_);
        ext::shared_ptr<SwapIndex> cms1 =
            ext::dynamic_pointer_cast<SwapIndex>(index1_);
        ext::shared_ptr<SwapIndex> cms2 =
            ext::dynamic_pointer_cast<SwapIndex>(index2_);
        ext::shared_ptr<SwapSpreadIndex> cmsspread1 =
            ext::dynamic_pointer_cast<SwapSpreadIndex>(index1_);
        ext::shared_ptr<SwapSpreadIndex> cmsspread2 =
            ext::dynamic_pointer_cast<SwapSpreadIndex>(index2_);

        QL_REQUIRE(ibor1 != nullptr || cms1 != nullptr || cmsspread1 != nullptr,
                   "index1 must be ibor or cms or cms spread");
        QL_REQUIRE(ibor2 != nullptr || cms2 != nullptr || cmsspread2 != nullptr,
                   "index2 must be ibor or cms");

        if (ibor1 != nullptr) {
            IborLeg leg(schedule1_, ibor1);
            leg = leg.withNotionals(nominal1_)
                      .withPaymentDayCounter(dayCount1_)
                      .withPaymentAdjustment(paymentConvention1_)
                      .withSpreads(spread1_)
                      .withGearings(gearing1_);
            if (cappedRate1_[0] != Null<Real>())
                leg = leg.withCaps(cappedRate1_);
            if (flooredRate1_[0] != Null<Real>())
                leg = leg.withFloors(flooredRate1_);
            legs_[0] = leg;
        }

        if (ibor2 != nullptr) {
            IborLeg leg(schedule2_, ibor2);
            leg = leg.withNotionals(nominal2_)
                      .withPaymentDayCounter(dayCount2_)
                      .withPaymentAdjustment(paymentConvention2_)
                      .withSpreads(spread2_)
                      .withGearings(gearing2_);
            if (cappedRate2_[0] != Null<Real>())
                leg = leg.withCaps(cappedRate2_);
            if (flooredRate2_[0] != Null<Real>())
                leg = leg.withFloors(flooredRate2_);
            legs_[1] = leg;
        }

        if (cms1 != nullptr) {
            CmsLeg leg(schedule1_, cms1);
            leg = leg.withNotionals(nominal1_)
                      .withPaymentDayCounter(dayCount1_)
                      .withPaymentAdjustment(paymentConvention1_)
                      .withSpreads(spread1_)
                      .withGearings(gearing1_);
            if (cappedRate1_[0] != Null<Real>())
                leg = leg.withCaps(cappedRate1_);
            if (flooredRate1_[0] != Null<Real>())
                leg = leg.withFloors(flooredRate1_);
            legs_[0] = leg;
        }

        if (cms2 != nullptr) {
            CmsLeg leg(schedule2_, cms2);
            leg = leg.withNotionals(nominal2_)
                      .withPaymentDayCounter(dayCount2_)
                      .withPaymentAdjustment(paymentConvention2_)
                      .withSpreads(spread2_)
                      .withGearings(gearing2_);
            if (cappedRate2_[0] != Null<Real>())
                leg = leg.withCaps(cappedRate2_);
            if (flooredRate2_[0] != Null<Real>())
                leg = leg.withFloors(flooredRate2_);
            legs_[1] = leg;
        }

        if (cmsspread1 != nullptr) {
            CmsSpreadLeg leg(schedule1_, cmsspread1);
            leg = leg.withNotionals(nominal1_)
                      .withPaymentDayCounter(dayCount1_)
                      .withPaymentAdjustment(paymentConvention1_)
                      .withSpreads(spread1_)
                      .withGearings(gearing1_);
            if (cappedRate1_[0] != Null<Real>())
                leg = leg.withCaps(cappedRate1_);
            if (flooredRate1_[0] != Null<Real>())
                leg = leg.withFloors(flooredRate1_);
            legs_[0] = leg;
        }

        if (cmsspread2 != nullptr) {
            CmsSpreadLeg leg(schedule2_, cmsspread2);
            leg = leg.withNotionals(nominal2_)
                      .withPaymentDayCounter(dayCount2_)
                      .withPaymentAdjustment(paymentConvention2_)
                      .withSpreads(spread2_)
                      .withGearings(gearing2_);
            if (cappedRate2_[0] != Null<Real>())
                leg = leg.withCaps(cappedRate2_);
            if (flooredRate2_[0] != Null<Real>())
                leg = leg.withFloors(flooredRate2_);
            legs_[1] = leg;
        }

        if (intermediateCapitalExchange_) {
            for (Size i = 0; i < legs_[0].size() - 1; i++) {
                Real cap = nominal1_[i] - nominal1_[i + 1];
                if (!close(cap, 0.0)) {
                    auto it1 = legs_[0].begin();
                    std::advance(it1, i + 1);
                    legs_[0].insert(
                        it1, ext::shared_ptr<CashFlow>(
                                 new Redemption(cap, legs_[0][i]->date())));
                    auto it2 = nominal1_.begin();
                    std::advance(it2, i + 1);
                    nominal1_.insert(it2, nominal1_[i]);
                    i++;
                }
            }
            for (Size i = 0; i < legs_[1].size() - 1; i++) {
                Real cap = nominal2_[i] - nominal2_[i + 1];
                if (!close(cap, 0.0)) {
                    auto it1 = legs_[1].begin();
                    std::advance(it1, i + 1);
                    legs_[1].insert(
                        it1, ext::shared_ptr<CashFlow>(
                                 new Redemption(cap, legs_[1][i]->date())));
                    auto it2 = nominal2_.begin();
                    std::advance(it2, i + 1);
                    nominal2_.insert(it2, nominal2_[i]);
                    i++;
                }
            }
        }

        if (finalCapitalExchange_) {
            legs_[0].push_back(ext::shared_ptr<CashFlow>(
                new Redemption(nominal1_.back(), legs_[0].back()->date())));
            nominal1_.push_back(nominal1_.back());
            legs_[1].push_back(ext::shared_ptr<CashFlow>(
                new Redemption(nominal2_.back(), legs_[1].back()->date())));
            nominal2_.push_back(nominal2_.back());
        }

        for (Leg::const_iterator i = legs_[0].begin(); i < legs_[0].end(); ++i)
            registerWith(*i);

        for (Leg::const_iterator i = legs_[1].begin(); i < legs_[1].end(); ++i)
            registerWith(*i);

        switch (type_) {
        case Swap::Payer:
            payer_[0] = -1.0;
            payer_[1] = +1.0;
            break;
        case Swap::Receiver:
            payer_[0] = +1.0;
            payer_[1] = -1.0;
            break;
        default:
            QL_FAIL("Unknown float float - swap type");
        }
    }

    void FloatFloatSwap::setupArguments(PricingEngine::arguments *args) const {

        Swap::setupArguments(args);

        auto* arguments = dynamic_cast<FloatFloatSwap::arguments*>(args);

        if (arguments == nullptr)
            return; // swap engine ... // QL_REQUIRE(arguments != 0, "argument type does not match");

        arguments->type = type_;
        arguments->nominal1 = nominal1_;
        arguments->nominal2 = nominal2_;
        arguments->index1 = index1_;
        arguments->index2 = index2_;

        const Leg &leg1Coupons = leg1();
        const Leg &leg2Coupons = leg2();

        arguments->leg1ResetDates = arguments->leg1PayDates =
            arguments->leg1FixingDates = std::vector<Date>(leg1Coupons.size());
        arguments->leg2ResetDates = arguments->leg2PayDates =
            arguments->leg2FixingDates = std::vector<Date>(leg2Coupons.size());

        arguments->leg1Spreads = arguments->leg1AccrualTimes =
            arguments->leg1Gearings = std::vector<Real>(leg1Coupons.size());
        arguments->leg2Spreads = arguments->leg2AccrualTimes =
            arguments->leg2Gearings = std::vector<Real>(leg2Coupons.size());

        arguments->leg1Coupons =
            std::vector<Real>(leg1Coupons.size(), Null<Real>());
        arguments->leg2Coupons =
            std::vector<Real>(leg2Coupons.size(), Null<Real>());

        arguments->leg1IsRedemptionFlow =
            std::vector<bool>(leg1Coupons.size(), false);
        arguments->leg2IsRedemptionFlow =
            std::vector<bool>(leg2Coupons.size(), false);

        arguments->leg1CappedRates = arguments->leg1FlooredRates =
            std::vector<Real>(leg1Coupons.size(), Null<Real>());
        arguments->leg2CappedRates = arguments->leg2FlooredRates =
            std::vector<Real>(leg2Coupons.size(), Null<Real>());

        for (Size i = 0; i < leg1Coupons.size(); ++i) {
            ext::shared_ptr<FloatingRateCoupon> coupon =
                ext::dynamic_pointer_cast<FloatingRateCoupon>(leg1Coupons[i]);
            if (coupon != nullptr) {
                arguments->leg1AccrualTimes[i] = coupon->accrualPeriod();
                arguments->leg1PayDates[i] = coupon->date();
                arguments->leg1ResetDates[i] = coupon->accrualStartDate();
                arguments->leg1FixingDates[i] = coupon->fixingDate();
                arguments->leg1Spreads[i] = coupon->spread();
                arguments->leg1Gearings[i] = coupon->gearing();
                try {
                    arguments->leg1Coupons[i] = coupon->amount();
                }
                catch (Error &) {
                    arguments->leg1Coupons[i] = Null<Real>();
                }
                ext::shared_ptr<CappedFlooredCoupon> cfcoupon =
                    ext::dynamic_pointer_cast<CappedFlooredCoupon>(
                        leg1Coupons[i]);
                if (cfcoupon != nullptr) {
                    arguments->leg1CappedRates[i] = cfcoupon->cap();
                    arguments->leg1FlooredRates[i] = cfcoupon->floor();
                }
            } else {
                ext::shared_ptr<CashFlow> cashflow =
                    ext::dynamic_pointer_cast<CashFlow>(leg1Coupons[i]);
                std::vector<Date>::const_iterator j =
                    std::find(arguments->leg1PayDates.begin(),
                              arguments->leg1PayDates.end(), cashflow->date());
                QL_REQUIRE(j != arguments->leg1PayDates.end(),
                           "nominal redemption on "
                               << cashflow->date()
                               << "has no corresponding coupon");
                Size jIdx = j - arguments->leg1PayDates.begin();
                arguments->leg1IsRedemptionFlow[i] = true;
                arguments->leg1Coupons[i] = cashflow->amount();
                arguments->leg1ResetDates[i] = arguments->leg1ResetDates[jIdx];
                arguments->leg1FixingDates[i] =
                    arguments->leg1FixingDates[jIdx];
                arguments->leg1AccrualTimes[i] = 0.0;
                arguments->leg1Spreads[i] = 0.0;
                arguments->leg1Gearings[i] = 1.0;
                arguments->leg1PayDates[i] = cashflow->date();
            }
        }

        for (Size i = 0; i < leg2Coupons.size(); ++i) {
            ext::shared_ptr<FloatingRateCoupon> coupon =
                ext::dynamic_pointer_cast<FloatingRateCoupon>(leg2Coupons[i]);
            if (coupon != nullptr) {
                arguments->leg2AccrualTimes[i] = coupon->accrualPeriod();
                arguments->leg2PayDates[i] = coupon->date();
                arguments->leg2ResetDates[i] = coupon->accrualStartDate();
                arguments->leg2FixingDates[i] = coupon->fixingDate();
                arguments->leg2Spreads[i] = coupon->spread();
                arguments->leg2Gearings[i] = coupon->gearing();
                try {
                    arguments->leg2Coupons[i] = coupon->amount();
                }
                catch (Error &) {
                    arguments->leg2Coupons[i] = Null<Real>();
                }
                ext::shared_ptr<CappedFlooredCoupon> cfcoupon =
                    ext::dynamic_pointer_cast<CappedFlooredCoupon>(
                        leg2Coupons[i]);
                if (cfcoupon != nullptr) {
                    arguments->leg2CappedRates[i] = cfcoupon->cap();
                    arguments->leg2FlooredRates[i] = cfcoupon->floor();
                }
            } else {
                ext::shared_ptr<CashFlow> cashflow =
                    ext::dynamic_pointer_cast<CashFlow>(leg2Coupons[i]);
                std::vector<Date>::const_iterator j =
                    std::find(arguments->leg2PayDates.begin(),
                              arguments->leg2PayDates.end(), cashflow->date());
                QL_REQUIRE(j != arguments->leg2PayDates.end(),
                           "nominal redemption on "
                               << cashflow->date()
                               << "has no corresponding coupon");
                Size jIdx = j - arguments->leg2PayDates.begin();
                arguments->leg2IsRedemptionFlow[i] = true;
                arguments->leg2Coupons[i] = cashflow->amount();
                arguments->leg2ResetDates[i] = arguments->leg2ResetDates[jIdx];
                arguments->leg2FixingDates[i] =
                    arguments->leg2FixingDates[jIdx];
                arguments->leg2AccrualTimes[i] = 0.0;
                arguments->leg2Spreads[i] = 0.0;
                arguments->leg2Gearings[i] = 1.0;
                arguments->leg2PayDates[i] = cashflow->date();
            }
        }
    }

    void FloatFloatSwap::setupExpired() const { Swap::setupExpired(); }

    void FloatFloatSwap::fetchResults(const PricingEngine::results *r) const {
        Swap::fetchResults(r);
    }

    void FloatFloatSwap::arguments::validate() const {

        Swap::arguments::validate();

        QL_REQUIRE(nominal1.size() == leg1ResetDates.size(),
                   "nominal1 size is different from resetDates1 size");
        QL_REQUIRE(nominal1.size() == leg1FixingDates.size(),
                   "nominal1 size is different from fixingDates1 size");
        QL_REQUIRE(nominal1.size() == leg1PayDates.size(),
                   "nominal1 size is different from payDates1 size");
        QL_REQUIRE(nominal1.size() == leg1Spreads.size(),
                   "nominal1 size is different from spreads1 size");
        QL_REQUIRE(nominal1.size() == leg1Gearings.size(),
                   "nominal1 size is different from gearings1 size");
        QL_REQUIRE(nominal1.size() == leg1CappedRates.size(),
                   "nominal1 size is different from cappedRates1 size");
        QL_REQUIRE(nominal1.size() == leg1FlooredRates.size(),
                   "nominal1 size is different from flooredRates1 size");
        QL_REQUIRE(nominal1.size() == leg1Coupons.size(),
                   "nominal1 size is different from coupons1 size");
        QL_REQUIRE(nominal1.size() == leg1AccrualTimes.size(),
                   "nominal1 size is different from accrualTimes1 size");
        QL_REQUIRE(nominal1.size() == leg1IsRedemptionFlow.size(),
                   "nominal1 size is different from redemption1 size");

        QL_REQUIRE(nominal2.size() == leg2ResetDates.size(),
                   "nominal2 size is different from resetDates2 size");
        QL_REQUIRE(nominal2.size() == leg2FixingDates.size(),
                   "nominal2 size is different from fixingDates2 size");
        QL_REQUIRE(nominal2.size() == leg2PayDates.size(),
                   "nominal2 size is different from payDates2 size");
        QL_REQUIRE(nominal2.size() == leg2Spreads.size(),
                   "nominal2 size is different from spreads2 size");
        QL_REQUIRE(nominal2.size() == leg2Gearings.size(),
                   "nominal2 size is different from gearings2 size");
        QL_REQUIRE(nominal2.size() == leg2CappedRates.size(),
                   "nominal2 size is different from cappedRates2 size");
        QL_REQUIRE(nominal2.size() == leg2FlooredRates.size(),
                   "nominal2 size is different from flooredRates2 size");
        QL_REQUIRE(nominal2.size() == leg2Coupons.size(),
                   "nominal2 size is different from coupons2 size");
        QL_REQUIRE(nominal2.size() == leg2AccrualTimes.size(),
                   "nominal2 size is different from accrualTimes2 size");
        QL_REQUIRE(nominal2.size() == leg2IsRedemptionFlow.size(),
                   "nominal2 size is different from redemption2 size");

        QL_REQUIRE(index1 != nullptr, "index1 is null");
        QL_REQUIRE(index2 != nullptr, "index2 is null");
    }

    void FloatFloatSwap::results::reset() { Swap::results::reset(); }
}
]]></document_content>
  </document>
  <document index="58">
    <source>floatfloatswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file floatfloatswap.hpp
    \brief swap exchanging capped floored Libor or CMS coupons with quite
           general specification. If no payment convention is given, the
           respective leg schedule convention is used. The interest rate
           indices should be linked to valid forwarding and in case of
           swap indices discounting curves
*/

#ifndef quantlib_floatfloat_swap_hpp
#define quantlib_floatfloat_swap_hpp

#include <ql/instruments/swap.hpp>
#include <ql/instruments/vanillaswap.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/time/schedule.hpp>
#include <boost/optional.hpp>

namespace QuantLib {

    class InterestRateIndex;

    //! float float swap

    class FloatFloatSwap : public Swap {
      public:
        class arguments;
        class results;
        class engine;
        FloatFloatSwap(
            Swap::Type type,
            Real nominal1,
            Real nominal2,
            const Schedule& schedule1,
            ext::shared_ptr<InterestRateIndex> index1,
            DayCounter dayCount1,
            const Schedule& schedule2,
            ext::shared_ptr<InterestRateIndex> index2,
            DayCounter dayCount2,
            bool intermediateCapitalExchange = false,
            bool finalCapitalExchange = false,
            Real gearing1 = 1.0,
            Real spread1 = 0.0,
            Real cappedRate1 = Null<Real>(),
            Real flooredRate1 = Null<Real>(),
            Real gearing2 = 1.0,
            Real spread2 = 0.0,
            Real cappedRate2 = Null<Real>(),
            Real flooredRate2 = Null<Real>(),
            const boost::optional<BusinessDayConvention>& paymentConvention1 = boost::none,
            const boost::optional<BusinessDayConvention>& paymentConvention2 = boost::none);

        FloatFloatSwap(
            Swap::Type type,
            std::vector<Real> nominal1,
            std::vector<Real> nominal2,
            Schedule schedule1,
            ext::shared_ptr<InterestRateIndex> index1,
            DayCounter dayCount1,
            Schedule schedule2,
            ext::shared_ptr<InterestRateIndex> index2,
            DayCounter dayCount2,
            bool intermediateCapitalExchange = false,
            bool finalCapitalExchange = false,
            std::vector<Real> gearing1 = std::vector<Real>(),
            std::vector<Real> spread1 = std::vector<Real>(),
            std::vector<Real> cappedRate1 = std::vector<Real>(),
            std::vector<Real> flooredRate1 = std::vector<Real>(),
            std::vector<Real> gearing2 = std::vector<Real>(),
            std::vector<Real> spread2 = std::vector<Real>(),
            std::vector<Real> cappedRate2 = std::vector<Real>(),
            std::vector<Real> flooredRate2 = std::vector<Real>(),
            const boost::optional<BusinessDayConvention>& paymentConvention1 = boost::none,
            const boost::optional<BusinessDayConvention>& paymentConvention2 = boost::none);

        //! \name Inspectors
        //@{
        Swap::Type type() const;
        const std::vector<Real> &nominal1() const;
        const std::vector<Real> &nominal2() const;

        const Schedule &schedule1() const;
        const Schedule &schedule2() const;

        const ext::shared_ptr<InterestRateIndex> &index1() const;
        const ext::shared_ptr<InterestRateIndex> &index2() const;

        std::vector<Real> spread1() const;
        std::vector<Real> spread2() const;

        std::vector<Real> gearing1() const;
        std::vector<Real> gearing2() const;

        std::vector<Rate> cappedRate1() const;
        std::vector<Rate> flooredRate1() const;
        std::vector<Rate> cappedRate2() const;
        std::vector<Rate> flooredRate2() const;

        const DayCounter &dayCount1() const;
        const DayCounter &dayCount2() const;

        BusinessDayConvention paymentConvention1() const;
        BusinessDayConvention paymentConvention2() const;

        const Leg &leg1() const;
        const Leg &leg2() const;
        //@}

        //! \name Results
        //@{
        //@}
        // other
        void setupArguments(PricingEngine::arguments* args) const override;
        void fetchResults(const PricingEngine::results*) const override;

      private:
        void init(boost::optional<BusinessDayConvention> paymentConvention1,
                  boost::optional<BusinessDayConvention> paymentConvention2);
        void setupExpired() const override;
        Swap::Type type_;
        std::vector<Real> nominal1_, nominal2_;
        Schedule schedule1_, schedule2_;
        ext::shared_ptr<InterestRateIndex> index1_, index2_;
        std::vector<Real> gearing1_, gearing2_, spread1_, spread2_;
        std::vector<Real> cappedRate1_, flooredRate1_, cappedRate2_,
            flooredRate2_;
        DayCounter dayCount1_, dayCount2_;
        std::vector<bool> isRedemptionFlow1_, isRedemptionFlow2_;
        BusinessDayConvention paymentConvention1_, paymentConvention2_;
        const bool intermediateCapitalExchange_, finalCapitalExchange_;
    };

    //! %Arguments for float float swap calculation
    class FloatFloatSwap::arguments : public Swap::arguments {
      public:
        arguments() = default;
        Swap::Type type = Swap::Receiver;
        std::vector<Real> nominal1, nominal2;

        std::vector<Date> leg1ResetDates, leg1FixingDates, leg1PayDates;
        std::vector<Date> leg2ResetDates, leg2FixingDates, leg2PayDates;

        std::vector<Real> leg1Spreads, leg2Spreads, leg1Gearings, leg2Gearings;
        std::vector<Real> leg1CappedRates, leg1FlooredRates, leg2CappedRates,
            leg2FlooredRates;

        std::vector<Real> leg1Coupons, leg2Coupons;
        std::vector<Real> leg1AccrualTimes, leg2AccrualTimes;

        ext::shared_ptr<InterestRateIndex> index1, index2;

        std::vector<bool> leg1IsRedemptionFlow, leg2IsRedemptionFlow;

        void validate() const override;
    };

    //! %Results from float float swap calculation
    class FloatFloatSwap::results : public Swap::results {
      public:
        void reset() override;
    };

    class FloatFloatSwap::engine
        : public GenericEngine<FloatFloatSwap::arguments,
                               FloatFloatSwap::results> {};

    // inline definitions

    inline Swap::Type FloatFloatSwap::type() const { return type_; }

    inline const std::vector<Real> &FloatFloatSwap::nominal1() const {
        return nominal1_;
    }

    inline const std::vector<Real> &FloatFloatSwap::nominal2() const {
        return nominal2_;
    }

    inline const Schedule &FloatFloatSwap::schedule1() const {
        return schedule1_;
    }

    inline const Schedule &FloatFloatSwap::schedule2() const {
        return schedule2_;
    }

    inline const ext::shared_ptr<InterestRateIndex> &
    FloatFloatSwap::index1() const {
        return index1_;
    }

    inline const ext::shared_ptr<InterestRateIndex> &
    FloatFloatSwap::index2() const {
        return index2_;
    }

    inline std::vector<Real> FloatFloatSwap::spread1() const { return spread1_; }

    inline std::vector<Real> FloatFloatSwap::spread2() const { return spread2_; }

    inline std::vector<Real> FloatFloatSwap::gearing1() const { return gearing1_; }

    inline std::vector<Real> FloatFloatSwap::gearing2() const { return gearing2_; }

    inline std::vector<Real> FloatFloatSwap::cappedRate1() const { return cappedRate1_; }

    inline std::vector<Real> FloatFloatSwap::cappedRate2() const { return cappedRate2_; }

    inline std::vector<Real> FloatFloatSwap::flooredRate1() const { return flooredRate1_; }

    inline std::vector<Real> FloatFloatSwap::flooredRate2() const { return flooredRate2_; }

    inline const DayCounter &FloatFloatSwap::dayCount1() const {
        return dayCount1_;
    }

    inline const DayCounter &FloatFloatSwap::dayCount2() const {
        return dayCount2_;
    }

    inline BusinessDayConvention FloatFloatSwap::paymentConvention1() const {
        return paymentConvention1_;
    }

    inline BusinessDayConvention FloatFloatSwap::paymentConvention2() const {
        return paymentConvention2_;
    }

    inline const Leg &FloatFloatSwap::leg1() const { return legs_[0]; }

    inline const Leg &FloatFloatSwap::leg2() const { return legs_[1]; }
}

#endif
]]></document_content>
  </document>
  <document index="59">
    <source>floatfloatswaption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2018 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/instruments/floatfloatswaption.hpp>
#include <utility>

namespace QuantLib {

    FloatFloatSwaption::FloatFloatSwaption(ext::shared_ptr<FloatFloatSwap> swap,
                                           const ext::shared_ptr<Exercise>& exercise,
                                           Settlement::Type delivery,
                                           Settlement::Method settlementMethod)
    : Option(ext::shared_ptr<Payoff>(), exercise), swap_(std::move(swap)),
      settlementType_(delivery), settlementMethod_(settlementMethod) {
        registerWith(swap_);
        registerWithObservables(swap_);
    }

    bool FloatFloatSwaption::isExpired() const {
        return detail::simple_event(exercise_->dates().back()).hasOccurred();
    }

    void
    FloatFloatSwaption::setupArguments(PricingEngine::arguments *args) const {

        swap_->setupArguments(args);

        auto* arguments = dynamic_cast<FloatFloatSwaption::arguments*>(args);

        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->swap = swap_;
        arguments->exercise = exercise_;
        arguments->settlementType = settlementType_;
        arguments->settlementMethod = settlementMethod_;
    }

    void FloatFloatSwaption::arguments::validate() const {
        FloatFloatSwap::arguments::validate();
        QL_REQUIRE(swap, "underlying cms swap not set");
        QL_REQUIRE(exercise, "exercise not set");
        Settlement::checkTypeAndMethodConsistency(settlementType,
                                                  settlementMethod);
    }

    Disposable<std::vector<ext::shared_ptr<BlackCalibrationHelper> > >
    FloatFloatSwaption::calibrationBasket(
        const ext::shared_ptr<SwapIndex>& standardSwapBase,
        const ext::shared_ptr<SwaptionVolatilityStructure>& swaptionVolatility,
        const BasketGeneratingEngine::CalibrationBasketType basketType) const {

        ext::shared_ptr<BasketGeneratingEngine> engine =
            ext::dynamic_pointer_cast<BasketGeneratingEngine>(engine_);
        QL_REQUIRE(engine, "engine is not a basket generating engine");
        engine_->reset();
        setupArguments(engine_->getArguments());
        engine_->getArguments()->validate();
        return engine->calibrationBasket(exercise_, standardSwapBase,
                                         swaptionVolatility, basketType);
    }

}
]]></document_content>
  </document>
  <document index="60">
    <source>floatfloatswaption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2018 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file floatfloatswaption.hpp
    \brief floatfloatswaption class
*/

#ifndef quantlib_instruments_floatfloatswaption_hpp
#define quantlib_instruments_floatfloatswaption_hpp

#include <ql/instruments/swaption.hpp>
#include <ql/instruments/floatfloatswap.hpp>
#include <ql/pricingengines/swaption/basketgeneratingengine.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/termstructures/volatility/swaption/swaptionvolstructure.hpp>
#include <ql/models/calibrationhelper.hpp>
#include <ql/utilities/disposable.hpp>

namespace QuantLib {

    //! floatfloat swaption class
    /*! \ingroup instruments
    */

    class FloatFloatSwaption : public Option {
      public:
        class arguments;
        class engine;
        FloatFloatSwaption(ext::shared_ptr<FloatFloatSwap> swap,
                           const ext::shared_ptr<Exercise>& exercise,
                           Settlement::Type delivery = Settlement::Physical,
                           Settlement::Method settlementMethod = Settlement::PhysicalOTC);
        //! \name Instrument interface
        //@{
        bool isExpired() const override;
        void setupArguments(PricingEngine::arguments*) const override;
        //@}
        //! \name Inspectors
        //@{
        Settlement::Type settlementType() const { return settlementType_; }
        Settlement::Method settlementMethod() const {
            return settlementMethod_;
        }
        Swap::Type type() const { return swap_->type(); }
        const ext::shared_ptr<FloatFloatSwap> &underlyingSwap() const {
            return swap_;
        }
        //@}
        Disposable<std::vector<ext::shared_ptr<BlackCalibrationHelper> > >
        calibrationBasket(const ext::shared_ptr<SwapIndex>& standardSwapBase,
                          const ext::shared_ptr<SwaptionVolatilityStructure>& swaptionVolatility,
                          BasketGeneratingEngine::CalibrationBasketType basketType =
                              BasketGeneratingEngine::MaturityStrikeByDeltaGamma) const;

      private:
        // arguments
        ext::shared_ptr<FloatFloatSwap> swap_;
        Settlement::Type settlementType_;
        Settlement::Method settlementMethod_;
    };

    //! %Arguments for cms swaption calculation
    class FloatFloatSwaption::arguments : public FloatFloatSwap::arguments,
                                          public Option::arguments {
      public:
        arguments() = default;
        ext::shared_ptr<FloatFloatSwap> swap;
        Settlement::Type settlementType;
        Settlement::Method settlementMethod;
        void validate() const override;
    };

    //! base class for cms swaption engines
    class FloatFloatSwaption::engine
        : public GenericEngine<FloatFloatSwaption::arguments,
                               FloatFloatSwaption::results> {};
}

#endif
]]></document_content>
  </document>
  <document index="61">
    <source>forward.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/event.hpp>
#include <ql/instruments/forward.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    Forward::Forward(DayCounter dayCounter,
                     Calendar calendar,
                     BusinessDayConvention businessDayConvention,
                     Natural settlementDays,
                     ext::shared_ptr<Payoff> payoff,
                     const Date& valueDate,
                     const Date& maturityDate,
                     Handle<YieldTermStructure> discountCurve)
    : dayCounter_(std::move(dayCounter)), calendar_(std::move(calendar)),
      businessDayConvention_(businessDayConvention), settlementDays_(settlementDays),
      payoff_(std::move(payoff)), valueDate_(valueDate), maturityDate_(maturityDate),
      discountCurve_(std::move(discountCurve)) {

        maturityDate_ = calendar_.adjust(maturityDate_,
                                         businessDayConvention_);

        registerWith(Settings::instance().evaluationDate());
        registerWith(discountCurve_);
    }


    Date Forward::settlementDate() const {
        Date d = calendar_.advance(Settings::instance().evaluationDate(),
                                   settlementDays_, Days);
        return std::max(d,valueDate_);
    }


    bool Forward::isExpired() const {
        return detail::simple_event(maturityDate_)
               .hasOccurred(settlementDate());
    }


    Real Forward::forwardValue() const {
        calculate();
        return (underlyingSpotValue_ - underlyingIncome_ )/
               discountCurve_->discount(maturityDate_);
    }


    InterestRate Forward::impliedYield(Real underlyingSpotValue,
                                       Real forwardValue,
                                       Date settlementDate,
                                       Compounding comp,
                                       const DayCounter& dayCounter) {

        Time t = dayCounter.yearFraction(settlementDate,maturityDate_) ;
        Real compoundingFactor = forwardValue/
            (underlyingSpotValue-spotIncome(incomeDiscountCurve_)) ;
        return InterestRate::impliedRate(compoundingFactor,
                                         dayCounter, comp, Annual,
                                         t);
    }


    void Forward::performCalculations() const {

        QL_REQUIRE(!discountCurve_.empty(),
                   "null term structure set to Forward");

        ext::shared_ptr<ForwardTypePayoff> ftpayoff =
            ext::dynamic_pointer_cast<ForwardTypePayoff>(payoff_);
        Real fwdValue = forwardValue();
        NPV_ = (*ftpayoff)(fwdValue) * discountCurve_->discount(maturityDate_);
    }

}
]]></document_content>
  </document>
  <document index="62">
    <source>forward.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file forward.hpp
    \brief Base forward class
*/

#ifndef quantlib_forward_hpp
#define quantlib_forward_hpp

#include <ql/instrument.hpp>
#include <ql/position.hpp>
#include <ql/time/calendar.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/interestrate.hpp>
#include <ql/types.hpp>
#include <ql/handle.hpp>
#include <ql/payoff.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>

namespace QuantLib {

    //! Abstract base forward class
    /*! Derived classes must implement the virtual functions
        spotValue() (NPV or spot price) and spotIncome() associated
        with the specific relevant underlying (e.g. bond, stock,
        commodity, loan/deposit). These functions must be used to set the
        protected member variables underlyingSpotValue_ and
        underlyingIncome_ within performCalculations() in the derived
        class before the base-class implementation is called.

        spotIncome() refers generically to the present value of
        coupons, dividends or storage costs.

        discountCurve_ is the curve used to discount forward contract
        cash flows back to the evaluation day, as well as to obtain
        forward values for spot values/prices.

        incomeDiscountCurve_, which for generality is not
        automatically set to the discountCurve_, is the curve used to
        discount future income/dividends/storage-costs etc back to the
        evaluation date.

        \todo Add preconditions and tests

        \warning This class still needs to be rigorously tested

        \ingroup instruments
    */
    class Forward : public Instrument {
      public:
        //! \name Inspectors
        //@{
        virtual Date settlementDate() const;
        const Calendar& calendar() const;
        BusinessDayConvention businessDayConvention() const;
        const DayCounter& dayCounter() const;
        //! term structure relevant to the contract (e.g. repo curve)
        Handle<YieldTermStructure> discountCurve() const;
        //! term structure that discounts the underlying's income cash flows
        Handle<YieldTermStructure> incomeDiscountCurve() const;
        //! returns whether the instrument is still tradable.
        bool isExpired() const override;
        //@}

        //! returns spot value/price of an underlying financial instrument
        virtual Real spotValue() const = 0;
        //! NPV of income/dividends/storage-costs etc. of underlying instrument
        virtual Real spotIncome(const Handle<YieldTermStructure>&
                                               incomeDiscountCurve) const = 0;

        //! \name Calculations
        //@{
        //! forward value/price of underlying, discounting income/dividends
        /*! \note if this is a bond forward price, is must be a dirty
                  forward price.
        */
        virtual Real forwardValue() const;

        /*! Simple yield calculation based on underlying spot and
            forward values, taking into account underlying income.
            When \f$ t>0 \f$, call with:
            underlyingSpotValue=spotValue(t),
            forwardValue=strikePrice, to get current yield. For a
            repo, if \f$ t=0 \f$, impliedYield should reproduce the
            spot repo rate. For FRA's, this should reproduce the
            relevant zero rate at the FRA's maturityDate_;
        */
        InterestRate impliedYield(Real underlyingSpotValue,
                                  Real forwardValue,
                                  Date settlementDate,
                                  Compounding compoundingConvention,
                                  const DayCounter& dayCounter);
        //@}
      protected:
        Forward(DayCounter dayCounter,
                Calendar calendar,
                BusinessDayConvention businessDayConvention,
                Natural settlementDays,
                ext::shared_ptr<Payoff> payoff,
                const Date& valueDate,
                const Date& maturityDate,
                Handle<YieldTermStructure> discountCurve = Handle<YieldTermStructure>());

        void performCalculations() const override;
        /*! derived classes must set this, typically via spotIncome() */
        mutable Real underlyingIncome_;
        /*! derived classes must set this, typically via spotValue() */
        mutable Real underlyingSpotValue_;

        DayCounter dayCounter_;
        Calendar calendar_;
        BusinessDayConvention businessDayConvention_;
        Natural settlementDays_;
        ext::shared_ptr<Payoff> payoff_;
        /*! valueDate = settlement date (date the fwd contract starts
            accruing)
        */
        Date valueDate_;
        //! maturityDate of the forward contract or delivery date of underlying
        Date maturityDate_;
        Handle<YieldTermStructure> discountCurve_;
        /*! must set this in derived classes, based on particular underlying */
        Handle<YieldTermStructure> incomeDiscountCurve_;
    };


    //! Class for forward type payoffs
    class ForwardTypePayoff : public Payoff {
      public:
        ForwardTypePayoff(Position::Type type, Real strike)
        : type_(type),strike_(strike) {
            QL_REQUIRE(strike >= 0.0,"negative strike given");
        }
        Position::Type forwardType() const { return type_; };
        Real strike() const { return strike_; };
        //! \name Payoff interface
        //@{
        std::string name() const override { return "Forward"; }
        std::string description() const override;
        Real operator()(Real price) const override;
        //@}
      protected:
        Position::Type type_;
        Real strike_;
    };



    // inline definitions

    inline const Calendar& Forward::calendar() const {
        return calendar_;
    }

    inline BusinessDayConvention Forward::businessDayConvention() const {
        return businessDayConvention_;
    }

    inline const DayCounter& Forward::dayCounter() const {
        return dayCounter_;
    }

    inline Handle<YieldTermStructure> Forward::discountCurve() const {
        return discountCurve_;
    }

    inline Handle<YieldTermStructure> Forward::incomeDiscountCurve() const {
        return incomeDiscountCurve_;
    }


    inline std::string ForwardTypePayoff::description() const {
        std::ostringstream result;
        result << name() << ", " << strike() << " strike";
        return result.str();
    }

    inline Real ForwardTypePayoff::operator()(Real price) const {
        switch (type_) {
          case Position::Long:
            return (price-strike_);
          case Position::Short:
            return (strike_-price);
          default:
            QL_FAIL("unknown/illegal position type");
        }
    }

}


#endif

]]></document_content>
  </document>
  <document index="63">
    <source>forwardrateagreement.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license. You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/forwardrateagreement.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/event.hpp>

namespace QuantLib {

    ForwardRateAgreement::ForwardRateAgreement(
                           const Date& valueDate,
                           const Date& maturityDate,
                           Position::Type type,
                           Rate strikeForwardRate,
                           Real notionalAmount,
                           const ext::shared_ptr<IborIndex>& index,
                           const Handle<YieldTermStructure>& discountCurve,
                           bool useIndexedCoupon)
    : Forward(index->dayCounter(), index->fixingCalendar(),
              index->businessDayConvention(),
              index->fixingDays(), ext::shared_ptr<Payoff>(),
              valueDate, maturityDate, discountCurve),
      fraType_(type), notionalAmount_(notionalAmount), index_(index),
      useIndexedCoupon_(useIndexedCoupon) {

        QL_REQUIRE(notionalAmount > 0.0, "notionalAmount must be positive");

        strikeForwardRate_ = InterestRate(strikeForwardRate,
                                          index->dayCounter(),
                                          Simple, Once);
        Real strike = notionalAmount_ *
                      strikeForwardRate_.compoundFactor(valueDate_,
                                                        maturityDate_);
        payoff_ = ext::shared_ptr<Payoff>(new ForwardTypePayoff(fraType_,
                                                                  strike));
        // incomeDiscountCurve_ is irrelevant to an FRA
        incomeDiscountCurve_ = discountCurve_;
        // income is irrelevant to FRA - set it to zero
        underlyingIncome_ = 0.0;
        registerWith(index_);
    }

    Date ForwardRateAgreement::settlementDate() const {
        return calendar_.advance(Settings::instance().evaluationDate(),
                                 settlementDays_, Days);
    }

    Date ForwardRateAgreement::fixingDate() const {
        return calendar_.advance(valueDate_,
                                 -static_cast<Integer>(settlementDays_), Days);
    }

    bool ForwardRateAgreement::isExpired() const {
        return detail::simple_event(valueDate_).hasOccurred(settlementDate());
    }

    Real ForwardRateAgreement::spotIncome(
                                    const Handle<YieldTermStructure>&) const {
        return 0.0;
    }

    // In theory, no need to implement this for a FRA (could directly
    // supply a forwardValue). For the sake of keeping a consistent
    // framework, we adhere to the concept of the forward contract as
    // defined in the base class, with an underlying having a
    // spotPrice (in this case, a loan or deposit with an NPV). Thus,
    // spotValue() is defined here.
    Real ForwardRateAgreement::spotValue() const {
        calculate();
        return notionalAmount_ *
               forwardRate().compoundFactor(valueDate_, maturityDate_) *
               discountCurve_->discount(maturityDate_);
    }

    InterestRate ForwardRateAgreement::forwardRate() const {
        calculate();
        return forwardRate_;
    }

    void ForwardRateAgreement::setupExpired() const {
        Forward::setupExpired();
        calculateForwardRate();
    }

    void ForwardRateAgreement::performCalculations() const {
        calculateForwardRate();
        underlyingSpotValue_ = spotValue();
        underlyingIncome_    = 0.0;
        Forward::performCalculations();
    }

    void ForwardRateAgreement::calculateForwardRate() const {
        if (useIndexedCoupon_)
            forwardRate_ =
                InterestRate(index_->fixing(fixingDate()), index_->dayCounter(), Simple, Once);
        else
            // par coupon approximation
            forwardRate_ =
                InterestRate((index_->forwardingTermStructure()->discount(valueDate_) /
                                  index_->forwardingTermStructure()->discount(maturityDate_) -
                              1.0) /
                                 index_->dayCounter().yearFraction(valueDate_, maturityDate_),
                             index_->dayCounter(), Simple, Once);
    }
}
]]></document_content>
  </document>
  <document index="64">
    <source>forwardrateagreement.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Allen Kuo

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file forwardrateagreement.hpp
    \brief forward rate agreement
*/

#ifndef quantlib_forward_rate_agreement_hpp
#define quantlib_forward_rate_agreement_hpp

#include <ql/instruments/forward.hpp>

namespace QuantLib {

    class IborIndex;

    //! %Forward rate agreement (FRA) class
    /*! 1. Unlike the forward contract conventions on carryable
           financial assets (stocks, bonds, commodities), the
           valueDate for a FRA is taken to be the day when the forward
           loan or deposit begins and when full settlement takes place
           (based on the NPV of the contract on that date).
           maturityDate is the date when the forward loan or deposit
           ends. In fact, the FRA settles and expires on the
           valueDate, not on the (later) maturityDate. It follows that
           (maturityDate - valueDate) is the tenor/term of the
           underlying loan or deposit

        2. Choose position type = Long for an "FRA purchase" (future
           long loan, short deposit [borrower])

        3. Choose position type = Short for an "FRA sale" (future short
           loan, long deposit [lender])

        4. If strike is given in the constructor, can calculate the NPV
           of the contract via NPV().

        5. If forward rate is desired/unknown, it can be obtained via
           forwardRate(). In this case, the strike variable in the
           constructor is irrelevant and will be ignored.

        <b>Example: </b>
        \link FRA.cpp
        valuation of a forward-rate agreement
        \endlink

        \todo Add preconditions and tests

        \todo Should put an instance of ForwardRateAgreement in the
              FraRateHelper to ensure consistency with the piecewise
              yield curve.

        \todo Differentiate between BBA (British)/AFB (French)
              [assumed here] and ABA (Australian) banker conventions
              in the calculations.

        \warning This class still needs to be rigorously tested

        \ingroup instruments
    */
    class ForwardRateAgreement: public Forward {
      public:
        ForwardRateAgreement(const Date& valueDate,
                             const Date& maturityDate,
                             Position::Type type,
                             Rate strikeForwardRate,
                             Real notionalAmount,
                             const ext::shared_ptr<IborIndex>& index,
                             const Handle<YieldTermStructure>& discountCurve =
                                                 Handle<YieldTermStructure>(),
                             bool useIndexedCoupon = true);
        //! \name Calculations
        //@{
        /*! A FRA expires/settles on the valueDate */
        bool isExpired() const override;
        /*! This returns evaluationDate + settlementDays (not FRA
            valueDate).
        */
        Date settlementDate() const override;
        Date fixingDate() const;
        /*!  Income is zero for a FRA */
        Real spotIncome(const Handle<YieldTermStructure>& incomeDiscountCurve) const override;
        //! Spot value (NPV) of the underlying loan
        /*! This has always a positive value (asset), even if short the FRA */
        Real spotValue() const override;
        //! Returns the relevant forward rate associated with the FRA term
        InterestRate forwardRate() const;
        //@}

      protected:
        void setupExpired() const override;
        void performCalculations() const override;
        Position::Type fraType_;
        //! aka FRA rate (the market forward rate)
        mutable InterestRate forwardRate_;
        //! aka FRA fixing rate, contract rate
        InterestRate strikeForwardRate_;
        Real notionalAmount_;
        ext::shared_ptr<IborIndex> index_;
        bool useIndexedCoupon_;

      private:
        void calculateForwardRate() const;
    };

}


#endif

]]></document_content>
  </document>
  <document index="65">
    <source>forwardvanillaoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/forwardvanillaoption.hpp>

namespace QuantLib {

    ForwardVanillaOption::ForwardVanillaOption(
                           Real moneyness,
                           const Date& resetDate,
                           const ext::shared_ptr<StrikedTypePayoff>& payoff,
                           const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise),
      moneyness_(moneyness), resetDate_(resetDate) {}

    void ForwardVanillaOption::setupArguments(
                                       PricingEngine::arguments* args) const {
        OneAssetOption::setupArguments(args);
        auto* arguments = dynamic_cast<ForwardVanillaOption::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->moneyness = moneyness_;
        arguments->resetDate = resetDate_;

    }

    void ForwardVanillaOption::fetchResults(
                                      const PricingEngine::results* r) const {
        OneAssetOption::fetchResults(r);
        const auto* results = dynamic_cast<const ForwardVanillaOption::results*>(r);
        QL_ENSURE(results != nullptr, "no results returned from pricing engine");
        delta_       = results->delta;
        gamma_       = results->gamma;
        theta_       = results->theta;
        vega_        = results->vega;
        rho_         = results->rho;
        dividendRho_ = results->dividendRho;
    }

}

]]></document_content>
  </document>
  <document index="66">
    <source>forwardvanillaoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file forwardvanillaoption.hpp
    \brief Forward version of a vanilla option
*/

#ifndef quantlib_forward_vanilla_option_hpp
#define quantlib_forward_vanilla_option_hpp

#include <ql/instruments/oneassetoption.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/exercise.hpp>
#include <ql/settings.hpp>

namespace QuantLib {

    //! %Arguments for forward (strike-resetting) option calculation
    template <class ArgumentsType>
    class ForwardOptionArguments : public ArgumentsType {
      public:
        ForwardOptionArguments() : moneyness(Null<Real>()),
                                   resetDate(Null<Date>()) {}
        void validate() const override;
        Real moneyness;
        Date resetDate;
    };

    //! %Forward version of a vanilla option
    /*! \ingroup instruments */
    class ForwardVanillaOption : public OneAssetOption {
      public:
        typedef ForwardOptionArguments<OneAssetOption::arguments> arguments;
        typedef OneAssetOption::results results;
        ForwardVanillaOption(Real moneyness,
                             const Date& resetDate,
                             const ext::shared_ptr<StrikedTypePayoff>& payoff,
                             const ext::shared_ptr<Exercise>& exercise);
        void setupArguments(PricingEngine::arguments*) const override;
        void fetchResults(const PricingEngine::results*) const override;

      private:
        // arguments
        Real moneyness_;
        Date resetDate_;
    };


    // template definitions

    template <class ArgumentsType>
    inline void ForwardOptionArguments<ArgumentsType>::validate() const {
        ArgumentsType::validate();

        QL_REQUIRE(moneyness != Null<Real>(), "null moneyness given");
        QL_REQUIRE(moneyness > 0.0, "negative or zero moneyness given");

        QL_REQUIRE(resetDate != Null<Date>(), "null reset date given");
        QL_REQUIRE(resetDate >= Settings::instance().evaluationDate(),
                   "reset date in the past");
        QL_REQUIRE(this->exercise->lastDate() > resetDate,
                   "reset date later or equal to maturity");
    }


}


#endif

]]></document_content>
  </document>
  <document index="67">
    <source>futures.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
Copyright (C) 2015 Ferdinando Ametrano
Copyright (C) 2015 Maddalena Zanzi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/futures.hpp>
#include <ql/types.hpp>
#include <ql/errors.hpp>

namespace QuantLib {

    std::ostream& operator<<(std::ostream& out, Futures::Type f) {
        switch (f) {
          case Futures::IMM:
            return out << "IMM";
          case Futures::ASX:
            return out << "ASX";
          default:
            QL_FAIL("unknown futures type (" << Integer(f) << ")");
        }
    }

}
]]></document_content>
  </document>
  <document index="68">
    <source>futures.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2015 Ferdinando Ametrano
 Copyright (C) 2015 Maddalena Zanzi

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file futures.hpp
    \brief Futures
*/

#ifndef quantlib_futures_hpp
#define quantlib_futures_hpp

#include <ql/qldefines.hpp>
#include <iosfwd>

namespace QuantLib {

    struct Futures {
        //! Futures type enumeration
        /*! These conventions specify the kind of futures type. */
        enum Type {
            IMM, /*!< Chicago Mercantile Internation Money Market, i.e.
                      third Wednesday of March, June, September, December */
            ASX  /*!< Australian Security Exchange, i.e. second Friday
                      of March, June, September, December */
        };
    };

    /*! \relates Futures */
    std::ostream& operator<<(std::ostream&, Futures::Type);

}

#endif
]]></document_content>
  </document>
  <document index="69">
    <source>impliedvolatility.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/impliedvolatility.hpp>
#include <ql/termstructures/volatility/equityfx/blackconstantvol.hpp>
#include <ql/math/solvers1d/brent.hpp>

namespace QuantLib {

    namespace {

        class PriceError {
          public:
            PriceError(const PricingEngine& engine,
                       SimpleQuote& vol,
                       Real targetValue);
            Real operator()(Volatility x) const;
          private:
            const PricingEngine& engine_;
            SimpleQuote& vol_;
            Real targetValue_;
            const Instrument::results* results_;
        };

        PriceError::PriceError(const PricingEngine& engine,
                               SimpleQuote& vol,
                               Real targetValue)
        : engine_(engine), vol_(vol), targetValue_(targetValue) {
            results_ =
                dynamic_cast<const Instrument::results*>(engine_.getResults());
            QL_REQUIRE(results_ != nullptr, "pricing engine does not supply needed results");
        }

        Real PriceError::operator()(Volatility x) const {
            vol_.setValue(x);
            engine_.calculate();
            return results_->value-targetValue_;
        }

    }


    namespace detail {

        Volatility ImpliedVolatilityHelper::calculate(
                                                 const Instrument& instrument,
                                                 const PricingEngine& engine,
                                                 SimpleQuote& volQuote,
                                                 Real targetValue,
                                                 Real accuracy,
                                                 Natural maxEvaluations,
                                                 Volatility minVol,
                                                 Volatility maxVol) {

            instrument.setupArguments(engine.getArguments());
            engine.getArguments()->validate();

            PriceError f(engine, volQuote, targetValue);
            Brent solver;
            solver.setMaxEvaluations(maxEvaluations);
            Volatility guess = (minVol+maxVol)/2.0;
            Volatility result = solver.solve(f, accuracy, guess,
                                             minVol, maxVol);
            return result;
        }

        ext::shared_ptr<GeneralizedBlackScholesProcess>
        ImpliedVolatilityHelper::clone(
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             const ext::shared_ptr<SimpleQuote>& volQuote) {

            Handle<Quote> stateVariable = process->stateVariable();
            Handle<YieldTermStructure> dividendYield = process->dividendYield();
            Handle<YieldTermStructure> riskFreeRate = process->riskFreeRate();

            Handle<BlackVolTermStructure> blackVol = process->blackVolatility();
            Handle<BlackVolTermStructure> volatility(
                ext::shared_ptr<BlackVolTermStructure>(
                               new BlackConstantVol(blackVol->referenceDate(),
                                                    blackVol->calendar(),
                                                    Handle<Quote>(volQuote),
                                                    blackVol->dayCounter())));

            return ext::make_shared<GeneralizedBlackScholesProcess>(
                stateVariable, dividendYield,
                                                   riskFreeRate, volatility);
        }

    }

}
]]></document_content>
  </document>
  <document index="70">
    <source>impliedvolatility.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file impliedvolatility.hpp
    \brief Utilities for implied-volatility calculation
*/

#ifndef quantlib_implied_volatility_hpp
#define quantlib_implied_volatility_hpp

#include <ql/instrument.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/processes/blackscholesprocess.hpp>

namespace QuantLib {

    namespace detail {

        //! helper class for one-asset implied-volatility calculation
        /*! The passed engine must be linked to the passed quote (see,
             e.g., VanillaOption to see how this can be achieved.)

             \note this function is meant for developers of option
                   classes so that they can implement an
                   impliedVolatility() method.
        */
        class ImpliedVolatilityHelper {
          public:
            static Volatility calculate(const Instrument& instrument,
                                        const PricingEngine& engine,
                                        SimpleQuote& volQuote,
                                        Real targetValue,
                                        Real accuracy,
                                        Natural maxEvaluations,
                                        Volatility minVol,
                                        Volatility maxVol);
            // utilities

            /*! The returned process is equal to the passed one, except
                for the volatility which is flat and whose value is driven
                by the passed quote.
            */
            static ext::shared_ptr<GeneralizedBlackScholesProcess> clone(
                     const ext::shared_ptr<GeneralizedBlackScholesProcess>&,
                     const ext::shared_ptr<SimpleQuote>&);
        };

    }

}

#endif
]]></document_content>
  </document>
  <document index="71">
    <source>inflationcapfloor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/cashflows/cashflows.hpp>
#include <ql/instruments/inflationcapfloor.hpp>
#include <ql/math/solvers1d/newtonsafe.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/utilities/dataformatters.hpp>
#include <utility>

namespace QuantLib {


    std::ostream& operator<<(std::ostream& out,
                             YoYInflationCapFloor::Type t) {
        switch (t) {
            case YoYInflationCapFloor::Cap:
                return out << "YoYInflationCap";
            case YoYInflationCapFloor::Floor:
                return out << "YoYInflationFloor";
            case YoYInflationCapFloor::Collar:
                return out << "YoYInflationCollar";
            default:
                QL_FAIL("unknown YoYInflationCapFloor::Type (" << Integer(t) << ")");
        }
    }

    YoYInflationCapFloor::YoYInflationCapFloor(YoYInflationCapFloor::Type type,
                                               Leg yoyLeg,
                                               std::vector<Rate> capRates,
                                               std::vector<Rate> floorRates)
    : type_(type), yoyLeg_(std::move(yoyLeg)), capRates_(std::move(capRates)),
      floorRates_(std::move(floorRates)) {
        if (type_ == Cap || type_ == Collar) {
            QL_REQUIRE(!capRates_.empty(), "no cap rates given");
            capRates_.reserve(yoyLeg_.size());
            while (capRates_.size() < yoyLeg_.size())
                capRates_.push_back(capRates_.back());
        }
        if (type_ == Floor || type_ == Collar) {
            QL_REQUIRE(!floorRates_.empty(), "no floor rates given");
            floorRates_.reserve(yoyLeg_.size());
            while (floorRates_.size() < yoyLeg_.size())
                floorRates_.push_back(floorRates_.back());
        }
        Leg::const_iterator i;
        for (i = yoyLeg_.begin(); i != yoyLeg_.end(); ++i)
            registerWith(*i);

        registerWith(Settings::instance().evaluationDate());
    }

    YoYInflationCapFloor::YoYInflationCapFloor(YoYInflationCapFloor::Type type,
                                               Leg yoyLeg,
                                               const std::vector<Rate>& strikes)
    : type_(type), yoyLeg_(std::move(yoyLeg)) {
        QL_REQUIRE(!strikes.empty(), "no strikes given");
        if (type_ == Cap) {
            capRates_ = strikes;
            capRates_.reserve(yoyLeg_.size());
            while (capRates_.size() < yoyLeg_.size())
                capRates_.push_back(capRates_.back());
        } else if (type_ == Floor) {
            floorRates_ = strikes;
            floorRates_.reserve(yoyLeg_.size());
            while (floorRates_.size() < yoyLeg_.size())
                floorRates_.push_back(floorRates_.back());
        } else
            QL_FAIL("only Cap/Floor types allowed in this constructor");

        Leg::const_iterator i;
        for (i = yoyLeg_.begin(); i != yoyLeg_.end(); ++i)
            registerWith(*i);

        registerWith(Settings::instance().evaluationDate());
    }

    bool YoYInflationCapFloor::isExpired() const {
        for (Size i=yoyLeg_.size(); i>0; --i)
            if (!yoyLeg_[i-1]->hasOccurred())
                return false;
        return true;
    }

    Date YoYInflationCapFloor::startDate() const {
        return CashFlows::startDate(yoyLeg_);
    }

    Date YoYInflationCapFloor::maturityDate() const {
        return CashFlows::maturityDate(yoyLeg_);
    }

    ext::shared_ptr<YoYInflationCoupon>
    YoYInflationCapFloor::lastYoYInflationCoupon() const {
        ext::shared_ptr<CashFlow> lastCF(yoyLeg_.back());
        ext::shared_ptr<YoYInflationCoupon> lastYoYInflationCoupon =
        ext::dynamic_pointer_cast<YoYInflationCoupon>(lastCF);
        return lastYoYInflationCoupon;
    }

    ext::shared_ptr<YoYInflationCapFloor> YoYInflationCapFloor::optionlet(const Size i) const {
        QL_REQUIRE(i < yoyLeg().size(),
                   io::ordinal(i+1) << " optionlet does not exist, only " <<
                   yoyLeg().size());
        Leg cf(1, yoyLeg()[i]);

        std::vector<Rate> cap, floor;
        if (type() == Cap || type() == Collar)
            cap.push_back(capRates()[i]);
        if (type() == Floor || type() == Collar)
            floor.push_back(floorRates()[i]);

        return ext::make_shared<YoYInflationCapFloor>(type(),
                                                    cf, cap, floor);
    }

    void YoYInflationCapFloor::setupArguments(PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<YoYInflationCapFloor::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        Size n = yoyLeg_.size();

        arguments->startDates.resize(n);
        arguments->fixingDates.resize(n);
        arguments->payDates.resize(n);
        arguments->accrualTimes.resize(n);
        arguments->nominals.resize(n);
        arguments->gearings.resize(n);
        arguments->capRates.resize(n);
        arguments->floorRates.resize(n);
        arguments->spreads.resize(n);

        arguments->type = type_;

        for (Size i=0; i<n; ++i) {
            ext::shared_ptr<YoYInflationCoupon> coupon =
            ext::dynamic_pointer_cast<YoYInflationCoupon>(
                                                            yoyLeg_[i]);
            QL_REQUIRE(coupon, "non-YoYInflationCoupon given");
            arguments->startDates[i] = coupon->accrualStartDate();
            arguments->fixingDates[i] = coupon->fixingDate();
            arguments->payDates[i] = coupon->date();

            // this is passed explicitly for precision
            arguments->accrualTimes[i] = coupon->accrualPeriod();

            arguments->nominals[i] = coupon->nominal();
            Spread spread = coupon->spread();
            Real gearing = coupon->gearing();
            arguments->gearings[i] = gearing;
            arguments->spreads[i] = spread;

            if (type_ == Cap || type_ == Collar)
                arguments->capRates[i] = (capRates_[i]-spread)/gearing;
            else
                arguments->capRates[i] = Null<Rate>();

            if (type_ == Floor || type_ == Collar)
                arguments->floorRates[i] = (floorRates_[i]-spread)/gearing;
            else
                arguments->floorRates[i] = Null<Rate>();
        }
    }

    void YoYInflationCapFloor::arguments::validate() const {
        QL_REQUIRE(payDates.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of pay dates ("
                   << payDates.size() << ")");
        QL_REQUIRE(accrualTimes.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of accrual times ("
                   << accrualTimes.size() << ")");
        QL_REQUIRE(type == YoYInflationCapFloor::Floor ||
                   capRates.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of cap rates ("
                   << capRates.size() << ")");
        QL_REQUIRE(type == YoYInflationCapFloor::Cap ||
                   floorRates.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of floor rates ("
                   << floorRates.size() << ")");
        QL_REQUIRE(gearings.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of gearings ("
                   << gearings.size() << ")");
        QL_REQUIRE(spreads.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of spreads ("
                   << spreads.size() << ")");
        QL_REQUIRE(nominals.size() == startDates.size(),
                   "number of start dates (" << startDates.size()
                   << ") different from that of nominals ("
                   << nominals.size() << ")");
    }

    Rate YoYInflationCapFloor::atmRate(const YieldTermStructure& discountCurve) const {
        return CashFlows::atmRate(yoyLeg_, discountCurve,
                                  false, discountCurve.referenceDate());
    }


}
]]></document_content>
  </document>
  <document index="72">
    <source>inflationcapfloor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

/*! \file capfloor.hpp
 \brief inflation cap and floor class, just year-on-year variety for now
 */

#ifndef quantlib_instruments_inflationcapfloor_hpp
#define quantlib_instruments_inflationcapfloor_hpp

#include <ql/instrument.hpp>
#include <ql/cashflows/yoyinflationcoupon.hpp>
#include <ql/handle.hpp>

namespace QuantLib {

    class YieldTermStructure;

    //! Base class for yoy inflation cap-like instruments
    /*! \ingroup instruments

        Note that the standard YoY inflation cap/floor defined here is
        different from nominal, because in nominal world standard
        cap/floors do not have the first optionlet.  This is because
        they set in advance so there is no point.  However, yoy
        inflation generally sets (effectively) in arrears, (actually
        in arrears vs lag of a few months) thus the first optionlet is
        relevant.  Hence we can do a parity test without a special
        definition of the YoY cap/floor instrument.

        \test
        - the relationship between the values of caps, floors and the
          resulting collars is checked.
        - the put-call parity between the values of caps, floors and
          swaps is checked.
        - the correctness of the returned value is tested by checking
          it against a known good value.
     */
    class YoYInflationCapFloor : public Instrument {
      public:
        enum Type { Cap, Floor, Collar };
        class arguments;
        class engine;
        YoYInflationCapFloor(Type type,
                             Leg yoyLeg,
                             std::vector<Rate> capRates,
                             std::vector<Rate> floorRates);
        YoYInflationCapFloor(Type type, Leg yoyLeg, const std::vector<Rate>& strikes);
        //! \name Instrument interface
        //@{
        bool isExpired() const override;
        void setupArguments(PricingEngine::arguments*) const override;
        //@}
        //! \name Inspectors
        //@{
        Type type() const { return type_; }
        const std::vector<Rate>& capRates() const { return capRates_; }
        const std::vector<Rate>& floorRates() const { return floorRates_; }
        const Leg& yoyLeg() const { return yoyLeg_; }

        Date startDate() const;
        Date maturityDate() const;
        ext::shared_ptr<YoYInflationCoupon> lastYoYInflationCoupon() const;
        //! Returns the n-th optionlet as a cap/floor with only one cash flow.
        ext::shared_ptr<YoYInflationCapFloor> optionlet(Size n) const;
        //@}
        virtual Rate atmRate(const YieldTermStructure& discountCurve) const;
        //! implied term volatility
        virtual Volatility impliedVolatility(
                            Real price,
                            const Handle<YoYInflationTermStructure>& yoyCurve,
                            Volatility guess,
                            Real accuracy = 1.0e-4,
                            Natural maxEvaluations = 100,
                            Volatility minVol = 1.0e-7,
                            Volatility maxVol = 4.0) const;
      private:
        Type type_;
        Leg yoyLeg_;
        std::vector<Rate> capRates_;
        std::vector<Rate> floorRates_;
    };

    //! Concrete YoY Inflation cap class
    /*! \ingroup instruments */
    class YoYInflationCap : public YoYInflationCapFloor {
      public:
        YoYInflationCap(const Leg& yoyLeg,
            const std::vector<Rate>& exerciseRates)
        : YoYInflationCapFloor(YoYInflationCapFloor::Cap, yoyLeg,
                   exerciseRates, std::vector<Rate>()) {}
    };

    //! Concrete YoY Inflation floor class
    /*! \ingroup instruments */
    class YoYInflationFloor : public YoYInflationCapFloor {
      public:
        YoYInflationFloor(const Leg& yoyLeg,
              const std::vector<Rate>& exerciseRates)
        : YoYInflationCapFloor(YoYInflationCapFloor::Floor, yoyLeg,
                   std::vector<Rate>(), exerciseRates) {}
    };

    //! Concrete YoY Inflation collar class
    /*! \ingroup instruments */
    class YoYInflationCollar : public YoYInflationCapFloor {
      public:
        YoYInflationCollar(const Leg& yoyLeg,
               const std::vector<Rate>& capRates,
               const std::vector<Rate>& floorRates)
        : YoYInflationCapFloor(YoYInflationCapFloor::Collar, yoyLeg,
                               capRates, floorRates) {}
    };


    //! %Arguments for YoY Inflation cap/floor calculation
    class YoYInflationCapFloor::arguments
        : public virtual PricingEngine::arguments {
      public:
        arguments() : type(YoYInflationCapFloor::Type(-1)) {}
        YoYInflationCapFloor::Type type;
        ext::shared_ptr<YoYInflationIndex> index;
        Period observationLag;
        std::vector<Date> startDates;
        std::vector<Date> fixingDates;
        std::vector<Date> payDates;
        std::vector<Time> accrualTimes;
        std::vector<Rate> capRates;
        std::vector<Rate> floorRates;
        std::vector<Real> gearings;
        std::vector<Real> spreads;
        std::vector<Real> nominals;
        void validate() const override;
    };

    //! base class for cap/floor engines
    class YoYInflationCapFloor::engine
    : public GenericEngine<YoYInflationCapFloor::arguments,
                           YoYInflationCapFloor::results> {};

    std::ostream& operator<<(std::ostream&, YoYInflationCapFloor::Type);

    // inline

    inline Volatility YoYInflationCapFloor::impliedVolatility(
                            Real,
                            const Handle<YoYInflationTermStructure>&,
                            Volatility,
                            Real,
                            Natural,
                            Volatility,
                            Volatility) const {
            QL_FAIL("not implemented yet");
        }

}

#endif
]]></document_content>
  </document>
  <document index="73">
    <source>lookbackoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/lookbackoption.hpp>

namespace QuantLib {

    ContinuousFloatingLookbackOption::ContinuousFloatingLookbackOption(
        Real minmax,
        const ext::shared_ptr<TypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise),
      minmax_(minmax) {}

    void ContinuousFloatingLookbackOption::setupArguments(
                                       PricingEngine::arguments* args) const {

        OneAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<ContinuousFloatingLookbackOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->minmax = minmax_;
    }

    void ContinuousFloatingLookbackOption::arguments::validate() const {

        OneAssetOption::arguments::validate();

        QL_REQUIRE(minmax != Null<Real>(), "null prior extremum");
        QL_REQUIRE(minmax >= 0.0, "nonnegative prior extremum required: "
                   << minmax << " not allowed");
    }


    ContinuousFixedLookbackOption::ContinuousFixedLookbackOption(
        Real minmax,
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise),
      minmax_(minmax) {}

    void ContinuousFixedLookbackOption::setupArguments(
                                       PricingEngine::arguments* args) const {

        OneAssetOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<ContinuousFixedLookbackOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->minmax = minmax_;
    }

    void ContinuousFixedLookbackOption::arguments::validate() const {

        OneAssetOption::arguments::validate();

        QL_REQUIRE(minmax != Null<Real>(), "null prior extremum");
        QL_REQUIRE(minmax >= 0.0, "nonnegative prior extremum required: "
                   << minmax << " not allowed");
    }

    ContinuousPartialFloatingLookbackOption::ContinuousPartialFloatingLookbackOption(
        Real minmax,
        Real lambda,
        Date lookbackPeriodEnd,
        const ext::shared_ptr<TypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : ContinuousFloatingLookbackOption(minmax, payoff, exercise),
      lambda_(lambda),
      lookbackPeriodEnd_(lookbackPeriodEnd) {}

    void ContinuousPartialFloatingLookbackOption::setupArguments(
                                       PricingEngine::arguments* args) const {

        ContinuousFloatingLookbackOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<ContinuousPartialFloatingLookbackOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->lambda = lambda_;
        moreArgs->lookbackPeriodEnd = lookbackPeriodEnd_;
    }

    void ContinuousPartialFloatingLookbackOption::arguments::validate() const {

        ContinuousFloatingLookbackOption::arguments::validate();

        ext::shared_ptr<EuropeanExercise> europeanExercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(exercise);
        QL_REQUIRE(lookbackPeriodEnd <= europeanExercise->lastDate(), 
            "lookback start date must be earlier than exercise date");
        
        ext::shared_ptr<FloatingTypePayoff> floatingTypePayoff =
            ext::dynamic_pointer_cast<FloatingTypePayoff>(payoff);
        
        if (floatingTypePayoff->optionType() == Option::Call) {
            QL_REQUIRE(lambda >= 1.0,
                       "lambda should be greater than or equal to 1 for calls");
        }
        if (floatingTypePayoff->optionType() == Option::Put) {
            QL_REQUIRE(lambda <= 1.0,
                       "lambda should be smaller than or equal to 1 for puts");
        }
    }

    ContinuousPartialFixedLookbackOption::ContinuousPartialFixedLookbackOption(
        Date lookbackPeriodStart,
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : ContinuousFixedLookbackOption(0, payoff, exercise),
      lookbackPeriodStart_(lookbackPeriodStart) {}

    void ContinuousPartialFixedLookbackOption::setupArguments(
                                       PricingEngine::arguments* args) const {

        ContinuousFixedLookbackOption::setupArguments(args);

        auto* moreArgs = dynamic_cast<ContinuousPartialFixedLookbackOption::arguments*>(args);
        QL_REQUIRE(moreArgs != nullptr, "wrong argument type");
        moreArgs->lookbackPeriodStart = lookbackPeriodStart_;
    }

    void ContinuousPartialFixedLookbackOption::arguments::validate() const {

        ContinuousFixedLookbackOption::arguments::validate();

        ext::shared_ptr<EuropeanExercise> europeanExercise =
            ext::dynamic_pointer_cast<EuropeanExercise>(exercise);
        QL_REQUIRE(lookbackPeriodStart <= europeanExercise->lastDate(), 
            "lookback start date must be earlier than exercise date");
    }
}

]]></document_content>
  </document>
  <document index="74">
    <source>lookbackoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2014 Francois Botha

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file lookbackoption.hpp
    \brief Lookback option on a single asset
*/

#ifndef quantlib_lookback_option_hpp
#define quantlib_lookback_option_hpp

#include <ql/instruments/oneassetoption.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {

    //! Continuous-floating lookback option
    /*! \ingroup instruments */
    class ContinuousFloatingLookbackOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        ContinuousFloatingLookbackOption(
                          Real currentMinmax,
                          const ext::shared_ptr<TypePayoff>& payoff,
                          const ext::shared_ptr<Exercise>& exercise);
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        // arguments
        Real minmax_;
    };

    //! Continuous-fixed lookback option
    /*! \ingroup instruments */
    class ContinuousFixedLookbackOption : public OneAssetOption {
      public:
        class arguments;
        class engine;
        ContinuousFixedLookbackOption(
                          Real currentMinmax,
                          const ext::shared_ptr<StrikedTypePayoff>& payoff,
                          const ext::shared_ptr<Exercise>& exercise);
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        // arguments
        Real minmax_;
    };

    //! Continuous-partial-floating lookback option
    /*! From http://help.rmetrics.org/fExoticOptions/LookbackOptions.html :

        For a partial-time floating strike lookback option, the
        lookback period starts at time zero and ends at an arbitrary
        date before expiration. Except for the partial lookback
        period, the option is similar to a floating strike lookback
        option. The partial-time floating strike lookback option is
        cheaper than a similar standard floating strike lookback
        option. Partial-time floating strike lookback options can be
        priced analytically using a model introduced by Heynen and Kat
        (1994).

        \ingroup instruments
    */
    class ContinuousPartialFloatingLookbackOption : public ContinuousFloatingLookbackOption {
      public:
        class arguments;
        class engine;
        ContinuousPartialFloatingLookbackOption(
                          Real currentMinmax,
                          Real lambda,
                          Date lookbackPeriodEnd,
                          const ext::shared_ptr<TypePayoff>& payoff,
                          const ext::shared_ptr<Exercise>& exercise);
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        // arguments
        Real lambda_;
        Date lookbackPeriodEnd_;
    };

    //! Continuous-partial-fixed lookback option
    /*! From http://help.rmetrics.org/fExoticOptions/LookbackOptions.html :

        For a partial-time fixed strike lookback option, the lookback
        period starts at a predetermined date after the initialization
        date of the option.  The partial-time fixed strike lookback
        call option payoff is given by the difference between the
        maximum observed price of the underlying asset during the
        lookback period and the fixed strike price. The partial-time
        fixed strike lookback put option payoff is given by the
        difference between the fixed strike price and the minimum
        observed price of the underlying asset during the lookback
        period. The partial-time fixed strike lookback option is
        cheaper than a similar standard fixed strike lookback
        option. Partial-time fixed strike lookback options can be
        priced analytically using a model introduced by Heynen and Kat
        (1994).

        \ingroup instruments
    */
    class ContinuousPartialFixedLookbackOption : public ContinuousFixedLookbackOption {
      public:
        class arguments;
        class engine;
        ContinuousPartialFixedLookbackOption(
                          Date lookbackPeriodStart,
                          const ext::shared_ptr<StrikedTypePayoff>& payoff,
                          const ext::shared_ptr<Exercise>& exercise);
        void setupArguments(PricingEngine::arguments*) const override;

      protected:
        // arguments
        Date lookbackPeriodStart_;
    };

    //! %Arguments for continuous floating lookback option calculation
    class ContinuousFloatingLookbackOption::arguments
        : public OneAssetOption::arguments {
      public:
        Real minmax;
        void validate() const override;
    };

    //! %Arguments for continuous fixed lookback option calculation
    class ContinuousFixedLookbackOption::arguments
        : public OneAssetOption::arguments {
      public:
        Real minmax;
        void validate() const override;
    };

    //! %Arguments for continuous partial floating lookback option calculation
    class ContinuousPartialFloatingLookbackOption::arguments
        : public ContinuousFloatingLookbackOption::arguments {
      public:
        Real lambda;
        Date lookbackPeriodEnd;
        void validate() const override;
    };

    //! %Arguments for continuous partial fixed lookback option calculation
    class ContinuousPartialFixedLookbackOption::arguments
        : public ContinuousFixedLookbackOption::arguments {
      public:
        Date lookbackPeriodStart;
        void validate() const override;
    };

    //! %Continuous floating lookback %engine base class
    class ContinuousFloatingLookbackOption::engine
        : public GenericEngine<ContinuousFloatingLookbackOption::arguments,
                               ContinuousFloatingLookbackOption::results> {};

    //! %Continuous fixed lookback %engine base class
    class ContinuousFixedLookbackOption::engine
        : public GenericEngine<ContinuousFixedLookbackOption::arguments,
                               ContinuousFixedLookbackOption::results> {};

    //! %Continuous partial floating lookback %engine base class
    class ContinuousPartialFloatingLookbackOption::engine
        : public GenericEngine<ContinuousPartialFloatingLookbackOption::arguments,
                               ContinuousPartialFloatingLookbackOption::results> {};

    //! %Continuous partial fixed lookback %engine base class
    class ContinuousPartialFixedLookbackOption::engine
        : public GenericEngine<ContinuousPartialFixedLookbackOption::arguments,
                               ContinuousPartialFixedLookbackOption::results> {};
}


#endif
]]></document_content>
  </document>
  <document index="75">
    <source>makecapfloor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/makecapfloor.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/pricingengines/capfloor/blackcapfloorengine.hpp>

namespace QuantLib {

    MakeCapFloor::MakeCapFloor(CapFloor::Type capFloorType,
                               const Period& tenor,
                               const ext::shared_ptr<IborIndex>& iborIndex,
                               Rate strike,
                               const Period& forwardStart)
    : capFloorType_(capFloorType), strike_(strike),
      firstCapletExcluded_(forwardStart==0*Days), asOptionlet_(false),
      // setting the fixed leg tenor avoids that MakeVanillaSwap throws
      // because of an unknown fixed leg default tenor for a currency,
      // notice that only the floating leg of the swap is used anyway
      makeVanillaSwap_(MakeVanillaSwap(tenor, iborIndex, 0.0, forwardStart)
                       .withFixedLegTenor(1*Years).withFixedLegDayCount(Actual365Fixed())) {}

    MakeCapFloor::operator CapFloor() const {
        ext::shared_ptr<CapFloor> capfloor = *this;
        return *capfloor;
    }

    MakeCapFloor::operator ext::shared_ptr<CapFloor>() const {

        VanillaSwap swap = makeVanillaSwap_;

        Leg leg = swap.floatingLeg();
        if (firstCapletExcluded_)
            leg.erase(leg.begin());

        // only leaves the last coupon
        if (asOptionlet_ && leg.size() > 1) {
            auto end = leg.end(); // Sun Studio needs an lvalue
            leg.erase(leg.begin(), --end);
        }

        std::vector<Rate> strikeVector(1, strike_);
        if (strike_ == Null<Rate>()) {

            // temporary patch...
            // should be fixed for every CapFloor::Engine
            ext::shared_ptr<BlackCapFloorEngine> temp = 
                ext::dynamic_pointer_cast<BlackCapFloorEngine>(engine_);
            QL_REQUIRE(temp,
                       "cannot calculate ATM without a BlackCapFloorEngine");
            Handle<YieldTermStructure> discountCurve = temp->termStructure();
            strikeVector[0] = CashFlows::atmRate(leg,
                                                 **discountCurve,
                                                 false,
                                                 discountCurve->referenceDate());
        }

        ext::shared_ptr<CapFloor> capFloor(new
            CapFloor(capFloorType_, leg, strikeVector));
        capFloor->setPricingEngine(engine_);
        return capFloor;
    }

    MakeCapFloor& MakeCapFloor::withNominal(Real n) {
        makeVanillaSwap_.withNominal(n);
        return *this;
    }

    MakeCapFloor& MakeCapFloor::withEffectiveDate(const Date& effectiveDate,
                                                  bool firstCapletExcluded) {
        makeVanillaSwap_.withEffectiveDate(effectiveDate);
        firstCapletExcluded_ = firstCapletExcluded;
        return *this;
    }

    MakeCapFloor& MakeCapFloor::withTenor(const Period& t) {
        makeVanillaSwap_.withFloatingLegTenor(t);
        return *this;
    }


    MakeCapFloor& MakeCapFloor::withCalendar(const Calendar& cal) {
        makeVanillaSwap_.withFloatingLegCalendar(cal);
        return *this;
    }


    MakeCapFloor& MakeCapFloor::withConvention(BusinessDayConvention bdc) {
        makeVanillaSwap_.withFloatingLegConvention(bdc);
        return *this;
    }


    MakeCapFloor&
    MakeCapFloor::withTerminationDateConvention(BusinessDayConvention bdc) {
        makeVanillaSwap_.withFloatingLegTerminationDateConvention(bdc);
        return *this;
    }


    MakeCapFloor& MakeCapFloor::withRule(DateGeneration::Rule r) {
        makeVanillaSwap_.withFloatingLegRule(r);
        return *this;
    }

    MakeCapFloor& MakeCapFloor::withEndOfMonth(bool flag) {
        makeVanillaSwap_.withFloatingLegEndOfMonth(flag);
        return *this;
    }


    MakeCapFloor& MakeCapFloor::withFirstDate(const Date& d) {
        makeVanillaSwap_.withFloatingLegFirstDate(d);
        return *this;
    }

    MakeCapFloor& MakeCapFloor::withNextToLastDate(const Date& d) {
        makeVanillaSwap_.withFloatingLegNextToLastDate(d);
        return *this;
    }

    MakeCapFloor& MakeCapFloor::withDayCount(const DayCounter& dc) {
        makeVanillaSwap_.withFloatingLegDayCount(dc);
        return *this;
    }

    MakeCapFloor& MakeCapFloor::asOptionlet(bool b) {
        asOptionlet_ = b;
        return *this;
    }

    MakeCapFloor& MakeCapFloor::withPricingEngine(
                             const ext::shared_ptr<PricingEngine>& engine) {
        engine_ = engine;
        return *this;
    }

}

]]></document_content>
  </document>
  <document index="76">
    <source>makecapfloor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file makecapfloor.hpp
    \brief Helper class to instantiate standard market cap/floor.
*/

#ifndef quantlib_instruments_makecapfloor_hpp
#define quantlib_instruments_makecapfloor_hpp

#include <ql/instruments/capfloor.hpp>
#include <ql/instruments/makevanillaswap.hpp>

namespace QuantLib {

    //! helper class
    /*! This class provides a more comfortable way
        to instantiate standard market cap and floor.
    */
    class MakeCapFloor {
      public:
        MakeCapFloor(CapFloor::Type capFloorType,
                     const Period& capFloorTenor,
                     const ext::shared_ptr<IborIndex>& iborIndex,
                     Rate strike = Null<Rate>(),
                     const Period& forwardStart = 0*Days);

        operator CapFloor() const;
        operator ext::shared_ptr<CapFloor>() const;

        MakeCapFloor& withNominal(Real n);
        MakeCapFloor& withEffectiveDate(const Date& effectiveDate,
                                        bool firstCapletExcluded);
        MakeCapFloor& withTenor(const Period& t);
        MakeCapFloor& withCalendar(const Calendar& cal);
        MakeCapFloor& withConvention(BusinessDayConvention bdc);
        MakeCapFloor& withTerminationDateConvention(BusinessDayConvention bdc);
        MakeCapFloor& withRule(DateGeneration::Rule r);
        MakeCapFloor& withEndOfMonth(bool flag = true);
        MakeCapFloor& withFirstDate(const Date& d);
        MakeCapFloor& withNextToLastDate(const Date& d);
        MakeCapFloor& withDayCount(const DayCounter& dc);

        //! only get last coupon
        MakeCapFloor& asOptionlet(bool b = true);

        MakeCapFloor& withPricingEngine(
                              const ext::shared_ptr<PricingEngine>& engine);
      private:
        CapFloor::Type capFloorType_;
        Rate strike_;
        bool firstCapletExcluded_, asOptionlet_;

        MakeVanillaSwap makeVanillaSwap_;

        ext::shared_ptr<PricingEngine> engine_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="77">
    <source>makecds.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/makecds.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/calendars/weekendsonly.hpp>


namespace QuantLib {

    MakeCreditDefaultSwap::MakeCreditDefaultSwap(const Period &tenor,
                                                 const Real couponRate)
        : side_(Protection::Buyer), nominal_(1.0), tenor_(tenor),
          couponTenor_(3 * Months), couponRate_(couponRate), upfrontRate_(0.0),
          dayCounter_(Actual360()), lastPeriodDayCounter_(Actual360(true)),
          rule_(DateGeneration::CDS), cashSettlementDays_(3) {}

    MakeCreditDefaultSwap::MakeCreditDefaultSwap(const Date &termDate,
                                                 const Real couponRate)
        : side_(Protection::Buyer), nominal_(1.0), termDate_(termDate),
          couponTenor_(3 * Months), couponRate_(couponRate), upfrontRate_(0.0),
          dayCounter_(Actual360()), lastPeriodDayCounter_(Actual360(true)),
          rule_(DateGeneration::CDS), cashSettlementDays_(3) {}

    MakeCreditDefaultSwap::operator CreditDefaultSwap() const {
        ext::shared_ptr<CreditDefaultSwap> swap = *this;
        return *swap;
    }

    MakeCreditDefaultSwap::operator ext::shared_ptr<CreditDefaultSwap>() const {

        Date tradeDate = Settings::instance().evaluationDate();
        Date upfrontDate = WeekendsOnly().advance(tradeDate, cashSettlementDays_, Days);

        Date protectionStart;
        if (rule_ == DateGeneration::CDS2015 || rule_ == DateGeneration::CDS) {
            protectionStart = tradeDate;
        } else {
            protectionStart = tradeDate + 1;
        }

        Date end;
        if (tenor_) { // NOLINT(readability-implicit-bool-conversion)
            if (rule_ == DateGeneration::CDS2015 || rule_ == DateGeneration::CDS || rule_ == DateGeneration::OldCDS) {
                end = cdsMaturity(tradeDate, *tenor_, rule_);
            } else {
                end = tradeDate + *tenor_;
            }
        } else {
            end = *termDate_;
        }

        Schedule schedule(protectionStart, end, couponTenor_, WeekendsOnly(), Following,
                          Unadjusted, rule_, false);

        ext::shared_ptr<CreditDefaultSwap> cds =
            ext::shared_ptr<CreditDefaultSwap>(new CreditDefaultSwap(
                side_, nominal_, upfrontRate_, couponRate_, schedule, Following,
                dayCounter_, true, true, protectionStart, upfrontDate,
                ext::shared_ptr<Claim>(), lastPeriodDayCounter_, true, tradeDate, cashSettlementDays_));

        cds->setPricingEngine(engine_);
        return cds;

    }

    MakeCreditDefaultSwap &
    MakeCreditDefaultSwap::withUpfrontRate(Real upfrontRate) {
        upfrontRate_ = upfrontRate;
        return *this;
    }

    MakeCreditDefaultSwap &
    MakeCreditDefaultSwap::withSide(Protection::Side side) {
        side_ = side;
        return *this;
    }

    MakeCreditDefaultSwap &MakeCreditDefaultSwap::withNominal(Real nominal) {
        nominal_ = nominal;
        return *this;
    }

    MakeCreditDefaultSwap &
    MakeCreditDefaultSwap::withCouponTenor(Period couponTenor) {
        couponTenor_ = couponTenor;
        return *this;
    }

    MakeCreditDefaultSwap &
    MakeCreditDefaultSwap::withDayCounter(DayCounter &dayCounter) {
        dayCounter_ = dayCounter;
        return *this;
    }

    MakeCreditDefaultSwap &MakeCreditDefaultSwap::withLastPeriodDayCounter(
        DayCounter &lastPeriodDayCounter) {
        lastPeriodDayCounter_ = lastPeriodDayCounter;
        return *this;
    }

    MakeCreditDefaultSwap& MakeCreditDefaultSwap::withDateGenerationRule(DateGeneration::Rule rule) {
        rule_ = rule;
        return *this;
    }

    MakeCreditDefaultSwap& MakeCreditDefaultSwap::withCashSettlementDays(Natural cashSettlementDays) {
        cashSettlementDays_ = cashSettlementDays;
        return *this;
    }

    MakeCreditDefaultSwap &MakeCreditDefaultSwap::withPricingEngine(
        const ext::shared_ptr<PricingEngine> &engine) {
        engine_ = engine;
        return *this;
    }
}
]]></document_content>
  </document>
  <document index="78">
    <source>makecds.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Jose Aparicio
 Copyright (C) 2014 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file makecds.hpp
    \brief Helper class to instantiate standard market cds.
*/

#ifndef quantlib_makecds_hpp
#define quantlib_makecds_hpp

#include <ql/instruments/creditdefaultswap.hpp>
#include <boost/optional.hpp>

namespace QuantLib {

    //! helper class
    /*! This class provides a more comfortable way
        to instantiate standard cds.
    */
    class MakeCreditDefaultSwap {
      public:
        MakeCreditDefaultSwap(const Period& tenor, Real couponRate);
        MakeCreditDefaultSwap(const Date& termDate, Real couponRate);

        operator CreditDefaultSwap() const;
        operator ext::shared_ptr<CreditDefaultSwap>() const;

        MakeCreditDefaultSwap& withUpfrontRate(Real);
        MakeCreditDefaultSwap& withSide(Protection::Side);
        MakeCreditDefaultSwap& withNominal(Real);
        MakeCreditDefaultSwap& withCouponTenor(Period);
        MakeCreditDefaultSwap& withDayCounter(DayCounter&);
        MakeCreditDefaultSwap& withLastPeriodDayCounter(DayCounter&);
        MakeCreditDefaultSwap& withDateGenerationRule(DateGeneration::Rule rule);
        MakeCreditDefaultSwap& withCashSettlementDays(Natural cashSettlementDays);

        MakeCreditDefaultSwap& withPricingEngine(const ext::shared_ptr<PricingEngine>&);

      private:
        Protection::Side side_;
        Real nominal_;
        boost::optional<Period> tenor_;
        boost::optional<Date> termDate_;
        Period couponTenor_;
        Real couponRate_;
        Real upfrontRate_;
        DayCounter dayCounter_;
        DayCounter lastPeriodDayCounter_;
        DateGeneration::Rule rule_;
        Natural cashSettlementDays_;

        ext::shared_ptr<PricingEngine> engine_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="79">
    <source>makecms.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007, 2014 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/makecms.hpp>
#include <ql/instruments/swap.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/time/schedule.hpp>
#include <ql/time/daycounters/actual360.hpp>

namespace QuantLib {

    MakeCms::MakeCms(const Period& swapTenor,
                     const ext::shared_ptr<SwapIndex>& swapIndex,
                     const ext::shared_ptr<IborIndex>& iborIndex,
                     Spread iborSpread,
                     const Period& forwardStart)
    : swapTenor_(swapTenor), swapIndex_(swapIndex),
      iborIndex_(iborIndex), iborSpread_(iborSpread),
      useAtmSpread_(false), forwardStart_(forwardStart),

      cmsSpread_(0.0), cmsGearing_(1.0),
      cmsCap_(Null<Real>()), cmsFloor_(Null<Real>()),

      effectiveDate_(Date()),
      cmsCalendar_(swapIndex->fixingCalendar()),
      floatCalendar_(iborIndex->fixingCalendar()),
      payCms_(true), nominal_(1.0),
      cmsTenor_(3*Months), floatTenor_(iborIndex->tenor()),
      cmsConvention_(ModifiedFollowing),
      cmsTerminationDateConvention_(ModifiedFollowing),
      floatConvention_(iborIndex->businessDayConvention()),
      floatTerminationDateConvention_(iborIndex->businessDayConvention()),
      cmsRule_(DateGeneration::Backward), floatRule_(DateGeneration::Backward),
      cmsEndOfMonth_(false), floatEndOfMonth_(false),
      cmsFirstDate_(Date()), cmsNextToLastDate_(Date()),
      floatFirstDate_(Date()), floatNextToLastDate_(Date()),
      cmsDayCount_(Actual360()),
      floatDayCount_(iborIndex->dayCounter()),
      // arbitrary choice:
      //engine_(new DiscountingSwapEngine(iborIndex->termStructure())),
      engine_(new DiscountingSwapEngine(swapIndex->forwardingTermStructure())) {}


    MakeCms::MakeCms(const Period& swapTenor,
                     const ext::shared_ptr<SwapIndex>& swapIndex,
                     Spread iborSpread,
                     const Period& forwardStart)
    : swapTenor_(swapTenor), swapIndex_(swapIndex),
      iborIndex_(swapIndex->iborIndex()), iborSpread_(iborSpread),
      useAtmSpread_(false), forwardStart_(forwardStart),

      cmsSpread_(0.0), cmsGearing_(1.0),
      cmsCap_(Null<Real>()), cmsFloor_(Null<Real>()),

      effectiveDate_(Date()),
      cmsCalendar_(swapIndex->fixingCalendar()),
      floatCalendar_(iborIndex_->fixingCalendar()),
      payCms_(true), nominal_(1.0),
      cmsTenor_(3*Months), floatTenor_(iborIndex_->tenor()),
      cmsConvention_(ModifiedFollowing),
      cmsTerminationDateConvention_(ModifiedFollowing),
      floatConvention_(iborIndex_->businessDayConvention()),
      floatTerminationDateConvention_(iborIndex_->businessDayConvention()),
      cmsRule_(DateGeneration::Backward), floatRule_(DateGeneration::Backward),
      cmsEndOfMonth_(false), floatEndOfMonth_(false),
      cmsFirstDate_(Date()), cmsNextToLastDate_(Date()),
      floatFirstDate_(Date()), floatNextToLastDate_(Date()),
      cmsDayCount_(Actual360()),
      floatDayCount_(iborIndex_->dayCounter()),
      engine_(new DiscountingSwapEngine(swapIndex->forwardingTermStructure())) {}


    MakeCms::operator Swap() const {
        ext::shared_ptr<Swap> swap = *this;
        return *swap;
    }

    MakeCms::operator ext::shared_ptr<Swap>() const {

        Date startDate;
        if (effectiveDate_ != Date())
            startDate = effectiveDate_;
        else {
            Natural fixingDays = iborIndex_->fixingDays();
            Date refDate = Settings::instance().evaluationDate();
            // if the evaluation date is not a business day
            // then move to the next business day
            refDate = floatCalendar_.adjust(refDate);
            Date spotDate = floatCalendar_.advance(refDate,
                                                   fixingDays*Days);
            startDate = spotDate+forwardStart_;
        }

        Date terminationDate = startDate+swapTenor_;

        Schedule cmsSchedule(startDate, terminationDate,
                             cmsTenor_, cmsCalendar_,
                             cmsConvention_,
                             cmsTerminationDateConvention_,
                             cmsRule_, cmsEndOfMonth_,
                             cmsFirstDate_, cmsNextToLastDate_);

        Schedule floatSchedule(startDate, terminationDate,
                               floatTenor_, floatCalendar_,
                               floatConvention_,
                               floatTerminationDateConvention_,
                               floatRule_ , floatEndOfMonth_,
                               floatFirstDate_, floatNextToLastDate_);

        Leg cmsLeg = CmsLeg(cmsSchedule, swapIndex_)
            .withNotionals(nominal_)
            .withPaymentDayCounter(cmsDayCount_)
            .withPaymentAdjustment(cmsConvention_)
            .withFixingDays(swapIndex_->fixingDays())
            .withGearings(cmsGearing_)
            .withSpreads(cmsSpread_)
            .withCaps(cmsCap_)
            .withFloors(cmsFloor_);
        if (couponPricer_ != nullptr)
            setCouponPricer(cmsLeg, couponPricer_);

        Rate usedSpread = iborSpread_;
        if (useAtmSpread_) {
            QL_REQUIRE(!iborIndex_->forwardingTermStructure().empty(),
                       "null term structure set to this instance of " <<
                       iborIndex_->name());
            QL_REQUIRE(!swapIndex_->forwardingTermStructure().empty(),
                       "null term structure set to this instance of " <<
                       swapIndex_->name());
            QL_REQUIRE(couponPricer_,
                       "no CmsCouponPricer set (yet)");
            Leg floatLeg = IborLeg(floatSchedule, iborIndex_)
                .withNotionals(nominal_)
                .withPaymentDayCounter(floatDayCount_)
                .withPaymentAdjustment(floatConvention_)
                .withFixingDays(iborIndex_->fixingDays());

            Swap temp(cmsLeg, floatLeg);
            temp.setPricingEngine(engine_);

            Real npv = temp.legNPV(0)+temp.legNPV(1);

            usedSpread = -npv/temp.legBPS(1)*1e-4;
        } else {
            QL_REQUIRE(usedSpread != Null<Spread>(),
                       "null spread set");
        }

        Leg floatLeg = IborLeg(floatSchedule, iborIndex_)
            .withNotionals(nominal_)
            .withPaymentDayCounter(floatDayCount_)
            .withPaymentAdjustment(floatConvention_)
            .withFixingDays(iborIndex_->fixingDays())
            .withSpreads(usedSpread);

        ext::shared_ptr<Swap> swap;
        if (payCms_)
            swap = ext::make_shared<Swap>(cmsLeg, floatLeg);
        else
            swap = ext::make_shared<Swap>(floatLeg, cmsLeg);
        swap->setPricingEngine(engine_);
        return swap;
    }

    MakeCms& MakeCms::receiveCms(bool flag) {
        payCms_ = !flag;
        return *this;
    }

    MakeCms& MakeCms::withNominal(Real n) {
        nominal_ = n;
        return *this;
    }

    MakeCms&
    MakeCms::withEffectiveDate(const Date& effectiveDate) {
        effectiveDate_ = effectiveDate;
        return *this;
    }

    MakeCms& MakeCms::withDiscountingTermStructure(
                const Handle<YieldTermStructure>& discountingTermStructure) {
        engine_ = ext::make_shared<DiscountingSwapEngine>(discountingTermStructure);
        return *this;
    }

    MakeCms& MakeCms::withCmsCouponPricer(
                    const ext::shared_ptr<CmsCouponPricer>& couponPricer) {
        couponPricer_ = couponPricer;
        return *this;
    }

    MakeCms& MakeCms::withCmsLegTenor(const Period& t) {
        cmsTenor_ = t;
        return *this;
    }

    MakeCms&
    MakeCms::withCmsLegCalendar(const Calendar& cal) {
        cmsCalendar_ = cal;
        return *this;
    }

    MakeCms&
    MakeCms::withCmsLegConvention(BusinessDayConvention bdc) {
        cmsConvention_ = bdc;
        return *this;
    }

    MakeCms&
    MakeCms::withCmsLegTerminationDateConvention(BusinessDayConvention bdc) {
        cmsTerminationDateConvention_ = bdc;
        return *this;
    }

    MakeCms& MakeCms::withCmsLegRule(DateGeneration::Rule r) {
        cmsRule_ = r;
        return *this;
    }

    MakeCms& MakeCms::withCmsLegEndOfMonth(bool flag) {
        cmsEndOfMonth_ = flag;
        return *this;
    }

    MakeCms& MakeCms::withCmsLegFirstDate(const Date& d) {
        cmsFirstDate_ = d;
        return *this;
    }

    MakeCms&
    MakeCms::withCmsLegNextToLastDate(const Date& d) {
        cmsNextToLastDate_ = d;
        return *this;
    }

    MakeCms&
    MakeCms::withCmsLegDayCount(const DayCounter& dc) {
        cmsDayCount_ = dc;
        return *this;
    }

    MakeCms& MakeCms::withFloatingLegTenor(const Period& t) {
        floatTenor_ = t;
        return *this;
    }

    MakeCms&
    MakeCms::withFloatingLegCalendar(const Calendar& cal) {
        floatCalendar_ = cal;
        return *this;
    }

    MakeCms&
    MakeCms::withFloatingLegConvention(BusinessDayConvention bdc) {
        floatConvention_ = bdc;
        return *this;
    }

    MakeCms&
    MakeCms::withFloatingLegTerminationDateConvention(BusinessDayConvention bdc) {
        floatTerminationDateConvention_ = bdc;
        return *this;
    }

    MakeCms& MakeCms::withFloatingLegRule(DateGeneration::Rule r) {
        floatRule_ = r;
        return *this;
    }

    MakeCms& MakeCms::withFloatingLegEndOfMonth(bool flag) {
        floatEndOfMonth_ = flag;
        return *this;
    }

    MakeCms&
    MakeCms::withFloatingLegFirstDate(const Date& d) {
        floatFirstDate_ = d;
        return *this;
    }

    MakeCms&
    MakeCms::withFloatingLegNextToLastDate(const Date& d) {
        floatNextToLastDate_ = d;
        return *this;
    }

    MakeCms&
    MakeCms::withFloatingLegDayCount(const DayCounter& dc) {
        floatDayCount_ = dc;
        return *this;
    }

    MakeCms& MakeCms::withAtmSpread(bool flag) {
        useAtmSpread_ = flag;
        return *this;
    }

}
]]></document_content>
  </document>
  <document index="80">
    <source>makecms.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file makecms.hpp
    \brief Helper class to instantiate standard market CMS.
*/

#ifndef quantlib_makecms_hpp
#define quantlib_makecms_hpp

#include <ql/cashflows/cmscoupon.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/pricingengine.hpp>

namespace QuantLib {

    class Swap;
    class IborIndex;

    //! helper class for instantiating CMS
    /*! This class provides a more comfortable way
        to instantiate standard market constant maturity swap.
    */
    class MakeCms {
      public:
        MakeCms(const Period& swapTenor,
                const ext::shared_ptr<SwapIndex>& swapIndex,
                const ext::shared_ptr<IborIndex>& iborIndex,
                Spread iborSpread = 0.0,
                const Period& forwardStart = 0*Days);

        MakeCms(const Period& swapTenor,
                const ext::shared_ptr<SwapIndex>& swapIndex,
                Spread iborSpread = 0.0,
                const Period& forwardStart = 0*Days);

        operator Swap() const;
        operator ext::shared_ptr<Swap>() const ;

        MakeCms& receiveCms(bool flag = true);
        MakeCms& withNominal(Real n);
        MakeCms& withEffectiveDate(const Date&);

        MakeCms& withCmsLegTenor(const Period& t);
        MakeCms& withCmsLegCalendar(const Calendar& cal);
        MakeCms& withCmsLegConvention(BusinessDayConvention bdc);
        MakeCms& withCmsLegTerminationDateConvention(BusinessDayConvention);
        MakeCms& withCmsLegRule(DateGeneration::Rule r);
        MakeCms& withCmsLegEndOfMonth(bool flag = true);
        MakeCms& withCmsLegFirstDate(const Date& d);
        MakeCms& withCmsLegNextToLastDate(const Date& d);
        MakeCms& withCmsLegDayCount(const DayCounter& dc);

        MakeCms& withFloatingLegTenor(const Period& t);
        MakeCms& withFloatingLegCalendar(const Calendar& cal);
        MakeCms& withFloatingLegConvention(BusinessDayConvention bdc);
        MakeCms& withFloatingLegTerminationDateConvention(
                                                    BusinessDayConvention bdc);
        MakeCms& withFloatingLegRule(DateGeneration::Rule r);
        MakeCms& withFloatingLegEndOfMonth(bool flag = true);
        MakeCms& withFloatingLegFirstDate(const Date& d);
        MakeCms& withFloatingLegNextToLastDate(const Date& d);
        MakeCms& withFloatingLegDayCount(const DayCounter& dc);

        MakeCms& withAtmSpread(bool flag = true);

        MakeCms& withDiscountingTermStructure(
            const Handle<YieldTermStructure>& discountingTermStructure);
        MakeCms& withCmsCouponPricer(
            const ext::shared_ptr<CmsCouponPricer>& couponPricer);

      private:
        Period swapTenor_;
        ext::shared_ptr<SwapIndex> swapIndex_;
        ext::shared_ptr<IborIndex> iborIndex_;
        Spread iborSpread_;
        bool useAtmSpread_;
        Period forwardStart_;

        Spread cmsSpread_;
        Real cmsGearing_;
        Rate cmsCap_, cmsFloor_;

        Date effectiveDate_;
        Calendar cmsCalendar_, floatCalendar_;

        bool payCms_;
        Real nominal_;
        Period cmsTenor_, floatTenor_;
        BusinessDayConvention cmsConvention_, cmsTerminationDateConvention_;
        BusinessDayConvention floatConvention_, floatTerminationDateConvention_;
        DateGeneration::Rule cmsRule_, floatRule_;
        bool cmsEndOfMonth_, floatEndOfMonth_;
        Date cmsFirstDate_, cmsNextToLastDate_;
        Date floatFirstDate_, floatNextToLastDate_;
        DayCounter cmsDayCount_, floatDayCount_;

        ext::shared_ptr<PricingEngine> engine_;
        ext::shared_ptr<CmsCouponPricer> couponPricer_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="81">
    <source>makeois.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009, 2014, 2015 Ferdinando Ametrano
 Copyright (C) 2015 Paolo Mazzocchi
 Copyright (C) 2017 Joseph Jeisman
 Copyright (C) 2017 Fabrice Lecuyer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/makeois.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/time/schedule.hpp>

namespace QuantLib {

    MakeOIS::MakeOIS(const Period& swapTenor,
                     const ext::shared_ptr<OvernightIndex>& overnightIndex,
                     Rate fixedRate,
                     const Period& forwardStart)
    : swapTenor_(swapTenor), overnightIndex_(overnightIndex),
      fixedRate_(fixedRate), forwardStart_(forwardStart),
      settlementDays_(2),
      calendar_(overnightIndex->fixingCalendar()),
      paymentFrequency_(Annual),
      paymentCalendar_(Calendar()),
      paymentAdjustment_(Following),
      paymentLag_(0),
      rule_(DateGeneration::Backward),
      // any value here for endOfMonth_ would not be actually used
      isDefaultEOM_(true),
      type_(Swap::Payer), nominal_(1.0),
      overnightSpread_(0.0),
      fixedDayCount_(overnightIndex->dayCounter()), 
      telescopicValueDates_(false), 
      averagingMethod_(RateAveraging::Compound) {}

    MakeOIS::operator OvernightIndexedSwap() const {
        ext::shared_ptr<OvernightIndexedSwap> ois = *this;
        return *ois;
    }

    MakeOIS::operator ext::shared_ptr<OvernightIndexedSwap>() const {

        Date startDate;
        if (effectiveDate_ != Date())
            startDate = effectiveDate_;
        else {
            Date refDate = Settings::instance().evaluationDate();
            // if the evaluation date is not a business day
            // then move to the next business day
            refDate = calendar_.adjust(refDate);
            Date spotDate = calendar_.advance(refDate,
                                              settlementDays_*Days);
            startDate = spotDate+forwardStart_;
            if (forwardStart_.length()<0)
                startDate = calendar_.adjust(startDate, Preceding);
            else
                startDate = calendar_.adjust(startDate, Following);
        }

        // OIS end of month default
        bool usedEndOfMonth =
            isDefaultEOM_ ? calendar_.isEndOfMonth(startDate) : endOfMonth_;

        Date endDate = terminationDate_;
        if (endDate == Date()) {
            if (usedEndOfMonth)
                endDate = calendar_.advance(startDate,
                                            swapTenor_,
                                            ModifiedFollowing,
                                            usedEndOfMonth);
            else
                endDate = startDate + swapTenor_;
        }

        Schedule schedule(startDate, endDate,
                          Period(paymentFrequency_),
                          calendar_,
                          ModifiedFollowing,
                          ModifiedFollowing,
                          rule_,
                          usedEndOfMonth);

        Rate usedFixedRate = fixedRate_;
        if (fixedRate_ == Null<Rate>()) {
            OvernightIndexedSwap temp(type_, nominal_,
                                      schedule,
                                      0.0, // fixed rate
                                      fixedDayCount_,
                                      overnightIndex_, overnightSpread_,
                                      paymentLag_, paymentAdjustment_,
                                      paymentCalendar_, telescopicValueDates_);
            if (engine_ == nullptr) {
                Handle<YieldTermStructure> disc =
                                    overnightIndex_->forwardingTermStructure();
                QL_REQUIRE(!disc.empty(),
                           "null term structure set to this instance of " <<
                           overnightIndex_->name());
                bool includeSettlementDateFlows = false;
                ext::shared_ptr<PricingEngine> engine(new
                    DiscountingSwapEngine(disc, includeSettlementDateFlows));
                temp.setPricingEngine(engine);
            } else
                temp.setPricingEngine(engine_);

            usedFixedRate = temp.fairRate();
        }

        ext::shared_ptr<OvernightIndexedSwap> ois(new
            OvernightIndexedSwap(type_, nominal_,
                                 schedule,
                                 usedFixedRate, fixedDayCount_,
                                 overnightIndex_, overnightSpread_,
                                 paymentLag_, paymentAdjustment_,
                                 paymentCalendar_, telescopicValueDates_, 
                                 averagingMethod_));

        if (engine_ == nullptr) {
            Handle<YieldTermStructure> disc =
                                overnightIndex_->forwardingTermStructure();
            bool includeSettlementDateFlows = false;
            ext::shared_ptr<PricingEngine> engine(new
                DiscountingSwapEngine(disc, includeSettlementDateFlows));
            ois->setPricingEngine(engine);
        } else
            ois->setPricingEngine(engine_);

        return ois;
    }

    MakeOIS& MakeOIS::receiveFixed(bool flag) {
        type_ = flag ? Swap::Receiver : Swap::Payer ;
        return *this;
    }

    MakeOIS& MakeOIS::withType(Swap::Type type) {
        type_ = type;
        return *this;
    }

    MakeOIS& MakeOIS::withNominal(Real n) {
        nominal_ = n;
        return *this;
    }

    MakeOIS& MakeOIS::withSettlementDays(Natural settlementDays) {
        settlementDays_ = settlementDays;
        effectiveDate_ = Date();
        return *this;
    }

    MakeOIS& MakeOIS::withEffectiveDate(const Date& effectiveDate) {
        effectiveDate_ = effectiveDate;
        return *this;
    }

    MakeOIS& MakeOIS::withTerminationDate(const Date& terminationDate) {
        terminationDate_ = terminationDate;
        swapTenor_ = Period();
        return *this;
    }

    MakeOIS& MakeOIS::withPaymentFrequency(Frequency f) {
        paymentFrequency_ = f;
        if (paymentFrequency_==Once)
            rule_ = DateGeneration::Zero;
        return *this;
    }

    MakeOIS& MakeOIS::withPaymentAdjustment(BusinessDayConvention convention) {
        paymentAdjustment_ = convention;
        return *this;
    }

    MakeOIS& MakeOIS::withPaymentLag(Natural lag) {
        paymentLag_ = lag;
        return *this;
    }

    MakeOIS& MakeOIS::withPaymentCalendar(const Calendar& cal) {
        paymentCalendar_ = cal;
        return *this;
    }

    MakeOIS& MakeOIS::withRule(DateGeneration::Rule r) {
        rule_ = r;
        if (r==DateGeneration::Zero)
            paymentFrequency_ = Once;
        return *this;
    }

    MakeOIS& MakeOIS::withDiscountingTermStructure(
                                        const Handle<YieldTermStructure>& d) {
        bool includeSettlementDateFlows = false;
        engine_ = ext::shared_ptr<PricingEngine>(new
            DiscountingSwapEngine(d, includeSettlementDateFlows));
        return *this;
    }

    MakeOIS& MakeOIS::withPricingEngine(
                             const ext::shared_ptr<PricingEngine>& engine) {
        engine_ = engine;
        return *this;
    }

    MakeOIS& MakeOIS::withFixedLegDayCount(const DayCounter& dc) {
        fixedDayCount_ = dc;
        return *this;
    }

    MakeOIS& MakeOIS::withEndOfMonth(bool flag) {
        endOfMonth_ = flag;
        isDefaultEOM_ = false;
        return *this;
    }

    MakeOIS& MakeOIS::withOvernightLegSpread(Spread sp) {
        overnightSpread_ = sp;
        return *this;
    }

    MakeOIS& MakeOIS::withTelescopicValueDates(bool telescopicValueDates) {
        telescopicValueDates_ = telescopicValueDates;
        return *this;
    }

    MakeOIS& MakeOIS::withAveragingMethod(RateAveraging::Type averagingMethod) {
        averagingMethod_ = averagingMethod;
        return *this;
    }

}
]]></document_content>
  </document>
  <document index="82">
    <source>makeois.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Ferdinando Ametrano
 Copyright (C) 2017 Joseph Jeisman
 Copyright (C) 2017 Fabrice Lecuyer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file makeois.hpp
    \brief Helper class to instantiate overnight indexed swaps.
*/

#ifndef quantlib_makeois_hpp
#define quantlib_makeois_hpp

#include <ql/instruments/overnightindexedswap.hpp>
#include <ql/time/dategenerationrule.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>

namespace QuantLib {

    //! helper class
    /*! This class provides a more comfortable way
        to instantiate overnight indexed swaps.
    */
    class MakeOIS {
      public:
        MakeOIS(const Period& swapTenor,
                const ext::shared_ptr<OvernightIndex>& overnightIndex,
                Rate fixedRate = Null<Rate>(),
                const Period& fwdStart = 0*Days);

        operator OvernightIndexedSwap() const;
        operator ext::shared_ptr<OvernightIndexedSwap>() const ;

        MakeOIS& receiveFixed(bool flag = true);
        MakeOIS& withType(Swap::Type type);
        MakeOIS& withNominal(Real n);

        MakeOIS& withSettlementDays(Natural settlementDays);
        MakeOIS& withEffectiveDate(const Date&);
        MakeOIS& withTerminationDate(const Date&);
        MakeOIS& withRule(DateGeneration::Rule r);

        MakeOIS& withPaymentFrequency(Frequency f);
        MakeOIS& withPaymentAdjustment(BusinessDayConvention convention);
        MakeOIS& withPaymentLag(Natural lag);
        MakeOIS& withPaymentCalendar(const Calendar& cal);

        MakeOIS& withEndOfMonth(bool flag = true);

        MakeOIS& withFixedLegDayCount(const DayCounter& dc);

        MakeOIS& withOvernightLegSpread(Spread sp);

        MakeOIS& withDiscountingTermStructure(
                  const Handle<YieldTermStructure>& discountingTermStructure);

        MakeOIS &withTelescopicValueDates(bool telescopicValueDates);

        MakeOIS& withAveragingMethod(RateAveraging::Type averagingMethod);

        MakeOIS& withPricingEngine(
                              const ext::shared_ptr<PricingEngine>& engine);
      private:
        Period swapTenor_;
        ext::shared_ptr<OvernightIndex> overnightIndex_;
        Rate fixedRate_;
        Period forwardStart_;

        Natural settlementDays_;
        Date effectiveDate_, terminationDate_;
        Calendar calendar_;

        Frequency paymentFrequency_;
        Calendar paymentCalendar_;
        BusinessDayConvention paymentAdjustment_;
        Natural paymentLag_;

        DateGeneration::Rule rule_;
        bool endOfMonth_, isDefaultEOM_;

        Swap::Type type_;
        Real nominal_;

        Spread overnightSpread_;
        DayCounter fixedDayCount_;

        ext::shared_ptr<PricingEngine> engine_;

        bool telescopicValueDates_;
        RateAveraging::Type averagingMethod_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="83">
    <source>makeswaption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2008, 2014 Ferdinando Ametrano
 Copyright (C) 2007 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflows.hpp>
#include <ql/exercise.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/instruments/makeswaption.hpp>
#include <ql/instruments/makevanillaswap.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/settings.hpp>
#include <utility>

namespace QuantLib {

    MakeSwaption::MakeSwaption(ext::shared_ptr<SwapIndex> swapIndex,
                               const Period& optionTenor,
                               Rate strike)
    : swapIndex_(std::move(swapIndex)), delivery_(Settlement::Physical),
      settlementMethod_(Settlement::PhysicalOTC), optionTenor_(optionTenor),
      optionConvention_(ModifiedFollowing), fixingDate_(Null<Date>()), strike_(strike),
      underlyingType_(Swap::Payer), nominal_(1.0) {}

    MakeSwaption::MakeSwaption(ext::shared_ptr<SwapIndex> swapIndex,
                               const Date& fixingDate,
                               Rate strike)
    : swapIndex_(std::move(swapIndex)), delivery_(Settlement::Physical),
      settlementMethod_(Settlement::PhysicalOTC), optionConvention_(ModifiedFollowing),
      fixingDate_(fixingDate), strike_(strike), underlyingType_(Swap::Payer) {}

    MakeSwaption::operator Swaption() const {
        ext::shared_ptr<Swaption> swaption = *this;
        return *swaption;
    }

    MakeSwaption::operator ext::shared_ptr<Swaption>() const {

        const Calendar& fixingCalendar = swapIndex_->fixingCalendar();
        Date refDate = Settings::instance().evaluationDate();
        // if the evaluation date is not a business day
        // then move to the next business day
        refDate = fixingCalendar.adjust(refDate);
        if (fixingDate_ == Null<Date>())
            fixingDate_ = fixingCalendar.advance(refDate, optionTenor_,
                                                 optionConvention_);
        if (exerciseDate_ == Null<Date>()) {
            exercise_ = ext::shared_ptr<Exercise>(new
                EuropeanExercise(fixingDate_));
        } else {
            QL_REQUIRE(exerciseDate_ <= fixingDate_,
                       "exercise date (" << exerciseDate_ << ") must be less "
                       "than or equal to fixing date (" << fixingDate_ << ")");
            exercise_ = ext::shared_ptr<Exercise>(new
                EuropeanExercise(exerciseDate_));
        }

        Rate usedStrike = strike_;
        if (strike_ == Null<Rate>()) {
            // ATM on curve(s) attached to index
            QL_REQUIRE(!swapIndex_->forwardingTermStructure().empty(),
                       "null term structure set to this instance of " <<
                       swapIndex_->name());
            ext::shared_ptr<VanillaSwap> temp =
                swapIndex_->underlyingSwap(fixingDate_);
            temp->setPricingEngine(
                ext::shared_ptr<PricingEngine>(new DiscountingSwapEngine(
                    swapIndex_->exogenousDiscount()
                        ? swapIndex_->discountingTermStructure()
                        : swapIndex_->forwardingTermStructure(),
                    false)));
            usedStrike = temp->fairRate();
        }

        BusinessDayConvention bdc = swapIndex_->fixedLegConvention();
        underlyingSwap_ =
            MakeVanillaSwap(swapIndex_->tenor(),
                            swapIndex_->iborIndex(), usedStrike)
            .withEffectiveDate(swapIndex_->valueDate(fixingDate_))
            .withFixedLegCalendar(swapIndex_->fixingCalendar())
            .withFixedLegDayCount(swapIndex_->dayCounter())
            .withFixedLegTenor(swapIndex_->fixedLegTenor())
            .withFixedLegConvention(bdc)
            .withFixedLegTerminationDateConvention(bdc)
            .withType(underlyingType_)
            .withNominal(nominal_);

        ext::shared_ptr<Swaption> swaption(new Swaption(
            underlyingSwap_, exercise_, delivery_, settlementMethod_));
        swaption->setPricingEngine(engine_);
        return swaption;
    }

    MakeSwaption& MakeSwaption::withSettlementType(Settlement::Type delivery) {
        delivery_ = delivery;
        return *this;
    }

    MakeSwaption& MakeSwaption::withSettlementMethod(
        Settlement::Method settlementMethod) {
        settlementMethod_ = settlementMethod;
        return *this;
    }

    MakeSwaption&
    MakeSwaption::withOptionConvention(BusinessDayConvention bdc) {
        optionConvention_ = bdc;
        return *this;
    }

    MakeSwaption& MakeSwaption::withExerciseDate(const Date& date) {
        exerciseDate_ = date;
        return *this;
    }

    MakeSwaption& MakeSwaption::withUnderlyingType(const Swap::Type type) {
        underlyingType_ = type;
        return *this;
    }

    MakeSwaption& MakeSwaption::withPricingEngine(
                             const ext::shared_ptr<PricingEngine>& engine) {
        engine_ = engine;
        return *this;
    }

    MakeSwaption& MakeSwaption::withNominal(Real n) {
        nominal_ = n;
        return *this;
    }

}
]]></document_content>
  </document>
  <document index="84">
    <source>makeswaption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Ferdinando Ametrano
 Copyright (C) 2007 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file makeswaption.hpp
    \brief Helper class to instantiate standard market swaption.
*/

#ifndef quantlib_make_swaption_hpp
#define quantlib_make_swaption_hpp

#include <ql/time/businessdayconvention.hpp>
#include <ql/instruments/swaption.hpp>

namespace QuantLib {

    class SwapIndex;
    class Swap;
    class Calendar;
    class IborIndex;
    class Period;
    class PricingEngine;

    //! helper class
    /*! This class provides a more comfortable way
        to instantiate standard market swaption.
    */
    class MakeSwaption {
      public:
        MakeSwaption(ext::shared_ptr<SwapIndex> swapIndex,
                     const Period& optionTenor,
                     Rate strike = Null<Rate>());

        MakeSwaption(ext::shared_ptr<SwapIndex> swapIndex,
                     const Date& fixingDate,
                     Rate strike = Null<Rate>());

        operator Swaption() const;
        operator ext::shared_ptr<Swaption>() const ;

        MakeSwaption& withNominal(Real n);
        MakeSwaption& withSettlementType(Settlement::Type delivery);
        MakeSwaption& withSettlementMethod(Settlement::Method settlementMethod);
        MakeSwaption& withOptionConvention(BusinessDayConvention bdc);
        MakeSwaption& withExerciseDate(const Date&);
        MakeSwaption& withUnderlyingType(Swap::Type type);

        MakeSwaption& withPricingEngine(
                              const ext::shared_ptr<PricingEngine>& engine);
      private:
        ext::shared_ptr<SwapIndex> swapIndex_;
        Settlement::Type delivery_;
        Settlement::Method settlementMethod_;
        mutable ext::shared_ptr<VanillaSwap> underlyingSwap_;

        Period optionTenor_;
        BusinessDayConvention optionConvention_;
        mutable Date fixingDate_;
        Date exerciseDate_;
        mutable ext::shared_ptr<Exercise> exercise_;

        Rate strike_;
        Swap::Type underlyingType_;
        Real nominal_;

        ext::shared_ptr<PricingEngine> engine_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="85">
    <source>makevanillaswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007, 2010, 2014, 2015 Ferdinando Ametrano
 Copyright (C) 2006 Katiuscia Manzoni
 Copyright (C) 2006 StatPro Italia srl
 Copyright (C) 2015 Paolo Mazzocchi
 Copyright (C) 2018 Matthias Groncki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/makevanillaswap.hpp>
#include <ql/pricingengines/swap/discountingswapengine.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <ql/time/daycounters/actual360.hpp>
#include <ql/time/daycounters/actual365fixed.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/time/schedule.hpp>
#include <ql/currencies/america.hpp>
#include <ql/currencies/asia.hpp>
#include <ql/currencies/europe.hpp>
#include <ql/currencies/oceania.hpp>
#include <ql/utilities/null.hpp>

namespace QuantLib {

    MakeVanillaSwap::MakeVanillaSwap(const Period& swapTenor,
                                     const ext::shared_ptr<IborIndex>& index,
                                     Rate fixedRate,
                                     const Period& forwardStart)
    : swapTenor_(swapTenor), iborIndex_(index),
      fixedRate_(fixedRate), forwardStart_(forwardStart),
      settlementDays_(Null<Natural>()),
      fixedCalendar_(index->fixingCalendar()),
      floatCalendar_(index->fixingCalendar()),
      type_(Swap::Payer), nominal_(1.0),
      floatTenor_(index->tenor()),
      fixedConvention_(ModifiedFollowing),
      fixedTerminationDateConvention_(ModifiedFollowing),
      floatConvention_(index->businessDayConvention()),
      floatTerminationDateConvention_(index->businessDayConvention()),
      fixedRule_(DateGeneration::Backward), floatRule_(DateGeneration::Backward),
      fixedEndOfMonth_(false), floatEndOfMonth_(false),
      fixedFirstDate_(Date()), fixedNextToLastDate_(Date()),
      floatFirstDate_(Date()), floatNextToLastDate_(Date()),
      floatSpread_(0.0),
      floatDayCount_(index->dayCounter()) {}

    MakeVanillaSwap::operator VanillaSwap() const {
        ext::shared_ptr<VanillaSwap> swap = *this;
        return *swap;
    }

    MakeVanillaSwap::operator ext::shared_ptr<VanillaSwap>() const {

        Date startDate;
        if (effectiveDate_ != Date())
            startDate = effectiveDate_;
        else {
            Date refDate = Settings::instance().evaluationDate();
            // if the evaluation date is not a business day
            // then move to the next business day
            refDate = floatCalendar_.adjust(refDate);
            // use index valueDate interface wherever possible to estimate spot date.
            // Unless we pass an explicit settlementDays_ which does not match the index-defined number of fixing days.
            Date spotDate;
            if (settlementDays_ == Null<Natural>())
                spotDate = iborIndex_->valueDate(refDate);
            else
                spotDate = floatCalendar_.advance(refDate, settlementDays_ * Days);
            startDate = spotDate+forwardStart_;
            if (forwardStart_.length()<0)
                startDate = floatCalendar_.adjust(startDate,
                                                  Preceding);
            else if (forwardStart_.length()>0)
                startDate = floatCalendar_.adjust(startDate,
                                                  Following);
            // no explicit date adjustment needed for forwardStart_.length()==0 (already handled by spotDate arithmetic above)
        }

        Date endDate = terminationDate_;
        if (endDate == Date()) {
            if (floatEndOfMonth_)
                endDate = floatCalendar_.advance(startDate,
                                                 swapTenor_,
                                                 ModifiedFollowing,
                                                 floatEndOfMonth_);
            else
                endDate = startDate + swapTenor_;
        }

        const Currency& curr = iborIndex_->currency();
        Period fixedTenor;
        if (fixedTenor_ != Period())
            fixedTenor = fixedTenor_;
        else {
            if ((curr == EURCurrency()) ||
                (curr == USDCurrency()) ||
                (curr == CHFCurrency()) ||
                (curr == SEKCurrency()) ||
                (curr == GBPCurrency() && swapTenor_ <= 1 * Years))
                fixedTenor = Period(1, Years);
            else if ((curr == GBPCurrency() && swapTenor_ > 1 * Years) ||
                (curr == JPYCurrency()) ||
                (curr == AUDCurrency() && swapTenor_ >= 4 * Years))
                fixedTenor = Period(6, Months);
            else if ((curr == HKDCurrency() ||
                     (curr == AUDCurrency() && swapTenor_ < 4 * Years)))
                fixedTenor = Period(3, Months);
            else
                QL_FAIL("unknown fixed leg default tenor for " << curr);
        }

        Schedule fixedSchedule(startDate, endDate,
                               fixedTenor, fixedCalendar_,
                               fixedConvention_,
                               fixedTerminationDateConvention_,
                               fixedRule_, fixedEndOfMonth_,
                               fixedFirstDate_, fixedNextToLastDate_);

        Schedule floatSchedule(startDate, endDate,
                               floatTenor_, floatCalendar_,
                               floatConvention_,
                               floatTerminationDateConvention_,
                               floatRule_, floatEndOfMonth_,
                               floatFirstDate_, floatNextToLastDate_);

        DayCounter fixedDayCount;
        if (fixedDayCount_ != DayCounter())
            fixedDayCount = fixedDayCount_;
        else {
            if (curr == USDCurrency())
                fixedDayCount = Actual360();
            else if (curr == EURCurrency() || curr == CHFCurrency() ||
                     curr == SEKCurrency())
                fixedDayCount = Thirty360(Thirty360::BondBasis);
            else if (curr == GBPCurrency() || curr == JPYCurrency() ||
                     curr == AUDCurrency() || curr == HKDCurrency() ||
                     curr == THBCurrency())
                fixedDayCount = Actual365Fixed();
            else
                QL_FAIL("unknown fixed leg day counter for " << curr);
        }

        Rate usedFixedRate = fixedRate_;
        if (fixedRate_ == Null<Rate>()) {
            VanillaSwap temp(type_, 100.00,
                             fixedSchedule,
                             0.0, // fixed rate
                             fixedDayCount,
                             floatSchedule, iborIndex_,
                             floatSpread_, floatDayCount_);
            if (engine_ == nullptr) {
                Handle<YieldTermStructure> disc =
                                        iborIndex_->forwardingTermStructure();
                QL_REQUIRE(!disc.empty(),
                           "null term structure set to this instance of " <<
                           iborIndex_->name());
                bool includeSettlementDateFlows = false;
                ext::shared_ptr<PricingEngine> engine(new
                    DiscountingSwapEngine(disc, includeSettlementDateFlows));
                temp.setPricingEngine(engine);
            } else
                temp.setPricingEngine(engine_);

            usedFixedRate = temp.fairRate();
        }

        ext::shared_ptr<VanillaSwap> swap(new
            VanillaSwap(type_, nominal_,
                        fixedSchedule,
                        usedFixedRate, fixedDayCount,
                        floatSchedule,
                        iborIndex_, floatSpread_, floatDayCount_));

        if (engine_ == nullptr) {
            Handle<YieldTermStructure> disc =
                                    iborIndex_->forwardingTermStructure();
            bool includeSettlementDateFlows = false;
            ext::shared_ptr<PricingEngine> engine(new
                DiscountingSwapEngine(disc, includeSettlementDateFlows));
            swap->setPricingEngine(engine);
        } else
            swap->setPricingEngine(engine_);

        return swap;
    }

    MakeVanillaSwap& MakeVanillaSwap::receiveFixed(bool flag) {
        type_ = flag ? Swap::Receiver : Swap::Payer ;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withType(Swap::Type type) {
        type_ = type;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withNominal(Real n) {
        nominal_ = n;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withSettlementDays(Natural settlementDays) {
        settlementDays_ = settlementDays;
        effectiveDate_ = Date();
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withEffectiveDate(const Date& effectiveDate) {
        effectiveDate_ = effectiveDate;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withTerminationDate(const Date& terminationDate) {
        terminationDate_ = terminationDate;
        swapTenor_ = Period();
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withRule(DateGeneration::Rule r) {
        fixedRule_ = r;
        floatRule_ = r;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withDiscountingTermStructure(
                                        const Handle<YieldTermStructure>& d) {
        bool includeSettlementDateFlows = false;
        engine_ = ext::shared_ptr<PricingEngine>(new
            DiscountingSwapEngine(d, includeSettlementDateFlows));
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withPricingEngine(
                             const ext::shared_ptr<PricingEngine>& engine) {
        engine_ = engine;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withFixedLegTenor(const Period& t) {
        fixedTenor_ = t;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFixedLegCalendar(const Calendar& cal) {
        fixedCalendar_ = cal;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFixedLegConvention(BusinessDayConvention bdc) {
        fixedConvention_ = bdc;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFixedLegTerminationDateConvention(BusinessDayConvention bdc) {
        fixedTerminationDateConvention_ = bdc;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withFixedLegRule(DateGeneration::Rule r) {
        fixedRule_ = r;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withFixedLegEndOfMonth(bool flag) {
        fixedEndOfMonth_ = flag;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withFixedLegFirstDate(const Date& d) {
        fixedFirstDate_ = d;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFixedLegNextToLastDate(const Date& d) {
        fixedNextToLastDate_ = d;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFixedLegDayCount(const DayCounter& dc) {
        fixedDayCount_ = dc;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withFloatingLegTenor(const Period& t) {
        floatTenor_ = t;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFloatingLegCalendar(const Calendar& cal) {
        floatCalendar_ = cal;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFloatingLegConvention(BusinessDayConvention bdc) {
        floatConvention_ = bdc;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFloatingLegTerminationDateConvention(BusinessDayConvention bdc) {
        floatTerminationDateConvention_ = bdc;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withFloatingLegRule(DateGeneration::Rule r) {
        floatRule_ = r;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withFloatingLegEndOfMonth(bool flag) {
        floatEndOfMonth_ = flag;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFloatingLegFirstDate(const Date& d) {
        floatFirstDate_ = d;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFloatingLegNextToLastDate(const Date& d) {
        floatNextToLastDate_ = d;
        return *this;
    }

    MakeVanillaSwap&
    MakeVanillaSwap::withFloatingLegDayCount(const DayCounter& dc) {
        floatDayCount_ = dc;
        return *this;
    }

    MakeVanillaSwap& MakeVanillaSwap::withFloatingLegSpread(Spread sp) {
        floatSpread_ = sp;
        return *this;
    }

}
]]></document_content>
  </document>
  <document index="86">
    <source>makevanillaswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007, 2010 Ferdinando Ametrano
 Copyright (C) 2006 Katiuscia Manzoni
 Copyright (C) 2006 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file makevanillaswap.hpp
    \brief Helper class to instantiate standard market swaps.
*/

#ifndef quantlib_makevanillaswap_hpp
#define quantlib_makevanillaswap_hpp

#include <ql/instruments/vanillaswap.hpp>
#include <ql/time/dategenerationrule.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>

namespace QuantLib {

    //! helper class
    /*! This class provides a more comfortable way
        to instantiate standard market swap.
    */
    class MakeVanillaSwap {
      public:
        MakeVanillaSwap(const Period& swapTenor,
                        const ext::shared_ptr<IborIndex>& iborIndex,
                        Rate fixedRate = Null<Rate>(),
                        const Period& forwardStart = 0*Days);

        operator VanillaSwap() const;
        operator ext::shared_ptr<VanillaSwap>() const;

        MakeVanillaSwap& receiveFixed(bool flag = true);
        MakeVanillaSwap& withType(Swap::Type type);
        MakeVanillaSwap& withNominal(Real n);

        MakeVanillaSwap& withSettlementDays(Natural settlementDays);
        MakeVanillaSwap& withEffectiveDate(const Date&);
        MakeVanillaSwap& withTerminationDate(const Date&);
        MakeVanillaSwap& withRule(DateGeneration::Rule r);

        MakeVanillaSwap& withFixedLegTenor(const Period& t);
        MakeVanillaSwap& withFixedLegCalendar(const Calendar& cal);
        MakeVanillaSwap& withFixedLegConvention(BusinessDayConvention bdc);
        MakeVanillaSwap& withFixedLegTerminationDateConvention(
                                                   BusinessDayConvention bdc);
        MakeVanillaSwap& withFixedLegRule(DateGeneration::Rule r);
        MakeVanillaSwap& withFixedLegEndOfMonth(bool flag = true);
        MakeVanillaSwap& withFixedLegFirstDate(const Date& d);
        MakeVanillaSwap& withFixedLegNextToLastDate(const Date& d);
        MakeVanillaSwap& withFixedLegDayCount(const DayCounter& dc);

        MakeVanillaSwap& withFloatingLegTenor(const Period& t);
        MakeVanillaSwap& withFloatingLegCalendar(const Calendar& cal);
        MakeVanillaSwap& withFloatingLegConvention(BusinessDayConvention bdc);
        MakeVanillaSwap& withFloatingLegTerminationDateConvention(
                                                   BusinessDayConvention bdc);
        MakeVanillaSwap& withFloatingLegRule(DateGeneration::Rule r);
        MakeVanillaSwap& withFloatingLegEndOfMonth(bool flag = true);
        MakeVanillaSwap& withFloatingLegFirstDate(const Date& d);
        MakeVanillaSwap& withFloatingLegNextToLastDate(const Date& d);
        MakeVanillaSwap& withFloatingLegDayCount(const DayCounter& dc);
        MakeVanillaSwap& withFloatingLegSpread(Spread sp);

        MakeVanillaSwap& withDiscountingTermStructure(
                              const Handle<YieldTermStructure>& discountCurve);
        MakeVanillaSwap& withPricingEngine(
                              const ext::shared_ptr<PricingEngine>& engine);
      private:
        Period swapTenor_;
        ext::shared_ptr<IborIndex> iborIndex_;
        Rate fixedRate_;
        Period forwardStart_;

        Natural settlementDays_;
        Date effectiveDate_, terminationDate_;
        Calendar fixedCalendar_, floatCalendar_;

        Swap::Type type_;
        Real nominal_;
        Period fixedTenor_, floatTenor_;
        BusinessDayConvention fixedConvention_, fixedTerminationDateConvention_;
        BusinessDayConvention floatConvention_, floatTerminationDateConvention_;
        DateGeneration::Rule fixedRule_, floatRule_;
        bool fixedEndOfMonth_, floatEndOfMonth_;
        Date fixedFirstDate_, fixedNextToLastDate_;
        Date floatFirstDate_, floatNextToLastDate_;
        Spread floatSpread_;
        DayCounter fixedDayCount_, floatDayCount_;

        ext::shared_ptr<PricingEngine> engine_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="87">
    <source>makeyoyinflationcapfloor.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/cashflows/cashflows.hpp>
#include <ql/instruments/makeyoyinflationcapfloor.hpp>
#include <ql/time/daycounters/thirty360.hpp>
#include <utility>

namespace QuantLib {

    MakeYoYInflationCapFloor::MakeYoYInflationCapFloor(YoYInflationCapFloor::Type capFloorType,
                                                       ext::shared_ptr<YoYInflationIndex> index,
                                                       const Size& length,
                                                       Calendar cal,
                                                       const Period& observationLag)
    : capFloorType_(capFloorType), length_(length), calendar_(std::move(cal)),
      index_(std::move(index)), observationLag_(observationLag), strike_(Null<Rate>()),
      firstCapletExcluded_(false), asOptionlet_(false), effectiveDate_(Date()),
      dayCounter_(Thirty360(Thirty360::BondBasis)), roll_(ModifiedFollowing), fixingDays_(0), nominal_(1000000.0) {}

    MakeYoYInflationCapFloor::operator YoYInflationCapFloor() const {
        ext::shared_ptr<YoYInflationCapFloor> capfloor = *this;
        return *capfloor;
    }

    MakeYoYInflationCapFloor::operator ext::shared_ptr<YoYInflationCapFloor>() const {

        Date startDate;
        if (effectiveDate_ != Date()) {
            startDate = effectiveDate_;
        } else {
            Date referenceDate = Settings::instance().evaluationDate();
            Date spotDate = calendar_.advance(referenceDate,
                                              fixingDays_*Days);
            startDate = spotDate+forwardStart_;
        }

        Date endDate = calendar_.advance(startDate,length_*Years,Unadjusted);
        Schedule schedule(startDate, endDate, Period(Annual), calendar_,
                          Unadjusted, Unadjusted, // ref periods & acc periods
                          DateGeneration::Forward, false);
        Leg leg = yoyInflationLeg(schedule, calendar_, index_,
                                  observationLag_)
        .withPaymentAdjustment(roll_)
        .withPaymentDayCounter(dayCounter_)
        .withNotionals(nominal_)
        ;

        if (firstCapletExcluded_)
            leg.erase(leg.begin());

        // only leaves the last coupon
        if (asOptionlet_ && leg.size() > 1) {
            auto end = leg.end(); // Sun Studio needs an lvalue
            leg.erase(leg.begin(), --end);
        }

        std::vector<Rate> strikeVector(1, strike_);
        if (strike_ == Null<Rate>()) {
            // ATM on the forecasting curve
            Handle<YieldTermStructure> fc;
            if (!nominalTermStructure_.empty()) {
                fc = nominalTermStructure_;
            } else {
                QL_REQUIRE(!index_->yoyInflationTermStructure().empty(),
                           "no forecasting yoy term structure set for " <<
                           index_->name());
                fc = index_->yoyInflationTermStructure()->nominalTermStructure();
            }
            strikeVector[0] = CashFlows::atmRate(leg,**fc,
                                                 false, fc->referenceDate());
        }

        ext::shared_ptr<YoYInflationCapFloor> capFloor(new
                    YoYInflationCapFloor(capFloorType_, leg, strikeVector));
        capFloor->setPricingEngine(engine_);
        return capFloor;
    }

    MakeYoYInflationCapFloor& MakeYoYInflationCapFloor::withNominal(Real n) {
        nominal_ = n;
        return *this;
    }

    MakeYoYInflationCapFloor& MakeYoYInflationCapFloor::withEffectiveDate(
                                            const Date& effectiveDate) {
        effectiveDate_ = effectiveDate;
        return *this;
    }

    MakeYoYInflationCapFloor&
    MakeYoYInflationCapFloor::withPaymentAdjustment(BusinessDayConvention bdc) {
        roll_ = bdc;
        return *this;
    }

    MakeYoYInflationCapFloor&
    MakeYoYInflationCapFloor::withPaymentDayCounter(const DayCounter& dc) {
        dayCounter_ = dc;
        return *this;
    }

    MakeYoYInflationCapFloor&
    MakeYoYInflationCapFloor::withFixingDays(Natural n) {
        fixingDays_ = n;
        return *this;
    }

    MakeYoYInflationCapFloor& MakeYoYInflationCapFloor::asOptionlet(bool b) {
        asOptionlet_ = b;
        return *this;
    }

    MakeYoYInflationCapFloor& MakeYoYInflationCapFloor::withPricingEngine(
        const ext::shared_ptr<PricingEngine>& engine) {
        engine_ = engine;
        return *this;
    }

    MakeYoYInflationCapFloor&
    MakeYoYInflationCapFloor::withStrike(Rate strike) {
        QL_REQUIRE(nominalTermStructure_.empty(), "ATM strike already given");
        strike_ = strike;
        return *this;
    }

    MakeYoYInflationCapFloor&
    MakeYoYInflationCapFloor::withAtmStrike(
                      const Handle<YieldTermStructure>& nominalTermStructure) {
        QL_REQUIRE(strike_ == Null<Rate>(), "explicit strike already given");
        nominalTermStructure_ = nominalTermStructure;
        return *this;
    }

    MakeYoYInflationCapFloor&
    MakeYoYInflationCapFloor::withForwardStart(Period forwardStart) {
        forwardStart_ = forwardStart;
        return *this;
    }

}

]]></document_content>
  </document>
  <document index="88">
    <source>makeyoyinflationcapfloor.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2007 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2009 Chris Kenyon

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

/*! \file makecapfloor.hpp
 \brief Helper class to instantiate standard yoy inflation cap/floor.
 */

#ifndef quantlib_instruments_make_yoyinflation_capfloor_hpp
#define quantlib_instruments_make_yoyinflation_capfloor_hpp

#include <ql/instruments/inflationcapfloor.hpp>
#include <ql/instruments/makevanillaswap.hpp>

namespace QuantLib {

    //! helper class
    /*! This class provides a more comfortable way to instantiate
        standard yoy inflation cap and floor.
     */
    class MakeYoYInflationCapFloor {
      public:
        MakeYoYInflationCapFloor(YoYInflationCapFloor::Type capFloorType,
                                 ext::shared_ptr<YoYInflationIndex> index,
                                 const Size& length,
                                 Calendar cal,
                                 const Period& observationLag);
        MakeYoYInflationCapFloor& withNominal(Real n);
        MakeYoYInflationCapFloor& withEffectiveDate(const Date& effectiveDate);
        MakeYoYInflationCapFloor& withFirstCapletExcluded();
        MakeYoYInflationCapFloor& withPaymentDayCounter(const DayCounter&);
        MakeYoYInflationCapFloor& withPaymentAdjustment(BusinessDayConvention);
        MakeYoYInflationCapFloor& withFixingDays(Natural fixingDays);
        MakeYoYInflationCapFloor& withPricingEngine(
                const ext::shared_ptr<PricingEngine>& engine);
        //! only get last coupon
        MakeYoYInflationCapFloor& asOptionlet(bool b = true);
        MakeYoYInflationCapFloor& withStrike(Rate strike);
        MakeYoYInflationCapFloor& withAtmStrike(
                      const Handle<YieldTermStructure>& nominalTermStructure);
        MakeYoYInflationCapFloor& withForwardStart(Period forwardStart);

        operator YoYInflationCapFloor() const;
        operator ext::shared_ptr<YoYInflationCapFloor>() const ;

      private:
        YoYInflationCapFloor::Type capFloorType_;
        Size length_;
        Calendar calendar_;
        ext::shared_ptr<YoYInflationIndex> index_;
        Period observationLag_;
        Rate strike_;
        bool firstCapletExcluded_, asOptionlet_;
        Date effectiveDate_;
        Period forwardStart_;
        DayCounter dayCounter_;
        BusinessDayConvention roll_;
        Natural fixingDays_;
        Real nominal_;
        Handle<YieldTermStructure> nominalTermStructure_;

        ext::shared_ptr<PricingEngine> engine_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="89">
    <source>multiassetoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2004 Neil Firth
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/multiassetoption.hpp>
#include <ql/stochasticprocess.hpp>
#include <ql/exercise.hpp>
#include <ql/event.hpp>

namespace QuantLib {

    MultiAssetOption::MultiAssetOption(
        const ext::shared_ptr<Payoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : Option(payoff, exercise) {}

    bool MultiAssetOption::isExpired() const {
        return detail::simple_event(exercise_->lastDate()).hasOccurred();
    }

    Real MultiAssetOption::delta() const {
        calculate();
        QL_REQUIRE(delta_ != Null<Real>(), "delta not provided");
        return delta_;
    }

    Real MultiAssetOption::gamma() const {
        calculate();
        QL_REQUIRE(gamma_ != Null<Real>(), "gamma not provided");
        return gamma_;
    }

    Real MultiAssetOption::theta() const {
        calculate();
        QL_REQUIRE(theta_ != Null<Real>(), "theta not provided");
        return theta_;
    }

    Real MultiAssetOption::vega() const {
        calculate();
        QL_REQUIRE(vega_ != Null<Real>(), "vega not provided");
        return vega_;
    }

    Real MultiAssetOption::rho() const {
        calculate();
        QL_REQUIRE(rho_ != Null<Real>(), "rho not provided");
        return rho_;
    }

    Real MultiAssetOption::dividendRho() const {
        calculate();
        QL_REQUIRE(dividendRho_ != Null<Real>(), "dividend rho not provided");
        return dividendRho_;
    }

    void MultiAssetOption::setupExpired() const {
        NPV_ = delta_ = gamma_ = theta_ =
            vega_ = rho_ = dividendRho_ =  0.0;
    }

    void MultiAssetOption::setupArguments(
                                       PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<MultiAssetOption::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->payoff = payoff_;
        arguments->exercise = exercise_;
    }

    void MultiAssetOption::fetchResults(const PricingEngine::results* r) const {
        Option::fetchResults(r);
        const auto* results = dynamic_cast<const Greeks*>(r);
        QL_ENSURE(results != nullptr, "no greeks returned from pricing engine");
        delta_          = results->delta;
        gamma_          = results->gamma;
        theta_          = results->theta;
        vega_           = results->vega;
        rho_            = results->rho;
        dividendRho_    = results->dividendRho;
    }

}
]]></document_content>
  </document>
  <document index="90">
    <source>multiassetoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2004 Neil Firth
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file multiassetoption.hpp
    \brief Option on multiple assets
*/

#ifndef quantlib_multiasset_option_hpp
#define quantlib_multiasset_option_hpp

#include <ql/option.hpp>

namespace QuantLib {

    //! Base class for options on multiple assets
    class MultiAssetOption : public Option {
      public:
        class engine;
        class results;
        MultiAssetOption(const ext::shared_ptr<Payoff>&,
                         const ext::shared_ptr<Exercise>&);
        //! \name Instrument interface
        //@{
        bool isExpired() const override;
        //@}
        //! \name greeks
        //@{
        Real delta() const;
        Real gamma() const;
        Real theta() const;
        Real vega() const;
        Real rho() const;
        Real dividendRho() const;
        //@}
        void setupArguments(PricingEngine::arguments*) const override;
        void fetchResults(const PricingEngine::results*) const override;

      protected:
        void setupExpired() const override;
        // results
        mutable Real delta_,  gamma_, theta_,
            vega_, rho_, dividendRho_;
    };

    //! %Results from multi-asset option calculation
    class MultiAssetOption::results : public Instrument::results,
                                      public Greeks {
      public:
        void reset() override {
            Instrument::results::reset();
            Greeks::reset();
        }
    };

    class MultiAssetOption::engine :
        public GenericEngine<MultiAssetOption::arguments,
                             MultiAssetOption::results> {};

}


#endif

]]></document_content>
  </document>
  <document index="91">
    <source>nonstandardswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2016 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/capflooredcoupon.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/cmscoupon.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/indexes/swapindex.hpp>
#include <ql/instruments/nonstandardswap.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    NonstandardSwap::NonstandardSwap(const VanillaSwap &fromVanilla)
        : Swap(2), type_(fromVanilla.type()),
          fixedNominal_(std::vector<Real>(fromVanilla.fixedLeg().size(),
                                          fromVanilla.nominal())),
          floatingNominal_(std::vector<Real>(fromVanilla.floatingLeg().size(),
                                             fromVanilla.nominal())),
          fixedSchedule_(fromVanilla.fixedSchedule()),
          fixedRate_(std::vector<Real>(fromVanilla.fixedLeg().size(),
                                       fromVanilla.fixedRate())),
          fixedDayCount_(fromVanilla.fixedDayCount()),
          floatingSchedule_(fromVanilla.floatingSchedule()),
          iborIndex_(fromVanilla.iborIndex()),
          spread_(std::vector<Real>(fromVanilla.floatingLeg().size(), fromVanilla.spread())),
          gearing_(std::vector<Real>(fromVanilla.floatingLeg().size(), 1.0)),
          singleSpreadAndGearing_(true),
          floatingDayCount_(fromVanilla.floatingDayCount()),
          paymentConvention_(fromVanilla.paymentConvention()),
          intermediateCapitalExchange_(false), finalCapitalExchange_(false) {

        init();
    }

    NonstandardSwap::NonstandardSwap(const Swap::Type type,
                                     std::vector<Real> fixedNominal,
                                     const std::vector<Real>& floatingNominal,
                                     Schedule fixedSchedule,
                                     std::vector<Real> fixedRate,
                                     DayCounter fixedDayCount,
                                     Schedule floatingSchedule,
                                     ext::shared_ptr<IborIndex> iborIndex,
                                     const Real gearing,
                                     const Spread spread,
                                     DayCounter floatingDayCount,
                                     const bool intermediateCapitalExchange,
                                     const bool finalCapitalExchange,
                                     boost::optional<BusinessDayConvention> paymentConvention)
    : Swap(2), type_(type), fixedNominal_(std::move(fixedNominal)),
      floatingNominal_(floatingNominal), fixedSchedule_(std::move(fixedSchedule)),
      fixedRate_(std::move(fixedRate)), fixedDayCount_(std::move(fixedDayCount)),
      floatingSchedule_(std::move(floatingSchedule)), iborIndex_(std::move(iborIndex)),
      spread_(std::vector<Real>(floatingNominal.size(), spread)),
      gearing_(std::vector<Real>(floatingNominal.size(), gearing)), singleSpreadAndGearing_(true),
      floatingDayCount_(std::move(floatingDayCount)),
      intermediateCapitalExchange_(intermediateCapitalExchange),
      finalCapitalExchange_(finalCapitalExchange) {

        if (paymentConvention) // NOLINT(readability-implicit-bool-conversion)
            paymentConvention_ = *paymentConvention;
        else
            paymentConvention_ = floatingSchedule_.businessDayConvention();
        init();
    }

    NonstandardSwap::NonstandardSwap(const Swap::Type type,
                                     std::vector<Real> fixedNominal,
                                     std::vector<Real> floatingNominal,
                                     Schedule fixedSchedule,
                                     std::vector<Real> fixedRate,
                                     DayCounter fixedDayCount,
                                     Schedule floatingSchedule,
                                     ext::shared_ptr<IborIndex> iborIndex,
                                     std::vector<Real> gearing,
                                     std::vector<Spread> spread,
                                     DayCounter floatingDayCount,
                                     const bool intermediateCapitalExchange,
                                     const bool finalCapitalExchange,
                                     boost::optional<BusinessDayConvention> paymentConvention)
    : Swap(2), type_(type), fixedNominal_(std::move(fixedNominal)),
      floatingNominal_(std::move(floatingNominal)), fixedSchedule_(std::move(fixedSchedule)),
      fixedRate_(std::move(fixedRate)), fixedDayCount_(std::move(fixedDayCount)),
      floatingSchedule_(std::move(floatingSchedule)), iborIndex_(std::move(iborIndex)),
      spread_(std::move(spread)), gearing_(std::move(gearing)), singleSpreadAndGearing_(false),
      floatingDayCount_(std::move(floatingDayCount)),
      intermediateCapitalExchange_(intermediateCapitalExchange),
      finalCapitalExchange_(finalCapitalExchange) {

        if (paymentConvention) // NOLINT(readability-implicit-bool-conversion)
            paymentConvention_ = *paymentConvention;
        else
            paymentConvention_ = floatingSchedule_.businessDayConvention();
        init();
    }

    void NonstandardSwap::init() {

        QL_REQUIRE(fixedNominal_.size() == fixedRate_.size(),
                   "Fixed nominal size ("
                       << fixedNominal_.size()
                       << ") does not match fixed rate size ("
                       << fixedRate_.size() << ")");

        QL_REQUIRE(fixedNominal_.size() == fixedSchedule_.size() - 1,
                   "Fixed nominal size (" << fixedNominal_.size()
                                          << ") does not match schedule size ("
                                          << fixedSchedule_.size() << ") - 1");

        QL_REQUIRE(floatingNominal_.size() == floatingSchedule_.size() - 1,
                   "Floating nominal size ("
                       << floatingNominal_.size()
                       << ") does not match schedule size ("
                       << floatingSchedule_.size() << ") - 1");

        QL_REQUIRE(floatingNominal_.size() == spread_.size(),
                   "Floating nominal size (" << floatingNominal_.size()
                                             << ") does not match spread size ("
                                             << spread_.size() << ")");

        QL_REQUIRE(floatingNominal_.size() == gearing_.size(),
                   "Floating nominal size ("
                       << floatingNominal_.size()
                       << ") does not match gearing size (" << gearing_.size()
                       << ")");

        // if the gearing is zero then the ibor leg will be set up with fixed
        // coupons which makes trouble here in this context. We therefore use
        // a dirty trick and enforce the gearing to be non zero.
        for (double& i : gearing_) {
            if (close(i, 0.0))
                i = QL_EPSILON;
        }

        legs_[0] = FixedRateLeg(fixedSchedule_)
                       .withNotionals(fixedNominal_)
                       .withCouponRates(fixedRate_, fixedDayCount_)
                       .withPaymentAdjustment(paymentConvention_);

        legs_[1] = IborLeg(floatingSchedule_, iborIndex_)
                       .withNotionals(floatingNominal_)
                       .withPaymentDayCounter(floatingDayCount_)
                       .withPaymentAdjustment(paymentConvention_)
                       .withSpreads(spread_)
                       .withGearings(gearing_);

        if (intermediateCapitalExchange_) {
            for (Size i = 0; i < legs_[0].size() - 1; i++) {
                Real cap = fixedNominal_[i] - fixedNominal_[i + 1];
                if (!close(cap, 0.0)) {
                    auto it1 = legs_[0].begin();
                    std::advance(it1, i + 1);
                    legs_[0].insert(
                        it1, ext::shared_ptr<CashFlow>(
                                 new Redemption(cap, legs_[0][i]->date())));
                    auto it2 = fixedNominal_.begin();
                    std::advance(it2, i + 1);
                    fixedNominal_.insert(it2, fixedNominal_[i]);
                    auto it3 = fixedRate_.begin();
                    std::advance(it3, i + 1);
                    fixedRate_.insert(it3, 0.0);
                    i++;
                }
            }
            for (Size i = 0; i < legs_[1].size() - 1; i++) {
                Real cap = floatingNominal_[i] - floatingNominal_[i + 1];
                if (!close(cap, 0.0)) {
                    auto it1 = legs_[1].begin();
                    std::advance(it1, i + 1);
                    legs_[1].insert(
                        it1, ext::shared_ptr<CashFlow>(
                                 new Redemption(cap, legs_[1][i]->date())));
                    auto it2 = floatingNominal_.begin();
                    std::advance(it2, i + 1);
                    floatingNominal_.insert(it2, floatingNominal_[i]);
                    i++;
                }
            }
        }

        if (finalCapitalExchange_) {
            legs_[0].push_back(ext::shared_ptr<CashFlow>(
                new Redemption(fixedNominal_.back(), legs_[0].back()->date())));
            fixedNominal_.push_back(fixedNominal_.back());
            fixedRate_.push_back(0.0);
            legs_[1].push_back(ext::shared_ptr<CashFlow>(new Redemption(
                floatingNominal_.back(), legs_[1].back()->date())));
            floatingNominal_.push_back(floatingNominal_.back());
        }

        for (Leg::const_iterator i = legs_[1].begin(); i < legs_[1].end(); ++i)
            registerWith(*i);

        switch (type_) {
        case Swap::Payer:
            payer_[0] = -1.0;
            payer_[1] = +1.0;
            break;
        case Swap::Receiver:
            payer_[0] = +1.0;
            payer_[1] = -1.0;
            break;
        default:
            QL_FAIL("Unknown nonstandard-swap type");
        }
    }

    void NonstandardSwap::setupArguments(PricingEngine::arguments *args) const {

        Swap::setupArguments(args);

        auto* arguments = dynamic_cast<NonstandardSwap::arguments*>(args);

        if (arguments == nullptr)
            return; // swap engine ...

        arguments->type = type_;
        arguments->fixedNominal = fixedNominal_;
        arguments->floatingNominal = floatingNominal_;
        arguments->fixedRate = fixedRate_;

        const Leg &fixedCoupons = fixedLeg();

        arguments->fixedResetDates = arguments->fixedPayDates =
            std::vector<Date>(fixedCoupons.size());
        arguments->fixedCoupons = std::vector<Real>(fixedCoupons.size());
        arguments->fixedIsRedemptionFlow =
            std::vector<bool>(fixedCoupons.size(), false);

        for (Size i = 0; i < fixedCoupons.size(); ++i) {
            ext::shared_ptr<FixedRateCoupon> coupon =
                ext::dynamic_pointer_cast<FixedRateCoupon>(fixedCoupons[i]);
            if (coupon != nullptr) {
                arguments->fixedPayDates[i] = coupon->date();
                arguments->fixedResetDates[i] = coupon->accrualStartDate();
                arguments->fixedCoupons[i] = coupon->amount();
            } else {
                ext::shared_ptr<CashFlow> cashflow =
                    ext::dynamic_pointer_cast<CashFlow>(fixedCoupons[i]);
                std::vector<Date>::const_iterator j =
                    std::find(arguments->fixedPayDates.begin(),
                              arguments->fixedPayDates.end(), cashflow->date());
                QL_REQUIRE(j != arguments->fixedPayDates.end(),
                           "nominal redemption on "
                               << cashflow->date()
                               << "has no corresponding coupon");
                Size jIdx = j - arguments->fixedPayDates.begin();
                arguments->fixedIsRedemptionFlow[i] = true;
                arguments->fixedCoupons[i] = cashflow->amount();
                arguments->fixedResetDates[i] =
                    arguments->fixedResetDates[jIdx];
                arguments->fixedPayDates[i] = cashflow->date();
            }
        }

        const Leg &floatingCoupons = floatingLeg();

        arguments->floatingResetDates = arguments->floatingPayDates =
            arguments->floatingFixingDates =
                std::vector<Date>(floatingCoupons.size());
        arguments->floatingAccrualTimes =
            std::vector<Time>(floatingCoupons.size());
        arguments->floatingSpreads =
            std::vector<Spread>(floatingCoupons.size());
        arguments->floatingGearings = std::vector<Real>(floatingCoupons.size());
        arguments->floatingCoupons = std::vector<Real>(floatingCoupons.size());
        arguments->floatingIsRedemptionFlow =
            std::vector<bool>(floatingCoupons.size(), false);

        for (Size i = 0; i < floatingCoupons.size(); ++i) {
            ext::shared_ptr<IborCoupon> coupon =
                ext::dynamic_pointer_cast<IborCoupon>(floatingCoupons[i]);
            if (coupon != nullptr) {
                arguments->floatingResetDates[i] = coupon->accrualStartDate();
                arguments->floatingPayDates[i] = coupon->date();
                arguments->floatingFixingDates[i] = coupon->fixingDate();
                arguments->floatingAccrualTimes[i] = coupon->accrualPeriod();
                arguments->floatingSpreads[i] = coupon->spread();
                arguments->floatingGearings[i] = coupon->gearing();
                try {
                    arguments->floatingCoupons[i] = coupon->amount();
                }
                catch (Error &) {
                    arguments->floatingCoupons[i] = Null<Real>();
                }
            } else {
                ext::shared_ptr<CashFlow> cashflow =
                    ext::dynamic_pointer_cast<CashFlow>(floatingCoupons[i]);
                std::vector<Date>::const_iterator j = std::find(
                    arguments->floatingPayDates.begin(),
                    arguments->floatingPayDates.end(), cashflow->date());
                QL_REQUIRE(j != arguments->floatingPayDates.end(),
                           "nominal redemption on "
                               << cashflow->date()
                               << "has no corresponding coupon");
                Size jIdx = j - arguments->floatingPayDates.begin();
                arguments->floatingIsRedemptionFlow[i] = true;
                arguments->floatingCoupons[i] = cashflow->amount();
                arguments->floatingResetDates[i] =
                    arguments->floatingResetDates[jIdx];
                arguments->floatingFixingDates[i] =
                    arguments->floatingFixingDates[jIdx];
                arguments->floatingAccrualTimes[i] = 0.0;
                arguments->floatingSpreads[i] = 0.0;
                arguments->floatingGearings[i] = 1.0;
                arguments->floatingPayDates[i] = cashflow->date();
            }
        }

        arguments->iborIndex = iborIndex();
    }

    void NonstandardSwap::setupExpired() const { Swap::setupExpired(); }

    void NonstandardSwap::fetchResults(const PricingEngine::results *r) const {

        Swap::fetchResults(r);
    }

    void NonstandardSwap::arguments::validate() const {
        Swap::arguments::validate();
        QL_REQUIRE(fixedNominal.size() == fixedPayDates.size(),
                   "number of fixed leg nominals plus redemption flows "
                   "different from number of payment dates");
        QL_REQUIRE(fixedRate.size() == fixedPayDates.size(),
                   "number of fixed rates plus redemption flows different from "
                   "number of payment dates");
        QL_REQUIRE(floatingNominal.size() == floatingPayDates.size(),
                   "number of float leg nominals different from number of "
                   "payment dates");
        QL_REQUIRE(fixedResetDates.size() == fixedPayDates.size(),
                   "number of fixed start dates different from "
                   "number of fixed payment dates");
        QL_REQUIRE(fixedPayDates.size() == fixedCoupons.size(),
                   "number of fixed payment dates different from "
                   "number of fixed coupon amounts");
        QL_REQUIRE(floatingResetDates.size() == floatingPayDates.size(),
                   "number of floating start dates different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingFixingDates.size() == floatingPayDates.size(),
                   "number of floating fixing dates different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingAccrualTimes.size() == floatingPayDates.size(),
                   "number of floating accrual Times different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingSpreads.size() == floatingPayDates.size(),
                   "number of floating spreads different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingPayDates.size() == floatingCoupons.size(),
                   "number of floating payment dates different from "
                   "number of floating coupon amounts");
    }

    void NonstandardSwap::results::reset() { Swap::results::reset(); }
}
]]></document_content>
  </document>
  <document index="92">
    <source>nonstandardswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2016 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file nonstandardswap.hpp
    \brief vanilla swap but possibly with period dependent nominal and strike
*/

#ifndef quantlib_nonstandard_swap_hpp
#define quantlib_nonstandard_swap_hpp

#include <ql/instruments/swap.hpp>
#include <ql/instruments/vanillaswap.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/time/schedule.hpp>
#include <boost/optional.hpp>

namespace QuantLib {

    class IborIndex;
    class SwapIndex;

    //! nonstandard swap

    class NonstandardSwap : public Swap {
      public:
        class arguments;
        class results;
        class engine;
        NonstandardSwap(const VanillaSwap &fromVanilla);
        NonstandardSwap(Swap::Type type,
                        std::vector<Real> fixedNominal,
                        const std::vector<Real>& floatingNominal,
                        Schedule fixedSchedule,
                        std::vector<Real> fixedRate,
                        DayCounter fixedDayCount,
                        Schedule floatingSchedule,
                        ext::shared_ptr<IborIndex> iborIndex,
                        Real gearing,
                        Spread spread,
                        DayCounter floatingDayCount,
                        bool intermediateCapitalExchange = false,
                        bool finalCapitalExchange = false,
                        boost::optional<BusinessDayConvention> paymentConvention = boost::none);
        NonstandardSwap(Swap::Type type,
                        std::vector<Real> fixedNominal,
                        std::vector<Real> floatingNominal,
                        Schedule fixedSchedule,
                        std::vector<Real> fixedRate,
                        DayCounter fixedDayCount,
                        Schedule floatingSchedule,
                        ext::shared_ptr<IborIndex> iborIndex,
                        std::vector<Real> gearing,
                        std::vector<Spread> spread,
                        DayCounter floatingDayCount,
                        bool intermediateCapitalExchange = false,
                        bool finalCapitalExchange = false,
                        boost::optional<BusinessDayConvention> paymentConvention = boost::none);
        //! \name Inspectors
        //@{
        Swap::Type type() const;
        const std::vector<Real> &fixedNominal() const;
        const std::vector<Real> &floatingNominal() const;

        const Schedule &fixedSchedule() const;
        const std::vector<Real> &fixedRate() const;
        const DayCounter &fixedDayCount() const;

        const Schedule &floatingSchedule() const;
        const ext::shared_ptr<IborIndex> &iborIndex() const;
        Spread spread() const;
        Real gearing() const;
        const std::vector<Spread>& spreads() const;
        const std::vector<Real>& gearings() const;
        const DayCounter &floatingDayCount() const;

        BusinessDayConvention paymentConvention() const;

        const Leg &fixedLeg() const;
        const Leg &floatingLeg() const;
        //@}

        //! \name Results
        //@{
        //@}
        // other
        void setupArguments(PricingEngine::arguments* args) const override;
        void fetchResults(const PricingEngine::results*) const override;

      private:
        void init();
        void setupExpired() const override;
        Swap::Type type_;
        std::vector<Real> fixedNominal_, floatingNominal_;
        Schedule fixedSchedule_;
        std::vector<Real> fixedRate_;
        DayCounter fixedDayCount_;
        Schedule floatingSchedule_;
        ext::shared_ptr<IborIndex> iborIndex_;
        std::vector<Spread> spread_;
        std::vector<Real> gearing_;
        bool singleSpreadAndGearing_;
        DayCounter floatingDayCount_;
        BusinessDayConvention paymentConvention_;
        const bool intermediateCapitalExchange_;
        const bool finalCapitalExchange_;
        // results
    };

    //! %Arguments for nonstandard swap calculation
    class NonstandardSwap::arguments : public Swap::arguments {
      public:
        arguments() = default;
        Swap::Type type = Swap::Receiver;
        std::vector<Real> fixedNominal, floatingNominal;

        std::vector<Date> fixedResetDates;
        std::vector<Date> fixedPayDates;
        std::vector<Time> floatingAccrualTimes;
        std::vector<Date> floatingResetDates;
        std::vector<Date> floatingFixingDates;
        std::vector<Date> floatingPayDates;

        std::vector<Real> fixedCoupons;
        std::vector<Real> fixedRate;
        std::vector<Spread> floatingSpreads;
        std::vector<Real> floatingGearings;
        std::vector<Real> floatingCoupons;

        ext::shared_ptr<IborIndex> iborIndex;

        std::vector<bool> fixedIsRedemptionFlow;
        std::vector<bool> floatingIsRedemptionFlow;

        void validate() const override;
    };

    //! %Results from nonstandard swap calculation
    class NonstandardSwap::results : public Swap::results {
      public:
        void reset() override;
    };

    class NonstandardSwap::engine
        : public GenericEngine<NonstandardSwap::arguments,
                               NonstandardSwap::results> {};

    // inline definitions

    inline Swap::Type NonstandardSwap::type() const { return type_; }

    inline const std::vector<Real> &NonstandardSwap::fixedNominal() const {
        return fixedNominal_;
    }

    inline const std::vector<Real> &NonstandardSwap::floatingNominal() const {
        return floatingNominal_;
    }

    inline const Schedule &NonstandardSwap::fixedSchedule() const {
        return fixedSchedule_;
    }

    inline const std::vector<Real> &NonstandardSwap::fixedRate() const {
        return fixedRate_;
    }

    inline const DayCounter &NonstandardSwap::fixedDayCount() const {
        return fixedDayCount_;
    }

    inline const Schedule &NonstandardSwap::floatingSchedule() const {
        return floatingSchedule_;
    }

    inline const ext::shared_ptr<IborIndex> &
    NonstandardSwap::iborIndex() const {
        return iborIndex_;
    }

    inline Spread NonstandardSwap::spread() const {
        QL_REQUIRE(singleSpreadAndGearing_,
                   "spread is a vector, use spreads inspector instead");
        return spread_.front();
    }

    inline Real NonstandardSwap::gearing() const {
        QL_REQUIRE(singleSpreadAndGearing_,
                   "gearing is a vector, use gearings inspector instead");
        return gearing_.front();
    }

    inline const std::vector<Spread> &NonstandardSwap::spreads() const {
        return spread_;
    }

    inline const std::vector<Real> &NonstandardSwap::gearings() const {
        return gearing_;
    }

    inline const DayCounter &NonstandardSwap::floatingDayCount() const {
        return floatingDayCount_;
    }

    inline BusinessDayConvention NonstandardSwap::paymentConvention() const {
        return paymentConvention_;
    }

    inline const Leg &NonstandardSwap::fixedLeg() const { return legs_[0]; }

    inline const Leg &NonstandardSwap::floatingLeg() const { return legs_[1]; }
}

#endif
]]></document_content>
  </document>
  <document index="93">
    <source>nonstandardswaption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2018 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/instruments/nonstandardswaption.hpp>
#include <utility>

namespace QuantLib {

    NonstandardSwaption::NonstandardSwaption(const Swaption &fromSwaption)
        : Option(ext::shared_ptr<Payoff>(),
                 const_cast<Swaption &>(fromSwaption).exercise()),
          swap_(ext::make_shared<NonstandardSwap>(
              *fromSwaption.underlyingSwap())),
          settlementType_(fromSwaption.settlementType()),
          settlementMethod_(fromSwaption.settlementMethod()) {

        registerWith(swap_);
    }

    NonstandardSwaption::NonstandardSwaption(ext::shared_ptr<NonstandardSwap> swap,
                                             const ext::shared_ptr<Exercise>& exercise,
                                             Settlement::Type delivery,
                                             Settlement::Method settlementMethod)
    : Option(ext::shared_ptr<Payoff>(), exercise), swap_(std::move(swap)),
      settlementType_(delivery), settlementMethod_(settlementMethod) {
        registerWith(swap_);
        registerWithObservables(swap_);
    }

    bool NonstandardSwaption::isExpired() const {

        return detail::simple_event(exercise_->dates().back()).hasOccurred();
    }

    void
    NonstandardSwaption::setupArguments(PricingEngine::arguments *args) const {

        swap_->setupArguments(args);

        auto* arguments = dynamic_cast<NonstandardSwaption::arguments*>(args);

        QL_REQUIRE(arguments != nullptr, "argument types do not match");

        arguments->swap = swap_;
        arguments->exercise = exercise_;
        arguments->settlementType = settlementType_;
        arguments->settlementMethod = settlementMethod_;
    }

    void NonstandardSwaption::arguments::validate() const {

        NonstandardSwap::arguments::validate();
        QL_REQUIRE(swap, "underlying non standard swap not set");
        QL_REQUIRE(exercise, "exercise not set");
        Settlement::checkTypeAndMethodConsistency(settlementType,
                                                  settlementMethod);
    }

    Disposable<std::vector<ext::shared_ptr<BlackCalibrationHelper> > >
    NonstandardSwaption::calibrationBasket(
        const ext::shared_ptr<SwapIndex>& standardSwapBase,
        const ext::shared_ptr<SwaptionVolatilityStructure>& swaptionVolatility,
        const BasketGeneratingEngine::CalibrationBasketType basketType) const {

        ext::shared_ptr<BasketGeneratingEngine> engine =
            ext::dynamic_pointer_cast<BasketGeneratingEngine>(engine_);
        QL_REQUIRE(engine, "engine is not a basket generating engine");
        engine_->reset();
        setupArguments(engine_->getArguments());
        engine_->getArguments()->validate();
        return engine->calibrationBasket(exercise_, standardSwapBase,
                                         swaptionVolatility, basketType);
    }
}
]]></document_content>
  </document>
  <document index="94">
    <source>nonstandardswaption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2013, 2018 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file nonstandardswaption.hpp
    \brief nonstandard swap option class
*/

#ifndef quantlib_instruments_nonstandardswaption_hpp
#define quantlib_instruments_nonstandardswaption_hpp

#include <ql/option.hpp>
#include <ql/instruments/swaption.hpp>
#include <ql/instruments/nonstandardswap.hpp>
#include <ql/pricingengines/swaption/basketgeneratingengine.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/termstructures/volatility/swaption/swaptionvolstructure.hpp>
#include <ql/models/calibrationhelper.hpp>
#include <ql/utilities/disposable.hpp>

namespace QuantLib {

    //! nonstandard swaption class
    /*! \ingroup instruments
    */

    class NonstandardSwaption : public Option {
      public:
        class arguments;
        class engine;
        NonstandardSwaption(const Swaption &fromSwaption);
        NonstandardSwaption(ext::shared_ptr<NonstandardSwap> swap,
                            const ext::shared_ptr<Exercise>& exercise,
                            Settlement::Type delivery = Settlement::Physical,
                            Settlement::Method settlementMethod = Settlement::PhysicalOTC);

        //! \name Instrument interface
        //@{
        bool isExpired() const override;
        void setupArguments(PricingEngine::arguments*) const override;
        //@}
        //! \name Inspectors
        //@{
        Settlement::Type settlementType() const { return settlementType_; }
        Settlement::Method settlementMethod() const {
            return settlementMethod_;
        }
        Swap::Type type() const { return swap_->type(); }

        const ext::shared_ptr<NonstandardSwap> &underlyingSwap() const {
            return swap_;
        }
        //@}
        Disposable<std::vector<ext::shared_ptr<BlackCalibrationHelper> > >
        calibrationBasket(const ext::shared_ptr<SwapIndex>& standardSwapBase,
                          const ext::shared_ptr<SwaptionVolatilityStructure>& swaptionVolatility,
                          BasketGeneratingEngine::CalibrationBasketType basketType =
                              BasketGeneratingEngine::MaturityStrikeByDeltaGamma) const;

      private:
        // arguments
        ext::shared_ptr<NonstandardSwap> swap_;
        Settlement::Type settlementType_;
        Settlement::Method settlementMethod_;
    };

    //! %Arguments for nonstandard swaption calculation
    class NonstandardSwaption::arguments : public NonstandardSwap::arguments,
                                           public Option::arguments {
      public:
        arguments() = default;
        ext::shared_ptr<NonstandardSwap> swap;
        Settlement::Type settlementType;
        Settlement::Method settlementMethod;
        void validate() const override;
    };

    //! base class for nonstandard swaption engines
    class NonstandardSwaption::engine
        : public GenericEngine<NonstandardSwaption::arguments,
                               NonstandardSwaption::results> {};
}

#endif
]]></document_content>
  </document>
  <document index="95">
    <source>oneassetoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/oneassetoption.hpp>
#include <ql/exercise.hpp>
#include <ql/event.hpp>

namespace QuantLib {

    OneAssetOption::OneAssetOption(
        const ext::shared_ptr<Payoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : Option(payoff, exercise) {}

    bool OneAssetOption::isExpired() const {
        return detail::simple_event(exercise_->lastDate()).hasOccurred();
    }

    Real OneAssetOption::delta() const {
        calculate();
        QL_REQUIRE(delta_ != Null<Real>(), "delta not provided");
        return delta_;
    }

    Real OneAssetOption::deltaForward() const {
        calculate();
        QL_REQUIRE(deltaForward_ != Null<Real>(),
                   "forward delta not provided");
        return deltaForward_;
    }

    Real OneAssetOption::elasticity() const {
        calculate();
        QL_REQUIRE(elasticity_ != Null<Real>(), "elasticity not provided");
        return elasticity_;
    }

    Real OneAssetOption::gamma() const {
        calculate();
        QL_REQUIRE(gamma_ != Null<Real>(), "gamma not provided");
        return gamma_;
    }

    Real OneAssetOption::theta() const {
        calculate();
        QL_REQUIRE(theta_ != Null<Real>(), "theta not provided");
        return theta_;
    }

    Real OneAssetOption::thetaPerDay() const {
        calculate();
        QL_REQUIRE(thetaPerDay_ != Null<Real>(), "theta per-day not provided");
        return thetaPerDay_;
    }

    Real OneAssetOption::vega() const {
        calculate();
        QL_REQUIRE(vega_ != Null<Real>(), "vega not provided");
        return vega_;
    }

    Real OneAssetOption::rho() const {
        calculate();
        QL_REQUIRE(rho_ != Null<Real>(), "rho not provided");
        return rho_;
    }

    Real OneAssetOption::dividendRho() const {
        calculate();
        QL_REQUIRE(dividendRho_ != Null<Real>(), "dividend rho not provided");
        return dividendRho_;
    }

    Real OneAssetOption::strikeSensitivity() const {
        calculate();
        QL_REQUIRE(strikeSensitivity_ != Null<Real>(),
                   "strike sensitivity not provided");
        return strikeSensitivity_;
    }

    Real OneAssetOption::itmCashProbability() const {
        calculate();
        QL_REQUIRE(itmCashProbability_ != Null<Real>(),
                   "in-the-money cash probability not provided");
        return itmCashProbability_;
    }

    void OneAssetOption::setupExpired() const {
        Option::setupExpired();
        delta_ = deltaForward_ = elasticity_ = gamma_ = theta_ =
            thetaPerDay_ = vega_ = rho_ = dividendRho_ =
            strikeSensitivity_ = itmCashProbability_ = 0.0;
    }

    void OneAssetOption::fetchResults(const PricingEngine::results* r) const {
        Option::fetchResults(r);
        const auto* results = dynamic_cast<const Greeks*>(r);
        QL_ENSURE(results != nullptr, "no greeks returned from pricing engine");
        /* no check on null values - just copy.
           this allows:
           a) to decide in derived options what to do when null
           results are returned (throw? numerical calculation?)
           b) to implement slim engines which only calculate the
           value---of course care must be taken not to call
           the greeks methods when using these.
        */
        delta_          = results->delta;
        gamma_          = results->gamma;
        theta_          = results->theta;
        vega_           = results->vega;
        rho_            = results->rho;
        dividendRho_    = results->dividendRho;

        const auto* moreResults = dynamic_cast<const MoreGreeks*>(r);
        QL_ENSURE(moreResults != nullptr, "no more greeks returned from pricing engine");
        /* no check on null values - just copy.
           this allows:
           a) to decide in derived options what to do when null
           results are returned (throw? numerical calculation?)
           b) to implement slim engines which only calculate the
           value---of course care must be taken not to call
           the greeks methods when using these.
        */
        deltaForward_       = moreResults->deltaForward;
        elasticity_         = moreResults->elasticity;
        thetaPerDay_        = moreResults->thetaPerDay;
        strikeSensitivity_  = moreResults->strikeSensitivity;
        itmCashProbability_ = moreResults->itmCashProbability;
    }

}

]]></document_content>
  </document>
  <document index="96">
    <source>oneassetoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file oneassetoption.hpp
    \brief Option on a single asset
*/

#ifndef quantlib_oneasset_option_hpp
#define quantlib_oneasset_option_hpp

#include <ql/option.hpp>

namespace QuantLib {

    //! Base class for options on a single asset
    class OneAssetOption : public Option {
      public:
        class engine;
        class results;
        OneAssetOption(const ext::shared_ptr<Payoff>&,
                       const ext::shared_ptr<Exercise>&);
        //! \name Instrument interface
        //@{
        bool isExpired() const override;
        //@}
        //! \name greeks
        //@{
        Real delta() const;
        Real deltaForward() const;
        Real elasticity() const;
        Real gamma() const;
        Real theta() const;
        Real thetaPerDay() const;
        Real vega() const;
        Real rho() const;
        Real dividendRho() const;
        Real strikeSensitivity() const;
        Real itmCashProbability() const;
        //@}
        void fetchResults(const PricingEngine::results*) const override;

      protected:
        void setupExpired() const override;
        // results
        mutable Real delta_, deltaForward_, elasticity_, gamma_, theta_,
            thetaPerDay_, vega_, rho_, dividendRho_, strikeSensitivity_,
            itmCashProbability_;
    };

    //! %Results from single-asset option calculation
    class OneAssetOption::results : public Instrument::results,
                                    public Greeks,
                                    public MoreGreeks {
      public:
        void reset() override {
            Instrument::results::reset();
            Greeks::reset();
            MoreGreeks::reset();
        }
    };

    class OneAssetOption::engine :
        public GenericEngine<OneAssetOption::arguments,
                             OneAssetOption::results> {};

}


#endif

]]></document_content>
  </document>
  <document index="97">
    <source>overnightindexedswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Roland Lichters
 Copyright (C) 2009 Ferdinando Ametrano
 Copyright (C) 2017 Joseph Jeisman
 Copyright (C) 2017 Fabrice Lecuyer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/overnightindexedcoupon.hpp>
#include <ql/instruments/overnightindexedswap.hpp>
#include <utility>

namespace QuantLib {

    OvernightIndexedSwap::OvernightIndexedSwap(Type type,
                                               Real nominal,
                                               const Schedule& schedule,
                                               Rate fixedRate,
                                               DayCounter fixedDC,
                                               ext::shared_ptr<OvernightIndex> overnightIndex,
                                               Spread spread,
                                               Natural paymentLag,
                                               BusinessDayConvention paymentAdjustment,
                                               const Calendar& paymentCalendar,
                                               bool telescopicValueDates, 
                                               RateAveraging::Type averagingMethod)
    : Swap(2), type_(type), nominals_(std::vector<Real>(1, nominal)),
      paymentFrequency_(schedule.tenor().frequency()),
      paymentCalendar_(paymentCalendar.empty() ? schedule.calendar() : paymentCalendar),
      paymentAdjustment_(paymentAdjustment), paymentLag_(paymentLag), fixedRate_(fixedRate),
      fixedDC_(std::move(fixedDC)), overnightIndex_(std::move(overnightIndex)), spread_(spread),
      telescopicValueDates_(telescopicValueDates), averagingMethod_(averagingMethod) {

        initialize(schedule);
    }

    OvernightIndexedSwap::OvernightIndexedSwap(Type type,
                                               std::vector<Real> nominals,
                                               const Schedule& schedule,
                                               Rate fixedRate,
                                               DayCounter fixedDC,
                                               ext::shared_ptr<OvernightIndex> overnightIndex,
                                               Spread spread,
                                               Natural paymentLag,
                                               BusinessDayConvention paymentAdjustment,
                                               const Calendar& paymentCalendar,
                                               bool telescopicValueDates, 
                                               RateAveraging::Type averagingMethod)
    : Swap(2), type_(type), nominals_(std::move(nominals)),
      paymentFrequency_(schedule.tenor().frequency()),
      paymentCalendar_(paymentCalendar.empty() ? schedule.calendar() : paymentCalendar),
      paymentAdjustment_(paymentAdjustment), paymentLag_(paymentLag), fixedRate_(fixedRate),
      fixedDC_(std::move(fixedDC)), overnightIndex_(std::move(overnightIndex)), spread_(spread),
      telescopicValueDates_(telescopicValueDates), averagingMethod_(averagingMethod) {

        initialize(schedule);
    }

    void OvernightIndexedSwap::initialize(const Schedule& schedule) {
        if (fixedDC_==DayCounter())
            fixedDC_ = overnightIndex_->dayCounter();
        legs_[0] = FixedRateLeg(schedule)
            .withNotionals(nominals_)
            .withCouponRates(fixedRate_, fixedDC_)
            .withPaymentLag(paymentLag_)
            .withPaymentAdjustment(paymentAdjustment_)
            .withPaymentCalendar(paymentCalendar_);

		legs_[1] = OvernightLeg(schedule, overnightIndex_)
            .withNotionals(nominals_)
            .withSpreads(spread_)
            .withTelescopicValueDates(telescopicValueDates_)
            .withPaymentLag(paymentLag_)
            .withPaymentAdjustment(paymentAdjustment_)
            .withPaymentCalendar(paymentCalendar_)
            .withAveragingMethod(averagingMethod_);

        for (Size j=0; j<2; ++j) {
            for (auto& i : legs_[j])
                registerWith(i);
        }

        switch (type_) {
          case Payer:
            payer_[0] = -1.0;
            payer_[1] = +1.0;
            break;
          case Receiver:
            payer_[0] = +1.0;
            payer_[1] = -1.0;
            break;
          default:
            QL_FAIL("Unknown overnight-swap type");
        }
    }

    Real OvernightIndexedSwap::fairRate() const {
        static Spread basisPoint = 1.0e-4;
        calculate();
        return fixedRate_ - NPV_/(fixedLegBPS()/basisPoint);
    }

    Spread OvernightIndexedSwap::fairSpread() const {
        static Spread basisPoint = 1.0e-4;
        calculate();
        return spread_ - NPV_/(overnightLegBPS()/basisPoint);
    }

    Real OvernightIndexedSwap::fixedLegBPS() const {
        calculate();
        QL_REQUIRE(legBPS_[0] != Null<Real>(), "result not available");
        return legBPS_[0];
    }

    Real OvernightIndexedSwap::overnightLegBPS() const {
        calculate();
        QL_REQUIRE(legBPS_[1] != Null<Real>(), "result not available");
        return legBPS_[1];
    }

    Real OvernightIndexedSwap::fixedLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[0] != Null<Real>(), "result not available");
        return legNPV_[0];
    }

    Real OvernightIndexedSwap::overnightLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[1] != Null<Real>(), "result not available");
        return legNPV_[1];
    }

}
]]></document_content>
  </document>
  <document index="98">
    <source>overnightindexedswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2009 Roland Lichters
 Copyright (C) 2009 Ferdinando Ametrano
 Copyright (C) 2017 Joseph Jeisman
 Copyright (C) 2017 Fabrice Lecuyer

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file overnightindexedswap.hpp
    \brief Overnight index swap paying compounded overnight vs. fixed
*/

#ifndef quantlib_overnight_indexed_swap_hpp
#define quantlib_overnight_indexed_swap_hpp

#include <ql/instruments/swap.hpp>
#include <ql/cashflows/rateaveraging.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/time/businessdayconvention.hpp>
#include <ql/time/calendar.hpp>

namespace QuantLib {

    class Schedule;
    class OvernightIndex;

    //! Overnight indexed swap: fix vs compounded overnight rate
    class OvernightIndexedSwap : public Swap {
      public:
        OvernightIndexedSwap(Type type,
                             Real nominal,
                             const Schedule& schedule,
                             Rate fixedRate,
                             DayCounter fixedDC,
                             ext::shared_ptr<OvernightIndex> overnightIndex,
                             Spread spread = 0.0,
                             Natural paymentLag = 0,
                             BusinessDayConvention paymentAdjustment = Following,
                             const Calendar& paymentCalendar = Calendar(),
                             bool telescopicValueDates = false,
                             RateAveraging::Type averagingMethod = RateAveraging::Compound);

        OvernightIndexedSwap(Type type,
                             std::vector<Real> nominals,
                             const Schedule& schedule,
                             Rate fixedRate,
                             DayCounter fixedDC,
                             ext::shared_ptr<OvernightIndex> overnightIndex,
                             Spread spread = 0.0,
                             Natural paymentLag = 0,
                             BusinessDayConvention paymentAdjustment = Following,
                             const Calendar& paymentCalendar = Calendar(),
                             bool telescopicValueDates = false,
                             RateAveraging::Type averagingMethod = RateAveraging::Compound);

        //! \name Inspectors
        //@{
        Type type() const { return type_; }
        Real nominal() const;
        std::vector<Real> nominals() const { return nominals_; }

        Frequency paymentFrequency() { return paymentFrequency_; }

        Rate fixedRate() const { return fixedRate_; }
        const DayCounter& fixedDayCount() { return fixedDC_; }

        const ext::shared_ptr<OvernightIndex>& overnightIndex() { return overnightIndex_; }
        Spread spread() const { return spread_; }

        const Leg& fixedLeg() const { return legs_[0]; }
        const Leg& overnightLeg() const { return legs_[1]; }

        RateAveraging::Type averagingMethod() const { return averagingMethod_; }
        //@}

        //! \name Results
        //@{
        Real fixedLegBPS() const;
        Real fixedLegNPV() const;
        Real fairRate() const;

        Real overnightLegBPS() const;
        Real overnightLegNPV() const;
        Spread fairSpread() const;
        //@}
      private:
        void initialize(const Schedule& schedule);
        Type type_;
        std::vector<Real> nominals_;

        Frequency paymentFrequency_;
        Calendar paymentCalendar_;
        BusinessDayConvention paymentAdjustment_;
        Natural paymentLag_;

        //Schedule schedule_;

        Rate fixedRate_;
        DayCounter fixedDC_;

        ext::shared_ptr<OvernightIndex> overnightIndex_;
        Spread spread_;
        bool telescopicValueDates_;
        RateAveraging::Type averagingMethod_;
    };


    // inline

    inline Real OvernightIndexedSwap::nominal() const {
        QL_REQUIRE(nominals_.size()==1, "varying nominals");
        return nominals_[0];
    }

}

#endif
]]></document_content>
  </document>
  <document index="99">
    <source>overnightindexfuture.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Roy Zywina
 Copyright (C) 2019 Eisuke Tani

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/overnightindexfuture.hpp>
#include <ql/indexes/indexmanager.hpp>
#include <ql/event.hpp>
#include <utility>

namespace QuantLib {

    OvernightIndexFuture::OvernightIndexFuture(ext::shared_ptr<OvernightIndex> overnightIndex,
                                               const Date& valueDate,
                                               const Date& maturityDate,
                                               Handle<Quote> convexityAdjustment,
                                               RateAveraging::Type averagingMethod)
    : overnightIndex_(std::move(overnightIndex)), valueDate_(valueDate),
      maturityDate_(maturityDate), convexityAdjustment_(std::move(convexityAdjustment)),
      averagingMethod_(averagingMethod) {
        QL_REQUIRE(overnightIndex_, "null overnight index");
        registerWith(overnightIndex_);
    }

    Real OvernightIndexFuture::averagedRate() const {
        Date today = Settings::instance().evaluationDate();
        Calendar calendar = overnightIndex_->fixingCalendar();
        DayCounter dayCounter = overnightIndex_->dayCounter();
        Handle<YieldTermStructure> forwardCurve = overnightIndex_->forwardingTermStructure();
        Real avg = 0;
        Date d1 = valueDate_;
        const TimeSeries<Real>& history = IndexManager::instance()
            .getHistory(overnightIndex_->name());
        Real fwd;
        while (d1 < maturityDate_) {
            Date d2 = calendar.advance(d1, 1, Days);
            if (d1 < today) {
                fwd = history[d1];
                QL_REQUIRE(fwd != Null<Real>(), "missing rate on " <<
                    d1 << " for index " << overnightIndex_->name());
            } else {
                fwd = forwardCurve->forwardRate(d1, d2, dayCounter, Simple).rate();
            }
            avg += fwd * dayCounter.yearFraction(d1, d2);
            d1 = d2;
        }

        return avg / dayCounter.yearFraction(valueDate_, maturityDate_);
    }

    Real OvernightIndexFuture::compoundedRate() const {
        Date today = Settings::instance().evaluationDate();
        Calendar calendar = overnightIndex_->fixingCalendar();
        DayCounter dayCounter = overnightIndex_->dayCounter();
        Handle<YieldTermStructure> forwardCurve = overnightIndex_->forwardingTermStructure();
        Real prod = 1;
        if (today > valueDate_) {
            // can't value on a weekend inside reference period because we
            // won't know the reset rate until start of next business day.
            // user can supply an estimate if they really want to do this
            today = calendar.adjust(today);
            // for valuations inside the reference period, index quotes
            // must have been populated in the history
            const TimeSeries<Real>& history = IndexManager::instance()
                .getHistory(overnightIndex_->name());
            Date d1 = valueDate_;
            while (d1 < today) {
                Real r = history[d1];
                QL_REQUIRE(r != Null<Real>(), "missing rate on " <<
                    d1 << " for index " << overnightIndex_->name());
                Date d2 = calendar.advance(d1, 1, Days);
                prod *= 1 + r * dayCounter.yearFraction(d1, d2);
                d1 = d2;
            }
        }
        DiscountFactor forwardDiscount = forwardCurve->discount(maturityDate_);
        if (valueDate_ > today) {
            forwardDiscount /= forwardCurve->discount(valueDate_);
        }
        prod /= forwardDiscount;

        return (prod - 1) / dayCounter.yearFraction(valueDate_, maturityDate_);
    }

    Real OvernightIndexFuture::rate() const {
        switch (averagingMethod_) {
          case RateAveraging::Simple:
            return averagedRate();
            break;
          case RateAveraging::Compound:
            return compoundedRate();
            break;
          default:
              QL_FAIL("unknown compounding convention (" << Integer(averagingMethod_) << ")");
        }
    }

    bool OvernightIndexFuture::isExpired() const {
        return detail::simple_event(maturityDate_).hasOccurred();
    }

    Real OvernightIndexFuture::convexityAdjustment() const {
        return convexityAdjustment_.empty() ? 0.0 : convexityAdjustment_->value();
    }

    void OvernightIndexFuture::performCalculations() const {
        Rate R = convexityAdjustment() + rate();
        NPV_ = 100.0 * (1.0 - R);
    }

}
]]></document_content>
  </document>
  <document index="100">
    <source>overnightindexfuture.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2018 Roy Zywina
 Copyright (C) 2019 Eisuke Tani

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file overnightindexfuture.hpp
    \brief Overnight Index Future
*/

#ifndef quantlib_overnightindexfuture_hpp
#define quantlib_overnightindexfuture_hpp

#include <ql/indexes/iborindex.hpp>
#include <ql/instruments/forward.hpp>
#include <ql/cashflows/rateaveraging.hpp>

namespace QuantLib {

    /*! Future on a compounded overnight index investment.

        Compatible with SOFR futures and Sonia futures available on
        CME and ICE exchanges.
    */
    class OvernightIndexFuture : public Instrument {
      public:
        OvernightIndexFuture(
            ext::shared_ptr<OvernightIndex> overnightIndex,
            const Date& valueDate,
            const Date& maturityDate,
            Handle<Quote> convexityAdjustment = Handle<Quote>(),
            RateAveraging::Type averagingMethod = RateAveraging::Compound);

        Real convexityAdjustment() const;
        bool isExpired() const override;
      private:
        void performCalculations() const override;
        Real rate() const;
        Real averagedRate() const;
        Real compoundedRate() const;
        ext::shared_ptr<OvernightIndex> overnightIndex_;
        Date valueDate_, maturityDate_;
        Handle<Quote> convexityAdjustment_;
        RateAveraging::Type averagingMethod_;
    };

}

#endif
]]></document_content>
  </document>
  <document index="101">
    <source>payoffs.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2006 Ferdinando Ametrano
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2006, 2008 StatPro Italia srl
 Copyright (C) 2006 Chiara Fornarola

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    std::string NullPayoff::name() const {
        return "Null";
    }

    std::string NullPayoff::description() const {
        return name();
    }

    Real NullPayoff::operator()(Real) const {
        QL_FAIL("dummy payoff given");
    }

    void NullPayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<NullPayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }



    std::string TypePayoff::description() const {
        std::ostringstream result;
        result << name() << " " << optionType();
        return result.str();
    }

    //std::string StrikedPayoff::description() const {
    //    std::ostringstream result;
    //    result << ", " << strike() << " strike";
    //    return result.str();
    //}

    Real FloatingTypePayoff::operator()(Real) const {
        QL_FAIL("floating payoff not handled");
    }

    Real FloatingTypePayoff::operator()(Real price, Real strike) const {
        switch (type_) {
            case Option::Call:
                return std::max<Real>(price - strike,0.0);
            case Option::Put:
                return std::max<Real>(strike - price,0.0);
            default:
                QL_FAIL("unknown/illegal option type");
        }
    }

    std::string StrikedTypePayoff::description() const {
        std::ostringstream result;
        result << TypePayoff::description() << ", " <<
                  strike() << " strike";
        return result.str();
    }

    void FloatingTypePayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<FloatingTypePayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }

    Real PlainVanillaPayoff::operator()(Real price) const {
        switch (type_) {
          case Option::Call:
            return std::max<Real>(price-strike_,0.0);
          case Option::Put:
            return std::max<Real>(strike_-price,0.0);
          default:
            QL_FAIL("unknown/illegal option type");
        }
    }

    void PlainVanillaPayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<PlainVanillaPayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }

    Real PercentageStrikePayoff::operator()(Real price) const {
        switch (type_) {
          case Option::Call:
            return price*std::max<Real>(Real(1.0)-strike_,0.0);
          case Option::Put:
            return price*std::max<Real>(strike_-Real(1.0),0.0);
          default:
            QL_FAIL("unknown/illegal option type");
        }
    }

    void PercentageStrikePayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<PercentageStrikePayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }

    Real AssetOrNothingPayoff::operator()(Real price) const {
        switch (type_) {
          case Option::Call:
            return (price-strike_ > 0.0 ? price : 0.0);
          case Option::Put:
            return (strike_-price > 0.0 ? price : 0.0);
          default:
            QL_FAIL("unknown/illegal option type");
        }
    }

    void AssetOrNothingPayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<AssetOrNothingPayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }

    std::string CashOrNothingPayoff::description() const {
        std::ostringstream result;
        result << StrikedTypePayoff::description() << ", " << cashPayoff() << " cash payoff";
        return result.str();
    }

    Real CashOrNothingPayoff::operator()(Real price) const {
        switch (type_) {
          case Option::Call:
            return (price-strike_ > 0.0 ? cashPayoff_ : 0.0);
          case Option::Put:
            return (strike_-price > 0.0 ? cashPayoff_ : 0.0);
          default:
            QL_FAIL("unknown/illegal option type");
        }
    }

    void CashOrNothingPayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<CashOrNothingPayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);}

    std::string GapPayoff::description() const {
        std::ostringstream result;
        result << StrikedTypePayoff::description() << ", " << secondStrike() << " strike payoff";
        return result.str();
    }

    Real GapPayoff::operator()(Real price) const {
        switch (type_) {
          case Option::Call:
            return (price-strike_ >= 0.0 ? price-secondStrike_ : 0.0);
          case Option::Put:
            return (strike_-price >= 0.0 ? secondStrike_-price : 0.0);
          default:
            QL_FAIL("unknown/illegal option type");
        }
    }

    void GapPayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<GapPayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }

    Real SuperFundPayoff::operator()(Real price) const {
        return (price>=strike_ && price<secondStrike_) ? price/strike_ : 0.0;
    }

    void SuperFundPayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<SuperFundPayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }
    std::string SuperSharePayoff::description() const {
        std::ostringstream result;
        result << StrikedTypePayoff::description() << ", " << secondStrike() << " second strike"<< ", " << cashPayoff() << " amount";
        return result.str();
    }

    Real SuperSharePayoff::operator()(Real price) const {
        return (price>=strike_ && price<secondStrike_) ? cashPayoff_ : 0.0;
    }

    void SuperSharePayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<SuperSharePayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }

}
]]></document_content>
  </document>
  <document index="102">
    <source>payoffs.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003, 2006 Ferdinando Ametrano
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2006, 2008 StatPro Italia srl
 Copyright (C) 2006 Chiara Fornarola

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file payoffs.hpp
    \brief Payoffs for various options
*/

#ifndef quantlib_payoffs_hpp
#define quantlib_payoffs_hpp

#include <ql/option.hpp>
#include <ql/payoff.hpp>

namespace QuantLib {

    //! Dummy %payoff class
    class NullPayoff : public Payoff {
      public:
        //! \name Payoff interface
        //@{
        std::string name() const override;
        std::string description() const override;
        Real operator()(Real price) const override;
        void accept(AcyclicVisitor&) override;
        //@}
    };


    //! Intermediate class for put/call payoffs
    class TypePayoff : public Payoff {
      public:
        Option::Type optionType() const { return type_; };
        //! \name Payoff interface
        //@{
        std::string description() const override;
        //@}
      protected:
        explicit TypePayoff(Option::Type type) : type_(type) {}
        Option::Type type_;
    };

    ////! Intermediate class for payoffs based on a fixed strike
    //class StrikedPayoff : public Payoff {
    //  public:
    //    StrikedPayoff(Real strike) : strike_(strike) {}
    //    Real strike() const { return strike_; };
    //    //! \name Payoff interface
    //    //@{
    //    std::string description() const;
    //    //@}
    //  protected:
    //    Real strike_;
    //};

    //! %Payoff based on a floating strike
    class FloatingTypePayoff : public TypePayoff {
      public:
        FloatingTypePayoff(Option::Type type) : TypePayoff(type) {}
        //! \name Payoff interface
        //@{
        std::string name() const override { return "FloatingType"; }
        Real operator()(Real price, Real strike) const;
        Real operator()(Real price) const override;
        void accept(AcyclicVisitor&) override;
        //@}
    };

    //! Intermediate class for payoffs based on a fixed strike
    class StrikedTypePayoff : public TypePayoff
                              //, public StrikedPayoff
    {
      public:
        //! \name Payoff interface
        //@{
        std::string description() const override;
        //@}
        Real strike() const { return strike_; };
      protected:
        StrikedTypePayoff(Option::Type type,
                          Real strike)
        : TypePayoff(type), strike_(strike) {}
        Real strike_;
    };

    //! Plain-vanilla payoff
    class PlainVanillaPayoff : public StrikedTypePayoff {
      public:
        PlainVanillaPayoff(Option::Type type,
                           Real strike)
        : StrikedTypePayoff(type, strike) {}
        //! \name Payoff interface
        //@{
        std::string name() const override { return "Vanilla"; }
        Real operator()(Real price) const override;
        void accept(AcyclicVisitor&) override;
        //@}
    };

    //! %Payoff with strike expressed as percentage
    class PercentageStrikePayoff : public StrikedTypePayoff {
      public:
        PercentageStrikePayoff(Option::Type type,
                               Real moneyness)
        : StrikedTypePayoff(type, moneyness) {}
        //! \name Payoff interface
        //@{
        std::string name() const override { return "PercentageStrike"; }
        Real operator()(Real price) const override;
        void accept(AcyclicVisitor&) override;
        //@}
    };

    /*! Definitions of Binary path-independent payoffs used below,
        can be found in M. Rubinstein, E. Reiner:"Unscrambling The Binary Code", Risk, Vol.4 no.9,1991.
        (see: http://www.in-the-money.com/artandpap/Binary%20Options.doc)
    */

    //! Binary asset-or-nothing payoff
    class AssetOrNothingPayoff : public StrikedTypePayoff {
      public:
        AssetOrNothingPayoff(Option::Type type,
                             Real strike)
        : StrikedTypePayoff(type, strike) {}
        //! \name Payoff interface
        //@{
        std::string name() const override { return "AssetOrNothing"; }
        Real operator()(Real price) const override;
        void accept(AcyclicVisitor&) override;
        //@}
    };

    //! Binary cash-or-nothing payoff
    class CashOrNothingPayoff : public StrikedTypePayoff {
      public:
        CashOrNothingPayoff(Option::Type type,
                            Real strike,
                            Real cashPayoff)
        : StrikedTypePayoff(type, strike), cashPayoff_(cashPayoff) {}
        //! \name Payoff interface
        //@{
        std::string name() const override { return "CashOrNothing"; }
        std::string description() const override;
        Real operator()(Real price) const override;
        void accept(AcyclicVisitor&) override;
        //@}
        Real cashPayoff() const { return cashPayoff_;}
      protected:
        Real cashPayoff_;
    };

    //! Binary gap payoff
    /*! This payoff is equivalent to being a) long a PlainVanillaPayoff at
        the first strike (same Call/Put type) and b) short a
        CashOrNothingPayoff at the first strike (same Call/Put type) with
        cash payoff equal to the difference between the second and the first
        strike.
        \warning this payoff can be negative depending on the strikes
    */
    class GapPayoff : public StrikedTypePayoff {
      public:
        GapPayoff(Option::Type type,
                  Real strike,
                  Real secondStrike) // a.k.a. payoff strike
        : StrikedTypePayoff(type, strike), secondStrike_(secondStrike) {}
        //! \name Payoff interface
        //@{
        std::string name() const override { return "Gap"; }
        std::string description() const override;
        Real operator()(Real price) const override;
        void accept(AcyclicVisitor&) override;
        //@}
        Real secondStrike() const { return secondStrike_;}
      protected:
        Real secondStrike_;
    };

    //! Binary supershare and superfund payoffs

    //! Binary superfund payoff
    /*! Superfund sometimes also called "supershare", which can lead to ambiguity; within QuantLib
        the terms supershare and superfund are used consistently according to the definitions in
        Bloomberg OVX function's help pages.
    */
    /*! This payoff is equivalent to being (1/lowerstrike) a) long (short) an AssetOrNothing
        Call (Put) at the lower strike and b) short (long) an AssetOrNothing
        Call (Put) at the higher strike
    */
    class SuperFundPayoff : public StrikedTypePayoff {
      public:
        SuperFundPayoff(Real strike,
                        Real secondStrike)
        : StrikedTypePayoff(Option::Call, strike),
          secondStrike_(secondStrike) {
            QL_REQUIRE(strike>0.0,
                       "strike (" <<  strike << ") must be "
                       "positive");
            QL_REQUIRE(secondStrike>strike,
                       "second strike (" <<  secondStrike << ") must be "
                       "higher than first strike (" << strike << ")");
        }
        //! \name Payoff interface
        //@{
        std::string name() const override { return "SuperFund"; }
        Real operator()(Real price) const override;
        void accept(AcyclicVisitor&) override;
        //@}
        Real secondStrike() const { return secondStrike_;}
      protected:
        Real secondStrike_;
    };

    //! Binary supershare payoff
    class SuperSharePayoff : public StrikedTypePayoff {
      public:
        SuperSharePayoff(Real strike,
                         Real secondStrike,
                         Real cashPayoff)
        : StrikedTypePayoff(Option::Call, strike),
          secondStrike_(secondStrike),
          cashPayoff_(cashPayoff){
              QL_REQUIRE(secondStrike>strike,
              "second strike (" <<  secondStrike << ") must be "
              "higher than first strike (" << strike << ")");}

        //! \name Payoff interface
        //@{
        std::string name() const override { return "SuperShare"; }
        std::string description() const override;
        Real operator()(Real price) const override;
        void accept(AcyclicVisitor&) override;
        //@}
        Real secondStrike() const { return secondStrike_;}
        Real cashPayoff() const { return cashPayoff_;}
      protected:
        Real secondStrike_;
        Real cashPayoff_;
    };
}

#endif
]]></document_content>
  </document>
  <document index="103">
    <source>quantobarrieroption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Paul Farrington

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/quantobarrieroption.hpp>

namespace QuantLib {

    QuantoBarrierOption::QuantoBarrierOption(
                        Barrier::Type barrierType,
                        Real barrier,
                        Real rebate,
                        const ext::shared_ptr<StrikedTypePayoff>& payoff,
                        const ext::shared_ptr<Exercise>& exercise)
    : BarrierOption(barrierType, barrier, rebate, payoff, exercise) {}

    Real QuantoBarrierOption::qvega() const {
        calculate();
        QL_REQUIRE(qvega_ != Null<Real>(),
                   "exchange rate vega calculation failed");
        return qvega_;
    }

    Real QuantoBarrierOption::qrho() const {
        calculate();
        QL_REQUIRE(qrho_ != Null<Real>(),
                   "foreign interest rate rho calculation failed");
        return qrho_;
    }

    Real QuantoBarrierOption::qlambda() const {
        calculate();
        QL_REQUIRE(qlambda_ != Null<Real>(),
                   "quanto correlation sensitivity calculation failed");
        return qlambda_;
    }

    void QuantoBarrierOption::setupExpired() const {
        BarrierOption::setupExpired();
        qvega_ = qrho_ = qlambda_ = 0.0;
    }

    void QuantoBarrierOption::fetchResults(
                                      const PricingEngine::results* r) const {
        BarrierOption::fetchResults(r);
        const auto* quantoResults = dynamic_cast<const QuantoBarrierOption::results*>(r);
        QL_ENSURE(quantoResults != nullptr, "no quanto results returned from pricing engine");
        qrho_    = quantoResults->qrho;
        qvega_   = quantoResults->qvega;
        qlambda_ = quantoResults->qlambda;
    }

}

]]></document_content>
  </document>
  <document index="104">
    <source>quantobarrieroption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2008 Paul Farrington

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file quantobarrieroption.hpp
    \brief Quanto version of a barrier option
*/

#ifndef quantlib_quanto_barrier_option_hpp
#define quantlib_quanto_barrier_option_hpp

#include <ql/instruments/quantovanillaoption.hpp>
#include <ql/instruments/barrieroption.hpp>

namespace QuantLib {

    //! Quanto version of a barrier option
    /*! \ingroup instruments */
    class QuantoBarrierOption : public BarrierOption {
      public:
        typedef BarrierOption::arguments arguments;
        typedef QuantoOptionResults<BarrierOption::results> results;
        QuantoBarrierOption(
                        Barrier::Type barrierType,
                        Real barrier,
                        Real rebate,
                        const ext::shared_ptr<StrikedTypePayoff>& payoff,
                        const ext::shared_ptr<Exercise>& exercise
            );
        //! \name greeks
        //@{
        Real qvega() const;
        Real qrho() const;
        Real qlambda() const;
        //@}
        void fetchResults(const PricingEngine::results*) const override;

      private:
        void setupExpired() const override;
        // results
        mutable Real qvega_, qrho_, qlambda_;
    };

}


#endif

]]></document_content>
  </document>
  <document index="105">
    <source>quantoforwardvanillaoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/quantoforwardvanillaoption.hpp>

namespace QuantLib {

    QuantoForwardVanillaOption::QuantoForwardVanillaOption(
                           Real moneyness,
                           const Date& resetDate,
                           const ext::shared_ptr<StrikedTypePayoff>& payoff,
                           const ext::shared_ptr<Exercise>& exercise)
    : ForwardVanillaOption(moneyness, resetDate, payoff, exercise) {}

    Real QuantoForwardVanillaOption::qvega() const {
        calculate();
        QL_REQUIRE(qvega_ != Null<Real>(),
                   "exchange rate vega calculation failed");
        return qvega_;
    }

    Real QuantoForwardVanillaOption::qrho() const {
        calculate();
        QL_REQUIRE(qrho_ != Null<Real>(),
                   "foreign interest rate rho calculation failed");
        return qrho_;
    }

    Real QuantoForwardVanillaOption::qlambda() const {
        calculate();
        QL_REQUIRE(qlambda_ != Null<Real>(),
                   "quanto correlation sensitivity calculation failed");
        return qlambda_;
    }

    void QuantoForwardVanillaOption::setupExpired() const {
        ForwardVanillaOption::setupExpired();
        qvega_ = qrho_ = qlambda_ = 0.0;
    }

    void QuantoForwardVanillaOption::fetchResults(
                                      const PricingEngine::results* r) const {
        ForwardVanillaOption::fetchResults(r);
        const auto* quantoResults = dynamic_cast<const QuantoForwardVanillaOption::results*>(r);
        QL_ENSURE(quantoResults != nullptr, "no quanto results returned from pricing engine");
        qrho_    = quantoResults->qrho;
        qvega_   = quantoResults->qvega;
        qlambda_ = quantoResults->qlambda;
    }

}

]]></document_content>
  </document>
  <document index="106">
    <source>quantoforwardvanillaoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file quantoforwardvanillaoption.hpp
    \brief Quanto version of a forward vanilla option
*/

#ifndef quantlib_quanto_forward_vanilla_option_h
#define quantlib_quanto_forward_vanilla_option_h

#include <ql/instruments/quantovanillaoption.hpp>
#include <ql/instruments/forwardvanillaoption.hpp>

namespace QuantLib {

    //! Quanto version of a forward vanilla option
    /*! \ingroup instruments */
    class QuantoForwardVanillaOption : public ForwardVanillaOption {
      public:
        typedef ForwardVanillaOption::arguments arguments;
        typedef QuantoOptionResults<ForwardVanillaOption::results> results;
        QuantoForwardVanillaOption(Real moneyness,
                                   const Date& resetDate,
                                   const ext::shared_ptr<StrikedTypePayoff>&,
                                   const ext::shared_ptr<Exercise>&);
        //! \name greeks
        //@{
        Real qvega() const;
        Real qrho() const;
        Real qlambda() const;
        //@}
        void fetchResults(const PricingEngine::results*) const override;

      private:
        void setupExpired() const override;
        // results
        mutable Real qvega_, qrho_, qlambda_;
    };

}


#endif

]]></document_content>
  </document>
  <document index="107">
    <source>quantovanillaoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/quantovanillaoption.hpp>

namespace QuantLib {

    QuantoVanillaOption::QuantoVanillaOption(
                   const ext::shared_ptr<StrikedTypePayoff>& payoff,
                   const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise) {}

    Real QuantoVanillaOption::qvega() const {
        calculate();
        QL_REQUIRE(qvega_ != Null<Real>(),
                   "exchange rate vega calculation failed");
        return qvega_;
    }

    Real QuantoVanillaOption::qrho() const {
        calculate();
        QL_REQUIRE(qrho_ != Null<Real>(),
                   "foreign interest rate rho calculation failed");
        return qrho_;
    }

    Real QuantoVanillaOption::qlambda() const {
        calculate();
        QL_REQUIRE(qlambda_ != Null<Real>(),
                   "quanto correlation sensitivity calculation failed");
        return qlambda_;
    }

    void QuantoVanillaOption::setupExpired() const {
        OneAssetOption::setupExpired();
        qvega_ = qrho_ = qlambda_ = 0.0;
    }

    void QuantoVanillaOption::fetchResults(
                                      const PricingEngine::results* r) const {
        OneAssetOption::fetchResults(r);
        const auto* quantoResults = dynamic_cast<const QuantoVanillaOption::results*>(r);
        QL_ENSURE(quantoResults != nullptr, "no quanto results returned from pricing engine");
        qrho_    = quantoResults->qrho;
        qvega_   = quantoResults->qvega;
        qlambda_ = quantoResults->qlambda;
    }

}

]]></document_content>
  </document>
  <document index="108">
    <source>quantovanillaoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2002, 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file quantovanillaoption.hpp
    \brief Quanto version of a vanilla option
*/

#ifndef quantlib_quanto_vanilla_option_hpp
#define quantlib_quanto_vanilla_option_hpp

#include <ql/instruments/oneassetoption.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    //! %Results from quanto option calculation
    template<class ResultsType>
    class QuantoOptionResults : public ResultsType {
      public:
        QuantoOptionResults() { reset() ;}
        void reset() override {
            ResultsType::reset();
            qvega = qrho = qlambda = Null<Real>();
        }
        Real qvega;
        Real qrho;
        Real qlambda;
    };

    //! quanto version of a vanilla option
    /*! \ingroup instruments */
    class QuantoVanillaOption : public OneAssetOption {
      public:
        typedef OneAssetOption::arguments arguments;
        typedef QuantoOptionResults<OneAssetOption::results> results;
        typedef GenericEngine<arguments, results> engine;
        QuantoVanillaOption(const ext::shared_ptr<StrikedTypePayoff>&,
                            const ext::shared_ptr<Exercise>&);
        //! \name greeks
        //@{
        Real qvega() const;
        Real qrho() const;
        Real qlambda() const;
        //@}
        void fetchResults(const PricingEngine::results*) const override;

      private:
        void setupExpired() const override;
        // results
        mutable Real qvega_, qrho_, qlambda_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="109">
    <source>stickyratchet.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2007 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/stickyratchet.hpp>

namespace QuantLib {

    // Double Sticky/Ratchet payoffs
    Real DoubleStickyRatchetPayoff::operator()(Real forward) const {
        QL_REQUIRE((std::fabs(type1_)==1.0 || type1_==0.0),
            "unknown/illegal type1 value (only 0.0 and +/-1,0 are allowed))");
        QL_REQUIRE((std::fabs(type2_)==1.0 || type2_==0.0),
            "unknown/illegal type2 value(only 0.0 and +/-1,0 are allowed)");
        Real swaplet = gearing3_ * forward + spread3_;
        Real effStrike1 = gearing1_ * initialValue1_ + spread1_;
        Real effStrike2 = gearing2_ * initialValue2_ + spread2_;
        Real effStrike3 = type1_*type2_*std::max<Real>(type2_*(swaplet-effStrike2),0.0);
        Real price = accrualFactor_ * (swaplet -
                    type1_*std::max<Real>(type1_*(swaplet-effStrike1),effStrike3));
        return price;
    }

    std::string DoubleStickyRatchetPayoff::name() const {
        return "DoubleStickyRatchetPayoff";
    }

    std::string DoubleStickyRatchetPayoff::description() const {
        std::ostringstream result;
        result << name();
        return result.str();
    }

    void DoubleStickyRatchetPayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<DoubleStickyRatchetPayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }

/*---------------------------------------------------------------------------

    // Old code for single sticky/ratchet payoffs,
    // superated by DoubleStickyRatchetPayoff class above

    // Single Sticky/Ratchet payoffs
    Real StickyRatchetPayoff::operator()(Real forward) const {
        QL_REQUIRE(abs(type_)==1.0, "unknown/illegal option type");
        Real swaplet = gearing2_ * forward + spread2_;
        Real effStrike = gearing2_ * initialValue_ + spread2_;
        Real price = accrualFactor_ * (swaplet -
                    type_*std::max<Real>(type_*(swaplet-effStrike),0.0));
        return price;
    }

    std::string StickyRatchetPayoff::description() const {
        std::ostringstream result;
        result << name();
        return result.str();
    }

    void StickyRatchetPayoff::accept(AcyclicVisitor& v) {
        Visitor<StickyRatchetPayoff>* v1 =
            dynamic_cast<Visitor<StickyRatchetPayoff>*>(&v);
        if (v1 != 0)
            v1->visit(*this);
        else
            Payoff::accept(v);
    }
-----------------------------------------------------------------------------*/

}
]]></document_content>
  </document>
  <document index="110">
    <source>stickyratchet.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007 Marco Bianchetti
 Copyright (C) 2007 Giorgio Facchinetti

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file stickyratchet.hpp
    \brief Payoffs for double nested options of sticky or ratchet type
*/

#ifndef quantlib_stickyratchet_hpp
#define quantlib_stickyratchet_hpp

#include <ql/option.hpp>
#include <ql/payoff.hpp>

namespace QuantLib {
    
    class AcyclicVisitor;
    //! Intermediate class for single/double sticky/ratchet payoffs.
    //  initialValues can be a (forward) rate or a coupon/accrualFactor 
    class DoubleStickyRatchetPayoff : public Payoff {
      public:
        DoubleStickyRatchetPayoff(Real type1, Real type2,
                            Real gearing1, Real gearing2, Real gearing3,
                            Real spread1, Real spread2, Real spread3,
                            Real initialValue1, Real initialValue2, 
                            Real accrualFactor) 
        : type1_(type1), type2_(type2), 
          gearing1_(gearing1), gearing2_(gearing2), gearing3_(gearing3),
          spread1_(spread1), spread2_(spread2), spread3_(spread3),
          initialValue1_(initialValue1), initialValue2_(initialValue2), 
          accrualFactor_(accrualFactor) {}
        //! \name Payoff interface
        //@{
        std::string name() const override;
        Real operator()(Real forward) const override;
        std::string description() const override;
        void accept(AcyclicVisitor&) override;
        //@}
      protected:
        Real type1_ ,type2_;
        Real gearing1_, gearing2_, gearing3_;
        Real spread1_, spread2_, spread3_;
        Real initialValue1_, initialValue2_, accrualFactor_;
    };

    //! Ratchet payoff (single option)
    class RatchetPayoff : public DoubleStickyRatchetPayoff {
      public:
         RatchetPayoff(Real gearing1, Real gearing2,
                       Real spread1, Real spread2,
                       Real initialValue, Real accrualFactor)
        : DoubleStickyRatchetPayoff(-1.0, 0.0,
                            gearing1, 0.0, gearing2,
                            spread1, 0.0, spread2,
                            initialValue, 0.0, 
                            accrualFactor) {}
        //! \name Payoff interface
        //@{
         std::string name() const override { return "Ratchet"; }
         //@}
    };    

    //! Sticky payoff (single option)
    class StickyPayoff : public DoubleStickyRatchetPayoff {
      public:
         StickyPayoff(Real gearing1, Real gearing2,
                       Real spread1, Real spread2,
                       Real initialValue, Real accrualFactor)
        : DoubleStickyRatchetPayoff(+1.0, 0.0,
                            gearing1, 0.0, gearing2,
                            spread1, 0.0, spread2,
                            initialValue, 0.0, 
                            accrualFactor) {}
        //! \name Payoff interface
        //@{
         std::string name() const override { return "Sticky"; }
         //@}
    };

    //! RatchetMax payoff (double option)
    class RatchetMaxPayoff : public DoubleStickyRatchetPayoff {
      public:
         RatchetMaxPayoff(Real gearing1, Real gearing2, Real gearing3,
                          Real spread1, Real spread2, Real spread3,
                          Real initialValue1, Real initialValue2, 
                          Real accrualFactor)
        : DoubleStickyRatchetPayoff(-1.0, -1.0,
                                    gearing1, gearing2, gearing3,
                                    spread1, spread2, spread3,
                                    initialValue1, initialValue2, 
                                    accrualFactor) {}
        //! \name Payoff interface
        //@{
         std::string name() const override { return "RatchetMax"; }
         //@}
    };    

    //! RatchetMin payoff (double option)
    class RatchetMinPayoff : public DoubleStickyRatchetPayoff {
      public:
         RatchetMinPayoff(Real gearing1, Real gearing2, Real gearing3,
                          Real spread1, Real spread2, Real spread3,
                          Real initialValue1, Real initialValue2, 
                          Real accrualFactor)
        : DoubleStickyRatchetPayoff(-1.0, +1.0,
                                    gearing1, gearing2, gearing3,
                                    spread1, spread2, spread3,
                                    initialValue1, initialValue2, 
                                    accrualFactor) {}
        //! \name Payoff interface
        //@{
         std::string name() const override { return "RatchetMin"; }
         //@}
    };    

    //! StickyMax payoff (double option)
    class StickyMaxPayoff : public DoubleStickyRatchetPayoff {
      public:
         StickyMaxPayoff(Real gearing1, Real gearing2, Real gearing3,
                          Real spread1, Real spread2, Real spread3,
                          Real initialValue1, Real initialValue2, 
                          Real accrualFactor)
        : DoubleStickyRatchetPayoff(+1.0, -1.0,
                                    gearing1, gearing2, gearing3,
                                    spread1, spread2, spread3,
                                    initialValue1, initialValue2, 
                                    accrualFactor) {}
        //! \name Payoff interface
        //@{
         std::string name() const override { return "StickyMax"; }
         //@}
    };    

    //! StickyMin payoff (double option)
    class StickyMinPayoff : public DoubleStickyRatchetPayoff {
      public:
         StickyMinPayoff(Real gearing1, Real gearing2, Real gearing3,
                          Real spread1, Real spread2, Real spread3,
                          Real initialValue1, Real initialValue2, 
                          Real accrualFactor)
        : DoubleStickyRatchetPayoff(+1.0, +1.0,
                                    gearing1, gearing2, gearing3,
                                    spread1, spread2, spread3,
                                    initialValue1, initialValue2, 
                                    accrualFactor) {}
        //! \name Payoff interface
        //@{
         std::string name() const override { return "StickyMin"; }
         //@}
    };    

/*---------------------------------------------------------------------------------
    // Old code for single sticky/ratchet payoffs, 
    // superated by DoubleStickyRatchetPayoff class above

    //! Intermediate class for sticky/ratchet payoffs
    //  initialValue can be a (forward) rate or a coupon/accrualFactor 
    class StickyRatchetPayoff : public Payoff {
      public:
        StickyRatchetPayoff(Real type,
                            Real gearing1, Real gearing2,
                            Real spread1, Real spread2,
                            Real initialValue, Real accrualFactor) 
        : type_(type), gearing1_(gearing1), gearing2_(gearing2), 
          spread1_(spread1), spread2_(spread2), initialValue_(initialValue),
          accrualFactor_(accrualFactor) {}
        //! \name Payoff interface
        //@{
        Real operator()(Real forward) const;
        std::string description() const;
        virtual void accept(AcyclicVisitor&);
        //@}
      protected:
        Real type_;
        Real gearing1_, gearing2_;
        Real spread1_, spread2_;
        Real initialValue_, accrualFactor_;
    };

    //! Ratchet_2 payoff
    class RatchetPayoff_2 : public StickyRatchetPayoff {
      public:
         RatchetPayoff_2(Real gearing1, Real gearing2,
                       Real spread1, Real spread2,
                       Real initialValue, Real accrualFactor)
        : StickyRatchetPayoff(-1,
                              gearing1, gearing2,
                              spread1, spread2,
                              initialValue, accrualFactor) {}
        //! \name Payoff interface
        //@{
        std::string name() const { return "Ratchet";}
        //@}
    };

    //! Sticky_2 payoff
    class StickyPayoff_2 : public StickyRatchetPayoff {
      public:
         StickyPayoff_2(Real gearing1, Real gearing2,
                       Real spread1, Real spread2,
                       Real initialValue, Real accrualFactor) 
        : StickyRatchetPayoff(+1,
                              gearing1, gearing2,
                              spread1, spread2,
                              initialValue, accrualFactor) {}
        //! \name Payoff interface
        //@{
        std::string name() const { return "Sticky";}
        //@}
    };
-----------------------------------------------------------------------------*/

}

#endif
]]></document_content>
  </document>
  <document index="111">
    <source>stock.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/stock.hpp>
#include <utility>

namespace QuantLib {

    Stock::Stock(Handle<Quote> quote) : quote_(std::move(quote)) { registerWith(quote_); }

    void Stock::performCalculations() const {
        QL_REQUIRE(!quote_.empty(), "null quote set");
        NPV_ = quote_->value();
    }

}

]]></document_content>
  </document>
  <document index="112">
    <source>stock.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file stock.hpp
    \brief concrete stock class
*/

#ifndef quantlib_stock_hpp
#define quantlib_stock_hpp

#include <ql/instrument.hpp>
#include <ql/quote.hpp>

namespace QuantLib {

    //! Simple stock class
    /*! \ingroup instruments */
    class Stock : public Instrument {
      public:
        Stock(Handle<Quote> quote);
        bool isExpired() const override { return false; }

      protected:
        void performCalculations() const override;

      private:
        Handle<Quote> quote_;
    };

}


#endif
]]></document_content>
  </document>
  <document index="113">
    <source>swap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006, 2011 Ferdinando Ametrano
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2007, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/swap.hpp>
#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/floatingratecoupon.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ostream>

namespace QuantLib {

    Swap::Swap(const Leg& firstLeg,
               const Leg& secondLeg)
    : legs_(2), payer_(2),
      legNPV_(2, 0.0), legBPS_(2, 0.0),
      startDiscounts_(2, 0.0), endDiscounts_(2, 0.0),
      npvDateDiscount_(0.0) {
        legs_[0] = firstLeg;
        legs_[1] = secondLeg;
        payer_[0] = -1.0;
        payer_[1] =  1.0;
        for (auto& i : legs_[0])
            registerWith(i);
        for (auto& i : legs_[1])
            registerWith(i);
    }

    Swap::Swap(const std::vector<Leg>& legs,
               const std::vector<bool>& payer)
    : legs_(legs), payer_(legs.size(), 1.0),
      legNPV_(legs.size(), 0.0), legBPS_(legs.size(), 0.0),
      startDiscounts_(legs.size(), 0.0), endDiscounts_(legs.size(), 0.0),
      npvDateDiscount_(0.0) {
        QL_REQUIRE(payer.size()==legs_.size(),
                   "size mismatch between payer (" << payer.size() <<
                   ") and legs (" << legs_.size() << ")");
        for (Size j=0; j<legs_.size(); ++j) {
            if (payer[j]) payer_[j]=-1.0;
            for (auto& i : legs_[j])
                registerWith(i);
        }
    }

    Swap::Swap(Size legs)
    : legs_(legs), payer_(legs),
      legNPV_(legs, 0.0), legBPS_(legs, 0.0),
      startDiscounts_(legs, 0.0), endDiscounts_(legs, 0.0),
      npvDateDiscount_(0.0) {}


    bool Swap::isExpired() const {
        for (const auto& leg : legs_) {
            Leg::const_iterator i;
            for (i = leg.begin(); i != leg.end(); ++i)
                if (!(*i)->hasOccurred())
                    return false;
        }
        return true;
    }

    void Swap::setupExpired() const {
        Instrument::setupExpired();
        std::fill(legBPS_.begin(), legBPS_.end(), 0.0);
        std::fill(legNPV_.begin(), legNPV_.end(), 0.0);
        std::fill(startDiscounts_.begin(), startDiscounts_.end(), 0.0);
        std::fill(endDiscounts_.begin(), endDiscounts_.end(), 0.0);
        npvDateDiscount_ = 0.0;
    }

    void Swap::setupArguments(PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<Swap::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->legs = legs_;
        arguments->payer = payer_;
    }

    void Swap::fetchResults(const PricingEngine::results* r) const {
        Instrument::fetchResults(r);

        const auto* results = dynamic_cast<const Swap::results*>(r);
        QL_REQUIRE(results != nullptr, "wrong result type");

        if (!results->legNPV.empty()) {
            QL_REQUIRE(results->legNPV.size() == legNPV_.size(),
                       "wrong number of leg NPV returned");
            legNPV_ = results->legNPV;
        } else {
            std::fill(legNPV_.begin(), legNPV_.end(), Null<Real>());
        }

        if (!results->legBPS.empty()) {
            QL_REQUIRE(results->legBPS.size() == legBPS_.size(),
                       "wrong number of leg BPS returned");
            legBPS_ = results->legBPS;
        } else {
            std::fill(legBPS_.begin(), legBPS_.end(), Null<Real>());
        }

        if (!results->startDiscounts.empty()) {
            QL_REQUIRE(results->startDiscounts.size() == startDiscounts_.size(),
                       "wrong number of leg start discounts returned");
            startDiscounts_ = results->startDiscounts;
        } else {
            std::fill(startDiscounts_.begin(), startDiscounts_.end(),
                                                    Null<DiscountFactor>());
        }

        if (!results->endDiscounts.empty()) {
            QL_REQUIRE(results->endDiscounts.size() == endDiscounts_.size(),
                       "wrong number of leg end discounts returned");
            endDiscounts_ = results->endDiscounts;
        } else {
            std::fill(endDiscounts_.begin(), endDiscounts_.end(),
                                                    Null<DiscountFactor>());
        }

        if (results->npvDateDiscount != Null<DiscountFactor>()) {
            npvDateDiscount_ = results->npvDateDiscount;
        } else {
            npvDateDiscount_ = Null<DiscountFactor>();
        }
    }

    Size Swap::numberOfLegs() const { return legs_.size(); }

    Date Swap::startDate() const {
        QL_REQUIRE(!legs_.empty(), "no legs given");
        Date d = CashFlows::startDate(legs_[0]);
        for (Size j=1; j<legs_.size(); ++j)
            d = std::min(d, CashFlows::startDate(legs_[j]));
        return d;
    }

    Date Swap::maturityDate() const {
        QL_REQUIRE(!legs_.empty(), "no legs given");
        Date d = CashFlows::maturityDate(legs_[0]);
        for (Size j=1; j<legs_.size(); ++j)
            d = std::max(d, CashFlows::maturityDate(legs_[j]));
        return d;
    }

    void Swap::deepUpdate() {
        for (auto& leg : legs_) {
            for (auto& k : leg) {
                ext::shared_ptr<LazyObject> f = ext::dynamic_pointer_cast<LazyObject>(k);
                if (f != nullptr)
                    f->update();
            }
        }
        update();
    }

    void Swap::arguments::validate() const {
        QL_REQUIRE(legs.size() == payer.size(),
                   "number of legs and multipliers differ");
    }

    void Swap::results::reset() {
        Instrument::results::reset();
        legNPV.clear();
        legBPS.clear();
        startDiscounts.clear();
        endDiscounts.clear();
        npvDateDiscount = Null<DiscountFactor>();
    }

    std::ostream& operator<<(std::ostream& out, Swap::Type t) {
        switch (t) {
          case Swap::Payer:
            return out << "Payer";
          case Swap::Receiver:
            return out << "Receiver";
          default:
            QL_FAIL("unknown Swap::Type(" << Integer(t) << ")");
        }
    }

}
]]></document_content>
  </document>
  <document index="114">
    <source>swap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2006, 2011 Ferdinando Ametrano
 Copyright (C) 2007, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file swap.hpp
    \brief Interest rate swap
*/

#ifndef quantlib_swap_hpp
#define quantlib_swap_hpp

#include <ql/instrument.hpp>
#include <ql/cashflow.hpp>
#include <iosfwd>

namespace QuantLib {

    //! Interest rate swap
    /*! The cash flows belonging to the first leg are paid;
        the ones belonging to the second leg are received.

        \ingroup instruments
    */
    class Swap : public Instrument {
      public:
        /*! In most cases, the swap has just two legs and can be
            defined as receiver or payer.

            Its type is usually defined with respect to the leg paying
            a fixed rate; derived swap classes will document any
            exceptions to the rule.
        */
        enum Type { Receiver = -1, Payer = 1 };

        class arguments;
        class results;
        class engine;
        //! \name Constructors
        //@{
        /*! The cash flows belonging to the first leg are paid;
            the ones belonging to the second leg are received.
        */
        Swap(const Leg& firstLeg,
             const Leg& secondLeg);
        /*! Multi leg constructor. */
        Swap(const std::vector<Leg>& legs,
             const std::vector<bool>& payer);
        //@}
        //! \name Observable interface
        //@{
        void deepUpdate() override;
        //@}
        //! \name Instrument interface
        //@{
        bool isExpired() const override;
        void setupArguments(PricingEngine::arguments*) const override;
        void fetchResults(const PricingEngine::results*) const override;
        //@}
        //! \name Additional interface
        //@{
        Size numberOfLegs() const;
        Date startDate() const;
        Date maturityDate() const;
        Real legBPS(Size j) const {
            QL_REQUIRE(j<legs_.size(), "leg# " << j << " doesn't exist!");
            calculate();
            QL_REQUIRE(legBPS_[j] != Null<Real>(), "result not available");
            return legBPS_[j];
        }
        Real legNPV(Size j) const {
            QL_REQUIRE(j<legs_.size(), "leg #" << j << " doesn't exist!");
            calculate();
            QL_REQUIRE(legNPV_[j] != Null<Real>(), "result not available");
            return legNPV_[j];
        }
        DiscountFactor startDiscounts(Size j) const {
            QL_REQUIRE(j<legs_.size(), "leg #" << j << " doesn't exist!");
            calculate();
            QL_REQUIRE(startDiscounts_[j] != Null<Real>(), "result not available");
            return startDiscounts_[j];
        }
        DiscountFactor endDiscounts(Size j) const {
            QL_REQUIRE(j<legs_.size(), "leg #" << j << " doesn't exist!");
            calculate();
            QL_REQUIRE(endDiscounts_[j] != Null<Real>(), "result not available");
            return endDiscounts_[j];
        }
        DiscountFactor npvDateDiscount() const {
            calculate();
            QL_REQUIRE(npvDateDiscount_ != Null<Real>(), "result not available");
            return npvDateDiscount_;
        }
        const Leg& leg(Size j) const {
            QL_REQUIRE(j<legs_.size(), "leg #" << j << " doesn't exist!");
            return legs_[j];
        }
        bool payer(Size j) const {
            QL_REQUIRE(j<legs_.size(), "leg #" << j << " doesn't exist!");
            return payer_[j] < 0.0;
        }
        //@}
      protected:
        //! \name Constructors
        //@{
        /*! This constructor can be used by derived classes that will
            build their legs themselves.
        */
        Swap(Size legs);
        //@}
        //! \name Instrument interface
        //@{
        void setupExpired() const override;
        //@}
        // data members
        std::vector<Leg> legs_;
        std::vector<Real> payer_;
        mutable std::vector<Real> legNPV_;
        mutable std::vector<Real> legBPS_;
        mutable std::vector<DiscountFactor> startDiscounts_, endDiscounts_;
        mutable DiscountFactor npvDateDiscount_;
    };


    class Swap::arguments : public virtual PricingEngine::arguments {
      public:
        std::vector<Leg> legs;
        std::vector<Real> payer;
        void validate() const override;
    };

    class Swap::results : public Instrument::results {
      public:
        std::vector<Real> legNPV;
        std::vector<Real> legBPS;
        std::vector<DiscountFactor> startDiscounts, endDiscounts;
        DiscountFactor npvDateDiscount;
        void reset() override;
    };

    class Swap::engine : public GenericEngine<Swap::arguments,
                                              Swap::results> {};

    std::ostream& operator<<(std::ostream& out, Swap::Type t);

}

#endif
]]></document_content>
  </document>
  <document index="115">
    <source>swaption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2006 Cristina Duminuco
 Copyright (C) 2006 Marco Bianchetti
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2014 Ferdinando Ametrano
 Copyright (C) 2016, 2018 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/exercise.hpp>
#include <ql/instruments/swaption.hpp>
#include <ql/math/solvers1d/newtonsafe.hpp>
#include <ql/pricingengines/swaption/blackswaptionengine.hpp>
#include <ql/quotes/simplequote.hpp>
#include <ql/shared_ptr.hpp>
#include <utility>

namespace QuantLib {

    namespace {

        class ImpliedSwaptionVolHelper {
          public:
            ImpliedSwaptionVolHelper(const Swaption&,
                                     Handle<YieldTermStructure> discountCurve,
                                     Real targetValue,
                                     Real displacement,
                                     VolatilityType type);
            Real operator()(Volatility x) const;
            Real derivative(Volatility x) const;
          private:
            ext::shared_ptr<PricingEngine> engine_;
            Handle<YieldTermStructure> discountCurve_;
            Real targetValue_;
            ext::shared_ptr<SimpleQuote> vol_;
            const Instrument::results* results_;
        };

        ImpliedSwaptionVolHelper::ImpliedSwaptionVolHelper(const Swaption& swaption,
                                                           Handle<YieldTermStructure> discountCurve,
                                                           Real targetValue,
                                                           Real displacement,
                                                           VolatilityType type)
        : discountCurve_(std::move(discountCurve)), targetValue_(targetValue),
          vol_(ext::make_shared<SimpleQuote>(-1.0)) {

            // vol_ is set an implausible value, so that calculation is forced
            // at first ImpliedSwaptionVolHelper::operator()(Volatility x) call

            Handle<Quote> h(vol_);

            switch (type) {
            case ShiftedLognormal:
                engine_ = ext::make_shared<BlackSwaptionEngine>(
                    discountCurve_, h, Actual365Fixed(), displacement);
                break;
            case Normal:
                engine_ = ext::make_shared<BachelierSwaptionEngine>(
                    discountCurve_, h, Actual365Fixed());
                break;
            default:
                QL_FAIL("unknown VolatilityType (" << type << ")");
                break;
            }
            swaption.setupArguments(engine_->getArguments());
            results_ = dynamic_cast<const Instrument::results *>(
                engine_->getResults());
        }

        Real ImpliedSwaptionVolHelper::operator()(Volatility x) const {
            if (x!=vol_->value()) {
                vol_->setValue(x);
                engine_->calculate();
            }
            return results_->value-targetValue_;
        }

        Real ImpliedSwaptionVolHelper::derivative(Volatility x) const {
            if (x!=vol_->value()) {
                vol_->setValue(x);
                engine_->calculate();
            }
            auto vega_ = results_->additionalResults.find("vega");
            QL_REQUIRE(vega_ != results_->additionalResults.end(),
                       "vega not provided");
            return boost::any_cast<Real>(vega_->second);
        }
    }

    std::ostream& operator<<(std::ostream& out,
                             Settlement::Type t) {
        switch (t) {
          case Settlement::Physical:
            return out << "Delivery";
          case Settlement::Cash:
            return out << "Cash";
          default:
            QL_FAIL("unknown Settlement::Type(" << Integer(t) << ")");
        }
    }

    std::ostream& operator<<(std::ostream& out, Settlement::Method m) {
        switch (m) {
        case Settlement::PhysicalOTC:
            return out << "PhysicalOTC";
        case Settlement::PhysicalCleared:
            return out << "PhysicalCleared";
        case Settlement::CollateralizedCashPrice:
            return out << "CollateralizedCashPrice";
        case Settlement::ParYieldCurve:
            return out << "ParYieldCurve";
        default:
            QL_FAIL("unknown Settlement::Method(" << Integer(m) << ")");
        }
    }

    Swaption::Swaption(ext::shared_ptr<VanillaSwap> swap,
                       const ext::shared_ptr<Exercise>& exercise,
                       Settlement::Type delivery,
                       Settlement::Method settlementMethod)
    : Option(ext::shared_ptr<Payoff>(), exercise), swap_(std::move(swap)),
      settlementType_(delivery), settlementMethod_(settlementMethod) {
        registerWith(swap_);
        registerWithObservables(swap_);
    }

    bool Swaption::isExpired() const {
        return detail::simple_event(exercise_->dates().back()).hasOccurred();
    }

    void Swaption::setupArguments(PricingEngine::arguments* args) const {

        swap_->setupArguments(args);

        auto* arguments = dynamic_cast<Swaption::arguments*>(args);

        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->swap = swap_;
        arguments->settlementType = settlementType_;
        arguments->settlementMethod = settlementMethod_;
        arguments->exercise = exercise_;
    }

    void Swaption::arguments::validate() const {
        VanillaSwap::arguments::validate();
        QL_REQUIRE(swap, "vanilla swap not set");
        QL_REQUIRE(exercise, "exercise not set");
        Settlement::checkTypeAndMethodConsistency(settlementType,
                                                  settlementMethod);
    }

    Volatility Swaption::impliedVolatility(Real targetValue,
                                           const Handle<YieldTermStructure>& d,
                                           Volatility guess,
                                           Real accuracy,
                                           Natural maxEvaluations,
                                           Volatility minVol,
                                           Volatility maxVol,
                                           VolatilityType type,
                                           Real displacement) const {
        //calculate();
        QL_REQUIRE(!isExpired(), "instrument expired");

        ImpliedSwaptionVolHelper f(*this, d, targetValue, displacement, type);
        //Brent solver;
        NewtonSafe solver;
        solver.setMaxEvaluations(maxEvaluations);
        return solver.solve(f, accuracy, guess, minVol, maxVol);
    }

    void Settlement::checkTypeAndMethodConsistency(
                                        Settlement::Type settlementType,
                                        Settlement::Method settlementMethod) {
        if (settlementType == Physical) {
            QL_REQUIRE(settlementMethod == PhysicalOTC ||
                       settlementMethod == PhysicalCleared,
                       "invalid settlement method for physical settlement");
        }
        if (settlementType == Cash) {
            QL_REQUIRE(settlementMethod == CollateralizedCashPrice ||
                       settlementMethod == ParYieldCurve,
                       "invalid settlement method for cash settlement");
        }
    }

}
]]></document_content>
  </document>
  <document index="116">
    <source>swaption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2001, 2002, 2003 Sadruddin Rejeb
 Copyright (C) 2006 Cristina Duminuco
 Copyright (C) 2006 Marco Bianchetti
 Copyright (C) 2007 StatPro Italia srl
 Copyright (C) 2014 Ferdinando Ametrano
 Copyright (C) 2016, 2018 Peter Caspers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file swaption.hpp
    \brief Swaption class
*/

#ifndef quantlib_instruments_swaption_hpp
#define quantlib_instruments_swaption_hpp

#include <ql/option.hpp>
#include <ql/instruments/vanillaswap.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/termstructures/volatility/volatilitytype.hpp>

namespace QuantLib {

    //! %settlement information
    struct Settlement {
        enum Type { Physical, Cash };
        enum Method {
            PhysicalOTC,
            PhysicalCleared,
            CollateralizedCashPrice,
            ParYieldCurve
        };
        //! check consistency of settlement type and method
        static void checkTypeAndMethodConsistency(Settlement::Type,
                                                  Settlement::Method);
    };

    std::ostream& operator<<(std::ostream& out,
                             Settlement::Type type);

    std::ostream& operator<<(std::ostream& out,
                             Settlement::Method method);

    //! %Swaption class
    /*! \ingroup instruments

        \test
        - the correctness of the returned value is tested by checking
          that the price of a payer (resp. receiver) swaption
          decreases (resp. increases) with the strike.
        - the correctness of the returned value is tested by checking
          that the price of a payer (resp. receiver) swaption
          increases (resp. decreases) with the spread.
        - the correctness of the returned value is tested by checking
          it against that of a swaption on a swap with no spread and a
          correspondingly adjusted fixed rate.
        - the correctness of the returned value is tested by checking
          it against a known good value.
        - the correctness of the returned value of cash settled swaptions
          is tested by checking the modified annuity against a value
          calculated without using the Swaption class.


        \todo add greeks and explicit exercise lag
    */
    class Swaption : public Option {
      public:
        class arguments;
        class engine;
        Swaption(ext::shared_ptr<VanillaSwap> swap,
                 const ext::shared_ptr<Exercise>& exercise,
                 Settlement::Type delivery = Settlement::Physical,
                 Settlement::Method settlementMethod = Settlement::PhysicalOTC);
        //! \name Instrument interface
        //@{
        bool isExpired() const override;
        void setupArguments(PricingEngine::arguments*) const override;
        //@}
        //! \name Inspectors
        //@{
        Settlement::Type settlementType() const { return settlementType_; }
        Settlement::Method settlementMethod() const {
            return settlementMethod_;
        }
        Swap::Type type() const { return swap_->type(); }
        const ext::shared_ptr<VanillaSwap>& underlyingSwap() const {
            return swap_;
        }
        //@}
        //! implied volatility
        Volatility impliedVolatility(
                              Real price,
                              const Handle<YieldTermStructure>& discountCurve,
                              Volatility guess,
                              Real accuracy = 1.0e-4,
                              Natural maxEvaluations = 100,
                              Volatility minVol = 1.0e-7,
                              Volatility maxVol = 4.0,
                              VolatilityType type = ShiftedLognormal,
                              Real displacement = 0.0) const;
      private:
        // arguments
        ext::shared_ptr<VanillaSwap> swap_;
        //Handle<YieldTermStructure> termStructure_;
        Settlement::Type settlementType_;
        Settlement::Method settlementMethod_;
    };

    //! %Arguments for swaption calculation
    class Swaption::arguments : public VanillaSwap::arguments,
                                public Option::arguments {
      public:
        arguments() = default;
        ext::shared_ptr<VanillaSwap> swap;
        Settlement::Type settlementType = Settlement::Physical;
        Settlement::Method settlementMethod;
        void validate() const override;
    };

    //! base class for swaption engines
    class Swaption::engine
        : public GenericEngine<Swaption::arguments, Swaption::results> {};

}

#endif
]]></document_content>
  </document>
  <document index="117">
    <source>vanillaoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/vanillaoption.hpp>
#include <ql/instruments/impliedvolatility.hpp>
#include <ql/pricingengines/vanilla/analyticeuropeanengine.hpp>
#include <ql/pricingengines/vanilla/fdblackscholesvanillaengine.hpp>
#include <ql/exercise.hpp>
#include <memory>

namespace QuantLib {

    VanillaOption::VanillaOption(
        const ext::shared_ptr<StrikedTypePayoff>& payoff,
        const ext::shared_ptr<Exercise>& exercise)
    : OneAssetOption(payoff, exercise) {}


    Volatility VanillaOption::impliedVolatility(
             Real targetValue,
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             Real accuracy,
             Size maxEvaluations,
             Volatility minVol,
             Volatility maxVol) const {

        QL_REQUIRE(!isExpired(), "option expired");

        ext::shared_ptr<SimpleQuote> volQuote(new SimpleQuote);

        ext::shared_ptr<GeneralizedBlackScholesProcess> newProcess =
            detail::ImpliedVolatilityHelper::clone(process, volQuote);

        // engines are built-in for the time being
        std::unique_ptr<PricingEngine> engine;
        switch (exercise_->type()) {
          case Exercise::European:
            engine.reset(new AnalyticEuropeanEngine(newProcess));
            break;
          case Exercise::American:
          case Exercise::Bermudan:
            engine.reset(new FdBlackScholesVanillaEngine(newProcess));
            break;
          default:
            QL_FAIL("unknown exercise type");
        }

        return detail::ImpliedVolatilityHelper::calculate(*this,
                                                          *engine,
                                                          *volQuote,
                                                          targetValue,
                                                          accuracy,
                                                          maxEvaluations,
                                                          minVol, maxVol);
    }

}

]]></document_content>
  </document>
  <document index="118">
    <source>vanillaoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2003 Ferdinando Ametrano
 Copyright (C) 2007 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vanillaoption.hpp
    \brief Vanilla option on a single asset
*/

#ifndef quantlib_vanilla_option_hpp
#define quantlib_vanilla_option_hpp

#include <ql/instruments/oneassetoption.hpp>
#include <ql/instruments/payoffs.hpp>

namespace QuantLib {

    class GeneralizedBlackScholesProcess;

    //! Vanilla option (no discrete dividends, no barriers) on a single asset
    /*! \ingroup instruments */
    class VanillaOption : public OneAssetOption {
      public:
        VanillaOption(const ext::shared_ptr<StrikedTypePayoff>&,
                      const ext::shared_ptr<Exercise>&);

        /*! \warning currently, this method returns the Black-Scholes
                     implied volatility using analytic formulas for
                     European options and a finite-difference method
                     for American and Bermudan options. It will give
                     unconsistent results if the pricing was performed
                     with any other methods (such as jump-diffusion
                     models.)

            \warning options with a gamma that changes sign (e.g.,
                     binary options) have values that are <b>not</b>
                     monotonic in the volatility. In these cases, the
                     calculation can fail and the result (if any) is
                     almost meaningless.  Another possible source of
                     failure is to have a target value that is not
                     attainable with any volatility, e.g., a target
                     value lower than the intrinsic value in the case
                     of American options.
        */
        Volatility impliedVolatility(
             Real price,
             const ext::shared_ptr<GeneralizedBlackScholesProcess>& process,
             Real accuracy = 1.0e-4,
             Size maxEvaluations = 100,
             Volatility minVol = 1.0e-7,
             Volatility maxVol = 4.0) const;
    };

}


#endif

]]></document_content>
  </document>
  <document index="119">
    <source>vanillastorageoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vanillastorageoption.hpp
    \brief vanilla storage option class
*/

#ifndef quantlib_vanilla_storage_option_hpp
#define quantlib_vanilla_storage_option_hpp

#include <ql/event.hpp>
#include <ql/exercise.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/instruments/oneassetoption.hpp>

namespace QuantLib {

    //! base option class
    class VanillaStorageOption : public OneAssetOption {
      public:
          class arguments;
          VanillaStorageOption(const ext::shared_ptr<BermudanExercise>& ex,
                               Real capacity, Real load, Real changeRate)
        : OneAssetOption(ext::shared_ptr<Payoff>(new NullPayoff), ex),
          capacity_  (capacity),
          load_      (load),
          changeRate_(changeRate) {}

          bool isExpired() const override;
          void setupArguments(PricingEngine::arguments*) const override;

        private:
          const Real capacity_;
          const Real load_;
          const Real changeRate_;
    };

    class VanillaStorageOption::arguments
        : public virtual PricingEngine::arguments {
      public:
        arguments() = default;
        void validate() const override {
            QL_REQUIRE(payoff, "no payoff given");
            QL_REQUIRE(exercise, "no exercise given");

            QL_REQUIRE(capacity > 0.0 && changeRate > 0.0 && load >= 0.0,
                      "positive capacity, load and change rate required");
            QL_REQUIRE(load <= capacity && changeRate <= capacity,
                        "illegal values load of changeRate");
        }

        Real capacity;
        Real load;
        Real changeRate;
        ext::shared_ptr<NullPayoff> payoff;
        ext::shared_ptr<BermudanExercise> exercise;
    };

    inline void VanillaStorageOption::setupArguments(
                                PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<VanillaStorageOption::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->payoff
            = ext::dynamic_pointer_cast<NullPayoff>(payoff_);
        arguments->exercise
            = ext::dynamic_pointer_cast<BermudanExercise>(exercise_);
        arguments->capacity   = capacity_;
        arguments->load       = load_;
        arguments->changeRate = changeRate_;
    }

    inline bool VanillaStorageOption::isExpired() const {
        return detail::simple_event(exercise_->lastDate()).hasOccurred();
    }
}

#endif
]]></document_content>
  </document>
  <document index="120">
    <source>vanillaswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007 StatPro Italia srl
 Copyright (C) 2007 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/iborcoupon.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/instruments/vanillaswap.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <utility>

namespace QuantLib {

    VanillaSwap::VanillaSwap(Type type,
                             Real nominal,
                             Schedule fixedSchedule,
                             Rate fixedRate,
                             DayCounter fixedDayCount,
                             Schedule floatSchedule,
                             ext::shared_ptr<IborIndex> iborIndex,
                             Spread spread,
                             DayCounter floatingDayCount,
                             boost::optional<BusinessDayConvention> paymentConvention)
    : Swap(2), type_(type), nominal_(nominal), fixedSchedule_(std::move(fixedSchedule)),
      fixedRate_(fixedRate), fixedDayCount_(std::move(fixedDayCount)),
      floatingSchedule_(std::move(floatSchedule)), iborIndex_(std::move(iborIndex)),
      spread_(spread), floatingDayCount_(std::move(floatingDayCount)) {

        if (paymentConvention) // NOLINT(readability-implicit-bool-conversion)
            paymentConvention_ = *paymentConvention;
        else
            paymentConvention_ = floatingSchedule_.businessDayConvention();

        legs_[0] = FixedRateLeg(fixedSchedule_)
            .withNotionals(nominal_)
            .withCouponRates(fixedRate_, fixedDayCount_)
            .withPaymentAdjustment(paymentConvention_);

        legs_[1] = IborLeg(floatingSchedule_, iborIndex_)
            .withNotionals(nominal_)
            .withPaymentDayCounter(floatingDayCount_)
            .withPaymentAdjustment(paymentConvention_)
            .withSpreads(spread_);
        for (Leg::const_iterator i = legs_[1].begin(); i < legs_[1].end(); ++i)
            registerWith(*i);

        switch (type_) {
          case Payer:
            payer_[0] = -1.0;
            payer_[1] = +1.0;
            break;
          case Receiver:
            payer_[0] = +1.0;
            payer_[1] = -1.0;
            break;
          default:
            QL_FAIL("Unknown vanilla-swap type");
        }
    }

    void VanillaSwap::setupArguments(PricingEngine::arguments* args) const {

        Swap::setupArguments(args);

        auto* arguments = dynamic_cast<VanillaSwap::arguments*>(args);

        if (arguments == nullptr) // it's a swap engine...
            return;

        arguments->type = type_;
        arguments->nominal = nominal_;

        const Leg& fixedCoupons = fixedLeg();

        arguments->fixedResetDates = arguments->fixedPayDates =
            std::vector<Date>(fixedCoupons.size());
        arguments->fixedCoupons = std::vector<Real>(fixedCoupons.size());

        for (Size i=0; i<fixedCoupons.size(); ++i) {
            ext::shared_ptr<FixedRateCoupon> coupon =
                ext::dynamic_pointer_cast<FixedRateCoupon>(fixedCoupons[i]);

            arguments->fixedPayDates[i] = coupon->date();
            arguments->fixedResetDates[i] = coupon->accrualStartDate();
            arguments->fixedCoupons[i] = coupon->amount();
        }

        const Leg& floatingCoupons = floatingLeg();

        arguments->floatingResetDates = arguments->floatingPayDates =
            arguments->floatingFixingDates =
            std::vector<Date>(floatingCoupons.size());
        arguments->floatingAccrualTimes =
            std::vector<Time>(floatingCoupons.size());
        arguments->floatingSpreads =
            std::vector<Spread>(floatingCoupons.size());
        arguments->floatingCoupons = std::vector<Real>(floatingCoupons.size());
        for (Size i=0; i<floatingCoupons.size(); ++i) {
            ext::shared_ptr<IborCoupon> coupon =
                ext::dynamic_pointer_cast<IborCoupon>(floatingCoupons[i]);

            arguments->floatingResetDates[i] = coupon->accrualStartDate();
            arguments->floatingPayDates[i] = coupon->date();

            arguments->floatingFixingDates[i] = coupon->fixingDate();
            arguments->floatingAccrualTimes[i] = coupon->accrualPeriod();
            arguments->floatingSpreads[i] = coupon->spread();
            try {
                arguments->floatingCoupons[i] = coupon->amount();
            } catch (Error&) {
                arguments->floatingCoupons[i] = Null<Real>();
            }
        }
    }

    Rate VanillaSwap::fairRate() const {
        calculate();
        QL_REQUIRE(fairRate_ != Null<Rate>(), "result not available");
        return fairRate_;
    }

    Spread VanillaSwap::fairSpread() const {
        calculate();
        QL_REQUIRE(fairSpread_ != Null<Spread>(), "result not available");
        return fairSpread_;
    }

    Real VanillaSwap::fixedLegBPS() const {
        calculate();
        QL_REQUIRE(legBPS_[0] != Null<Real>(), "result not available");
        return legBPS_[0];
    }

    Real VanillaSwap::floatingLegBPS() const {
        calculate();
        QL_REQUIRE(legBPS_[1] != Null<Real>(), "result not available");
        return legBPS_[1];
    }

    Real VanillaSwap::fixedLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[0] != Null<Real>(), "result not available");
        return legNPV_[0];
    }

    Real VanillaSwap::floatingLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[1] != Null<Real>(), "result not available");
        return legNPV_[1];
    }

    void VanillaSwap::setupExpired() const {
        Swap::setupExpired();
        legBPS_[0] = legBPS_[1] = 0.0;
        fairRate_ = Null<Rate>();
        fairSpread_ = Null<Spread>();
    }

    void VanillaSwap::fetchResults(const PricingEngine::results* r) const {
        static const Spread basisPoint = 1.0e-4;

        Swap::fetchResults(r);

        const auto* results = dynamic_cast<const VanillaSwap::results*>(r);
        if (results != nullptr) { // might be a swap engine, so no error is thrown
            fairRate_ = results->fairRate;
            fairSpread_ = results->fairSpread;
        } else {
            fairRate_ = Null<Rate>();
            fairSpread_ = Null<Spread>();
        }

        if (fairRate_ == Null<Rate>()) {
            // calculate it from other results
            if (legBPS_[0] != Null<Real>())
                fairRate_ = fixedRate_ - NPV_/(legBPS_[0]/basisPoint);
        }
        if (fairSpread_ == Null<Spread>()) {
            // ditto
            if (legBPS_[1] != Null<Real>())
                fairSpread_ = spread_ - NPV_/(legBPS_[1]/basisPoint);
        }
    }

    void VanillaSwap::arguments::validate() const {
        Swap::arguments::validate();
        QL_REQUIRE(nominal != Null<Real>(), "nominal null or not set");
        QL_REQUIRE(fixedResetDates.size() == fixedPayDates.size(),
                   "number of fixed start dates different from "
                   "number of fixed payment dates");
        QL_REQUIRE(fixedPayDates.size() == fixedCoupons.size(),
                   "number of fixed payment dates different from "
                   "number of fixed coupon amounts");
        QL_REQUIRE(floatingResetDates.size() == floatingPayDates.size(),
                   "number of floating start dates different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingFixingDates.size() == floatingPayDates.size(),
                   "number of floating fixing dates different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingAccrualTimes.size() == floatingPayDates.size(),
                   "number of floating accrual Times different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingSpreads.size() == floatingPayDates.size(),
                   "number of floating spreads different from "
                   "number of floating payment dates");
        QL_REQUIRE(floatingPayDates.size() == floatingCoupons.size(),
                   "number of floating payment dates different from "
                   "number of floating coupon amounts");
    }

    void VanillaSwap::results::reset() {
        Swap::results::reset();
        fairRate = Null<Rate>();
        fairSpread = Null<Spread>();
    }

}
]]></document_content>
  </document>
  <document index="121">
    <source>vanillaswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2000, 2001, 2002, 2003 RiskMap srl
 Copyright (C) 2003, 2004, 2005, 2006, 2007 StatPro Italia srl
 Copyright (C) 2006, 2008 Ferdinando Ametrano

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vanillaswap.hpp
    \brief Simple fixed-rate vs Libor swap
*/

#ifndef quantlib_vanilla_swap_hpp
#define quantlib_vanilla_swap_hpp

#include <ql/instruments/swap.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/time/schedule.hpp>
#include <boost/optional.hpp>

namespace QuantLib {

    class IborIndex;

    //! Plain-vanilla swap: fix vs floating leg
    /*! \ingroup instruments

        If no payment convention is passed, the convention of the
        floating-rate schedule is used.

        \warning if <tt>Settings::includeReferenceDateCashFlows()</tt>
                 is set to <tt>true</tt>, payments occurring at the
                 settlement date of the swap might be included in the
                 NPV and therefore affect the fair-rate and
                 fair-spread calculation. This might not be what you
                 want.

        \test
        - the correctness of the returned value is tested by checking
          that the price of a swap paying the fair fixed rate is null.
        - the correctness of the returned value is tested by checking
          that the price of a swap receiving the fair floating-rate
          spread is null.
        - the correctness of the returned value is tested by checking
          that the price of a swap decreases with the paid fixed rate.
        - the correctness of the returned value is tested by checking
          that the price of a swap increases with the received
          floating-rate spread.
        - the correctness of the returned value is tested by checking
          it against a known good value.
    */
    class VanillaSwap : public Swap {
      public:
        class arguments;
        class results;
        class engine;
        VanillaSwap(Type type,
                    Real nominal,
                    Schedule fixedSchedule,
                    Rate fixedRate,
                    DayCounter fixedDayCount,
                    Schedule floatSchedule,
                    ext::shared_ptr<IborIndex> iborIndex,
                    Spread spread,
                    DayCounter floatingDayCount,
                    boost::optional<BusinessDayConvention> paymentConvention = boost::none);
        //! \name Inspectors
        //@{
        Type type() const;
        Real nominal() const;

        const Schedule& fixedSchedule() const;
        Rate fixedRate() const;
        const DayCounter& fixedDayCount() const;

        const Schedule& floatingSchedule() const;
        const ext::shared_ptr<IborIndex>& iborIndex() const;
        Spread spread() const;
        const DayCounter& floatingDayCount() const;

        BusinessDayConvention paymentConvention() const;

        const Leg& fixedLeg() const;
        const Leg& floatingLeg() const;
        //@}

        //! \name Results
        //@{
        Real fixedLegBPS() const;
        Real fixedLegNPV() const;
        Rate fairRate() const;

        Real floatingLegBPS() const;
        Real floatingLegNPV() const;
        Spread fairSpread() const;
        //@}
        // other
        void setupArguments(PricingEngine::arguments* args) const override;
        void fetchResults(const PricingEngine::results*) const override;

      private:
        void setupExpired() const override;
        Type type_;
        Real nominal_;
        Schedule fixedSchedule_;
        Rate fixedRate_;
        DayCounter fixedDayCount_;
        Schedule floatingSchedule_;
        ext::shared_ptr<IborIndex> iborIndex_;
        Spread spread_;
        DayCounter floatingDayCount_;
        BusinessDayConvention paymentConvention_;
        // results
        mutable Rate fairRate_;
        mutable Spread fairSpread_;
    };


    //! %Arguments for simple swap calculation
    class VanillaSwap::arguments : public Swap::arguments {
      public:
        arguments() : nominal(Null<Real>()) {}
        Type type = Receiver;
        Real nominal;

        std::vector<Date> fixedResetDates;
        std::vector<Date> fixedPayDates;
        std::vector<Time> floatingAccrualTimes;
        std::vector<Date> floatingResetDates;
        std::vector<Date> floatingFixingDates;
        std::vector<Date> floatingPayDates;

        std::vector<Real> fixedCoupons;
        std::vector<Spread> floatingSpreads;
        std::vector<Real> floatingCoupons;
        void validate() const override;
    };

    //! %Results from simple swap calculation
    class VanillaSwap::results : public Swap::results {
      public:
        Rate fairRate;
        Spread fairSpread;
        void reset() override;
    };

    class VanillaSwap::engine : public GenericEngine<VanillaSwap::arguments,
                                                     VanillaSwap::results> {};


    // inline definitions

    inline Swap::Type VanillaSwap::type() const {
        return type_;
    }

    inline Real VanillaSwap::nominal() const {
        return nominal_;
    }

    inline const Schedule& VanillaSwap::fixedSchedule() const {
        return fixedSchedule_;
    }

    inline Rate VanillaSwap::fixedRate() const {
        return fixedRate_;
    }

    inline const DayCounter& VanillaSwap::fixedDayCount() const {
        return fixedDayCount_;
    }

    inline const Schedule& VanillaSwap::floatingSchedule() const {
        return floatingSchedule_;
    }

    inline const ext::shared_ptr<IborIndex>& VanillaSwap::iborIndex() const {
        return iborIndex_;
    }

    inline Spread VanillaSwap::spread() const {
        return spread_;
    }

    inline const DayCounter& VanillaSwap::floatingDayCount() const {
        return floatingDayCount_;
    }

    inline BusinessDayConvention VanillaSwap::paymentConvention() const {
        return paymentConvention_;
    }

    inline const Leg& VanillaSwap::fixedLeg() const {
        return legs_[0];
    }

    inline const Leg& VanillaSwap::floatingLeg() const {
        return legs_[1];
    }

}

#endif
]]></document_content>
  </document>
  <document index="122">
    <source>vanillaswingoption.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010, 2011 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vanillaswingoption.cpp
    \brief vanilla swing option class
*/


#include <ql/event.hpp>
#include <ql/instruments/vanillaswingoption.hpp>

namespace QuantLib {

    namespace {
        const Size secPerDay = 24U * 3600U;

        std::pair<std::vector<Date>, std::vector<Size> >
            createDateTimes(const Date& from, const Date& to, Size stepSize) {

            std::vector<Size> secs;
            std::vector<Date> dates;

            Date iterDate = from;
            Size iterStepSize = 0U;

            while (iterDate <= to) {
                dates.push_back(iterDate);
                secs.push_back(iterStepSize);

                iterStepSize+=stepSize;
                if (iterStepSize >= secPerDay) {
                    iterDate+=1L;
                    iterStepSize%=secPerDay;
                }
            }

            return std::pair<std::vector<Date>,std::vector<Size> >(dates, secs);
        }
    }

    SwingExercise::SwingExercise(const std::vector<Date>& dates, const std::vector<Size>& seconds)
    : BermudanExercise(dates),
      seconds_(seconds.empty() ? std::vector<Size>(dates.size(), 0U) : seconds) {
        QL_REQUIRE(dates_.size() == seconds_.size(),
                   "dates and seconds must have the same size");
        for (Size i=0; i < dates_.size(); ++i) {
            QL_REQUIRE(seconds_[i] < secPerDay,
                       "a date can not have more than 24*3600 seconds");
            if (i > 0) {
                QL_REQUIRE(dates_[i-1] < dates_[i]
                           || (dates_[i-1] == dates_[i]
                               && seconds_[i-1] < seconds_[i]),
                           "date times must be sorted");
            }
        }
    }


    SwingExercise::SwingExercise(const Date& from,
                                 const Date& to, Size stepSizeSecs)
    : BermudanExercise(createDateTimes(from, to, stepSizeSecs).first),
      seconds_(createDateTimes(from, to, stepSizeSecs).second) {
    }

    const std::vector<Size>& SwingExercise::seconds() const { return seconds_; }

    std::vector<Time> SwingExercise::exerciseTimes(const DayCounter& dc,
                                                   const Date& refDate) const {
        std::vector<Time> exerciseTimes;
        exerciseTimes.reserve(dates().size());
        for (Size i=0; i<dates().size(); ++i) {
            Time t = dc.yearFraction(refDate, dates()[i]);

            const Time dt = dc.yearFraction(refDate, dates()[i] + Period(1U, Days)) - t;

            t += dt*seconds()[i]/(24*3600.);

            QL_REQUIRE(t >= 0, "exercise dates must not contain past date");
            exerciseTimes.push_back(t);
        }

        return exerciseTimes;
    }

    Real VanillaForwardPayoff::operator()(Real price) const {
        switch (type_) {
          case Option::Call:
            return price-strike_;
          case Option::Put:
            return strike_-price;
          default:
            QL_FAIL("unknown/illegal option type");
        }
    }

    void VanillaForwardPayoff::accept(AcyclicVisitor& v) {
        auto* v1 = dynamic_cast<Visitor<VanillaForwardPayoff>*>(&v);
        if (v1 != nullptr)
            v1->visit(*this);
        else
            StrikedTypePayoff::accept(v);
    }


    void VanillaSwingOption::arguments::validate() const {
        QL_REQUIRE(payoff, "no payoff given");
        QL_REQUIRE(exercise, "no exercise given");

        QL_REQUIRE(minExerciseRights <= maxExerciseRights,
                   "minExerciseRights <= maxExerciseRights");
        QL_REQUIRE(exercise->dates().size() >= maxExerciseRights,
                   "number of exercise rights exceeds "
                   "number of exercise dates");
    }

    void VanillaSwingOption::setupArguments(
                            PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<VanillaSwingOption::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->payoff
            = ext::dynamic_pointer_cast<StrikedTypePayoff>(payoff_);
        arguments->exercise
            = ext::dynamic_pointer_cast<SwingExercise>(exercise_);
        arguments->minExerciseRights = minExerciseRights_;
        arguments->maxExerciseRights = maxExerciseRights_;
    }

    bool VanillaSwingOption::isExpired() const {
        return detail::simple_event(exercise_->lastDate()).hasOccurred();
    }
}
]]></document_content>
  </document>
  <document index="123">
    <source>vanillaswingoption.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2010 Klaus Spanderen

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file vanillaswingoption.hpp
    \brief vanilla swing option class
*/

#ifndef quantlib_vanilla_swing_option_hpp
#define quantlib_vanilla_swing_option_hpp

#include <ql/exercise.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/instruments/oneassetoption.hpp>

namespace QuantLib {

    //! Swing exercise
    /*! A Swing option can only be exercised at a set of fixed date times
    */
    class SwingExercise : public BermudanExercise {
      public:
        explicit SwingExercise(const std::vector<Date>& dates,
                               const std::vector<Size>& seconds = std::vector<Size>());
        SwingExercise(const Date& from, const Date& to, Size stepSizeSecs);

        const std::vector<Size>& seconds() const;

        std::vector<Time> exerciseTimes(const DayCounter& dc,
                                        const Date& refDate) const;

      private:
        const std::vector<Size> seconds_;
    };

    class VanillaForwardPayoff : public StrikedTypePayoff {
      public:
        VanillaForwardPayoff(Option::Type type, Real strike)
          : StrikedTypePayoff(type, strike) {}

        std::string name() const override { return "ForwardTypePayoff"; }
        Real operator()(Real price) const override;
        void accept(AcyclicVisitor&) override;
    };

    //! base option class
    class VanillaSwingOption : public OneAssetOption {
      public:
          class arguments;
          VanillaSwingOption(const ext::shared_ptr<Payoff>& payoff,
                             const ext::shared_ptr<SwingExercise>& ex,
                             Size minExerciseRights, Size maxExerciseRights)
        : OneAssetOption(payoff, ex),
          minExerciseRights_(minExerciseRights),
          maxExerciseRights_(maxExerciseRights) {}

          bool isExpired() const override;
          void setupArguments(PricingEngine::arguments*) const override;

        private:
          const Size minExerciseRights_, maxExerciseRights_;
    };

    class VanillaSwingOption::arguments 
        : public virtual PricingEngine::arguments {
      public:
        arguments() = default;
        void validate() const override;

        Size minExerciseRights, maxExerciseRights;
        ext::shared_ptr<StrikedTypePayoff> payoff;
        ext::shared_ptr<SwingExercise> exercise;
    };
}

#endif
]]></document_content>
  </document>
  <document index="124">
    <source>varianceswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2007, 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

#include <ql/instruments/varianceswap.hpp>
#include <ql/event.hpp>

namespace QuantLib {

    VarianceSwap::VarianceSwap(
                          Position::Type position,
                          Real strike,
                          Real notional,
                          const Date& startDate,
                          const Date& maturityDate)
    : position_(position), strike_(strike), notional_(notional),
      startDate_(startDate), maturityDate_(maturityDate) {}

    Real VarianceSwap::variance() const {
        calculate();
        QL_REQUIRE(variance_ != Null<Real>(), "result not available");
        return variance_;
    }

    void VarianceSwap::setupExpired() const {
        Instrument::setupExpired();
        variance_ = Null<Real>();
    }

    void VarianceSwap::setupArguments(PricingEngine::arguments* args) const {
        auto* arguments = dynamic_cast<VarianceSwap::arguments*>(args);
        QL_REQUIRE(arguments != nullptr, "wrong argument type");

        arguments->position = position_;
        arguments->strike = strike_;
        arguments->notional = notional_;
        arguments->startDate = startDate_;
        arguments->maturityDate = maturityDate_;
    }

    void VarianceSwap::fetchResults(const PricingEngine::results* r) const {
        Instrument::fetchResults(r);
        const auto* results = dynamic_cast<const VarianceSwap::results*>(r);
        variance_ = results->variance;
    }

    void VarianceSwap::arguments::validate() const {
        QL_REQUIRE(strike != Null<Real>(), "no strike given");
        QL_REQUIRE(strike > 0.0, "negative or null strike given");
        QL_REQUIRE(notional != Null<Real>(), "no notional given");
        QL_REQUIRE(notional > 0.0, "negative or null notional given");
        QL_REQUIRE(startDate != Date(), "null start date given");
        QL_REQUIRE(maturityDate != Date(), "null maturity date given");
    }

    bool VarianceSwap::isExpired() const {
        return detail::simple_event(maturityDate_).hasOccurred();
    }

}
]]></document_content>
  </document>
  <document index="125">
    <source>varianceswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2006 Warren Chou
 Copyright (C) 2008 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file varianceswap.hpp
    \brief Variance swap
*/

#ifndef quantlib_variance_swap_hpp
#define quantlib_variance_swap_hpp

#include <ql/processes/blackscholesprocess.hpp>
#include <ql/instruments/payoffs.hpp>
#include <ql/option.hpp>
#include <ql/position.hpp>

namespace QuantLib {

    //! Variance swap
    /*! \warning This class does not manage seasoned variance swaps.

        \ingroup instruments
    */
    class VarianceSwap : public Instrument {
      public:
        class arguments;
        class results;
        class engine;
        VarianceSwap(Position::Type position,
                     Real strike,
                     Real notional,
                     const Date& startDate,
                     const Date& maturityDate);
        //! \name Instrument interface
        //@{
        bool isExpired() const override;
        //@}
        //! \name Additional interface
        //@{
        // inspectors
        Real strike() const;
        Position::Type position() const;
        Date startDate() const;
        Date maturityDate() const;
        Real notional() const;
        // results
        Real variance() const;
        //@}
        // other
        void setupArguments(PricingEngine::arguments* args) const override;
        void fetchResults(const PricingEngine::results*) const override;

      protected:
        void setupExpired() const override;
        // data members
        Position::Type position_;
        Real strike_;
        Real notional_;
        Date startDate_, maturityDate_;
        // results
        mutable Real variance_;
    };


    //! %Arguments for forward fair-variance calculation
    class VarianceSwap::arguments : public virtual PricingEngine::arguments {
      public:
        arguments() : strike(Null<Real>()), notional(Null<Real>()) {}
        void validate() const override;
        Position::Type position;
        Real strike;
        Real notional;
        Date startDate;
        Date maturityDate;
    };


    //! %Results from variance-swap calculation
    class VarianceSwap::results : public Instrument::results {
      public:
        Real variance;
        void reset() override {
            Instrument::results::reset();
            variance = Null<Real>();
        }
    };

    //! base class for variance-swap engines
    class VarianceSwap::engine :
        public GenericEngine<VarianceSwap::arguments,
                             VarianceSwap::results> {};


    // inline definitions

    inline Date VarianceSwap::startDate() const {
        return startDate_;
    }

    inline Date VarianceSwap::maturityDate() const {
        return maturityDate_;
    }

    inline Real VarianceSwap::strike() const {
        return strike_;
    }

    inline Real VarianceSwap::notional() const {
        return notional_;
    }

    inline Position::Type VarianceSwap::position() const {
        return position_;
    }

}


#endif
]]></document_content>
  </document>
  <document index="126">
    <source>yearonyearinflationswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 Chris Kenyon
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/cashflows/cashflows.hpp>
#include <ql/cashflows/cashflowvectors.hpp>
#include <ql/cashflows/couponpricer.hpp>
#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/yoyinflationcoupon.hpp>
#include <ql/indexes/inflationindex.hpp>
#include <ql/instruments/yearonyearinflationswap.hpp>
#include <ql/termstructures/yieldtermstructure.hpp>
#include <ql/time/schedule.hpp>
#include <utility>

namespace QuantLib {

    YearOnYearInflationSwap::YearOnYearInflationSwap(Type type,
                                                     Real nominal,
                                                     Schedule fixedSchedule,
                                                     Rate fixedRate,
                                                     DayCounter fixedDayCount,
                                                     Schedule yoySchedule,
                                                     ext::shared_ptr<YoYInflationIndex> yoyIndex,
                                                     const Period& observationLag,
                                                     Spread spread,
                                                     DayCounter yoyDayCount,
                                                     Calendar paymentCalendar,
                                                     BusinessDayConvention paymentConvention)
    : Swap(2), type_(type), nominal_(nominal), fixedSchedule_(std::move(fixedSchedule)),
      fixedRate_(fixedRate), fixedDayCount_(std::move(fixedDayCount)),
      yoySchedule_(std::move(yoySchedule)), yoyIndex_(std::move(yoyIndex)),
      observationLag_(observationLag), spread_(spread), yoyDayCount_(std::move(yoyDayCount)),
      paymentCalendar_(std::move(paymentCalendar)), paymentConvention_(paymentConvention) {
        // N.B. fixed leg gets its calendar from the schedule!
        Leg fixedLeg = FixedRateLeg(fixedSchedule_)
        .withNotionals(nominal_)
        .withCouponRates(fixedRate_, fixedDayCount_) // Simple compounding by default
        .withPaymentAdjustment(paymentConvention_);

        Leg yoyLeg = yoyInflationLeg(yoySchedule_, paymentCalendar_, yoyIndex_, observationLag_)
        .withNotionals(nominal_)
        .withPaymentDayCounter(yoyDayCount_)
        .withPaymentAdjustment(paymentConvention_)
        .withSpreads(spread_);

        Leg::const_iterator i;
        for (i = yoyLeg.begin(); i < yoyLeg.end(); ++i)
            registerWith(*i);

        legs_[0] = fixedLeg;
        legs_[1] = yoyLeg;
        if (type_==Payer) {
            payer_[0] = -1.0;
            payer_[1] = +1.0;
        } else {
            payer_[0] = +1.0;
            payer_[1] = -1.0;
        }
    }


     void YearOnYearInflationSwap::setupArguments(PricingEngine::arguments* args) const {

        Swap::setupArguments(args);

        auto* arguments = dynamic_cast<YearOnYearInflationSwap::arguments*>(args);

        if (arguments == nullptr) // it's a swap engine...
            return;

        arguments->type = type_;
        arguments->nominal = nominal_;

        const Leg& fixedCoupons = fixedLeg();

        arguments->fixedResetDates = arguments->fixedPayDates =
        std::vector<Date>(fixedCoupons.size());
        arguments->fixedCoupons = std::vector<Real>(fixedCoupons.size());

        for (Size i=0; i<fixedCoupons.size(); ++i) {
            ext::shared_ptr<FixedRateCoupon> coupon =
            ext::dynamic_pointer_cast<FixedRateCoupon>(fixedCoupons[i]);

            arguments->fixedPayDates[i] = coupon->date();
            arguments->fixedResetDates[i] = coupon->accrualStartDate();
            arguments->fixedCoupons[i] = coupon->amount();
        }

        const Leg& yoyCoupons = yoyLeg();

        arguments->yoyResetDates = arguments->yoyPayDates =
        arguments->yoyFixingDates =
        std::vector<Date>(yoyCoupons.size());
        arguments->yoyAccrualTimes =
        std::vector<Time>(yoyCoupons.size());
        arguments->yoySpreads =
        std::vector<Spread>(yoyCoupons.size());
        arguments->yoyCoupons = std::vector<Real>(yoyCoupons.size());
        for (Size i=0; i<yoyCoupons.size(); ++i) {
            ext::shared_ptr<YoYInflationCoupon> coupon =
            ext::dynamic_pointer_cast<YoYInflationCoupon>(yoyCoupons[i]);

            arguments->yoyResetDates[i] = coupon->accrualStartDate();
            arguments->yoyPayDates[i] = coupon->date();

            arguments->yoyFixingDates[i] = coupon->fixingDate();
            arguments->yoyAccrualTimes[i] = coupon->accrualPeriod();
            arguments->yoySpreads[i] = coupon->spread();
            try {
                arguments->yoyCoupons[i] = coupon->amount();
            } catch (Error&) {
                arguments->yoyCoupons[i] = Null<Real>();
            }
        }
    }


    Rate YearOnYearInflationSwap::fairRate() const {
        calculate();
        QL_REQUIRE(fairRate_ != Null<Rate>(), "result not available");
        return fairRate_;
    }

    Spread YearOnYearInflationSwap::fairSpread() const {
        calculate();
        QL_REQUIRE(fairSpread_ != Null<Spread>(), "result not available");
        return fairSpread_;
    }


    Real YearOnYearInflationSwap::fixedLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[0] != Null<Real>(), "result not available");
        return legNPV_[0];
    }

    Real YearOnYearInflationSwap::yoyLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[1] != Null<Real>(), "result not available");
        return legNPV_[1];
    }

    void YearOnYearInflationSwap::setupExpired() const {
        Swap::setupExpired();
        legBPS_[0] = legBPS_[1] = 0.0;
        fairRate_ = Null<Rate>();
        fairSpread_ = Null<Spread>();
    }

    void YearOnYearInflationSwap::fetchResults(const PricingEngine::results* r) const {
        static const Spread basisPoint = 1.0e-4;

        // copy from VanillaSwap
        // works because similarly simple instrument
        // that we always expect to be priced with a swap engine

        Swap::fetchResults(r);

        const auto* results = dynamic_cast<const YearOnYearInflationSwap::results*>(r);
        if (results != nullptr) { // might be a swap engine, so no error is thrown
            fairRate_ = results->fairRate;
            fairSpread_ = results->fairSpread;
        } else {
            fairRate_ = Null<Rate>();
            fairSpread_ = Null<Spread>();
        }

        if (fairRate_ == Null<Rate>()) {
            // calculate it from other results
            if (legBPS_[0] != Null<Real>())
                fairRate_ = fixedRate_ - NPV_/(legBPS_[0]/basisPoint);
        }
        if (fairSpread_ == Null<Spread>()) {
            // ditto
            if (legBPS_[1] != Null<Real>())
                fairSpread_ = spread_ - NPV_/(legBPS_[1]/basisPoint);
        }

    }

    void YearOnYearInflationSwap::arguments::validate() const {
        Swap::arguments::validate();
        QL_REQUIRE(nominal != Null<Real>(), "nominal null or not set");
        QL_REQUIRE(fixedResetDates.size() == fixedPayDates.size(),
                   "number of fixed start dates different from "
                   "number of fixed payment dates");
        QL_REQUIRE(fixedPayDates.size() == fixedCoupons.size(),
                   "number of fixed payment dates different from "
                   "number of fixed coupon amounts");
        QL_REQUIRE(yoyResetDates.size() == yoyPayDates.size(),
                   "number of yoy start dates different from "
                   "number of yoy payment dates");
        QL_REQUIRE(yoyFixingDates.size() == yoyPayDates.size(),
                   "number of yoy fixing dates different from "
                   "number of yoy payment dates");
        QL_REQUIRE(yoyAccrualTimes.size() == yoyPayDates.size(),
                   "number of yoy accrual Times different from "
                   "number of yoy payment dates");
        QL_REQUIRE(yoySpreads.size() == yoyPayDates.size(),
                   "number of yoy spreads different from "
                   "number of yoy payment dates");
        QL_REQUIRE(yoyPayDates.size() == yoyCoupons.size(),
                   "number of yoy payment dates different from "
                   "number of yoy coupon amounts");
    }

    void YearOnYearInflationSwap::results::reset() {
        Swap::results::reset();
        fairRate = Null<Rate>();
        fairSpread = Null<Spread>();
    }

}

]]></document_content>
  </document>
  <document index="127">
    <source>yearonyearinflationswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 Chris Kenyon
 Copyright (C) 2009 StatPro Italia srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

/*! \file yearonyearinflationswap.hpp
 \brief Year-on-year inflation-indexed swap
 */

#ifndef quantlib_yyiis_hpp
#define quantlib_yyiis_hpp

#include <ql/instruments/swap.hpp>
#include <ql/time/calendar.hpp>
#include <ql/time/daycounter.hpp>
#include <ql/time/schedule.hpp>

namespace QuantLib {
    class YoYInflationIndex;

    //! Year-on-year inflation-indexed swap
    /*! Quoted as a fixed rate \f$ K \f$.  At start:
        \f[
        \sum_{i=1}^{M} P_n(0,t_i) N K =
        \sum_{i=1}^{M} P_n(0,t_i) N \left[ \frac{I(t_i)}{I(t_i-1)} - 1 \right]
        \f]
        where \f$ t_M \f$ is the maturity time, \f$ P_n(0,t) \f$ is the
        nominal discount factor at time \f$ t \f$, \f$ N \f$ is the
        notional, and \f$ I(t) \f$ is the inflation index value at
        time \f$ t \f$.
    */
    class YearOnYearInflationSwap : public Swap {
    public:
        class arguments;
        class results;
        class engine;
        YearOnYearInflationSwap(
            Type type,
            Real nominal,
            Schedule fixedSchedule,
            Rate fixedRate,
            DayCounter fixedDayCount,
            Schedule yoySchedule,
            ext::shared_ptr<YoYInflationIndex> yoyIndex,
            const Period& observationLag,
            Spread spread,
            DayCounter yoyDayCount,
            Calendar paymentCalendar, // inflation index does not have a calendar
            BusinessDayConvention paymentConvention = ModifiedFollowing);
        // results
        virtual Real fixedLegNPV() const;
        virtual Rate fairRate() const;

        virtual Real yoyLegNPV() const;
        virtual Spread fairSpread() const;
        // inspectors
        virtual Type type() const;
        virtual Real nominal() const;

        virtual const Schedule& fixedSchedule() const;
        virtual Rate fixedRate() const;
        virtual const DayCounter& fixedDayCount() const;

        virtual const Schedule& yoySchedule() const;
        virtual const ext::shared_ptr<YoYInflationIndex>& yoyInflationIndex() const;
        virtual Period observationLag() const { return observationLag_; }
        virtual Spread spread() const;
        virtual const DayCounter& yoyDayCount() const;

        virtual Calendar paymentCalendar() const { return paymentCalendar_; }
        virtual BusinessDayConvention paymentConvention() const;

        virtual const Leg& fixedLeg() const;
        virtual const Leg& yoyLeg() const;

        // other
        void setupArguments(PricingEngine::arguments* args) const override;
        void fetchResults(const PricingEngine::results*) const override;
        ~YearOnYearInflationSwap() override = default;

      private:
        void setupExpired() const override;
        Type type_;
        Real nominal_;
        Schedule fixedSchedule_;
        Rate fixedRate_;
        DayCounter fixedDayCount_;
        Schedule yoySchedule_;
        ext::shared_ptr<YoYInflationIndex> yoyIndex_;
        Period observationLag_;
        Spread spread_;
        DayCounter yoyDayCount_;
        Calendar paymentCalendar_;
        BusinessDayConvention paymentConvention_;
        // results
        mutable Rate fairRate_;
        mutable Spread fairSpread_;
    };


    //! %Arguments for YoY swap calculation
    class YearOnYearInflationSwap::arguments : public Swap::arguments {
    public:
      arguments() : nominal(Null<Real>()) {}
      Type type = Receiver;
      Real nominal;

      std::vector<Date> fixedResetDates;
      std::vector<Date> fixedPayDates;
      std::vector<Time> yoyAccrualTimes;
      std::vector<Date> yoyResetDates;
      std::vector<Date> yoyFixingDates;
      std::vector<Date> yoyPayDates;

      std::vector<Real> fixedCoupons;
      std::vector<Spread> yoySpreads;
      std::vector<Real> yoyCoupons;
      void validate() const override;
    };

    //! %Results from YoY swap calculation
    class YearOnYearInflationSwap::results : public Swap::results {
    public:
        Rate fairRate;
        Spread fairSpread;
        void reset() override;
    };

    class YearOnYearInflationSwap::engine : public GenericEngine<YearOnYearInflationSwap::arguments,
    YearOnYearInflationSwap::results> {};


    // inline definitions

    inline Swap::Type YearOnYearInflationSwap::type() const {
        return type_;
    }

    inline Real YearOnYearInflationSwap::nominal() const {
        return nominal_;
    }

    inline const Schedule& YearOnYearInflationSwap::fixedSchedule() const {
        return fixedSchedule_;
    }

    inline Rate YearOnYearInflationSwap::fixedRate() const {
        return fixedRate_;
    }

    inline const DayCounter& YearOnYearInflationSwap::fixedDayCount() const {
        return fixedDayCount_;
    }

    inline const Schedule& YearOnYearInflationSwap::yoySchedule() const {
        return yoySchedule_;
    }

    inline const ext::shared_ptr<YoYInflationIndex>& YearOnYearInflationSwap::yoyInflationIndex() const {
        return yoyIndex_;
    }

    inline Spread YearOnYearInflationSwap::spread() const {
        return spread_;
    }

    inline const DayCounter& YearOnYearInflationSwap::yoyDayCount() const {
        return yoyDayCount_;
    }

    inline BusinessDayConvention YearOnYearInflationSwap::paymentConvention() const {
        return paymentConvention_;
    }

    inline const Leg& YearOnYearInflationSwap::fixedLeg() const {
        return legs_[0];
    }

    inline const Leg& YearOnYearInflationSwap::yoyLeg() const {
        return legs_[1];
    }

}

#endif

]]></document_content>
  </document>
  <document index="128">
    <source>zerocouponinflationswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 Chris Kenyon
 Copyright (C) 2009 StatPro Italia srl
 Copyright (C) 2021 Ralf Konrad Eckel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/cashflows/zeroinflationcashflow.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/instruments/zerocouponinflationswap.hpp>
#include <ql/time/calendars/nullcalendar.hpp>
#include <utility>

namespace QuantLib {

    /* Generally inflation indices are available with a lag of 1month
       and then observed with a lag of 2-3 months depending whether
       they use an interpolated fixing or not.  Here, we make the
       swap use the interpolation of the index to avoid incompatibilities.
    */
    ZeroCouponInflationSwap::ZeroCouponInflationSwap(
        Type type,
        Real nominal,
        const Date& startDate, // start date of contract (only)
        const Date& maturity,  // this is pre-adjustment!
        Calendar fixCalendar,
        BusinessDayConvention fixConvention,
        DayCounter dayCounter,
        Rate fixedRate,
        const ext::shared_ptr<ZeroInflationIndex>& infIndex,
        const Period& observationLag,
        CPI::InterpolationType observationInterpolation,
        bool adjustInfObsDates,
        Calendar infCalendar,
        BusinessDayConvention infConvention)
    : Swap(2), type_(type), nominal_(nominal), startDate_(startDate), maturityDate_(maturity),
      fixCalendar_(std::move(fixCalendar)), fixConvention_(fixConvention), fixedRate_(fixedRate),
      infIndex_(infIndex), observationLag_(observationLag),
      observationInterpolation_(observationInterpolation), adjustInfObsDates_(adjustInfObsDates),
      infCalendar_(std::move(infCalendar)), infConvention_(infConvention),
      dayCounter_(std::move(dayCounter)) {
        // first check compatibility of index and swap definitions
        if (detail::CPI::effectiveInterpolationType(infIndex_, observationInterpolation_) == CPI::Linear) {
            Period pShift(infIndex_->frequency());
            QL_REQUIRE(observationLag_ - pShift >= infIndex_->availabilityLag(),
                       "inconsistency between swap observation lag "
                           << observationLag_ << ", interpolated index period "
                           << pShift << " and index availability " << infIndex_->availabilityLag()
                           << ": need (obsLag-index period) >= availLag");
        } else {
            QL_REQUIRE(infIndex_->availabilityLag() < observationLag_,
                       "index tries to observe inflation fixings that do not yet exist: "
                           << " availability lag " << infIndex_->availabilityLag()
                           << " versus obs lag = " << observationLag_);
        }

        if (infCalendar_ == Calendar())
            infCalendar_ = fixCalendar_;
        if (infConvention_ == BusinessDayConvention())
            infConvention_ = fixConvention_;

        Date infPayDate = infCalendar_.adjust(maturity, infConvention_);
        Date fixedPayDate = fixCalendar_.adjust(maturity, fixConvention_);

        bool growthOnly = true;

        auto inflationCashFlow =
            ext::make_shared<ZeroInflationCashFlow>(nominal, infIndex, observationInterpolation_,
                                                    startDate, maturity, observationLag_,
                                                    adjustInfObsDates_ ? infCalendar_ : NullCalendar(),
                                                    infConvention, infPayDate, growthOnly);

        baseDate_ = inflationCashFlow->baseDate();
        obsDate_ = inflationCashFlow->fixingDate();

        // At this point the index may not be able to forecast
        // i.e. do not want to force the existence of an inflation
        // term structure before allowing users to create instruments.
        Real T =
            inflationYearFraction(infIndex_->frequency(),
                                  detail::CPI::isInterpolated(infIndex_, observationInterpolation_),
                                  dayCounter_, baseDate_, obsDate_);
        // N.B. the -1.0 is because swaps only exchange growth, not notionals as well
        Real fixedAmount = nominal * (std::pow(1.0 + fixedRate, T) - 1.0);

        auto fixedCashFlow = ext::make_shared<SimpleCashFlow>(fixedAmount, fixedPayDate);

        legs_[0].push_back(fixedCashFlow);
        legs_[1].push_back(inflationCashFlow);

        registerWith(inflationCashFlow);

        switch (type_) {
            case Payer:
                payer_[0] = +1.0;
                payer_[1] = -1.0;
                break;
            case Receiver:
                payer_[0] = -1.0;
                payer_[1] = +1.0;
                break;
            default:
                QL_FAIL("Unknown zero-inflation-swap type");
        }
    }

    ZeroCouponInflationSwap::ZeroCouponInflationSwap(
        Type type,
        Real nominal,
        const Date& startDate,
        const Date& maturity,
        Calendar fixCalendar,
        BusinessDayConvention fixConvention,
        DayCounter dayCounter,
        Rate fixedRate,
        const ext::shared_ptr<ZeroInflationIndex>& infIndex,
        const Period& observationLag,
        bool adjustInfObsDates,
        Calendar infCalendar,
        BusinessDayConvention infConvention)
    : ZeroCouponInflationSwap(type,
                              nominal,
                              startDate,
                              maturity,
                              std::move(fixCalendar),
                              fixConvention,
                              std::move(dayCounter),
                              fixedRate,
                              infIndex,
                              observationLag,
                              CPI::AsIndex,
                              adjustInfObsDates,
                              std::move(infCalendar),
                              infConvention) {}


    void ZeroCouponInflationSwap::setupArguments(PricingEngine::arguments* args) const {
        Swap::setupArguments(args);
        // you don't actually need to do anything else because it is so simple
    }

    void ZeroCouponInflationSwap::arguments::validate() const {
        Swap::arguments::validate();
        // you don't actually need to do anything else because it is so simple
    }

    void ZeroCouponInflationSwap::fetchResults(const PricingEngine::results* r) const {
        Swap::fetchResults(r);
        // you don't actually need to do anything else because it is so simple
    }

    Real ZeroCouponInflationSwap::fairRate() const {
        // What does this mean before or after trade date?
        // Always means that NPV is zero for _this_ instrument
        // if it was created with _this_ rate
        // _knowing_ the time from base to obs (etc).

        ext::shared_ptr<IndexedCashFlow> icf =
        ext::dynamic_pointer_cast<IndexedCashFlow>(legs_[1].at(0));
        QL_REQUIRE(icf,"failed to downcast to IndexedCashFlow in ::fairRate()");

        // +1 because the IndexedCashFlow has growthOnly=true
        Real growth = icf->amount() / icf->notional() + 1.0;
        Real T =
            inflationYearFraction(infIndex_->frequency(),
                                  detail::CPI::isInterpolated(infIndex_, observationInterpolation_),
                                  dayCounter_, baseDate_, obsDate_);

        return std::pow(growth,1.0/T) - 1.0;

        // we cannot use this simple definition because
        // it does not work for already-issued instruments
        // return infIndex_->zeroInflationTermStructure()->zeroRate(
        //      maturityDate(), observationLag(), infIndex_->interpolated());
    }


    Real ZeroCouponInflationSwap::fixedLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[0] != Null<Real>(), "result not available");
        return legNPV_[0];
    }

    Real ZeroCouponInflationSwap::inflationLegNPV() const {
        calculate();
        QL_REQUIRE(legNPV_[1] != Null<Real>(), "result not available");
        return legNPV_[1];
    }

    const Leg& ZeroCouponInflationSwap::fixedLeg() const {
        return legs_[0];
    }

    const Leg& ZeroCouponInflationSwap::inflationLeg() const {
        return legs_[1];
    }

}
]]></document_content>
  </document>
  <document index="129">
    <source>zerocouponinflationswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2007, 2009 Chris Kenyon
 Copyright (C) 2009 StatPro Italia srl
 Copyright (C) 2021 Ralf Konrad Eckel

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

/*! \file zerocouponinflationswap.hpp
 \brief Zero-coupon inflation-indexed swap
 */

#ifndef quantlib_xxxzciis_hpp
#define quantlib_xxxzciis_hpp

#include <ql/indexes/inflationindex.hpp>
#include <ql/instruments/swap.hpp>
#include <ql/time/calendar.hpp>
#include <ql/time/daycounter.hpp>


namespace QuantLib {
    //! Zero-coupon inflation-indexed swap
    /*! Quoted as a fixed rate \f$ K \f$.  At start:
        \f[
        P_n(0,T) N [(1+K)^{T}-1] =
        P_n(0,T) N \left[ \frac{I(T)}{I(0)} -1 \right]
        \f]
        where \f$ T \f$ is the maturity time, \f$ P_n(0,t) \f$ is the
        nominal discount factor at time \f$ t \f$, \f$ N \f$ is the
        notional, and \f$ I(t) \f$ is the inflation index value at
        time \f$ t \f$.

        This inherits from swap and has two very simple legs: a fixed
        leg, from the quote (K); and an indexed leg.  At maturity the
        two single cashflows are swapped.  These are the notional
        versus the inflation-indexed notional Because the coupons are
        zero there are no accruals (and no coupons).

        In this swap, the passed type (Payer or Receiver) refers to
        the inflation leg.

        Inflation is generally available on every day, including
        holidays and weekends.  Hence there is a variable to state
        whether the observe/fix dates for inflation are adjusted or
        not.  The default is not to adjust.

        A zero inflation swap is a simple enough instrument that the
        standard discounting pricing engine that works for a vanilla
        swap also works.

        \note we do not need Schedules on the legs because they use
              one or two dates only per leg.
    */
    class ZeroCouponInflationSwap : public Swap {
      public:
        class arguments;
        class engine;

        ZeroCouponInflationSwap(Type type,
                                Real nominal,
                                const Date& startDate, // start date of contract (only)
                                const Date& maturity,  // this is pre-adjustment!
                                Calendar fixCalendar,
                                BusinessDayConvention fixConvention,
                                DayCounter dayCounter,
                                Rate fixedRate,
                                const ext::shared_ptr<ZeroInflationIndex>& infIndex,
                                const Period& observationLag,
                                CPI::InterpolationType observationInterpolation,
                                bool adjustInfObsDates = false,
                                Calendar infCalendar = Calendar(),
                                BusinessDayConvention infConvention = BusinessDayConvention());

        /*! \deprecated Use the other constructor.

            Deprecated in version 1.23.
        */
        QL_DEPRECATED
        ZeroCouponInflationSwap(Type type,
                                Real nominal,
                                const Date& startDate, // start date of contract (only)
                                const Date& maturity,  // this is pre-adjustment!
                                Calendar fixCalendar,
                                BusinessDayConvention fixConvention,
                                DayCounter dayCounter,
                                Rate fixedRate,
                                const ext::shared_ptr<ZeroInflationIndex>& infIndex,
                                const Period& observationLag,
                                bool adjustInfObsDates = false,
                                Calendar infCalendar = Calendar(),
                                BusinessDayConvention infConvention = BusinessDayConvention());

        //! \name Inspectors
        //@{
        //! "Payer" or "Receiver" refers to the inflation leg
        Type type() const { return type_; }
        Real nominal() const { return nominal_; }
        Date startDate() const { return startDate_; }
        Date maturityDate() const { return maturityDate_; }
        Calendar fixedCalendar() const { return fixCalendar_; }
        BusinessDayConvention fixedConvention() const {
            return fixConvention_;
        }
        DayCounter dayCounter() const { return dayCounter_; }
        //! \f$ K \f$ in the above formula.
        Rate fixedRate() const { return fixedRate_; }
        ext::shared_ptr<ZeroInflationIndex> inflationIndex() const {
            return infIndex_;
        }
        Period observationLag() const { return observationLag_; }
        CPI::InterpolationType observationInterpolation() const {
            return observationInterpolation_;
        }
        bool adjustObservationDates() const { return adjustInfObsDates_; }
        Calendar inflationCalendar() const { return infCalendar_; }
        BusinessDayConvention inflationConvention() const {
            return infConvention_;
        }
        //! just one cashflow (that is not a coupon) in each leg
        const Leg& fixedLeg() const;
        //! just one cashflow (that is not a coupon) in each leg
        const Leg& inflationLeg() const;
        //@}

        //! \name Instrument interface
        //@{
        void setupArguments(PricingEngine::arguments*) const override;
        void fetchResults(const PricingEngine::results* r) const override;
        //@}

        //! \name Results
        //@{
        Real fixedLegNPV() const;
        Real inflationLegNPV() const;
        Real fairRate() const;
        //@}

      protected:
        Type type_;
        Real nominal_;
        Date startDate_, maturityDate_;
        Calendar fixCalendar_;
        BusinessDayConvention fixConvention_;
        Rate fixedRate_;
        ext::shared_ptr<ZeroInflationIndex> infIndex_;
        Period observationLag_;
        CPI::InterpolationType observationInterpolation_;
        bool adjustInfObsDates_;
        Calendar infCalendar_;
        BusinessDayConvention infConvention_;
        DayCounter dayCounter_;
        Date baseDate_, obsDate_;
    };


    class ZeroCouponInflationSwap::arguments : public Swap::arguments {
      public:
        Rate fixedRate;
        void validate() const override;
    };


    class ZeroCouponInflationSwap::engine
    : public GenericEngine<ZeroCouponInflationSwap::arguments,
    ZeroCouponInflationSwap::results> {};

}


#endif
]]></document_content>
  </document>
  <document index="130">
    <source>zerocouponswap.cpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/cashflows/fixedratecoupon.hpp>
#include <ql/cashflows/simplecashflow.hpp>
#include <ql/cashflows/subperiodcoupon.hpp>
#include <ql/indexes/iborindex.hpp>
#include <ql/instruments/zerocouponswap.hpp>
#include <utility>

namespace QuantLib {

    namespace {       
        ext::shared_ptr<CashFlow>
        compoundedSubPeriodicCoupon(const Date& paymentDate,
                                    const Date& startDate,
                                    const Date& maturityDate,
                                    Real nominal,
                                    const ext::shared_ptr<IborIndex>& index) {
            auto floatCpn = ext::make_shared<SubPeriodsCoupon>(
                paymentDate, nominal, startDate, maturityDate, index->fixingDays(), index);
            floatCpn->setPricer(
                ext::shared_ptr<FloatingRateCouponPricer>(new CompoundingRatePricer));
            return floatCpn;
        }
    }

    ZeroCouponSwap::ZeroCouponSwap(Type type,
                                   Real baseNominal,
                                   const Date& startDate,
                                   const Date& maturityDate,
                                   ext::shared_ptr<IborIndex> iborIndex,
                                   const Calendar& paymentCalendar,
                                   BusinessDayConvention paymentConvention,
                                   Natural paymentDelay)
    : Swap(2), type_(type), baseNominal_(baseNominal), iborIndex_(std::move(iborIndex)), 
      startDate_(startDate), maturityDate_(maturityDate) {

        QL_REQUIRE(!(baseNominal < 0.0), "base nominal cannot be negative");
        QL_REQUIRE(startDate < maturityDate,
                   "start date (" << startDate 
                   << ") later than or equal to maturity date ("
                   << maturityDate << ")");

        paymentDate_ = paymentCalendar.advance(maturityDate, paymentDelay, Days, paymentConvention);

        legs_[1].push_back(compoundedSubPeriodicCoupon(paymentDate_, startDate, maturityDate,
                                                       baseNominal_, iborIndex_));
        for (Leg::const_iterator i = legs_[1].begin(); i < legs_[1].end(); ++i)
            registerWith(*i);

        switch (type_) {
            case Payer:
                payer_[0] = -1.0;
                payer_[1] = +1.0;
                break;
            case Receiver:
                payer_[0] = +1.0;
                payer_[1] = -1.0;
                break;
            default:
                QL_FAIL("unknown zero coupon swap type");
        }
    }

    ZeroCouponSwap::ZeroCouponSwap(Type type,
                                   Real baseNominal,
                                   const Date& startDate,
                                   const Date& maturityDate,
                                   Real fixedPayment,
                                   ext::shared_ptr<IborIndex> iborIndex,
                                   const Calendar& paymentCalendar,
                                   BusinessDayConvention paymentConvention,
                                   Natural paymentDelay)
    : ZeroCouponSwap(type,
                     baseNominal,
                     startDate,
                     maturityDate,
                     std::move(iborIndex),
                     paymentCalendar,
                     paymentConvention,
                     paymentDelay) {

        legs_[0].push_back(
            ext::shared_ptr<CashFlow>(new SimpleCashFlow(fixedPayment, paymentDate_)));
    }

    ZeroCouponSwap::ZeroCouponSwap(Type type,
                                   Real baseNominal,
                                   const Date& startDate,
                                   const Date& maturityDate,
                                   Rate fixedRate,
                                   const DayCounter& fixedDayCounter,
                                   ext::shared_ptr<IborIndex> iborIndex,
                                   const Calendar& paymentCalendar,
                                   BusinessDayConvention paymentConvention,
                                   Natural paymentDelay)
    : ZeroCouponSwap(type,
                     baseNominal,
                     startDate,
                     maturityDate,
                     std::move(iborIndex),
                     paymentCalendar,
                     paymentConvention,
                     paymentDelay) {

        InterestRate interest(fixedRate, fixedDayCounter, Compounded, Annual);
        legs_[0].push_back(ext::shared_ptr<CashFlow>(
            new FixedRateCoupon(paymentDate_, baseNominal_, interest, startDate, maturityDate)));
    }

    Real ZeroCouponSwap::fixedLegNPV() const {
        return legNPV(0);
    }

    Real ZeroCouponSwap::floatingLegNPV() const {
        return legNPV(1);
    }

    Real ZeroCouponSwap::fairFixedPayment() const {
        // Knowing that for the fair payment NPV = 0.0, where:
        // NPV = (discount at fixed amount pay date) * (payer\receiver * fixed amount)
        //     + (discount at float amount pay date) * (-payer\receiver * float amount)
        // we have:
        // fair amount = NPV float / discount at fixed amount pay date
        // with NPV float corrected for the payer sign.
        Real scaling = payer(1) ? -1.0 : 1.0;
        return floatingLegNPV() / (endDiscounts(0) * scaling);
    }

    Rate ZeroCouponSwap::fairFixedRate(const DayCounter& dayCounter) const {
        // Given the relation between the fixed payment (N^FIX) and the fixed rate (R),
        // N^FIX = N * [(1 + R)^T - 1],
        // the compound factor C = (1 + R)^T
        // can be equivalently expressed as:
        // C = N^FIX / N + 1
        Real compound = fairFixedPayment() / baseNominal_ + 1.0;
        return InterestRate::impliedRate(compound, dayCounter, Compounded, Annual, startDate_,
                                         maturityDate_);
    }

    const Leg& ZeroCouponSwap::fixedLeg() const { return leg(0); }

    const Leg& ZeroCouponSwap::floatingLeg() const { return leg(1); }

    Real ZeroCouponSwap::fixedPayment() const { return fixedLeg()[0]->amount(); }
}
]]></document_content>
  </document>
  <document index="131">
    <source>zerocouponswap.hpp</source>
    <document_content><![CDATA[/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2021 Marcin Rybacki

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

/*! \file zerocouponswap.hpp
 \brief Zero-coupon interest rate swap
 */

#ifndef quantlib_zerocouponswap_hpp
#define quantlib_zerocouponswap_hpp

#include <ql/instruments/swap.hpp>
#include <ql/time/calendar.hpp>
#include <ql/time/daycounter.hpp>

namespace QuantLib {
    class IborIndex;

    //! Zero-coupon interest rate swap
    /*! Quoted in terms of a known fixed cash flow \f$ N^{FIX} \f$ or
        a fixed rate \f$ R \f$, where:
        \f[
        N^{FIX} = N \left[ (1+R)^{\alpha(T_{0}, T_{K})}-1 \right] ,
        \f]
        with \f$ \alpha(T_{0}, T_{K}) \f$ being the time fraction
        between the start date of the contract \f$ T_{0} \f$ and
        the end date \f$ T_{K} \f$ - according to a given day count
        convention. \f$ N \f$ is the base notional amount prior to
        compounding.
        The floating leg also pays a single cash flow \f$ N^{FLT} \f$,
        which value is determined by periodically averaging (e.g. every
        6 months) interest rate index fixings.
        Assuming the use of compounded averaging the projected value of
        the floating leg becomes:
        \f[
        N^{FLT} = N \left[ \prod_{k=0}^{K-1} (1+\alpha(T_{k},T_{k+1})
                           L(T_{k},T_{k+1})) -1 \right],
        \f]
        where \f$ L(T_{i}, T_{j})) \f$ are interest rate index fixings
        for accrual period \f$ [T_{i}, T_{j}] \f$.
        For a par contract, it holds that:
        \f[
        P_n(0,T) N^{FIX} = P_n(0,T) N^{FLT}
        \f]
        where \f$ T \f$ is the final payment time, \f$ P_n(0,t) \f$
        is the nominal discount factor at time \f$ t \f$.

        At maturity the two single cashflows are swapped.

        \note we do not need Schedules on the legs because they use
              one or two dates only per leg. Those dates are not
              adjusted for potential non-business days. Only the
              payment date is subject to adjustment.
    */

    class ZeroCouponSwap : public Swap {
      public:
        ZeroCouponSwap(Type type,
                       Real baseNominal,
                       const Date& startDate,
                       const Date& maturityDate,
                       Real fixedPayment,
                       ext::shared_ptr<IborIndex> iborIndex,
                       const Calendar& paymentCalendar,
                       BusinessDayConvention paymentConvention = Following,
                       Natural paymentDelay = 0);

        ZeroCouponSwap(Type type,
                       Real baseNominal,
                       const Date& startDate,
                       const Date& maturityDate,
                       Rate fixedRate,
                       const DayCounter& fixedDayCounter,
                       ext::shared_ptr<IborIndex> iborIndex,
                       const Calendar& paymentCalendar,
                       BusinessDayConvention paymentConvention = Following,
                       Natural paymentDelay = 0);

        //! \name Inspectors
        //@{
        //! "payer" or "receiver" refer to the fixed leg.
        Type type() const { return type_; }
        Real baseNominal() const { return baseNominal_; }
        Date startDate() const { return startDate_; }
        Date maturityDate() const { return maturityDate_; }
        const ext::shared_ptr<IborIndex>& iborIndex() const { return iborIndex_; }

        //! just one cashflow in each leg
        const Leg& fixedLeg() const;
        //! just one cashflow in each leg
        const Leg& floatingLeg() const;

        Real fixedPayment() const;
        //@}

        //! \name Results
        //@{
        Real fixedLegNPV() const;
        Real floatingLegNPV() const;
        Real fairFixedPayment() const;
        Rate fairFixedRate(const DayCounter& dayCounter) const;
        //@}

      private:
        ZeroCouponSwap(Type type,
                       Real baseNominal,
                       const Date& startDate,
                       const Date& maturityDate,
                       ext::shared_ptr<IborIndex> iborIndex,
                       const Calendar& paymentCalendar,
                       BusinessDayConvention paymentConvention,
                       Natural paymentDelay);

        Type type_;
        Real baseNominal_;
        ext::shared_ptr<IborIndex> iborIndex_;
        Date startDate_;
        Date maturityDate_;
        Date paymentDate_;
    };
}

#endif
]]></document_content>
  </document>
</documents>